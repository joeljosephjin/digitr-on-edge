/*! For license information please see bundle.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}(self,(()=>(()=>{var e={122:(e,t,n)=>{"use strict";var r,a,i,o,s,u,l,d,c,p,f,h,m,g,y,w,$,v,b,x,S,_,C,E,I,A,O,T,R="/index.js",k=Object.defineProperty,B=Object.getOwnPropertyDescriptor,M=Object.getOwnPropertyNames,D=Object.prototype.hasOwnProperty,P=(e,t)=>()=>(e&&(t=e(e=0)),t),z=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),W=(e,t)=>{for(var n in t)k(e,n,{get:t[n],enumerable:!0})},N=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let n of M(t))!D.call(e,n)&&undefined!==n&&k(e,n,{get:()=>t[n],enumerable:!(r=B(t,n))||r.enumerable});return e})(k({},"__esModule",{value:!0}),e),G=P((()=>{a=new Map,i=[],o=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=a.get(e);if(void 0===r)a.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=i.indexOf(e);-1!==t&&i.splice(t,1);for(let t=0;t<i.length;t++)if(a.get(i[t]).priority<=n)return void i.splice(t,0,e);i.push(e)}}},s=async e=>{let t=0===e.length?i:e,n=[];for(let e of t){let t=a.get(e);if(t){if(t.initialized)return t.backend;if(t.aborted)continue;let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(a){r||n.push({name:e,err:a}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)}})),U=P((()=>{G()})),V=P((()=>{u="1.17.0-dev.20231103-1439da36fe"})),j=P((()=>{V(),l="warning",d={wasm:{},webgl:{},webgpu:{},versions:{common:u},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);l=e}},get logLevel(){return l}},Object.defineProperty(d,"logLevel",{enumerable:!0})})),F=P((()=>{j(),c=d})),H=P((()=>{p=(e,t)=>{let n=document.createElement("canvas");n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[3]):(a=e.dims[3],i=e.dims[2]);let o,s,u=void 0!==t?.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?o=[255,255,255,255]:"number"==typeof l.mean?o=[l.mean,l.mean,l.mean,l.mean]:(o=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(o[3]=l.mean[3])),void 0===l||void 0===l.bias?s=[0,0,0,0]:"number"==typeof l.bias?s=[l.bias,l.bias,l.bias,l.bias]:(s=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(s[3]=l.bias[3]));let d=i*a,c=0,p=d,f=2*d,h=-1;"RGBA"===u?(c=0,p=d,f=2*d,h=3*d):"RGB"===u?(c=0,p=d,f=2*d):"RBG"===u&&(c=0,f=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<a;n++){let a=(e.data[c++]-s[0])*o[0],i=(e.data[p++]-s[1])*o[1],u=(e.data[f++]-s[2])*o[2],l=-1===h?255:(e.data[h++]-s[3])*o[3];r.fillStyle="rgba("+a+","+i+","+u+","+l+")",r.fillRect(n,t,1,1)}return n.toDataURL()}throw new Error("Can not access image data")},f=(e,t)=>{let n,r=document.createElement("canvas").getContext("2d");if(null==r)throw new Error("Can not access image data");{let a,i,o;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[1],o=e.dims[3]):(a=e.dims[3],i=e.dims[2],o=e.dims[1]);let s,u,l=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?s=[255,255,255,255]:"number"==typeof d.mean?s=[d.mean,d.mean,d.mean,d.mean]:(s=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(s[3]=d.mean[3])),void 0===d||void 0===d.bias?u=[0,0,0,0]:"number"==typeof d.bias?u=[d.bias,d.bias,d.bias,d.bias]:(u=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(u[3]=d.bias[3]));let c=i*a;if(void 0!==t&&(void 0!==t.format&&4===o&&"RGBA"!==t.format||3===o&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let p=4,f=0,h=1,m=2,g=3,y=0,w=c,$=2*c,v=-1;"RGBA"===l?(y=0,w=c,$=2*c,v=3*c):"RGB"===l?(y=0,w=c,$=2*c):"RBG"===l&&(y=0,$=c,w=2*c),n=r.createImageData(a,i);for(let t=0;t<i*a;f+=p,h+=p,m+=p,g+=p,t++)n.data[f]=(e.data[y++]-u[0])*s[0],n.data[h]=(e.data[w++]-u[1])*s[1],n.data[m]=(e.data[$++]-u[2])*s[2],n.data[g]=-1===v?255:(e.data[v++]-u[3])*s[3]}return n}})),L=P((()=>{K(),h=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:a,width:i}=t,o=t.norm??{mean:255,bias:0};n="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],r="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=a*i,d="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l),c=4,p=0,f=1,h=2,m=3,g=0,y=l,w=2*l,$=-1;"RGB"===s&&(c=3,p=0,f=1,h=2,m=-1),"RGBA"===u?$=3*l:"RBG"===u?(g=0,w=l,y=2*l):"BGR"===u&&(w=0,y=l,g=2*l);for(let t=0;t<l;t++,p+=c,h+=c,f+=c,m+=c)d[g++]=(e[p]+r[0])/n[0],d[y++]=(e[f]+r[1])/n[1],d[w++]=(e[h]+r[2])/n[2],-1!==$&&-1!==m&&(d[$++]=(e[m]+r[3])/n[3]);return new C("float32",d,"RGBA"===u?[1,4,a,i]:[1,3,a,i])},m=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,o="string"==typeof e,s=t??{};if(r){let r=document.createElement("canvas");r.width=e.width,r.height=e.height;let a=r.getContext("2d");if(null==a)throw new Error("Can not access image data");{let r=e.height,i=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=r,s.width=i}else s.tensorFormat="RGBA",s.height=r,s.width=i;a.drawImage(e,0,0),n=a.getImageData(0,0,i,r).data}}else{if(!a){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=document.createElement("canvas");r.width=e.width,r.height=e.height;let a=r.getContext("2d");if(null!=a){let t=e.height,r=e.width;return a.drawImage(e,0,0,r,t),n=a.getImageData(0,0,r,t).data,s.height=t,s.width=r,h(n,s)}throw new Error("Can not access image data")}if(o)return new Promise(((t,n)=>{let r=document.createElement("canvas"),a=r.getContext("2d");if(!e||!a)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,a.drawImage(i,0,0,r.width,r.height);let e=a.getImageData(0,0,r.width,r.height);s.height=r.height,s.width=r.width,t(h(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,a;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,a=t.resizedWidth):(r=e.height,a=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=r,s.width=a,void 0!==t){let t=document.createElement("canvas");t.width=a,t.height=r;let i=t.getContext("2d");if(null==i)throw new Error("Can not access image data");i.putImageData(e,0,0),n=i.getImageData(0,0,a,r).data}else n=e.data}}if(void 0!==n)return h(n,s);throw new Error("Input data provided is not supported - aborted tensor creation")},g=(e,t)=>{let{width:n,height:r,download:a,dispose:i}=t;return new C({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:a,dispose:i})},y=(e,t)=>{let{dataType:n,dims:r,download:a,dispose:i}=t;return new C({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:a,dispose:i})},w=(e,t,n)=>new C({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),q=P((()=>{$=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),v=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),b=!1,x=()=>{if(!b){b=!0;let e=typeof BigInt64Array<"u"&&"function"==typeof BigInt64Array.from,t=typeof BigUint64Array<"u"&&"function"==typeof BigUint64Array.from;e&&($.set("int64",BigInt64Array),v.set(BigInt64Array,"int64")),t&&($.set("uint64",BigUint64Array),v.set(BigUint64Array,"uint64"))}}})),Y=P((()=>{K(),S=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},_=(e,t)=>{switch(e.location){case"cpu":return new C(e.type,e.data,t);case"cpu-pinned":return new C({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new C({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new C({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),K=P((()=>{H(),L(),q(),Y(),C=class{constructor(e,t,n){let r,a;if(x(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,a=e.dims,e.location){case"cpu-pinned":{let t=$.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"bool"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,o;if("string"==typeof e)if(r=e,o=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");i=t}else{let n=$.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);i=t}}else if(o=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else{let t=v.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===o)o=[i.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");a=o,this.cpuData=i,this.dataLocation="cpu"}let i=S(a);if(this.cpuData&&i!==this.cpuData.length)throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=i}static async fromImage(e,t){return m(e,t)}static fromTexture(e,t){return g(e,t)}static fromGpuBuffer(e,t){return y(e,t)}static fromPinnedBuffer(e,t,n){return w(e,t,n)}toDataURL(e){return p(this,e)}toImageData(e){return f(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return _(this,e)}}})),X=P((()=>{K(),E=C})),J=P((()=>{G(),X(),I=class e{constructor(e){this.handler=e}async run(e,t,n){let r={},a={};if("object"!=typeof e||null===e||e instanceof E||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,o=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==o.indexOf(n)){let a=t[n];(null===a||a instanceof E)&&(e=!0,i=!1,r[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(let e of this.outputNames)r[e]=null;let o=await this.handler.run(e,r,a),s={};for(let e in o)if(Object.hasOwnProperty.call(o,e)){let t=o[e];s[e]=t instanceof E?t:new E(t.type,t.data,t.dims)}return s}async release(){return this.handler.dispose()}static async create(t,n,r,a){let i,o={};if("string"==typeof t){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,s=0,u=t.byteLength;if("object"==typeof n&&null!==n)o=n;else if("number"==typeof n){if(s=n,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(u=t.byteLength-s,"number"==typeof r){if(u=r,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||s+u>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-s}].`);if("object"==typeof a&&null!==a)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(e,s,u)}}let u=(o.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await(await s(u)).createInferenceSessionHandler(i,o);return new e(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),Q=P((()=>{J(),A=I})),Z=P((()=>{})),ee=P((()=>{G(),X(),O=class e{constructor(e){this.handler=e}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,n){let r=t.evalModel||"",a=t.optimizerModel||"",i=n||{},o=(i.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),u=await s(o);if(u.createTrainingSessionHandler){let n=await u.createTrainingSessionHandler(t.checkpointState,t.trainModel,r,a,i);return new e(n)}throw new Error("Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.")}typeNarrowingForRunStep(e,t,n){let r={},a={};if("object"!=typeof e||null===e||e instanceof E||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,o=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==o.indexOf(n)){let a=t[n];(null===a||a instanceof E)&&(e=!0,i=!1,r[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(let e of this.outputNames)r[e]=null;return[r,a]}convertHandlerReturnTypeToMapOfTensors(e){let t={};for(let n in e)if(Object.hasOwnProperty.call(e,n)){let r=e[n];t[n]=r instanceof E?r:new E(r.type,r.data,r.dims)}return t}async runTrainStep(e,t,n){let[r,a]=this.typeNarrowingForRunStep(e,t,n),i=await this.handler.runTrainStep(e,r,a);return this.convertHandlerReturnTypeToMapOfTensors(i)}async loadParametersBuffer(e,t){throw new Error("Method not implemented.")}async getContiguousParameters(e){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}})),te=P((()=>{ee(),T=O})),ne={};W(ne,{InferenceSession:()=>A,Tensor:()=>E,TrainingSession:()=>T,env:()=>c,registerBackend:()=>o});var re=P((()=>{U(),F(),Q(),X(),Z(),te()})),ae={};W(ae,{readFile:()=>ie});var ie,oe=P((()=>{ie=void 0})),se={};W(se,{join:()=>ue});var ue,le=P((()=>{ue=void 0})),de=z(((n,a)=>{var i,o=(i=(i=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||R,function(e={}){var t,n,r=e;r.ready=new Promise(((e,r)=>{t=e,n=r})),r.jsepInit=(e,t,n,a,i,o,s,u)=>{r.Za=e,r.Oa=t,r.Qa=n,r.Ja=a,r.Pa=i,r.ra=o,r.Ra=s,r.Sa=u,t=(e,t,n)=>(...r)=>{let a=be,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),be!=a?new Promise(((e,t)=>{Ie={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(r.Da)throw Error("Session already started");let a=r.Da={Ta:n[0],errors:[]},i=await t(...n);if(r.Da!==a)throw Error("Session mismatch");e.flush();let o=a.errors;if(0<o.length){let e=await Promise.all(o);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return i}finally{r.Da=null}},r._OrtRun=n(t(r._OrtRun,(()=>r._OrtRun),(e=>r._OrtRun=e))),r._OrtRunWithBinding=n(t(r._OrtRunWithBinding,(()=>r._OrtRunWithBinding),(e=>r._OrtRunWithBinding=e))),r._OrtBindInput=t(r._OrtBindInput,(()=>r._OrtBindInput),(e=>r._OrtBindInput=e)),r.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),r.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},r.jsepGetBuffer=t=>e.getBuffer(t),r.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r)};var a,o,s,u=Object.assign({},r),l="./this.program",d=(e,t)=>{throw t},c="object"==typeof window,p="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var m=(oe(),N(ae)),g=(le(),N(se));h=p?g.dirname(h)+"/":"//",a=(e,t)=>(e=e.startsWith("file://")?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),s=e=>((e=a(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):g.normalize(e),m.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!r.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),d=(e,t)=>{throw process.exitCode=e,t},r.inspect=()=>"[Emscripten Module object]"}else(c||p)&&(p?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),i&&(h=i),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},p&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,w=r.print||console.log.bind(console),$=r.printErr||console.error.bind(console);Object.assign(r,u),u=null,r.thisProgram&&(l=r.thisProgram),r.quit&&(d=r.quit),r.wasmBinary&&(y=r.wasmBinary);var v=r.noExitRuntime||!0;"object"!=typeof WebAssembly&&U("no native wasm support detected");var b,x,S,_,C,E,I,A,O,T=!1;function R(){var e=b.buffer;r.HEAP8=_=new Int8Array(e),r.HEAP16=new Int16Array(e),r.HEAP32=E=new Int32Array(e),r.HEAPU8=C=new Uint8Array(e),r.HEAPU16=new Uint16Array(e),r.HEAPU32=I=new Uint32Array(e),r.HEAPF32=A=new Float32Array(e),r.HEAPF64=O=new Float64Array(e)}var k=[],B=[],M=[];function D(){var e=r.preRun.shift();k.unshift(e)}var P,z=0,W=null,G=null;function U(e){throw r.onAbort&&r.onAbort(e),$(e="Aborted("+e+")"),T=!0,S=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function V(e){return e.startsWith("data:application/octet-stream;base64,")}if(!V(P="ort-wasm-simd.wasm")){var j=P;P=r.locateFile?r.locateFile(j,h):h+j}function F(e){if(e==P&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function H(e,t,n){return function(e){if(!y&&(c||p)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>F(e)));if(o)return new Promise(((t,n)=>{o(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>F(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{$("failed to asynchronously prepare wasm: "+e),U(e)}))}var L,q={913792:e=>{r.ra("Abs",e,void 0)},913843:e=>{r.ra("Neg",e,void 0)},913894:e=>{r.ra("Floor",e,void 0)},913947:e=>{r.ra("Ceil",e,void 0)},913999:e=>{r.ra("Reciprocal",e,void 0)},914057:e=>{r.ra("Sqrt",e,void 0)},914109:e=>{r.ra("Exp",e,void 0)},914160:e=>{r.ra("Erf",e,void 0)},914211:e=>{r.ra("Sigmoid",e,void 0)},914266:e=>{r.ra("Log",e,void 0)},914317:e=>{r.ra("Sin",e,void 0)},914368:e=>{r.ra("Cos",e,void 0)},914419:e=>{r.ra("Tan",e,void 0)},914470:e=>{r.ra("Asin",e,void 0)},914522:e=>{r.ra("Acos",e,void 0)},914574:e=>{r.ra("Atan",e,void 0)},914626:e=>{r.ra("Sinh",e,void 0)},914678:e=>{r.ra("Cosh",e,void 0)},914730:e=>{r.ra("Asinh",e,void 0)},914783:e=>{r.ra("Acosh",e,void 0)},914836:e=>{r.ra("Atanh",e,void 0)},914889:e=>{r.ra("Tanh",e,void 0)},914941:e=>{r.ra("Not",e,void 0)},914992:(e,t,n)=>{r.ra("ClipV10",e,{min:t,max:n})},915064:e=>{r.ra("Clip",e,void 0)},915116:(e,t)=>{r.ra("Elu",e,{alpha:t})},915174:e=>{r.ra("Relu",e,void 0)},915226:(e,t)=>{r.ra("LeakyRelu",e,{alpha:t})},915290:(e,t)=>{r.ra("ThresholdedRelu",e,{alpha:t})},915360:(e,t)=>{r.ra("Cast",e,{to:t})},915418:e=>{r.ra("Add",e,void 0)},915469:e=>{r.ra("Sub",e,void 0)},915520:e=>{r.ra("Mul",e,void 0)},915571:e=>{r.ra("Div",e,void 0)},915622:e=>{r.ra("Pow",e,void 0)},915673:e=>{r.ra("Equal",e,void 0)},915726:e=>{r.ra("Greater",e,void 0)},915781:e=>{r.ra("GreaterOrEqual",e,void 0)},915843:e=>{r.ra("Less",e,void 0)},915895:e=>{r.ra("LessOrEqual",e,void 0)},915954:(e,t,n,a,i)=>{r.ra("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916118:(e,t,n,a,i)=>{r.ra("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916281:(e,t,n,a,i)=>{r.ra("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916444:(e,t,n,a,i)=>{r.ra("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916608:(e,t,n,a,i)=>{r.ra("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916771:(e,t,n,a,i)=>{r.ra("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916933:(e,t,n,a,i)=>{r.ra("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917095:(e,t,n,a,i)=>{r.ra("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917261:(e,t,n,a,i)=>{r.ra("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917430:(e,t,n,a,i)=>{r.ra("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917599:e=>{r.ra("Where",e,void 0)},917652:(e,t,n)=>{r.ra("Transpose",e,{perm:t?Array.from(E.subarray(n>>>0,n+t>>>0)):[]})},917765:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m)=>{r.ra("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[d>>>0],outputPadding:c?Array.from(E.subarray(p>>>0,p+c>>>0)):[],outputShape:f?Array.from(E.subarray(h>>>0,h+f>>>0)):[],activation:ee(m)})},918179:(e,t,n,a,i,o,s,u,l,d,c,p,f,h)=>{r.ra("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(E.subarray(n>>>0,n+2>>>0)),group:a,kernelShape:Array.from(E.subarray(i>>>0,i+2>>>0)),pads:Array.from(E.subarray(o>>>0,o+4>>>0)),strides:Array.from(E.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<d?Array.from(E.subarray(c>>>0,c+d>>>0)):[],outputShape:0<p?Array.from(E.subarray(f>>>0,f+p>>>0)):[],activation:ee(h)})},918736:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m)=>{r.ra("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[d>>>0],outputPadding:c?Array.from(E.subarray(p>>>0,p+c>>>0)):[],outputShape:f?Array.from(E.subarray(h>>>0,h+f>>>0)):[],activation:ee(m)})},919150:(e,t,n,a,i,o,s,u,l,d,c,p,f,h)=>{r.ra("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(E.subarray(n>>>0,n+2>>>0)),group:a,kernelShape:Array.from(E.subarray(i>>>0,i+2>>>0)),pads:Array.from(E.subarray(o>>>0,o+4>>>0)),strides:Array.from(E.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<d?Array.from(E.subarray(c>>>0,c+d>>>0)):[],outputShape:0<p?Array.from(E.subarray(f>>>0,f+p>>>0)):[],activation:ee(h)})},919707:(e,t)=>{r.ra("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},919798:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920082:(e,t)=>{r.ra("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},920173:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920457:(e,t)=>{r.ra("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},920544:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920824:(e,t)=>{r.ra("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},920911:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},921191:(e,t,n,a,i)=>{r.ra("Gemm",e,{alpha:t,beta:n,transA:a,transB:i})},921295:e=>{r.ra("MatMul",e,void 0)},921349:(e,t,n,a)=>{r.ra("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},921457:(e,t,n,a)=>{r.ra("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},921565:(e,t)=>{r.ra("Softmax",e,{axis:t})},921628:(e,t)=>{r.ra("Concat",e,{axis:t})},921688:(e,t,n,a,i)=>{r.ra("Split",e,{axis:t,numOutputs:n,splitSizes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},921833:e=>{r.ra("Expand",e,void 0)},921887:(e,t)=>{r.ra("Gather",e,{axis:Number(t)})},921958:(e,t)=>{r.ra("GatherElements",e,{axis:Number(t)})},922037:(e,t,n,a,i,o,s,u,l,d,c)=>{r.ra("Resize",e,{antialias:t,axes:n?Array.from(E.subarray(a>>>0,a+n>>>0)):[],coordinateTransformMode:ee(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:ee(l),mode:ee(d),nearestMode:ee(c)})},922388:(e,t,n,a,i,o,s)=>{r.ra("Slice",e,{starts:t?Array.from(E.subarray(n>>>0,n+t>>>0)):[],ends:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[],axes:o?Array.from(E.subarray(s>>>0,s+o>>>0)):[]})},922619:e=>{r.ra("Tile",e,void 0)},922671:(e,t,n)=>{r.ra("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},922778:(e,t,n)=>{r.ra("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},922892:(e,t,n)=>{r.ra("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},923006:e=>{r.ra("Range",e,void 0)},923059:(e,t)=>{r.ra("Einsum",e,{equation:ee(t)})},923140:(e,t,n,a,i)=>{r.ra("Pad",e,{mode:t,value:n,pads:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},923272:e=>{r.ra("Gelu",e,void 0)},923324:e=>{r.ra("BiasAdd",e,void 0)},923379:e=>{r.ra("BiasSplitGelu",e,void 0)},923440:(e,t)=>{r.ra("SkipLayerNormalization",e,{epsilon:t})},923521:(e,t,n,a,i,o,s,u,l,d,c,p,f)=>{r.ra("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:a,kernel_shape:[i],pads:o?Array.from(E.subarray(s>>>0,s+o>>>0)):[],strides:[u],w_is_const:()=>!!_[d>>>0],activation:ee(c),activation_params:p?Array.from(A.subarray(f>>>0,f+p>>>0)):[]})},923902:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:t,dilations:[n,a],group:i,kernel_shape:[o,s],pads:u?Array.from(E.subarray(l>>>0,l+u>>>0)):[],strides:[d,c],w_is_const:()=>!!_[f>>>0],activation:ee(h),activation_params:m?Array.from(A.subarray(g>>>0,g+m>>>0)):[]})},924304:e=>{r.Ra(e)},924338:(e,t)=>r.Sa(e,t,r.Da.Ta,r.Da.errors),924450:e=>r.Oa(e),924483:e=>r.Qa(e),924515:(e,t,n)=>{r.Ja(e,t,n,!0)},924554:(e,t,n)=>{r.Ja(e,t,n)}};function Y(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var K=e=>{for(;0<e.length;)e.shift()(r)};function X(e){this.Ha=e-24,this.Ma=function(e){I[this.Ha+4>>2>>>0]=e},this.La=function(e){I[this.Ha+8>>2>>>0]=e},this.Ya=function(e,t){this.Ka(),this.Ma(e),this.La(t)},this.Ka=function(){I[this.Ha+16>>2>>>0]=0}}var J,Q=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Z=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Q)return Q.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},ee=(e,t)=>(e>>>=0)?Z(C,e,t):"",te=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},ne=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},re=e=>e%4==0&&(e%100!=0||e%400==0),ie=[0,31,60,91,121,152,182,213,244,274,305,335],ue=[0,31,59,90,120,151,181,212,243,273,304,334],de=e=>{var t=te(e)+1,n=Re(t);return n&&ne(e,C,n,t),n},ce=[],pe=(e,t)=>{var n;for(ce.length=0,t>>=2;n=C[e++>>>0];)t+=105!=n&t,ce.push(105==n?E[t>>>0]:O[t++>>>1]),++t;return ce},fe={},he=()=>{if(!J){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"};for(e in fe)void 0===fe[e]?delete t[e]:t[e]=fe[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);J=n}return J},me=[null,[],[]],ge=[31,29,31,30,31,30,31,31,30,31,30,31],ye=[31,28,31,30,31,30,31,31,30,31,30,31];function we(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return a(e,t,"0")}function o(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.Ba;for(e=new Date(new Date(e.Ca+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(re(e.getFullYear())?ge:ye)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=o(t,e)?0>=o(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0;var l=E[40+(r>>>=0)>>2>>>0];for(var d in r={Wa:E[r>>2>>>0],Va:E[r+4>>2>>>0],Ea:E[r+8>>2>>>0],Ia:E[r+12>>2>>>0],Fa:E[r+16>>2>>>0],Ca:E[r+20>>2>>>0],wa:E[r+24>>2>>>0],Ba:E[r+28>>2>>>0],$a:E[r+32>>2>>>0],Ua:E[r+36>>2>>>0],Xa:l?ee(l):""},n=ee(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(d,"g"),l[d]);var c="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(d in l={"%a":e=>c[e.wa].substring(0,3),"%A":e=>c[e.wa],"%b":e=>p[e.Fa].substring(0,3),"%B":e=>p[e.Fa],"%C":e=>i((e.Ca+1900)/100|0,2),"%d":e=>i(e.Ia,2),"%e":e=>a(e.Ia,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>i(e.Ea,2),"%I":e=>(0==(e=e.Ea)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Fa-1;t+=(re(e.Ca+1900)?ge:ye)[n++]);return i(e.Ia+t,3)},"%m":e=>i(e.Fa+1,2),"%M":e=>i(e.Va,2),"%n":()=>"\n","%p":e=>0<=e.Ea&&12>e.Ea?"AM":"PM","%S":e=>i(e.Wa,2),"%t":()=>"\t","%u":e=>e.wa||7,"%U":e=>i(Math.floor((e.Ba+7-e.wa)/7),2),"%V":e=>{var t=Math.floor((e.Ba+7-(e.wa+6)%7)/7);if(2>=(e.wa+371-e.Ba-2)%7&&t++,t)53==t&&(4==(n=(e.wa+371-e.Ba)%7)||3==n&&re(e.Ca)||(t=1));else{t=52;var n=(e.wa+7-e.Ba-1)%7;(4==n||5==n&&re(e.Ca%400-1))&&t++}return i(t,2)},"%w":e=>e.wa,"%W":e=>i(Math.floor((e.Ba+7-(e.wa+6)%7)/7),2),"%y":e=>(e.Ca+1900).toString().substring(2),"%Y":e=>e.Ca+1900,"%z":e=>(0<=(e=e.Ua)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.Xa,"%%":()=>"%"},n=n.replace(/%%/g,"\0\0"),l)n.includes(d)&&(n=n.replace(new RegExp(d,"g"),l[d](r)));return d=function(e){var t=Array(te(e)+1);return ne(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),d.length>t?0:(_.set(d,e>>>0),d.length-1)}function $e(e){try{e()}catch(e){U(e)}}var ve=0,be=null,xe=0,Se=[],_e={},Ce={},Ee=0,Ie=null,Ae=[];var Oe={n:function(e,t,n){return function(e){return function(e){if(!T){if(0===ve){var t=!1,n=!1;e(((e=0)=>{if(!T&&(xe=e,t=!0,n)){ve=2,$e((()=>Ne(be))),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),e=!1;try{var r=(0,x[Ce[E[be+8>>2>>>0]]])()}catch(t){r=t,e=!0}var a=!1;if(!be){var i=Ie;i&&(Ie=null,(e?i.reject:i.resolve)(r),a=!0)}if(e&&!a)throw r}})),n=!0,t||(ve=1,be=function(){var e=Re(65548),t=e+12;I[e>>2>>>0]=t,I[e+4>>2>>>0]=t+65536,t=Se[0];var n=_e[t];return void 0===n&&(n=Ee++,_e[t]=n,Ce[n]=t),E[e+8>>2>>>0]=n,e}(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),$e((()=>ze(be))))}else 2===ve?(ve=0,$e(Ge),ke(be),be=null,Ae.forEach((e=>{if(!T)try{if(e(),!v)try{S=S=e=S,v||(r.onExit&&r.onExit(e),T=!0),d(e,new Y(e))}catch(e){e instanceof Y||"unwind"==e||d(1,e)}}catch(e){e instanceof Y||"unwind"==e||d(1,e)}}))):U(`invalid state: ${ve}`);return xe}}((t=>{e().then(t)}))}((async()=>{await r.Pa(e,t,n)}))},a:function(e,t,n){throw new X(e>>>=0).Ya(t>>>0,n>>>0),e},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),E[n>>2>>>0]=e.getUTCSeconds(),E[n+4>>2>>>0]=e.getUTCMinutes(),E[n+8>>2>>>0]=e.getUTCHours(),E[n+12>>2>>>0]=e.getUTCDate(),E[n+16>>2>>>0]=e.getUTCMonth(),E[n+20>>2>>>0]=e.getUTCFullYear()-1900,E[n+24>>2>>>0]=e.getUTCDay(),E[n+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),E[n>>2>>>0]=e.getSeconds(),E[n+4>>2>>>0]=e.getMinutes(),E[n+8>>2>>>0]=e.getHours(),E[n+12>>2>>>0]=e.getDate(),E[n+16>>2>>>0]=e.getMonth(),E[n+20>>2>>>0]=e.getFullYear()-1900,E[n+24>>2>>>0]=e.getDay(),E[n+28>>2>>>0]=(re(e.getFullYear())?ie:ue)[e.getMonth()]+e.getDate()-1|0,E[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();E[n+32>>2>>>0]=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t))},s:function(e){e>>>=0;var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,a);return 0>n?E[e+32>>2>>>0]=+(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(re(t.getFullYear())?ie:ue)[t.getMonth()]+t.getDate()-1|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Be((L=e,1<=+Math.abs(L)?0<L?+Math.floor(L/4294967296)>>>0:~~+Math.ceil((L-+(~~L>>>0))/4294967296)>>>0:0)),e>>>0},o:function(){return-52},p:function(){},v:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}n>>>=0;var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var s=o.getTimezoneOffset();I[e>>>0>>2>>>0]=60*Math.max(a,s),E[t>>>0>>2>>>0]=+(a!=s),e=r(i),t=r(o),e=de(e),t=de(t),s<a?(I[n>>2>>>0]=e,I[n+4>>2>>>0]=t):(I[n>>2>>>0]=t,I[n+4>>2>>>0]=e)},e:()=>{U("")},b:function(e,t,n){return e>>>=0,t=pe(t>>>0,n>>>0),q[e].apply(null,t)},i:function(e,t,n){return e>>>=0,t=pe(t>>>0,n>>>0),q[e].apply(null,t)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(e,t,n){return t>>>=0,C.copyWithin(e>>>0>>>0,t>>>0,t+(n>>>0)>>>0)},u:function(e){e>>>=0;var t=C.length;if(4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r);e:{a=a.min.call(a,4294901760,r+(65536-r%65536)%65536)-b.buffer.byteLength+65535>>>16;try{b.grow(a),R();var i=1;break e}catch{}i=void 0}if(i)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var n=0;return he().forEach((function(r,a){var i=t+n;for(a=I[e+4*a>>2>>>0]=i,i=0;i<r.length;++i)_[a++>>0>>>0]=r.charCodeAt(i);_[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var n=he();I[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),I[t>>2>>>0]=r,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(e,t,n,r){t>>>=0,n>>>=0,r>>>=0;for(var a=0,i=0;i<n;i++){var o=I[t>>2>>>0],s=I[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=C[o+u>>>0],d=me[e];0===l||10===l?((1===e?w:$)(Z(d,0)),d.length=0):d.push(l)}a+=s}return I[r>>2>>>0]=a,0},F:we,d:function(e,t,n,r){return we(e>>>0,t>>>0,n>>>0,r>>>0)}};(function(){function e(e){if(e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){Se.push(t);try{return r.apply(null,arguments)}finally{T||(Se.pop()===t||U(),be&&1===ve&&0===Se.length&&(ve=0,$e(We),typeof Fibers<"u"&&Fibers.ab()))}}:r}(t);return n}(e=e.exports),x=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),b=x.M,R(),B.unshift(x.N),z--,r.monitorRunDependencies&&r.monitorRunDependencies(z),0==z&&(null!==W&&(clearInterval(W),W=null),G)){var t=G;G=null,t()}return e}var t={a:Oe};if(z++,r.monitorRunDependencies&&r.monitorRunDependencies(z),r.instantiateWasm)try{return r.instantiateWasm(t,e)}catch(e){$("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var n=P;return y||"function"!=typeof WebAssembly.instantiateStreaming||V(n)||n.startsWith("file://")||f||"function"!=typeof fetch?H(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return $("wasm streaming compile failed: "+r),$("falling back to ArrayBuffer instantiation"),H(n,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)})(),r._OrtInit=(e,t)=>(r._OrtInit=x.O)(e,t),r._OrtGetLastError=(e,t)=>(r._OrtGetLastError=x.P)(e,t),r._OrtCreateSessionOptions=(e,t,n,a,i,o,s,u,l,d)=>(r._OrtCreateSessionOptions=x.Q)(e,t,n,a,i,o,s,u,l,d),r._OrtAppendExecutionProvider=(e,t)=>(r._OrtAppendExecutionProvider=x.R)(e,t),r._OrtAddFreeDimensionOverride=(e,t,n)=>(r._OrtAddFreeDimensionOverride=x.S)(e,t,n),r._OrtAddSessionConfigEntry=(e,t,n)=>(r._OrtAddSessionConfigEntry=x.T)(e,t,n),r._OrtReleaseSessionOptions=e=>(r._OrtReleaseSessionOptions=x.U)(e),r._OrtCreateSession=(e,t,n)=>(r._OrtCreateSession=x.V)(e,t,n),r._OrtReleaseSession=e=>(r._OrtReleaseSession=x.W)(e),r._OrtGetInputOutputCount=(e,t,n)=>(r._OrtGetInputOutputCount=x.X)(e,t,n),r._OrtGetInputName=(e,t)=>(r._OrtGetInputName=x.Y)(e,t),r._OrtGetOutputName=(e,t)=>(r._OrtGetOutputName=x.Z)(e,t),r._OrtFree=e=>(r._OrtFree=x._)(e),r._OrtCreateTensor=(e,t,n,a,i,o)=>(r._OrtCreateTensor=x.$)(e,t,n,a,i,o),r._OrtGetTensorData=(e,t,n,a,i)=>(r._OrtGetTensorData=x.aa)(e,t,n,a,i),r._OrtReleaseTensor=e=>(r._OrtReleaseTensor=x.ba)(e),r._OrtCreateRunOptions=(e,t,n,a)=>(r._OrtCreateRunOptions=x.ca)(e,t,n,a),r._OrtAddRunConfigEntry=(e,t,n)=>(r._OrtAddRunConfigEntry=x.da)(e,t,n),r._OrtReleaseRunOptions=e=>(r._OrtReleaseRunOptions=x.ea)(e),r._OrtCreateBinding=e=>(r._OrtCreateBinding=x.fa)(e),r._OrtBindInput=(e,t,n)=>(r._OrtBindInput=x.ga)(e,t,n),r._OrtBindOutput=(e,t,n,a)=>(r._OrtBindOutput=x.ha)(e,t,n,a),r._OrtClearBoundOutputs=e=>(r._OrtClearBoundOutputs=x.ia)(e),r._OrtReleaseBinding=e=>(r._OrtReleaseBinding=x.ja)(e),r._OrtRunWithBinding=(e,t,n,a,i)=>(r._OrtRunWithBinding=x.ka)(e,t,n,a,i),r._OrtRun=(e,t,n,a,i,o,s,u)=>(r._OrtRun=x.la)(e,t,n,a,i,o,s,u),r._OrtEndProfiling=e=>(r._OrtEndProfiling=x.ma)(e),r._JsepOutput=(e,t,n)=>(r._JsepOutput=x.na)(e,t,n),r._JsepGetNodeName=e=>(r._JsepGetNodeName=x.oa)(e);var Te,Re=r._malloc=e=>(Re=r._malloc=x.pa)(e),ke=r._free=e=>(ke=r._free=x.qa)(e),Be=e=>(Be=x.sa)(e),Me=()=>(Me=x.ta)(),De=e=>(De=x.ua)(e),Pe=e=>(Pe=x.va)(e),ze=e=>(ze=x.xa)(e),We=()=>(We=x.ya)(),Ne=e=>(Ne=x.za)(e),Ge=()=>(Ge=x.Aa)();function Ue(){function e(){if(!Te&&(Te=!0,r.calledRun=!0,!T)){if(K(B),t(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for("function"==typeof r.postRun&&(r.postRun=[r.postRun]);r.postRun.length;){var e=r.postRun.shift();M.unshift(e)}K(M)}}if(!(0<z)){if(r.preRun)for("function"==typeof r.preRun&&(r.preRun=[r.preRun]);r.preRun.length;)D();K(k),0<z||(r.setStatus?(r.setStatus("Running..."),setTimeout((function(){setTimeout((function(){r.setStatus("")}),1),e()}),1)):e())}}if(r.___start_em_js=924587,r.___stop_em_js=924748,r.stackAlloc=Pe,r.stackSave=Me,r.stackRestore=De,r.UTF8ToString=ee,r.stringToUTF8=(e,t,n)=>ne(e,C,t,n),r.lengthBytesUTF8=te,G=function e(){Te||Ue(),Te||(G=e)},r.preInit)for("function"==typeof r.preInit&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Ue(),e.ready});"object"==typeof n&&"object"==typeof a?a.exports=o:void 0===(r=(()=>o).apply(t,[]))||(e.exports=r)})),ce=z((()=>{})),pe=z((()=>{})),fe={};W(fe,{cpus:()=>he});var he,me,ge,ye,we,$e,ve,be,xe,Se,_e,Ce,Ee,Ie,Ae,Oe,Te,Re,ke,Be,Me,De,Pe,ze,We,Ne,Ge,Ue,Ve,je,Fe,He,Le,qe,Ye,Ke,Xe,Je,Qe,Ze,et,tt,nt,rt,at,it,ot,st,ut,lt,dt,ct,pt,ft,ht,mt,gt,yt,wt,$t,vt,bt,xt,St,_t,Ct,Et,It,At,Ot,Tt,Rt,kt,Bt,Mt,Dt,Pt,zt,Wt,Nt,Gt,Ut,Vt,jt,Ft,Ht,Lt,qt,Yt,Kt,Xt,Jt,Qt,Zt,en,tn,nn,rn,an,on,sn,un,ln,dn,cn,pn,fn,hn,mn,gn,yn,wn,$n,vn,bn,xn,Sn,_n,Cn,En,In,An,On,Tn,Rn,kn,Bn,Mn,Dn,Pn,zn,Wn,Nn,Gn,Un,Vn,jn,Fn,Hn,Ln,qn,Yn,Kn,Xn,Jn,Qn,Zn,er,tr,nr,rr,ar,ir,or,sr,ur,lr,dr,cr,pr,fr,hr,mr,gr,yr,wr,$r,vr,br,xr,Sr,_r,Cr,Er,Ir,Ar,Or,Tr,Rr,kr,Br,Mr,Dr,Pr,zr,Wr,Nr,Gr,Ur,Vr,jr,Fr,Hr,Lr,qr,Yr,Kr,Xr,Jr,Qr,Zr,ea,ta,na,ra,aa,ia,oa,sa,ua,la,da,ca,pa,fa,ha,ma,ga,ya,wa,$a,va,ba,xa,Sa,_a,Ca,Ea,Ia,Aa,Oa,Ta,Ra,ka,Ba,Ma,Da,Pa,za,Wa,Na,Ga,Ua,Va,ja,Fa,Ha,La,qa,Ya,Ka,Xa,Ja,Qa,Za,ei,ti,ni,ri,ai,ii,oi,si,ui,li,di,ci,pi,fi,hi,mi,gi,yi,wi,$i,vi,bi,xi,Si,_i,Ci,Ei,Ii,Ai,Oi,Ti,Ri,ki,Bi,Mi,Di,Pi,zi,Wi,Ni,Gi,Ui,Vi,ji,Fi,Hi,Li,qi,Yi,Ki,Xi,Ji,Qi,Zi,eo,to,no,ro,ao,io,oo,so,uo,lo,co,po,fo,ho,mo,go,yo,wo,$o,vo,bo,xo,So,_o,Co,Eo,Io,Ao,Oo,To,Ro,ko,Bo,Mo,Do,Po,zo,Wo,No=P((()=>{he=void 0})),Go=z(((a,i)=>{var o,s=(o=(o=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||R,function(e={}){function t(){return k.buffer!=P.buffer&&F(),P}function r(){return k.buffer!=P.buffer&&F(),z}function a(){return k.buffer!=P.buffer&&F(),W}function i(){return k.buffer!=P.buffer&&F(),G}function s(){return k.buffer!=P.buffer&&F(),U}function u(){return k.buffer!=P.buffer&&F(),V}var l,d,c=e;c.ready=new Promise(((e,t)=>{l=e,d=t})),c.jsepInit=(e,t,n,r,a,i,o,s)=>{c.Qb=e,c.wb=t,c.yb=n,c.jb=r,c.xb=a,c.Ea=i,c.zb=o,c.Ab=s,t=(e,t,n)=>(...r)=>{let a=xt,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),xt!=a?new Promise(((e,t)=>{At={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(c.bb)throw Error("Session already started");let r=c.bb={Fb:n[0],errors:[]},a=await t(...n);if(c.bb!==r)throw Error("Session mismatch");e.flush();let i=r.errors;if(0<i.length){let e=await Promise.all(i);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return a}finally{c.bb=null}},c._OrtRun=n(t(c._OrtRun,(()=>c._OrtRun),(e=>c._OrtRun=e))),c._OrtRunWithBinding=n(t(c._OrtRunWithBinding,(()=>c._OrtRunWithBinding),(e=>c._OrtRunWithBinding=e))),c._OrtBindInput=t(c._OrtBindInput,(()=>c._OrtBindInput),(e=>c._OrtBindInput=e)),c.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),c.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},c.jsepGetBuffer=t=>e.getBuffer(t),c.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r)};var p,f,h,m=Object.assign({},c),g="./this.program",y=(e,t)=>{throw t},w="object"==typeof window,$="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,x="";function S(e){return c.locateFile?c.locateFile(e,x):x+e}if(v){var _=(oe(),N(ae)),C=(le(),N(se));let e;x=$?C.dirname(x)+"/":"//",p=(e,t)=>(e=e.startsWith("file://")?new URL(e):C.normalize(e),_.readFileSync(e,t?void 0:"utf8")),h=e=>((e=p(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):C.normalize(e),_.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),y=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{e=ce()}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=e.Worker}else(w||$)&&($?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),typeof o<"u"&&o&&(x=o),x=0!==x.indexOf("blob:")?x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},$&&(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));v&&typeof performance>"u"&&(n.g.performance=pe().performance);var E=console.log.bind(console),I=console.error.bind(console);v&&(E=(...e)=>_.writeSync(1,e.join(" ")+"\n"),I=(...e)=>_.writeSync(2,e.join(" ")+"\n"));var A,O=c.print||E,T=c.printErr||I;Object.assign(c,m),m=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(y=c.quit),c.wasmBinary&&(A=c.wasmBinary);var R=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&re("no native wasm support detected");var k,B,M,D,P,z,W,G,U,V,j=!1;function F(){var e=k.buffer;c.HEAP8=P=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=W=new Int32Array(e),c.HEAPU8=z=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=G=new Uint32Array(e),c.HEAPF32=U=new Float32Array(e),c.HEAPF64=V=new Float64Array(e)}var H=c.INITIAL_MEMORY||16777216;if(5242880<=H||re("INITIAL_MEMORY should be larger than STACK_SIZE, was "+H+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:H/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw T("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&T("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");F(),H=k.buffer.byteLength;var L=[],q=[],Y=[],K=0;function X(){return R||0<K}var J,Q=0,Z=null,ee=null;function te(){Q++,c.monitorRunDependencies&&c.monitorRunDependencies(Q)}function ne(){if(Q--,c.monitorRunDependencies&&c.monitorRunDependencies(Q),0==Q&&(null!==Z&&(clearInterval(Z),Z=null),ee)){var e=ee;ee=null,e()}}function re(e){throw c.onAbort&&c.onAbort(e),T(e="Aborted("+e+")"),j=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),d(e),e}function ie(e){return e.startsWith("data:application/octet-stream;base64,")}function ue(e){if(e==J&&A)return new Uint8Array(A);if(h)return h(e);throw"both async and sync fetching of the wasm failed"}function de(e,t,n){return function(e){if(!A&&(w||$)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>ue(e)));if(f)return new Promise(((t,n)=>{f(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>ue(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{T("failed to asynchronously prepare wasm: "+e),re(e)}))}ie(J="ort-wasm-simd-threaded.wasm")||(J=S(J));var he,me={914988:e=>{c.Ea("Abs",e,void 0)},915039:e=>{c.Ea("Neg",e,void 0)},915090:e=>{c.Ea("Floor",e,void 0)},915143:e=>{c.Ea("Ceil",e,void 0)},915195:e=>{c.Ea("Reciprocal",e,void 0)},915253:e=>{c.Ea("Sqrt",e,void 0)},915305:e=>{c.Ea("Exp",e,void 0)},915356:e=>{c.Ea("Erf",e,void 0)},915407:e=>{c.Ea("Sigmoid",e,void 0)},915462:e=>{c.Ea("Log",e,void 0)},915513:e=>{c.Ea("Sin",e,void 0)},915564:e=>{c.Ea("Cos",e,void 0)},915615:e=>{c.Ea("Tan",e,void 0)},915666:e=>{c.Ea("Asin",e,void 0)},915718:e=>{c.Ea("Acos",e,void 0)},915770:e=>{c.Ea("Atan",e,void 0)},915822:e=>{c.Ea("Sinh",e,void 0)},915874:e=>{c.Ea("Cosh",e,void 0)},915926:e=>{c.Ea("Asinh",e,void 0)},915979:e=>{c.Ea("Acosh",e,void 0)},916032:e=>{c.Ea("Atanh",e,void 0)},916085:e=>{c.Ea("Tanh",e,void 0)},916137:e=>{c.Ea("Not",e,void 0)},916188:(e,t,n)=>{c.Ea("ClipV10",e,{min:t,max:n})},916260:e=>{c.Ea("Clip",e,void 0)},916312:(e,t)=>{c.Ea("Elu",e,{alpha:t})},916370:e=>{c.Ea("Relu",e,void 0)},916422:(e,t)=>{c.Ea("LeakyRelu",e,{alpha:t})},916486:(e,t)=>{c.Ea("ThresholdedRelu",e,{alpha:t})},916556:(e,t)=>{c.Ea("Cast",e,{to:t})},916614:e=>{c.Ea("Add",e,void 0)},916665:e=>{c.Ea("Sub",e,void 0)},916716:e=>{c.Ea("Mul",e,void 0)},916767:e=>{c.Ea("Div",e,void 0)},916818:e=>{c.Ea("Pow",e,void 0)},916869:e=>{c.Ea("Equal",e,void 0)},916922:e=>{c.Ea("Greater",e,void 0)},916977:e=>{c.Ea("GreaterOrEqual",e,void 0)},917039:e=>{c.Ea("Less",e,void 0)},917091:e=>{c.Ea("LessOrEqual",e,void 0)},917150:(e,t,n,r,i)=>{c.Ea("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917314:(e,t,n,r,i)=>{c.Ea("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917477:(e,t,n,r,i)=>{c.Ea("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917640:(e,t,n,r,i)=>{c.Ea("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917804:(e,t,n,r,i)=>{c.Ea("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917967:(e,t,n,r,i)=>{c.Ea("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918129:(e,t,n,r,i)=>{c.Ea("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918291:(e,t,n,r,i)=>{c.Ea("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918457:(e,t,n,r,i)=>{c.Ea("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918626:(e,t,n,r,i)=>{c.Ea("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918795:e=>{c.Ea("Where",e,void 0)},918848:(e,t,n)=>{c.Ea("Transpose",e,{perm:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[]})},918961:(e,n,r,i,o,s,u,l,d,p,f,h,m,g,y)=>{c.Ea("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:m?Array.from(a().subarray(g>>>0,g+m>>>0)):[],activation:xe(y)})},919375:(e,n,r,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(m>>>0,m+h>>>0)):[],activation:xe(g)})},919932:(e,n,r,i,o,s,u,l,d,p,f,h,m,g,y)=>{c.Ea("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:m?Array.from(a().subarray(g>>>0,g+m>>>0)):[],activation:xe(y)})},920346:(e,n,r,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(m>>>0,m+h>>>0)):[],activation:xe(g)})},920903:(e,t)=>{c.Ea("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},920994:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},921278:(e,t)=>{c.Ea("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},921369:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},921653:(e,t)=>{c.Ea("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},921740:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},922020:(e,t)=>{c.Ea("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},922107:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},922387:(e,t,n,r,a)=>{c.Ea("Gemm",e,{alpha:t,beta:n,transA:r,transB:a})},922491:e=>{c.Ea("MatMul",e,void 0)},922545:(e,t,n,r)=>{c.Ea("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},922653:(e,t,n,r)=>{c.Ea("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},922761:(e,t)=>{c.Ea("Softmax",e,{axis:t})},922824:(e,t)=>{c.Ea("Concat",e,{axis:t})},922884:(e,t,n,r,i)=>{c.Ea("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},923029:e=>{c.Ea("Expand",e,void 0)},923083:(e,t)=>{c.Ea("Gather",e,{axis:Number(t)})},923154:(e,t)=>{c.Ea("GatherElements",e,{axis:Number(t)})},923233:(e,t,n,r,i,o,s,u,l,d,p)=>{c.Ea("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(r>>>0,r+n>>>0)):[],coordinateTransformMode:xe(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:xe(l),mode:xe(d),nearestMode:xe(p)})},923584:(e,t,n,r,i,o,s)=>{c.Ea("Slice",e,{starts:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[],ends:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[],axes:o?Array.from(a().subarray(s>>>0,s+o>>>0)):[]})},923815:e=>{c.Ea("Tile",e,void 0)},923867:(e,t,n)=>{c.Ea("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},923974:(e,t,n)=>{c.Ea("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},924088:(e,t,n)=>{c.Ea("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},924202:e=>{c.Ea("Range",e,void 0)},924255:(e,t)=>{c.Ea("Einsum",e,{equation:xe(t)})},924336:(e,t,n,r,i)=>{c.Ea("Pad",e,{mode:t,value:n,pads:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},924468:e=>{c.Ea("Gelu",e,void 0)},924520:e=>{c.Ea("BiasAdd",e,void 0)},924575:e=>{c.Ea("BiasSplitGelu",e,void 0)},924636:(e,t)=>{c.Ea("SkipLayerNormalization",e,{epsilon:t})},924717:(e,n,r,i,o,u,l,d,p,f,h,m,g)=>{c.Ea("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:i,kernel_shape:[o],pads:u?Array.from(a().subarray(l>>>0,l+u>>>0)):[],strides:[d],w_is_const:()=>!!t()[f>>>0],activation:xe(h),activation_params:m?Array.from(s().subarray(g>>>0,g+m>>>0)):[]})},925098:(e,n,r,i,o,u,l,d,p,f,h,m,g,y,w,$)=>{c.Ea("Conv",e,{format:m?"NHWC":"NCHW",auto_pad:n,dilations:[r,i],group:o,kernel_shape:[u,l],pads:d?Array.from(a().subarray(p>>>0,p+d>>>0)):[],strides:[f,h],w_is_const:()=>!!t()[g>>>0],activation:xe(y),activation_params:w?Array.from(s().subarray($>>>0,$+w>>>0)):[]})},925500:e=>{c.zb(e)},925534:(e,t)=>c.Ab(e,t,c.bb.Fb,c.bb.errors),925646:e=>c.wb(e),925679:e=>c.yb(e),925711:(e,t,n)=>{c.jb(e,t,n,!0)},925750:(e,t,n)=>{c.jb(e,t,n)}};function ge(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ye(e){e.terminate(),e.onmessage=()=>{}}function we(e){(e=Ce.Qa[e])||re(),Ce.Eb(e)}function $e(e){var t=Ce.tb();if(!t)return 6;Ce.Ya.push(t),Ce.Qa[e.Xa]=t,t.Xa=e.Xa;var n={cmd:"run",start_routine:e.Gb,arg:e.rb,pthread_ptr:e.Xa};return v&&t.unref(),t.postMessage(n,e.Mb),0}var ve=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,be=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&ve)return ve.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},xe=(e,t)=>(e>>>=0)?be(r(),e,t):"";function Se(e){if(b)return it(1,1,e);D=e,X()||(Ce.Hb(),c.onExit&&c.onExit(e),j=!0),y(e,new ge(e))}var _e=e=>{if(D=e,b)throw Ie(e),"unwind";Se(e)},Ce={ab:[],Ya:[],mb:[],Qa:{},gb:function(){b?Ce.vb():Ce.ub()},ub:function(){L.unshift((()=>{te(),Ce.Bb((()=>ne()))}))},vb:function(){Ce.receiveObjectTransfer=Ce.Db,Ce.threadInitTLS=Ce.lb,Ce.setExitStatus=Ce.kb,R=!1},kb:function(e){D=e},Sb:["$terminateWorker"],Hb:function(){for(var e of Ce.Ya)ye(e);for(e of Ce.ab)ye(e);Ce.ab=[],Ce.Ya=[],Ce.Qa=[]},Eb:function(e){var t=e.Xa;delete Ce.Qa[t],Ce.ab.push(e),Ce.Ya.splice(Ce.Ya.indexOf(e),1),e.Xa=0,Wt(t)},Db:function(){},lb:function(){Ce.mb.forEach((e=>e()))},Cb:e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=kt()){var a=Ce.Qa[n.Rb];a?a.postMessage(n,n.transferList):T('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"checkMailbox"===r?Ke():"spawnThread"===r?$e(n):"cleanupThread"===r?we(n.thread):"killThread"===r?(n=n.thread,r=Ce.Qa[n],delete Ce.Qa[n],ye(r),Wt(n),Ce.Ya.splice(Ce.Ya.indexOf(r),1),r.Xa=0):"cancelThread"===r?Ce.Qa[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?c[n.handler](...n.args):r&&T("worker sent an unknown command "+r)},e.onerror=e=>{throw T("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var n,r=[];for(n of["onExit","onAbort","print","printErr"])c.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,urlOrBlob:c.mainScriptUrlOrBlob||o,wasmMemory:k,wasmModule:M})})),Bb:function(e){e()},qb:function(){var e=S("ort-wasm-simd-threaded.worker.js");e=new Worker(e),Ce.ab.push(e)},tb:function(){return 0==Ce.ab.length&&(Ce.qb(),Ce.Cb(Ce.ab[0])),Ce.ab.pop()}};c.PThread=Ce;var Ee=e=>{for(;0<e.length;)e.shift()(c)};function Ie(e){if(b)return it(2,0,e);_e(e)}function Ae(e){this.fb=e-24,this.pb=function(e){i()[this.fb+4>>2>>>0]=e},this.ob=function(e){i()[this.fb+8>>2>>>0]=e},this.gb=function(e,t){this.nb(),this.pb(e),this.ob(t)},this.nb=function(){i()[this.fb+16>>2>>>0]=0}}function Oe(e,t,n,r){return b?it(3,1,e,t,n,r):Te(e,t,n,r)}function Te(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,typeof SharedArrayBuffer>"u")return T("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?Oe(e,t,n,r):(e={Gb:n,Xa:e,rb:r,Mb:a},b?(e.Ob="spawnThread",postMessage(e,a),0):$e(e))}function Re(e,t,n){return b?it(4,1,e,t,n):0}function ke(e,t){if(b)return it(5,1,e,t)}c.establishStackSpace=function(){var e=kt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],Vt(t,t-e),Ft(t)},c.invokeEntryPoint=function(e,t){e=Lt.apply(null,[e,t]),X()?Ce.kb(e):Nt(e)};var Be=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Me=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},De=(e,t,n)=>Me(e,r(),t,n);function Pe(e,t){if(b)return it(6,1,e,t)}function ze(e,t,n){if(b)return it(7,1,e,t,n)}function We(e,t,n){return b?it(8,1,e,t,n):0}function Ne(e,t){if(b)return it(9,1,e,t)}function Ge(e,t,n){if(b)return it(10,1,e,t,n)}function Ue(e,t,n,r){if(b)return it(11,1,e,t,n,r)}function Ve(e,t,n,r){if(b)return it(12,1,e,t,n,r)}function je(e,t,n,r){if(b)return it(13,1,e,t,n,r)}function Fe(e){if(b)return it(14,1,e)}function He(e,t){if(b)return it(15,1,e,t)}function Le(e,t,n){if(b)return it(16,1,e,t,n)}var qe=e=>{if(!j)try{if(e(),!X())try{b?Nt(D):_e(D)}catch(e){e instanceof ge||"unwind"==e||y(1,e)}}catch(e){e instanceof ge||"unwind"==e||y(1,e)}};function Ye(e){e>>>=0,"function"==typeof Atomics.Nb&&(Atomics.Nb(a(),e>>2,e).value.then(Ke),e+=128,Atomics.store(a(),e>>2,1))}function Ke(){var e=kt();e&&(Ye(e),qe((()=>Gt())))}c.__emscripten_thread_mailbox_await=Ye,c.checkMailbox=Ke;var Xe=e=>e%4==0&&(e%100!=0||e%400==0),Je=[0,31,60,91,121,152,182,213,244,274,305,335],Qe=[0,31,59,90,120,151,181,212,243,273,304,334];function Ze(e,t,n,r,a,i,o,s){return b?it(17,1,e,t,n,r,a,i,o,s):-52}function et(e,t,n,r,a,i,o){if(b)return it(18,1,e,t,n,r,a,i,o)}var tt=e=>{var t=Be(e)+1,n=Bt(t);return n&&De(e,n,t),n},nt=[],rt=(e,t)=>{var n;for(nt.length=0,t>>=2;n=r()[e++>>>0];)t+=105!=n&t,nt.push(105==n?a()[t>>>0]:u()[t++>>>1]),++t;return nt},at=e=>{var t=jt();return e=e(),Ft(t),e};function it(e,t){var n=arguments.length-2,r=arguments;return at((()=>{for(var a=Ht(8*n),i=a>>3,o=0;o<n;o++){var s=r[2+o];u()[i+o>>>0]=s}return zt(e,n,a,t)}))}var ot,st=[],ut={},lt=()=>{if(!ot){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in ut)void 0===ut[e]?delete t[e]:t[e]=ut[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);ot=n}return ot};function dt(e,n){if(b)return it(19,1,e,n);e>>>=0,n>>>=0;var r=0;return lt().forEach((function(a,o){var s=n+r;for(o=i()[e+4*o>>2>>>0]=s,s=0;s<a.length;++s)t()[o++>>0>>>0]=a.charCodeAt(s);t()[o>>0>>>0]=0,r+=a.length+1})),0}function ct(e,t){if(b)return it(20,1,e,t);e>>>=0,t>>>=0;var n=lt();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function pt(e){return b?it(21,1,e):52}function ft(e,t,n,r){return b?it(22,1,e,t,n,r):52}function ht(e,t,n,r,a){return b?it(23,1,e,t,n,r,a):70}var mt=[null,[],[]];function gt(e,t,n,a){if(b)return it(24,1,e,t,n,a);t>>>=0,n>>>=0,a>>>=0;for(var o=0,s=0;s<n;s++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var d=0;d<l;d++){var c=r()[u+d>>>0],p=mt[e];0===c||10===c?((1===e?O:T)(be(p,0)),p.length=0):p.push(c)}o+=l}return i()[a>>2>>>0]=o,0}var yt=[31,29,31,30,31,30,31,31,30,31,30,31],wt=[31,28,31,30,31,30,31,31,30,31,30,31];function $t(e,n,r,i){function o(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return o(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function l(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function d(e){var t=e.Za;for(e=new Date(new Date(e.$a+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?yt:wt)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=l(new Date(e.getFullYear(),0,4)),n=l(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,n>>>=0,r>>>=0,i>>>=0;var c=a()[i+40>>2>>>0];for(var p in i={Kb:a()[i>>2>>>0],Jb:a()[i+4>>2>>>0],cb:a()[i+8>>2>>>0],ib:a()[i+12>>2>>>0],eb:a()[i+16>>2>>>0],$a:a()[i+20>>2>>>0],Wa:a()[i+24>>2>>>0],Za:a()[i+28>>2>>>0],Tb:a()[i+32>>2>>>0],Ib:a()[i+36>>2>>>0],Lb:c?xe(c):""},r=xe(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),c[p]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(p in c={"%a":e=>f[e.Wa].substring(0,3),"%A":e=>f[e.Wa],"%b":e=>h[e.eb].substring(0,3),"%B":e=>h[e.eb],"%C":e=>s((e.$a+1900)/100|0,2),"%d":e=>s(e.ib,2),"%e":e=>o(e.ib,2," "),"%g":e=>d(e).toString().substring(2),"%G":e=>d(e),"%H":e=>s(e.cb,2),"%I":e=>(0==(e=e.cb)?e=12:12<e&&(e-=12),s(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.eb-1;t+=(Xe(e.$a+1900)?yt:wt)[n++]);return s(e.ib+t,3)},"%m":e=>s(e.eb+1,2),"%M":e=>s(e.Jb,2),"%n":()=>"\n","%p":e=>0<=e.cb&&12>e.cb?"AM":"PM","%S":e=>s(e.Kb,2),"%t":()=>"\t","%u":e=>e.Wa||7,"%U":e=>s(Math.floor((e.Za+7-e.Wa)/7),2),"%V":e=>{var t=Math.floor((e.Za+7-(e.Wa+6)%7)/7);if(2>=(e.Wa+371-e.Za-2)%7&&t++,t)53==t&&(4==(n=(e.Wa+371-e.Za)%7)||3==n&&Xe(e.$a)||(t=1));else{t=52;var n=(e.Wa+7-e.Za-1)%7;(4==n||5==n&&Xe(e.$a%400-1))&&t++}return s(t,2)},"%w":e=>e.Wa,"%W":e=>s(Math.floor((e.Za+7-(e.Wa+6)%7)/7),2),"%y":e=>(e.$a+1900).toString().substring(2),"%Y":e=>e.$a+1900,"%z":e=>(0<=(e=e.Ib)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.Lb,"%%":()=>"%"},r=r.replace(/%%/g,"\0\0"),c)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),c[p](i)));return p=function(e){var t=Array(Be(e)+1);return Me(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),p.length>n?0:(((e,n)=>{t().set(e,n>>>0)})(p,e),p.length-1)}function vt(e){try{e()}catch(e){re(e)}}var bt=0,xt=null,St=0,_t=[],Ct={},Et={},It=0,At=null,Ot=[];Ce.gb();var Tt=[null,Se,Ie,Oe,Re,ke,Pe,ze,We,Ne,Ge,Ue,Ve,je,Fe,He,Le,Ze,et,dt,ct,pt,ft,ht,gt],Rt={r:function(e,t,n){return function(e){return function(e){if(!j){if(0===bt){var t=!1,n=!1;e(((e=0)=>{if(!j&&(St=e,t=!0,n)){bt=2,vt((()=>Kt(xt))),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),e=!1;try{var r=function(){var e=a()[xt+8>>2>>>0];return e=B[Et[e]],--K,e()}()}catch(t){r=t,e=!0}var i=!1;if(!xt){var o=At;o&&(At=null,(e?o.reject:o.resolve)(r),i=!0)}if(e&&!i)throw r}})),n=!0,t||(bt=1,xt=function(){var e=Bt(65548),t=e+12;i()[e>>2>>>0]=t,i()[e+4>>2>>>0]=t+65536,t=_t[0];var n=Ct[t];return void 0===n&&(n=It++,Ct[t]=n,Et[n]=t),t=n,a()[e+8>>2>>>0]=t,e}(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),vt((()=>qt(xt))))}else 2===bt?(bt=0,vt(Xt),Mt(xt),xt=null,Ot.forEach((e=>qe(e)))):re(`invalid state: ${bt}`);return St}}((t=>{e().then(t)}))}((async()=>{await c.xb(e,t,n)}))},b:function(e,t,n){throw new Ae(e>>>=0).gb(t>>>0,n>>>0),e},O:function(e){Dt(e>>>0,!$,1,!w,131072,!1),Ce.lb()},l:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):we(e)},I:Te,i:Re,U:ke,E:Pe,G:ze,V:We,S:Ne,K:Ge,R:Ue,p:Ve,F:je,C:Fe,T:He,D:Le,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>Ke())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=Ce.Qa[e])&&e.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Ye,X:function(e){v&&Ce.Qa[e>>>0].ref()},u:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getUTCSeconds(),a()[n+4>>2>>>0]=e.getUTCMinutes(),a()[n+8>>2>>>0]=e.getUTCHours(),a()[n+12>>2>>>0]=e.getUTCDate(),a()[n+16>>2>>>0]=e.getUTCMonth(),a()[n+20>>2>>>0]=e.getUTCFullYear()-1900,a()[n+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[n+28>>2>>>0]=e},v:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getSeconds(),a()[n+4>>2>>>0]=e.getMinutes(),a()[n+8>>2>>>0]=e.getHours(),a()[n+12>>2>>>0]=e.getDate(),a()[n+16>>2>>>0]=e.getMonth(),a()[n+20>>2>>>0]=e.getFullYear()-1900,a()[n+24>>2>>>0]=e.getDay(),t=(Xe(e.getFullYear())?Je:Qe)[e.getMonth()]+e.getDate()-1|0,a()[n+28>>2>>>0]=t,a()[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t)),a()[n+32>>2>>>0]=e},w:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(o,i);return 0>n?a()[e+32>>2>>>0]=+(i!=o&&s==r):0<n!=(s==r)&&(i=Math.max(o,i),t.setTime(t.getTime()+6e4*((0<n?s:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(Xe(t.getFullYear())?Je:Qe)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Ut((he=e,1<=+Math.abs(he)?0<he?+Math.floor(he/4294967296)>>>0:~~+Math.ceil((he-+(~~he>>>0))/4294967296)>>>0:0)),e>>>0},s:Ze,t:et,z:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var o=(new Date).getFullYear(),s=new Date(o,0,1),u=new Date(o,6,1);o=s.getTimezoneOffset();var l=u.getTimezoneOffset(),d=Math.max(o,l);i()[e>>2>>>0]=60*d,a()[t>>2>>>0]=+(o!=l),e=r(s),t=r(u),e=tt(e),t=tt(t),l<o?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)},d:()=>{re("")},c:function(e,t,n){return e>>>=0,t=rt(t>>>0,n>>>0),me[e].apply(null,t)},k:function(e,t,n){return e>>>=0,t=rt(t>>>0,n>>>0),me[e].apply(null,t)},m:function(){},j:function(){return Date.now()},W:()=>{throw K+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return v?(No(),N(fe)).cpus().length:navigator.hardwareConcurrency},L:function(e,t,n,r){for(Ce.Pb=t>>>0,st.length=n,t=r>>>0>>3,r=0;r<n;r++)st[r]=u()[t+r>>>0];return(0>e?me[-e-1]:Tt[e]).apply(null,st)},y:function(e){e>>>=0;var t=r().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var i=Math;a=Math.max(e,a);e:{i=i.min.call(i,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(i),F();var o=1;break e}catch{}o=void 0}if(o)return!0}return!1},P:dt,Q:ct,H:_e,h:pt,o:ft,x:ht,n:gt,a:k||c.wasmMemory,J:$t,e:function(e,t,n,r){return $t(e>>>0,t>>>0,n>>>0,r>>>0)}};(function(){function e(e,t){return e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){_t.push(t);try{return r.apply(null,arguments)}finally{j||(_t.pop()===t||re(),xt&&1===bt&&0===_t.length&&(bt=0,K+=1,vt(Yt),typeof Fibers<"u"&&Fibers.Ub()))}}:r}(t);return n}(e=e.exports),B=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),Ce.mb.push(B.Da),q.unshift(B.Y),M=t,ne(),e}var t={a:Rt};if(te(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){T("Module.instantiateWasm callback failed with error: "+e),d(e)}(function(e,t){var n=J;return A||"function"!=typeof WebAssembly.instantiateStreaming||ie(n)||n.startsWith("file://")||v||"function"!=typeof fetch?de(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return T("wasm streaming compile failed: "+r),T("falling back to ArrayBuffer instantiation"),de(n,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(d)})(),c._OrtInit=(e,t)=>(c._OrtInit=B.Z)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=B._)(e,t),c._OrtCreateSessionOptions=(e,t,n,r,a,i,o,s,u,l)=>(c._OrtCreateSessionOptions=B.$)(e,t,n,r,a,i,o,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=B.aa)(e,t),c._OrtAddFreeDimensionOverride=(e,t,n)=>(c._OrtAddFreeDimensionOverride=B.ba)(e,t,n),c._OrtAddSessionConfigEntry=(e,t,n)=>(c._OrtAddSessionConfigEntry=B.ca)(e,t,n),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=B.da)(e),c._OrtCreateSession=(e,t,n)=>(c._OrtCreateSession=B.ea)(e,t,n),c._OrtReleaseSession=e=>(c._OrtReleaseSession=B.fa)(e),c._OrtGetInputOutputCount=(e,t,n)=>(c._OrtGetInputOutputCount=B.ga)(e,t,n),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=B.ha)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=B.ia)(e,t),c._OrtFree=e=>(c._OrtFree=B.ja)(e),c._OrtCreateTensor=(e,t,n,r,a,i)=>(c._OrtCreateTensor=B.ka)(e,t,n,r,a,i),c._OrtGetTensorData=(e,t,n,r,a)=>(c._OrtGetTensorData=B.la)(e,t,n,r,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=B.ma)(e),c._OrtCreateRunOptions=(e,t,n,r)=>(c._OrtCreateRunOptions=B.na)(e,t,n,r),c._OrtAddRunConfigEntry=(e,t,n)=>(c._OrtAddRunConfigEntry=B.oa)(e,t,n),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=B.pa)(e),c._OrtCreateBinding=e=>(c._OrtCreateBinding=B.qa)(e),c._OrtBindInput=(e,t,n)=>(c._OrtBindInput=B.ra)(e,t,n),c._OrtBindOutput=(e,t,n,r)=>(c._OrtBindOutput=B.sa)(e,t,n,r),c._OrtClearBoundOutputs=e=>(c._OrtClearBoundOutputs=B.ta)(e),c._OrtReleaseBinding=e=>(c._OrtReleaseBinding=B.ua)(e),c._OrtRunWithBinding=(e,t,n,r,a)=>(c._OrtRunWithBinding=B.va)(e,t,n,r,a),c._OrtRun=(e,t,n,r,a,i,o,s)=>(c._OrtRun=B.wa)(e,t,n,r,a,i,o,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=B.xa)(e),c._JsepOutput=(e,t,n)=>(c._JsepOutput=B.ya)(e,t,n),c._JsepGetNodeName=e=>(c._JsepGetNodeName=B.za)(e);var kt=c._pthread_self=()=>(kt=c._pthread_self=B.Aa)(),Bt=c._malloc=e=>(Bt=c._malloc=B.Ba)(e),Mt=c._free=e=>(Mt=c._free=B.Ca)(e);c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=B.Da)();var Dt=c.__emscripten_thread_init=(e,t,n,r,a,i)=>(Dt=c.__emscripten_thread_init=B.Fa)(e,t,n,r,a,i);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=B.Ga)();var Pt,zt=(e,t,n,r)=>(zt=B.Ha)(e,t,n,r),Wt=e=>(Wt=B.Ia)(e),Nt=c.__emscripten_thread_exit=e=>(Nt=c.__emscripten_thread_exit=B.Ja)(e),Gt=c.__emscripten_check_mailbox=()=>(Gt=c.__emscripten_check_mailbox=B.Ka)(),Ut=e=>(Ut=B.La)(e),Vt=(e,t)=>(Vt=B.Ma)(e,t),jt=()=>(jt=B.Na)(),Ft=e=>(Ft=B.Oa)(e),Ht=e=>(Ht=B.Pa)(e),Lt=c.dynCall_ii=(e,t)=>(Lt=c.dynCall_ii=B.Ra)(e,t),qt=e=>(qt=B.Sa)(e),Yt=()=>(Yt=B.Ta)(),Kt=e=>(Kt=B.Ua)(e),Xt=()=>(Xt=B.Va)();function Jt(){function e(){if(!Pt&&(Pt=!0,c.calledRun=!0,!j)&&(b||Ee(q),l(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();Y.unshift(e)}Ee(Y)}}if(!(0<Q))if(b)l(c),b||Ee(q),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)L.unshift(c.preRun.shift());Ee(L),0<Q||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.___start_em_js=925783,c.___stop_em_js=925944,c.keepRuntimeAlive=X,c.wasmMemory=k,c.stackAlloc=Ht,c.stackSave=jt,c.stackRestore=Ft,c.UTF8ToString=xe,c.stringToUTF8=De,c.lengthBytesUTF8=Be,c.ExitStatus=ge,c.PThread=Ce,ee=function e(){Pt||Jt(),Pt||(ee=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return Jt(),e.ready});"object"==typeof a&&"object"==typeof i?i.exports=s:void 0===(r=(()=>s).apply(t,[]))||(e.exports=r)})),Uo=z(((e,t)=>{t.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'})),Vo=P((()=>{me=de(),ge=Go(),we=!1,$e=!1,ve=!1,be=()=>{try{return!(typeof SharedArrayBuffer>"u")&&(typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},xe=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Se=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",_e=async e=>{if(we)return Promise.resolve();if($e)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ve)throw new Error("previous call to 'initializeWebAssembly()' failed.");$e=!0;let t=e.initTimeout,n=e.numThreads,r=e.simd,a=n>1&&be(),i=r&&xe(),o=e.wasmPaths,s="string"==typeof o?o:void 0,u=Se(i,a),l="object"==typeof o?o[u]:void 0,d=!1,c=[];if(t>0&&c.push(new Promise((e=>{setTimeout((()=>{d=!0,e()}),t)}))),c.push(new Promise(((e,t)=>{let n=a?ge:me,r={locateFile:(e,t)=>{if(a&&e.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Uo()],{type:"text/javascript"}));if(e.endsWith(".wasm")){if(l)return l;let e=s??t;return"ort-wasm-simd.wasm"===u?e+"ort-wasm-simd.jsep.wasm":"ort-wasm-simd-threaded.wasm"===u?e+"ort-wasm-simd-threaded.jsep.wasm":e+u}return t+e}};if(a)if(typeof Blob>"u")r.mainScriptUrlOrBlob=(void 0)("/","ort-wasm-threaded.js");else{let e=`var ortWasmThreaded=${n.toString()};`;r.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(r).then((t=>{$e=!1,we=!0,ye=t,e()}),(e=>{$e=!1,ve=!0,t(e)}))}))),await Promise.race(c),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ce=()=>{if(we&&ye)return ye;throw new Error("WebAssembly is not initialized yet.")}})),jo=P((()=>{Vo(),Ee=(e,t)=>{let n=Ce(),r=n.lengthBytesUTF8(e)+1,a=n._malloc(r);return n.stringToUTF8(e,a,r),t.push(a),a},Ie=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,a])=>{let i=t?t+e:e;if("object"==typeof a)Ie(a,i+".",n,r);else if("string"==typeof a||"number"==typeof a)r(i,a.toString());else{if("boolean"!=typeof a)throw new Error("Can't handle extra config type: "+typeof a);r(i,a?"1":"0")}}))},Ae=e=>{let t=Ce(),n=t.stackSave();try{let n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);let r=t.HEAP32[n/4],a=t.HEAPU32[n/4+1],i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}})),Fo=P((()=>{Vo(),jo(),Oe=e=>{let t=Ce(),n=0,r=[],a=e||{};try{if(void 0===e?.logSeverityLevel)a.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)a.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(a.terminate=!1);let i=0;return void 0!==e?.tag&&(i=Ee(e.tag,r)),n=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,i),0===n&&Ae("Can't create run options."),void 0!==e?.extra&&Ie(e.extra,"",new WeakSet,((e,a)=>{let i=Ee(e,r),o=Ee(a,r);0!==t._OrtAddRunConfigEntry(n,i,o)&&Ae(`Can't set a run config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),Ho=P((()=>{Vo(),jo(),Te=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Re=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},ke=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},Be=(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof r){let t=r;if(t?.deviceType){let r=Ee("deviceType",n),a=Ee(t.deviceType,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'deviceType' - ${t.deviceType}.`)}if(t?.powerPreference){let r=Ee("powerPreference",n),a=Ee(t.powerPreference,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'powerPreference' - ${t.powerPreference}.`)}}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);let r=Ee("preferredLayout",n),a=Ee(t.preferredLayout,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'preferredLayout' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=Ee(t,n);0!==Ce()._OrtAppendExecutionProvider(e,a)&&Ae(`Can't append execution provider: ${t}.`)}},Me=e=>{let t=Ce(),n=0,r=[],a=e||{};ke(a);try{let e=Te(a.graphOptimizationLevel??"all"),i=Re(a.executionMode??"sequential"),o="string"==typeof a.logId?Ee(a.logId,r):0,s=a.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw new Error(`log serverity level is not valid: ${s}`);let u=a.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let l="string"==typeof a.optimizedModelFilePath?Ee(a.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!a.enableCpuMemArena,!!a.enableMemPattern,i,!!a.enableProfiling,0,o,s,u,l),0===n&&Ae("Can't create session options."),a.executionProviders&&Be(n,a.executionProviders,r),a.freeDimensionOverrides)for(let[e,i]of Object.entries(a.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof i||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let a=Ee(e,r);0!==t._OrtAddFreeDimensionOverride(n,a,i)&&Ae(`Can't set a free dimension override: ${e} - ${i}.`)}return void 0!==a.extra&&Ie(a.extra,"",new WeakSet,((e,a)=>{let i=Ee(e,r),o=Ee(a,r);0!==t._OrtAddSessionConfigEntry(n,i,o)&&Ae(`Can't set a session config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseSessionOptions(n),r.forEach((e=>t._free(e))),e}}})),Lo=P((()=>{De=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Pe=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ze=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],We=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ne=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ge=e=>"float32"===e||"int32"===e||"int64"===e||"bool"===e||"float16"===e||"uint32"===e,Ue=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}})),qo=P((()=>{Lo(),Ve=["V","I","W","E","F"],je=(e,t)=>{console.log(`[${Ve[e]},${(new Date).toISOString()}]${t}`)},Le=(e,t)=>{Fe=e,He=t},qe=(e,t)=>{let n=Ne(e);n>=Ne(Fe)&&je(n,"function"==typeof t?t():t)},Ye=(...e)=>{He&&qe(...e)}})),Yo=P((()=>{Lo(),Ke=(e,t)=>new(We(t))(e)})),Ko=P((()=>{})),Xo=P((()=>{qo(),Ko(),Xe=e=>16*Math.ceil(e/16),Je=1,Qe=()=>Je++,Ze=async(e,t,n,r)=>{let a=Xe(n),i=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=e.getCommandEncoder();e.endComputePass(),o.copyBufferToBuffer(t,0,i,0,a),e.flush(),await i.mapAsync(GPUMapMode.READ);let s=i.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(s,0,n)),e}return new Uint8Array(s.slice(0,n))}finally{i.destroy()}},et=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,t){let n=t.buffer,r=t.byteOffset,a=t.byteLength,i=Xe(a),o=this.storageCache.get(e);if(!o)throw new Error("gpu data for uploading does not exist");if(o.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${a}`);let s=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=s.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,r,a)),s.unmap();let l=this.backend.getCommandEncoder();this.backend.endComputePass(),l.copyBufferToBuffer(s,0,o.gpuData.buffer,0,i),Ye("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(s)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=Xe(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}registerExternalBuffer(e,t,n){let r;if(n){if(r=this.externalBuffers.get(n),void 0===r)throw new Error("previous buffer is not registered");if(e===n)return Ye("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;this.externalBuffers.delete(n)}else r=Qe();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),this.externalBuffers.set(e,r),Ye("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){let t=this.externalBuffers.get(e);void 0!==t&&(this.storageCache.delete(t),this.externalBuffers.delete(e),Ye("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=Xe(e),a=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||i){let e=a?this.freeBuffers:this.freeUniformBuffers,i=e.get(r);i||(i=[],e.set(r,i)),n=i.length>0?i.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let o={id:Qe(),type:0,buffer:n};return this.storageCache.set(o.id,{gpuData:o,originalSize:e}),Ye("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${o.id}`)),o}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return Ye("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");await Ze(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},tt=(...e)=>new et(...e)})),Jo=P((()=>{nt=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}},rt=e=>new nt(e)})),Qo=P((()=>{at=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},it=class{static calcShape(e,t,n=!1){let r=e.length,a=t.length;if(0===r)return t;if(0===a)return e;let i=Math.max(e.length,t.length),o=new Array(i);if(n){if(r<2||a<2)return;let n=at.calcMatMulShape([e[r-2],e[r-1]],[t[a-2],t[a-1]]);if(void 0===n)return;[o[i-2],o[i-1]]=n}for(let s=n?3:1;s<=i;s++){let n=r-s<0?1:e[r-s],u=a-s<0?1:t[a-s];if(n!==u&&n>1&&u>1)return;o[i-s]=Math.max(n,u)}return o}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(1!==e[n-a]&&e[n-a]!==t[r-a])return!1;return!0}},ot=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let a=t;a<n;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=e[a]}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},st=class e{static adjustPoolAttributes(e,t,n,r,a,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,a,i,o,s){if(s){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<t.length-2;u++)e.adjustPadAndReturnShape(t[u+(o?1:2)],n[u],r[u],a[u],i,u,u+t.length-2,s)}}static computePoolOutputShape(t,n,r,a,i,o,s){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return e.computeShapeHelper(t,n,u,r,a,i,o,s),u}static computeConvOutputShape(t,n,r,a,i,o,s){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[t[0],n[0]];return e.computeShapeHelper(!1,t,u,r,a,i,o,s),u}static computeShapeHelper(t,n,r,a,i,o,s,u){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],a[t],i[t],o[t],s,t,t+n.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,a,i,o,s){let u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[i]+a[o]-u)/t+1);switch(s){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return a[i]=Math.floor("SAME_LOWER"===s?(n+1)/2:n/2),a[o]=n-a[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},ut=class{static getShapeOfGemmResult(e,t,n,r,a){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,o,s;t?(i=e[1],o=e[0]):(i=e[0],o=e[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==o)throw new Error("dimension mismatch");if(i<=0||s<=0||o<=0)throw new Error("invalid shape specified");if(a&&!it.isValidBroadcast(a,[i,s]))throw new Error("gemm: invalid bias shape for broadcast");return[i,s,o]}},lt=-34028234663852886e22,dt=34028234663852886e22})),Zo=P((()=>{Lo(),Qo(),ct=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},pt=(e,t=1)=>{let n=ct(e,t);return"string"==typeof n?n:n[0]},ft=e=>[{type:"uint32",data:e},{type:"uint32",data:ot.computeStrides(e)}],ht=e=>e%4==0?4:e%2==0?2:1,mt=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,gt=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}f(${n})`,yt=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,wt=(e,t,n,r,a)=>{let i="number"==typeof n,o=i?n:n.length,s=[...new Array(o).keys()],u=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,l=ct(t,a),d="string"==typeof l?l:l[1],c="string"==typeof l?l:l[0],p={indices:u,value:d,storage:c,tensor:t},f=e=>"string"==typeof e?e:`${e}u`,h={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=i?"uniforms.":"",g=`${m}${e}_shape`,y=`${m}${e}_strides`,w="";for(let e=0;e<o-1;e++)w+=`\n    let dim${e} = current / ${y}[${e}];\n    let rest${e} = current % ${y}[${e}];\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;w+=`indices[${o-1}] = current;`;let $=o<2?"":`\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\n    var indices: ${p.indices};\n    var current = offset;\n    ${w}\n    return indices;\n  }`,v=[];if(o>=2)for(let e=o-1;e>=0;e--)v.push(`${y}[${e}] * (indices[${e}])`);let b=o<2?"":`\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\n    return ${v.join("+")};\n  }`,x=(...e)=>0===o?"0u":`${p.indices}(${e.map(f).join(",")})`,S=(e,t)=>o<2?`${e}`:`${e}[${t}]`,_={},C=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),E=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),I=o<2?"":`\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${d} {\n    return ${E(`i2o_${e}(indices)`)};\n  }`,A=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn get_${e}(${t}) -> ${d} {\n    return get_${e}ByIndices(${x(n)});\n  }`})(),O=o<2?"":`\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${d}) {\n    ${C(`i2o_${e}(indices)`,"value")}\n  }`,T=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn set_${e}(${t}, value: ${d}) {\n    set_${e}ByIndices(${x(n)}, value);\n  }`})();return{impl:()=>{let e=[];return i||(e.push(`const ${g} = ${p.indices}(${n.join(",")});`),e.push(`const ${y} = ${p.indices}(${ot.computeStrides(n).join(",")});`)),h.offsetToIndices&&e.push($),h.indicesToOffset&&e.push(b),h.broadcastedIndicesToOffset&&Object.values(_).forEach((t=>e.push(t))),h.set&&e.push(T),h.setByIndices&&e.push(O),h.get&&e.push(A),h.getByIndices&&e.push(I),e.join("\n")},type:p,offsetToIndices:t=>(h.offsetToIndices=!0,o<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(h.indicesToOffset=!0,o<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{h.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in _)return`${r}(${t})`;let a=[];for(let e=o-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-o);a.push(`${S(y,e)} * (${t} % ${S(g,e)})`)}return _[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${a.length>0?a.join("+"):"0u"};\n           }`,`${r}(${t})`},indices:x,indicesGet:S,indicesSet:(e,t,n)=>o<2?`${e}=${n};`:`${e}[${t}]=${n};`,set:(...t)=>{if(t.length!==o+1)throw new Error(`indices length must be ${o}`);let n=t[o];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,o).map(f).join(",");return 0===o?C("0u",n):1===o?C(r[0],n):(h.set=!0,h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:C,setByIndices:(t,n)=>o<2?C(t,n):(h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==o)throw new Error(`indices length must be ${o}`);let n=t.map(f).join(",");return 0===o?E("0u"):1===o?E(n[0]):(h.get=!0,h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:E,getByIndices:t=>o<2?E(t):(h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r?"input":"output",name:e,strides:y,shape:g,rank:o}},$t=(e,t,n,r=1)=>wt(e,t,n,!0,r),vt=(e,t,n,r=1)=>wt(e,t,n,!1,r),bt=class{constructor(e){this.normalizedDispatchGroup=e,this.indicesHelpers=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=64){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2],a=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\n  fn main(${a?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\n    ${a?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${t*n*r}u + local_index;`}\n  `}declareVariable(e,t){this.indicesHelpers.push(e),e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:e.type.indices}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:e.type.indices});let n="input"===e.usage?"read":"read_write",r=e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\n")}registerUniform(e,t){return this.uniforms.push({name:e,type:t}),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n}of this.uniforms)e.push(`${t}:${n}`);return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map((e=>e.impl())).join("\n")}},xt=e=>new bt(e),St=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;a++){let i=n-1-a,o=e[i]||1;(t[t.length-1-a]||1)>1&&1===o&&r.unshift(i)}return r},_t=e=>e<=4})),es=P((()=>{Qo(),Jo(),Zo(),Ct=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.")},Et=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,It=(e,t)=>ot.sortBasedOnPerm(e,Et(e.length,t)),At=(e,t,n,r)=>{let a=[];a.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)a.push(n.indicesSet("a",e[r],`i[${r}]`));return a.push("return a;}"),a.join("\n")},Ot=(e,t)=>{let n=e.dataType,r=e.dims.length,a=Et(r,t),i=_t(r),o=It(e.dims,a),s=i?o.length:o,u=i?r:e.dims,l=vt("output",n,s),d=$t("a",n,u);return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:i?["rank"]:["dims"]},getRunData:e=>{let t=ot.size(o);return{outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:i?[{type:"uint32",data:t},...ft(e[0].dims),...ft(o)]:[{type:"uint32",data:t}]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(d,l)}\n\n  ${At(a,r,d,l)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${l.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${l.setByOffset("global_idx",d.getByIndices("aIndices"))}\n  }`}},Tt=(e,t)=>{Ct(e.inputs),e.compute(Ot(e.inputs[0],t.perm))},Rt=e=>rt({perm:e.perm})})),ts=P((()=>{Qo(),Zo(),ns(),es(),kt={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Bt={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Mt={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Dt={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Pt=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},zt=(e,t)=>{let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]},Wt=(e,t)=>{let n=e.length+t.length,r=[],a=0;for(let i=0;i<n;i++)-1===t.indexOf(i)?r.push(e[a++]):r.push(1);return r},Nt=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Gt=(e,t)=>{let n=[];if(!Nt(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},Ut=(e,t,n,r,a,i,o)=>{let s=n[0].dims,u=ot.size(i),l=ot.size(o),d=$t("_A",n[0].dataType,s),c=vt("output",a,i),p=`\n          var<workgroup> aBestValues : array<${c.type.storage}, 32>;\n       `;return{name:e,shaderCache:t,getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,c)}\n        ${p}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(32)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / 32;\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${c.type.storage}(${Mt[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + 32) {\n           let candidate = ${c.type.storage}(${d.getByOffset("offset + k")});\n           bestValue = ${kt[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, 32u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${Bt[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${c.setByOffset("outputIndex","mean"===r?`bestValue / ${c.type.storage}(uniforms.reduceSize)`:`${Dt[r]}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:u},programUniforms:[{type:"uint32",data:l}]})}},Vt=(e,t,n,r)=>{let a=1===e.inputs.length?n:nn(e.inputs,n),i=a.axes;0===i.length&&!a.noopWithEmptyAxes&&(i=e.inputs[0].dims.map(((e,t)=>t)));let o=ot.normalizeAxes(i,e.inputs[0].dims.length),s=o,u=e.inputs[0],l=Gt(s,e.inputs[0].dims.length);l.length>0&&(u=e.compute(Ot(e.inputs[0],l),{inputs:[0],outputs:[-1]})[0],s=Pt(s.length,u.dims.length));let[d,c]=zt(u.dims,s),p=d;a.keepDims&&(p=Wt(d,o)),e.compute(Ut(t,{hint:a.cacheKey,inputDependencies:["type"]},[u],r,e.inputs[0].dataType,p,c),{inputs:[u]})},jt=(e,t)=>{Vt(e,"ReduceMeanShared",t,"mean")},Ft=(e,t)=>{Vt(e,"ReduceL1Shared",t,"l1")},Ht=(e,t)=>{Vt(e,"ReduceL2Shared",t,"l2")},Lt=(e,t)=>{Vt(e,"ReduceLogSumExpShared",t,"logSumExp")},qt=(e,t)=>{Vt(e,"ReduceMaxShared",t,"max")},Yt=(e,t)=>{Vt(e,"ReduceMinShared",t,"min")},Kt=(e,t)=>{Vt(e,"ReduceProdShared",t,"prod")},Xt=(e,t)=>{Vt(e,"ReduceSumShared",t,"sum")},Jt=(e,t)=>{Vt(e,"ReduceSumSquareShared",t,"sumSquare")},Qt=(e,t)=>{Vt(e,"ReduceLogSumShared",t,"logSum")}})),ns=P((()=>{Qo(),Jo(),Zo(),ts(),Zt=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},en=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],tn=(e,t,n,r,a,i,o=!1,s=!1)=>{let u=[],l=n[0].dims,d=ot.normalizeAxes(a,n[0].dims.length),c=!s&&0===d.length;l.forEach(((e,t)=>{c||d.indexOf(t)>=0?o&&u.push(1):u.push(e)}));let p=[],f=$t("_A",n[0].dataType,l),h=vt("output",i,u),m=r(f,h,d),g=`inputOffset = ${f.indicesToOffset("inputIndices")};`,y=`let ${g};`,w=`var ${g};`,$=""===m[1]?"":w,v=(""===m[1]?y:g)+"\n"+m[2];for(let e=0,t=0;e<n[0].dims.length;e++)c||d.indexOf(e)>=0?(o&&t++,v=`for(var j${e}: u32 = 0; j${e} < ${n[0].dims[e]}; j${e}++) {\n                ${m[2].includes("lastIndex")?`let lastIndex = j${e};`:""}\n                ${f.indicesSet("inputIndices",e,`j${e}`)}\n                ${v}\n              }`):(p.push(`${f.indicesSet("inputIndices",e,h.indicesGet("outputIndices",t))};`),t++);let b=ot.size(u);return{name:e,shaderCache:t,getShaderSource:e=>`\n        ${e.declareVariables(f,h)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n          var inputIndices: ${f.type.indices};\n          let outputIndices = ${h.offsetToIndices("global_idx")};\n\n          ${p.join("\n")}\n          ${m[0]}       // init ops for reduce max/min\n          ${$}\n          ${m[1]}\n          ${v}\n          ${m[3]}\n          ${4===m.length?h.setByOffset("global_idx","value"):m.slice(4).join("\n")}\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(b/64)}})}},nn=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),rt({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rn=(e,t,n,r)=>{let a=e.inputs,i=1===a.length?n:nn(a,n);e.compute(tn(t,{hint:i.cacheKey},[a[0]],i.noopWithEmptyAxes&&0===i.axes.length?en:r,i.axes,a[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},an=(e,t)=>{Zt(e.inputs),rn(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,"value = log(value);"]))},on=(e,t)=>{Zt(e.inputs),rn(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByOffset("inputOffset")});`,""]))},sn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"]))},un=(e,t)=>{Zt(e.inputs),rn(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByOffset("inputOffset")});`,"value = log(value);"]))},ln=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("inputIndices",t,0));return[`${r.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = max(value, ${e.getByOffset("inputOffset")});`,""]}))},dn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMean",t,((t,n,r)=>{let a=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(a*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${a});`]}))},cn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`inputIndices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = min(value, ${e.getByOffset("inputOffset")});`,""]}))},pn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByOffset("inputOffset")};`,""]))},fn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,""]))},hn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += t * t;`,""]))},mn=(e,t,n)=>{if(0===t.length)return!!n;let r=1,a=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:a*=e[n];return a<32&&r>1024},gn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dn(e,t):jt(e,t)},yn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?on(e,t):Ft(e,t)},wn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?sn(e,t):Ht(e,t)},$n=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?un(e,t):Lt(e,t)},vn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ln(e,t):qt(e,t)},bn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cn(e,t):Yt(e,t)},xn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pn(e,t):Kt(e,t)},Sn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fn(e,t):Xt(e,t)},_n=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hn(e,t):Jt(e,t)},Cn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?an(e,t):Qt(e,t)},En=e=>rt(e)})),rs=P((()=>{Lo(),Jo(),ns(),In=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},An=(e,t)=>rt({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),On=(e,t)=>{In(e.inputs);let n=1===e.inputs.length?t:An(e.inputs,t);e.compute(tn("ArgMin",{hint:n.cacheKey},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]}),[n.axis],7,n.keepDims),{inputs:[0]})},Tn=(e,t)=>{In(e.inputs);let n=1===e.inputs.length?t:An(e.inputs,t);e.compute(tn("argMax",{hint:n.cacheKey},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]}),[n.axis],7,n.keepDims),{inputs:[0]})},Rn=e=>rt(e)})),as=P((()=>{Qo(),Zo(),kn=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Bn=e=>{let t=e[0].dims,n=e[0].dims[2],r=ot.size(t)/4,a=e[0].dataType,i=$t("input",a,t,4),o=$t("bias",a,[n],4),s=$t("residual",a,t,4),u=vt("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(i,o,s,u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${i.getByOffset("global_idx")}\n      + ${o.getByOffset("global_idx % channels")} + ${s.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx","value")}\n  }`}},Mn=e=>{kn(e.inputs),e.compute(Bn(e.inputs))}})),is=P((()=>{Lo(),Qo(),Jo(),Zo(),Dn=(e,t,n,r,a,i)=>{let o=Math.ceil(t/4),s="";s="string"==typeof a?`${a}(a)`:a("a");let u=$t("inputData",n,[o],4),l=vt("outputData",r,[o],4);return`\n  ${e.declareVariables(u,l)}\n\n  ${i??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    let a = ${u.getByOffset("global_idx")};\n    ${l.setByOffset("global_idx",s)}\n  }`},Pn=(e,t,n,r,a,i=e.dataType)=>({name:t,shaderCache:{hint:a},getShaderSource:t=>Dn(t,ot.size(e.dims),e.dataType,i,n,r),getRunData:t=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(ot.size(t[0].dims)/64/4)}})}),zn=e=>{e.compute(Pn(e.inputs[0],"Abs","abs"))},Wn=e=>{e.compute(Pn(e.inputs[0],"Acos","acos"))},Nn=e=>{e.compute(Pn(e.inputs[0],"Acosh","acosh"))},Gn=e=>{e.compute(Pn(e.inputs[0],"Asin","asin"))},Un=e=>{e.compute(Pn(e.inputs[0],"Asinh","asinh"))},Vn=e=>{e.compute(Pn(e.inputs[0],"Atan","atan"))},jn=e=>{e.compute(Pn(e.inputs[0],"Atanh","atanh"))},Fn=e=>rt(e),Hn=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Pn(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},Ln=(e,t)=>{let n=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<${n}> = vec4(${n}(${t.min}));\n    const clip_max_: vec4<${n}> = vec4(${n}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},qn=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:lt,n=e.length>=3?e[2].getFloat32Array()[0]:dt;return rt({min:t,max:n})},Yn=e=>{let t=qn(e.inputs);Ln(e,t)},Kn=e=>{e.compute(Pn(e.inputs[0],"Ceil","ceil"))},Xn=e=>{e.compute(Pn(e.inputs[0],"Cos","cos"))},Jn=e=>{e.compute(Pn(e.inputs[0],"Cosh","cosh"))},Qn=e=>rt(e),Zn=(e,t)=>{e.compute(Pn(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},er=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,tr=e=>{let t=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),er(`vec4<${t}>`,t)))},nr=e=>{e.compute(Pn(e.inputs[0],"Exp","exp"))},rr=e=>{e.compute(Pn(e.inputs[0],"Floor","floor"))},ar=e=>{let t=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),er(`vec4<${t}>`,t)))},ir=(e,t)=>{e.compute(Pn(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},or=e=>{e.compute(Pn(e.inputs[0],"Not",(e=>`!${e}`)))},sr=e=>{e.compute(Pn(e.inputs[0],"Neg",(e=>`-${e}`)))},ur=e=>{e.compute(Pn(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},lr=e=>{e.compute(Pn(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},dr=e=>{e.compute(Pn(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},cr=e=>{e.compute(Pn(e.inputs[0],"Sin","sin"))},pr=e=>{e.compute(Pn(e.inputs[0],"Sinh","sinh"))},fr=e=>{e.compute(Pn(e.inputs[0],"Sqrt","sqrt"))},hr=e=>{e.compute(Pn(e.inputs[0],"Tan","tan"))},mr=e=>{e.compute(Pn(e.inputs[0],"Tanh","tanh"))},gr=(e,t)=>(e.compute(Pn(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),yr=e=>{e.compute(Pn(e.inputs[0],"Log","log"))}})),os=P((()=>{Qo(),Zo(),is(),wr=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},$r=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=$t("input",e[0].dataType,e[0].dims,4),r=$t("bias",e[0].dataType,[e[0].dims[2]],4),a=vt("output",e[0].dataType,t,4),i=ot.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,r,a)}\n\n  ${er("vec4f")}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},vr=e=>{wr(e.inputs),e.compute($r(e.inputs))}})),ss=P((()=>{Lo(),Qo(),Zo(),br=(e,t,n,r,a,i,o,s,u,l,d)=>{let c,p,f=ot.size(r),h=Math.ceil(f/4);"string"==typeof o?c=p=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?c=p=o:(c=o.scalar,p=o.vector);let m,g="",y=vt("outputData",l,r,4),w=$t("aData",s,t,4),$=$t("bData",u,n,4);if(i){let e=e=>{let t=ot.computeStrides(e),n=[];for(let a=e.length-1;a>=0;a--){let i=y.indicesGet("outputIndices",a+r.length-e.length);n.push(`${t[a]}u * (${i} % ${e[a]}u)`)}return n.length>0?n.join("+"):"0u"};g=`\n          fn calcOffsetA(outputIndices: ${y.type.indices}) -> u32 {\n            return ${e(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${y.type.indices}) -> u32 {\n            return ${e(n)};\n          }\n        `}if(a)if(i){let e=1===ot.size(t),r=1===ot.size(n);m=e||r?y.setByOffset("global_idx",p(e?`${w.type.value}(${w.getByOffset("0")}.x)`:w.getByOffset("global_idx"),r?`${$.type.value}(${$.getByOffset("0")}.x)`:$.getByOffset("global_idx"))):`\n            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${y.setByOffset("global_idx",p(w.getByOffset("offsetA / 4u"),$.getByOffset("offsetB / 4u")))}\n          `}else m=y.setByOffset("global_idx",p(w.getByOffset("global_idx"),$.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${y.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = calcOffsetA(outputIndices${t});\n            let offsetB${t} = calcOffsetB(outputIndices${t});\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${c(r,a)});\n          `};m=9===l?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(w,$,y)}\n\n        ${d??""}\n        ${g}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n        ${m}\n      }`},xr=(e,t,n,r,a,i,o=n.dataType)=>{let s=!ot.areEqual(n.dims,r.dims),u=n.dims,l=ot.size(n.dims),d=!1;if(s){let e=it.calcShape(n.dims,r.dims,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");u=e,l=ot.size(u);let t=1===ot.size(n.dims),a=1===ot.size(r.dims),i=1;for(let e=1;e<u.length;e++){let t=n.dims[n.dims.length-e]??1;if(t!==(r.dims[r.dims.length-e]??1))break;i*=t}(i%4==0||t||a)&&(d=!0)}else d=!0;return{name:e,shaderCache:{hint:t},getShaderSource:e=>br(e,n.dims,r.dims,u,d,s,a,n.dataType,r.dataType,o,i),getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},Sr=(e,t,n,r,a,i)=>{e.compute(xr(t,a??"",e.inputs[0],e.inputs[1],n,r,i))},_r=e=>{Sr(e,"Add",((e,t)=>`${e}+${t}`))},Cr=e=>{Sr(e,"Div",((e,t)=>`${e}/${t}`))},Er=e=>{Sr(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},Ir=e=>{Sr(e,"Mul",((e,t)=>`${e}*${t}`))},Ar=e=>{let t=$t("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Sr(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Or=e=>{Sr(e,"Sub",((e,t)=>`${e}-${t}`))},Tr=e=>{Sr(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Rr=e=>{Sr(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},kr=e=>{Sr(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Br=e=>{Sr(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),us=P((()=>{Qo(),Jo(),Zo(),Mr=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,n=e[0].dims.length;for(let r of e){if(r.dataType!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}},Dr=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Pr=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;++a){let i=t.setByOffset("global_idx",e[a].getByIndices("indices"));1===n?r.push(i):0===a?r.push(`if (inputIndex == ${a}u) { ${i} }`):a===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${a}) { ${i} }`)}return r.join("\n")},zr=(e,t)=>{let n=e[0].dims.slice();if(t>=n.length||t<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");let r=t<0?n.length+t:t,a=n.slice(0);for(let t=1;t<e.length;t++){let i=e[t].dims.slice();for(let e=0;e<n.length;e++)if(e===r)a[r]+=i[e];else if(n[e]!==i[e])throw new Error("non concat dimensions must match")}let i=ot.size(a),o=new Array(e.length),s=new Array(e.length),u=e[0].dataType,l=0;for(let t=0;t<e.length;++t)l+=e[t].dims[r],o[t]=l,s[t]=$t(`input${t}`,u,e[t].dims);let d=vt("output",u,a),c=d.indicesGet("indices",r);return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n  ${e.declareVariables(...s,d)}\n\n  const sizeInConcatAxis = array<u32, ${o.length}>(${o.map((e=>`${e}u`)).join(",")});\n  ${Dr(o.length)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n    var indices = ${d.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${c});\n    if (inputIndex != 0u) {\n      ${c} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Pr(s,d)}\n  }`}},Wr=(e,t)=>{Mr(e.inputs),e.compute(zr(e.inputs,t.axis))},Nr=e=>rt({axis:e.axis})})),ls=P((()=>{Gr=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Ur=(e,t=!1,n=!1,r=3)=>"",Vr=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `})),ds=P((()=>{jr="\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n"})),cs=P((()=>{Qo(),Fr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Hr=e=>{let t=e?.activation||"";if("Clip"===t){let[n,r]=e?.activation_params||[lt,dt];return{activation:t,clipMax:r,clipMin:n,activationCacheKey:`${t}:${n},${r}`}}return{activation:t,activationCacheKey:t}}})),ps=P((()=>{Qo(),Zo(),cs(),ls(),Lr=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,qr=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Yr=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32)=>{let u=t[1]*e[1],l=t[0]*e[0],d=a?u:i,c=a?i:u,p=d/t[0],f=i/t[1];if((!a||4!==p||4!==e[1])&&(a||3!==p&&4!==p)||d%t[0]!=0||i%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${a} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${p} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${p}<${n}>, ${d/p}>, ${c}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${p};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${o?"0":"i32(globalId.z)"};\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let numTiles = ${o?`${Math.ceil(s/i)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${f};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Lr(a,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${qr(a,p)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Kr=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Xr=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Jr=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32,u=!1)=>{let l=e[1]*t[1],d=e[0]*t[0],c=a?l:i,p=a?i:l;if(p%t[1]!=0||c%t[0]!=0||i%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let f=p/t[1],h=c/t[0],m=i/t[1],g=u?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${l};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${Kr(a,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${l};\n\nlet tileRowA = i32(localId.y) * ${f};\nlet tileColA = i32(localId.x) * ${h};\nlet tileRowB = i32(localId.y) * ${m};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${h}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Kr(a,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Xr(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${o?"0":"i32(globalId.z)"};\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${o?`${Math.ceil(s/i)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${g}\n  }\n`},Qr=(e,t,n,r,a,i=!1)=>{let o=a[0],s=a[1],u=a[2],l=r[0],d=r[1],c=r[2],p=r[3],f=St(o,u),h=St(s,u),m=pt(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${Gr(e,m)} {\n      var value = ${Gr(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${(()=>{let e=d.rank,t=l.rank,n=`var aIndices: ${d.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\naIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return f.forEach((e=>{n+=`\naIndices[${e}] = 0;`})),n+=`\naIndices[${e-2}] = u32(row);\n                   aIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${Gr(e,m)} {\n      var value = ${Gr(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${(()=>{let e=c.rank,t=l.rank,n=`var bIndices: ${c.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\nbIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return h.forEach((e=>{n+=`\nbIndices[${e}] = 0;`})),n+=`\nbIndices[${e-2}] = u32(row);\n                   bIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${c.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Gr(e,m)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${i?"bias[colIn]":`${Gr(e,m)}(bias[row])`};`:""}\n        ${n}\n        ${p.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Zr=(e,t,n,r,a=!1)=>{let i=e[0].dims,o=e[1].dims,s=i.slice(0,-2),u=o.slice(0,-2),l=r?r.slice(0,-2):n.slice(0,-2),d=$t("batchDims",e[0].dataType,l),c=[d],p=[s,u,l],f=ot.size(l),h=i[i.length-2],m=i[i.length-1],g=o[o.length-1],y=m%4==0&&g%4==0,{activationFunction:w,applyActivation:$}=Fr(t,y),v=h<=8?[4,1,1]:[4,4,1],b=[8,8,1],x=[Math.ceil(g/b[0]/v[0]),Math.ceil(h/b[1]/v[1]),Math.ceil(f/b[2]/v[2])],S=pt(e[0].dataType),_=y?4:1,C=$t("a",e[0].dataType,[...s,h,m/_],_),E=$t("b",e[1].dataType,[...u,m,g/_],_),I=vt("result",e[0].dataType,[f,h,g/_],_);c.push(C),c.push(E),c.push(I);let A=[C,E],O=e.length>2,T=Qr(_,O,$,c,p,a);if(O){let t=a?_:1;A.push($t("bias",e[2].dataType,e[2].dims,t))}return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]}}),getShaderSource:e=>`\n  const dimAOuter: i32 = ${h};\n  const dimBOuter: i32 = ${g};\n  const dimInner: i32 = ${m};\n  ${e.declareVariables(...A,I)}\n  ${w}\n  ${T}\n  ${y?Yr(v,b,S,d):Jr(v,b,S,d)}\n                   ${d.impl()}`}}})),fs=P((()=>{qo(),Qo(),Zo(),ls(),ds(),ps(),ea=(e,t,n,r,a=!1,i,o=!1,s=4,u=4,l=4,d="f32")=>{let c=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",p=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",m=e?"row":"col",g=e?"col":"row",y=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${m} / outWidth;\n    let outCol = ${m} % outWidth;\n\n    let WRow = ${g} / (filterDims[1] * inChannels);\n    let WCol = ${g} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${g} % inChannels;\n    var resData = ${Gr(s,d)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\n      ${c}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(s)}\n    }\n    return resData;`,w=e?t&&r?`\n    let col = colIn * ${s};\n    ${y}`:`\n    let col = colIn * ${s};\n    if (row < dimAOuter && col < dimInner) {\n      ${y}\n    }\n    return ${Gr(s,d)}(0.0);`:r&&n?`\n    let col = colIn * ${s};\n    ${y}`:`\n    let col = colIn * ${s};\n    if (row < dimInner && col < dimBOuter) {\n      ${y}\n    }\n    return ${Gr(s,d)}(0.0);`,$=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,v=Gr(l,d),b=Gr(e?s:u,d),x=Gr(e?u:s,d);return`\n    ${Ur(i,o,4===l,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\n      ${e?w:$}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\n      ${e?$:w}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${v}) {\n      let col = colIn * ${l};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${p}\n      ${Vr(a,i)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ta=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],c=u?n[2]:n[3],p=u?n[1]:n[2],f=u?n[3]:n[1],h=u&&(l%4==0||l%3==0)&&f%4==0,m=u?f:c*p,g=u?c*p:f,y=[8,8,1],w=r<=8?[4,1,1]:[4,4,1],$=[Math.ceil(m/y[0]/w[0]),Math.ceil(g/y[1]/w[1]),Math.ceil(d/y[2]/w[2])];Ye("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${$}`));let v=h?u&&l%4!=0?3:4:w[0],b=y[1]*w[1],x=y[0]*w[0],S=Math.max(y[0]*v,y[1]),_=r%b==0,C=a%x==0,E=i%S==0,I=h?[v,4,4]:[1,1,1],A=pt(e[0].dataType),O=[`@group(0) @binding(0) var<storage, read> x: array<${h&&4===v?`vec4<${A}>`:A}>;`,`@group(0) @binding(1) var<storage, read> w: array<${h?`vec4<${A}>`:A}>;`],T=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${h?`vec4<${A}>`:A}) {\n        result[flatIndex] = ${h?`vec4<${A}>`:A}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${h?`vec4<${A}>`:A}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${h?"/ 4":""}, value);\n      }`;return o&&(O.push(`@group(0) @binding(2) var<storage, read> bias: array<${h?`vec4<${A}>`:A}>;`),T+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?`vec4<${A}>`:A} {\n          return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]}}),getShaderSource:()=>`\n        ${jr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${O.join("")}\n        @group(0) @binding(${O.length}) var<storage, read_write> result: array<${h?`vec4<${A}>`:A}>;\n        //@group(0) @binding(${O.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${ot.computeStrides(n).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${r};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${i};\n        ${T}\n        ${ea(u,_,C,E,o,t.activation.toLowerCase(),!1,I[0],I[1],I[2],A)}\n            ${h?Yr(w,y,A,void 0,!u,S):Jr(w,y,A,void 0,!u,S,!1,void 0,s)}`}}})),hs=P((()=>{Qo(),Zo(),ms(),cs(),na=(e,t,n)=>{let r=e.length>2,a=r?"value += b[output_channel];":"",i=e[0].dims,o=e[1].dims,s=o[0]/t.group,{activationFunction:u,applyActivation:l}=Fr(t),d="NHWC"===t.format,c=ra(i,o,t.dilations,t.pads,t.strides,d),p=ot.size(c),f=vt("output",e[0].dataType,c),h=$t("x",e[0].dataType,i),m=$t("w",e[1].dataType,o),g=[h,m];return r&&g.push($t("b",e[2].dataType,e[2].dims)),{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n?n(c):c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:e=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${e.declareVariables(...g,f)}\n\n  ${u}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n    let outputIndices = ${f.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${d?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${d?1:2}], outputIndices[${d?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${s}u;\n\n    var value: ${f.type.value} = ${f.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${o[1]}u; wInChannel++) {\n      let input_channel = group_id * ${o[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${o[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${i[d?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${o[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${i[d?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${d?h.get("batch","xHeight","xWidth","input_channel"):h.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${m.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${a}\n    ${l}\n    ${f.setByOffset("global_idx","value")}\n  }`}}})),ms=P((()=>{Qo(),Jo(),fs(),ps(),hs(),cs(),es(),ra=(e,t,n,r,a,i)=>{let o=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-d[t]+a[t])/a[t])));return c.splice(0,0,o),c.splice(i?3:1,0,l),c},aa=[2,3,1,0],ia=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},oa=(e,t)=>{let n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();st.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),a},sa=e=>{let t=Hr(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,i=e.group,o=e.kernel_shape,s=e.pads,u=e.strides,l=e.w_is_const();return rt({autoPad:r,format:n,dilations:a,group:i,kernelShape:o,pads:s,strides:u,wIsConst:l,...t})},ua=(e,t,n)=>{let r=oa(n,t);if(1!==n.group)return void e.compute(na(t,r));let a="NHWC"===n.format,i=3===t.length,o=t[0].dims[a?1:2],s=t[0].dims[a?2:3],u=t[0].dims[a?3:1],l=t[1].dims[2],d=t[1].dims[3],c=ra(t[0].dims,t[1].dims,n.dilations,r.pads,n.strides,a),p=c[a?1:2],f=c[a?2:3],h=c[a?3:1],m=a&&l===o&&d===s&&0===n.pads[0]&&0===n.pads[1];if(m||1===l&&1===d&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let l,d,g,y=c[0],w=[];if(a){let r=e.kernelCustomData.wT??e.compute(Ot(t[1],aa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*s*u;l=t[0].reshape([1,y,e]),d=r.reshape([1,e,h]),g=[1,y,h]}else l=t[0].reshape([y,o*s,u]),d=r.reshape([1,u,h]),g=[y,p*f,h];w.push(l),w.push(d)}else l=t[0].reshape([y,u,o*s]),d=t[1].reshape([1,h,u]),g=[y,h,p*f],w.push(d),w.push(l);return i&&w.push(t[2]),void e.compute(Zr(w,r,c,g,a),{inputs:w})}let g=e.kernelCustomData.wT??e.compute(Ot(t[1],aa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let y=[t[0],g];i&&y.push(t[2]);let w=a?p*f:h,$=a?h:p*f,v=l*d*u;e.compute(ta(y,r,c,w,$,v,i,!0),{inputs:y})},la=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),o=[1].concat(t.dilations),s=[1].concat(t.kernelShape),u=oa({...t,pads:a,strides:i,dilations:o,kernelShape:s},r);e.compute(na(r,u,(e=>n?[e[0],e[2],e[3]]:[])))},da=(e,t)=>{ia(e.inputs,t),3===e.inputs[0].dims.length?la(e,t):ua(e,e.inputs,t)}})),gs=P((()=>{qo(),Qo(),ls(),ds(),ps(),ca=(e,t=!1,n,r=!1,a=4)=>{let i=Gr(a,"f32"),o=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",s=e?"row":"col",u=e?"col":"row",l=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${s} / outWidth;\n      let outCol = ${s} % outWidth;\n\n      let WRow = ${u} / (filterDims[1] * inChannels);\n      let WCol = ${u} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${e?"outBackprop[1]":"outBackprop[2]"}) || fract(xR) > 0.0) {\n        return ${i}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${e?"outBackprop[2]":"outBackprop[3]"}) || fract(xC) > 0.0) {\n        return ${i}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${u} % inChannels;\n      ${e?"\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      "}\n      return x[getIndexFromCoords4D(coord, xShape)/${a}];`,d=e?`\n      let col = colIn * ${a};\n      if (row < dimAOuter && col < dimInner) {\n        ${l}\n      }\n      return ${i}(0.0);`:`\n      let col = colIn * ${a};\n      if (row < dimInner && col < dimBOuter) {\n        ${l}\n      }\n      return ${i}(0.0);`,c=`\n      let col = colIn * ${a};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\n      }\n      return ${i}(0.0);\n      `;return`\n  ${Ur(n,r,4===a,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?d:c}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?c:d}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${i}) {\n    let col = colIn * ${a};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${o}\n      ${Vr(t,n)}\n      result[getIndexFromCoords4D(coords, outShape)/${a}] = value;\n    }\n  }`},pa=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],c=u?n[2]:n[3],p=u?n[1]:n[2],f=u?n[3]:n[1],h=u?l%4==0&&f%4==0:c%4==0&&f%4==0,m=u?f:c*p,g=u?c*p:f,y=h?[8,8,1]:[m<=4||g<=4?4:16,m>4&&g<=4?4:16,1],w=h?[4,4,1]:[m<=4?1:4,m>4&&g<=4?1:4,1],$=[Math.ceil(m/y[0]/w[0]),Math.ceil(g/y[1]/w[1]),Math.ceil(d/y[2]/w[2])];Ye("verbose",(()=>`[conv_backprop_mm_webgpu] dispatch = ${$}`));let v=h?4:1,b=Math.max(y[0]*v,y[1]),x=[`@group(0) @binding(0) var<storage, read> x: array<${h?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],S="";return o&&(x.push(`@group(0) @binding(2) var<storage, read> bias: array<${h?"vec4<f32>":"f32"}>;`),S+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?"vec4<f32>":"f32"} {\n          return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]}}),getShaderSource:()=>`\n        ${jr}\n        ${x.join("\n")}\n        @group(0) @binding(${x.length}) var<storage, read_write> result: array<${h?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${ot.computeStrides(n).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[u?1:2]}, ${t.kernelShape[u?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[u?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[u?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${r};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${i};\n        ${S}\n        ${ca(u,o,t.activation.toLowerCase(),!1,v)}\n        ${h?Yr(w,y,"f32",void 0,!u,b):Jr(w,y,"f32",void 0,!u,b,!1,void 0,s)}`}}})),ys=P((()=>{qo(),Qo(),Zo(),fa=(e,t,n,r,a,i,o=!1,s)=>{let u="NHWC"===n.format,l=u?1:2,d=u?2:3,c=u?3:1,p=ot.size(r),f=o?2:1,h=n.group,m=t[1].dims,g=m[0]/h,y=m[1],w=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${o?`vec4<${s}>`:s}) {\n    result[flatIndex] = ${o?`vec4<${s}>`:s}(value);\n  }`;a&&(w+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${o?`vec4<${s}>`:s} {\n      return bias[coords.${u?"w":"y"}${o?"/ 4":""}];\n    }`);let $=o?4:1,v=$t("W",t[1].dataType,t[1].dims,$),b=$t("Dy",t[0].dataType,t[0].dims,$),x=[b,v];a&&x.push($t("bias",t[2].dataType,[r[c]],$));let S=vt("result",t[0].dataType,r,$),_=`{\n        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${i?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${i?"global_id.y":"workgroup_id.y"} * ${f};\n        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${s}>, ${f}>;\n        for (var i = 0; i < ${f}; i++) {\n          dotProd[i] = vec4<${s}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${s}(dyCorner.x) + ${s}(wR)) / ${s}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${s}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${s}(dyCorner.y) + ${s}(wC)) / ${s}(strides.y);\n            let dyC2 = (${s}(dyCorner.y) + 1.0 + ${s}(wC)) / ${s}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${s}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${s}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${b.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${s}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${c}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${f}; i = i + 1) {\n          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};\n          ${S.set("batch","r","c + i","d1","value")};\n        }\n      }`,C=`\n          let outputIndices = ${S.offsetToIndices("global_idx")};\n          let batch = ${S.indicesGet("outputIndices",0)};\n          let d1 = ${S.indicesGet("outputIndices",c)};\n          let r = ${S.indicesGet("outputIndices",l)};\n          let c = ${S.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${y};\n          let wOutChannel = d1 - groupId * ${y};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${s}(dyRCorner) + ${s}(wR)) / ${s}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${s}(outBackprop[${l}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${s}(dyCCorner) + ${s}(wC)) / ${s}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${s}(outBackprop[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${g};\n              for (var d2: u32 = 0; d2 < ${g}; d2 = d2 + 1) {\n                let xValue = ${u?b.get("batch","idyR","idyC","inputChannel"):b.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${v.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${a?"bias[d1]":"0.0"};\n          ${S.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...x,S)}\n  ${w}\n  const outShape : vec4<u32> = vec4<u32>(${r.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[u?1:2]}, ${n.kernelShape[u?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${n.dilations[0]<=1?0:(n.kernelShape[u?1:2]-1)*(n.dilations[0]-1)},\n          ${n.dilations[1]<=1?0:(n.kernelShape[u?2:3]-1)*(n.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)};\n  ${o?_:C}}`},ha=(e,t,n)=>{let r=e.length>2,a=t.outputShape,i=ot.size(a),o=[Math.ceil(i/64),1,1];Ye("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${o}`));let s=pt(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:o[0],y:o[1],z:o[2]},outputs:[{dims:n?n(a):a,dataType:e[0].dataType}]}),getShaderSource:n=>fa(n,e,t,a,r,1===o[1]&&1===o[2],!1,s)}}})),ws=P((()=>{Jo(),gs(),ys(),cs(),es(),ma=(e,t,n,r,a,i)=>(e-1)*t+n+(r-1)*a+1-i,ga=(e,t,n,r,a)=>{let i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[a]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[a]=i)},ya=(e,t,n,r,a,i,o,s,u,l)=>{let d=e.length-2,c=0===l.length;if(0===u.length)for(let e=0;e<d;++e)u.push(0);let p=e[0],f=t[s?3:1]*a;for(let a=0,p=e.length-d-(s?1:0);a<d;++a,++p){let s=e[p],f=c?s*o[a]:l[a],h=ma(s,o[a],i[a],t[p],n[a],f);ga(h,r,i,a,a+d),c&&l.push(o[a]*(s-1)+u[a]+(t[p]-1)*n[a]+1-i[a]-i[a+d])}l.splice(0,0,p),l.splice(s?3:1,0,f)},wa=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let a=e.pads.slice(),i=e.outputShape.slice(),o=e.outputPadding.slice(),s=t[0].dims,u=e.dilations.slice();if(0===u.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}let l=e.strides.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}ya(s,n,u,e.autoPad,e.group,a,l,r,o,i);let d=Object.assign({},e),c=e.cacheKey+[n.join("n,"),a.join(","),l.join(","),o.join(","),i.join(","),u.join(",")].join("_");return Object.assign(d,{kernelShape:n,pads:a,outputPadding:o,outputShape:i,dilations:u,strides:l,cacheKey:c}),d},$a=e=>{let t=Hr(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,i=e.group,o=e.kernelShape,s=e.pads,u=e.strides,l=e.wIsConst(),d=e.outputPadding,c=e.outputShape;return rt({autoPad:r,format:n,dilations:a,group:i,kernelShape:o,outputPadding:d,outputShape:c,pads:s,strides:u,wIsConst:l,...t})},va=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},ba=[2,3,1,0],xa=(e,t,n)=>{let r=wa(n,t),a="NHWC"===n.format,i=3===t.length;if(1!==r.group)return void e.compute(ha(t,r));let o=r.outputShape,s=o[a?1:2],u=o[a?2:3],l=o[a?3:1],d=a?s*u:l,c=a?l:s*u,p=t[1].dims[2]*t[1].dims[3]*t[0].dims[a?3:1],f=e.kernelCustomData.wT??e.compute(Ot(t[1],ba),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=f);let h=[t[0],f];i&&(a||1!==t[2].dims.length?h.push(t[2]):h.push(t[2].reshape([t[2].dims[0],1,1]))),e.compute(pa(h,r,o,d,c,p,i,!0),{inputs:h})},Sa=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===r.length&&r.push(e.inputs[2]);let a=t.kernelShape;(0===a.length||0===a[0])&&(a=[e.inputs[1].dims[2]]);let i=t.dilations;(0===i.length||0===i[0])&&(i=[1]);let o=t.strides;(0===o.length||0===o[0])&&(o=[1]);let s=t.pads;0===s.length&&(s=[0,0]),s=[0,s[0],0,s[1]],o=[1].concat(o),i=[1].concat(i),a=[1].concat(a);let u=wa({...t,pads:s,strides:o,dilations:i,kernelShape:a},r);e.compute(ha(r,u,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])))},_a=(e,t)=>{va(e.inputs,t),3===e.inputs[0].dims.length?Sa(e,t):xa(e,e.inputs,t)}})),$s=P((()=>{Qo(),Jo(),Zo(),Ia="^"+(Ea="("+(Ca="[a-zA-Z]|\\.\\.\\.")+")+")+"$",Aa="^("+Ea+",)*"+Ea+"$",Oa=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Ta=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(Aa)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(Ia)))throw new Error("Invalid LHS term");let a=this.processTerm(t,!0,r,n);this.lhs.push(a)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(Ea)))throw new Error("Invalid RHS");r.match(RegExp(Ca,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!0,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let a=n.length,i=!1,o=[],s=0;if(!e.match(RegExp(Ia))&&!t&&""!==e)throw new Error("Invalid LHS term");let u=e.match(RegExp(Ca,"g")),l=new Oa(r);return u?.forEach(((e,d)=>{if("..."===e){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let e=a-u.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(o=n.slice(s,s+e),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=o}for(let e=0;e<o.length;e++){let t=String.fromCharCode("0".charCodeAt(0)+d);l.addSymbol(t,d+e),this.addSymbol(t,n[s++],r)}}else l.addSymbol(e,d),this.addSymbol(e,n[s++],r)})),l}},Ra=(e,t)=>{let n=e[0].dataType,r=new Array(e.length);for(let t=0;t<e.length;++t)r[t]=$t(`input${t}`,n,e[t].dims);let a=t.outputDims,i=ot.size(a),o=vt("output",n,a),s=[],u=Array.from(t.rhs.symbolToIndices.keys()),l=[],d=[],c=[],p=[],f=t.symbolToInfo.size===u.length;t.symbolToInfo.forEach(((e,n)=>{if(u.includes(n)){let a=u.indexOf(n);t.lhs.forEach(((t,i)=>{if(e.inputIndices.includes(i)){let e=t.symbolToIndices.get(n);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{s.push(`${r[i].indicesSet(`input${i}Indices`,e,o.indicesGet("outputIndices",a))}`)}))}}))}else t.lhs.forEach(((e,a)=>{let i=t.symbolToInfo.get(n);if(void 0===i)throw new Error("Invalid symbol error");if(i.inputIndices.includes(a)){let t=e.symbolToIndices.get(n);if(void 0===t)throw new Error("Invalid symbol error");t.forEach((e=>{l.push(`${r[a].indicesSet(`input${a}Indices`,e,`${n}`)}`)})),p.push(`prod *= ${r[a].getByIndices(`input${a}Indices`)};`)}})),d.push(`for(var ${n}: u32 = 0; ${n} < ${t.symbolToInfo.get(n)?.dimValue}; ${n}++) {`),c.push("}")}));let h=f?[...s,`let sum = ${r.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...s,"var sum = 0.0;",...d,...l,"var prod = 1.0;",...p,"sum += prod;",...c];return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n      ${e.declareVariables(...r,o)}\n\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n        var outputIndices = ${o.offsetToIndices("global_idx")};\n        ${r.map(((e,t)=>`var input${t}Indices: ${r[t].type.indices};`)).join("\n")}\n        ${h.join("\n")};\n        ${o.setByOffset("global_idx","sum")};\n      }`}},ka=(e,t)=>{let n=new Ta(e.inputs,t.equation);e.compute(Ra(e.inputs,n))},Ba=e=>{let t=e.equation.replace(/\s+/g,"");return rt({equation:t})}})),vs=P((()=>{Qo(),Zo(),Ma=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,a=t.length<n.length?0:t.length-n.length;for(;r<n.length&&a<t.length;++r,++a)if(n[r]!==t[a]&&1!==n[r]&&1!==t[a])throw new Error("Expand requires shape to be broadcastable to input")},Da=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let a=0;a<t.length;++a)r.push(1===t[a]?e[a+n]:t[a]);return r},Pa=(e,t)=>e.length>t.length?Da(e,t):Da(t,e),za=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=Pa(t,n),a=ot.size(r),i=e[0].dataType,o=$t("input",i,t),s=vt("output",i,r);return{name:"Expand",shaderCache:{hint:`${r}`},getShaderSource:e=>`\n  const inputShape = ${o.indices(...t)};\n  ${e.declareVariables(o,s)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let outputIndices = ${s.offsetToIndices("global_idx")};\n    var inputIndices: ${o.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${o.indicesGet("inputShape","i")} == 1) {\n        ${o.indicesSet("inputIndices","i",0)}\n      } else {\n        ${o.indicesSet("inputIndices","i",s.indicesGet("outputIndices","i + "+(r.length-t.length)))}\n      }\n    }\n    ${s.setByOffset("global_idx",o.getByIndices("inputIndices"))}\n  }`,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}})}},Wa=e=>{Ma(e.inputs),e.compute(za(e.inputs),{inputs:[0]})}})),bs=P((()=>{Qo(),Jo(),Zo(),Na=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},Ga=(e,t)=>{let n=e[0].dims,r=e[1].dims,a=n.length,i=ot.normalizeAxis(t.axis,a),o=n.slice(0);o.splice(i,1,...r);let s=n[i],u=ot.size(o),l=$t("data",e[0].dataType,e[0].dims),d=$t("inputIndices",e[1].dataType,e[1].dims),c=vt("output",e[0].dataType,o);return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:e=>`\n      ${e.declareVariables(l,d,c)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        let outputIndices = ${c.offsetToIndices("global_idx")};\n        ${(()=>{let e=r.length,t=`var indicesIndices  = ${d.type.indices}(0);`;for(let n=0;n<e;n++)t+=`${e>1?`indicesIndices[${n}]`:"indicesIndices"} = ${o.length>1?`outputIndices[${i+n}]`:"outputIndices"};`;t+=`\n        var idx = ${d.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${s};\n        }\n        var dataIndices = ${l.type.indices}(0);\n      `;for(let n=0,r=0;n<a;n++)n===i?(t+=(a>1?`dataIndices[${n}]`:"dataIndices")+" = u32(idx);",r+=e):(t+=`${a>1?`dataIndices[${n}]`:"dataIndices"} = ${o.length>1?`outputIndices[${r}]`:"outputIndices"};`,r++);return t})()};\n        let value = ${l.getByIndices("dataIndices")};\n        ${c.setByOffset("global_idx","value")};\n      }`}},Ua=e=>rt({axis:e.axis}),Va=(e,t)=>{let n=e.inputs;Na(n),e.compute(Ga(e.inputs,t))}})),xs=P((()=>{Qo(),Jo(),Zo(),ja=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},Fa=(e,t)=>{let n=e[0].dims,r=e[0].dataType,a=n.length,i=ot.computeStrides(n),o=ot.size(n),s=e[1].dims,u=e[1].dataType,l=ot.size(s),d=ot.normalizeAxis(t.axis,a),c=n[d],p=s.slice(0),f=ot.size(p),h=$t("input",r,n),m=$t("indices",u,[l]),g=vt("output",r,p);return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:e=>`\n      const inputStrides = array<u32, ${i.length}>(${i.map((e=>`${e}u`)).join(",")});\n      ${e.declareVariables(h,m,g)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n\n      let outputIndices = ${g.offsetToIndices("global_idx")};\n\n      var idx = ${m.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${c};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${n.length}; i++) {\n        if (i == ${d}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${g.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${o}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`}},Ha=e=>rt({axis:e.axis}),La=(e,t)=>{let n=e.inputs;ja(n),e.compute(Fa(e.inputs,t))}})),Ss=P((()=>{Qo(),Jo(),Zo(),qa=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Ya=(e,t,n)=>{if(0===n.length)return"0u";let r=1===n.length&&1!==e||2===n.length&&n[0]!==e,a=n[n.length-1]!==t,i="0u";return r||(i+=`+ m * ${n[n.length-1]}u`),a||(i+="+n"),i},Ka=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[a,i,o]=ut.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),s=[a,i];if(!s)throw new Error("Can't use gemm on the given tensors");let u=ot.size(s),l="";t.transA&&t.transB?l="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?l="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?l="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(l="value += a[m * K + k] * b[k * N + n];");let d=pt(e[0].dataType),c=1===t.alpha?"":"value *= alpha;",p=3===e.length?`value += beta * c[${Ya(a,i,e[2].dims)}];`:"",f=[`@group(0) @binding(0) var<storage, read> a : array<${d}>;`,`@group(0) @binding(1) var<storage, read> b : array<${d}>;`];return 3===e.length&&f.push(`@group(0) @binding(2) var<storage, read> c : array<${d}>;`),{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:n=>`\n  const M: u32 = ${a}u;\n  const N: u32 = ${i}u;\n  const K: u32 = ${o}u;\n  const alpha = ${d}(${t.alpha});\n  const beta = ${d}(${t.beta});\n\n  ${f.join("\n")}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${d}>;\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${d}(0);\n    for (var k: u32 = 0u; k<${o}u; k++) {\n      ${l}\n    }\n\n    ${c}\n    ${p}\n    output[global_id.x] = value;\n\n  }`}},Xa=(e,t)=>{qa(e.inputs),e.compute(Ka(e.inputs,t))},Ja=e=>rt(e)})),_s=P((()=>{Lo(),Qo(),Jo(),Zo(),Qa={name:"InstanceNormalization"},Za=(e,t)=>{let n=e[0].dims,r=n,a=ot.sizeToDimension(n,2),i=ot.sizeFromDimension(n,2),o=n[1],s=$t("x",e[0].dataType,[n[0],n[1],i]),u=$t("scale",e[1].dataType,e[1].dims),l=$t("bias",e[2].dataType,e[2].dims),d=vt("output",e[0].dataType,[n[0],n[1],i]),c=[s,u,l,d],p=s.type.value;return{...Qa,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:a}}),getShaderSource:e=>`\n\n  const C: u32 = ${o};\n  const normSize: u32 = ${i};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${p};\n  var<workgroup> squaredNormShared : ${p};\n  var<workgroup> workgroupShared : array<${p}, 64>;\n  const workgroupSize = 64u;\n  ${e.declareVariables(...c)}\n  ${e.mainStart(64)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${p} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${s.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${p}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${s.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${p}(normSize) + epsilon);\n    let channelScale = invStdDev * ${u.getByOffset("channel")};\n    let channelShift = ${l.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${s.get("batch","channel","h")} * channelScale + channelShift;\n      ${d.set("batch","channel","h","value")};\n    }\n  }`}},ei=(e,t,n,r,a,i,o,s)=>{let u=ht(o),l=$t("input",t.dataType,t.dims,u),d=$t("scale",n.dataType,n.dims,u),c=$t("bias",r.dataType,r.dims,u),p=1===u?"vec2f":`mat2x${u}f`,f=1===u?"f32":`vec${u}f`,h=(e,t)=>`${p}(${e}, ${t})`,m=a*o/u,g=Math.ceil(i/64),y=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:u,n:a,h:i,c:o})},getRunData:()=>({outputs:[{dims:[a,o,64,2],dataType:1}],dispatchGroup:{x:a*o/u}}),getShaderSource:e=>`\n  const H: u32 = ${i};\n  const C: u32 = ${o/u};\n  const imageSize: u32 = ${i*o/u};\n\n  ${e.declareVariables(l)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${p}>;\n\n  ${e.mainStart(64)}\n    let currentImageNumber = global_idx / 64 / C;\n    let currentChannelNumber = (global_idx / 64) % C;\n    let wgId = global_idx % 64;\n    let wgOffset = wgId * ${g};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${g}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${mt("f32",u)};\n    var squaredSum = ${mt("f32",u)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${f}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${h("sum","squaredSum")};\n  }`},{inputs:[t],outputs:[-1]})[0];return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:u,n:a,h:i,c:o,epsilon:s})},getRunData:()=>({outputs:[{dims:[a,o,2],dataType:1}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:e=>`\n  const H: u32 = ${i};\n  const C: u32 = ${o/u};\n  const imageSize: u32 = ${64*o/u};\n  const epsilon: f32 = ${s};\n\n  @group(0) @binding(0) var<storage, read> input : array<${p}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${d.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${c.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${p}>;\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${mt("f32",u)};\n    var squaredSum = ${mt("f32",u)};\n    for (var i: u32 = 0; i < 64; i++) {\n        let value = input[offset + i + currentChannelNumber * 64];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${f}(scale[currentChannelNumber]);\n    let channelShift = ${f}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${h("channelScale","channelShift")};\n  }`},{inputs:[y,n,r],outputs:[-1]})[0]},ti=(e,t,n)=>{let r=t[0].dims,a=r,i=r[0],o=r[r.length-1],s=ot.sizeFromDimension(r,1)/o,u=ht(o),l=ot.size(a)/u,d=$t("input",t[0].dataType,t[0].dims,u),c=vt("output",t[0].dataType,a,u),p=pt(t[0].dataType),f=1===u?"vec2f":`mat2x${u}f`,h=1===u?p:`vec${u}<${p}>`,m=ei(e,t[0],t[1],t[2],i,s,o,n.epsilon);e.compute({name:"InstanceNormalization",shaderCache:{hint:`${n.cacheKey}`},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:e=>`\n  const H: u32 = ${s};\n  const C: u32 = ${o/u};\n\n  @group(0) @binding(0) var<storage, read> input : array<${d.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${f}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${c.type.storage}>;\n\n  ${e.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${h}(scale[0]), ${h}(scale[1]));\n  }`},{inputs:[t[0],m]})},ni=e=>rt({epsilon:e.epsilon,format:e.format}),ri=(e,t)=>{"NHWC"===t.format?ti(e,e.inputs,t):e.compute(Za(e.inputs,t))}})),Cs=P((()=>{Lo(),Qo(),Jo(),Zo(),ai=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ii=(e,t,n)=>{let r=e[0].dims,a=e[1],i=e[2],o=r,s=ot.normalizeAxis(t.axis,r.length),u=ot.sizeToDimension(r,s),l=ot.sizeFromDimension(r,s),d=ot.size(a.dims),c=i?ot.size(i.dims):0;if(d!==l||i&&c!==l)throw new Error(`Size of X.shape()[axis:] == ${l}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${d} and bias size of ${c}`);let p=[];for(let e=0;e<r.length;++e)e<s?p.push(r[e]):p.push(1);let f=ht(l),h=pt(e[0].dataType),m=[$t("x",e[0].dataType,e[0].dims,f),$t("scale",a.dataType,a.dims,f)];i&&m.push($t("bias",i.dataType,i.dims,f)),m.push(vt("output",e[0].dataType,o,f));let g=n>1,y=n>2;g&&m.push(vt("meanDataOutput",1,p)),y&&m.push(vt("invStdOutput",1,p));let w=[{dims:o,dataType:e[0].dataType}];return g&&w.push({dims:p,dataType:1}),y&&w.push({dims:p,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${n}|${e.length}`},getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:e=>`\n  const normSize: f32 = ${l};\n  const normSizeVectorized: u32 = ${l/f};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${e.declareVariables(...m)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${mt("f32",f)};\n    var meanSquareVector = ${mt("f32",f)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${gt(h,f,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${yt("meanVector",f)} / normSize;\n    let meanSquare = sqrt(${yt("meanSquareVector",f)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${gt(h,f,"x[j + offset]")};\n      let f32scale = ${gt(h,f,"scale[j]")};\n      output[j + offset] = ${m[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${i?`+ ${gt(h,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${g?"meanDataOutput[global_idx] = mean":""};\n    ${y?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`}},oi=e=>rt({axis:e.axis,epsilon:e.epsilon}),si=(e,t)=>{ai(e.inputs),e.compute(ii(e.inputs,t,e.outputCount))}})),Es=P((()=>{Qo(),ps(),ui=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},li=e=>{ui(e.inputs);let t=it.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(Zr(e.inputs,{activation:"",activationCacheKey:""},t))}})),Is=P((()=>{Lo(),Qo(),Jo(),Zo(),di=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType)throw new Error("Input type must be float.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},ci=(e,t,n,r,a,i,o)=>{let s="";for(let t=n.length-1;t>=0;--t)s+=`\n            k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${n[t]}) {\n              break;\n            }\n            offset += k * ${r[t]};\n        `;return`\n          value = ${i}(${o});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${s}\n            value = x[offset];\n          }\n      `},pi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(n[t]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${n[t]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},fi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${n[t]}) {\n                  k = ${n[t]-1};\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},hi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0)  {\n                  k += ${n[t]};\n                }\n                if (k >= ${n[t]}) {\n                  k -= ${n[t]};\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},mi=(e,t,n,r,a,i)=>{switch(a.mode){case 0:return ci(e,0,n,r,a.pads,i,a.value);case 1:return pi(e,0,n,r,a.pads);case 2:return fi(e,0,n,r,a.pads);case 3:return hi(e,0,n,r,a.pads);default:throw new Error("Invalid mode")}},gi=(e,t,n,r)=>{let a=t[0].dims,i=ot.padShape(a.slice(),n.pads),o=ot.size(i),s=ot.computeStrides(a),u=vt("output",t[0].dataType,i),l=$t("x",t[0].dataType,a),d=mi(u,0,a,s,n,r);return`\n              ${e.declareVariables(l,u)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n              let indices = ${u.offsetToIndices("global_idx")};\n\n              var value = ${r}(0);\n              ${d}\n              output[global_idx] = value;\n          }`},yi=(e,t)=>{let n=ot.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ot.size(n)/64)}}),getShaderSource:n=>gi(n,e,t,"f32")}},wi=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,i=new Int32Array(2*a).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)i[Number(t[e])]=Number(n[e]),i[Number(t[e])+a]=Number(n[e+t.length])}else n.forEach(((e,t)=>i[Number(t)]=Number(e)));let o=[];return i.forEach((e=>o.push(e))),rt({mode:t.mode,value:r,pads:o})}return t},$i=(e,t)=>{di(e.inputs);let n=wi(e.inputs,t);e.compute(yi(e.inputs,n),{inputs:[0]})},vi=e=>{let t=e.mode,n=e.value,r=e.pads;return rt({mode:t,value:n,pads:r})}})),As=P((()=>{Qo(),Jo(),Zo(),bi=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},xi=(e,t,n)=>{let r="NHWC"===t.format,a=e.dims.slice();r&&a.splice(1,0,a.pop());let i=Object.hasOwnProperty.call(t,"dilations"),o=t.kernelShape.slice(),s=t.strides.slice(),u=i?t.dilations.slice():[],l=t.pads.slice();st.adjustPoolAttributes(n,a,o,s,u,l);let d=st.computePoolOutputShape(n,a,s,u,o,l,t.autoPad),c=Object.assign({},t);i?Object.assign(c,{kernelShape:o,strides:s,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:o,strides:s,pads:l,cacheKey:t.cacheKey});let p=d.slice();return p.push(p.splice(1,1)[0]),[c,r?p:d]},Si=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===a.format,l=n,d=t.type.value,c=l.length,p=ot.size(r),f=vt("output",t.type.tensor,r);if(a.kernelShape.length<=2){let n=a.kernelShape[a.kernelShape.length-1],r=a.strides[a.strides.length-1],h=a.pads[a.pads.length/2-1],m=c-(u?2:1),g="",y="",w="";if(g=h+a.pads[a.pads.length-1]!==0?`\n                for (var i: u32 = 0u; i < ${n}u; i++) {\n                  xIndices[${m}] = indices[${m}] * ${r} - ${h} + i;\n                  if (xIndices[${m}] < 0 || xIndices[${m}] >= ${l[m]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`:`\n                for (var i: u32 = 0u; i < ${n}u; i++) {\n                  xIndices[${m}] = indices[${m}] * ${r} - ${h} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`,2===a.kernelShape.length){let e=a.kernelShape[a.kernelShape.length-2],t=a.strides[a.strides.length-2],r=a.pads[a.pads.length/2-2],i=a.pads[a.pads.length-2],o=c-(u?3:2),s=l[o];y=r+i!==0?`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\n                  if (xIndices[${o}] < 0 || xIndices[${o}] >= ${s}) {\n                    pad+= ${n};\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\n                `,w="\n              }\n            "}return`\n            ${e.declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var value: ${d} = ${d}(${s});\n              var pad = 0;\n              ${y}\n              ${g}\n              ${w}\n              ${o}\n\n              output[global_idx] = value;\n            }`}{if(u)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let n=ot.size(a.kernelShape),r=ot.computeStrides(a.kernelShape),d=r.length,h=a.pads.length,m="";return m=a.pads.reduce(((e,t)=>e+t))?`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${i}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${i}\n            `,`\n            ${e.declareVariables(t,f)}\n\n            const pads = array<u32, ${h}>(${a.pads.map((e=>`${e}u`)).join(",")});\n            const inputDims = array<u32, ${c}>(${l.map((e=>`${e}u`)).join(",")});\n            const kernelStrides = array<u32, ${d}>(${r.map((e=>`${e}u`)).join(",")});\n            const strides = array<u32, ${d}>(${a.strides.map((e=>`${e}u`)).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              let xIndices = ${f.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${d}>;\n\n              var value = ${f.type.value}(${s});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${d-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${d-1}] = offset;\n\n                isPad = false;\n                for (var j = ${c-d}u; j < ${c}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${c-d}u]\n                    + offsets[j - ${c-d}u] - pads[j - 2u];\n                  ${m}\n              }\n              ${o}\n\n              output[global_idx] = value;\n            }`}},_i=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ci=(e,t,n,r)=>{let[a,i]=xi(t,r,n),o=ot.size(a.kernelShape),s=$t("x",t.dataType,t.dims),u=s.type.value,l="";return a.countIncludePad?l+=`value /= ${u}(${o});`:l+=`value /= ${u}(${o} - pad);`,{name:e,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ot.size(i)/64)}}),getShaderSource:e=>Si(e,s,t.dims,i,a,"value += x_val;",l,"0.0")}},Ei=e=>{let t=0!==e.count_include_pad,n=_i(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return rt({countIncludePad:t,...n})},Ii=(e,t)=>{bi(e.inputs),e.compute(Ci("AveragePool",e.inputs[0],!1,t))},Ai={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Oi=e=>{let t=e.format;return{format:t,...Ai,cacheKey:t}},Ti=(e,t)=>{bi(e.inputs),e.compute(Ci("GlobalAveragePool",e.inputs[0],!0,t))},Ri=(e,t,n,r)=>{let[a,i]=xi(t,r,n),o=$t("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ot.size(i)/64)}}),getShaderSource:e=>Si(e,o,t.dims,i,a,"\n      value = max(x_val, value);\n    ","","-1e5")}},ki=(e,t)=>{bi(e.inputs),e.compute(Ri("MaxPool",e.inputs[0],!1,t))},Bi=e=>{let t=e.storage_order,n=e.dilations,r=_i(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return rt({storageOrder:t,dilations:n,...r})},Mi=e=>{let t=e.format;return{format:t,...Ai,cacheKey:t}},Di=(e,t)=>{bi(e.inputs),e.compute(Ri("GlobalMaxPool",e.inputs[0],!0,t))}})),Os=P((()=>{re(),Lo(),Zo(),Pi=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},zi=(e,t,n,r)=>{let a=Math.abs(Math.ceil((t-e)/n)),i=[a],o=a,s=vt("output",r,i),u=s.type.storage;return{name:"Range",shaderCache:{hint:[e,t,n].map((e=>e.toString())).join("_")},getShaderSource:t=>`\n        ${t.declareVariables(s)}\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n        output[global_idx] = ${u}(${e}) + ${u}(global_idx) * ${u}(${n});\n      }`,getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)}})}},Wi=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),c.webgpu.validateInputContent&&Pi(t,n,r),e.compute(zi(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),Ts=P((()=>{Qo(),Jo(),Zo(),Ni=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},Gi=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},Ui=(e,t,n,r,a,i)=>{let[o,s,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(s>0&&e.length>s&&e[s].dims.length>0){if(e[s].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ni(r,t),t.axes.length>0&&Gi(r,t.axes,l).forEach(((e,t)=>r[t]=e))}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach((e=>a.push(Number(e)))),a.length!==l||n>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof a<"u"&&r.length>0&&a.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},Vi=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join("\n");case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",ji=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Fi=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),a=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=a[i],r[i+n]=a[t.length+i]})),r):a},Hi=(e,t,n,r)=>{let a=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>a.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>a[e]=n[t]))}else n.forEach((e=>a.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");a=e.map(((e,n)=>Math.round(e*t[n])))}return a},Li=(e,t,n,r)=>{let a=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map((e=>n[e])),Number.MAX_VALUE):Math.min(...n,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map((e=>n[e])),Number.MIN_VALUE):Math.max(...n,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();n.fill(1,0,n.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach((e=>n[e]=a)),r.axes.forEach((t=>i[t]=Math.round(e[t]*n[t])))):(n.fill(a,0,n.length),i.forEach(((e,t)=>i[t]=Math.round(e*n[t])))),i},qi=(e,t,n,r,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${n.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\n      const outputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n      const scales = array<f32, ${r.length}>(${r.map((e=>`${e}f`)).join(",")});\n      const roi = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\n      var originalIndices: array<f32, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var outputIndex = ${1===n.length?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Yi=(e,t,n,r,a,i,o)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n        const outputShape = array<u32, ${r.length}>(${r.map((e=>`${e}u`)).join(",")});\n        const scales = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\n        const roi = array<f32, ${i.length}>(${i.map((e=>`${e}f`)).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${r.length}; i++) {\n          var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${n.length}]);\n            if (!${o} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,Ki=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${1===t.length?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Xi=(e,t,n,r,a,i,o)=>{let[s,u,l,d]=2===n.length?[-1,0,1,-1]:1===a[1]?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${u}] = max(0, min(row, ${n[u]} - 1));\n      inputIndices[${l}] = max(0, min(col, ${n[l]} - 1));\n      if (${n.length} > 2) {\n        inputIndices[${d}] = channel;\n        inputIndices[${s}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${u}];\n      var col:f32 = originalIndices[${l}];\n      if (${i} && (row < 0 || row > (${n[u]} - 1) || col < 0 || col > ${n[l]} - 1)) {\n        return ${o};\n      }\n      row = max(0, min(row, ${n[u]} - 1));\n      col = max(0, min(col, ${n[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${n.length>2}) {\n        channel = u32(originalIndices[${d}]);\n        batch = u32(originalIndices[${s}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Ji=(e,t,n,r,a,i,o,s,u,l)=>{let[d,c]=2===n.length?[0,1]:1===a[1]?[2,3]:[1,2],p=o=>{let c=o===d?"row":"col";return`\n      fn ${c}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${1===r.length?"outputIndices":`outputIndices[${o}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[o]},\n        f32(${r[o]}), f32(${n[o]}), ${i[o]}, ${i[o]} + ${n.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${s} && (originalIdx < 0 || originalIdx > (${n[o]} - 1))) {\n          return ${u};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${c}: f32 = originalIdx + f32(i);\n          if (${c} < 0 || ${c} >= ${n[o]}) {\n            if (${l}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${s}) {\n              return ${u};\n            } else {\n              ${c} = max(0, min(${c}, ${n[o]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${o}] = u32(${c});\n          data[i + 1] = ${o===d?`input[${e.indicesToOffset("inputIndicesCopy")}];`:"\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);"}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${p(d)};\n    ${p(c)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};\n    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Qi=(e,t,n,r,a,i)=>{let o=e.dims,s=Fi(i,t.axes,o.length),u=Hi(o,r,a,t.axes),l=r.slice();0===r.length&&(l=o.map(((e,t)=>0===e?1:u[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(u=Li(o,0,l,t)));let d=vt("output",e.dataType,u),c=$t("input",e.dataType,o),p=ot.size(u),f=o.length===u.length&&o.every(((e,t)=>e===u[t])),h="tf_crop_and_resize"===t.coordinateTransformMode;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${l.length>0?l:""}|${a.length>0?a:""}`},getShaderSource:e=>`\n      ${Vi(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Ki(c,o)};\n              ${ji(t.nearestMode,n)};\n              ${Yi(c,d,o,u,l,s,h)};\n              `;case"linear":return`\n              ${qi(d,o,u,l,s)};\n              ${Xi(c,d,o,0,l,h,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Ji(c,d,o,u,l,s,t.cubicCoeffA,h,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${e.declareVariables(c,d)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n        if (${f}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${d.offsetToIndices("global_idx")};\n          var inputIndices: ${c.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${c.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)}})}},Zi=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},eo=(e,t)=>{let n=[],r=[],a=[],i=Zi(e);Ui(e.inputs,t,i,n,r,a),e.compute(Qi(e.inputs[0],t,i,n,r,a),{inputs:[0]})},to=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,a=e.cubicCoeffA,i=0!==e.excludeOutside,o=e.extrapolationValue,s=e.keepAspectRatioPolicy,u=e.mode,l=""===e.nearestMode?"simple":e.nearestMode;return rt({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:a,excludeOutside:i,extrapolationValue:o,keepAspectRatioPolicy:s,mode:u,nearestMode:l})}})),Rs=P((()=>{Lo(),Qo(),Jo(),Zo(),no=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},ro=(e,t,n,r)=>{let a=e[0].dims,i=a,o=ot.size(a),s=a.slice(-1)[0],u=r?a.slice(0,-1).concat(1):[],l=e.length>3,d=e.length>4,c=r&&n>1,p=r&&n>2,f=n>3,h=ht(s),m=[$t("x",e[0].dataType,e[0].dims,h),$t("skip",e[1].dataType,e[1].dims,h),$t("gamma",e[2].dataType,e[2].dims,h)];l&&m.push($t("beta",e[3].dataType,e[3].dims,h)),d&&m.push($t("bias",e[4].dataType,e[4].dims,h)),m.push(vt("output",e[0].dataType,i,h)),c&&m.push(vt("meanOutput",1,u)),p&&m.push(vt("invStdOutput",1,u)),f&&m.push(vt("inputSkipBiasSum",e[0].dataType,i,h));let g=pt(e[0].dataType),y=[{dims:i,dataType:e[0].dataType}];return n>1&&y.push({dims:u,dataType:1}),n>2&&y.push({dims:u,dataType:1}),n>3&&y.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:e=>`\n      const hiddenSize: f32 = ${s};\n      const hiddenSizeVectorized: u32 = ${s/h};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${e.declareVariables(...m)}\n\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(o/s)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${mt("f32",h)};\n        var squareSum = ${mt("f32",h)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${d?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${f?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${gt(g,h,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${yt("sum",h)} / hiddenSize;\n        let variance = sqrt(${yt("squareSum",h)} / hiddenSize - mean * mean + epsilon);\n        ${c?"meanOutput[global_idx] = mean;":""}\n        ${p?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${g}(mean)) / ${g}(variance) * gamma[i]\n           + ${l?"beta[i]":"0.0"};\n        }\n      }`,getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(o/s/64)}})}},ao=(e,t)=>{no(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(ro(e.inputs,t,e.outputCount,!1),{outputs:n})},io=e=>{let t=e.epsilon;return rt({epsilon:t})}})),ks=P((()=>{Lo(),Qo(),Jo(),Zo(),oo=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},so=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},uo=(e,t)=>{if(e.length>1){let t=so(e,1),n=so(e,2),r=so(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),rt({starts:t,ends:n,axes:r})}return t},lo=(e,t,n,r,a)=>{let i=e;return e<0&&(i+=n[r[t]]),a[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},co=(e,t,n,r)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${1===n.length?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,po=(e,t)=>{let n=e[0].dims,r=ot.size(n),a=t.axes.length>0?ot.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=so(e,4);i.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===i.length&&(i=Array(a.length).fill(1));let o=t.starts.map(((e,t)=>lo(e,t,n,a,i))),s=t.ends.map(((e,t)=>lo(e,t,n,a,i)));if(a.length!==n.length)for(let e=0;e<n.length;++e)a.includes(e)||(o.splice(e,0,0),s.splice(e,0,n[e]),i.splice(e,0,1));let u=i.map((e=>Math.sign(e)));i.forEach(((e,t,n)=>{if(e<0){let r=(s[t]-o[t])/e,a=o[t],u=a+r*i[t];o[t]=u,s[t]=a,n[t]=-e}}));let l=n.slice(0);a.forEach(((e,t)=>{l[e]=Math.ceil((s[e]-o[e])/i[e])}));let d={dims:l,dataType:e[0].dataType},c=vt("output",e[0].dataType,l),p=$t("input",e[0].dataType,n),f=ot.size(l);return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:e=>`\n      ${e.declareVariables(p,c)}\n        const signs = array<i32, ${u.length}>(${u.map((e=>`${e}i`)).join(",")});\n        const starts = array<u32, ${o.length}>(${o.map((e=>`${e}u`)).join(",")});\n        const ends = array<u32, ${s.length}>(${s.map((e=>`${e}u`)).join(",")});\n        const steps = array<u32, ${i.length}>(${i.map((e=>`${e}u`)).join(",")});\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n\n        ${co(p,c,n,l)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n          let outputIndices = ${c.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${c.setByOffset("global_idx",p.getByIndices("inputIndices"))}\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)}})}},fo=(e,t)=>{oo(e.inputs,t);let n=uo(e.inputs,t);e.compute(po(e.inputs,n),{inputs:[0]})},ho=e=>{let t=e.starts,n=e.ends,r=e.axes;return rt({starts:t,ends:n,axes:r})}})),Bs=P((()=>{Qo(),Jo(),Zo(),mo=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},go=(e,t)=>{let n=pt(e.dataType),r=e.dims,a=ot.size(r),i=t.axis;if(i<0&&(i=r.length+i),i<r.length-1)throw new Error("softmax only supports last axis for now.");let o=r[i],s=a/o,u=ht(o),l=o/u,d=1===u?n:`vec${u}<${n}>`,c="f32"===n?`var threadMax = ${d}(-3.402823e+38f);`:`var threadMax = ${d}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:s}}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${d};\n      var<workgroup> rowSumShared : ${d};\n      var<workgroup> threadShared : array<${d}, 64>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${d}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${d}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${d} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${d}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(64, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = 64;\n        let row = gindex / wg;\n        let cols = ${l};\n        let row_stride : i32 = ${l};\n\n        // find the rows max\n        ${c}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${d}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",u)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${d}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${d}(${yt("threadShared[0]",u)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},yo=(e,t)=>{mo(e.inputs),e.compute(go(e.inputs[0],t))},wo=e=>rt({axis:e.axis})})),Ms=P((()=>{Qo(),Jo(),Zo(),$o=e=>{if(!e||e.length<1)throw new Error("too few inputs")},vo=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),rt({numOutputs:r,axis:t.axis,splitSizes:n})},bo=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,xo=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let a=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(a):0===r?n.push(`if (outputNumber == ${r}u) { ${a} }`):r===t-1?n.push(`else { ${a} }`):n.push(`else if (outputNumber == ${r}) { ${a} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},So=(e,t)=>{let n=e[0].dims,r=ot.size(n),a=e[0].dataType,i=n.length,o=t.axis,s=o<0?n.length+o:o,u=new Array(t.numOutputs),l=$t("input",a,n),d=new Array(t.numOutputs),c=[],p=[],f=0;for(let r=0;r<t.numOutputs;r++){f+=t.splitSizes[r],d[r]=f;let i=n.slice();i[t.axis]=t.splitSizes[r],p.push(i),u[r]=vt(`output${r}`,a,p[r]),c.push({dims:p[r],dataType:e[0].dataType})}let h=i<2?"indices":`indices[${s}]`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:e=>`\n  ${e.declareVariables(l,...u)}\n  const sizeInConcatAxis = array<u32, ${d.length}>(${d.map((e=>`${e}u`)).join(",")});\n  ${bo(d.length)}\n  ${xo(u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n\n    var indices = ${l.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${h});\n    if (outputNumber != 0) {\n        ${h} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`,getRunData:()=>({outputs:c,dispatchGroup:{x:Math.ceil(r/64)}})}},_o=(e,t)=>{$o(e.inputs);let n=1===e.inputs.length?t:vo(e.inputs,t);e.compute(So(e.inputs,n),{inputs:[0]})},Co=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return rt({axis:t,numOutputs:r,splitSizes:n})}})),Ds=P((()=>{Lo(),Qo(),Zo(),Eo=e=>Array.from(e.getBigInt64Array(),Number),Io=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Eo(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Ao=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Oo=e=>{let t=e[0].dims,n=Eo(e[1]),r=Ao(t,n),a=ot.size(r),i=e[0].dataType,o=$t("input",i,t),s=vt("output",i,r);return{name:"Tile",shaderCache:{hint:`${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:e=>`\n      const inputShape = ${o.indices(...t)};\n      ${e.declareVariables(o,s)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n      let outputIndices = ${s.offsetToIndices("global_idx")};\n      var inputIndices: ${o.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${s.indicesGet("outputIndices","i")}  % ${o.indicesGet("inputShape","i")};\n\n        ${o.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${s.setByOffset("global_idx",o.getByIndices("inputIndices"))}\n    }`}},To=e=>{Io(e.inputs),e.compute(Oo(e.inputs),{inputs:[0]})}})),Ps=P((()=>{Lo(),Qo(),Zo(),Ro=(e,t,n,r,a)=>{let i,o=ot.size(n),s=Math.ceil(o/4),u=vt("outputData",a,n,4),l=$t("aData",t[1].dataType,t[1].dims,4),d=$t("bData",t[2].dataType,t[2].dims,4),c=$t("cData",t[0].dataType,t[0].dims,4),p=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`,i=`bool(cData[indexC${t}] & ${4278190080>>>8*(3-t)}u)`;return`\n            let outputIndices${t} = ${u.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${l.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let offsetB${t} = ${d.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let offsetC${t} = ${c.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let indexC${t} = offsetC${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${p(r,a,i)});\n          `};i=9===a?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}else i=u.setByOffset("global_idx",p(l.getByOffset("global_idx"),d.getByOffset("global_idx"),c.getByOffset("global_idx")));return`\n        ${e.declareVariables(c,l,d,u)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        ${i}\n      }`},ko=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,a=e[1].dataType,i=!(ot.areEqual(t,n)&&ot.areEqual(n,r)),o=t,s=ot.size(t);if(i){let e=it.calcShape(it.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can't perform where op on the given tensors");o=e,s=ot.size(o)}return{name:"Where",getShaderSource:t=>Ro(t,e,o,i,a),getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:Math.ceil(s/64/4)}})}},Bo=e=>{e.compute(ko(e.inputs))}})),zs=P((()=>{rs(),as(),os(),ss(),us(),ms(),ws(),$s(),vs(),bs(),xs(),Ss(),_s(),Cs(),Es(),Is(),As(),Os(),ns(),Ts(),Rs(),ks(),Bs(),Ms(),Ds(),es(),is(),Ps(),Mo=new Map([["Abs",[zn]],["Acos",[Wn]],["Acosh",[Nn]],["Add",[_r]],["ArgMax",[Tn,Rn]],["ArgMin",[On,Rn]],["Asin",[Gn]],["Asinh",[Un]],["Atan",[Vn]],["Atanh",[jn]],["AveragePool",[Ii,Ei]],["BiasAdd",[Mn]],["BiasSplitGelu",[vr]],["Cast",[Hn,Fn]],["Ceil",[Kn]],["ClipV10",[Ln]],["Clip",[Yn]],["Concat",[Wr,Nr]],["Conv",[da,sa]],["ConvTranspose",[_a,$a]],["Cos",[Xn]],["Cosh",[Jn]],["Div",[Cr]],["Einsum",[ka,Ba]],["Elu",[Zn,Qn]],["Equal",[Er]],["Erf",[tr]],["Exp",[nr]],["Expand",[Wa]],["Floor",[rr]],["FusedConv",[da,sa]],["Gather",[Va,Ua]],["GatherElements",[La,Ha]],["Gelu",[ar]],["Gemm",[Xa,Ja]],["GlobalAveragePool",[Ti,Oi]],["GlobalMaxPool",[Di,Mi]],["Greater",[Tr]],["GreaterOrEqual",[kr]],["InstanceNormalization",[ri,ni]],["LayerNormalization",[si,oi]],["LeakyRelu",[ir,Qn]],["Less",[Rr]],["LessOrEqual",[Br]],["Log",[yr]],["MatMul",[li]],["MaxPool",[ki,Bi]],["Mul",[Ir]],["Neg",[sr]],["Not",[or]],["Pad",[$i,vi]],["Pow",[Ar]],["Range",[Wi]],["Reciprocal",[ur]],["ReduceMin",[bn,En]],["ReduceMean",[gn,En]],["ReduceMax",[vn,En]],["ReduceSum",[Sn,En]],["ReduceProd",[xn,En]],["ReduceL1",[yn,En]],["ReduceL2",[wn,En]],["ReduceLogSum",[Cn,En]],["ReduceLogSumExp",[$n,En]],["ReduceSumSquare",[_n,En]],["Relu",[lr]],["Resize",[eo,to]],["Sigmoid",[dr]],["Sin",[cr]],["Sinh",[pr]],["Slice",[fo,ho]],["SkipLayerNormalization",[ao,io]],["Split",[_o,Co]],["Sqrt",[fr]],["Softmax",[yo,wo]],["Sub",[Or]],["Tan",[hr]],["Tanh",[mr]],["ThresholdedRelu",[gr,Qn]],["Tile",[To]],["Transpose",[Tt,Rt]],["Where",[Bo]]])})),Ws=P((()=>{Lo(),qo(),Zo(),Do=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,a,i,o){let s=this.backend.device,u=this.backend.getComputePassEncoder();u.setPipeline(e.computePipeline);let l=[];for(let e of r)l.push({binding:l.length,resource:{buffer:e.buffer}});for(let e of a)l.push({binding:l.length,resource:{buffer:e.buffer}});o&&l.push({binding:l.length,resource:o});let d=s.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:l,label:e.programInfo.name});if(u.setBindGroup(0,d),u.dispatchWorkgroups(...i),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(8*this.backend.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let e=this.backend.gpuDataManager.create(8*this.backend.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,e.buffer,0,8*this.backend.querySetCount),this.backend.flush();let r=this.backend.currentKernelId,a=this.backend.kernels.get(r),i=`[${a[0]}] ${a[1]}`;e.buffer.mapAsync(GPUMapMode.READ).then((()=>{let a=new BigUint64Array(e.buffer.getMappedRange()),o=a[0],s=a[1];e.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=o);let u=Number(o-this.backend.queryTimeBase),l=Number(s-this.backend.queryTimeBase);if(!Number.isSafeInteger(u)||!Number.isSafeInteger(l))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id);let d="";t.forEach(((e,t)=>{d+=`input[${t}]: [${e.dims}] | ${Pe(e.dataType)}, `}));let c="";n.forEach(((e,t)=>{c+=`output[${t}]: [${e.dims}] | ${Pe(e.dataType)}, `})),console.log(`[profiling] kernel "${r}|${i}" ${d}${c}execution time: ${l-u} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){let n=this.backend.device,r=[];n.features.has("shader-f16")&&r.push("enable f16;");let a=xt(t),i=e.getShaderSource(a),o=`${r.join("\n")}\n${a.additionalImplementations}\n${i}`,s=n.createShaderModule({code:o,label:e.name});return Ye("verbose",(()=>`[WebGPU] shader code: ${o}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:s,entryPoint:"main"},layout:"auto",label:e.name})}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&n<=a&&r<=a)return[t,n,r];let i=t*n*r,o=Math.ceil(Math.sqrt(i));if(o>a){if(o=Math.ceil(Math.cbrt(i)),o>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}return[o,o,1]}}})),Ns=P((()=>{qo(),Yo(),Xo(),zs(),Ws(),Po=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let a=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${a}`);break;case"rank":{let t=e[r].dims.length;n.push(`${a};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${a};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},zo=(e,t)=>{let n=e.name;return e.shaderCache?.hint&&(n+="["+e.shaderCache.hint+"]"),n+=`:${Po(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,n},Wo=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.querySetCount=2,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n};t.features.has("timestamp-query")&&n.push("timestamp-query"),t.features.has("shader-f16")&&n.push("shader-f16"),this.device=await t.requestDevice(r),this.gpuDataManager=tt(this),this.programManager=new Do(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Le(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!(!this.device.features.has("timestamp-query")||"default"!==this.env.webgpu.profilingMode)}run(e,t,n,r,a){let i=[];for(let e=0;e<t.length;++e){let n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);i[e]=n}let o=zo(e,t),s=this.programManager.getArtifact(o),{outputs:u,dispatchGroup:l,programUniforms:d}=e.getRunData(t),c=0===n.length?u.map(((e,t)=>t)):n;if(c.length!==u.length)throw new Error(`Output size ${c.length} must be equal to ${u.length}.`);let p,f=[],h=[];for(let e=0;e<u.length;++e){if(!Number.isInteger(c[e])||c[e]<-3||c[e]>=u.length)throw new Error(`Invalid output index: ${c[e]}`);if(-3===c[e])continue;let t=-1===c[e],n=-2===c[e],i=t||n?a(u[e].dataType,u[e].dims):r(c[e],u[e].dataType,u[e].dims),o=this.gpuDataManager.get(i.data);if(!o)throw new Error(`no GPU data for output: ${i.data}`);if(t&&this.temporaryData.push(o),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(o)}f.push(i),h.push(o)}if(d){let e=0,t=0,n=[],r=1;d.forEach((a=>{let i,o="number"==typeof a.data?[a.data]:a.data;switch(o.length){case 1:i=4;break;case 2:i=8;break;case 3:case 4:case 5:case 6:i=16;break;default:throw new Error(`unsupported data length: ${o.length}`)}(5===t||6===t)&&(i=16),i>r&&(r=i),e=Math.ceil(e/i)*i,t=o.length,n.push(e),e+=4*o.length})),e=Math.ceil(e/r)*r;let a=new ArrayBuffer(e);d.forEach(((e,t)=>{let r=n[t],i="number"==typeof e.data?[e.data]:e.data;"int32"===e.type?new Int32Array(a,r,i.length).set(i):"uint32"===e.type?new Uint32Array(a,r,i.length).set(i):new Float32Array(a,r,i.length).set(i)}));let i=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(i.buffer,0,a,0,e),this.gpuDataManager.release(i.id),p={offset:0,size:e,buffer:i.buffer}}let m=this.programManager.normalizeDispatchGroupSize(l);return s||(s=this.programManager.build(e,m),this.programManager.setArtifact(o,s)),Ye("info",(()=>`[ProgramManager] run "${e.name}" (key=${o}) with ${m[0]}x${m[1]}x${m[2]}`)),this.programManager.run(s,t,f,i,h,m,p),f}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let a=Mo.get(e);if(!a)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r,a[0],[a[1],n]])}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let[a,i,o,s]=r;if(null!==this.currentKernelId)throw new Error(`kernel "[${a}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,s[0]&&(s[1]=s[0](s[1]),s[0]=void 0),Ye("info",(()=>`[WebGPU] Start to run kernel "[${a}] ${i}"...`));let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),o(t,s[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${i}" failed. ${e}`)),1}finally{u&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${a}] ${i}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let a=this.sessionExternalDataMapping.get(e);a||(a=new Map,this.sessionExternalDataMapping.set(e,a));let i=a.get(t),o=this.gpuDataManager.registerExternalBuffer(n,r,i?.[1]);return a.set(t,[o,n]),o}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[1]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await Ze(this,e,t);return Ke(r.buffer,n)}}}})),Gs={};W(Gs,{init:()=>js});var Us,Vs,js,Fs,Hs,Ls,qs,Ys,Ks,Xs,Js,Qs,Zs,eu,tu,nu,ru,au,iu,ou,su,uu,lu,du,cu,pu,fu,hu,mu,gu,yu,wu,$u,vu,bu,xu,Su,_u,Cu,Eu,Iu,Au,Ou,Tu,Ru,ku,Bu,Mu,Du,Pu=P((()=>{Lo(),Ns(),qo(),Qo(),Us=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(ot.size(t)!==ot.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Vs=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0;let r=e.HEAPU32,a=n>>2;this.opKernelContext=r[a++];let i=r[a++];this.outputCount=r[a++],this.customDataOffset=r[a++],this.customDataSize=r[a++];let o=[];for(let t=0;t<i;t++){let t=r[a++],n=r[a++],i=r[a++],s=[];for(let e=0;e<i;e++)s.push(r[a++]);o.push(new Us(e,t,n,s))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new Us(this.module,t,this.output(e,n),n)),((e,t)=>{let n=ze(e);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n*ot.size(t);return new Us(this.module,e,this.backend.gpuDataManager.create(r).id,t)}))}output(e,t){let n=this.module.stackSave();try{let n=this.module.stackAlloc(4*(1+t.length)),r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},js=async(e,t)=>{let n=e.jsepInit;if(n&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let r=new Wo;await r.initialize(t),n(r,(e=>r.alloc(e)),(e=>r.free(e)),((t,n,a,i=!1)=>{if(i)Ye("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${a}`)),r.memcpy(t,n);else{Ye("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${a}`));let i=e.HEAPU8.subarray(t,t+a);r.upload(n,i)}}),(async(t,n,a)=>{Ye("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${a}`)),await r.download(t,(()=>e.HEAPU8.subarray(n,n+a)))}),((n,a,i)=>r.createKernel(n,a,i,t.debug||"default"===t.webgpu.profilingMode?e.UTF8ToString(e._JsepGetNodeName(a)):`${a}`)),(e=>r.releaseKernel(e)),((t,n,a,i)=>{Ye("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${a}, kernel=${t}, contextDataOffset=${n}`));let o=new Vs(e,r,n);return r.computeKernel(t,o,i)}))}}})),zu=P((()=>{Fo(),Ho(),Lo(),Vo(),jo(),Fs=!1,Hs=e=>{let t=Ce(),n=t.stackSave();try{let n=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,n,n+4)&&Ae("Can't get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(n)}},Ls=(e,t)=>{0!==Ce()._OrtInit(e,t)&&Ae("Can't initialize onnxruntime.")},qs=async e=>{Ls(e.wasm.numThreads,Ne(e.logLevel));{let t=(Pu(),N(Gs)).init;await t(Ce(),e)}Fs=!0},Ys=new Map,Ks=()=>Fs,Xs=e=>{let t=Ce(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Js=(e,t)=>{let n=Ce(),r=0,a=0,i=0,o=[],s=[],u=[];try{[a,o]=Me(t),r=n._OrtCreateSession(e[0],e[1],a),0===r&&Ae("Can't create a session.");let[l,d]=Hs(r),c=[],p=[],f=[];for(let e=0;e<l;e++){let t=n._OrtGetInputName(r,e);0===t&&Ae("Can't get an input name."),s.push(t),c.push(n.UTF8ToString(t))}for(let e=0;e<d;e++){let a=n._OrtGetOutputName(r,e);0===a&&Ae("Can't get an output name."),u.push(a);let i=n.UTF8ToString(a);p.push(i);{let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[i]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}.`);f.push(e)}}let h=null;return f.some((e=>"gpu-buffer"===e))&&(i=n._OrtCreateBinding(r),0===i&&Ae("Can't create IO binding."),h={handle:i,outputPreferredLocations:f,outputPreferredLocationsEncoded:f.map((e=>Ue(e)))}),Ys.set(r,[r,s,u,h]),[r,c,p]}catch(e){throw s.forEach((e=>n._OrtFree(e))),u.forEach((e=>n._OrtFree(e))),0!==i&&n._OrtReleaseBinding(i),0!==r&&n._OrtReleaseSession(r),e}finally{n._free(e[0]),0!==a&&n._OrtReleaseSessionOptions(a),o.forEach((e=>n._free(e)))}},Qs=(e,t)=>{let n=Xs(e);return Js(n,t)},Zs=e=>{let t=Ce(),n=Ys.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,a,i,o]=n;o&&t._OrtReleaseBinding(o.handle),t.jsepUnregisterBuffers?.(e),a.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(r),Ys.delete(e)},eu=(e,t,n,r,a)=>{if(!e)return void t.push(0);let i,o,s=Ce(),u=e[0],l=e[1],d=e[3];if("string"===u&&"gpu-buffer"===d)throw new Error("String tensor is not supported on GPU.");if("gpu-buffer"===d){let t=e[2].gpuBuffer,n=ze(De(u));o=l.reduce(((e,t)=>e*t),1)*n,i=s.jsepRegisterBuffer(r,a,t,o)}else{let t=e[2];if(Array.isArray(t)){o=4*t.length,i=s._malloc(o),n.push(i);let e=i/4;for(let r=0;r<t.length;r++){if("string"!=typeof t[r])throw new TypeError(`tensor data at index ${r} is not a string`);s.HEAPU32[e++]=Ee(t[r],n)}}else o=t.byteLength,i=s._malloc(o),n.push(i),s.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),i)}let c=s.stackSave(),p=s.stackAlloc(4*l.length);try{let e=p/4;l.forEach((t=>s.HEAP32[e++]=t));let n=s._OrtCreateTensor(De(u),i,o,p,l.length,Ue(d));0===n&&Ae(`Can't create tensor for input/output. session=${r}, index=${a}.`),t.push(n)}finally{s.stackRestore(c)}},tu=async(e,t,n,r,a,i)=>{let o=Ce(),s=Ys.get(e);if(!s)throw new Error(`cannot run inference. invalid session id: ${e}`);let[u,l,d,c]=s,p=t.length,f=r.length,h=0,m=[],g=[],y=[],w=[],$=o.stackSave(),v=o.stackAlloc(4*p),b=o.stackAlloc(4*p),x=o.stackAlloc(4*f),S=o.stackAlloc(4*f);try{[h,m]=Oe(i);for(let r=0;r<p;r++)eu(n[r],g,w,e,t[r]);for(let t=0;t<f;t++)eu(a[t],y,w,e,p+r[t]);let s,$=v/4,_=b/4,C=x/4,E=S/4;for(let e=0;e<p;e++)o.HEAPU32[$++]=g[e],o.HEAPU32[_++]=l[t[e]];for(let e=0;e<f;e++)o.HEAPU32[C++]=y[e],o.HEAPU32[E++]=d[r[e]];if(c){let{handle:n,outputPreferredLocations:i,outputPreferredLocationsEncoded:s}=c;if(l.length!==p)throw new Error(`input count from feeds (${p}) is expected to be always equal to model's input count (${l.length}).`);for(let r=0;r<p;r++){let a=t[r];0!==await o._OrtBindInput(n,l[a],g[r])&&Ae(`Can't bind input[${r}] for session=${e}.`)}for(let t=0;t<f;t++){let u=r[t];a[t]?.[3]?0!==o._OrtBindOutput(n,d[u],y[t],0)&&Ae(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==o._OrtBindOutput(n,d[u],0,s[u])&&Ae(`Can't bind output[${t}] to ${i[t]} for session=${e}.`)}}s=c?await o._OrtRunWithBinding(u,c.handle,f,x,h):await o._OrtRun(u,b,v,p,S,f,x,h),0!==s&&Ae("failed to call OrtRun().");let I=[];for(let e=0;e<f;e++){let t=o.HEAPU32[x/4+e];if(t===y[e]){I.push(a[e]);continue}let n,i=o.stackSave(),s=o.stackAlloc(16),u=!1,l=0;try{0!==o._OrtGetTensorData(t,s,s+4,s+8,s+12)&&Ae(`Can't access output tensor data on index ${e}.`);let a=s/4,i=o.HEAPU32[a++];l=o.HEAPU32[a++];let d=o.HEAPU32[a++],p=o.HEAPU32[a++],f=[];for(let e=0;e<p;e++)f.push(o.HEAPU32[d/4+e]);o._OrtFree(d);let h=f.reduce(((e,t)=>e*t),1);n=Pe(i);let m=c?.outputPreferredLocations[r[e]];if("string"===n){if("gpu-buffer"===m)throw new Error("String tensor is not supported on GPU.");let e=[],t=l/4;for(let n=0;n<h;n++){let r=o.HEAPU32[t++],a=n===h-1?void 0:o.HEAPU32[t]-r;e.push(o.UTF8ToString(r,a))}I.push([n,f,e,"cpu"])}else if("gpu-buffer"===m&&h>0){let e=o.jsepGetBuffer(l),r=ze(i);if(void 0===r||!Ge(n))throw new Error(`Unsupported data type: ${n}`);u=!0,I.push([n,f,{gpuBuffer:e,download:o.jsepCreateDownloader(e,h*r,n),dispose:()=>{o._OrtReleaseTensor(t)}},"gpu-buffer"])}else{let e=new(We(n))(h);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(o.HEAPU8.subarray(l,l+e.byteLength)),I.push([n,f,e,"cpu"])}}finally{o.stackRestore(i),"string"===n&&l&&o._free(l),u||o._OrtReleaseTensor(t)}}return c&&o._OrtClearBoundOutputs(c.handle),I}finally{o.stackRestore($),g.forEach((e=>o._OrtReleaseTensor(e))),y.forEach((e=>o._OrtReleaseTensor(e))),w.forEach((e=>o._free(e))),0!==h&&o._OrtReleaseRunOptions(h),m.forEach((e=>o._free(e)))}},nu=e=>{let t=Ce(),n=Ys.get(e);if(!n)throw new Error("invalid session id");let r=n[0],a=t._OrtEndProfiling(r);0===a&&Ae("Can't get an profile file name."),t._OrtFree(a)},ru=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),Wu=z(((e,t)=>{t.exports='/*!\n * ONNX Runtime Web v1.17.0-dev.20231103-1439da36fe\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var on=Object.defineProperty;var Su=Object.getOwnPropertyDescriptor;var Cu=Object.getOwnPropertyNames;var Au=Object.prototype.hasOwnProperty;var H=(e,t)=>()=>(e&&(t=e(e=0)),t);var Jt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ir=(e,t)=>{for(var r in t)on(e,r,{get:t[r],enumerable:!0})},Iu=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Cu(t))!Au.call(e,n)&&n!==r&&on(e,n,{get:()=>t[n],enumerable:!(o=Su(t,n))||o.enumerable});return e};var Mt=e=>Iu(on({},"__esModule",{value:!0}),e);var an={};Ir(an,{readFile:()=>Eu});var Eu,sn=H(()=>{Eu=void 0});var un={};Ir(un,{join:()=>Tu});var Tu,ln=H(()=>{Tu=void 0});var uo=Jt((so,dn)=>{"use strict";var io=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((l,p)=>{o=l,n=p}),r.jsepInit=(l,p,h,C,T,U,G,ue)=>{r.Za=l,r.Oa=p,r.Qa=h,r.Ja=C,r.Pa=T,r.ra=U,r.Ra=G,r.Sa=ue,p=(Y,Q,J)=>(...ce)=>{let me=He,E=Q?.();ce=Y(...ce);let te=Q?.();return E!==te&&(Y=te,J(E),Q=J=null),He!=me?gr():ce},h=Y=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let J=r.Da={Ta:Q[0],errors:[]},ce=await Y(...Q);if(r.Da!==J)throw Error("Session mismatch");l.flush();let me=J.errors;if(0<me.length){let E=await Promise.all(me);if(E=E.filter(te=>te),0<E.length)throw Error(E.join(`\n`))}return ce}finally{r.Da=null}},r._OrtRun=h(p(r._OrtRun,()=>r._OrtRun,Y=>r._OrtRun=Y)),r._OrtRunWithBinding=h(p(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Y=>r._OrtRunWithBinding=Y)),r._OrtBindInput=p(r._OrtBindInput,()=>r._OrtBindInput,Y=>r._OrtBindInput=Y),r.jsepRegisterBuffer=(Y,Q,J,ce)=>l.registerBuffer(Y,Q,J,ce),r.jsepUnregisterBuffers=Y=>{l.unregisterBuffers(Y)},r.jsepGetBuffer=Y=>l.getBuffer(Y),r.jsepCreateDownloader=(Y,Q,J)=>l.createDownloader(Y,Q,J)};var s=Object.assign({},r),u="./this.program",d=(l,p)=>{throw p},a=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x="",b,w,v;if(g){var y=(sn(),Mt(an)),S=(ln(),Mt(un));x=m?S.dirname(x)+"/":__dirname+"/",b=(l,p)=>(l=l.startsWith("file://")?new URL(l):S.normalize(l),y.readFileSync(l,p?void 0:"utf8")),v=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),w=(l,p,h,C=!0)=>{l=l.startsWith("file://")?new URL(l):S.normalize(l),y.readFile(l,C?void 0:"utf8",(T,U)=>{T?h(T):p(C?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,p)=>{throw process.exitCode=l,p},r.inspect=()=>"[Emscripten Module object]"}else(a||m)&&(m?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),e&&(x=e),x.indexOf("blob:")!==0?x=x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):x="",b=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.send(null),p.responseText},m&&(v=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),w=(l,p,h)=>{var C=new XMLHttpRequest;C.open("GET",l,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?p(C.response):h()},C.onerror=h,C.send(null)});var A=r.print||console.log.bind(console),R=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(d=r.quit);var W;r.wasmBinary&&(W=r.wasmBinary);var M=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Le("no native wasm support detected");var D,_,z=!1,F,q,le,B,K,xe,ae;function we(){var l=D.buffer;r.HEAP8=q=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=B=new Int32Array(l),r.HEAPU8=le=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=K=new Uint32Array(l),r.HEAPF32=xe=new Float32Array(l),r.HEAPF64=ae=new Float64Array(l)}var j=[],Se=[],Oe=[];function Ie(){var l=r.preRun.shift();j.unshift(l)}var Ce=0,dt=null,Ne=null;function Le(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",R(l),z=!0,F=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function N(l){return l.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!N(de)){var pe=de;de=r.locateFile?r.locateFile(pe,x):x+pe}function ze(l){if(l==de&&W)return new Uint8Array(W);if(v)return v(l);throw"both async and sync fetching of the wasm failed"}function Ue(l){if(!W&&(a||m)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at \'"+l+"\'";return p.arrayBuffer()}).catch(()=>ze(l));if(w)return new Promise((p,h)=>{w(l,C=>p(new Uint8Array(C)),h)})}return Promise.resolve().then(()=>ze(l))}function Te(l,p,h){return Ue(l).then(C=>WebAssembly.instantiate(C,p)).then(C=>C).then(h,C=>{R("failed to asynchronously prepare wasm: "+C),Le(C)})}function ke(l,p){var h=de;return W||typeof WebAssembly.instantiateStreaming!="function"||N(h)||h.startsWith("file://")||g||typeof fetch!="function"?Te(h,l,p):fetch(h,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,l).then(p,function(T){return R("wasm streaming compile failed: "+T),R("falling back to ArrayBuffer instantiation"),Te(h,l,p)}))}var Ge,Xe={913792:l=>{r.ra("Abs",l,void 0)},913843:l=>{r.ra("Neg",l,void 0)},913894:l=>{r.ra("Floor",l,void 0)},913947:l=>{r.ra("Ceil",l,void 0)},913999:l=>{r.ra("Reciprocal",l,void 0)},914057:l=>{r.ra("Sqrt",l,void 0)},914109:l=>{r.ra("Exp",l,void 0)},914160:l=>{r.ra("Erf",l,void 0)},914211:l=>{r.ra("Sigmoid",l,void 0)},914266:l=>{r.ra("Log",l,void 0)},914317:l=>{r.ra("Sin",l,void 0)},914368:l=>{r.ra("Cos",l,void 0)},914419:l=>{r.ra("Tan",l,void 0)},914470:l=>{r.ra("Asin",l,void 0)},914522:l=>{r.ra("Acos",l,void 0)},914574:l=>{r.ra("Atan",l,void 0)},914626:l=>{r.ra("Sinh",l,void 0)},914678:l=>{r.ra("Cosh",l,void 0)},914730:l=>{r.ra("Asinh",l,void 0)},914783:l=>{r.ra("Acosh",l,void 0)},914836:l=>{r.ra("Atanh",l,void 0)},914889:l=>{r.ra("Tanh",l,void 0)},914941:l=>{r.ra("Not",l,void 0)},914992:(l,p,h)=>{r.ra("ClipV10",l,{min:p,max:h})},915064:l=>{r.ra("Clip",l,void 0)},915116:(l,p)=>{r.ra("Elu",l,{alpha:p})},915174:l=>{r.ra("Relu",l,void 0)},915226:(l,p)=>{r.ra("LeakyRelu",l,{alpha:p})},915290:(l,p)=>{r.ra("ThresholdedRelu",l,{alpha:p})},915360:(l,p)=>{r.ra("Cast",l,{to:p})},915418:l=>{r.ra("Add",l,void 0)},915469:l=>{r.ra("Sub",l,void 0)},915520:l=>{r.ra("Mul",l,void 0)},915571:l=>{r.ra("Div",l,void 0)},915622:l=>{r.ra("Pow",l,void 0)},915673:l=>{r.ra("Equal",l,void 0)},915726:l=>{r.ra("Greater",l,void 0)},915781:l=>{r.ra("GreaterOrEqual",l,void 0)},915843:l=>{r.ra("Less",l,void 0)},915895:l=>{r.ra("LessOrEqual",l,void 0)},915954:(l,p,h,C,T)=>{r.ra("ReduceMean",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916118:(l,p,h,C,T)=>{r.ra("ReduceMax",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916281:(l,p,h,C,T)=>{r.ra("ReduceMin",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916444:(l,p,h,C,T)=>{r.ra("ReduceProd",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916608:(l,p,h,C,T)=>{r.ra("ReduceSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916771:(l,p,h,C,T)=>{r.ra("ReduceL1",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916933:(l,p,h,C,T)=>{r.ra("ReduceL2",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917095:(l,p,h,C,T)=>{r.ra("ReduceLogSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917261:(l,p,h,C,T)=>{r.ra("ReduceSumSquare",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917430:(l,p,h,C,T)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917599:l=>{r.ra("Where",l,void 0)},917652:(l,p,h)=>{r.ra("Transpose",l,{perm:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[]})},917765:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[T],pads:[U,G],strides:[ue],wIsConst:()=>!!q[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},918179:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:ue?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(T>>>0,T+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!q[Y>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},918736:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[T],pads:[U,G],strides:[ue],wIsConst:()=>!!q[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},919150:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:ue?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(T>>>0,T+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!q[Y>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},919707:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},919798:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920082:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},920173:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920457:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},920544:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920824:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},920911:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},921191:(l,p,h,C,T)=>{r.ra("Gemm",l,{alpha:p,beta:h,transA:C,transB:T})},921295:l=>{r.ra("MatMul",l,void 0)},921349:(l,p,h,C)=>{r.ra("ArgMax",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},921457:(l,p,h,C)=>{r.ra("ArgMin",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},921565:(l,p)=>{r.ra("Softmax",l,{axis:p})},921628:(l,p)=>{r.ra("Concat",l,{axis:p})},921688:(l,p,h,C,T)=>{r.ra("Split",l,{axis:p,numOutputs:h,splitSizes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},921833:l=>{r.ra("Expand",l,void 0)},921887:(l,p)=>{r.ra("Gather",l,{axis:Number(p)})},921958:(l,p)=>{r.ra("GatherElements",l,{axis:Number(p)})},922037:(l,p,h,C,T,U,G,ue,Y,Q,J)=>{r.ra("Resize",l,{antialias:p,axes:h?Array.from(B.subarray(C>>>0,C+h>>>0)):[],coordinateTransformMode:_e(T),cubicCoeffA:U,excludeOutside:G,extrapolationValue:ue,keepAspectRatioPolicy:_e(Y),mode:_e(Q),nearestMode:_e(J)})},922388:(l,p,h,C,T,U,G)=>{r.ra("Slice",l,{starts:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[],ends:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[],axes:U?Array.from(B.subarray(G>>>0,G+U>>>0)):[]})},922619:l=>{r.ra("Tile",l,void 0)},922671:(l,p,h)=>{r.ra("LayerNormalization",l,{axis:Number(p),epsilon:Number(h)})},922778:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},922892:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},923006:l=>{r.ra("Range",l,void 0)},923059:(l,p)=>{r.ra("Einsum",l,{equation:_e(p)})},923140:(l,p,h,C,T)=>{r.ra("Pad",l,{mode:p,value:h,pads:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},923272:l=>{r.ra("Gelu",l,void 0)},923324:l=>{r.ra("BiasAdd",l,void 0)},923379:l=>{r.ra("BiasSplitGelu",l,void 0)},923440:(l,p)=>{r.ra("SkipLayerNormalization",l,{epsilon:p})},923521:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me)=>{r.ra("Conv",l,{format:Y?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:C,kernel_shape:[T],pads:U?Array.from(B.subarray(G>>>0,G+U>>>0)):[],strides:[ue],w_is_const:()=>!!q[Q>>>0],activation:_e(J),activation_params:ce?Array.from(xe.subarray(me>>>0,me+ce>>>0)):[]})},923902:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("Conv",l,{format:ce?"NHWC":"NCHW",auto_pad:p,dilations:[h,C],group:T,kernel_shape:[U,G],pads:ue?Array.from(B.subarray(Y>>>0,Y+ue>>>0)):[],strides:[Q,J],w_is_const:()=>!!q[me>>>0],activation:_e(E),activation_params:te?Array.from(xe.subarray(fe>>>0,fe+te>>>0)):[]})},924304:l=>{r.Ra(l)},924338:(l,p)=>r.Sa(l,p,r.Da.Ta,r.Da.errors),924450:l=>r.Oa(l),924483:l=>r.Qa(l),924515:(l,p,h)=>{r.Ja(l,p,h,!0)},924554:(l,p,h)=>{r.Ja(l,p,h)}};function Fe(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var yt=l=>{for(;0<l.length;)l.shift()(r)};function bt(l){this.Ha=l-24,this.Ma=function(p){K[this.Ha+4>>2>>>0]=p},this.La=function(p){K[this.Ha+8>>2>>>0]=p},this.Ya=function(p,h){this.Ka(),this.Ma(p),this.La(h)},this.Ka=function(){K[this.Ha+16>>2>>>0]=0}}var Bt=0,lr=0,Ke=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,kt=(l,p,h)=>{p>>>=0;var C=p+h;for(h=p;l[h]&&!(h>=C);)++h;if(16<h-p&&l.buffer&&Ke)return Ke.decode(l.subarray(p,h));for(C="";p<h;){var T=l[p++];if(T&128){var U=l[p++]&63;if((T&224)==192)C+=String.fromCharCode((T&31)<<6|U);else{var G=l[p++]&63;T=(T&240)==224?(T&15)<<12|U<<6|G:(T&7)<<18|U<<12|G<<6|l[p++]&63,65536>T?C+=String.fromCharCode(T):(T-=65536,C+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else C+=String.fromCharCode(T)}return C},_e=(l,p)=>(l>>>=0)?kt(le,l,p):"",It=l=>{for(var p=0,h=0;h<l.length;++h){var C=l.charCodeAt(h);127>=C?p++:2047>=C?p+=2:55296<=C&&57343>=C?(p+=4,++h):p+=3}return p},Dt=(l,p,h,C)=>{if(h>>>=0,!(0<C))return 0;var T=h;C=h+C-1;for(var U=0;U<l.length;++U){var G=l.charCodeAt(U);if(55296<=G&&57343>=G){var ue=l.charCodeAt(++U);G=65536+((G&1023)<<10)|ue&1023}if(127>=G){if(h>=C)break;p[h++>>>0]=G}else{if(2047>=G){if(h+1>=C)break;p[h++>>>0]=192|G>>6}else{if(65535>=G){if(h+2>=C)break;p[h++>>>0]=224|G>>12}else{if(h+3>=C)break;p[h++>>>0]=240|G>>18,p[h++>>>0]=128|G>>12&63}p[h++>>>0]=128|G>>6&63}p[h++>>>0]=128|G&63}}return p[h>>>0]=0,h-T},at=l=>l%4===0&&(l%100!==0||l%400===0),dr=[0,31,60,91,121,152,182,213,244,274,305,335],it=[0,31,59,90,120,151,181,212,243,273,304,334],Et=l=>{var p=It(l)+1,h=Rt(p);return h&&Dt(l,le,h,p),h},ct=[],Tt=(l,p)=>{ct.length=0;var h;for(p>>=2;h=le[l++>>>0];)p+=h!=105&p,ct.push(h==105?B[p>>>0]:ae[p++>>>1]),++p;return ct},Ot={},Wt=()=>{if(!_t){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},p;for(p in Ot)Ot[p]===void 0?delete l[p]:l[p]=Ot[p];var h=[];for(p in l)h.push(`${p}=${l[p]}`);_t=h}return _t},_t,cr=[null,[],[]],Ve=[31,29,31,30,31,30,31,31,30,31,30,31],zt=[31,28,31,30,31,30,31,31,30,31,30,31];function Vt(l){var p=Array(It(l)+1);return Dt(l,p,0,p.length),p}function ne(l,p,h,C){function T(E,te,fe){for(E=typeof E=="number"?E.toString():E||"";E.length<te;)E=fe[0]+E;return E}function U(E,te){return T(E,te,"0")}function G(E,te){function fe(Xt){return 0>Xt?-1:0<Xt?1:0}var ut;return(ut=fe(E.getFullYear()-te.getFullYear()))===0&&(ut=fe(E.getMonth()-te.getMonth()))===0&&(ut=fe(E.getDate()-te.getDate())),ut}function ue(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function Y(E){var te=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<te;){var fe=E.getMonth(),ut=(at(E.getFullYear())?Ve:zt)[fe];if(te>ut-E.getDate())te-=ut-E.getDate()+1,E.setDate(1),11>fe?E.setMonth(fe+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+te);break}}return fe=new Date(E.getFullYear()+1,0,4),te=ue(new Date(E.getFullYear(),0,4)),fe=ue(fe),0>=G(te,E)?0>=G(fe,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}l>>>=0,p>>>=0,h>>>=0,C>>>=0;var Q=B[C+40>>2>>>0];C={Wa:B[C>>2>>>0],Va:B[C+4>>2>>>0],Ea:B[C+8>>2>>>0],Ia:B[C+12>>2>>>0],Fa:B[C+16>>2>>>0],Ca:B[C+20>>2>>>0],wa:B[C+24>>2>>>0],Ba:B[C+28>>2>>>0],$a:B[C+32>>2>>>0],Ua:B[C+36>>2>>>0],Xa:Q?_e(Q):""},h=_e(h),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var J in Q)h=h.replace(new RegExp(J,"g"),Q[J]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),me="January February March April May June July August September October November December".split(" ");Q={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>me[E.Fa].substring(0,3),"%B":E=>me[E.Fa],"%C":E=>U((E.Ca+1900)/100|0,2),"%d":E=>U(E.Ia,2),"%e":E=>T(E.Ia,2," "),"%g":E=>Y(E).toString().substring(2),"%G":E=>Y(E),"%H":E=>U(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),U(E,2)),"%j":E=>{for(var te=0,fe=0;fe<=E.Fa-1;te+=(at(E.Ca+1900)?Ve:zt)[fe++]);return U(E.Ia+te,3)},"%m":E=>U(E.Fa+1,2),"%M":E=>U(E.Va,2),"%n":()=>`\n`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>U(E.Wa,2),"%t":()=>"\t","%u":E=>E.wa||7,"%U":E=>U(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var te=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&te++,te)te==53&&(fe=(E.wa+371-E.Ba)%7,fe==4||fe==3&&at(E.Ca)||(te=1));else{te=52;var fe=(E.wa+7-E.Ba-1)%7;(fe==4||fe==5&&at(E.Ca%400-1))&&te++}return U(te,2)},"%w":E=>E.wa,"%W":E=>U(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var te=0<=E;return E=Math.abs(E)/60,(te?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},h=h.replace(/%%/g,"\\0\\0");for(J in Q)h.includes(J)&&(h=h.replace(new RegExp(J,"g"),Q[J](C)));return h=h.replace(/\\0\\0/g,"%"),J=Vt(h),J.length>p?0:(q.set(J,l>>>0),J.length-1)}function st(l){try{l()}catch(p){Le(p)}}function pr(l){var p={},h;for(h in l)(function(C){var T=l[C];p[C]=typeof T=="function"?function(){wt.push(C);try{return T.apply(null,arguments)}finally{z||(wt.pop()===C||Le(),He&&Je===1&&wt.length===0&&(Je=0,st(qt),typeof Fibers<"u"&&Fibers.ab()))}}:T})(h);return p}var Je=0,He=null,fr=0,wt=[],Gt={},Nt={},mr=0,vt=null,hr=[];function gr(){return new Promise((l,p)=>{vt={resolve:l,reject:p}})}function yr(){var l=Rt(65548),p=l+12;K[l>>2>>>0]=p,K[l+4>>2>>>0]=p+65536,p=wt[0];var h=Gt[p];return h===void 0&&(h=mr++,Gt[p]=h,Nt[h]=p),B[l+8>>2>>>0]=h,l}function br(l){if(!z){if(Je===0){var p=!1,h=!1;l((C=0)=>{if(!z&&(fr=C,p=!0,h)){Je=2,st(()=>Pt(He)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var T=(0,_[Nt[B[He+8>>2>>>0]]])()}catch(ue){T=ue,C=!0}var U=!1;if(!He){var G=vt;G&&(vt=null,(C?G.reject:G.resolve)(T),U=!0)}if(C&&!U)throw T}}),h=!0,p||(Je=1,He=yr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),st(()=>Kt(He)))}else Je===2?(Je=0,st($t),Ut(He),He=null,hr.forEach(C=>{if(!z)try{if(C(),!M)try{F=F=C=F,M||(r.onExit&&r.onExit(C),z=!0),d(C,new Fe(C))}catch(T){T instanceof Fe||T=="unwind"||d(1,T)}}catch(T){T instanceof Fe||T=="unwind"||d(1,T)}})):Le(`invalid state: ${Je}`);return fr}}function wr(l){return br(p=>{l().then(p)})}var vr={n:function(l,p,h){return wr(async()=>{await r.Pa(l,p,h)})},a:function(l,p,h){throw l>>>=0,new bt(l).Ya(p>>>0,h>>>0),Bt=l,lr++,Bt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getUTCSeconds(),B[h+4>>2>>>0]=l.getUTCMinutes(),B[h+8>>2>>>0]=l.getUTCHours(),B[h+12>>2>>>0]=l.getUTCDate(),B[h+16>>2>>>0]=l.getUTCMonth(),B[h+20>>2>>>0]=l.getUTCFullYear()-1900,B[h+24>>2>>>0]=l.getUTCDay(),B[h+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getSeconds(),B[h+4>>2>>>0]=l.getMinutes(),B[h+8>>2>>>0]=l.getHours(),B[h+12>>2>>>0]=l.getDate(),B[h+16>>2>>>0]=l.getMonth(),B[h+20>>2>>>0]=l.getFullYear()-1900,B[h+24>>2>>>0]=l.getDay(),B[h+28>>2>>>0]=(at(l.getFullYear())?dr:it)[l.getMonth()]+l.getDate()-1|0,B[h+36>>2>>>0]=-(60*l.getTimezoneOffset()),p=new Date(l.getFullYear(),6,1).getTimezoneOffset();var C=new Date(l.getFullYear(),0,1).getTimezoneOffset();B[h+32>>2>>>0]=(p!=C&&l.getTimezoneOffset()==Math.min(C,p))|0},s:function(l){l>>>=0;var p=new Date(B[l+20>>2>>>0]+1900,B[l+16>>2>>>0],B[l+12>>2>>>0],B[l+8>>2>>>0],B[l+4>>2>>>0],B[l>>2>>>0],0),h=B[l+32>>2>>>0],C=p.getTimezoneOffset(),T=new Date(p.getFullYear(),6,1).getTimezoneOffset(),U=new Date(p.getFullYear(),0,1).getTimezoneOffset(),G=Math.min(U,T);return 0>h?B[l+32>>2>>>0]=+(T!=U&&G==C):0<h!=(G==C)&&(T=Math.max(U,T),p.setTime(p.getTime()+6e4*((0<h?G:T)-C))),B[l+24>>2>>>0]=p.getDay(),B[l+28>>2>>>0]=(at(p.getFullYear())?dr:it)[p.getMonth()]+p.getDate()-1|0,B[l>>2>>>0]=p.getSeconds(),B[l+4>>2>>>0]=p.getMinutes(),B[l+8>>2>>>0]=p.getHours(),B[l+12>>2>>>0]=p.getDate(),B[l+16>>2>>>0]=p.getMonth(),B[l+20>>2>>>0]=p.getYear(),l=p.getTime()/1e3,Lt((Ge=l,1<=+Math.abs(Ge)?0<Ge?+Math.floor(Ge/4294967296)>>>0:~~+Math.ceil((Ge-+(~~Ge>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,p,h){function C(Y){return(Y=Y.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Y[1]:"GMT"}h>>>=0;var T=new Date().getFullYear(),U=new Date(T,0,1),G=new Date(T,6,1);T=U.getTimezoneOffset();var ue=G.getTimezoneOffset();K[l>>>0>>2>>>0]=60*Math.max(T,ue),B[p>>>0>>2>>>0]=+(T!=ue),l=C(U),p=C(G),l=Et(l),p=Et(p),ue<T?(K[h>>2>>>0]=l,K[h+4>>2>>>0]=p):(K[h>>2>>>0]=p,K[h+4>>2>>>0]=l)},e:()=>{Le("")},b:function(l,p,h){return l>>>=0,p=Tt(p>>>0,h>>>0),Xe[l].apply(null,p)},i:function(l,p,h){return l>>>=0,p=Tt(p>>>0,h>>>0),Xe[l].apply(null,p)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,p,h){return p>>>=0,le.copyWithin(l>>>0>>>0,p>>>0,p+(h>>>0)>>>0)},u:function(l){l>>>=0;var p=le.length;if(4294901760<l)return!1;for(var h=1;4>=h;h*=2){var C=p*(1+.2/h);C=Math.min(C,l+100663296);var T=Math;C=Math.max(l,C);e:{T=T.min.call(T,4294901760,C+(65536-C%65536)%65536)-D.buffer.byteLength+65535>>>16;try{D.grow(T),we();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(l,p){l>>>=0,p>>>=0;var h=0;return Wt().forEach(function(C,T){var U=p+h;for(T=K[l+4*T>>2>>>0]=U,U=0;U<C.length;++U)q[T++>>0>>>0]=C.charCodeAt(U);q[T>>0>>>0]=0,h+=C.length+1}),0},E:function(l,p){l>>>=0,p>>>=0;var h=Wt();K[l>>2>>>0]=h.length;var C=0;return h.forEach(function(T){C+=T.length+1}),K[p>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,p,h,C){p>>>=0,h>>>=0,C>>>=0;for(var T=0,U=0;U<h;U++){var G=K[p>>2>>>0],ue=K[p+4>>2>>>0];p+=8;for(var Y=0;Y<ue;Y++){var Q=le[G+Y>>>0],J=cr[l];Q===0||Q===10?((l===1?A:R)(kt(J,0)),J.length=0):J.push(Q)}T+=ue}return K[C>>2>>>0]=T,0},F:ne,d:function(l,p,h,C){return ne(l>>>0,p>>>0,h>>>0,C>>>0)}};(function(){function l(h){if(h=h.exports,h=pr(h),_=h=pt(h),D=_.M,we(),Se.unshift(_.N),Ce--,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),Ce==0&&(dt!==null&&(clearInterval(dt),dt=null),Ne)){var C=Ne;Ne=null,C()}return h}var p={a:vr};if(Ce++,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),r.instantiateWasm)try{return r.instantiateWasm(p,l)}catch(h){R("Module.instantiateWasm callback failed with error: "+h),n(h)}return ke(p,function(h){l(h.instance)}).catch(n),{}})(),r._OrtInit=(l,p)=>(r._OrtInit=_.O)(l,p),r._OrtGetLastError=(l,p)=>(r._OrtGetLastError=_.P)(l,p),r._OrtCreateSessionOptions=(l,p,h,C,T,U,G,ue,Y,Q)=>(r._OrtCreateSessionOptions=_.Q)(l,p,h,C,T,U,G,ue,Y,Q),r._OrtAppendExecutionProvider=(l,p)=>(r._OrtAppendExecutionProvider=_.R)(l,p),r._OrtAddFreeDimensionOverride=(l,p,h)=>(r._OrtAddFreeDimensionOverride=_.S)(l,p,h),r._OrtAddSessionConfigEntry=(l,p,h)=>(r._OrtAddSessionConfigEntry=_.T)(l,p,h),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=_.U)(l),r._OrtCreateSession=(l,p,h)=>(r._OrtCreateSession=_.V)(l,p,h),r._OrtReleaseSession=l=>(r._OrtReleaseSession=_.W)(l),r._OrtGetInputOutputCount=(l,p,h)=>(r._OrtGetInputOutputCount=_.X)(l,p,h),r._OrtGetInputName=(l,p)=>(r._OrtGetInputName=_.Y)(l,p),r._OrtGetOutputName=(l,p)=>(r._OrtGetOutputName=_.Z)(l,p),r._OrtFree=l=>(r._OrtFree=_._)(l),r._OrtCreateTensor=(l,p,h,C,T,U)=>(r._OrtCreateTensor=_.$)(l,p,h,C,T,U),r._OrtGetTensorData=(l,p,h,C,T)=>(r._OrtGetTensorData=_.aa)(l,p,h,C,T),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=_.ba)(l),r._OrtCreateRunOptions=(l,p,h,C)=>(r._OrtCreateRunOptions=_.ca)(l,p,h,C),r._OrtAddRunConfigEntry=(l,p,h)=>(r._OrtAddRunConfigEntry=_.da)(l,p,h),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=_.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=_.fa)(l),r._OrtBindInput=(l,p,h)=>(r._OrtBindInput=_.ga)(l,p,h),r._OrtBindOutput=(l,p,h,C)=>(r._OrtBindOutput=_.ha)(l,p,h,C),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=_.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=_.ja)(l),r._OrtRunWithBinding=(l,p,h,C,T)=>(r._OrtRunWithBinding=_.ka)(l,p,h,C,T),r._OrtRun=(l,p,h,C,T,U,G,ue)=>(r._OrtRun=_.la)(l,p,h,C,T,U,G,ue),r._OrtEndProfiling=l=>(r._OrtEndProfiling=_.ma)(l),r._JsepOutput=(l,p,h)=>(r._JsepOutput=_.na)(l,p,h),r._JsepGetNodeName=l=>(r._JsepGetNodeName=_.oa)(l);var Rt=r._malloc=l=>(Rt=r._malloc=_.pa)(l),Ut=r._free=l=>(Ut=r._free=_.qa)(l),Lt=l=>(Lt=_.sa)(l),Ft=()=>(Ft=_.ta)(),Ht=l=>(Ht=_.ua)(l),jt=l=>(jt=_.va)(l),Kt=l=>(Kt=_.xa)(l),qt=()=>(qt=_.ya)(),Pt=l=>(Pt=_.za)(l),$t=()=>($t=_.Aa)();r.___start_em_js=924587,r.___stop_em_js=924748;function pt(l){l=Object.assign({},l);var p=C=>()=>C()>>>0,h=C=>T=>C(T)>>>0;return l.__errno_location=p(l.__errno_location),l.malloc=h(l.malloc),l.stackSave=p(l.stackSave),l.stackAlloc=h(l.stackAlloc),l}r.stackAlloc=jt,r.stackSave=Ft,r.stackRestore=Ht,r.UTF8ToString=_e,r.stringToUTF8=(l,p,h)=>Dt(l,le,p,h),r.lengthBytesUTF8=It;var xt;Ne=function l(){xt||Yt(),xt||(Ne=l)};function Yt(){function l(){if(!xt&&(xt=!0,r.calledRun=!0,!z)){if(yt(Se),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var p=r.postRun.shift();Oe.unshift(p)}yt(Oe)}}if(!(0<Ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ie();yt(j),0<Ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Yt(),t.ready}})();typeof so=="object"&&typeof dn=="object"?dn.exports=io:typeof define=="function"&&define.amd&&define([],()=>io)});var lo=Jt(()=>{});var co=Jt(()=>{});var po={};Ir(po,{cpus:()=>Ou});var Ou,fo=H(()=>{Ou=void 0});var go=Jt((ho,cn)=>{"use strict";var mo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=Ce.buffer&&pe(),Ce}function o(){return we.buffer!=Ce.buffer&&pe(),dt}function n(){return we.buffer!=Ce.buffer&&pe(),Ne}function s(){return we.buffer!=Ce.buffer&&pe(),Le}function u(){return we.buffer!=Ce.buffer&&pe(),N}function d(){return we.buffer!=Ce.buffer&&pe(),de}var a=t,m,g;a.ready=new Promise((i,c)=>{m=i,g=c}),a.jsepInit=(i,c,f,$,I,P,V,oe)=>{a.Qb=i,a.wb=c,a.yb=f,a.jb=$,a.xb=I,a.Ea=P,a.zb=V,a.Ab=oe,c=(ee,Z,re)=>(...he)=>{let be=Ze,O=Z?.();he=ee(...he);let se=Z?.();return O!==se&&(ee=se,re(O),Z=re=null),Ze!=be?hu():he},f=ee=>async(...Z)=>{try{if(a.bb)throw Error("Session already started");let re=a.bb={Fb:Z[0],errors:[]},he=await ee(...Z);if(a.bb!==re)throw Error("Session mismatch");i.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(se=>se),0<O.length)throw Error(O.join(`\n`))}return he}finally{a.bb=null}},a._OrtRun=f(c(a._OrtRun,()=>a._OrtRun,ee=>a._OrtRun=ee)),a._OrtRunWithBinding=f(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,ee=>a._OrtRunWithBinding=ee)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,ee=>a._OrtBindInput=ee),a.jsepRegisterBuffer=(ee,Z,re,he)=>i.registerBuffer(ee,Z,re,he),a.jsepUnregisterBuffers=ee=>{i.unregisterBuffers(ee)},a.jsepGetBuffer=ee=>i.getBuffer(ee),a.jsepCreateDownloader=(ee,Z,re)=>i.createDownloader(ee,Z,re)};var x=Object.assign({},a),b="./this.program",w=(i,c)=>{throw c},v=typeof window=="object",y=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=a.ENVIRONMENT_IS_PTHREAD||!1,R="";function W(i){return a.locateFile?a.locateFile(i,R):R+i}var M,D,_;if(S){var z=(sn(),Mt(an)),F=(ln(),Mt(un));R=y?F.dirname(R)+"/":__dirname+"/",M=(c,f)=>(c=c.startsWith("file://")?new URL(c):F.normalize(c),z.readFileSync(c,f?void 0:"utf8")),_=c=>(c=M(c,!0),c.buffer||(c=new Uint8Array(c)),c),D=(c,f,$,I=!0)=>{c=c.startsWith("file://")?new URL(c):F.normalize(c),z.readFile(c,I?void 0:"utf8",(P,V)=>{P?$(P):f(I?V.buffer:V)})},!a.thisProgram&&1<process.argv.length&&(b=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),w=(c,f)=>{throw process.exitCode=c,f},a.inspect=()=>"[Emscripten Module object]";let i;try{i=lo()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else(v||y)&&(y?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.indexOf("blob:")!==0?R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1):R="",S||(M=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},y&&(_=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),D=(i,c,f)=>{var $=new XMLHttpRequest;$.open("GET",i,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?c($.response):f()},$.onerror=f,$.send(null)}));S&&typeof performance>"u"&&(global.performance=co().performance);var q=console.log.bind(console),le=console.error.bind(console);S&&(q=(...i)=>z.writeSync(1,i.join(" ")+`\n`),le=(...i)=>z.writeSync(2,i.join(" ")+`\n`));var B=a.print||q,K=a.printErr||le;Object.assign(a,x),x=null,a.thisProgram&&(b=a.thisProgram),a.quit&&(w=a.quit);var xe;a.wasmBinary&&(xe=a.wasmBinary);var ae=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Ke("no native wasm support detected");var we,j,Se,Oe=!1,Ie,Ce,dt,Ne,Le,N,de;function pe(){var i=we.buffer;a.HEAP8=Ce=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAP32=Ne=new Int32Array(i),a.HEAPU8=dt=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAPU32=Le=new Uint32Array(i),a.HEAPF32=N=new Float32Array(i),a.HEAPF64=de=new Float64Array(i)}var ze=a.INITIAL_MEMORY||16777216;if(5242880<=ze||Ke("INITIAL_MEMORY should be larger than STACK_SIZE, was "+ze+"! (STACK_SIZE=5242880)"),A)we=a.wasmMemory;else if(a.wasmMemory)we=a.wasmMemory;else if(we=new WebAssembly.Memory({initial:ze/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),ze=we.buffer.byteLength;var Ue=[],Te=[],ke=[],Ge=0;function Xe(){return ae||0<Ge}var Fe=0,yt=null,bt=null;function Bt(){Fe++,a.monitorRunDependencies&&a.monitorRunDependencies(Fe)}function lr(){if(Fe--,a.monitorRunDependencies&&a.monitorRunDependencies(Fe),Fe==0&&(yt!==null&&(clearInterval(yt),yt=null),bt)){var i=bt;bt=null,i()}}function Ke(i){throw a.onAbort&&a.onAbort(i),i="Aborted("+i+")",K(i),Oe=!0,Ie=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),g(i),i}function kt(i){return i.startsWith("data:application/octet-stream;base64,")}var _e;_e="ort-wasm-simd-threaded.wasm",kt(_e)||(_e=W(_e));function It(i){if(i==_e&&xe)return new Uint8Array(xe);if(_)return _(i);throw"both async and sync fetching of the wasm failed"}function Dt(i){if(!xe&&(v||y)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>It(i));if(D)return new Promise((c,f)=>{D(i,$=>c(new Uint8Array($)),f)})}return Promise.resolve().then(()=>It(i))}function at(i,c,f){return Dt(i).then($=>WebAssembly.instantiate($,c)).then($=>$).then(f,$=>{K("failed to asynchronously prepare wasm: "+$),Ke($)})}function dr(i,c){var f=_e;return xe||typeof WebAssembly.instantiateStreaming!="function"||kt(f)||f.startsWith("file://")||S||typeof fetch!="function"?at(f,i,c):fetch(f,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,i).then(c,function(I){return K("wasm streaming compile failed: "+I),K("falling back to ArrayBuffer instantiation"),at(f,i,c)}))}var it,Et={914988:i=>{a.Ea("Abs",i,void 0)},915039:i=>{a.Ea("Neg",i,void 0)},915090:i=>{a.Ea("Floor",i,void 0)},915143:i=>{a.Ea("Ceil",i,void 0)},915195:i=>{a.Ea("Reciprocal",i,void 0)},915253:i=>{a.Ea("Sqrt",i,void 0)},915305:i=>{a.Ea("Exp",i,void 0)},915356:i=>{a.Ea("Erf",i,void 0)},915407:i=>{a.Ea("Sigmoid",i,void 0)},915462:i=>{a.Ea("Log",i,void 0)},915513:i=>{a.Ea("Sin",i,void 0)},915564:i=>{a.Ea("Cos",i,void 0)},915615:i=>{a.Ea("Tan",i,void 0)},915666:i=>{a.Ea("Asin",i,void 0)},915718:i=>{a.Ea("Acos",i,void 0)},915770:i=>{a.Ea("Atan",i,void 0)},915822:i=>{a.Ea("Sinh",i,void 0)},915874:i=>{a.Ea("Cosh",i,void 0)},915926:i=>{a.Ea("Asinh",i,void 0)},915979:i=>{a.Ea("Acosh",i,void 0)},916032:i=>{a.Ea("Atanh",i,void 0)},916085:i=>{a.Ea("Tanh",i,void 0)},916137:i=>{a.Ea("Not",i,void 0)},916188:(i,c,f)=>{a.Ea("ClipV10",i,{min:c,max:f})},916260:i=>{a.Ea("Clip",i,void 0)},916312:(i,c)=>{a.Ea("Elu",i,{alpha:c})},916370:i=>{a.Ea("Relu",i,void 0)},916422:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},916486:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},916556:(i,c)=>{a.Ea("Cast",i,{to:c})},916614:i=>{a.Ea("Add",i,void 0)},916665:i=>{a.Ea("Sub",i,void 0)},916716:i=>{a.Ea("Mul",i,void 0)},916767:i=>{a.Ea("Div",i,void 0)},916818:i=>{a.Ea("Pow",i,void 0)},916869:i=>{a.Ea("Equal",i,void 0)},916922:i=>{a.Ea("Greater",i,void 0)},916977:i=>{a.Ea("GreaterOrEqual",i,void 0)},917039:i=>{a.Ea("Less",i,void 0)},917091:i=>{a.Ea("LessOrEqual",i,void 0)},917150:(i,c,f,$,I)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917314:(i,c,f,$,I)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917477:(i,c,f,$,I)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917640:(i,c,f,$,I)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917804:(i,c,f,$,I)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917967:(i,c,f,$,I)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918129:(i,c,f,$,I)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918291:(i,c,f,$,I)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918457:(i,c,f,$,I)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918626:(i,c,f,$,I)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918795:i=>{a.Ea("Where",i,void 0)},918848:(i,c,f)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[]})},918961:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se)=>{a.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[I],pads:[P,V],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ve(se)})},919375:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O)=>{a.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(P>>>0,P+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ve(O)})},919932:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se)=>{a.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[I],pads:[P,V],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ve(se)})},920346:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O)=>{a.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(P>>>0,P+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ve(O)})},920903:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},920994:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},921278:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},921369:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},921653:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},921740:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},922020:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},922107:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},922387:(i,c,f,$,I)=>{a.Ea("Gemm",i,{alpha:c,beta:f,transA:$,transB:I})},922491:i=>{a.Ea("MatMul",i,void 0)},922545:(i,c,f,$)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},922653:(i,c,f,$)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},922761:(i,c)=>{a.Ea("Softmax",i,{axis:c})},922824:(i,c)=>{a.Ea("Concat",i,{axis:c})},922884:(i,c,f,$,I)=>{a.Ea("Split",i,{axis:c,numOutputs:f,splitSizes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},923029:i=>{a.Ea("Expand",i,void 0)},923083:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},923154:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},923233:(i,c,f,$,I,P,V,oe,ee,Z,re)=>{a.Ea("Resize",i,{antialias:c,axes:f?Array.from(n().subarray($>>>0,$+f>>>0)):[],coordinateTransformMode:Ve(I),cubicCoeffA:P,excludeOutside:V,extrapolationValue:oe,keepAspectRatioPolicy:Ve(ee),mode:Ve(Z),nearestMode:Ve(re)})},923584:(i,c,f,$,I,P,V)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[],ends:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[],axes:P?Array.from(n().subarray(V>>>0,V+P>>>0)):[]})},923815:i=>{a.Ea("Tile",i,void 0)},923867:(i,c,f)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(f)})},923974:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},924088:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},924202:i=>{a.Ea("Range",i,void 0)},924255:(i,c)=>{a.Ea("Einsum",i,{equation:Ve(c)})},924336:(i,c,f,$,I)=>{a.Ea("Pad",i,{mode:c,value:f,pads:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},924468:i=>{a.Ea("Gelu",i,void 0)},924520:i=>{a.Ea("BiasAdd",i,void 0)},924575:i=>{a.Ea("BiasSplitGelu",i,void 0)},924636:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},924717:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be)=>{a.Ea("Conv",i,{format:ee?"NHWC":"NCHW",auto_pad:c,dilations:[f],group:$,kernel_shape:[I],pads:P?Array.from(n().subarray(V>>>0,V+P>>>0)):[],strides:[oe],w_is_const:()=>!!r()[Z>>>0],activation:Ve(re),activation_params:he?Array.from(u().subarray(be>>>0,be+he>>>0)):[]})},925098:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("Conv",i,{format:he?"NHWC":"NCHW",auto_pad:c,dilations:[f,$],group:I,kernel_shape:[P,V],pads:oe?Array.from(n().subarray(ee>>>0,ee+oe>>>0)):[],strides:[Z,re],w_is_const:()=>!!r()[be>>>0],activation:Ve(O),activation_params:se?Array.from(u().subarray(ye>>>0,ye+se>>>0)):[]})},925500:i=>{a.zb(i)},925534:(i,c)=>a.Ab(i,c,a.bb.Fb,a.bb.errors),925646:i=>a.wb(i),925679:i=>a.yb(i),925711:(i,c,f)=>{a.jb(i,c,f,!0)},925750:(i,c,f)=>{a.jb(i,c,f)}};function ct(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Tt(i){i.terminate(),i.onmessage=()=>{}}function Ot(i){(i=ne.Qa[i])||Ke(),ne.Eb(i)}function Wt(i){var c=ne.tb();if(!c)return 6;ne.Ya.push(c),ne.Qa[i.Xa]=c,c.Xa=i.Xa;var f={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return S&&c.unref(),c.postMessage(f,i.Mb),0}var _t=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,cr=(i,c,f)=>{c>>>=0;var $=c+f;for(f=c;i[f]&&!(f>=$);)++f;if(16<f-c&&i.buffer&&_t)return _t.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,f):i.subarray(c,f));for($="";c<f;){var I=i[c++];if(I&128){var P=i[c++]&63;if((I&224)==192)$+=String.fromCharCode((I&31)<<6|P);else{var V=i[c++]&63;I=(I&240)==224?(I&15)<<12|P<<6|V:(I&7)<<18|P<<12|V<<6|i[c++]&63,65536>I?$+=String.fromCharCode(I):(I-=65536,$+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else $+=String.fromCharCode(I)}return $},Ve=(i,c)=>(i>>>=0)?cr(o(),i,c):"";function zt(i){if(A)return G(1,1,i);Ie=i,Xe()||(ne.Hb(),a.onExit&&a.onExit(i),Oe=!0),w(i,new ct(i))}var Vt=i=>{if(Ie=i,A)throw pr(i),"unwind";zt(i)},ne={ab:[],Ya:[],mb:[],Qa:{},gb:function(){A?ne.vb():ne.ub()},ub:function(){Ue.unshift(()=>{Bt(),ne.Bb(()=>lr())})},vb:function(){ne.receiveObjectTransfer=ne.Db,ne.threadInitTLS=ne.lb,ne.setExitStatus=ne.kb,ae=!1},kb:function(i){Ie=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ne.Ya)Tt(i);for(i of ne.ab)Tt(i);ne.ab=[],ne.Ya=[],ne.Qa=[]},Eb:function(i){var c=i.Xa;delete ne.Qa[c],ne.ab.push(i),ne.Ya.splice(ne.Ya.indexOf(i),1),i.Xa=0,en(c)},Db:function(){},lb:function(){ne.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=P=>{P=P.data;var V=P.cmd;if(P.targetThread&&P.targetThread!=Sr()){var oe=ne.Qa[P.Rb];oe?oe.postMessage(P,P.transferList):K(\'Internal error! Worker sent a message "\'+V+\'" to target pthread \'+P.targetThread+", but that thread no longer exists!")}else V==="checkMailbox"?$t():V==="spawnThread"?Wt(P):V==="cleanupThread"?Ot(P.thread):V==="killThread"?(P=P.thread,V=ne.Qa[P],delete ne.Qa[P],Tt(V),en(P),ne.Ya.splice(ne.Ya.indexOf(V),1),V.Xa=0):V==="cancelThread"?ne.Qa[P.thread].postMessage({cmd:"cancel"}):V==="loaded"?(i.loaded=!0,c(i)):V==="alert"?alert("Thread "+P.threadId+": "+P.text):P.target==="setimmediate"?i.postMessage(P):V==="callHandler"?a[P.handler](...P.args):V&&K("worker sent an unknown command "+V)},i.onerror=P=>{throw K("worker sent an error! "+P.filename+":"+P.lineno+": "+P.message),P},S&&(i.on("message",function(P){i.onmessage({data:P})}),i.on("error",function(P){i.onerror(P)}));var f=[],$=["onExit","onAbort","print","printErr"],I;for(I of $)a.hasOwnProperty(I)&&f.push(I);i.postMessage({cmd:"load",handlers:f,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Se})}),Bb:function(i){i()},qb:function(){var i=W("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ne.ab.push(i)},tb:function(){return ne.ab.length==0&&(ne.qb(),ne.Cb(ne.ab[0])),ne.ab.pop()}};a.PThread=ne;var st=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=function(){var i=Sr(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],Zn(c,c-i),Cr(c)};function pr(i){if(A)return G(2,0,i);Vt(i)}a.invokeEntryPoint=function(i,c){i=Qn.apply(null,[i,c]),Xe()?ne.kb(i):tn(i)};function Je(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,f){this.nb(),this.pb(c),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var He=0,fr=0;function wt(i,c,f,$){return A?G(3,1,i,c,f,$):Gt(i,c,f,$)}function Gt(i,c,f,$){if(i>>>=0,c>>>=0,f>>>=0,$>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var I=[];return A&&I.length===0?wt(i,c,f,$):(i={Gb:f,Xa:i,rb:$,Mb:I},A?(i.Ob="spawnThread",postMessage(i,I),0):Wt(i))}function Nt(i,c,f){return A?G(4,1,i,c,f):0}function mr(i,c){if(A)return G(5,1,i,c)}var vt=i=>{for(var c=0,f=0;f<i.length;++f){var $=i.charCodeAt(f);127>=$?c++:2047>=$?c+=2:55296<=$&&57343>=$?(c+=4,++f):c+=3}return c},hr=(i,c,f,$)=>{if(f>>>=0,!(0<$))return 0;var I=f;$=f+$-1;for(var P=0;P<i.length;++P){var V=i.charCodeAt(P);if(55296<=V&&57343>=V){var oe=i.charCodeAt(++P);V=65536+((V&1023)<<10)|oe&1023}if(127>=V){if(f>=$)break;c[f++>>>0]=V}else{if(2047>=V){if(f+1>=$)break;c[f++>>>0]=192|V>>6}else{if(65535>=V){if(f+2>=$)break;c[f++>>>0]=224|V>>12}else{if(f+3>=$)break;c[f++>>>0]=240|V>>18,c[f++>>>0]=128|V>>12&63}c[f++>>>0]=128|V>>6&63}c[f++>>>0]=128|V&63}}return c[f>>>0]=0,f-I},gr=(i,c,f)=>hr(i,o(),c,f);function yr(i,c){if(A)return G(6,1,i,c)}function br(i,c,f){if(A)return G(7,1,i,c,f)}function wr(i,c,f){return A?G(8,1,i,c,f):0}function vr(i,c){if(A)return G(9,1,i,c)}function Rt(i,c,f){if(A)return G(10,1,i,c,f)}function Ut(i,c,f,$){if(A)return G(11,1,i,c,f,$)}function Lt(i,c,f,$){if(A)return G(12,1,i,c,f,$)}function Ft(i,c,f,$){if(A)return G(13,1,i,c,f,$)}function Ht(i){if(A)return G(14,1,i)}function jt(i,c){if(A)return G(15,1,i,c)}function Kt(i,c,f){if(A)return G(16,1,i,c,f)}var qt=i=>{if(!Oe)try{if(i(),!Xe())try{A?tn(Ie):Vt(Ie)}catch(c){c instanceof ct||c=="unwind"||w(1,c)}}catch(c){c instanceof ct||c=="unwind"||w(1,c)}};function Pt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then($t),i+=128,Atomics.store(n(),i>>2,1))}a.__emscripten_thread_mailbox_await=Pt;function $t(){var i=Sr();i&&(Pt(i),qt(()=>Xn()))}a.checkMailbox=$t;var pt=i=>i%4===0&&(i%100!==0||i%400===0),xt=[0,31,60,91,121,152,182,213,244,274,305,335],Yt=[0,31,59,90,120,151,181,212,243,273,304,334];function l(i,c,f,$,I,P,V,oe){return A?G(17,1,i,c,f,$,I,P,V,oe):-52}function p(i,c,f,$,I,P,V){if(A)return G(18,1,i,c,f,$,I,P,V)}var h=i=>{var c=vt(i)+1,f=Qr(c);return f&&gr(i,f,c),f},C=[],T=(i,c)=>{C.length=0;var f;for(c>>=2;f=o()[i++>>>0];)c+=f!=105&c,C.push(f==105?n()[c>>>0]:d()[c++>>>1]),++c;return C},U=i=>{var c=rn();return i=i(),Cr(c),i};function G(i,c){var f=arguments.length-2,$=arguments;return U(()=>{for(var I=nn(8*f),P=I>>3,V=0;V<f;V++){var oe=$[2+V];d()[P+V>>>0]=oe}return Yn(i,f,I,c)})}var ue=[],Y={},Q=()=>{if(!J){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"},c;for(c in Y)Y[c]===void 0?delete i[c]:i[c]=Y[c];var f=[];for(c in i)f.push(`${c}=${i[c]}`);J=f}return J},J;function ce(i,c){if(A)return G(19,1,i,c);i>>>=0,c>>>=0;var f=0;return Q().forEach(function($,I){var P=c+f;for(I=s()[i+4*I>>2>>>0]=P,P=0;P<$.length;++P)r()[I++>>0>>>0]=$.charCodeAt(P);r()[I>>0>>>0]=0,f+=$.length+1}),0}function me(i,c){if(A)return G(20,1,i,c);i>>>=0,c>>>=0;var f=Q();s()[i>>2>>>0]=f.length;var $=0;return f.forEach(function(I){$+=I.length+1}),s()[c>>2>>>0]=$,0}function E(i){return A?G(21,1,i):52}function te(i,c,f,$){return A?G(22,1,i,c,f,$):52}function fe(i,c,f,$,I){return A?G(23,1,i,c,f,$,I):70}var ut=[null,[],[]];function Xt(i,c,f,$){if(A)return G(24,1,i,c,f,$);c>>>=0,f>>>=0,$>>>=0;for(var I=0,P=0;P<f;P++){var V=s()[c>>2>>>0],oe=s()[c+4>>2>>>0];c+=8;for(var ee=0;ee<oe;ee++){var Z=o()[V+ee>>>0],re=ut[i];Z===0||Z===10?((i===1?B:K)(cr(re,0)),re.length=0):re.push(Z)}I+=oe}return s()[$>>2>>>0]=I,0}var Nn=[31,29,31,30,31,30,31,31,30,31,30,31],Un=[31,28,31,30,31,30,31,31,30,31,30,31];function du(i){var c=Array(vt(i)+1);return hr(i,c,0,c.length),c}var cu=(i,c)=>{r().set(i,c>>>0)};function Ln(i,c,f,$){function I(O,se,ye){for(O=typeof O=="number"?O.toString():O||"";O.length<se;)O=ye[0]+O;return O}function P(O,se){return I(O,se,"0")}function V(O,se){function ye(ao){return 0>ao?-1:0<ao?1:0}var St;return(St=ye(O.getFullYear()-se.getFullYear()))===0&&(St=ye(O.getMonth()-se.getMonth()))===0&&(St=ye(O.getDate()-se.getDate())),St}function oe(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ee(O){var se=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<se;){var ye=O.getMonth(),St=(pt(O.getFullYear())?Nn:Un)[ye];if(se>St-O.getDate())se-=St-O.getDate()+1,O.setDate(1),11>ye?O.setMonth(ye+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+se);break}}return ye=new Date(O.getFullYear()+1,0,4),se=oe(new Date(O.getFullYear(),0,4)),ye=oe(ye),0>=V(se,O)?0>=V(ye,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}i>>>=0,c>>>=0,f>>>=0,$>>>=0;var Z=n()[$+40>>2>>>0];$={Kb:n()[$>>2>>>0],Jb:n()[$+4>>2>>>0],cb:n()[$+8>>2>>>0],ib:n()[$+12>>2>>>0],eb:n()[$+16>>2>>>0],$a:n()[$+20>>2>>>0],Wa:n()[$+24>>2>>>0],Za:n()[$+28>>2>>>0],Tb:n()[$+32>>2>>>0],Ib:n()[$+36>>2>>>0],Lb:Z?Ve(Z):""},f=Ve(f),Z={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in Z)f=f.replace(new RegExp(re,"g"),Z[re]);var he="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");Z={"%a":O=>he[O.Wa].substring(0,3),"%A":O=>he[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>P((O.$a+1900)/100|0,2),"%d":O=>P(O.ib,2),"%e":O=>I(O.ib,2," "),"%g":O=>ee(O).toString().substring(2),"%G":O=>ee(O),"%H":O=>P(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),P(O,2)),"%j":O=>{for(var se=0,ye=0;ye<=O.eb-1;se+=(pt(O.$a+1900)?Nn:Un)[ye++]);return P(O.ib+se,3)},"%m":O=>P(O.eb+1,2),"%M":O=>P(O.Jb,2),"%n":()=>`\n`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>P(O.Kb,2),"%t":()=>"\t","%u":O=>O.Wa||7,"%U":O=>P(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var se=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&se++,se)se==53&&(ye=(O.Wa+371-O.Za)%7,ye==4||ye==3&&pt(O.$a)||(se=1));else{se=52;var ye=(O.Wa+7-O.Za-1)%7;(ye==4||ye==5&&pt(O.$a%400-1))&&se++}return P(se,2)},"%w":O=>O.Wa,"%W":O=>P(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var se=0<=O;return O=Math.abs(O)/60,(se?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(re in Z)f.includes(re)&&(f=f.replace(new RegExp(re,"g"),Z[re]($)));return f=f.replace(/\\0\\0/g,"%"),re=du(f),re.length>c?0:(cu(re,i),re.length-1)}function $r(i){try{i()}catch(c){Ke(c)}}function pu(i){var c={},f;for(f in i)(function($){var I=i[$];c[$]=typeof I=="function"?function(){xr.push($);try{return I.apply(null,arguments)}finally{Oe||(xr.pop()===$||Ke(),Ze&&ft===1&&xr.length===0&&(ft=0,Ge+=1,$r(to),typeof Fibers<"u"&&Fibers.Ub()))}}:I})(f);return c}var ft=0,Ze=null,Fn=0,xr=[],Hn={},jn={},fu=0,Zr=null,mu=[];function hu(){return new Promise((i,c)=>{Zr={resolve:i,reject:c}})}function gu(){var i=Qr(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=xr[0];var f=Hn[c];return f===void 0&&(f=fu++,Hn[c]=f,jn[f]=c),c=f,n()[i+8>>2>>>0]=c,i}function yu(){var i=n()[Ze+8>>2>>>0];return i=j[jn[i]],--Ge,i()}function bu(i){if(!Oe){if(ft===0){var c=!1,f=!1;i(($=0)=>{if(!Oe&&(Fn=$,c=!0,f)){ft=2,$r(()=>ro(Ze)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),$=!1;try{var I=yu()}catch(oe){I=oe,$=!0}var P=!1;if(!Ze){var V=Zr;V&&(Zr=null,($?V.reject:V.resolve)(I),P=!0)}if($&&!P)throw I}}),f=!0,c||(ft=1,Ze=gu(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),$r(()=>eo(Ze)))}else ft===2?(ft=0,$r(no),Kn(Ze),Ze=null,mu.forEach($=>qt($))):Ke(`invalid state: ${ft}`);return Fn}}function wu(i){return bu(c=>{i().then(c)})}ne.gb();var vu=[null,zt,pr,wt,Nt,mr,yr,br,wr,vr,Rt,Ut,Lt,Ft,Ht,jt,Kt,l,p,ce,me,E,te,fe,Xt],$u={r:function(i,c,f){return wu(async()=>{await a.xb(i,c,f)})},b:function(i,c,f){throw i>>>=0,new Je(i).gb(c>>>0,f>>>0),He=i,fr++,He},O:function(i){qn(i>>>0,!y,1,!v,131072,!1),ne.lb()},l:function(i){i>>>=0,A?postMessage({cmd:"cleanupThread",thread:i}):Ot(i)},I:Gt,i:Nt,U:mr,E:yr,G:br,V:wr,S:vr,K:Rt,R:Ut,p:Lt,F:Ft,C:Ht,T:jt,D:Kt,q:()=>!0,A:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>$t()):A?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ne.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Pt,X:function(i){S&&ne.Qa[i>>>0].ref()},u:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getUTCSeconds(),n()[f+4>>2>>>0]=i.getUTCMinutes(),n()[f+8>>2>>>0]=i.getUTCHours(),n()[f+12>>2>>>0]=i.getUTCDate(),n()[f+16>>2>>>0]=i.getUTCMonth(),n()[f+20>>2>>>0]=i.getUTCFullYear()-1900,n()[f+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>2>>>0]=i},v:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getSeconds(),n()[f+4>>2>>>0]=i.getMinutes(),n()[f+8>>2>>>0]=i.getHours(),n()[f+12>>2>>>0]=i.getDate(),n()[f+16>>2>>>0]=i.getMonth(),n()[f+20>>2>>>0]=i.getFullYear()-1900,n()[f+24>>2>>>0]=i.getDay(),c=(pt(i.getFullYear())?xt:Yt)[i.getMonth()]+i.getDate()-1|0,n()[f+28>>2>>>0]=c,n()[f+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var $=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=$&&i.getTimezoneOffset()==Math.min($,c))|0,n()[f+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),f=n()[i+32>>2>>>0],$=c.getTimezoneOffset(),I=new Date(c.getFullYear(),6,1).getTimezoneOffset(),P=new Date(c.getFullYear(),0,1).getTimezoneOffset(),V=Math.min(P,I);return 0>f?n()[i+32>>2>>>0]=+(I!=P&&V==$):0<f!=(V==$)&&(I=Math.max(P,I),c.setTime(c.getTime()+6e4*((0<f?V:I)-$))),n()[i+24>>2>>>0]=c.getDay(),f=(pt(c.getFullYear())?xt:Yt)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=f,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,Jn((it=i,1<=+Math.abs(it)?0<it?+Math.floor(it/4294967296)>>>0:~~+Math.ceil((it-+(~~it>>>0))/4294967296)>>>0:0)),i>>>0},s:l,t:p,z:function(i,c,f){function $(Z){return(Z=Z.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Z[1]:"GMT"}i>>>=0,c>>>=0,f>>>=0;var I=new Date().getFullYear(),P=new Date(I,0,1),V=new Date(I,6,1);I=P.getTimezoneOffset();var oe=V.getTimezoneOffset(),ee=Math.max(I,oe);s()[i>>2>>>0]=60*ee,n()[c>>2>>>0]=+(I!=oe),i=$(P),c=$(V),i=h(i),c=h(c),oe<I?(s()[f>>2>>>0]=i,s()[f+4>>2>>>0]=c):(s()[f>>2>>>0]=c,s()[f+4>>2>>>0]=i)},d:()=>{Ke("")},c:function(i,c,f){return i>>>=0,c=T(c>>>0,f>>>0),Et[i].apply(null,c)},k:function(i,c,f){return i>>>=0,c=T(c>>>0,f>>>0),Et[i].apply(null,c)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ge+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return S?(fo(),Mt(po)).cpus().length:navigator.hardwareConcurrency},L:function(i,c,f,$){for(ne.Pb=c>>>0,ue.length=f,c=$>>>0>>3,$=0;$<f;$++)ue[$]=d()[c+$>>>0];return(0>i?Et[-i-1]:vu[i]).apply(null,ue)},y:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var f=1;4>=f;f*=2){var $=c*(1+.2/f);$=Math.min($,i+100663296);var I=Math;$=Math.max(i,$);e:{I=I.min.call(I,4294901760,$+(65536-$%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(I),pe();var P=1;break e}catch{}P=void 0}if(P)return!0}return!1},P:ce,Q:me,H:Vt,h:E,o:te,x:fe,n:Xt,a:we||a.wasmMemory,J:Ln,e:function(i,c,f,$){return Ln(i>>>0,c>>>0,f>>>0,$>>>0)}};(function(){function i(f,$){return f=f.exports,f=pu(f),j=f=xu(f),ne.mb.push(j.Da),Te.unshift(j.Y),Se=$,lr(),f}var c={a:$u};if(Bt(),a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(f){K("Module.instantiateWasm callback failed with error: "+f),g(f)}return dr(c,function(f){i(f.instance,f.module)}).catch(g),{}})(),a._OrtInit=(i,c)=>(a._OrtInit=j.Z)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=j._)(i,c),a._OrtCreateSessionOptions=(i,c,f,$,I,P,V,oe,ee,Z)=>(a._OrtCreateSessionOptions=j.$)(i,c,f,$,I,P,V,oe,ee,Z),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=j.aa)(i,c),a._OrtAddFreeDimensionOverride=(i,c,f)=>(a._OrtAddFreeDimensionOverride=j.ba)(i,c,f),a._OrtAddSessionConfigEntry=(i,c,f)=>(a._OrtAddSessionConfigEntry=j.ca)(i,c,f),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=j.da)(i),a._OrtCreateSession=(i,c,f)=>(a._OrtCreateSession=j.ea)(i,c,f),a._OrtReleaseSession=i=>(a._OrtReleaseSession=j.fa)(i),a._OrtGetInputOutputCount=(i,c,f)=>(a._OrtGetInputOutputCount=j.ga)(i,c,f),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=j.ha)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=j.ia)(i,c),a._OrtFree=i=>(a._OrtFree=j.ja)(i),a._OrtCreateTensor=(i,c,f,$,I,P)=>(a._OrtCreateTensor=j.ka)(i,c,f,$,I,P),a._OrtGetTensorData=(i,c,f,$,I)=>(a._OrtGetTensorData=j.la)(i,c,f,$,I),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=j.ma)(i),a._OrtCreateRunOptions=(i,c,f,$)=>(a._OrtCreateRunOptions=j.na)(i,c,f,$),a._OrtAddRunConfigEntry=(i,c,f)=>(a._OrtAddRunConfigEntry=j.oa)(i,c,f),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=j.pa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=j.qa)(i),a._OrtBindInput=(i,c,f)=>(a._OrtBindInput=j.ra)(i,c,f),a._OrtBindOutput=(i,c,f,$)=>(a._OrtBindOutput=j.sa)(i,c,f,$),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=j.ta)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=j.ua)(i),a._OrtRunWithBinding=(i,c,f,$,I)=>(a._OrtRunWithBinding=j.va)(i,c,f,$,I),a._OrtRun=(i,c,f,$,I,P,V,oe)=>(a._OrtRun=j.wa)(i,c,f,$,I,P,V,oe),a._OrtEndProfiling=i=>(a._OrtEndProfiling=j.xa)(i),a._JsepOutput=(i,c,f)=>(a._JsepOutput=j.ya)(i,c,f),a._JsepGetNodeName=i=>(a._JsepGetNodeName=j.za)(i);var Sr=a._pthread_self=()=>(Sr=a._pthread_self=j.Aa)(),Qr=a._malloc=i=>(Qr=a._malloc=j.Ba)(i),Kn=a._free=i=>(Kn=a._free=j.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=j.Da)();var qn=a.__emscripten_thread_init=(i,c,f,$,I,P)=>(qn=a.__emscripten_thread_init=j.Fa)(i,c,f,$,I,P);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=j.Ga)();var Yn=(i,c,f,$)=>(Yn=j.Ha)(i,c,f,$),en=i=>(en=j.Ia)(i),tn=a.__emscripten_thread_exit=i=>(tn=a.__emscripten_thread_exit=j.Ja)(i),Xn=a.__emscripten_check_mailbox=()=>(Xn=a.__emscripten_check_mailbox=j.Ka)(),Jn=i=>(Jn=j.La)(i),Zn=(i,c)=>(Zn=j.Ma)(i,c),rn=()=>(rn=j.Na)(),Cr=i=>(Cr=j.Oa)(i),nn=i=>(nn=j.Pa)(i),Qn=a.dynCall_ii=(i,c)=>(Qn=a.dynCall_ii=j.Ra)(i,c),eo=i=>(eo=j.Sa)(i),to=()=>(to=j.Ta)(),ro=i=>(ro=j.Ua)(i),no=()=>(no=j.Va)();a.___start_em_js=925783,a.___stop_em_js=925944;function xu(i){i=Object.assign({},i);var c=$=>()=>$()>>>0,f=$=>I=>$(I)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=f(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=f(i.stackAlloc),i}a.keepRuntimeAlive=Xe,a.wasmMemory=we,a.stackAlloc=nn,a.stackSave=rn,a.stackRestore=Cr,a.UTF8ToString=Ve,a.stringToUTF8=gr,a.lengthBytesUTF8=vt,a.ExitStatus=ct,a.PThread=ne;var Ar;bt=function i(){Ar||oo(),Ar||(bt=i)};function oo(){function i(){if(!Ar&&(Ar=!0,a.calledRun=!0,!Oe)&&(A||st(Te),m(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!A)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();ke.unshift(c)}st(ke)}}if(!(0<Fe))if(A)m(a),A||st(Te),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Ue.unshift(a.preRun.shift());st(Ue),0<Fe||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),i()},1)):i())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return oo(),t.ready}})();typeof ho=="object"&&typeof cn=="object"?cn.exports=mo:typeof define=="function"&&define.amd&&define([],()=>mo)});var yo=Jt((mc,_u)=>{_u.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var mn,Qt,er,Tr,tr,So,hn,De=H(()=>{"use strict";mn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Qt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},er=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Tr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},tr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},So=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",hn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Vu,Gu,Co,Ao,Io,Nu,Ee,mt=H(()=>{"use strict";De();Vu=["V","I","W","E","F"],Gu=(e,t)=>{console.log(`[${Vu[e]},${new Date().toISOString()}]${t}`)},Io=(e,t)=>{Co=e,Ao=t},Nu=(e,t)=>{let r=tr(e),o=tr(Co);r>=o&&Gu(r,typeof t=="function"?t():t)},Ee=(...e)=>{Ao&&Nu(...e)}});var Eo,To=H(()=>{"use strict";De();Eo=(e,t)=>new(Tr(t))(e)});var Oo=H(()=>{"use strict"});var Or,Uu,_o,yn,gn,Ro,Po=H(()=>{"use strict";mt();Oo();Or=e=>Math.ceil(e/16)*16,Uu=1,_o=()=>Uu++,yn=async(e,t,r,o)=>{let n=Or(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let d=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(d,0,r)),a}else return new Uint8Array(d.slice(0,r))}finally{s.destroy()}},gn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Or(s),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=a.getMappedRange();new Uint8Array(m).set(new Uint8Array(o,n,s)),a.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(a,0,d.gpuData.buffer,0,u),Ee("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Or(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=_o();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ee("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Or(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,m=a.get(o);m||(m=[],a.set(o,m)),m.length>0?n=m.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let d={id:_o(),type:0,buffer:n};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Ee("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ee("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await yn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Ro=(...e)=>new gn(...e)});var bn,ie,Pe=H(()=>{"use strict";bn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ie=e=>new bn(e)});var wn,Qe,k,Ct,_r,Rr,Pr,ge=H(()=>{"use strict";wn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},Qe=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),d=new Array(u);if(o){if(n<2||s<2)return;let a=wn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[d[u-2],d[u-1]]=a}for(let a=o?3:1;a<=u;a++){let m=n-a<0?1:t[n-a],g=s-a<0?1:r[s-a];if(m!==g&&m>1&&g>1)return;d[u-a]=Math.max(m,g)}return d}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},k=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},Ct=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<n.length){if(n[d]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let d=0;d<o.length;d++)if(d<s.length){if(s[d]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let d=0;d<o.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=o[d]||u[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,d){if(d){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,d)}}static computePoolOutputShape(t,r,o,n,s,u,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,d),a}static computeConvOutputShape(t,r,o,n,s,u,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,d),a}static computeShapeHelper(t,r,o,n,s,u,d,a){if(t)for(let m=0;m<r.length-2;m++)o.push(1);else for(let m=0;m<r.length-2;m++)o.push(e.adjustPadAndReturnShape(r[m+2],n[m],s[m],u[m],d,m,m+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,d,a){let m=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[d]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let x=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(x+1)/2:x/2),s[d]=x-s[u],Math.floor((t+x-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[d]-m)/r+1)}},_r=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,d,a;r?(u=t[1],d=t[0]):(u=t[0],d=t[1]);let m=-1;if(n?(a=o[0],m=1):(a=o[1],m=0),o[m]!==d)throw new Error("dimension mismatch");if(u<=0||a<=0||d<=0)throw new Error("invalid shape specified");if(s&&!Qe.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,d]}},Rr=-34028234663852886e22,Pr=34028234663852886e22});var Lu,Mo,Me,$n,lt,qe,At,ht,Bo,L,X,vn,ko,xn,Do,ve=H(()=>{"use strict";De();ge();Lu=64,Mo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Me=(e,t=1)=>{let r=Mo(e,t);return typeof r=="string"?r:r[0]},$n=e=>[{type:"uint32",data:e},{type:"uint32",data:k.computeStrides(e)}],lt=e=>e%4===0?4:e%2===0?2:1,qe=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,At=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,ht=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Bo=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,d=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,m=Mo(t,n),g=typeof m=="string"?m:m[1],x=typeof m=="string"?m:m[0],b={indices:a,value:g,storage:x,tensor:t},w=N=>typeof N=="string"?N:`${N}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=s?"uniforms.":"",S=`${y}${e}_shape`,A=`${y}${e}_strides`,R="";for(let N=0;N<u-1;N++)R+=`\n    let dim${N} = current / ${A}[${N}];\n    let rest${N} = current % ${A}[${N}];\n    indices[${N}] = dim${N};\n    current = rest${N};\n    `;R+=`indices[${u-1}] = current;`;let W=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${R}\n    return indices;\n  }`,M=N=>(v.offsetToIndices=!0,u<2?N:`o2i_${e}(${N})`),D=[];if(u>=2)for(let N=u-1;N>=0;N--)D.push(`${A}[${N}] * (indices[${N}])`);let _=u<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${D.join("+")};\n  }`,z=N=>(v.indicesToOffset=!0,u<2?N:`i2o_${e}(${N})`),F=(...N)=>u===0?"0u":`${b.indices}(${N.map(w).join(",")})`,q=(N,de)=>u<2?`${N}`:`${N}[${de}]`,le=(N,de,pe)=>u<2?`${N}=${pe};`:`${N}[${de}]=${pe};`,B={},K=(N,de)=>{v.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in B)return`${pe}(${N})`;let ze=[];for(let Ue=u-1;Ue>=0;Ue--){let Te=de.indicesGet("outputIndices",Ue+de.rank-u);ze.push(`${q(A,Ue)} * (${Te} % ${q(S,Ue)})`)}return B[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {\n             return ${ze.length>0?ze.join("+"):"0u"};\n           }`,`${pe}(${N})`},xe=(N,de)=>(()=>{if(b.storage===b.value)return`${e}[${N}]=${de};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${N}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${N}]=vec2<u32>(u32(${de}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${N}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ae=N=>(()=>{if(b.storage===b.value)return`${e}[${N}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${N}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${N}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${N}] & 0xFFu), bool(${e}[${N}] & 0xFF00u), bool(${e}[${N}] & 0xFF0000u), bool(${e}[${N}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),we=u<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${g} {\n    return ${ae(`i2o_${e}(indices)`)};\n  }`,j=u<2?"":(()=>{let N=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn get_${e}(${N}) -> ${g} {\n    return get_${e}ByIndices(${F(de)});\n  }`})(),Se=(...N)=>{if(N.length!==u)throw new Error(`indices length must be ${u}`);let de=N.map(w).join(",");return u===0?ae("0u"):u===1?ae(de[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${de})`)},Oe=N=>u<2?ae(N):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${N})`),Ie=u<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${g}) {\n    ${xe(`i2o_${e}(indices)`,"value")}\n  }`,Ce=u<2?"":(()=>{let N=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn set_${e}(${N}, value: ${g}) {\n    set_${e}ByIndices(${F(de)}, value);\n  }`})();return{impl:()=>{let N=[];return s||(N.push(`const ${S} = ${b.indices}(${r.join(",")});`),N.push(`const ${A} = ${b.indices}(${k.computeStrides(r).join(",")});`)),v.offsetToIndices&&N.push(W),v.indicesToOffset&&N.push(_),v.broadcastedIndicesToOffset&&Object.values(B).forEach(de=>N.push(de)),v.set&&N.push(Ce),v.setByIndices&&N.push(Ie),v.get&&N.push(j),v.getByIndices&&N.push(we),N.join(`\n`)},type:b,offsetToIndices:M,indicesToOffset:z,broadcastedIndicesToOffset:K,indices:F,indicesGet:q,indicesSet:le,set:(...N)=>{if(N.length!==u+1)throw new Error(`indices length must be ${u}`);let de=N[u];if(typeof de!="string")throw new Error("value must be string");let pe=N.slice(0,u).map(w).join(",");return u===0?xe("0u",de):u===1?xe(pe[0],de):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:xe,setByIndices:(N,de)=>u<2?xe(N,de):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${N}, ${de});`),get:Se,getByOffset:ae,getByIndices:Oe,usage:o?"input":"output",name:e,strides:A,shape:S,rank:u}},L=(e,t,r,o=1)=>Bo(e,t,r,!0,o),X=(e,t,r,o=1)=>Bo(e,t,r,!1,o),vn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Lu){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,d=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*o*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${d}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},ko=e=>new vn(e),xn=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},Do=e=>e<=4});var Fu,Wo,Hu,ju,gt,zo,Vo,rr=H(()=>{"use strict";ge();Pe();ve();Fu=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Wo=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Hu=(e,t)=>k.sortBasedOnPerm(e,Wo(e.length,t)),ju=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},gt=(e,t)=>{let r=e.dataType,o=e.dims.length,n=Wo(o,t),s=Do(o),u=Hu(e.dims,n),d=s?u.length:u,a=s?o:e.dims,m=X("output",r,d),g=L("a",r,a),x=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(g,m)}\n\n  ${ju(n,o,g,m)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",g.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:b=>{let w=k.size(u);return{outputs:[{dims:u,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:s?[{type:"uint32",data:w},...$n(b[0].dims),...$n(u)]:[{type:"uint32",data:w}]}},getShaderSource:x}},zo=(e,t)=>{Fu(e.inputs),e.compute(gt(e.inputs[0],t.perm))},Vo=e=>ie({perm:e.perm})});var Ku,qu,Yu,Xu,Ju,Zu,Qu,el,tl,rl,et,Go,No,Uo,Lo,Fo,Ho,jo,Ko,qo,Yo,Xo=H(()=>{"use strict";ge();ve();Mr();rr();Ku={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},qu={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Yu={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Xu={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Ju=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Zu=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},Qu=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},el=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},tl=(e,t)=>{let r=[];if(!el(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},rl=(e,t,r,o,n,s,u)=>{let d=r[0].dims,a=k.size(s),m=k.size(u),g=L("_A",r[0].dataType,d),x=X("output",n,s),b=32,w=`\n          var<workgroup> aBestValues : array<${x.type.storage}, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:y=>`\n        ${y.registerUniform("reduceSize","u32").declareVariables(g,x)}\n        ${w}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${y.mainStart(b)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${x.type.storage}(${Yu[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = ${x.type.storage}(${g.getByOffset("offset + k")});\n           bestValue = ${Ku[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${qu[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${x.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${x.type.storage}(uniforms.reduceSize)`:`${Xu[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:m}]})}},et=(e,t,r,o)=>{let n=e.inputs.length===1?r:Sn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((w,v)=>v));let u=k.normalizeAxes(s,e.inputs[0].dims.length),d=u,a=e.inputs[0],m=tl(d,e.inputs[0].dims.length);m.length>0&&(a=e.compute(gt(e.inputs[0],m),{inputs:[0],outputs:[-1]})[0],d=Ju(d.length,a.dims.length));let[g,x]=Zu(a.dims,d),b=g;n.keepDims&&(b=Qu(g,u)),e.compute(rl(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,b,x),{inputs:[a]})},Go=(e,t)=>{et(e,"ReduceMeanShared",t,"mean")},No=(e,t)=>{et(e,"ReduceL1Shared",t,"l1")},Uo=(e,t)=>{et(e,"ReduceL2Shared",t,"l2")},Lo=(e,t)=>{et(e,"ReduceLogSumExpShared",t,"logSumExp")},Fo=(e,t)=>{et(e,"ReduceMaxShared",t,"max")},Ho=(e,t)=>{et(e,"ReduceMinShared",t,"min")},jo=(e,t)=>{et(e,"ReduceProdShared",t,"prod")},Ko=(e,t)=>{et(e,"ReduceSumShared",t,"sum")},qo=(e,t)=>{et(e,"ReduceSumSquareShared",t,"sumSquare")},Yo=(e,t)=>{et(e,"ReduceLogSumShared",t,"logSum")}});var tt,nl,Br,Sn,rt,ol,al,il,sl,ul,ll,dl,cl,pl,fl,nt,Jo,Zo,Qo,ea,ta,ra,na,oa,aa,ia,Ye,Mr=H(()=>{"use strict";ge();Pe();ve();Xo();tt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},nl=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Br=(e,t,r,o,n,s,u=!1,d=!1)=>{let a=[],m=r[0].dims,g=k.normalizeAxes(n,r[0].dims.length),x=!d&&g.length===0;m.forEach((z,F)=>{x||g.indexOf(F)>=0?u&&a.push(1):a.push(z)});let b=[],w=L("_A",r[0].dataType,m),v=X("output",s,a),y=o(w,v,g),S=`inputOffset = ${w.indicesToOffset("inputIndices")};`,A=`let ${S};`,R=`var ${S};`,W=y[1]===""?"":R,M=(y[1]===""?A:S)+`\n`+y[2];for(let z=0,F=0;z<r[0].dims.length;z++)x||g.indexOf(z)>=0?(u&&F++,M=`for(var j${z}: u32 = 0; j${z} < ${r[0].dims[z]}; j${z}++) {\n                ${y[2].includes("lastIndex")?`let lastIndex = j${z};`:""}\n                ${w.indicesSet("inputIndices",z,`j${z}`)}\n                ${M}\n              }`):(b.push(`${w.indicesSet("inputIndices",z,v.indicesGet("outputIndices",F))};`),F++);let D=k.size(a);return{name:e,shaderCache:t,getShaderSource:z=>`\n        ${z.declareVariables(w,v)}\n\n        ${z.mainStart()}\n          ${z.guardAgainstOutOfBoundsWorkgroupSizes(D)}\n          var inputIndices: ${w.type.indices};\n          let outputIndices = ${v.offsetToIndices("global_idx")};\n\n          ${b.join(`\n`)}\n          ${y[0]}       // init ops for reduce max/min\n          ${W}\n          ${y[1]}\n          ${M}\n          ${y[3]}\n          ${y.length===4?v.setByOffset("global_idx","value"):y.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(D/64)}})}},Sn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ie({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rt=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:Sn(n,r);e.compute(Br(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?nl:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},ol=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},al=(e,t)=>{tt(e.inputs),rt(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},il=(e,t)=>{tt(e.inputs),rt(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},sl=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},ul=(e,t)=>{tt(e.inputs),rt(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(o.indicesSet("inputIndices",d,0));return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},ll=(e,t)=>{tt(e.inputs),rt(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&(u*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},dl=(e,t)=>{tt(e.inputs),rt(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`inputIndices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},cl=(e,t)=>{tt(e.inputs),rt(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},pl=(e,t)=>{tt(e.inputs),rt(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},fl=(e,t)=>{tt(e.inputs),rt(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},nt=(e,t,r)=>{if(t.length===0)return!!r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},Jo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ll(e,t):Go(e,t)},Zo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?al(e,t):No(e,t)},Qo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?il(e,t):Uo(e,t)},ea=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?sl(e,t):Lo(e,t)},ta=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ul(e,t):Fo(e,t)},ra=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dl(e,t):Ho(e,t)},na=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cl(e,t):jo(e,t)},oa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pl(e,t):Ko(e,t)},aa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fl(e,t):qo(e,t)},ia=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ol(e,t):Yo(e,t)},Ye=e=>ie(e)});var sa,ua,la,da,Cn,ca=H(()=>{"use strict";De();Pe();Mr();sa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},ua=(e,t)=>ie({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),la=(e,t)=>{sa(e.inputs);let r=(n,s,u)=>{let d=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&d.push(`inputIndices[${a}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ua(e.inputs,t);e.compute(Br("ArgMin",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},da=(e,t)=>{sa(e.inputs);let r=(n,s,u)=>{let d=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&d.push(`inputIndices[${a}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ua(e.inputs,t);e.compute(Br("argMax",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Cn=e=>ie(e)});var ml,hl,pa,fa=H(()=>{"use strict";ge();ve();ml=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hl=e=>{let t=e[0].dims,r=e[0].dims[2],o=k.size(t)/4,n=e[0].dataType,s=L("input",n,t,4),u=L("bias",n,[r],4),d=L("residual",n,t,4),a=X("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:g=>`\n  const channels = ${r}u / 4;\n  ${g.declareVariables(s,u,d,a)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},pa=e=>{ml(e.inputs),e.compute(hl(e.inputs))}});var gl,$e,ma,ha,ga,ya,ba,wa,va,$a,xa,An,yl,Sa,Ca,Aa,Ia,kr,Ea,Dr,Ta,Oa,_a,Ra,Pa,Ma,Ba,ka,Da,Wa,za,Va,Ga,Na,Ua,La,Fa,In=H(()=>{"use strict";De();ge();Pe();ve();gl=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),d="";typeof n=="string"?d=`${n}(a)`:d=n("a");let a=L("inputData",r,[u],4),m=X("outputData",o,[u],4);return`\n  ${e.declareVariables(a,m)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx",d)}\n  }`},$e=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n},getShaderSource:u=>gl(u,k.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(k.size(u[0].dims)/64/4)}})}),ma=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},ha=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},ga=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},ya=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},ba=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},wa=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},va=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},$a=e=>ie(e),xa=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},An=(e,t)=>{let r=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},yl=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Rr,r=e.length>=3?e[2].getFloat32Array()[0]:Pr;return ie({min:t,max:r})},Sa=e=>{let t=yl(e.inputs);An(e,t)},Ca=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},Aa=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},Ia=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},kr=e=>ie(e),Ea=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Dr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Ta=e=>{let t=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Dr(`vec4<${t}>`,t)))},Oa=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},_a=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},Ra=e=>{let t=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Dr(`vec4<${t}>`,t)))},Pa=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},Ma=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},Ba=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},ka=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Da=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},Wa=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},za=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},Va=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},Ga=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},Na=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},Ua=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},La=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),Fa=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var wl,vl,Ha,ja=H(()=>{"use strict";ge();ve();In();wl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},vl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=L("input",e[0].dataType,e[0].dims,4),o=L("bias",e[0].dataType,[e[0].dims[2]],4),n=X("output",e[0].dataType,t,4),s=k.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:d=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${d.declareVariables(r,o,n)}\n\n  ${Dr("vec4f")}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ha=e=>{wl(e.inputs),e.compute(vl(e.inputs))}});var $l,xl,ot,Ka,qa,Ya,Xa,Ja,Za,Qa,ei,ti,ri,ni=H(()=>{"use strict";De();ge();ve();$l=(e,t,r,o,n,s,u,d,a,m,g)=>{let x=k.size(o),b=Math.ceil(x/4),w,v;typeof u=="string"?w=v=(M,D)=>`${u}((${M}),(${D}))`:typeof u=="function"?w=v=u:(w=u.scalar,v=u.vector);let y="",S=X("outputData",m,o,4),A=L("aData",d,t,4),R=L("bData",a,r,4);if(s){let M=D=>{let _=k.computeStrides(D),z=[];for(let F=D.length-1;F>=0;F--){let q=S.indicesGet("outputIndices",F+o.length-D.length);z.push(`${_[F]}u * (${q} % ${D[F]}u)`)}return z.length>0?z.join("+"):"0u"};y=`\n          fn calcOffsetA(outputIndices: ${S.type.indices}) -> u32 {\n            return ${M(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${S.type.indices}) -> u32 {\n            return ${M(r)};\n          }\n        `}let W;if(n)if(s){let M=k.size(t)===1,D=k.size(r)===1;M||D?W=S.setByOffset("global_idx",v(M?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"),D?`${R.type.value}(${R.getByOffset("0")}.x)`:R.getByOffset("global_idx"))):W=`\n            let outputIndices = ${S.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${S.setByOffset("global_idx",v(A.getByOffset("offsetA / 4u"),R.getByOffset("offsetB / 4u")))}\n          `}else W=S.setByOffset("global_idx",v(A.getByOffset("global_idx"),R.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let M=(D,_,z="")=>{let F=`aData[indexA${_}][componentA${_}]`,q=`bData[indexB${_}][componentB${_}]`;return`\n            let outputIndices${_} = ${S.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offsetA${_} = calcOffsetA(outputIndices${_});\n            let offsetB${_} = calcOffsetB(outputIndices${_});\n            let indexA${_} = offsetA${_} / 4u;\n            let indexB${_} = offsetB${_} / 4u;\n            let componentA${_} = offsetA${_} % 4u;\n            let componentB${_} = offsetB${_} % 4u;\n            ${D}[${_}] = ${z}(${w(F,q)});\n          `};m===9?W=`\n            var data = vec4<u32>(0);\n            ${M("data",0,"u32")}\n            ${M("data",1,"u32")}\n            ${M("data",2,"u32")}\n            ${M("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:W=`\n            ${M("outputData[global_idx]",0)}\n            ${M("outputData[global_idx]",1)}\n            ${M("outputData[global_idx]",2)}\n            ${M("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(A,R,S)}\n\n        ${g??""}\n        ${y}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        ${W}\n      }`},xl=(e,t,r,o,n,s,u=r.dataType)=>{let d=!k.areEqual(r.dims,o.dims),a=r.dims,m=k.size(r.dims),g=!1;if(d){let x=Qe.calcShape(r.dims,o.dims,!1);if(!x)throw new Error("Can\'t perform binary op on the given tensors");a=x,m=k.size(a);let b=k.size(r.dims)===1,w=k.size(o.dims)===1,v=1;for(let y=1;y<a.length;y++){let S=r.dims[r.dims.length-y]??1,A=o.dims[o.dims.length-y]??1;if(S===A)v*=S;else break}(v%4===0||b||w)&&(g=!0)}else g=!0;return{name:e,shaderCache:{hint:t},getShaderSource:x=>$l(x,r.dims,o.dims,a,g,d,n,r.dataType,o.dataType,u,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(m/64/4)}})}},ot=(e,t,r,o,n,s)=>{e.compute(xl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},Ka=e=>{ot(e,"Add",(t,r)=>`${t}+${r}`)},qa=e=>{ot(e,"Div",(t,r)=>`${t}/${r}`)},Ya=e=>{ot(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Xa=e=>{ot(e,"Mul",(t,r)=>`${t}*${r}`)},Ja=e=>{let t=L("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ot(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Za=e=>{ot(e,"Sub",(t,r)=>`${t}-${r}`)},Qa=e=>{ot(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},ei=e=>{ot(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},ti=e=>{ot(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},ri=e=>{ot(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Cl,Al,Il,El,oi,ai,ii=H(()=>{"use strict";ge();Pe();ve();Cl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},Al=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Il=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},El=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let w=1;w<e.length;w++){let v=e[w].dims.slice();for(let y=0;y<r.length;y++)if(y===o)n[o]+=v[y];else if(r[y]!==v[y])throw new Error("non concat dimensions must match")}let s=k.size(n),u=new Array(e.length),d=new Array(e.length),a=e[0].dataType,m=0;for(let w=0;w<e.length;++w)m+=e[w].dims[o],u[w]=m,d[w]=L(`input${w}`,a,e[w].dims);let g=X("output",a,n),x=g.indicesGet("indices",o),b=w=>`\n  ${w.declareVariables(...d,g)}\n\n  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map(v=>`${v}u`).join(",")});\n  ${Al(u.length)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n\n    var indices = ${g.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${x});\n    if (inputIndex != 0u) {\n      ${x} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Il(d,g)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:b}},oi=(e,t)=>{Cl(e.inputs),e.compute(El(e.inputs,t.axis))},ai=e=>ie({axis:e.axis})});var We,Wr,zr,Vr=H(()=>{"use strict";We=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Wr=(e,t=!1,r=!1,o=3)=>"",zr=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `});var Gr,En=H(()=>{"use strict";Gr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Nr,Ur,nr=H(()=>{"use strict";ge();Nr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Ur=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Rr,Pr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var Tl,Ol,or,si,_l,ar,Rl,Lr,ir=H(()=>{"use strict";ge();ve();nr();Vr();Tl=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Ol=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,or=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32)=>{let a=t[1]*e[1],m=t[0]*e[0],g=n?a:s,x=n?s:a,b=g/t[0],w=s/t[1];if(!((n&&b===4&&e[1]===4||!n&&(b===3||b===4))&&g%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${g/b}>, ${x}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${w};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Tl(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Ol(n,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},si=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,_l=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",ar=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32,a=!1)=>{let m=e[1]*t[1],g=e[0]*t[0],x=n?m:s,b=n?s:m;if(!(b%t[1]===0&&x%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${x} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=b/t[1],v=x/t[0],y=s/t[1],S=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${m};\n    let globalColStart = i32(workgroupId.x) * ${g};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${x}; inputCol = inputCol + ${t[0]}) {\n          ${si(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${m};\n\nlet tileRowA = i32(localId.y) * ${w};\nlet tileColA = i32(localId.x) * ${v};\nlet tileRowB = i32(localId.y) * ${y};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${si(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${_l(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${x}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${S}\n  }\n`},Rl=(e,t,r,o,n,s=!1)=>{let u=n[0],d=n[1],a=n[2],m=o[0],g=o[1],x=o[2],b=o[3],w=xn(u,a),v=xn(d,a),y=Me(o[0].type.tensor),S=()=>{let W=g.rank,M=m.rank,D=`var aIndices: ${g.type.indices};`;for(let _=W-2-1,z=M-1;_>=0;_--,z--)D+=`\naIndices[${_}] = ${M>1?`batchIndices[${z}]`:"batchIndices"};`;return w.forEach(_=>{D+=`\naIndices[${_}] = 0;`}),D+=`\naIndices[${W-2}] = u32(row);\n                   aIndices[${W-1}] = u32(colIn);`,D},A=()=>{let W=x.rank,M=m.rank,D=`var bIndices: ${x.type.indices};`;for(let _=W-2-1,z=M-1;_>=0;_--,z--)D+=`\nbIndices[${_}] = ${M>1?`batchIndices[${z}]`:"batchIndices"};`;return v.forEach(_=>{D+=`\nbIndices[${_}] = 0;`}),D+=`\nbIndices[${W-2}] = u32(row);\n                   bIndices[${W-1}] = u32(colIn);`,D};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,y)} {\n      var value = ${We(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${S()}\n        value = ${g.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,y)} {\n      var value = ${We(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${A()}\n        value = ${x.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${We(e,y)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${We(e,y)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Lr=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s.slice(0,-2),a=u.slice(0,-2),m=o?o.slice(0,-2):r.slice(0,-2),g=L("batchDims",e[0].dataType,m),x=[g],b=[d,a,m],w=k.size(m),v=s[s.length-2],y=s[s.length-1],S=u[u.length-1],A=y%4===0&&S%4===0,{activationFunction:R,applyActivation:W}=Nr(t,A),M=v<=8?[4,1,1]:[4,4,1],D=[8,8,1],_=[Math.ceil(S/D[0]/M[0]),Math.ceil(v/D[1]/M[1]),Math.ceil(w/D[2]/M[2])],z=Me(e[0].dataType),F=A?4:1,q=L("a",e[0].dataType,[...d,v,y/F],F),le=L("b",e[1].dataType,[...a,y,S/F],F),B=X("result",e[0].dataType,[w,v,S/F],F);x.push(q),x.push(le),x.push(B);let K=[q,le],xe=e.length>2,ae=Rl(F,xe,W,x,b,n);if(xe){let j=n?F:1;K.push(L("bias",e[2].dataType,e[2].dims,j))}let we=j=>`\n  const dimAOuter: i32 = ${v};\n  const dimBOuter: i32 = ${S};\n  const dimInner: i32 = ${y};\n  ${j.declareVariables(...K,B)}\n  ${R}\n  ${ae}\n  ${A?or(M,D,z,g):ar(M,D,z,g)}\n                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]}}),getShaderSource:we}}});var Pl,ui,li=H(()=>{"use strict";mt();ge();ve();Vr();En();ir();Pl=(e,t,r,o,n=!1,s,u=!1,d=4,a=4,m=4,g="f32")=>{let x=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},b=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,v=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"xShape[1]":"xShape[2]",S=e?"xShape[2]":"xShape[3]",A=e?"row":"col",R=e?"col":"row",W=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${R} / (filterDims[1] * inChannels);\n    let WCol = ${R} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${R} % inChannels;\n    var resData = ${We(d,g)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${S}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${x(d)}\n    }\n    return resData;`,M=e?t&&o?`\n    let col = colIn * ${d};\n    ${W}`:`\n    let col = colIn * ${d};\n    if (row < dimAOuter && col < dimInner) {\n      ${W}\n    }\n    return ${We(d,g)}(0.0);`:o&&r?`\n    let col = colIn * ${d};\n    ${W}`:`\n    let col = colIn * ${d};\n    if (row < dimInner && col < dimBOuter) {\n      ${W}\n    }\n    return ${We(d,g)}(0.0);`,D=`${b(a)}`,_=We(m,g),z=e?We(d,g):We(a,g),F=e?We(a,g):We(d,g);return`\n    ${Wr(s,u,m===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${z} {\n      ${e?M:D}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${F} {\n      ${e?D:M}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${m};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${v}\n      ${zr(n,s)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ui=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",m=a?e[0].dims[3]:e[0].dims[1],g=r[0],x=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],v=a&&(m%4===0||m%3===0)&&w%4===0,y=a?w:x*b,S=a?x*b:w,A=[8,8,1],R=o<=8?[4,1,1]:[4,4,1],W=[Math.ceil(y/A[0]/R[0]),Math.ceil(S/A[1]/R[1]),Math.ceil(g/A[2]/R[2])];Ee("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${W}`);let M=v?a&&m%4!==0?3:4:R[0],D=A[1]*R[1],_=A[0]*R[0],z=Math.max(A[0]*M,A[1]),F=o%D===0,q=n%_===0,le=s%z===0,B=v?[M,4,4]:[1,1,1],K=Me(e[0].dataType),xe=[`@group(0) @binding(0) var<storage, read> x: array<${v&&M===4?`vec4<${K}>`:K}>;`,`@group(0) @binding(1) var<storage, read> w: array<${v?`vec4<${K}>`:K}>;`],ae=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${K}>`:K}) {\n        result[flatIndex] = ${v?`vec4<${K}>`:K}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${K}>`:K}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`;return u&&(xe.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?`vec4<${K}>`:K}>;`),ae+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${K}>`:K} {\n          return bias[coords.${a?"w":"y"}${v?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${Gr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${xe.join("")}\n        @group(0) @binding(${xe.length}) var<storage, read_write> result: array<${v?`vec4<${K}>`:K}>;\n        //@group(0) @binding(${xe.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${ae}\n        ${Pl(a,F,q,le,u,t.activation.toLowerCase(),!1,B[0],B[1],B[2],K)}\n            ${v?or(R,A,K,void 0,!a,z):ar(R,A,K,void 0,!a,z,!1,void 0,d)}`}}});var Tn,di=H(()=>{"use strict";ge();ve();_n();nr();Tn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,d=u[0]/t.group,{activationFunction:a,applyActivation:m}=Nr(t),g=t.format==="NHWC",x=On(s,u,t.dilations,t.pads,t.strides,g),b=k.size(x),w=X("output",e[0].dataType,x),v=L("x",e[0].dataType,s),y=L("w",e[1].dataType,u),S=[v,y];o&&S.push(L("b",e[2].dataType,e[2].dims));let A=R=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${R.declareVariables(...S,w)}\n\n  ${a}\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n    let outputIndices = ${w.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${g?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${w.type.value} = ${w.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[g?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[g?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${g?v.get("batch","xHeight","xWidth","input_channel"):v.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${y.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${m}\n    ${w.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(x):x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:A}}});var On,ci,Ml,pi,Rn,Bl,kl,Pn,_n=H(()=>{"use strict";ge();Pe();li();ir();di();nr();rr();On=(e,t,r,o,n,s)=>{let u=e[0],d=e.slice(s?1:2,s?3:4),a=d.length,m=t[0],x=t.slice(2).map((v,y)=>v+(v-1)*(r[y]-1)),w=d.map((v,y)=>v+o[y]+o[y+a]).map((v,y)=>Math.floor((v-x[y]+n[y])/n[y]));return w.splice(0,0,u),w.splice(s?3:1,0,m),w},ci=[2,3,1,0],Ml=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},pi=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();Ct.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},Rn=e=>{let t=Ur(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,d=e.pads,a=e.strides,m=e.w_is_const();return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:d,strides:a,wIsConst:m,...t})},Bl=(e,t,r)=>{let o=pi(r,t);if(r.group!==1){e.compute(Tn(t,o));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],d=t[0].dims[n?2:3],a=t[0].dims[n?3:1],m=t[1].dims[2],g=t[1].dims[3],x=On(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),b=x[n?1:2],w=x[n?2:3],v=x[n?3:1],y=n&&m===u&&g===d&&r.pads[0]===0&&r.pads[1]===0;if(y||m===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let _=x[0],z,F,q,le=[];if(n){let B=e.kernelCustomData.wT??e.compute(gt(t[1],ci),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=B),y){let K=u*d*a;z=t[0].reshape([1,_,K]),F=B.reshape([1,K,v]),q=[1,_,v]}else z=t[0].reshape([_,u*d,a]),F=B.reshape([1,a,v]),q=[_,b*w,v];le.push(z),le.push(F)}else z=t[0].reshape([_,a,u*d]),F=t[1].reshape([1,v,a]),q=[_,v,b*w],le.push(F),le.push(z);s&&le.push(t[2]),e.compute(Lr(le,o,x,q,n),{inputs:le});return}let S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],ci),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let R=[t[0],A];s&&R.push(t[2]);let W=n?b*w:v,M=n?v:b*w,D=m*g*a;e.compute(ui(R,o,x,W,M,D,s,S),{inputs:R})},kl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),d=[1].concat(t.kernelShape),a=pi({...t,pads:n,strides:s,dilations:u,kernelShape:d},o);e.compute(Tn(o,a,m=>r?[m[0],m[2],m[3]]:[]))},Pn=(e,t)=>{Ml(e.inputs,t),e.inputs[0].dims.length===3?kl(e,t):Bl(e,e.inputs,t)}});var Dl,fi,mi=H(()=>{"use strict";mt();ge();Vr();En();ir();Dl=(e,t=!1,r,o=!1,n=4)=>{let s=We(n,"f32"),u=A=>{switch(A){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${A} is not supported.`)}},d=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,a=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"outBackprop[1]":"outBackprop[2]",g=e?"outBackprop[2]":"outBackprop[3]",x=e?"row":"col",b=e?"col":"row",w=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${x} / outWidth;\n      let outCol = ${x} % outWidth;\n\n      let WRow = ${b} / (filterDims[1] * inChannels);\n      let WCol = ${b} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${b} % inChannels;\n      ${d}\n      return x[getIndexFromCoords4D(coord, xShape)/${n}];`,v=e?`\n      let col = colIn * ${n};\n      if (row < dimAOuter && col < dimInner) {\n        ${w}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${n};\n      if (row < dimInner && col < dimBOuter) {\n        ${w}\n      }\n      return ${s}(0.0);`,y=`\n      let col = colIn * ${n};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(n)}\n      }\n      return ${s}(0.0);\n      `;return`\n  ${Wr(r,o,n===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?v:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?y:v}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${n};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${a}\n      ${zr(t,r)}\n      result[getIndexFromCoords4D(coords, outShape)/${n}] = value;\n    }\n  }`},fi=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",m=a?e[0].dims[3]:e[0].dims[1],g=r[0],x=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],v=a?m%4===0&&w%4===0:x%4===0&&w%4===0,y=a?w:x*b,S=a?x*b:w,A=v?[8,8,1]:[y<=4||S<=4?4:16,y>4&&S<=4?4:16,1],R=v?[4,4,1]:[y<=4?1:4,y>4&&S<=4?1:4,1],W=[Math.ceil(y/A[0]/R[0]),Math.ceil(S/A[1]/R[1]),Math.ceil(g/A[2]/R[2])];Ee("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${W}`);let M=v?4:1,D=Math.max(A[0]*M,A[1]),_=[`@group(0) @binding(0) var<storage, read> x: array<${v?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],z="";return u&&(_.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?"vec4<f32>":"f32"}>;`),z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?"vec4<f32>":"f32"} {\n          return bias[coords.${a?"w":"y"}${v?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${Gr}\n        ${_.join(`\n`)}\n        @group(0) @binding(${_.length}) var<storage, read_write> result: array<${v?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${z}\n        ${Dl(a,u,t.activation.toLowerCase(),!1,M)}\n        ${v?or(R,A,"f32",void 0,!a,D):ar(R,A,"f32",void 0,!a,D,!1,void 0,d)}`}}});var Wl,Mn,hi=H(()=>{"use strict";mt();ge();ve();Wl=(e,t,r,o,n,s,u=!1,d)=>{let a=r.format==="NHWC",m=a?1:2,g=a?2:3,x=a?3:1,b=k.size(o),w=u?2:1,v=r.group,y=t[1].dims,S=y[0]/v,A=y[1],R=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${u?`vec4<${d}>`:d}(value);\n  }`;n&&(R+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${d}>`:d} {\n      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];\n    }`);let W=u?4:1,M=L("W",t[1].dataType,t[1].dims,W),D=L("Dy",t[0].dataType,t[0].dims,W),_=[D,M];n&&_.push(L("bias",t[2].dataType,[o[x]],W));let z=X("result",t[0].dataType,o,W),F=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${D.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${x}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${z.set("batch","r","c + i","d1","value")};\n        }\n      }`,q=`\n          let outputIndices = ${z.offsetToIndices("global_idx")};\n          let batch = ${z.indicesGet("outputIndices",0)};\n          let d1 = ${z.indicesGet("outputIndices",x)};\n          let r = ${z.indicesGet("outputIndices",m)};\n          let c = ${z.indicesGet("outputIndices",g)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${A};\n          let wOutChannel = d1 - groupId * ${A};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${m}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${g}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${S};\n              for (var d2: u32 = 0; d2 < ${S}; d2 = d2 + 1) {\n                let xValue = ${a?D.get("batch","idyR","idyC","inputChannel"):D.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${M.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${z.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(..._,z)}\n  ${R}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${u?F:q}}`},Mn=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=k.size(n),u=[Math.ceil(s/64),1,1];Ee("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let d=Me(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>Wl(a,e,t,n,o,u[1]===1&&u[2]===1,!1,d)}}});var zl,Vl,Gl,gi,yi,Nl,Ul,Ll,Fl,bi,wi=H(()=>{"use strict";Pe();mi();hi();nr();rr();zl=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,Vl=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},Gl=(e,t,r,o,n,s,u,d,a,m)=>{let g=e.length-2,x=m.length===0;if(a.length===0)for(let v=0;v<g;++v)a.push(0);let b=e[0],w=t[d?3:1]*n;for(let v=0,y=e.length-g-(d?1:0);v<g;++v,++y){let S=e[y],A=x?S*u[v]:m[v],R=zl(S,u[v],s[v],t[y],r[v],A);Vl(R,o,s,v,v+g),x&&m.push(u[v]*(S-1)+a[v]+(t[y]-1)*r[v]+1-s[v]-s[v+g])}m.splice(0,0,b),m.splice(d?3:1,0,w)},gi=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,w)=>b*w,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),d=t[0].dims,a=e.dilations.slice();if(a.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;a=new Array(b).fill(1)}let m=e.strides.slice();if(m.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;m=new Array(b).fill(1)}Gl(d,r,a,e.autoPad,e.group,n,m,o,u,s);let g=Object.assign({},e),x=e.cacheKey+[r.join("n,"),n.join(","),m.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:m,cacheKey:x}),g},yi=e=>{let t=Ur(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,d=e.pads,a=e.strides,m=e.wIsConst(),g=e.outputPadding,x=e.outputShape;return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:g,outputShape:x,pads:d,strides:a,wIsConst:m,...t})},Nl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((g,x)=>g+x,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((g,x)=>g+x,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((g,x)=>g+x,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((g,x)=>g+x,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ul=[2,3,1,0],Ll=(e,t,r)=>{let o=gi(r,t),n=r.format==="NHWC",s=t.length===3;if(o.group!==1){e.compute(Mn(t,o));return}let u=o.outputShape,d=u[n?1:2],a=u[n?2:3],m=u[n?3:1],g=t[1].dims[2],x=t[1].dims[3],b=t[0].dims[n?3:1],w=n?d*a:m,v=n?m:d*a,y=g*x*b,S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],Ul),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let R=[t[0],A];s&&(!n&&t[2].dims.length===1?R.push(t[2].reshape([t[2].dims[0],1,1])):R.push(t[2])),e.compute(fi(R,o,u,w,v,y,s,S),{inputs:R})},Fl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=gi({...t,pads:d,strides:u,dilations:s,kernelShape:n},o);e.compute(Mn(o,a,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},bi=(e,t)=>{Nl(e.inputs,t),e.inputs[0].dims.length===3?Fl(e,t):Ll(e,e.inputs,t)}});var Bn,Fr,vi,Hl,jl,kn,Dn,Kl,$i,xi,Si=H(()=>{"use strict";ge();Pe();ve();Bn="[a-zA-Z]|\\\\.\\\\.\\\\.",Fr="("+Bn+")+",vi="^"+Fr+"$",Hl="("+Fr+",)*"+Fr,jl="^"+Hl+"$",kn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Dn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(jl)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,a)=>{let m=t[a].dims.slice();if(!d.match(RegExp(vi)))throw new Error("Invalid LHS term");let g=this.processTerm(d,!0,m,a);this.lhs.push(g)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([d,a])=>a.count===1||d==="...").map(([d])=>d).join("");else if(!n.match(RegExp(Fr)))throw new Error("Invalid RHS");n.match(RegExp(Bn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(d);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,d=[],a=0;if(!t.match(RegExp(vi))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(Bn,"g")),g=new kn(n);return m?.forEach((x,b)=>{if(x==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-m.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(a,a+w),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<d.length;v++){let y=String.fromCharCode("0".charCodeAt(0)+b);g.addSymbol(y,b+v),this.addSymbol(y,o[a++],n)}}else g.addSymbol(x,b),this.addSymbol(x,o[a++],n)}),g}},Kl=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let W=0;W<e.length;++W)o[W]=L(`input${W}`,r,e[W].dims);let n=t.outputDims,s=k.size(n),u=X("output",r,n),d=[],a=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",g="var sum = 0.0;",x="sum += prod;",b=[],w=[],v=[],y=[],S=t.symbolToInfo.size===a.length;t.symbolToInfo.forEach((W,M)=>{if(a.includes(M)){let D=a.indexOf(M);t.lhs.forEach((_,z)=>{if(W.inputIndices.includes(z)){let F=_.symbolToIndices.get(M);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(q=>{d.push(`${o[z].indicesSet(`input${z}Indices`,q,u.indicesGet("outputIndices",D))}`)})}})}else t.lhs.forEach((D,_)=>{let z=t.symbolToInfo.get(M);if(z===void 0)throw new Error("Invalid symbol error");if(z.inputIndices.includes(_)){let F=D.symbolToIndices.get(M);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(q=>{b.push(`${o[_].indicesSet(`input${_}Indices`,q,`${M}`)}`)}),y.push(`prod *= ${o[_].getByIndices(`input${_}Indices`)};`)}}),w.push(`for(var ${M}: u32 = 0; ${M} < ${t.symbolToInfo.get(M)?.dimValue}; ${M}++) {`),v.push("}")});let A=S?[...d,`let sum = ${o.map((W,M)=>W.getByIndices(`input${M}Indices`)).join(" * ")};`]:[...d,g,...w,...b,m,...y,x,...v],R=W=>`\n      ${W.declareVariables(...o,u)}\n\n      ${W.mainStart()}\n        ${W.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${u.offsetToIndices("global_idx")};\n        ${o.map((M,D)=>`var input${D}Indices: ${o[D].type.indices};`).join(`\n`)}\n        ${A.join(`\n`)};\n        ${u.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:R}},$i=(e,t)=>{let r=new Dn(e.inputs,t.equation);e.compute(Kl(e.inputs,r))},xi=e=>{let t=e.equation.replace(/\\s+/g,"");return ie({equation:t})}});var ql,Ci,Yl,Xl,Ai,Ii=H(()=>{"use strict";ge();ve();ql=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Ci=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},Yl=(e,t)=>e.length>t.length?Ci(e,t):Ci(t,e),Xl=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Yl(t,r),n=k.size(o),s=e[0].dataType,u=L("input",s,t),d=X("output",s,o),a=m=>`\n  const inputShape = ${u.indices(...t)};\n  ${m.declareVariables(u,d)}\n  ${m.mainStart()}\n  ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    var inputIndices: ${u.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${u.indicesGet("inputShape","i")} == 1) {\n        ${u.indicesSet("inputIndices","i",0)}\n      } else {\n        ${u.indicesSet("inputIndices","i",d.indicesGet("outputIndices",`i + ${o.length-t.length}`))}\n      }\n    }\n    ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:a,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Ai=e=>{ql(e.inputs),e.compute(Xl(e.inputs),{inputs:[0]})}});var Jl,Zl,Ei,Ti,Oi=H(()=>{"use strict";ge();Pe();ve();Jl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Zl=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=k.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let d=r[s],a=k.size(u),m=L("data",e[0].dataType,e[0].dims),g=L("inputIndices",e[1].dataType,e[1].dims),x=X("output",e[0].dataType,u),b=()=>{let v=o.length,y=`var indicesIndices  = ${g.type.indices}(0);`;for(let S=0;S<v;S++)y+=`${v>1?`indicesIndices[${S}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+S}]`:"outputIndices"};`;y+=`\n        var idx = ${g.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${d};\n        }\n        var dataIndices = ${m.type.indices}(0);\n      `;for(let S=0,A=0;S<n;S++)S===s?(y+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = u32(idx);`,A+=v):(y+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = ${u.length>1?`outputIndices[${A}]`:"outputIndices"};`,A++);return y},w=v=>`\n      ${v.declareVariables(m,g,x)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n        let outputIndices = ${x.offsetToIndices("global_idx")};\n        ${b()};\n        let value = ${m.getByIndices("dataIndices")};\n        ${x.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:w}},Ei=e=>ie({axis:e.axis}),Ti=(e,t)=>{let r=e.inputs;Jl(r),e.compute(Zl(e.inputs,t))}});var Ql,ed,_i,Ri,Pi=H(()=>{"use strict";ge();Pe();ve();Ql=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},ed=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=k.computeStrides(r),u=k.size(r),d=e[1].dims,a=e[1].dataType,m=k.size(d),g=k.normalizeAxis(t.axis,n),x=r[g],b=d.slice(0),w=k.size(b),v=L("input",o,r),y=L("indices",a,[m]),S=X("output",o,b),A=R=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(W=>`${W}u`).join(",")});\n      ${R.declareVariables(v,y,S)}\n      ${R.mainStart()}\n      ${R.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n\n      let outputIndices = ${S.offsetToIndices("global_idx")};\n\n      var idx = ${y.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${x};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${g}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${S.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${u}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:A}},_i=e=>ie({axis:e.axis}),Ri=(e,t)=>{let r=e.inputs;Ql(r),e.compute(ed(e.inputs,t))}});var td,rd,nd,Mi,Bi,ki=H(()=>{"use strict";ge();Pe();ve();td=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},rd=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},nd=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=_r.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[n,s];if(!d)throw new Error("Can\'t use gemm on the given tensors");let a=k.size(d),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let g=Me(e[0].dataType),x=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${rd(n,s,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let v=y=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${g}(${t.alpha});\n  const beta = ${g}(${t.beta});\n\n  ${w.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${g}>;\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${g}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${m}\n    }\n\n    ${x}\n    ${b}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:v}},Mi=(e,t)=>{td(e.inputs),e.compute(nd(e.inputs,t))},Bi=e=>ie(e)});var od,ad,id,sd,Di,Wi,zi=H(()=>{"use strict";De();ge();Pe();ve();od={name:"InstanceNormalization"},ad=(e,t)=>{let r=e[0].dims,o=r,n=2,s=k.sizeToDimension(r,n),u=k.sizeFromDimension(r,n),d=r[1],a=L("x",e[0].dataType,[r[0],r[1],u]),m=L("scale",e[1].dataType,e[1].dims),g=L("bias",e[2].dataType,e[2].dims),x=X("output",e[0].dataType,[r[0],r[1],u]),b=[a,m,g,x],w=a.type.value,v=64,y=S=>`\n\n  const C: u32 = ${d};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${w};\n  var<workgroup> squaredNormShared : ${w};\n  var<workgroup> workgroupShared : array<${w}, ${v}>;\n  const workgroupSize = ${v}u;\n  ${S.declareVariables(...b)}\n  ${S.mainStart(v)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${w} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${a.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${w}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${a.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${w}(normSize) + epsilon);\n    let channelScale = invStdDev * ${m.getByOffset("channel")};\n    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${a.get("batch","channel","h")} * channelScale + channelShift;\n      ${x.set("batch","channel","h","value")};\n    }\n  }`;return{...od,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:y}},id=(e,t,r,o,n,s,u,d)=>{let a=lt(u),m=L("input",t.dataType,t.dims,a),g=L("scale",r.dataType,r.dims,a),x=L("bias",o.dataType,o.dims,a),b=64,w=a===1?"vec2f":`mat2x${a}f`,v=a===1?"f32":`vec${a}f`,y=(D,_)=>`${w}(${D}, ${_})`,S=n*u/a,A=Math.ceil(s/b),R=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${s*u/a};\n\n  ${D.declareVariables(m)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart(b)}\n    let currentImageNumber = global_idx / ${b} / C;\n    let currentChannelNumber = (global_idx / ${b}) % C;\n    let wgId = global_idx % ${b};\n    let wgOffset = wgId * ${A};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${A}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${qe("f32",a)};\n    var squaredSum = ${qe("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${v}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${y("sum","squaredSum")};\n  }`,W=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,b,2],dataType:1}],dispatchGroup:{x:n*u/a}}),getShaderSource:R},{inputs:[t],outputs:[-1]})[0],M=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${b*u/a};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${w}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${g.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${x.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart()}\n    ${D.guardAgainstOutOfBoundsWorkgroupSizes(S)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${qe("f32",a)};\n    var squaredSum = ${qe("f32",a)};\n    for (var i: u32 = 0; i < ${b}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${b}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${v}(scale[currentChannelNumber]);\n    let channelShift = ${v}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${y("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u,epsilon:d})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:M},{inputs:[W,r,o],outputs:[-1]})[0]},sd=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],d=k.sizeFromDimension(o,1)/u,a=lt(u),m=k.size(n)/a,g=L("input",t[0].dataType,t[0].dims,a),x=X("output",t[0].dataType,n,a),b=Me(t[0].dataType),w=a===1?"vec2f":`mat2x${a}f`,v=a===1?b:`vec${a}<${b}>`,y=id(e,t[0],t[1],t[2],s,d,u,r.epsilon),S=A=>`\n  const H: u32 = ${d};\n  const C: u32 = ${u/a};\n\n  @group(0) @binding(0) var<storage, read> input : array<${g.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${x.type.storage}>;\n\n  ${A.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${v}(scale[0]), ${v}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:S},{inputs:[t[0],y]})},Di=e=>ie({epsilon:e.epsilon,format:e.format}),Wi=(e,t)=>{t.format==="NHWC"?sd(e,e.inputs,t):e.compute(ad(e.inputs,t))}});var ud,ld,Vi,Gi,Ni=H(()=>{"use strict";De();ge();Pe();ve();ud=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ld=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,d=k.normalizeAxis(t.axis,o.length),a=k.sizeToDimension(o,d),m=k.sizeFromDimension(o,d),g=k.size(n.dims),x=s?k.size(s.dims):0;if(g!==m||s&&x!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${g} and bias size of ${x}`);let b=[];for(let M=0;M<o.length;++M)M<d?b.push(o[M]):b.push(1);let w=lt(m),v=Me(e[0].dataType),y=[L("x",e[0].dataType,e[0].dims,w),L("scale",n.dataType,n.dims,w)];s&&y.push(L("bias",s.dataType,s.dims,w)),y.push(X("output",e[0].dataType,u,w));let S=r>1,A=r>2;S&&y.push(X("meanDataOutput",1,b)),A&&y.push(X("invStdOutput",1,b));let R=M=>`\n  const normSize: f32 = ${m};\n  const normSizeVectorized: u32 = ${m/w};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${M.declareVariables(...y)}\n  ${M.mainStart()}\n    ${M.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${qe("f32",w)};\n    var meanSquareVector = ${qe("f32",w)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${At(v,w,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${ht("meanVector",w)} / normSize;\n    let meanSquare = sqrt(${ht("meanSquareVector",w)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${At(v,w,"x[j + offset]")};\n      let f32scale = ${At(v,w,"scale[j]")};\n      output[j + offset] = ${y[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${At(v,w,"bias[j]")}`:""}\n      );\n    }\n\n    ${S?"meanDataOutput[global_idx] = mean":""};\n    ${A?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,W=[{dims:u,dataType:e[0].dataType}];return S&&W.push({dims:b,dataType:1}),A&&W.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:R}},Vi=e=>ie({axis:e.axis,epsilon:e.epsilon}),Gi=(e,t)=>{ud(e.inputs),e.compute(ld(e.inputs,t,e.outputCount))}});var dd,Ui,Li=H(()=>{"use strict";ge();ir();dd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Ui=e=>{dd(e.inputs);let t=Qe.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(Lr(e.inputs,{activation:"",activationCacheKey:""},t))}});var cd,pd,fd,md,hd,gd,yd,bd,wd,Fi,Hi,ji=H(()=>{"use strict";De();ge();Pe();ve();cd=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},pd=(e,t,r,o,n,s,u)=>{let d=r.length,a="";for(let m=d-1;m>=0;--m)a+=`\n            k = i32(${e.indicesGet("indices",m)}) - ${n[m]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[m]}) {\n              break;\n            }\n            offset += k * ${o[m]};\n        `;return`\n          value = ${s}(${u});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${a}\n            value = x[offset];\n          }\n      `},fd=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[d]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[d]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},md=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[d]}) {\n                  k = ${r[d]-1};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},hd=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0)  {\n                  k += ${r[d]};\n                }\n                if (k >= ${r[d]}) {\n                  k -= ${r[d]};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},gd=(e,t,r,o,n,s)=>{switch(n.mode){case 0:return pd(e,t,r,o,n.pads,s,n.value);case 1:return fd(e,t,r,o,n.pads);case 2:return md(e,t,r,o,n.pads);case 3:return hd(e,t,r,o,n.pads);default:throw new Error("Invalid mode")}},yd=(e,t,r,o)=>{let n=t[0].dims,s=k.padShape(n.slice(),r.pads),u=k.size(s),d=k.computeStrides(n),a=X("output",t[0].dataType,s),m=L("x",t[0].dataType,n),g=gd(a,s,n,d,r,o);return`\n              ${e.declareVariables(m,a)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${a.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${g}\n              output[global_idx] = value;\n          }`},bd=(e,t)=>{let r=k.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(r)/64)}}),getShaderSource:o=>yd(o,e,t,"f32")}},wd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let a=0;a<d.length;a++)s[Number(d[a])]=Number(r[a]),s[Number(d[a])+n]=Number(r[a+d.length])}else r.forEach((d,a)=>s[Number(a)]=Number(d));let u=[];return s.forEach(d=>u.push(d)),ie({mode:t.mode,value:o,pads:u})}else return t},Fi=(e,t)=>{cd(e.inputs);let r=wd(e.inputs,t);e.compute(bd(e.inputs,r),{inputs:[0]})},Hi=e=>{let t=e.mode,r=e.value,o=e.pads;return ie({mode:t,value:r,pads:o})}});var Hr,Ki,qi,Yi,Xi,Ji,Zi,Qi,es,ts,rs,ns,os,as,is,ss=H(()=>{"use strict";ge();Pe();ve();Hr=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Ki=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),d=t.strides.slice(),a=s?t.dilations.slice():[],m=t.pads.slice();Ct.adjustPoolAttributes(r,n,u,d,a,m);let g=Ct.computePoolOutputShape(r,n,d,a,u,m,t.autoPad),x=Object.assign({},t);s?Object.assign(x,{kernelShape:u,strides:d,pads:m,dilations:a,cacheKey:t.cacheKey}):Object.assign(x,{kernelShape:u,strides:d,pads:m,cacheKey:t.cacheKey});let b=g.slice();return b.push(b.splice(1,1)[0]),[x,o?b:g]},qi=(e,t,r,o,n,s,u,d)=>{let a=n.format==="NHWC",m=r,g=t.type.value,x=m.length,b=k.size(o),w=X("output",t.type.tensor,o);if(n.kernelShape.length<=2){let v=n.kernelShape[n.kernelShape.length-1],y=n.strides[n.strides.length-1],S=n.pads[n.pads.length/2-1],A=n.pads[n.pads.length-1],R=x-(a?2:1),W="",M="",D="";if(S+A!==0?W=`\n                for (var i: u32 = 0u; i < ${v}u; i++) {\n                  xIndices[${R}] = indices[${R}] * ${y} - ${S} + i;\n                  if (xIndices[${R}] < 0 || xIndices[${R}] >= ${m[R]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:W=`\n                for (var i: u32 = 0u; i < ${v}u; i++) {\n                  xIndices[${R}] = indices[${R}] * ${y} - ${S} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let z=n.kernelShape[n.kernelShape.length-2],F=n.strides[n.strides.length-2],q=n.pads[n.pads.length/2-2],le=n.pads[n.pads.length-2],B=x-(a?3:2),K=m[B];q+le!==0?M=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${F} - ${q} + j;\n                  if (xIndices[${B}] < 0 || xIndices[${B}] >= ${K}) {\n                    pad+= ${v};\n                    continue;\n                  }\n              `:M=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${F} - ${q} + j;\n                `,D=`\n              }\n            `}return`\n            ${e.declareVariables(t,w)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              var xIndices = ${w.offsetToIndices("global_idx")};\n\n              var value: ${g} = ${g}(${d});\n              var pad = 0;\n              ${M}\n              ${W}\n              ${D}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(a)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let v=k.size(n.kernelShape),y=k.computeStrides(n.kernelShape),S=y.length,A=n.pads.length,R=n.pads.reduce((D,_)=>D+_),W="";return R?W=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:W=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,w)}\n\n            const pads = array<u32, ${A}>(${n.pads.map(D=>`${D}u`).join(",")});\n            const inputDims = array<u32, ${x}>(${m.map(D=>`${D}u`).join(",")});\n            const kernelStrides = array<u32, ${S}>(${y.map(D=>`${D}u`).join(",")});\n            const strides = array<u32, ${S}>(${n.strides.map(D=>`${D}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              let xIndices = ${w.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${w.type.value}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${v}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${x-S}u; j < ${x}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${x-S}u]\n                    + offsets[j - ${x-S}u] - pads[j - 2u];\n                  ${W}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},Yi=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xi=(e,t,r,o)=>{let[n,s]=Ki(t,o,r),u=k.size(n.kernelShape),d=L("x",t.dataType,t.dims),a=d.type.value,m="value += x_val;",g="";return n.countIncludePad?g+=`value /= ${a}(${u});`:g+=`value /= ${a}(${u} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:x=>qi(x,d,t.dims,s,n,m,g,"0.0")}},Ji=e=>{let t=e.count_include_pad!==0,r=Yi(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ie({countIncludePad:t,...r})},Zi=(e,t)=>{Hr(e.inputs),e.compute(Xi("AveragePool",e.inputs[0],!1,t))},Qi={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},es=e=>{let t=e.format;return{format:t,...Qi,cacheKey:t}},ts=(e,t)=>{Hr(e.inputs),e.compute(Xi("GlobalAveragePool",e.inputs[0],!0,t))},rs=(e,t,r,o)=>{let[n,s]=Ki(t,o,r),u=`\n      value = max(x_val, value);\n    `,d="",a=L("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:m=>qi(m,a,t.dims,s,n,u,d,"-1e5")}},ns=(e,t)=>{Hr(e.inputs),e.compute(rs("MaxPool",e.inputs[0],!1,t))},os=e=>{let t=e.storage_order,r=e.dilations,o=Yi(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ie({storageOrder:t,dilations:r,...o})},as=e=>{let t=e.format;return{format:t,...Qi,cacheKey:t}},is=(e,t)=>{Hr(e.inputs),e.compute(rs("GlobalMaxPool",e.inputs[0],!0,t))}});var jr=H(()=>{"use strict"});var us=H(()=>{"use strict";jr()});var ls,ds=H(()=>{"use strict";ls="1.17.0-dev.20231103-1439da36fe"});var cs,Wn,ps=H(()=>{"use strict";ds();cs="warning",Wn={wasm:{},webgl:{},webgpu:{},versions:{common:ls},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);cs=e}},get logLevel(){return cs}};Object.defineProperty(Wn,"logLevel",{enumerable:!0})});var fs,ms=H(()=>{"use strict";ps();fs=Wn});var hs=H(()=>{"use strict"});var gs=H(()=>{"use strict";Kr()});var bs=H(()=>{"use strict"});var ws=H(()=>{"use strict";Kr()});var Kr=H(()=>{"use strict";hs();gs();bs();ws()});var qr=H(()=>{"use strict";Kr()});var vs=H(()=>{"use strict";jr();qr()});var $s=H(()=>{"use strict";vs()});var xs=H(()=>{"use strict"});var Ss=H(()=>{"use strict";jr();qr()});var Cs=H(()=>{"use strict";Ss()});var As=H(()=>{"use strict";us();ms();$s();qr();xs();Cs()});var Sd,Cd,Is,Es=H(()=>{"use strict";As();De();ve();Sd=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},Cd=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,d=X("output",o,s),a=d.type.storage,m=g=>`\n        ${g.declareVariables(d)}\n        ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${a}(${e}) + ${a}(global_idx) * ${a}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(g=>g.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},Is=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),fs.webgpu.validateInputContent&&Sd(t,r,o),e.compute(Cd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var Ad,Id,Ed,Td,Od,_d,Rd,Pd,Md,Bd,kd,Dd,Wd,zd,Vd,Ts,Os,_s=H(()=>{"use strict";ge();Pe();ve();Ad=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Id=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},Ed=(e,t,r,o,n,s)=>{let[u,d,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(g=>s.push(g));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(g=>o.push(g)),o.length!==0&&o.length!==m&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ad(o,t),t.axes.length>0&&Id(o,t.axes,m).forEach((g,x)=>o[x]=g)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(g=>n.push(Number(g))),n.length!==m||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},Td=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Od=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",_d=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},Rd=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},Pd=(e,t,r,o)=>{let n=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return o.axes.length>0?(o.axes.forEach(u=>r[u]=n),o.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(n,0,r.length),s.forEach((u,d)=>s[d]=Math.round(u*r[d]))),s},Md=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Bd=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(d=>`${d}u`).join(",")});\n        const outputShape = array<u32, ${o.length}>(${o.map(d=>`${d}u`).join(",")});\n        const scales = array<f32, ${n.length}>(${n.map(d=>`${d}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(d=>`${d}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${o.length}; i++) {\n          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,kd=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Dd=(e,t,r,o,n,s,u)=>{let[d,a,m,g]=r.length===2?[-1,0,1,-1]:n[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${a}] = max(0, min(row, ${r[a]} - 1));\n      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${g}] = channel;\n        inputIndices[${d}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${a}];\n      var col:f32 = originalIndices[${m}];\n      if (${s} && (row < 0 || row > (${r[a]} - 1) || col < 0 || col > ${r[m]} - 1)) {\n        return ${u};\n      }\n      row = max(0, min(row, ${r[a]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${g}]);\n        batch = u32(originalIndices[${d}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Wd=(e,t,r,o,n,s,u,d,a,m)=>{let[g,x]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],b=w=>{let v=w===g?"row":"col";return`\n      fn ${v}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${w}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[w]},\n        f32(${o[w]}), f32(${r[w]}), ${s[w]}, ${s[w]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[w]} - 1))) {\n          return ${a};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${v}: f32 = originalIdx + f32(i);\n          if (${v} < 0 || ${v} >= ${r[w]}) {\n            if (${m}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${a};\n            } else {\n              ${v} = max(0, min(${v}, ${r[w]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${w}] = u32(${v});\n          data[i + 1] = ${w===g?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${b(g)};\n    ${b(x)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},zd=(e,t,r,o,n,s)=>{let u=e.dims,d=_d(s,t.axes,u.length),a=Rd(u,o,n,t.axes),m=o.slice();o.length===0&&(m=u.map((S,A)=>S===0?1:a[A]/S),t.keepAspectRatioPolicy!=="stretch"&&(a=Pd(u,a,m,t)));let g=X("output",e.dataType,a),x=L("input",e.dataType,u),b=k.size(a),w=u.length===a.length&&u.every((S,A)=>S===a[A]),v=t.coordinateTransformMode==="tf_crop_and_resize",y=S=>`\n      ${Td(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${kd(x,u)};\n              ${Od(t.nearestMode,r)};\n              ${Bd(x,g,u,a,m,d,v)};\n              `;case"linear":return`\n              ${Md(g,u,a,m,d)};\n              ${Dd(x,g,u,a,m,v,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Wd(x,g,u,a,m,d,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${S.declareVariables(x,g)}\n      ${S.mainStart()}\n        ${S.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        if (${w}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${g.offsetToIndices("global_idx")};\n          var inputIndices: ${x.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${x.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${n.length>0?n:""}`},getShaderSource:y,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},Vd=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Ts=(e,t)=>{let r=[],o=[],n=[],s=Vd(e);Ed(e.inputs,t,s,r,o,n),e.compute(zd(e.inputs[0],t,s,r,o,n),{inputs:[0]})},Os=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,a=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return ie({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:d,mode:a,nearestMode:m})}});var Gd,Nd,Rs,Ps,Ms=H(()=>{"use strict";De();ge();Pe();ve();Gd=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},Nd=(e,t,r,o)=>{let n=e[0].dims,s=k.size(n),u=n,d=s,a=n.slice(-1)[0],m=o?n.slice(0,-1).concat(1):[],g=e.length>3,x=e.length>4,b=o&&r>1,w=o&&r>2,v=r>3,y=lt(a),S=[L("x",e[0].dataType,e[0].dims,y),L("skip",e[1].dataType,e[1].dims,y),L("gamma",e[2].dataType,e[2].dims,y)];g&&S.push(L("beta",e[3].dataType,e[3].dims,y)),x&&S.push(L("bias",e[4].dataType,e[4].dims,y)),S.push(X("output",e[0].dataType,u,y)),b&&S.push(X("meanOutput",1,m)),w&&S.push(X("invStdOutput",1,m)),v&&S.push(X("inputSkipBiasSum",e[0].dataType,u,y));let A=Me(e[0].dataType),R=M=>`\n      const hiddenSize: f32 = ${a};\n      const hiddenSizeVectorized: u32 = ${a/y};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${M.declareVariables(...S)}\n\n      ${M.mainStart()}\n        ${M.guardAgainstOutOfBoundsWorkgroupSizes(d/a)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${qe("f32",y)};\n        var squareSum = ${qe("f32",y)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${x?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${v?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${At(A,y,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${ht("sum",y)} / hiddenSize;\n        let variance = sqrt(${ht("squareSum",y)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${A}(mean)) / ${A}(variance) * gamma[i]\n           + ${g?"beta[i]":"0.0"};\n        }\n      }`,W=[{dims:u,dataType:e[0].dataType}];return r>1&&W.push({dims:m,dataType:1}),r>2&&W.push({dims:m,dataType:1}),r>3&&W.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:R,getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(d/a/64)}})}},Rs=(e,t)=>{Gd(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Nd(e.inputs,t,e.outputCount,!1),{outputs:o})},Ps=e=>{let t=e.epsilon;return ie({epsilon:t})}});var Ud,Yr,Ld,Bs,Fd,Hd,ks,Ds,Ws=H(()=>{"use strict";De();ge();Pe();ve();Ud=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Yr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Ld=(e,t)=>{if(e.length>1){let r=Yr(e,1),o=Yr(e,2),n=Yr(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ie({starts:r,ends:o,axes:n})}else return t},Bs=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},Fd=(e,t,r,o)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Hd=(e,t)=>{let r=e[0].dims,o=k.size(r),n=t.axes.length>0?k.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=Yr(e,4);s.forEach(y=>y!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((y,S)=>Bs(y,S,r,n,s)),d=t.ends.map((y,S)=>Bs(y,S,r,n,s));if(n.length!==r.length)for(let y=0;y<r.length;++y)n.includes(y)||(u.splice(y,0,0),d.splice(y,0,r[y]),s.splice(y,0,1));let a=s.map(y=>Math.sign(y));s.forEach((y,S,A)=>{if(y<0){let R=(d[S]-u[S])/y,W=u[S],M=W+R*s[S];u[S]=M,d[S]=W,A[S]=-y}});let m=r.slice(0);n.forEach((y,S)=>{m[y]=Math.ceil((d[y]-u[y])/s[y])});let g={dims:m,dataType:e[0].dataType},x=X("output",e[0].dataType,m),b=L("input",e[0].dataType,r),w=k.size(m),v=y=>`\n      ${y.declareVariables(b,x)}\n        const signs = array<i32, ${a.length}>(${a.map(S=>`${S}i`).join(",")});\n        const starts = array<u32, ${u.length}>(${u.map(S=>`${S}u`).join(",")});\n        const ends = array<u32, ${d.length}>(${d.map(S=>`${S}u`).join(",")});\n        const steps = array<u32, ${s.length}>(${s.map(S=>`${S}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(S=>`${S}u`).join(",")});\n\n        ${Fd(b,x,r,m)}\n        ${y.mainStart()}\n          ${y.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${x.setByOffset("global_idx",b.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:v,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(o/64)}})}},ks=(e,t)=>{Ud(e.inputs,t);let r=Ld(e.inputs,t);e.compute(Hd(e.inputs,r),{inputs:[0]})},Ds=e=>{let t=e.starts,r=e.ends,o=e.axes;return ie({starts:t,ends:r,axes:o})}});var jd,Kd,zs,Vs,Gs=H(()=>{"use strict";ge();Pe();ve();jd=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Kd=(e,t)=>{let r=Me(e.dataType),o=e.dims,n=k.size(o),s=64,u=t.axis;if(u<0&&(u=o.length+u),u<o.length-1)throw new Error("softmax only supports last axis for now.");let d=o[u],a=n/d,m=lt(d),g=d/m,x=m===1?r:`vec${m}<${r}>`,b=(y,S)=>S===4?`max(max(${y}.x, ${y}.y), max(${y}.z, ${y}.w))`:S===2?`max(${y}.x, ${y}.y)`:S===3?`max(max(${y}.x, ${y}.y), ${y}.z)`:y,w=r==="f32"?`var threadMax = ${x}(-3.402823e+38f);`:`var threadMax = ${x}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:a}}),getShaderSource:y=>`\n      var<workgroup> rowMaxShared : ${x};\n      var<workgroup> rowSumShared : ${x};\n      var<workgroup> threadShared : array<${x}, ${s}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${x}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${x}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${x} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${x}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${s}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${s};\n        let row = gindex / wg;\n        let cols = ${g};\n        let row_stride : i32 = ${g};\n\n        // find the rows max\n        ${w}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${x}(${b("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${x}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${x}(${ht("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},zs=(e,t)=>{jd(e.inputs),e.compute(Kd(e.inputs[0],t))},Vs=e=>ie({axis:e.axis})});var qd,Yd,Xd,Jd,Zd,Ns,Us,Ls=H(()=>{"use strict";ge();Pe();ve();qd=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Yd=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),ie({numOutputs:o,axis:t.axis,splitSizes:r})},Xd=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Jd=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (outputNumber == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${o}) { ${n} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Zd=(e,t)=>{let r=e[0].dims,o=k.size(r),n=e[0].dataType,s=r.length,u=t.axis,d=u<0?r.length+u:u,a=new Array(t.numOutputs),m=L("input",n,r),g=new Array(t.numOutputs),x=[],b=[],w=0;for(let S=0;S<t.numOutputs;S++){w+=t.splitSizes[S],g[S]=w;let A=r.slice();A[t.axis]=t.splitSizes[S],b.push(A),a[S]=X(`output${S}`,n,b[S]),x.push({dims:b[S],dataType:e[0].dataType})}let v=s<2?"indices":`indices[${d}]`,y=S=>`\n  ${S.declareVariables(m,...a)}\n  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(A=>`${A}u`).join(",")});\n  ${Xd(g.length)}\n  ${Jd(a)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    var indices = ${m.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${v});\n    if (outputNumber != 0) {\n        ${v} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:y,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(o/64)}})}},Ns=(e,t)=>{qd(e.inputs);let r=e.inputs.length===1?t:Yd(e.inputs,t);e.compute(Zd(e.inputs,r),{inputs:[0]})},Us=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ie({axis:t,numOutputs:o,splitSizes:r})}});var Fs,Qd,ec,tc,Hs,js=H(()=>{"use strict";De();ge();ve();Fs=e=>Array.from(e.getBigInt64Array(),Number),Qd=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Fs(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ec=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},tc=e=>{let t=e[0].dims,r=Fs(e[1]),o=ec(t,r),n=k.size(o),s=e[0].dataType,u=L("input",s,t),d=X("output",s,o),a=m=>`\n      const inputShape = ${u.indices(...t)};\n      ${m.declareVariables(u,d)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      var inputIndices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${d.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};\n\n        ${u.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:a}},Hs=e=>{Qd(e.inputs),e.compute(tc(e.inputs),{inputs:[0]})}});var rc,nc,Ks,qs=H(()=>{"use strict";De();ge();ve();rc=(e,t,r,o,n)=>{let s=k.size(r),u=Math.ceil(s/4),d=X("outputData",n,r,4),a=L("aData",t[1].dataType,t[1].dims,4),m=L("bData",t[2].dataType,t[2].dims,4),g=L("cData",t[0].dataType,t[0].dims,4),x,b=(w,v,y)=>`select(${v}, ${w}, ${y})`;if(!o)x=d.setByOffset("global_idx",b(a.getByOffset("global_idx"),m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let w=(v,y,S="")=>{let A=`aData[indexA${y}][componentA${y}]`,R=`bData[indexB${y}][componentB${y}]`,W=`bool(cData[indexC${y}] & ${4278190080>>>(3-y)*8}u)`;return`\n            let outputIndices${y} = ${d.offsetToIndices(`global_idx * 4u + ${y}u`)};\n            let offsetA${y} = ${a.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let offsetB${y} = ${m.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let offsetC${y} = ${g.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let indexA${y} = offsetA${y} / 4u;\n            let indexB${y} = offsetB${y} / 4u;\n            let indexC${y} = offsetC${y} / 4u;\n            let componentA${y} = offsetA${y} % 4u;\n            let componentB${y} = offsetB${y} % 4u;\n            ${v}[${y}] = ${S}(${b(A,R,W)});\n          `};n===9?x=`\n            var data = vec4<u32>(0);\n            ${w("data",0,"u32")}\n            ${w("data",1,"u32")}\n            ${w("data",2,"u32")}\n            ${w("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:x=`\n            ${w("outputData[global_idx]",0)}\n            ${w("outputData[global_idx]",1)}\n            ${w("outputData[global_idx]",2)}\n            ${w("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(g,a,m,d)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        ${x}\n      }`},nc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(k.areEqual(t,r)&&k.areEqual(r,o)),u=t,d=k.size(t);if(s){let a=Qe.calcShape(Qe.calcShape(t,r,!1),o,!1);if(!a)throw new Error("Can\'t perform where op on the given tensors");u=a,d=k.size(u)}return{name:"Where",getShaderSource:a=>rc(a,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(d/64/4)}})}},Ks=e=>{e.compute(nc(e.inputs))}});var Ys,Xs=H(()=>{"use strict";ca();fa();ja();ni();ii();_n();wi();Si();Ii();Oi();Pi();ki();zi();Ni();Li();ji();ss();Es();Mr();_s();Ms();Ws();Gs();Ls();js();rr();In();qs();Ys=new Map([["Abs",[ma]],["Acos",[ha]],["Acosh",[ga]],["Add",[Ka]],["ArgMax",[da,Cn]],["ArgMin",[la,Cn]],["Asin",[ya]],["Asinh",[ba]],["Atan",[wa]],["Atanh",[va]],["AveragePool",[Zi,Ji]],["BiasAdd",[pa]],["BiasSplitGelu",[Ha]],["Cast",[xa,$a]],["Ceil",[Ca]],["ClipV10",[An]],["Clip",[Sa]],["Concat",[oi,ai]],["Conv",[Pn,Rn]],["ConvTranspose",[bi,yi]],["Cos",[Aa]],["Cosh",[Ia]],["Div",[qa]],["Einsum",[$i,xi]],["Elu",[Ea,kr]],["Equal",[Ya]],["Erf",[Ta]],["Exp",[Oa]],["Expand",[Ai]],["Floor",[_a]],["FusedConv",[Pn,Rn]],["Gather",[Ti,Ei]],["GatherElements",[Ri,_i]],["Gelu",[Ra]],["Gemm",[Mi,Bi]],["GlobalAveragePool",[ts,es]],["GlobalMaxPool",[is,as]],["Greater",[Qa]],["GreaterOrEqual",[ti]],["InstanceNormalization",[Wi,Di]],["LayerNormalization",[Gi,Vi]],["LeakyRelu",[Pa,kr]],["Less",[ei]],["LessOrEqual",[ri]],["Log",[Fa]],["MatMul",[Ui]],["MaxPool",[ns,os]],["Mul",[Xa]],["Neg",[Ba]],["Not",[Ma]],["Pad",[Fi,Hi]],["Pow",[Ja]],["Range",[Is]],["Reciprocal",[ka]],["ReduceMin",[ra,Ye]],["ReduceMean",[Jo,Ye]],["ReduceMax",[ta,Ye]],["ReduceSum",[oa,Ye]],["ReduceProd",[na,Ye]],["ReduceL1",[Zo,Ye]],["ReduceL2",[Qo,Ye]],["ReduceLogSum",[ia,Ye]],["ReduceLogSumExp",[ea,Ye]],["ReduceSumSquare",[aa,Ye]],["Relu",[Da]],["Resize",[Ts,Os]],["Sigmoid",[Wa]],["Sin",[za]],["Sinh",[Va]],["Slice",[ks,Ds]],["SkipLayerNormalization",[Rs,Ps]],["Split",[Ns,Us]],["Sqrt",[Ga]],["Softmax",[zs,Vs]],["Sub",[Za]],["Tan",[Na]],["Tanh",[Ua]],["ThresholdedRelu",[La,kr]],["Tile",[Hs]],["Transpose",[zo,Vo]],["Where",[Ks]]])});var Xr,Js=H(()=>{"use strict";De();mt();ve();Xr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s,u,d){let a=this.backend.device,m=this.backend.getComputePassEncoder();m.setPipeline(t.computePipeline);let g=[];for(let b of n)g.push({binding:g.length,resource:{buffer:b.buffer}});for(let b of s)g.push({binding:g.length,resource:{buffer:b.buffer}});d&&g.push({binding:g.length,resource:d});let x=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:g,label:t.programInfo.name});if(m.setBindGroup(0,x),m.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let b=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,b.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,v=this.backend.kernels.get(w),y=`[${v[0]}] ${v[1]}`;b.buffer.mapAsync(GPUMapMode.READ).then(()=>{let S=new BigUint64Array(b.buffer.getMappedRange()),A=S[0],R=S[1];b.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=A);let W=Number(A-this.backend.queryTimeBase),M=Number(R-this.backend.queryTimeBase);if(!Number.isSafeInteger(W)||!Number.isSafeInteger(M))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(b.id);let D="";r.forEach((z,F)=>{D+=`input[${F}]: [${z.dims}] | ${Qt(z.dataType)}, `});let _="";o.forEach((z,F)=>{_+=`output[${F}]: [${z.dims}] | ${Qt(z.dataType)}, `}),console.log(`[profiling] kernel "${w}|${y}" ${D}${_}execution time: ${M-W} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=ko(r),u=t.getShaderSource(s),d=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:d,label:t.name});Ee("verbose",()=>`[WebGPU] shader code: ${d}`);let m=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,d=Math.ceil(Math.sqrt(u));if(d>s){if(d=Math.ceil(Math.cbrt(u)),d>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var oc,ac,Jr,Zs=H(()=>{"use strict";mt();To();Po();Xs();Js();oc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},ac=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${oc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Jr=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Ro(this),this.programManager=new Xr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Io(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,o,n,s){let u=[];for(let A=0;A<r.length;++A){let R=this.gpuDataManager.get(r[A].data);if(!R)throw new Error(`no GPU data for input: ${r[A].data}`);u[A]=R}let d=ac(t,r),a=this.programManager.getArtifact(d),{outputs:m,dispatchGroup:g,programUniforms:x}=t.getRunData(r),b=o.length===0?m.map((A,R)=>R):o;if(b.length!==m.length)throw new Error(`Output size ${b.length} must be equal to ${m.length}.`);let w=[],v=[];for(let A=0;A<m.length;++A){if(!Number.isInteger(b[A])||b[A]<-3||b[A]>=m.length)throw new Error(`Invalid output index: ${b[A]}`);if(b[A]===-3)continue;let R=b[A]===-1,W=b[A]===-2,M=R||W?s(m[A].dataType,m[A].dims):n(b[A],m[A].dataType,m[A].dims),D=this.gpuDataManager.get(M.data);if(!D)throw new Error(`no GPU data for output: ${M.data}`);if(R&&this.temporaryData.push(D),W){let _=this.kernelPersistentData.get(this.currentKernelId);_||(_=[],this.kernelPersistentData.set(this.currentKernelId,_)),_.push(D)}w.push(M),v.push(D)}let y;if(x){let A=0,R=0,W=[],M=1;x.forEach(z=>{let F=typeof z.data=="number"?[z.data]:z.data,q;switch(F.length){case 1:q=4;break;case 2:q=8;break;case 3:q=16;break;case 4:q=16;break;case 5:q=16;break;case 6:q=16;break;default:throw new Error(`unsupported data length: ${F.length}`)}(R===5||R===6)&&(q=16),q>M&&(M=q),A=Math.ceil(A/q)*q,R=F.length,W.push(A),A+=F.length*4}),A=Math.ceil(A/M)*M;let D=new ArrayBuffer(A);x.forEach((z,F)=>{let q=W[F],le=typeof z.data=="number"?[z.data]:z.data;z.type==="int32"?new Int32Array(D,q,le.length).set(le):z.type==="uint32"?new Uint32Array(D,q,le.length).set(le):new Float32Array(D,q,le.length).set(le)});let _=this.gpuDataManager.create(A,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(_.buffer,0,D,0,A),this.gpuDataManager.release(_.id),y={offset:0,size:A,buffer:_.buffer}}let S=this.programManager.normalizeDispatchGroupSize(g);return a||(a=this.programManager.build(t,S),this.programManager.setArtifact(d,a)),Ee("info",()=>`[ProgramManager] run "${t.name}" (key=${d}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(a,r,w,u,v,S,y),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=Ys.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,d,a]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Ee("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),d(r,a[1]),0}catch(g){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${g}`)),1}finally{m&&o.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${s}] ${u}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),d=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await yn(this,t,r);return Eo(n.buffer,o)}}}});var Qs={};Ir(Qs,{init:()=>ic});var sr,zn,ic,eu=H(()=>{"use strict";De();Zs();mt();ge();sr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(k.size(t)!==k.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},zn=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let d=[];for(let a=0;a<u;a++){let m=n[s++],g=n[s++],x=n[s++],b=[];for(let w=0;w<x;w++)b.push(n[s++]);d.push(new sr(t,m,g,b))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,n=r?.outputs??[],s=(d,a,m)=>new sr(this.module,a,this.output(d,m),m),u=(d,a)=>{let m=er(d);if(!m)throw new Error(`Unsupported data type: ${d}`);let g=m*k.size(a);return new sr(this.module,d,this.backend.gpuDataManager.create(g).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},ic=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new Jr;await o.initialize(t),r(o,n=>o.alloc(n),n=>o.free(n),(n,s,u,d=!1)=>{if(d)Ee("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),o.memcpy(n,s);else{Ee("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let a=e.HEAPU8.subarray(n,n+u);o.upload(s,a)}},async(n,s,u)=>{Ee("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await o.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>o.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>o.releaseKernel(n),(n,s,u,d)=>{Ee("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let a=new zn(e,o,s);return o.computeKernel(n,a,d)})}}});var wo;wo=uo();var Ru=go(),pn,fn=!1,Er=!1,bo=!1,Pu=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Mu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Bu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",vo=async e=>{if(fn)return Promise.resolve();if(Er)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(bo)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Er=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=r>1&&Pu(),s=o&&Mu(),u=e.wasmPaths,d=typeof u=="string"?u:void 0,a=Bu(s,n),m=typeof u=="object"?u[a]:void 0,g=!1,x=[];if(t>0&&x.push(new Promise(b=>{setTimeout(()=>{g=!0,b()},t)})),x.push(new Promise((b,w)=>{let v=n?Ru:wo,y={locateFile:(S,A)=>{if(n&&S.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([yo()],{type:"text/javascript"}));if(S.endsWith(".wasm")){if(m)return m;let R=d??A;return a==="ort-wasm-simd.wasm"?R+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?R+"ort-wasm-simd-threaded.jsep.wasm":R+a}return A+S}};if(n)if(typeof Blob>"u")y.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let S=`var ortWasmThreaded=${v.toString()};`;y.mainScriptUrlOrBlob=new Blob([S],{type:"text/javascript"})}v(y).then(S=>{Er=!1,fn=!0,pn=S,b()},S=>{Er=!1,bo=!0,w(S)})})),await Promise.race(x),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(fn&&pn)return pn;throw new Error("WebAssembly is not initialized yet.")};var Be=(e,t)=>{let r=Re(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},Zt=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")Zt(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ae=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var $o=e=>{let t=Re(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Be(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&Zt(e.extra,"",new WeakSet,(u,d)=>{let a=Be(u,o),m=Be(d,o);t._OrtAddRunConfigEntry(r,a,m)!==0&&Ae(`Can\'t set a run config entry: ${u} - ${d}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var ku=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Du=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Wu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},zu=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let d=Be("deviceType",r),a=Be(u.deviceType,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.powerPreference){let d=Be("powerPreference",r),a=Be(u.powerPreference,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let d=Be("preferredLayout",r),a=Be(u.preferredLayout,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Be(n,r);Re()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can\'t append execution provider: ${n}.`)}},xo=e=>{let t=Re(),r=0,o=[],n=e||{};Wu(n);try{let s=ku(n.graphOptimizationLevel??"all"),u=Du(n.executionMode??"sequential"),d=typeof n.logId=="string"?Be(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let m=n.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let g=typeof n.optimizedModelFilePath=="string"?Be(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,d,a,m,g),r===0&&Ae("Can\'t create session options."),n.executionProviders&&zu(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[x,b]of Object.entries(n.freeDimensionOverrides)){if(typeof x!="string")throw new Error(`free dimension override name must be a string: ${x}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let w=Be(x,o);t._OrtAddFreeDimensionOverride(r,w,b)!==0&&Ae(`Can\'t set a free dimension override: ${x} - ${b}.`)}return n.extra!==void 0&&Zt(n.extra,"",new WeakSet,(x,b)=>{let w=Be(x,o),v=Be(b,o);t._OrtAddSessionConfigEntry(r,w,v)!==0&&Ae(`Can\'t set a session config entry: ${x} - ${b}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};De();var ru=!1,sc=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},uc=(e,t)=>{Re()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},nu=async e=>{uc(e.wasm.numThreads,tr(e.logLevel));{let t=(eu(),Mt(Qs)).init;await t(Re(),e)}ru=!0},ur=new Map,ou=()=>ru,Vn=e=>{let t=Re(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Gn=(e,t)=>{let r=Re(),o=0,n=0,s=0,u=[],d=[],a=[];try{[n,u]=xo(t),o=r._OrtCreateSession(e[0],e[1],n),o===0&&Ae("Can\'t create a session.");let[m,g]=sc(o),x=[],b=[],w=[];for(let y=0;y<m;y++){let S=r._OrtGetInputName(o,y);S===0&&Ae("Can\'t get an input name."),d.push(S),x.push(r.UTF8ToString(S))}for(let y=0;y<g;y++){let S=r._OrtGetOutputName(o,y);S===0&&Ae("Can\'t get an output name."),a.push(S);let A=r.UTF8ToString(S);b.push(A);{let R=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[A]??"cpu";if(R!=="cpu"&&R!=="cpu-pinned"&&R!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${R}.`);w.push(R)}}let v=null;return w.some(y=>y==="gpu-buffer")&&(s=r._OrtCreateBinding(o),s===0&&Ae("Can\'t create IO binding."),v={handle:s,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(y=>hn(y))}),ur.set(o,[o,d,a,v]),[o,x,b]}catch(m){throw d.forEach(g=>r._OrtFree(g)),a.forEach(g=>r._OrtFree(g)),s!==0&&r._OrtReleaseBinding(s),o!==0&&r._OrtReleaseSession(o),m}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(m=>r._free(m))}},au=(e,t)=>{let r=Vn(e);return Gn(r,t)},iu=e=>{let t=Re(),r=ur.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),ur.delete(e)},tu=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=Re(),u=e[0],d=e[1],a=e[3],m,g;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let w=e[2].gpuBuffer,v=er(mn(u));g=d.reduce((y,S)=>y*S,1)*v,m=s.jsepRegisterBuffer(o,n,w,g)}else{let w=e[2];if(Array.isArray(w)){g=4*w.length,m=s._malloc(g),r.push(m);let v=m/4;for(let y=0;y<w.length;y++){if(typeof w[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);s.HEAPU32[v++]=Be(w[y],r)}}else g=w.byteLength,m=s._malloc(g),r.push(m),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,g),m)}let x=s.stackSave(),b=s.stackAlloc(4*d.length);try{let w=b/4;d.forEach(y=>s.HEAP32[w++]=y);let v=s._OrtCreateTensor(mn(u),m,g,b,d.length,hn(a));v===0&&Ae(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push(v)}finally{s.stackRestore(x)}},su=async(e,t,r,o,n,s)=>{let u=Re(),d=ur.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,m,g,x]=d,b=t.length,w=o.length,v=0,y=[],S=[],A=[],R=[],W=u.stackSave(),M=u.stackAlloc(b*4),D=u.stackAlloc(b*4),_=u.stackAlloc(w*4),z=u.stackAlloc(w*4);try{[v,y]=$o(s);for(let ae=0;ae<b;ae++)tu(r[ae],S,R,e,t[ae]);for(let ae=0;ae<w;ae++)tu(n[ae],A,R,e,b+o[ae]);let F=M/4,q=D/4,le=_/4,B=z/4;for(let ae=0;ae<b;ae++)u.HEAPU32[F++]=S[ae],u.HEAPU32[q++]=m[t[ae]];for(let ae=0;ae<w;ae++)u.HEAPU32[le++]=A[ae],u.HEAPU32[B++]=g[o[ae]];if(x){let{handle:ae,outputPreferredLocations:we,outputPreferredLocationsEncoded:j}=x;if(m.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${m.length}).`);for(let Se=0;Se<b;Se++){let Oe=t[Se];await u._OrtBindInput(ae,m[Oe],S[Se])!==0&&Ae(`Can\'t bind input[${Se}] for session=${e}.`)}for(let Se=0;Se<w;Se++){let Oe=o[Se];n[Se]?.[3]?u._OrtBindOutput(ae,g[Oe],A[Se],0)!==0&&Ae(`Can\'t bind pre-allocated output[${Se}] for session=${e}.`):u._OrtBindOutput(ae,g[Oe],0,j[Oe])!==0&&Ae(`Can\'t bind output[${Se}] to ${we[Se]} for session=${e}.`)}}let K;x?K=await u._OrtRunWithBinding(a,x.handle,w,_,v):K=await u._OrtRun(a,D,M,b,z,w,_,v),K!==0&&Ae("failed to call OrtRun().");let xe=[];for(let ae=0;ae<w;ae++){let we=u.HEAPU32[_/4+ae];if(we===A[ae]){xe.push(n[ae]);continue}let j=u.stackSave(),Se=u.stackAlloc(4*4),Oe=!1,Ie,Ce=0;try{u._OrtGetTensorData(we,Se,Se+4,Se+8,Se+12)!==0&&Ae(`Can\'t access output tensor data on index ${ae}.`);let Ne=Se/4,Le=u.HEAPU32[Ne++];Ce=u.HEAPU32[Ne++];let N=u.HEAPU32[Ne++],de=u.HEAPU32[Ne++],pe=[];for(let Te=0;Te<de;Te++)pe.push(u.HEAPU32[N/4+Te]);u._OrtFree(N);let ze=pe.reduce((Te,ke)=>Te*ke,1);Ie=Qt(Le);let Ue=x?.outputPreferredLocations[o[ae]];if(Ie==="string"){if(Ue==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Te=[],ke=Ce/4;for(let Ge=0;Ge<ze;Ge++){let Xe=u.HEAPU32[ke++],Fe=Ge===ze-1?void 0:u.HEAPU32[ke]-Xe;Te.push(u.UTF8ToString(Xe,Fe))}xe.push([Ie,pe,Te,"cpu"])}else if(Ue==="gpu-buffer"&&ze>0){let Te=u.jsepGetBuffer(Ce),ke=er(Le);if(ke===void 0||!So(Ie))throw new Error(`Unsupported data type: ${Ie}`);Oe=!0,xe.push([Ie,pe,{gpuBuffer:Te,download:u.jsepCreateDownloader(Te,ze*ke,Ie),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Te=Tr(Ie),ke=new Te(ze);new Uint8Array(ke.buffer,ke.byteOffset,ke.byteLength).set(u.HEAPU8.subarray(Ce,Ce+ke.byteLength)),xe.push([Ie,pe,ke,"cpu"])}}finally{u.stackRestore(j),Ie==="string"&&Ce&&u._free(Ce),Oe||u._OrtReleaseTensor(we)}}return x&&u._OrtClearBoundOutputs(x.handle),xe}finally{u.stackRestore(W),S.forEach(F=>u._OrtReleaseTensor(F)),A.forEach(F=>u._OrtReleaseTensor(F)),R.forEach(F=>u._free(F)),v!==0&&u._OrtReleaseRunOptions(v),y.forEach(F=>u._free(F))}},uu=e=>{let t=Re(),r=ur.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Ae("Can\'t get an profile file name."),t._OrtFree(n)},lu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{vo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{nu(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=Vn(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,o=Gn(t,r);postMessage({type:"create_finalize",out:o})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,o=au(t,r);postMessage({type:"create",out:o})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;iu(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:o,outputIndices:n,options:s}=e.data.in;su(t,r,o,n,s).then(u=>{postMessage({type:"run",out:u},lu(u))},u=>{postMessage({type:"run",err:u})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;uu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=ou();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'})),Nu=P((()=>{re(),zu(),Vo(),au=()=>!!c.wasm.proxy&&typeof document<"u",ou=!1,su=!1,uu=!1,cu=[],pu=[],fu=[],hu=[],mu=[],gu=[],yu=[],wu=()=>{if(ou||!su||uu||!iu)throw new Error("worker not ready")},$u=e=>{switch(e.data.type){case"init-wasm":ou=!1,e.data.err?(uu=!0,lu[1](e.data.err)):(su=!0,lu[0]());break;case"init-ort":e.data.err?du[1](e.data.err):du[0]();break;case"create_allocate":e.data.err?cu.shift()[1](e.data.err):cu.shift()[0](e.data.out);break;case"create_finalize":e.data.err?pu.shift()[1](e.data.err):pu.shift()[0](e.data.out);break;case"create":e.data.err?fu.shift()[1](e.data.err):fu.shift()[0](e.data.out);break;case"release":e.data.err?hu.shift()[1](e.data.err):hu.shift()[0]();break;case"run":e.data.err?mu.shift()[1](e.data.err):mu.shift()[0](e.data.out);break;case"end-profiling":e.data.err?gu.shift()[1](e.data.err):gu.shift()[0]();break;case"is-ort-env-initialized":e.data.err?yu.shift()[1](e.data.err):yu.shift()[0](e.data.out)}},vu=typeof document<"u"?document?.currentScript?.src:void 0,bu=async()=>{if(au()){if(su)return;if(ou)throw new Error("multiple calls to 'initWasm()' detected.");if(uu)throw new Error("previous call to 'initWasm()' failed.");return ou=!0,void 0===c.wasm.wasmPaths&&vu&&0!==vu.indexOf("blob:")&&(c.wasm.wasmPaths=vu.substr(0,+vu.lastIndexOf("/")+1)),new Promise(((e,t)=>{iu?.terminate();let n=URL.createObjectURL(new Blob([Wu()],{type:"text/javascript"}));(iu=new Worker(n,{name:"ort-wasm-proxy-worker"})).onerror=e=>t(e),iu.onmessage=$u,URL.revokeObjectURL(n),lu=[e,t];let r={type:"init-wasm",in:c.wasm};iu.postMessage(r)}))}return _e(c.wasm)},xu=async e=>{if(au())return wu(),new Promise(((t,n)=>{du=[t,n];let r={type:"init-ort",in:e};iu.postMessage(r)}));await qs(e)},Su=async e=>au()?(wu(),new Promise(((t,n)=>{cu.push([t,n]);let r={type:"create_allocate",in:{model:e}};iu.postMessage(r,[e.buffer])}))):Xs(e),_u=async(e,t)=>au()?(wu(),new Promise(((n,r)=>{pu.push([n,r]);let a={type:"create_finalize",in:{modeldata:e,options:t}};iu.postMessage(a)}))):Js(e,t),Cu=async(e,t)=>{if(au()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return wu(),new Promise(((n,r)=>{fu.push([n,r]);let a={type:"create",in:{model:e,options:t}};iu.postMessage(a,[e.buffer])}))}return Qs(e,t)},Eu=async e=>{if(au())return wu(),new Promise(((t,n)=>{hu.push([t,n]);let r={type:"release",in:e};iu.postMessage(r)}));Zs(e)},Iu=async(e,t,n,r,a,i)=>{if(au()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return wu(),new Promise(((a,o)=>{mu.push([a,o]);let s=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:s,outputIndices:r,options:i}};iu.postMessage(u,ru(s))}))}return tu(e,t,n,r,a,i)},Au=async e=>{if(au())return wu(),new Promise(((t,n)=>{gu.push([t,n]);let r={type:"end-profiling",in:e};iu.postMessage(r)}));nu(e)},Ou=async()=>au()?(wu(),new Promise(((e,t)=>{yu.push([e,t]),iu.postMessage({type:"is-ort-env-initialized"})}))):Ks()})),Gu=P((()=>{re(),Nu(),Lo(),Ru=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},ku=e=>{switch(e[3]){case"cpu":return new E(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Ge(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:a}=e[2];return E.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},Bu=class{async createSessionAllocate(e){let t=await fetch(e);if(200!==t.status)throw new Error(`failed to load model: ${e}`);let n=await t.arrayBuffer();return Su(new Uint8Array(n))}async loadModel(e,t){if(await Ou()||(Tu||(Tu=xu(c)),await Tu,Tu=void 0),"string"==typeof e)if(typeof process<"u"&&process.versions&&process.versions.node){let n=await(void 0)(e);[this.sessionId,this.inputNames,this.outputNames]=await Cu(n,t)}else{let n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await _u(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await Cu(e,t)}async dispose(){return Eu(this.sessionId)}async run(e,t,n){let r=[],a=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],i=this.inputNames.indexOf(t);if(-1===i)throw new Error(`invalid input '${t}'`);r.push(n),a.push(i)}));let i=[],o=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output '${t}'`);i.push(n),o.push(r)}));let s=r.map(((e,t)=>Ru(e,(()=>`input "${this.inputNames[a[t]]}"`)))),u=i.map(((e,t)=>e?Ru(e,(()=>`output "${this.outputNames[o[t]]}"`)):null)),l=await Iu(this.sessionId,a,s,o,u,n),d={};for(let e=0;e<l.length;e++)d[this.outputNames[o[e]]]=i[e]??ku(l[e]);return d}startProfiling(){}endProfiling(){Au(this.sessionId)}}})),Uu=P((()=>{re(),Nu(),Gu(),Mu=()=>{if(("number"!=typeof c.wasm.initTimeout||c.wasm.initTimeout<0)&&(c.wasm.initTimeout=0),"boolean"!=typeof c.wasm.simd&&(c.wasm.simd=!0),"boolean"!=typeof c.wasm.proxy&&(c.wasm.proxy=!1),"number"!=typeof c.wasm.numThreads||!Number.isInteger(c.wasm.numThreads)||c.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;c.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Du=class{async init(){Mu(),await bu()}async createInferenceSessionHandler(e,t){let n=new Bu;return await n.loadModel(e,t),Promise.resolve(n)}}})),Vu={};W(Vu,{wasmBackend:()=>ju});var ju,Fu=P((()=>{Uu(),ju=new Du})),Hu={};W(Hu,{InferenceSession:()=>A,Tensor:()=>E,TrainingSession:()=>T,default:()=>Lu,env:()=>c,registerBackend:()=>o}),e.exports=N(Hu),re(),re(),re();var Lu=ne;{let e=(Fu(),N(Vu)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&o("webgpu",e,5),o("cpu",e,10),o("wasm",e,10),o("xnnpack",e,9),o("webnn",e,9)}Object.defineProperty(c.versions,"web",{value:"1.17.0-dev.20231103-1439da36fe",enumerable:!0})}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}return n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{const e=n(122),t=28,r=28,a={sam_b:["models/mnist_cnn.onnx"]},i=function(){var e={model:"sam_b",provider:"webgpu",device:"gpu",threads:"1"};let t=window.location.search.substring(1).split("&");for(var n=0;n<t.length;n++){let r=t[n].split("=");if(r[0]in e)e[r[0]]=decodeURIComponent(r[1]);else if(r[0].length>0)throw new Error("unknown argument: "+r[0])}return e.threads=parseInt(e.threads),e}();let o,s;var u;e.env.wasm.numThreads=i.threads,e.env.wasm.proxy=!0;var l,d=[];function c(e){document.getElementById("status").innerText+=`\n[${performance.now().toFixed(3)}] `+e,console.log(e)}async function p(n){return n=await e.Tensor.fromImage(n,options={resizedWidth:t,resizedHeight:r}),n=await async function(t){const n=t.data,r=new e.Tensor(n.slice(0,784),[1,1,28,28]);return c(`reshapedTensor is ${r.dims}`),r}(n),await async function(e){return isWhite=await async function(e,t=.3){var n=0;const r=e.data;for(let e=0;e<r.length;e++)1==r[e]&&(n+=1);var a=n/784;return c(`percent whitenesss is ${a}; count is ${n}; ${e.dims}`),a>=t}(e),1==isWhite?(c("yaay! image is white background; gotta invert!"),e=await async function(e){const t=e.data;for(let e=0;e<t.length;e++)t[e]=1-t[e];return e}(e)):(c("noo! img is NOT white background"),e)}(n)}document.addEventListener("DOMContentLoaded",(()=>{!async function(){const t=a[i.model];o=document.getElementById("img_canvas"),s=document.getElementById("file-in");let n=document.getElementById("original-image");console.log("[debug] BEFORE model loading..."),async function(t,n,r){let a=i.provider;switch(a){case"webnn":if(!("ml"in navigator))throw new Error("webnn is NOT supported");a={name:"webnn",deviceType:i.device,powerPreference:"default"};break;case"webgpu":if(!navigator.gpu)throw new Error("webgpu is NOT supported")}const o={executionProviders:[a]};c(`[load_model] idx is what? ${n}`),async function(e){try{const t=await caches.open("onnx");i.clear_cache&&t.delete(e);let n=await t.match(e);return null==n?(await t.add(e),n=await t.match(e),c(`${e} (from network)`)):c(`${e} (from cache)`),await n.arrayBuffer()}catch(t){return c(`${e} (from network)`),await fetch(e).then((e=>e.arrayBuffer()))}}(t[n]).then((a=>{d[n]=e.InferenceSession.create(a,o),d[n].then((()=>{c(`${t[n]} loaded. yoy`),0==n&&c("[load_model] idx is 0; so going for next recursion of model")}),(e=>{throw c(`${t[n]} failed with ${e}.`),e})),c(void 0!==r?"img is undefined!":"img is not undefined!")}))}(t,0,n).then((()=>{}),(e=>{c(e)})),console.log("[debug] model loaded; sess:",d),s.onchange=function(e){let t=(e.target||window.event.src).files;if(FileReader&&t&&t.length){let e=new FileReader;e.onload=()=>{n.onload=()=>async function(e){const t=document.getElementById("prediction-element");s.disabled=!0;const n=document.createElement("canvas");n.style.cursor="wait",u=void 0;var r=e.width,a=e.height;r>a?r>28&&(a*=28/r,r=28):a>28&&(r*=28/a,a=28),r=Math.round(r),a=Math.round(a),n.width=r,n.height=a;var i=n.getContext("2d");console.log(`[handleImage] img.height: ${e.height}### img.width: ${e.width}`),i.drawImage(e,0,0,r,a),l=i.getImageData(0,0,r,a);const o=await p(l);c(`###imgTensor.dims is this: ${o.dims}###`),c(`###imgTensor sample is this: ${o.data.slice(110,119)}###`);const f={"input.1":o},h=await d[0];performance.now(),console.log("[debug] s:",h),u=await h.run(f);const m=await async function(e){for(key in e)c(`object[${key}]: ${e[key]}`);return e[key]}(u);probs=m.cpuData,max_prob=Math.max(...probs),maxInd=probs.indexOf(max_prob),t.innerText=`Class: ${maxInd}###Probabilities: ${probs}###`,s.disabled=!1}(n),n.src=e.result},e.readAsDataURL(t[0])}}}()}))})(),{}})()));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxhQUFhWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxXQUFXWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxXQUFXWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxlQUFlWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxrQkFBa0JYLEVBQUUsQ0FBQ21JLFdBQVdsSSxFQUFFbUksb0JBQW9CakksRUFBRWtJLEtBQUtqSSxFQUFFbEUsTUFBTWQsS0FBS2tLLEVBQUVnRCxTQUFTakksSUFBSSxFQUFFQSxFQUFFRCxJQUFJLElBQUksSUFBRyxFQUFHLE9BQU8sQ0FBQ0osRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsS0FBSzNMLEVBQUVpTSxHQUFHLGtCQUFrQlgsRUFBRSxDQUFDbUksV0FBV2xJLEVBQUVtSSxvQkFBb0JqSSxFQUFFa0ksS0FBS2pJLEVBQUVsRSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNqSSxJQUFJLEVBQUVBLEVBQUVELElBQUksSUFBSSxJQUFHLEVBQUcsT0FBT0osSUFBSXRMLEVBQUVpTSxHQUFHLFFBQVFYLE9BQUUsRUFBTSxFQUFHLE9BQU8sQ0FBQ0EsRUFBRUMsRUFBRUUsS0FBS3pMLEVBQUVpTSxHQUFHLFlBQVlYLEVBQUUsQ0FBQ3VJLEtBQUt0SSxFQUFFL0QsTUFBTWQsS0FBS2tLLEVBQUVnRCxTQUFTbkksSUFBSSxFQUFFQSxFQUFFRixJQUFJLElBQUksSUFBRyxFQUFHLE9BQU8sQ0FBQ0QsRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBR00sRUFBRUMsRUFBRUMsRUFBRUMsRUFBR0MsRUFBR0UsRUFBRUMsS0FBTTNNLEVBQUVpTSxHQUFHLGdCQUFnQlgsRUFBRSxDQUFDbkksT0FBT2lKLEVBQUUsT0FBTyxPQUFPMEgsUUFBUXZJLEVBQUV3SSxVQUFVLENBQUN0SSxHQUFHdUksTUFBTXRJLEVBQUV1SSxhQUFhLENBQUN0SSxHQUFHdUksS0FBSyxDQUFDdEksRUFBRUMsR0FBR3NJLFFBQVEsQ0FBQ3JJLEdBQUlzSSxTQUFTLE1BQU0xRCxFQUFFckUsSUFBSSxHQUFHZ0ksY0FBYy9ILEVBQUU5RSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNySCxJQUFLLEVBQUVBLEVBQUdELElBQUksSUFBSSxHQUFHZ0ksWUFBWTlILEVBQUdoRixNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNsSCxJQUFJLEVBQUVBLEVBQUVGLElBQUssSUFBSSxHQUFHK0gsV0FBV0MsR0FBRzdILElBQUksRUFBRyxPQUFPLENBQUNyQixFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHTSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHQyxFQUFHRSxLQUFLMU0sRUFBRWlNLEdBQUcsZ0JBQWdCWCxFQUFFLENBQUNuSSxPQUFPMkksRUFBRyxPQUFPLE9BQU9nSSxRQUFRdkksRUFBRXdJLFVBQVV2TSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNuSSxJQUFJLEVBQUVBLEVBQUUsSUFBSSxJQUFJdUksTUFBTXRJLEVBQUUrSSxZQUFZak4sTUFBTWQsS0FBS2tLLEVBQUVnRCxTQUFTakksSUFBSSxFQUFFQSxFQUFFLElBQUksSUFBSXVJLEtBQUsxTSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNoSSxJQUFJLEVBQUVBLEVBQUUsSUFBSSxJQUFJdUksUUFBUTNNLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBUy9ILElBQUksRUFBRUEsRUFBRSxJQUFJLElBQUl1SSxTQUFTLE1BQU0xRCxFQUFFdEUsSUFBSSxHQUFHaUksY0FBYyxFQUFFaEksRUFBRTdFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU3RILElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLEdBQUdpSSxZQUFZLEVBQUUvSCxFQUFHL0UsTUFBTWQsS0FBS2tLLEVBQUVnRCxTQUFTcEgsSUFBSyxFQUFFQSxFQUFHRCxJQUFLLElBQUksR0FBR2dJLFdBQVdDLEdBQUc5SCxJQUFHLEVBQUcsT0FBTyxDQUFDcEIsRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBR00sRUFBRUMsRUFBRUMsRUFBRUMsRUFBR0MsRUFBR0UsRUFBRUMsS0FBTTNNLEVBQUVpTSxHQUFHLGdCQUFnQlgsRUFBRSxDQUFDbkksT0FBT2lKLEVBQUUsT0FBTyxPQUFPMEgsUUFBUXZJLEVBQUV3SSxVQUFVLENBQUN0SSxHQUFHdUksTUFBTXRJLEVBQUV1SSxhQUFhLENBQUN0SSxHQUFHdUksS0FBSyxDQUFDdEksRUFBRUMsR0FBR3NJLFFBQVEsQ0FBQ3JJLEdBQUlzSSxTQUFTLE1BQU0xRCxFQUFFckUsSUFBSSxHQUFHZ0ksY0FBYy9ILEVBQUU5RSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNySCxJQUFLLEVBQUVBLEVBQUdELElBQUksSUFBSSxHQUFHZ0ksWUFBWTlILEVBQUdoRixNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNsSCxJQUFJLEVBQUVBLEVBQUVGLElBQUssSUFBSSxHQUFHK0gsV0FBV0MsR0FBRzdILElBQUksRUFBRyxPQUFPLENBQUNyQixFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHTSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHQyxFQUFHRSxLQUFLMU0sRUFBRWlNLEdBQUcsZ0JBQWdCWCxFQUFFLENBQUNuSSxPQUFPMkksRUFBRyxPQUFPLE9BQU9nSSxRQUFRdkksRUFBRXdJLFVBQVV2TSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNuSSxJQUFJLEVBQUVBLEVBQUUsSUFBSSxJQUFJdUksTUFBTXRJLEVBQUUrSSxZQUFZak4sTUFBTWQsS0FBS2tLLEVBQUVnRCxTQUFTakksSUFBSSxFQUFFQSxFQUFFLElBQUksSUFBSXVJLEtBQUsxTSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNoSSxJQUFJLEVBQUVBLEVBQUUsSUFBSSxJQUFJdUksUUFBUTNNLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBUy9ILElBQUksRUFBRUEsRUFBRSxJQUFJLElBQUl1SSxTQUFTLE1BQU0xRCxFQUFFdEUsSUFBSSxHQUFHaUksY0FBYyxFQUFFaEksRUFBRTdFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU3RILElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLEdBQUdpSSxZQUFZLEVBQUUvSCxFQUFHL0UsTUFBTWQsS0FBS2tLLEVBQUVnRCxTQUFTcEgsSUFBSyxFQUFFQSxFQUFHRCxJQUFLLElBQUksR0FBR2dJLFdBQVdDLEdBQUc5SCxJQUFHLEVBQUcsT0FBTyxDQUFDcEIsRUFBRUMsS0FBS3ZMLEVBQUVpTSxHQUFHLG9CQUFvQlgsRUFBRSxDQUFDbkksT0FBT29JLEVBQUUsT0FBTyxRQUFPLEVBQUcsT0FBTyxDQUFDRCxFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHTSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHQyxFQUFHRSxFQUFFQyxFQUFHK0gsS0FBTTFVLEVBQUVpTSxHQUFHLGNBQWNYLEVBQUUsQ0FBQ25JLE9BQU91UixFQUFHLE9BQU8sT0FBT0MsU0FBU3BKLEVBQUVxSixVQUFVbkosRUFBRW9KLGtCQUFrQm5KLEVBQUVvSixjQUFjbkosRUFBRW9JLFVBQVUsQ0FBQ25JLEVBQUVDLEdBQUdvSSxhQUFhLENBQUNuSSxFQUFHTSxHQUFHOEgsS0FBSyxDQUFDN0gsRUFBRUMsRUFBRUMsRUFBR0MsR0FBSTJILFFBQVEsQ0FBQ3pILEVBQUVDLElBQUksRUFBRyxPQUFPLENBQUNyQixFQUFFQyxLQUFLdkwsRUFBRWlNLEdBQUcsb0JBQW9CWCxFQUFFLENBQUNuSSxPQUFPb0ksRUFBRSxPQUFPLFFBQU8sRUFBRyxPQUFPLENBQUNELEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUdNLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUdDLEVBQUdFLEVBQUVDLEVBQUcrSCxLQUFNMVUsRUFBRWlNLEdBQUcsY0FBY1gsRUFBRSxDQUFDbkksT0FBT3VSLEVBQUcsT0FBTyxPQUFPQyxTQUFTcEosRUFBRXFKLFVBQVVuSixFQUFFb0osa0JBQWtCbkosRUFBRW9KLGNBQWNuSixFQUFFb0ksVUFBVSxDQUFDbkksRUFBRUMsR0FBR29JLGFBQWEsQ0FBQ25JLEVBQUdNLEdBQUc4SCxLQUFLLENBQUM3SCxFQUFFQyxFQUFFQyxFQUFHQyxHQUFJMkgsUUFBUSxDQUFDekgsRUFBRUMsSUFBSSxFQUFHLE9BQU8sQ0FBQ3JCLEVBQUVDLEtBQUt2TCxFQUFFaU0sR0FBRyxnQkFBZ0JYLEVBQUUsQ0FBQ25JLE9BQU9vSSxFQUFFLE9BQU8sUUFBTyxFQUFHLE9BQU8sQ0FBQ0QsRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBR00sRUFBRUMsRUFBRUMsRUFBRUMsRUFBR0MsRUFBR0UsRUFBRUMsRUFBRytILEtBQU0xVSxFQUFFaU0sR0FBRyxVQUFVWCxFQUFFLENBQUNuSSxPQUFPdVIsRUFBRyxPQUFPLE9BQU9DLFNBQVNwSixFQUFFcUosVUFBVW5KLEVBQUVvSixrQkFBa0JuSixFQUFFb0osY0FBY25KLEVBQUVvSSxVQUFVLENBQUNuSSxFQUFFQyxHQUFHb0ksYUFBYSxDQUFDbkksRUFBR00sR0FBRzhILEtBQUssQ0FBQzdILEVBQUVDLEVBQUVDLEVBQUdDLEdBQUkySCxRQUFRLENBQUN6SCxFQUFFQyxJQUFJLEVBQUcsT0FBTyxDQUFDckIsRUFBRUMsS0FBS3ZMLEVBQUVpTSxHQUFHLGdCQUFnQlgsRUFBRSxDQUFDbkksT0FBT29JLEVBQUUsT0FBTyxRQUFPLEVBQUcsT0FBTyxDQUFDRCxFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHTSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHQyxFQUFHRSxFQUFFQyxFQUFHK0gsS0FBTTFVLEVBQUVpTSxHQUFHLFVBQVVYLEVBQUUsQ0FBQ25JLE9BQU91UixFQUFHLE9BQU8sT0FBT0MsU0FBU3BKLEVBQUVxSixVQUFVbkosRUFBRW9KLGtCQUFrQm5KLEVBQUVvSixjQUFjbkosRUFBRW9JLFVBQVUsQ0FBQ25JLEVBQUVDLEdBQUdvSSxhQUFhLENBQUNuSSxFQUFHTSxHQUFHOEgsS0FBSyxDQUFDN0gsRUFBRUMsRUFBRUMsRUFBR0MsR0FBSTJILFFBQVEsQ0FBQ3pILEVBQUVDLElBQUksRUFBRyxPQUFPLENBQUNyQixFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxLQUFLM0wsRUFBRWlNLEdBQUcsT0FBT1gsRUFBRSxDQUFDa0ksTUFBTWpJLEVBQUV3SixLQUFLdEosRUFBRXVKLE9BQU90SixFQUFFdUosT0FBT3RKLEdBQUUsRUFBRyxPQUFPTCxJQUFJdEwsRUFBRWlNLEdBQUcsU0FBU1gsT0FBRSxFQUFNLEVBQUcsT0FBTyxDQUFDQSxFQUFFQyxFQUFFRSxFQUFFQyxLQUFLMUwsRUFBRWlNLEdBQUcsU0FBU1gsRUFBRSxDQUFDbUksV0FBV2xJLEVBQUUySixrQkFBa0J6SixFQUFFMEosS0FBS3pKLEdBQUUsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEtBQUsxTCxFQUFFaU0sR0FBRyxTQUFTWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRTJKLGtCQUFrQnpKLEVBQUUwSixLQUFLekosR0FBRSxFQUFHLE9BQU8sQ0FBQ0osRUFBRUMsS0FBS3ZMLEVBQUVpTSxHQUFHLFVBQVVYLEVBQUUsQ0FBQzZKLEtBQUs1SixHQUFFLEVBQUcsT0FBTyxDQUFDRCxFQUFFQyxLQUFLdkwsRUFBRWlNLEdBQUcsU0FBU1gsRUFBRSxDQUFDNkosS0FBSzVKLEdBQUUsRUFBRyxPQUFPLENBQUNELEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxRQUFRWCxFQUFFLENBQUM2SixLQUFLNUosRUFBRTZKLFdBQVczSixFQUFFNEosV0FBVzNKLEVBQUVsRSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNqSSxJQUFJLEVBQUVBLEVBQUVELElBQUksSUFBSSxJQUFHLEVBQUcsT0FBT0osSUFBSXRMLEVBQUVpTSxHQUFHLFNBQVNYLE9BQUUsRUFBTSxFQUFHLE9BQU8sQ0FBQ0EsRUFBRUMsS0FBS3ZMLEVBQUVpTSxHQUFHLFNBQVNYLEVBQUUsQ0FBQzZKLEtBQUt0TyxPQUFPMEUsSUFBRyxFQUFHLE9BQU8sQ0FBQ0QsRUFBRUMsS0FBS3ZMLEVBQUVpTSxHQUFHLGlCQUFpQlgsRUFBRSxDQUFDNkosS0FBS3RPLE9BQU8wRSxJQUFHLEVBQUcsT0FBTyxDQUFDRCxFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHTSxFQUFFQyxFQUFFQyxLQUFLdE0sRUFBRWlNLEdBQUcsU0FBU1gsRUFBRSxDQUFDZ0ssVUFBVS9KLEVBQUVvSSxLQUFLbEksRUFBRWpFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2xJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLEdBQUc4Six3QkFBd0JmLEdBQUc3SSxHQUFHNkosWUFBWTVKLEVBQUU2SixlQUFlNUosRUFBRTZKLG1CQUFtQjVKLEVBQUc2SixzQkFBc0JuQixHQUFHcEksR0FBR3dKLEtBQUtwQixHQUFHbkksR0FBR3dKLFlBQVlyQixHQUFHbEksSUFBRyxFQUFHLE9BQU8sQ0FBQ2hCLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUVDLEtBQUs3TCxFQUFFaU0sR0FBRyxRQUFRWCxFQUFFLENBQUN3SyxPQUFPdkssRUFBRS9ELE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU25JLElBQUksRUFBRUEsRUFBRUYsSUFBSSxJQUFJLEdBQUd3SyxLQUFLckssRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLEdBQUdpSSxLQUFLL0gsRUFBRXBFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBUy9ILElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPTixJQUFJdEwsRUFBRWlNLEdBQUcsT0FBT1gsT0FBRSxFQUFNLEVBQUcsT0FBTyxDQUFDQSxFQUFFQyxFQUFFRSxLQUFLekwsRUFBRWlNLEdBQUcscUJBQXFCWCxFQUFFLENBQUM2SixLQUFLdE8sT0FBTzBFLEdBQUd5SyxRQUFRblAsT0FBTzRFLElBQUcsRUFBRyxPQUFPLENBQUNILEVBQUVDLEVBQUVFLEtBQUt6TCxFQUFFaU0sR0FBRyx3QkFBd0JYLEVBQUUsQ0FBQzBLLFFBQVF6SyxFQUFFcEksT0FBT3NJLEVBQUUsT0FBTyxRQUFPLEVBQUcsT0FBTyxDQUFDSCxFQUFFQyxFQUFFRSxLQUFLekwsRUFBRWlNLEdBQUcsd0JBQXdCWCxFQUFFLENBQUMwSyxRQUFRekssRUFBRXBJLE9BQU9zSSxFQUFFLE9BQU8sUUFBTyxFQUFHLE9BQU9ILElBQUl0TCxFQUFFaU0sR0FBRyxRQUFRWCxPQUFFLEVBQU0sRUFBRyxPQUFPLENBQUNBLEVBQUVDLEtBQUt2TCxFQUFFaU0sR0FBRyxTQUFTWCxFQUFFLENBQUMySyxTQUFTekIsR0FBR2pKLElBQUcsRUFBRyxPQUFPLENBQUNELEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxNQUFNWCxFQUFFLENBQUNzSyxLQUFLckssRUFBRWhMLE1BQU1rTCxFQUFFeUksS0FBS3hJLEVBQUVsRSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVNqSSxJQUFJLEVBQUVBLEVBQUVELElBQUksSUFBSSxJQUFHLEVBQUcsT0FBT0osSUFBSXRMLEVBQUVpTSxHQUFHLE9BQU9YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxVQUFVWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsZ0JBQWdCWCxPQUFFLEVBQU0sRUFBRyxPQUFPLENBQUNBLEVBQUVDLEtBQUt2TCxFQUFFaU0sR0FBRyx5QkFBeUJYLEVBQUUsQ0FBQzBLLFFBQVF6SyxHQUFFLEVBQUcsT0FBTyxDQUFDRCxFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHTSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHQyxLQUFNeE0sRUFBRWlNLEdBQUcsT0FBT1gsRUFBRSxDQUFDbkksT0FBT2lKLEVBQUUsT0FBTyxPQUFPdUksU0FBU3BKLEVBQUV3SSxVQUFVLENBQUN0SSxHQUFHdUksTUFBTXRJLEVBQUV1SSxhQUFhLENBQUN0SSxHQUFHdUksS0FBS3RJLEVBQUVwRSxNQUFNZCxLQUFLa0ssRUFBRWdELFNBQVMvSCxJQUFJLEVBQUVBLEVBQUVELElBQUksSUFBSSxHQUFHdUksUUFBUSxDQUFDckksR0FBSW9LLFdBQVcsTUFBTXhGLEVBQUVyRSxJQUFJLEdBQUdrSSxXQUFXQyxHQUFHbEksR0FBRzZKLGtCQUFrQjVKLEVBQUcvRSxNQUFNZCxLQUFLb0ssRUFBRzhDLFNBQVNwSCxJQUFLLEVBQUVBLEVBQUdELElBQUssSUFBSSxJQUFHLEVBQUcsT0FBTyxDQUFDakIsRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBR00sRUFBRUMsRUFBRUMsRUFBRUMsRUFBR0MsRUFBR0UsRUFBRUMsRUFBRytILEtBQU0xVSxFQUFFaU0sR0FBRyxPQUFPWCxFQUFFLENBQUNuSSxPQUFPb0osRUFBRyxPQUFPLE9BQU9vSSxTQUFTcEosRUFBRXdJLFVBQVUsQ0FBQ3RJLEVBQUVDLEdBQUdzSSxNQUFNckksRUFBRXNJLGFBQWEsQ0FBQ3JJLEVBQUVDLEdBQUdxSSxLQUFLcEksRUFBR3RFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU3hILElBQUksRUFBRUEsRUFBRU4sSUFBSyxJQUFJLEdBQUdxSSxRQUFRLENBQUM5SCxFQUFFQyxHQUFHNEosV0FBVyxNQUFNeEYsRUFBRWxFLElBQUssR0FBRytILFdBQVdDLEdBQUc5SCxHQUFHeUosa0JBQWtCeEosRUFBR25GLE1BQU1kLEtBQUtvSyxFQUFHOEMsU0FBU2MsSUFBSyxFQUFFQSxFQUFHL0gsSUFBSyxJQUFJLElBQUcsRUFBRyxPQUFPckIsSUFBSXRMLEVBQUVrTSxHQUFHWixFQUFDLEVBQUcsT0FBTyxDQUFDQSxFQUFFQyxJQUFJdkwsRUFBRW1NLEdBQUdiLEVBQUVDLEVBQUV2TCxFQUFFK00sR0FBR0MsR0FBR2hOLEVBQUUrTSxHQUFHRSxRQUFRLE9BQU8zQixHQUFHdEwsRUFBRStMLEdBQUdULEdBQUcsT0FBT0EsR0FBR3RMLEVBQUV5QyxHQUFHNkksR0FBRyxPQUFPLENBQUNBLEVBQUVDLEVBQUVFLEtBQUt6TCxFQUFFakMsR0FBR3VOLEVBQUVDLEVBQUVFLEdBQUUsRUFBRSxFQUFHLE9BQU8sQ0FBQ0gsRUFBRUMsRUFBRUUsS0FBS3pMLEVBQUVqQyxHQUFHdU4sRUFBRUMsRUFBRUUsRUFBQyxHQUFJLFNBQVMySyxFQUFHOUssR0FBR3JFLEtBQUt0RixLQUFLLGFBQWFzRixLQUFLb1AsUUFBUSxnQ0FBZ0MvSyxLQUFLckUsS0FBSzBJLE9BQU9yRSxDQUFDLENBQUMsSUFBSWdMLEVBQUdoTCxJQUFJLEtBQUssRUFBRUEsRUFBRWxLLFFBQVFrSyxFQUFFeUcsT0FBRnpHLENBQVV0TCxFQUFDLEVBQUcsU0FBU3VXLEVBQUdqTCxHQUFHckUsS0FBS3ZKLEdBQUc0TixFQUFFLEdBQUdyRSxLQUFLdVAsR0FBRyxTQUFTakwsR0FBR3NGLEVBQUU1SixLQUFLdkosR0FBRyxHQUFHLElBQUksR0FBRzZOLENBQUMsRUFBRXRFLEtBQUtsRixHQUFHLFNBQVN3SixHQUFHc0YsRUFBRTVKLEtBQUt2SixHQUFHLEdBQUcsSUFBSSxHQUFHNk4sQ0FBQyxFQUFFdEUsS0FBS3pFLEdBQUcsU0FBUytJLEVBQUVFLEdBQUd4RSxLQUFLaEYsS0FBS2dGLEtBQUt1UCxHQUFHakwsR0FBR3RFLEtBQUtsRixHQUFHMEosRUFBRSxFQUFFeEUsS0FBS2hGLEdBQUcsV0FBVzRPLEVBQUU1SixLQUFLdkosR0FBRyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUF5d0QrWSxFQUEzdkRDLFNBQVVDLFlBQVksSUFBSSxJQUFJQSxZQUFZLGFBQVEsRUFBT0MsRUFBRyxDQUFDdEwsRUFBRUMsRUFBRUUsS0FBWSxJQUFJQyxHQUFYSCxLQUFLLEdBQVVFLEVBQUUsSUFBSUEsRUFBRUYsRUFBRUQsRUFBRUcsTUFBTUEsR0FBR0MsTUFBTUQsRUFBRSxHQUFHLEdBQUdBLEVBQUVGLEdBQUdELEVBQUVxRCxRQUFRK0gsRUFBRyxPQUFPQSxFQUFHRyxPQUFPdkwsRUFBRXNJLFNBQVNySSxFQUFFRSxJQUFJLElBQUlDLEVBQUUsR0FBR0gsRUFBRUUsR0FBRyxDQUFDLElBQUlFLEVBQUVMLEVBQUVDLEtBQUssR0FBSyxJQUFGSSxFQUFNLENBQUMsSUFBSUMsRUFBUyxHQUFQTixFQUFFQyxLQUFRLEdBQVksTUFBTixJQUFGSSxHQUFZRCxHQUFHb0wsT0FBT0MsY0FBZ0IsR0FBRnBMLElBQU8sRUFBRUMsT0FBTyxDQUFDLElBQUlDLEVBQVMsR0FBUFAsRUFBRUMsS0FBd0UsT0FBaEVJLEVBQVcsTUFBTixJQUFGQSxJQUFlLEdBQUZBLElBQU8sR0FBR0MsR0FBRyxFQUFFQyxHQUFLLEVBQUZGLElBQU0sR0FBR0MsR0FBRyxHQUFHQyxHQUFHLEVBQVMsR0FBUFAsRUFBRUMsTUFBZ0JHLEdBQUdvTCxPQUFPQyxhQUFhcEwsSUFBSUEsR0FBRyxNQUFNRCxHQUFHb0wsT0FBT0MsYUFBYSxNQUFNcEwsR0FBRyxHQUFHLE1BQVEsS0FBRkEsR0FBUSxDQUFDLE1BQU1ELEdBQUdvTCxPQUFPQyxhQUFhcEwsRUFBRSxDQUFDLE9BQU9ELEdBQUc4SSxHQUFHLENBQUNsSixFQUFFQyxLQUFLRCxLQUFLLEdBQUdzTCxFQUFHakcsRUFBR3JGLEVBQUVDLEdBQUcsR0FBR3lMLEdBQUcxTCxJQUFJLElBQUksSUFBSUMsRUFBRSxFQUFFRSxFQUFFLEVBQUVBLEVBQUVILEVBQUVsSyxTQUFTcUssRUFBRSxDQUFDLElBQUlDLEVBQUVKLEVBQUUyTCxXQUFXeEwsR0FBRyxLQUFLQyxFQUFFSCxJQUFJLE1BQU1HLEVBQUVILEdBQUcsRUFBRSxPQUFPRyxHQUFHLE9BQU9BLEdBQUdILEdBQUcsSUFBSUUsR0FBR0YsR0FBRyxDQUFDLENBQUMsT0FBT0EsR0FBRzJMLEdBQUcsQ0FBQzVMLEVBQUVDLEVBQUVFLEVBQUVDLEtBQUssS0FBWSxFQUFFQSxHQUFHLE9BQU8sRUFBRSxJQUFJQyxFQUEzQkYsS0FBSyxFQUEwQkMsRUFBRUQsRUFBRUMsRUFBRSxFQUFFLElBQUksSUFBSUUsRUFBRSxFQUFFQSxFQUFFTixFQUFFbEssU0FBU3dLLEVBQUUsQ0FBQyxJQUFJQyxFQUFFUCxFQUFFMkwsV0FBV3JMLEdBQWtGLEdBQTVFLE9BQU9DLEdBQUcsT0FBT0EsSUFBNEJBLEVBQUUsUUFBVSxLQUFGQSxJQUFTLElBQU8sS0FBNUNQLEVBQUUyTCxhQUFhckwsSUFBcUMsS0FBS0MsRUFBRSxDQUFDLEdBQUdKLEdBQUdDLEVBQUUsTUFBTUgsRUFBRUUsTUFBTSxHQUFHSSxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU1BLEVBQUUsQ0FBQyxHQUFHSixFQUFFLEdBQUdDLEVBQUUsTUFBTUgsRUFBRUUsTUFBTSxHQUFHLElBQUlJLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPQSxFQUFFLENBQUMsR0FBR0osRUFBRSxHQUFHQyxFQUFFLE1BQU1ILEVBQUVFLE1BQU0sR0FBRyxJQUFJSSxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUdKLEVBQUUsR0FBR0MsRUFBRSxNQUFNSCxFQUFFRSxNQUFNLEdBQUcsSUFBSUksR0FBRyxHQUFHTixFQUFFRSxNQUFNLEdBQUcsSUFBSUksR0FBRyxHQUFHLEVBQUUsQ0FBQ04sRUFBRUUsTUFBTSxHQUFHLElBQUlJLEdBQUcsRUFBRSxFQUFFLENBQUNOLEVBQUVFLE1BQU0sR0FBRyxJQUFNLEdBQUZJLENBQUksQ0FBQyxDQUFDLE9BQU9OLEVBQUVFLElBQUksR0FBRyxFQUFFQSxFQUFFRSxHQUFHd0wsR0FBRzdMLEdBQUdBLEVBQUUsR0FBSSxJQUFJQSxFQUFFLEtBQU0sR0FBR0EsRUFBRSxLQUFNLEdBQUc4TCxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUtDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksS0FBS0MsR0FBR2hNLElBQUksSUFBSUMsRUFBRXlMLEdBQUcxTCxHQUFHLEVBQUVHLEVBQUU4TCxHQUFHaE0sR0FBRyxPQUFPRSxHQUFHeUwsR0FBRzVMLEVBQUVxRixFQUFHbEYsRUFBRUYsR0FBR0UsR0FBRytMLEdBQUcsR0FBR0MsR0FBRyxDQUFDbk0sRUFBRUMsS0FBaUIsSUFBSUUsRUFBRSxJQUFsQitMLEdBQUdwVyxPQUFPLEVBQVltSyxJQUFJLEVBQUVFLEVBQUVrRixFQUFHckYsTUFBTSxJQUFJQyxHQUFNLEtBQUhFLEVBQU9GLEVBQUVpTSxHQUFHblcsS0FBUSxLQUFIb0ssRUFBT21GLEVBQUVyRixJQUFJLEdBQUd3RixFQUFHeEYsTUFBTSxNQUFNQSxFQUFFLE9BQU9pTSxJQUFJRSxHQUFHLENBQUMsRUFBRUMsR0FBRyxLQUFLLElBQUlsQixFQUFHLENBQUMsSUFBc05sTCxFQUFsTkQsRUFBRSxDQUFDc00sS0FBSyxXQUFXQyxRQUFRLFdBQVdDLEtBQUssSUFBSUMsSUFBSSxJQUFJQyxLQUFLLGlCQUFpQkMsTUFBd0IsaUJBQVhDLFdBQXFCQSxVQUFVQyxXQUFXRCxVQUFVQyxVQUFVLElBQUksS0FBS3JKLFFBQVEsSUFBSSxLQUFLLFNBQVNuRCxFQUFFakssR0FBRyxrQkFBb0IsSUFBSTZKLEtBQUttTSxRQUFXLElBQVJBLEdBQUduTSxVQUFtQkQsRUFBRUMsR0FBR0QsRUFBRUMsR0FBR21NLEdBQUduTSxHQUFHLElBQUlFLEVBQUUsR0FBRyxJQUFJRixLQUFLRCxFQUFFRyxFQUFFcEssS0FBSyxHQUFHa0ssS0FBS0QsRUFBRUMsTUFBTWtMLEVBQUdoTCxDQUFDLENBQUMsT0FBT2dMLEdBQU8yQixHQUFHLENBQUMsS0FBSyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFvRSxTQUFTQyxHQUFHak4sRUFBRUMsRUFBRUUsRUFBRUMsR0FBRyxTQUFTQyxFQUFFZSxFQUFFQyxFQUFHK0gsR0FBSSxJQUFJaEksRUFBWSxpQkFBSEEsRUFBWUEsRUFBRThMLFdBQVc5TCxHQUFHLEdBQUdBLEVBQUV0TCxPQUFPdUwsR0FBSUQsRUFBRWdJLEVBQUcsR0FBR2hJLEVBQUUsT0FBT0EsQ0FBQyxDQUFDLFNBQVNkLEVBQUVjLEVBQUVDLEdBQUksT0FBT2hCLEVBQUVlLEVBQUVDLEVBQUcsSUFBSSxDQUFDLFNBQVNkLEVBQUVhLEVBQUVDLEdBQUksU0FBUytILEVBQUcrRCxHQUFJLE9BQU8sRUFBRUEsR0FBSSxFQUFFLEVBQUVBLEVBQUcsRUFBRSxDQUFDLENBQUMsSUFBSUMsRUFBRyxPQUFrRCxLQUEzQ0EsRUFBR2hFLEVBQUdoSSxFQUFFaU0sY0FBY2hNLEVBQUdnTSxpQkFBMkQsS0FBckNELEVBQUdoRSxFQUFHaEksRUFBRWtNLFdBQVdqTSxFQUFHaU0sZUFBbUJGLEVBQUdoRSxFQUFHaEksRUFBRW1NLFVBQVVsTSxFQUFHa00sWUFBWUgsQ0FBRSxDQUFDLFNBQVM1TSxFQUFHWSxHQUFHLE9BQU9BLEVBQUVvTSxVQUFVLEtBQUssRUFBRSxPQUFPLElBQUlDLEtBQUtyTSxFQUFFaU0sY0FBYyxFQUFFLEdBQUcsSUFBSSxLQUFLLEVBQUUsT0FBT2pNLEVBQUUsS0FBSyxFQUFFLE9BQU8sSUFBSXFNLEtBQUtyTSxFQUFFaU0sY0FBYyxFQUFFLEdBQUcsS0FBSyxFQUFFLE9BQU8sSUFBSUksS0FBS3JNLEVBQUVpTSxjQUFjLEVBQUUsR0FBRyxLQUFLLEVBQUUsT0FBTyxJQUFJSSxLQUFLck0sRUFBRWlNLGNBQWMsRUFBRSxHQUFHLEtBQUssRUFBRSxPQUFPLElBQUlJLEtBQUtyTSxFQUFFaU0sY0FBYyxFQUFFLEdBQUcsSUFBSSxLQUFLLEVBQUUsT0FBTyxJQUFJSSxLQUFLck0sRUFBRWlNLGNBQWMsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTdk0sRUFBRU0sR0FBRyxJQUFJQyxFQUFHRCxFQUFFc00sR0FBRyxJQUFJdE0sRUFBRSxJQUFJcU0sS0FBSyxJQUFJQSxLQUFLck0sRUFBRXVNLEdBQUcsS0FBSyxFQUFFLEdBQUdDLFdBQVcsRUFBRXZNLEdBQUksQ0FBQyxJQUFJK0gsRUFBR2hJLEVBQUVrTSxXQUFXRixHQUFJdkIsR0FBR3pLLEVBQUVpTSxlQUFlTixHQUFHQyxJQUFJNUQsR0FBSSxLQUFHL0gsRUFBRytMLEVBQUdoTSxFQUFFbU0sV0FBd0gsQ0FBQ25NLEVBQUV5TSxRQUFRek0sRUFBRW1NLFVBQVVsTSxHQUFJLEtBQUssQ0FBOUlBLEdBQUkrTCxFQUFHaE0sRUFBRW1NLFVBQVUsRUFBRW5NLEVBQUV5TSxRQUFRLEdBQUcsR0FBR3pFLEVBQUdoSSxFQUFFME0sU0FBUzFFLEVBQUcsSUFBSWhJLEVBQUUwTSxTQUFTLEdBQUcxTSxFQUFFMk0sWUFBWTNNLEVBQUVpTSxjQUFjLEdBQXlDLENBQUMsT0FBT2pFLEVBQUcsSUFBSXFFLEtBQUtyTSxFQUFFaU0sY0FBYyxFQUFFLEVBQUUsR0FBR2hNLEVBQUdiLEVBQUcsSUFBSWlOLEtBQUtyTSxFQUFFaU0sY0FBYyxFQUFFLElBQUlqRSxFQUFHNUksRUFBRzRJLEdBQUksR0FBRzdJLEVBQUVjLEVBQUdELEdBQUcsR0FBR2IsRUFBRTZJLEVBQUdoSSxHQUFHQSxFQUFFaU0sY0FBYyxFQUFFak0sRUFBRWlNLGNBQWNqTSxFQUFFaU0sY0FBYyxDQUFDLENBQUNyTixLQUFLLEVBQUVDLEtBQUssRUFBRUUsS0FBSyxFQUFTLElBQUlZLEVBQUV1RSxFQUFJLElBQWpCbEYsS0FBSyxJQUFnQixJQUFJLEdBQW1rQixJQUFJLElBQUlZLEtBQXhrQlosRUFBRSxDQUFDNE4sR0FBRzFJLEVBQUVsRixHQUFHLElBQUksR0FBRzZOLEdBQUczSSxFQUFFbEYsRUFBRSxHQUFHLElBQUksR0FBRzhOLEdBQUc1SSxFQUFFbEYsRUFBRSxHQUFHLElBQUksR0FBRytOLEdBQUc3SSxFQUFFbEYsRUFBRSxJQUFJLElBQUksR0FBR2dPLEdBQUc5SSxFQUFFbEYsRUFBRSxJQUFJLElBQUksR0FBR3VOLEdBQUdySSxFQUFFbEYsRUFBRSxJQUFJLElBQUksR0FBR2lPLEdBQUcvSSxFQUFFbEYsRUFBRSxJQUFJLElBQUksR0FBR3NOLEdBQUdwSSxFQUFFbEYsRUFBRSxJQUFJLElBQUksR0FBR2tPLEdBQUdoSixFQUFFbEYsRUFBRSxJQUFJLElBQUksR0FBR21PLEdBQUdqSixFQUFFbEYsRUFBRSxJQUFJLElBQUksR0FBRzVOLEdBQUd1TyxFQUFFbUksR0FBR25JLEdBQUcsSUFBSVosRUFBRStJLEdBQUcvSSxHQUFHWSxFQUFFLENBQUMsS0FBSyx1QkFBdUIsS0FBSyxXQUFXLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxjQUFjLEtBQUssUUFBUSxLQUFLLFdBQVcsS0FBSyxXQUFXLEtBQUssV0FBVyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sV0FBVyxNQUFNLFdBQVcsTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQXFCWixFQUFFQSxFQUFFcUQsUUFBUSxJQUFJZ0wsT0FBT3hOLEVBQUUsS0FBS0QsRUFBRUMsSUFBSSxJQUFJQyxFQUFHLDJEQUEyRHdOLE1BQU0sS0FBS3ZOLEVBQUcsd0ZBQXdGdU4sTUFBTSxLQUNwdWUsSUFBSXpOLEtBRHF1ZUQsRUFBRSxDQUFDLEtBQUtLLEdBQUdILEVBQUdHLEVBQUVpTixJQUFJSyxVQUFVLEVBQUUsR0FBRyxLQUFLdE4sR0FBR0gsRUFBR0csRUFBRWlOLElBQUksS0FBS2pOLEdBQUdGLEVBQUdFLEVBQUVnTixJQUFJTSxVQUFVLEVBQUUsR0FBRyxLQUFLdE4sR0FBR0YsRUFBR0UsRUFBRWdOLElBQUksS0FBS2hOLEdBQUdkLEdBQUdjLEVBQUV1TSxHQUFHLE1BQU0sSUFBSSxFQUFFLEdBQUcsS0FBS3ZNLEdBQUdkLEVBQUVjLEVBQUUrTSxHQUFHLEdBQUcsS0FBSy9NLEdBQUdmLEVBQUVlLEVBQUUrTSxHQUFHLEVBQUUsS0FBSyxLQUFLL00sR0FBR04sRUFBRU0sR0FBRzhMLFdBQVd3QixVQUFVLEdBQUcsS0FBS3ROLEdBQUdOLEVBQUVNLEdBQUcsS0FBS0EsR0FBR2QsRUFBRWMsRUFBRThNLEdBQUcsR0FBRyxLQUFLOU0sSUFBYyxJQUFWQSxFQUFFQSxFQUFFOE0sSUFBUTlNLEVBQUUsR0FBRyxHQUFHQSxJQUFJQSxHQUFHLElBQUlkLEVBQUVjLEVBQUUsSUFBSSxLQUFLQSxJQUFJLElBQUksSUFBSUMsRUFBRyxFQUFFK0gsRUFBRyxFQUFFQSxHQUFJaEksRUFBRWdOLEdBQUcsRUFBRS9NLElBQUt3SyxHQUFHekssRUFBRXVNLEdBQUcsTUFBTVosR0FBR0MsSUFBSTVELE1BQU8sT0FBTzlJLEVBQUVjLEVBQUUrTSxHQUFHOU0sRUFBRyxFQUFDLEVBQUcsS0FBS0QsR0FBR2QsRUFBRWMsRUFBRWdOLEdBQUcsRUFBRSxHQUFHLEtBQUtoTixHQUFHZCxFQUFFYyxFQUFFNk0sR0FBRyxHQUFHLEtBQUssSUFBSSxLQUMvd2dCLEtBQUs3TSxHQUFHLEdBQUdBLEVBQUU4TSxJQUFJLEdBQUc5TSxFQUFFOE0sR0FBRyxLQUFLLEtBQUssS0FBSzlNLEdBQUdkLEVBQUVjLEVBQUU0TSxHQUFHLEdBQUcsS0FBSyxJQUFJLEtBQUksS0FBSzVNLEdBQUdBLEVBQUVpTixJQUFJLEVBQUUsS0FBS2pOLEdBQUdkLEVBQUVxTyxLQUFLQyxPQUFPeE4sRUFBRXNNLEdBQUcsRUFBRXRNLEVBQUVpTixJQUFJLEdBQUcsR0FBRyxLQUFLak4sSUFBSSxJQUFJQyxFQUFHc04sS0FBS0MsT0FBT3hOLEVBQUVzTSxHQUFHLEdBQUd0TSxFQUFFaU4sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUlqTixFQUFFaU4sR0FBRyxJQUFJak4sRUFBRXNNLEdBQUcsR0FBRyxHQUFHck0sSUFBS0EsRUFBTyxJQUFKQSxJQUFrQyxJQUF6QitILEdBQUloSSxFQUFFaU4sR0FBRyxJQUFJak4sRUFBRXNNLElBQUksSUFBYSxHQUFKdEUsR0FBT3lDLEdBQUd6SyxFQUFFdU0sTUFBTXRNLEVBQUcsUUFBUSxDQUFDQSxFQUFHLEdBQUcsSUFBSStILEdBQUloSSxFQUFFaU4sR0FBRyxFQUFFak4sRUFBRXNNLEdBQUcsR0FBRyxHQUFPLEdBQUp0RSxHQUFXLEdBQUpBLEdBQU95QyxHQUFHekssRUFBRXVNLEdBQUcsSUFBSSxLQUFLdE0sR0FBSSxDQUFDLE9BQU9mLEVBQUVlLEVBQUcsRUFBQyxFQUFHLEtBQUtELEdBQUdBLEVBQUVpTixHQUFHLEtBQUtqTixHQUFHZCxFQUFFcU8sS0FBS0MsT0FBT3hOLEVBQUVzTSxHQUFHLEdBQUd0TSxFQUFFaU4sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUtqTixJQUFJQSxFQUFFdU0sR0FBRyxNQUFNVCxXQUFXd0IsVUFBVSxHQUFHLEtBQUt0TixHQUFHQSxFQUFFdU0sR0FBRyxLQUFLLEtBQUt2TSxJQUFrQixJQUFkQSxFQUFFQSxFQUFFbU4sSUFBMkMsSUFBSSxNQUFNLFNBQS9Cbk4sRUFBRXVOLEtBQUtFLElBQUl6TixHQUFHLElBQTJCLEdBQUcsSUFBSUEsRUFBRSxLQUFLcUMsT0FBTyxHQUFJLEtBQUtyQyxHQUFHQSxFQUFFNU8sR0FBRyxLQUFLLElBQUksS0FBSzJOLEVBQUVBLEVBQUVxRCxRQUFRLE1BQU0sUUFBaUJ6QyxFQUFFWixFQUFFMk8sU0FBUzlOLEtBQUtiLEVBQUVBLEVBQUVxRCxRQUFRLElBQUlnTCxPQUFPeE4sRUFBRSxLQUFLRCxFQUFFQyxHQUFHWixLQUFLLE9BQWdDWSxFQUQwbmEsU0FBWWhCLEdBQUcsSUFBSUMsRUFBRS9ELE1BQU13UCxHQUFHMUwsR0FBRyxHQUFHLE9BQU80TCxHQUFHNUwsRUFBRUMsRUFBRSxFQUFFQSxFQUFFbkssUUFBUW1LLENBQUMsQ0FDdnJhOE8sQ0FBM0I1TyxFQUFFQSxFQUFFcUQsUUFBUSxRQUFRLE1BQWF4QyxFQUFFbEwsT0FBT21LLEVBQUUsR0FBR21GLEVBQUU3UCxJQUFJeUwsRUFBRWhCLElBQUksR0FBR2dCLEVBQUVsTCxPQUFPLEVBQUUsQ0FBQyxTQUFTa1osR0FBR2hQLEdBQUcsSUFBSUEsR0FBRyxDQUFDLE1BQU1DLEdBQUdnRixFQUFHaEYsRUFBRSxDQUFDLENBQTJRLElBQUlnUCxHQUFHLEVBQUU5TixHQUFHLEtBQUsrTixHQUFHLEVBQUVDLEdBQUcsR0FBR0MsR0FBRyxDQUFDLEVBQUVDLEdBQUcsQ0FBQyxFQUFFQyxHQUFHLEVBQUVoTyxHQUFHLEtBQUtpTyxHQUFHLEdBQXc2QixJQUFJQyxHQUFHLENBQUMxYSxFQUFFLFNBQVNrTCxFQUFFQyxFQUFFRSxHQUFHLE9BQXJFLFNBQVlILEdBQUcsT0FBM3FCLFNBQVlBLEdBQUcsSUFBSTBGLEVBQUUsQ0FBQyxHQUFRLElBQUx1SixHQUFPLENBQUMsSUFBSWhQLEdBQUUsRUFBR0UsR0FBRSxFQUFHSCxHQUFFLENBQUNJLEVBQUUsS0FBSyxJQUFJc0YsSUFBSXdKLEdBQUc5TyxFQUFFSCxHQUFFLEVBQUdFLEdBQUcsQ0FBQzhPLEdBQUcsRUFBRUQsSUFBRyxJQUFJUyxHQUFHdE8sYUFBWXVPLFFBQVEsS0FBS0EsUUFBUUMsR0FBR0MsSUFBSUYsUUFBUUMsR0FBR0UsU0FBU3pQLEdBQUUsRUFBRyxJQUFJLElBQUlDLEdBQUUsRUFBRzZFLEVBQUVtSyxHQUFHL0osRUFBRW5FLEdBQUcsR0FBRyxJQUFJLE9BQU8sQ0FBQyxNQUFNWCxHQUFJSCxFQUFFRyxFQUFHSixHQUFFLENBQUUsQ0FBQyxJQUFJRSxHQUFFLEVBQUcsSUFBSWEsR0FBRyxDQUFDLElBQUlaLEVBQUVlLEdBQUdmLElBQUllLEdBQUcsTUFBTWxCLEVBQUVHLEVBQUVpQixPQUFPakIsRUFBRWdCLFNBQVNsQixHQUFHQyxHQUFFLEVBQUcsQ0FBQyxHQUFHRixJQUFJRSxFQUFFLE1BQU1ELENBQUMsS0FBSUYsR0FBRSxFQUFHRixJQUFJZ1AsR0FBRyxFQUFFOU4sR0FBNWQsV0FBYyxJQUFJbkIsRUFBRWlNLEdBQUcsT0FBT2hNLEVBQUVELEVBQUUsR0FBR3VGLEVBQUV2RixHQUFHLElBQUksR0FBR0MsRUFBRXNGLEVBQUV2RixFQUFFLEdBQUcsSUFBSSxHQUFHQyxFQUFFLE1BQU1BLEVBQUVrUCxHQUFHLEdBQUcsSUFBSWhQLEVBQUVpUCxHQUFHblAsR0FBRyxZQUFXLElBQUpFLElBQWFBLEVBQUVtUCxLQUFLRixHQUFHblAsR0FBR0UsRUFBRWtQLEdBQUdsUCxHQUFHRixHQUFHcUYsRUFBRXRGLEVBQUUsR0FBRyxJQUFJLEdBQUdHLEVBQUVILENBQUMsQ0FBcVU4UCxVQUFZSixRQUFRLEtBQUtBLFFBQVFDLEdBQUdDLElBQUlGLFFBQVFDLEdBQUdJLFFBQVFmLElBQUcsSUFBSWdCLEdBQUc3TyxNQUFLLE1BQVcsSUFBTDhOLElBQVFBLEdBQUcsRUFBRUQsR0FBR2lCLElBQUlDLEdBQUcvTyxJQUFJQSxHQUFHLEtBQUtvTyxHQUFHWSxTQUFRL1AsSUFBSSxJQUFJc0YsRUFBRSxJQUFJLEdBQUd0RixLQUFLdkgsRUFBRSxJQUFJc00sRUFBRUEsRUFBRS9FLEVBQUUrRSxFQUFFdE0sSUFBSW5FLEVBQUUwYixRQUFRMWIsRUFBRTBiLE9BQU9oUSxHQUFHc0YsR0FBRSxHQUFJNU4sRUFBRXNJLEVBQUUsSUFBSTBLLEVBQUcxSyxHQUFHLENBQUMsTUFBTUMsR0FBR0EsYUFBYXlLLEdBQU8sVUFBSHpLLEdBQWF2SSxFQUFFLEVBQUV1SSxFQUFFLENBQUMsQ0FBQyxNQUFNQSxHQUFHQSxhQUFheUssR0FBTyxVQUFIekssR0FBYXZJLEVBQUUsRUFBRXVJLEVBQUUsTUFBSzRFLEVBQUcsa0JBQWtCZ0ssTUFBTSxPQUFPQyxFQUFFLENBQUMsQ0FBdUJtQixFQUFHcFEsSUFBSUQsSUFBSXdILEtBQUt2SCxFQUFDLEdBQUcsQ0FBa0NxUSxFQUFHdGEsZ0JBQWdCdEIsRUFBRWdNLEdBQUdWLEVBQUVDLEVBQUVFLEVBQUMsR0FBRyxFQUFFdE8sRUFBRSxTQUFTbU8sRUFBRUMsRUFBRUUsR0FBRyxNQUFhLElBQUk4SyxFQUFYakwsS0FBSyxHQUFZOUksR0FBRytJLElBQUksRUFBRUUsSUFBSSxHQUFNSCxDQUFTLEVBQUU1SCxFQUFFLFdBQVcsT0FBTyxDQUFDLEVBQUU0SSxFQUFFLFdBQVcsRUFBRXVQLEVBQUUsV0FBVyxFQUFFM1gsRUFBRSxXQUFXLEVBQUV2RSxFQUFFLFdBQVcsT0FBTyxDQUFDLEVBQUU4USxFQUFFLFdBQVcsRUFBRS9FLEVBQUUsV0FBVyxFQUFFRSxFQUFFLFdBQVcsRUFBRXhJLEVBQUUsV0FBVyxFQUFFMFksRUFBRSxXQUFXLEVBQUVDLEVBQUUsV0FBVyxFQUFFaFksRUFBRSxXQUFXLEVBQUVOLEVBQUUsV0FBVyxFQUFFRCxFQUFFLEtBQUksRUFBR3FOLEVBQUUsU0FBU3ZGLEVBQUVDLEVBQUVFLEdBQUdILEVBQUVDLEVBQUUsVUFBVSxFQUFFLFVBQVVELEdBQUdBLElBQUksR0FBRyxXQUFXQyxFQUFFeVEsSUFBSXZRLEtBQUssRUFBRUgsRUFBRSxJQUFJeU4sS0FBSyxJQUFJek4sR0FBR3NGLEVBQUVuRixHQUFHLElBQUksR0FBR0gsRUFBRTJRLGdCQUFnQnJMLEVBQUVuRixFQUFFLEdBQUcsSUFBSSxHQUFHSCxFQUFFNFEsZ0JBQWdCdEwsRUFBRW5GLEVBQUUsR0FBRyxJQUFJLEdBQUdILEVBQUU2USxjQUFjdkwsRUFBRW5GLEVBQUUsSUFBSSxJQUFJLEdBQUdILEVBQUU4USxhQUFheEwsRUFBRW5GLEVBQUUsSUFBSSxJQUFJLEdBQUdILEVBQUUrUSxjQUFjekwsRUFBRW5GLEVBQUUsSUFBSSxJQUFJLEdBQUdILEVBQUVnUixpQkFBaUIsS0FBSzFMLEVBQUVuRixFQUFFLElBQUksSUFBSSxHQUFHSCxFQUFFaVIsWUFBWTNMLEVBQUVuRixFQUFFLElBQUksSUFBSSxJQUFJSCxFQUFFNE4sVUFBVUgsS0FBS3lELElBQUlsUixFQUFFZ1IsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLE1BQU0sQ0FBQyxFQUFFdGMsRUFBRSxTQUFTc0wsRUFBRUMsRUFBRUUsR0FBR0gsRUFBRUMsRUFBRSxVQUFVLEVBQUUsVUFBVUQsR0FBR0EsSUFBSSxHQUFHLFdBQVdDLEVBQUV5USxJQUFJdlEsS0FBSyxFQUFFSCxFQUFFLElBQUl5TixLQUFLLElBQUl6TixHQUFHc0YsRUFBRW5GLEdBQUcsSUFBSSxHQUFHSCxFQUFFbVIsYUFBYTdMLEVBQUVuRixFQUFFLEdBQUcsSUFBSSxHQUFHSCxFQUFFb1IsYUFBYTlMLEVBQUVuRixFQUFFLEdBQUcsSUFBSSxHQUFHSCxFQUFFcVIsV0FBVy9MLEVBQUVuRixFQUFFLElBQUksSUFBSSxHQUFHSCxFQUFFdU4sVUFBVWpJLEVBQUVuRixFQUFFLElBQUksSUFBSSxHQUFHSCxFQUFFc04sV0FBV2hJLEVBQUVuRixFQUFFLElBQUksSUFBSSxHQUFHSCxFQUFFcU4sY0FBYyxLQUFLL0gsRUFBRW5GLEVBQUUsSUFBSSxJQUFJLEdBQUdILEVBQUV3TixTQUFTbEksRUFBRW5GLEVBQUUsSUFBSSxJQUFJLElBQUkwTCxHQUFHN0wsRUFBRXFOLGVBQWV2QixHQUFHQyxJQUFJL0wsRUFBRXNOLFlBQVl0TixFQUFFdU4sVUFBVSxFQUFFLEVBQUVqSSxFQUFFbkYsRUFBRSxJQUFJLElBQUksSUFBSyxHQUFHSCxFQUFFc1Isb0JBQXFCclIsRUFBRSxJQUFJd04sS0FBS3pOLEVBQUVxTixjQUFjLEVBQUUsR0FBR2lFLG9CQUFvQixJQUFJbFIsRUFBRSxJQUFJcU4sS0FBS3pOLEVBQUVxTixjQUFjLEVBQUUsR0FBR2lFLG9CQUFvQmhNLEVBQUVuRixFQUFFLElBQUksSUFBSSxHQUFnRCxHQUE1Q0YsR0FBR0csR0FBR0osRUFBRXNSLHFCQUFxQjNDLEtBQUszRyxJQUFJNUgsRUFBRUgsR0FBSyxFQUFFcEssRUFBRSxTQUFTbUssR0FBR0EsS0FBSyxFQUFFLElBQUlDLEVBQUUsSUFBSXdOLEtBQUtuSSxFQUFFdEYsRUFBRSxJQUFJLElBQUksR0FBRyxLQUFLc0YsRUFBRXRGLEVBQUUsSUFBSSxJQUFJLEdBQUdzRixFQUFFdEYsRUFBRSxJQUFJLElBQUksR0FBR3NGLEVBQUV0RixFQUFFLEdBQUcsSUFBSSxHQUFHc0YsRUFBRXRGLEVBQUUsR0FBRyxJQUFJLEdBQUdzRixFQUFFdEYsR0FBRyxJQUFJLEdBQUcsR0FBR0csRUFBRW1GLEVBQUV0RixFQUFFLElBQUksSUFBSSxHQUFHSSxFQUFFSCxFQUFFcVIsb0JBQW9CalIsRUFBRSxJQUFJb04sS0FBS3hOLEVBQUVvTixjQUFjLEVBQUUsR0FBR2lFLG9CQUFvQmhSLEVBQUUsSUFBSW1OLEtBQUt4TixFQUFFb04sY0FBYyxFQUFFLEdBQUdpRSxvQkFBb0IvUSxFQUFFb08sS0FBSzNHLElBQUkxSCxFQUFFRCxHQUFHLE9BQU8sRUFBRUYsRUFBRW1GLEVBQUV0RixFQUFFLElBQUksSUFBSSxLQUFLSyxHQUFHQyxHQUFHQyxHQUFHSCxHQUFHLEVBQUVELElBQUlJLEdBQUdILEtBQUtDLEVBQUVzTyxLQUFLMUcsSUFBSTNILEVBQUVELEdBQUdKLEVBQUVzUixRQUFRdFIsRUFBRTJOLFVBQVUsTUFBTSxFQUFFek4sRUFBRUksRUFBRUYsR0FBR0QsS0FBS2tGLEVBQUV0RixFQUFFLElBQUksSUFBSSxHQUFHQyxFQUFFdU4sU0FBU2xJLEVBQUV0RixFQUFFLElBQUksSUFBSSxJQUFJNkwsR0FBRzVMLEVBQUVvTixlQUFldkIsR0FBR0MsSUFBSTlMLEVBQUVxTixZQUFZck4sRUFBRXNOLFVBQVUsRUFBRSxFQUFFakksRUFBRXRGLEdBQUcsSUFBSSxHQUFHQyxFQUFFa1IsYUFBYTdMLEVBQUV0RixFQUFFLEdBQUcsSUFBSSxHQUFHQyxFQUFFbVIsYUFBYTlMLEVBQUV0RixFQUFFLEdBQUcsSUFBSSxHQUFHQyxFQUFFb1IsV0FBVy9MLEVBQUV0RixFQUFFLElBQUksSUFBSSxHQUFHQyxFQUFFc04sVUFBVWpJLEVBQUV0RixFQUFFLElBQUksSUFBSSxHQUFHQyxFQUFFcU4sV0FBV2hJLEVBQUV0RixFQUFFLElBQUksSUFBSSxHQUFHQyxFQUFFdVIsVUFBVXhSLEVBQUVDLEVBQUUyTixVQUFVLElBQUk2RCxJQUFJM0osRUFBRzlILEVBQUUsSUFBSTJPLEtBQUtFLElBQUkvRyxHQUFJLEVBQUVBLEdBQUk2RyxLQUFLQyxNQUFNOUcsRUFBRyxjQUFjLEtBQUs2RyxLQUFLK0MsTUFBTTVKLE1BQU9BLElBQUssSUFBSSxjQUFjLEVBQUUsSUFBSTlILElBQUksQ0FBQyxFQUFFckksRUFBRSxXQUFXLE9BQU8sRUFBRSxFQUFFQyxFQUFFLFdBQVcsRUFBRVMsRUFBRSxTQUFTMkgsRUFBRUMsRUFBRUUsR0FBRyxTQUFTQyxFQUFFVSxHQUFHLE9BQU9BLEVBQUVBLEVBQUU2USxlQUFlQyxNQUFNLHNCQUFzQjlRLEVBQUUsR0FBRyxLQUFLLENBQUNYLEtBQUssRUFBRSxJQUFJRSxHQUFFLElBQUlvTixNQUFPSixjQUFjL00sRUFBRSxJQUFJbU4sS0FBS3BOLEVBQUUsRUFBRSxHQUFHRSxFQUFFLElBQUlrTixLQUFLcE4sRUFBRSxFQUFFLEdBQUdBLEVBQUVDLEVBQUVnUixvQkFBb0IsSUFBSTlRLEVBQUdELEVBQUUrUSxvQkFBb0IvTCxFQUFFdkYsSUFBSSxHQUFHLElBQUksR0FBRyxHQUFHMk8sS0FBSzFHLElBQUk1SCxFQUFFRyxHQUFJOEUsRUFBRXJGLElBQUksR0FBRyxJQUFJLEtBQUtJLEdBQUdHLEdBQUlSLEVBQUVJLEVBQUVFLEdBQUdMLEVBQUVHLEVBQUVHLEdBQUdQLEVBQUVnTSxHQUFHaE0sR0FBR0MsRUFBRStMLEdBQUcvTCxHQUFHTyxFQUFHSCxHQUFHa0YsRUFBRXBGLEdBQUcsSUFBSSxHQUFHSCxFQUFFdUYsRUFBRXBGLEVBQUUsR0FBRyxJQUFJLEdBQUdGLElBQUlzRixFQUFFcEYsR0FBRyxJQUFJLEdBQUdGLEVBQUVzRixFQUFFcEYsRUFBRSxHQUFHLElBQUksR0FBR0gsRUFBRSxFQUFFMUwsRUFBRSxLQUFLMlEsRUFBRyxHQUFFLEVBQUcxTSxFQUFFLFNBQVN5SCxFQUFFQyxFQUFFRSxHQUFHLE9BQU9ILEtBQUssRUFBRUMsRUFBRWtNLEdBQUdsTSxJQUFJLEVBQUVFLElBQUksR0FBRzRILEVBQUcvSCxHQUFHNlIsTUFBTSxLQUFLNVIsRUFBRSxFQUFFbk8sRUFBRSxTQUFTa08sRUFBRUMsRUFBRUUsR0FBRyxPQUFPSCxLQUFLLEVBQUVDLEVBQUVrTSxHQUFHbE0sSUFBSSxFQUFFRSxJQUFJLEdBQUc0SCxFQUFHL0gsR0FBRzZSLE1BQU0sS0FBSzVSLEVBQUUsRUFBRTZSLEVBQUUsV0FBVyxPQUFPckUsS0FBS3NFLEtBQUssRUFBRTVSLEVBQUUsV0FBVyxPQUFPLFVBQVUsRUFBRTZSLEVBQUUsSUFBSUMsWUFBWUYsTUFBTTNNLEVBQUUsU0FBU3BGLEVBQUVDLEVBQUVFLEdBQUcsT0FBT0YsS0FBSyxFQUFFb0YsRUFBRzZNLFdBQVdsUyxJQUFJLElBQUksRUFBRUMsSUFBSSxFQUFFQSxHQUFHRSxJQUFJLEtBQUssRUFBRSxFQUFFL0osRUFBRSxTQUFTNEosR0FBR0EsS0FBSyxFQUFFLElBQUlDLEVBQUVvRixFQUFHdlAsT0FBTyxHQUFHLFdBQVdrSyxFQUFFLE9BQU0sRUFBRyxJQUFJLElBQUlHLEVBQUUsRUFBRSxHQUFHQSxFQUFFQSxHQUFHLEVBQUUsQ0FBQyxJQUFJQyxFQUFFSCxHQUFHLEVBQUUsR0FBR0UsR0FBR0MsRUFBRXVPLEtBQUszRyxJQUFJNUgsRUFBRUosRUFBRSxXQUFXLElBQUlLLEVBQUVzTyxLQUFLdk8sRUFBRXVPLEtBQUsxRyxJQUFJakksRUFBRUksR0FBRzlMLEVBQUUsQ0FBQytMLEVBQUVBLEVBQUUySCxJQUFJalQsS0FBS3NMLEVBQUUsV0FBV0QsR0FBRyxNQUFNQSxFQUFFLE9BQU8sT0FBT2xILEVBQUVtSyxPQUFPNUYsV0FBVyxRQUFRLEdBQUcsSUFBSXZFLEVBQUVpWixLQUFLOVIsR0FBR3NGLElBQUssSUFBSXJGLEVBQUUsRUFBRSxNQUFNaE0sQ0FBQyxDQUFDLE1BQU0sQ0FBQ2dNLE9BQUUsQ0FBTSxDQUFDLEdBQUdBLEVBQUUsT0FBTSxDQUFFLENBQUMsT0FBTSxDQUFFLEVBQUVwSCxFQUFFLFNBQVM4RyxFQUFFQyxHQUFHRCxLQUFLLEVBQUVDLEtBQUssRUFBRSxJQUFJRSxFQUFFLEVBQUUsT0FBT2tNLEtBQUs4RCxTQUFRLFNBQVMvUCxFQUFFQyxHQUFHLElBQUlDLEVBQUVMLEVBQUVFLEVBQUUsSUFBSUUsRUFBRWtGLEVBQUV2RixFQUFFLEVBQUVLLEdBQUcsSUFBSSxHQUFHQyxFQUFFQSxFQUFFLEVBQUVBLEVBQUVGLEVBQUV0SyxTQUFTd0ssRUFBRThFLEVBQUUvRSxLQUFLLElBQUksR0FBR0QsRUFBRXVMLFdBQVdyTCxHQUFHOEUsRUFBRS9FLEdBQUcsSUFBSSxHQUFHLEVBQUVGLEdBQUdDLEVBQUV0SyxPQUFPLENBQUMsSUFBRyxDQUFDLEVBQUVzTCxFQUFFLFNBQVNwQixFQUFFQyxHQUFHRCxLQUFLLEVBQUVDLEtBQUssRUFBRSxJQUFJRSxFQUFFa00sS0FBSzlHLEVBQUV2RixHQUFHLElBQUksR0FBR0csRUFBRXJLLE9BQU8sSUFBSXNLLEVBQUUsRUFBRSxPQUFPRCxFQUFFZ1EsU0FBUSxTQUFTOVAsR0FBR0QsR0FBR0MsRUFBRXZLLE9BQU8sQ0FBQyxJQUFHeVAsRUFBRXRGLEdBQUcsSUFBSSxHQUFHRyxFQUFFLENBQUMsRUFBRUgsRUFBRSxJQUFJLEdBQUdtUyxFQUFFLFdBQVcsT0FBTyxFQUFFLEVBQUU3ZCxFQUFFLFdBQVcsT0FBTyxFQUFFLEVBQUU2UixFQUFFLFNBQVNwRyxFQUFFQyxFQUFFRSxFQUFFQyxHQUFHSCxLQUFLLEVBQUVFLEtBQUssRUFBRUMsS0FBSyxFQUFFLElBQUksSUFBSUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVBLEVBQUVILEVBQUVHLElBQUksQ0FBQyxJQUFJQyxFQUFFZ0YsRUFBRXRGLEdBQUcsSUFBSSxHQUFHTyxFQUFHK0UsRUFBRXRGLEVBQUUsR0FBRyxJQUFJLEdBQUdBLEdBQUcsRUFBRSxJQUFJLElBQUlhLEVBQUUsRUFBRUEsRUFBRU4sRUFBR00sSUFBSSxDQUFDLElBQUlDLEVBQUVzRSxFQUFHOUUsRUFBRU8sSUFBSSxHQUFHRSxFQUFFOEwsR0FBRzlNLEdBQU8sSUFBSmUsR0FBVyxLQUFKQSxJQUFhLElBQUpmLEVBQU12SCxFQUFFRSxHQUFHMlMsRUFBR3RLLEVBQUUsSUFBSUEsRUFBRWxMLE9BQU8sR0FBR2tMLEVBQUVqTCxLQUFLZ0wsRUFBRSxDQUFDVixHQUFHRyxDQUFFLENBQUMsT0FBTytFLEVBQUVuRixHQUFHLElBQUksR0FBR0MsRUFBRSxDQUFDLEVBQUVnUyxFQUFFcEYsR0FBR2pOLEVBQUUsU0FBU0EsRUFBRUMsRUFBRUUsRUFBRUMsR0FBRyxPQUFPNk0sR0FBR2pOLElBQUksRUFBRUMsSUFBSSxFQUFFRSxJQUFJLEVBQUVDLElBQUksRUFBRSxJQUFHLFdBQVksU0FBU0osRUFBRUcsR0FBRyxHQUFlQSxFQUE1akssU0FBWUgsR0FBRyxJQUFTRyxFQUFMRixFQUFFLENBQUMsRUFBSSxJQUFJRSxLQUFLSCxHQUFFLFNBQVVJLEdBQUcsSUFBSUMsRUFBRUwsRUFBRUksR0FBR0gsRUFBRUcsR0FBYSxtQkFBSEMsRUFBYyxXQUFXOE8sR0FBR3BaLEtBQUtxSyxHQUFHLElBQUksT0FBT0MsRUFBRXdSLE1BQU0sS0FBS1MsVUFBVSxDQUFDLFFBQVE1TSxJQUFJeUosR0FBR29ELFFBQVFuUyxHQUFHNkUsSUFBSzlELElBQVMsSUFBTDhOLElBQW9CLElBQVpFLEdBQUdyWixTQUFhbVosR0FBRyxFQUFFRCxHQUFHd0QsV0FBV0MsT0FBTyxLQUFLQSxPQUFPQyxNQUFNLENBQUMsRUFBRXJTLENBQUUsQ0FBdk4sQ0FBeU5GLEdBQUcsT0FBT0YsQ0FBQyxDQUFxekowUyxDQUFkeFMsRUFBRUEsRUFBRTFPLFNBQWdCeVQsRUFBRS9FLEVBQXcrRSxTQUFZSCxHQUF5QixJQUFJQyxFQUFFRyxHQUFHLElBQUlBLE1BQU0sRUFBRUQsRUFBRUMsR0FBR0MsR0FBR0QsRUFBRUMsS0FBSyxFQUFFLE9BQTVETCxFQUFFcE0sT0FBTzhPLE9BQU8sQ0FBQyxFQUFFMUMsSUFBa0Q0UyxpQkFBaUIzUyxFQUFFRCxFQUFFNFMsa0JBQWtCNVMsRUFBRTZTLE9BQU8xUyxFQUFFSCxFQUFFNlMsUUFBUTdTLEVBQUU4UyxVQUFVN1MsRUFBRUQsRUFBRThTLFdBQVc5UyxFQUFFK1MsV0FBVzVTLEVBQUVILEVBQUUrUyxZQUFZL1MsQ0FBQyxDQUEvcUZnVCxDQUFHN1MsR0FBR2pILEVBQUVnTSxFQUFFSSxFQUFFSyxJQUFLVSxFQUFHSyxRQUFReEIsRUFBRStOLEdBQUdyTSxJQUFLbFMsRUFBRXdlLHdCQUF3QnhlLEVBQUV3ZSx1QkFBdUJ0TSxHQUFRLEdBQUpBLElBQWEsT0FBTEMsSUFBWXNNLGNBQWN0TSxHQUFJQSxFQUFHLE1BQU1DLEdBQUksQ0FBQyxJQUFJMUcsRUFBRTBHLEVBQUdBLEVBQUcsS0FBSzFHLEdBQUcsQ0FBQyxPQUFPRCxDQUFDLENBQUMsSUFBSUYsRUFBRSxDQUFDcE8sRUFBRTJkLElBQUksR0FBRzVJLElBQUtsUyxFQUFFd2Usd0JBQXdCeGUsRUFBRXdlLHVCQUF1QnRNLEdBQUlsUyxFQUFFMGUsZ0JBQWdCLElBQUksT0FBTzFlLEVBQUUwZSxnQkFBZ0JuVCxFQUFFRCxFQUFFLENBQUMsTUFBTUcsR0FBR3hILEVBQUUsc0RBQXNEd0gsR0FBR3JMLEVBQUVxTCxFQUFFLEVBRDcxRixTQUFZSCxFQUFFQyxHQUFHLElBQUlFLEVBQUV3RyxFQUFHLE9BQU8vTixHQUE0QyxtQkFBbENvTSxZQUFZcU8sc0JBQWtDcE0sRUFBRTlHLElBQUlBLEVBQUU4QyxXQUFXLFlBQVkvSyxHQUFpQixtQkFBUG9QLE1BQWtCRCxFQUFHbEgsRUFBRUgsRUFBRUMsR0FBR3FILE1BQU1uSCxFQUFFLENBQUNvSCxZQUFZLGdCQUFnQkMsTUFBS3BILEdBQUc0RSxZQUFZcU8scUJBQXFCalQsRUFBRUosR0FBR3dILEtBQUt2SCxHQUFFLFNBQVNJLEdBQUcsT0FBTzFILEVBQUUsa0NBQWtDMEgsR0FBRzFILEVBQUUsNkNBQTZDME8sRUFBR2xILEVBQUVILEVBQUVDLEVBQUUsS0FBRyxFQUN3L0VxVCxDQUFHclQsR0FBRSxTQUFTRSxHQUFHSCxFQUFFRyxFQUFFb1QsU0FBUyxJQUFHNUwsTUFBTTdTLEVBQU0sRUFBamUsR0FBcWVKLEVBQUU4ZSxTQUFTLENBQUN4VCxFQUFFQyxLQUFLdkwsRUFBRThlLFNBQVN0TyxFQUFFdU8sR0FBR3pULEVBQUVDLEdBQUd2TCxFQUFFZ2YsaUJBQWlCLENBQUMxVCxFQUFFQyxLQUFLdkwsRUFBRWdmLGlCQUFpQnhPLEVBQUVyTSxHQUFHbUgsRUFBRUMsR0FBR3ZMLEVBQUVpZix5QkFBeUIsQ0FBQzNULEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUVDLEVBQUdNLEVBQUVDLEtBQUtyTSxFQUFFaWYseUJBQXlCek8sRUFBRTBPLEdBQUc1VCxFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFHTSxFQUFFQyxHQUFHck0sRUFBRW1mLDRCQUE0QixDQUFDN1QsRUFBRUMsS0FBS3ZMLEVBQUVtZiw0QkFBNEIzTyxFQUFFQSxHQUFHbEYsRUFBRUMsR0FBR3ZMLEVBQUVvZiw2QkFBNkIsQ0FBQzlULEVBQUVDLEVBQUVFLEtBQUt6TCxFQUFFb2YsNkJBQTZCNU8sRUFBRTFNLEdBQUd3SCxFQUFFQyxFQUFFRSxHQUFHekwsRUFBRXFmLDBCQUEwQixDQUFDL1QsRUFBRUMsRUFBRUUsS0FBS3pMLEVBQUVxZiwwQkFBMEI3TyxFQUFFdk0sR0FBR3FILEVBQUVDLEVBQUVFLEdBQUd6TCxFQUFFc2YsMEJBQTBCaFUsSUFBSXRMLEVBQUVzZiwwQkFBMEI5TyxFQUFFK0IsR0FBR2pILEdBQUd0TCxFQUFFdWYsa0JBQWtCLENBQUNqVSxFQUFFQyxFQUFFRSxLQUFLekwsRUFBRXVmLGtCQUFrQi9PLEVBQUUzRSxHQUFHUCxFQUFFQyxFQUFFRSxHQUFHekwsRUFBRXdmLG1CQUFtQmxVLElBQUl0TCxFQUFFd2YsbUJBQW1CaFAsRUFBRVEsR0FBRzFGLEdBQUd0TCxFQUFFeWYsd0JBQXdCLENBQUNuVSxFQUFFQyxFQUFFRSxLQUFLekwsRUFBRXlmLHdCQUF3QmpQLEVBQUVrUCxHQUFHcFUsRUFBRUMsRUFBRUUsR0FBR3pMLEVBQUUyZixpQkFBaUIsQ0FBQ3JVLEVBQUVDLEtBQUt2TCxFQUFFMmYsaUJBQWlCblAsRUFBRXBFLEdBQUdkLEVBQUVDLEdBQUd2TCxFQUFFNGYsa0JBQWtCLENBQUN0VSxFQUFFQyxLQUFLdkwsRUFBRTRmLGtCQUFrQnBQLEVBQUVuRSxHQUFHZixFQUFFQyxHQUFHdkwsRUFBRTZmLFNBQVN2VSxJQUFJdEwsRUFBRTZmLFNBQVNyUCxFQUFFN0UsR0FBR0wsR0FBR3RMLEVBQUU4ZixpQkFBaUIsQ0FBQ3hVLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEVBQUVDLEtBQUs1TCxFQUFFOGYsaUJBQWlCdFAsRUFBRTVNLEdBQUcwSCxFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxHQUFHNUwsRUFBRStmLGtCQUFrQixDQUFDelUsRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsS0FBSzNMLEVBQUUrZixrQkFBa0J2UCxFQUFFd1AsSUFBSTFVLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEdBQUczTCxFQUFFaWdCLGtCQUFrQjNVLElBQUl0TCxFQUFFaWdCLGtCQUFrQnpQLEVBQUUwUCxJQUFJNVUsR0FBR3RMLEVBQUVtZ0IscUJBQXFCLENBQUM3VSxFQUFFQyxFQUFFRSxFQUFFQyxLQUFLMUwsRUFBRW1nQixxQkFBcUIzUCxFQUFFNFAsSUFBSTlVLEVBQUVDLEVBQUVFLEVBQUVDLEdBQUcxTCxFQUFFcWdCLHNCQUFzQixDQUFDL1UsRUFBRUMsRUFBRUUsS0FBS3pMLEVBQUVxZ0Isc0JBQXNCN1AsRUFBRThQLElBQUloVixFQUFFQyxFQUFFRSxHQUFHekwsRUFBRXVnQixzQkFBc0JqVixJQUFJdEwsRUFBRXVnQixzQkFBc0IvUCxFQUFFZ1EsSUFBSWxWLEdBQUd0TCxFQUFFeWdCLGtCQUFrQm5WLElBQUl0TCxFQUFFeWdCLGtCQUFrQmpRLEVBQUVrUSxJQUFJcFYsR0FBR3RMLEVBQUV1TixjQUFjLENBQUNqQyxFQUFFQyxFQUFFRSxLQUFLekwsRUFBRXVOLGNBQWNpRCxFQUFFbVEsSUFBSXJWLEVBQUVDLEVBQUVFLEdBQUd6TCxFQUFFNGdCLGVBQWUsQ0FBQ3RWLEVBQUVDLEVBQUVFLEVBQUVDLEtBQUsxTCxFQUFFNGdCLGVBQWVwUSxFQUFFcVEsSUFBSXZWLEVBQUVDLEVBQUVFLEVBQUVDLEdBQUcxTCxFQUFFOGdCLHNCQUFzQnhWLElBQUl0TCxFQUFFOGdCLHNCQUFzQnRRLEVBQUV1USxJQUFJelYsR0FBR3RMLEVBQUVnaEIsbUJBQW1CMVYsSUFBSXRMLEVBQUVnaEIsbUJBQW1CeFEsRUFBRXhPLElBQUlzSixHQUFHdEwsRUFBRXNOLG1CQUFtQixDQUFDaEMsRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsS0FBSzNMLEVBQUVzTixtQkFBbUJrRCxFQUFFeVEsSUFBSTNWLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEdBQUczTCxFQUFFcU4sUUFBUSxDQUFDL0IsRUFBRUMsRUFBRUUsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsRUFBRUMsS0FBTTlMLEVBQUVxTixRQUFRbUQsRUFBRTBRLElBQUk1VixFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxHQUFJOUwsRUFBRW1oQixpQkFBaUI3VixJQUFJdEwsRUFBRW1oQixpQkFBaUIzUSxFQUFFNFEsSUFBSTlWLEdBQUd0TCxFQUFFcWhCLFlBQVksQ0FBQy9WLEVBQUVDLEVBQUVFLEtBQUt6TCxFQUFFcWhCLFlBQVk3USxFQUFFOFEsSUFBSWhXLEVBQUVDLEVBQUVFLEdBQUd6TCxFQUFFdWhCLGlCQUFpQmpXLElBQUl0TCxFQUFFdWhCLGlCQUFpQi9RLEVBQUVnUixJQUFJbFcsR0FBRyxJQUFnbUJtVyxHQUE1bEJsSyxHQUFHdlgsRUFBRTBoQixRQUFRcFcsSUFBSWlNLEdBQUd2WCxFQUFFMGhCLFFBQVFsUixFQUFFbVIsSUFBSXJXLEdBQUdrUSxHQUFHeGIsRUFBRTRoQixNQUFNdFcsSUFBSWtRLEdBQUd4YixFQUFFNGhCLE1BQU1wUixFQUFFN1MsSUFBSTJOLEdBQUd5UixHQUFHelIsSUFBSXlSLEdBQUd2TSxFQUFFcVIsSUFBSXZXLEdBQUd3VyxHQUFHLEtBQUtBLEdBQUd0UixFQUFFdVIsTUFBTUMsR0FBRzFXLElBQUkwVyxHQUFHeFIsRUFBRXlSLElBQUkzVyxHQUFHNFcsR0FBRzVXLElBQUk0VyxHQUFHMVIsRUFBRTJSLElBQUk3VyxHQUFHZ1EsR0FBR2hRLElBQUlnUSxHQUFHOUssRUFBRTRSLElBQUk5VyxHQUFHd1MsR0FBRyxLQUFLQSxHQUFHdE4sRUFBRTZSLE1BQU10SCxHQUFHelAsSUFBSXlQLEdBQUd2SyxFQUFFOFIsSUFBSWhYLEdBQUdpUSxHQUFHLEtBQUtBLEdBQUcvSyxFQUFFK1IsTUFBd2EsU0FBU0MsS0FBSyxTQUFTbFgsSUFBSSxJQUFJbVcsS0FBS0EsSUFBRyxFQUFHemhCLEVBQUV5aUIsV0FBVSxHQUFJelIsR0FBRyxDQUFDLEdBQUdzRixFQUFHM0UsR0FBSXhVLEVBQUU2QyxHQUFHQSxFQUFFMGlCLHNCQUFzQjFpQixFQUFFMGlCLHVCQUF1QjFpQixFQUFFMmlCLFFBQVEsSUFBc0IsbUJBQVgzaUIsRUFBRTJpQixVQUFzQjNpQixFQUFFMmlCLFFBQVEsQ0FBQzNpQixFQUFFMmlCLFVBQVUzaUIsRUFBRTJpQixRQUFRdmhCLFFBQVEsQ0FBQyxJQUFJbUssRUFBRXZMLEVBQUUyaUIsUUFBUTVRLFFBQVFILEVBQUdJLFFBQVF6RyxFQUFFLENBQUMrSyxFQUFHMUUsRUFBRyxDQUFDLENBQUMsS0FBSyxFQUFFTSxHQUFJLENBQUMsR0FBR2xTLEVBQUU4UixPQUFPLElBQXFCLG1CQUFWOVIsRUFBRThSLFNBQXFCOVIsRUFBRThSLE9BQU8sQ0FBQzlSLEVBQUU4UixTQUFTOVIsRUFBRThSLE9BQU8xUSxRQUFReVEsSUFBS3lFLEVBQUc1RSxHQUFHLEVBQUVRLElBQUtsUyxFQUFFNGlCLFdBQVc1aUIsRUFBRTRpQixVQUFVLGNBQWNDLFlBQVcsV0FBV0EsWUFBVyxXQUFXN2lCLEVBQUU0aUIsVUFBVSxHQUFHLEdBQUUsR0FBR3RYLEdBQUcsR0FBRSxJQUFJQSxJQUFJLENBQUMsQ0FBQyxHQUE3NEJ0TCxFQUFFOGlCLGVBQWUsT0FBTzlpQixFQUFFK2lCLGNBQWMsT0FBaU4vaUIsRUFBRXFlLFdBQVc2RCxHQUFHbGlCLEVBQUVvZSxVQUFVMEQsR0FBRzloQixFQUFFZ2pCLGFBQWFoQixHQUFHaGlCLEVBQUVpakIsYUFBYXpPLEdBQUd4VSxFQUFFa2pCLGFBQWEsQ0FBQzVYLEVBQUVDLEVBQUVFLElBQUl5TCxHQUFHNUwsRUFBRXFGLEVBQUdwRixFQUFFRSxHQUFHekwsRUFBRW1qQixnQkFBZ0JuTSxHQUFVNUUsRUFBRyxTQUFTOUcsSUFBSW1XLElBQUllLEtBQUtmLEtBQUtyUCxFQUFHOUcsRUFBRSxFQUFnZnRMLEVBQUVvakIsUUFBUSxJQUFzQixtQkFBWHBqQixFQUFFb2pCLFVBQXNCcGpCLEVBQUVvakIsUUFBUSxDQUFDcGpCLEVBQUVvakIsVUFBVSxFQUFFcGpCLEVBQUVvakIsUUFBUWhpQixRQUFRcEIsRUFBRW9qQixRQUFRdkYsS0FBVjdkLEdBQWtCLE9BQU93aUIsS0FBSzNpQixFQUFFd0wsS0FBSyxHQUFpQixpQkFBSkwsR0FBeUIsaUJBQUpDLEVBQWFBLEVBQUdsTyxRQUFRbU8sT0FBMEQsS0FBUCxPQUFLQSxHQUFFLFFBQVQsT0FBUyxnQkFBUW1ZLEdBQUd2akIsR0FBRyxTQUFZd2pCLEdBQUd4akIsR0FBRyxTQUFZeWpCLEdBQUcsQ0FBQyxFQUFFeGpCLEVBQUd3akIsR0FBRyxDQUFDQyxLQUFLLElBQUlDLEtBQUssSUFBSUEsR0FJczZGQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFvNERDLEdBQUdDLEdBQUdDLEdBQTh2QkMsR0FBZy9CQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUF3bEdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQXNzREMsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBNFBDLEdBQTBGQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUF3dklDLEdBQUdDLEdBQTZPQyxHQUFHQyxHQUFHekssR0FBRTBLLEdBQUdDLEdBQUdDLEdBQUdDLEdBQStxSkMsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR3ZKLEdBQUUrQixHQUFFeUgsR0FBR0MsR0FBR0MsR0FBR0MsR0F1Q3p4OEJDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBY29PQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQXVDZ25CQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQXdCMlRDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBVS93Q0MsR0FBR0MsR0FBR0MsR0FTMUpDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBa0Nvc0NDLEdBQUdDLEdBQUdDLEdBa0J0ekNDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBdUQ2WkMsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0EwQjdRQyxHQUFHQyxHQUFHQyxHQUlyUEMsR0FTTkMsR0FBR0MsR0FBOHVCQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQXdScGpCQyxHQUFHQyxHQXFHM0l4UCxHQTBDMkd1QixHQUFHa08sR0FBR0MsR0FBR0MsR0FBRzdPLEdBQUc4TyxHQUFHQyxHQUFHclEsR0FBMGlIc1EsR0FBR0MsR0ErR3pxSEMsR0FBR2hQLEdBNEtrVWlQLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQTh0SW5RLEdBQUdvUSxHQUFHQyxHQUFNQyxHQUFHeFAsR0FBR0ksR0FBR3FQLEdBQUdDLEdBQUdDLEdBVzkySUMsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FldEdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBY3dCQyxHQUFHQyxHQUFHQyxHQUFHQyxHQStCTEMsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0EwQjFDQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQXlJc0ZDLEdBQUdDLEdBQUdDLEdBQUdDLEdBaUNxQ0MsR0FBR0MsR0FBcWJDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBeUVDQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQWdHN0tDLEdBQUdDLEdBQUdDLEdBSzVKQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQW9MdUpDLEdBQUdDLEdBQUdDLEdBQUdDLEdBK0J4UEMsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0E0QjNOQyxHQUFHQyxHQUFHQyxHQUFHQyxHQTRFM1BDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBQUdDLEdBMkJvVkMsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FhMU9DLEdBQUdDLEdBQUdDLEdBMkI2TUMsR0FBOG9EQyxHQUc1OENDLEdBQUdDLEdBQUdDLEdBenhEbzRSQyxHQUFHOTRCLEdBQUUsS0FBSzhqQixRQUFHLENBQUssSUFBUWlWLEdBQUc1NEIsR0FBRyxDQUFDNjRCLEVBQUdDLEtBQW1CLElBQWlCaDVCLEVBQWJpNUIsR0FBNEhqNUIsR0FBL0dBLFNBQVM4QyxTQUFTLEtBQUtBLFNBQVN5SSxjQUFjekksU0FBU3lJLGNBQWM1RixTQUFJLElBQTJDNkYsRUFBWSxTQUFTdkwsRUFBRSxDQUFDLEdBQUcsU0FBU0csSUFBSSxPQUFPaVIsRUFBR3RDLFFBQVF1RCxFQUFHdkQsUUFBUTZELElBQUtOLENBQUUsQ0FBQyxTQUFTL1UsSUFBSSxPQUFPOFQsRUFBR3RDLFFBQVF1RCxFQUFHdkQsUUFBUTZELElBQUtMLENBQUUsQ0FBQyxTQUFTL1IsSUFBSSxPQUFPNlEsRUFBR3RDLFFBQVF1RCxFQUFHdkQsUUFBUTZELElBQUtKLENBQUUsQ0FBQyxTQUFTalIsSUFBSSxPQUFPOFAsRUFBR3RDLFFBQVF1RCxFQUFHdkQsUUFBUTZELElBQUtqQyxDQUFFLENBQUMsU0FBUzdPLElBQUksT0FBT3VQLEVBQUd0QyxRQUFRdUQsRUFBR3ZELFFBQVE2RCxJQUFLRCxDQUFDLENBQUMsU0FBU25QLElBQUksT0FBTzZOLEVBQUd0QyxRQUFRdUQsRUFBR3ZELFFBQVE2RCxJQUFLUCxDQUFFLENBQUMsSUFBUS9PLEVBQUVNLEVBQU5QLEVBQUVwRCxFQUFNb0QsRUFBRW9JLE1BQU0sSUFBSWpHLFNBQVEsQ0FBQ2hJLEVBQUVrZ0IsS0FBS3BhLEVBQUU5RixFQUFFb0csRUFBRThaLEtBQUlyYSxFQUFFdUksU0FBUyxDQUFDcE8sRUFBRWtnQixFQUFFRixFQUFFckIsRUFBRUQsRUFBRTRCLEVBQUVhLEVBQUV1YSxLQUFNNzFCLEVBQUU4MUIsR0FBRzM3QixFQUFFNkYsRUFBRSsxQixHQUFHMWIsRUFBRXJhLEVBQUVnMkIsR0FBRzdiLEVBQUVuYSxFQUFFaTJCLEdBQUduZCxFQUFFOVksRUFBRWsyQixHQUFHcmQsRUFBRTdZLEVBQUV1VyxHQUFHa0UsRUFBRXphLEVBQUVtMkIsR0FBRzdhLEVBQUV0YixFQUFFbzJCLEdBQUdQLEVBQUd4YixFQUFFLENBQUNnYyxFQUFHcGEsRUFBRXFhLElBQUssSUFBSUMsS0FBTSxJQUFJQyxFQUFHQyxHQUFHM2EsRUFBRUcsTUFBTXNhLEVBQUdGLEtBQU1FLEdBQUksSUFBSUcsRUFBR3phLE1BQU0sT0FBT0gsSUFBSTRhLElBQUtMLEVBQUdLLEVBQUdKLEVBQUd4YSxHQUFHRyxFQUFFcWEsRUFBRyxNQUFNRyxJQUFJRCxFQUl2bVMsSUFBSXIwQixTQUFRLENBQUNoSSxFQUFFa2dCLEtBQUtzYyxHQUFHLENBQUMvc0IsUUFBUXpQLEVBQUUwUCxPQUFPd1EsRUFBQyxJQUpxa1NrYyxHQUFJcGMsRUFBRWtjLEdBQUloNEIsU0FBUzRkLEtBQUssSUFBSSxHQUFHamMsRUFBRTQyQixHQUFHLE1BQU03NEIsTUFBTSwyQkFBMkIsSUFBSXU0QixFQUFHdDJCLEVBQUU0MkIsR0FBRyxDQUFDQyxHQUFHNWEsRUFBRSxHQUFHalMsT0FBTyxJQUFJdXNCLFFBQVNGLEtBQU1wYSxHQUFHLEdBQUdqYyxFQUFFNDJCLEtBQUtOLEVBQUcsTUFBTXY0QixNQUFNLG9CQUFvQjVELEVBQUU4UCxRQUFRLElBQUl1c0IsRUFBR0YsRUFBR3RzQixPQUFPLEdBQUcsRUFBRXdzQixFQUFHcjRCLE9BQU8sQ0FBQyxJQUFJMmQsUUFBUTNaLFFBQVErSCxJQUFJc3NCLEdBQUksR0FBRzFhLEVBQUVBLEVBQUUzUixRQUFPdXNCLEdBQUlBLElBQUksRUFBRTVhLEVBQUUzZCxPQUFPLE1BQU1KLE1BQU0rZCxFQUFFamQsS0FBSyxNQUMzaVYsQ0FBQyxPQUFPMDNCLENBQUUsQ0FBQyxRQUFRdjJCLEVBQUU0MkIsR0FBRyxJQUFJLEdBQUc1MkIsRUFBRW9LLFFBQVErUCxFQUFFRSxFQUFFcmEsRUFBRW9LLFNBQVEsSUFBSXBLLEVBQUVvSyxVQUFRaXNCLEdBQUlyMkIsRUFBRW9LLFFBQVFpc0IsS0FBS3IyQixFQUFFcUssbUJBQW1COFAsRUFBRUUsRUFBRXJhLEVBQUVxSyxvQkFBbUIsSUFBSXJLLEVBQUVxSyxxQkFBbUJnc0IsR0FBSXIyQixFQUFFcUssbUJBQW1CZ3NCLEtBQUtyMkIsRUFBRXNLLGNBQWMrUCxFQUFFcmEsRUFBRXNLLGVBQWMsSUFBSXRLLEVBQUVzSyxnQkFBYytyQixHQUFJcjJCLEVBQUVzSyxjQUFjK3JCLElBQUlyMkIsRUFBRXVLLG1CQUFtQixDQUFDOHJCLEVBQUdwYSxFQUFFcWEsRUFBR0MsSUFBS3A4QixFQUFFcVEsZUFBZTZyQixFQUFHcGEsRUFBRXFhLEVBQUdDLEdBQUl2MkIsRUFBRXlLLHNCQUFzQjRyQixJQUFLbDhCLEVBQUV1USxrQkFBa0IyckIsRUFBRSxFQUFHcjJCLEVBQUUySyxjQUFjMHJCLEdBQUlsOEIsRUFBRXlRLFVBQVV5ckIsR0FBSXIyQixFQUFFNksscUJBQXFCLENBQUN3ckIsRUFBR3BhLEVBQUVxYSxJQUFLbjhCLEVBQUUyUSxpQkFBaUJ1ckIsRUFBR3BhLEVBQUVxYSxFQUFFLEVBQUcsSUFBbVVwMUIsRUFBRUssRUFBRWdNLEVBQW5VL00sRUFBRXZFLE9BQU84TyxPQUFPLENBQUMsRUFBRS9LLEdBQUdTLEVBQUUsaUJBQWlCQyxFQUFFLENBQUN2RyxFQUFFa2dCLEtBQUssTUFBTUEsR0FBRzFaLEVBQWlCLGlCQUFScUssT0FBaUJwSyxFQUF3QixtQkFBZnFLLGNBQTBCcEssRUFBa0IsaUJBQVRxSyxTQUE0QyxpQkFBbEJBLFFBQVE5TCxVQUFrRCxpQkFBdkI4TCxRQUFROUwsU0FBUytMLEtBQWVySyxFQUFFZCxFQUFFODJCLHlCQUF3QixFQUFHOTFCLEVBQUUsR0FBRyxTQUFTQyxFQUFFOUcsR0FBRyxPQUFPNkYsRUFBRXdQLFdBQVd4UCxFQUFFd1AsV0FBV3JWLEVBQUU2RyxHQUFHQSxFQUFFN0csQ0FBQyxDQUFXLEdBQUcwRyxFQUFFLENBQUMsSUFBSWtOLEdBQUdyRyxLQUFLeEssRUFBR3FLLEtBQUtpRyxHQUFHM0YsS0FBSzNLLEVBQUd5SyxLQUFxZixJQUFJeE4sRUFBcGY2RyxFQUFFSixFQUFFNE0sRUFBRXBDLFFBQVFwSyxHQUFHLElBQUlxSyxLQUFjbkssRUFBRSxDQUFDbVosRUFBRUYsS0FBS0UsRUFBRUEsRUFBRS9PLFdBQVcsV0FBVyxJQUFJQyxJQUFJOE8sR0FBRzdNLEVBQUVoQyxVQUFVNk8sR0FBR3RNLEVBQUV0QyxhQUFhNE8sRUFBRUYsT0FBRSxFQUFPLFNBQVM1TSxFQUFFOE0sS0FBSUEsRUFBRW5aLEVBQUVtWixHQUFFLElBQU0zTyxTQUFTMk8sRUFBRSxJQUFJcFgsV0FBV29YLElBQUlBLEdBQUc5WSxFQUFFLENBQUM4WSxFQUFFRixFQUFFckIsRUFBRUQsR0FBRSxLQUFNd0IsRUFBRUEsRUFBRS9PLFdBQVcsV0FBVyxJQUFJQyxJQUFJOE8sR0FBRzdNLEVBQUVoQyxVQUFVNk8sR0FBR3RNLEVBQUV2RyxTQUFTNlMsRUFBRXhCLE9BQUUsRUFBTyxRQUFPLENBQUM0QixFQUFFYSxLQUFLYixFQUFFM0IsRUFBRTJCLEdBQUdOLEVBQUV0QixFQUFFeUMsRUFBRTVQLE9BQU80UCxFQUFDLEdBQUUsR0FBSXRiLEVBQUUyTCxhQUFhLEVBQUVULFFBQVFVLEtBQUt6TixTQUFTc0MsRUFBRXlLLFFBQVFVLEtBQUssR0FBR0MsUUFBUSxNQUFNLE1BQU1YLFFBQVFVLEtBQUtFLE1BQU0sR0FBR3BMLEVBQUUsQ0FBQzJaLEVBQUVGLEtBQUssTUFBTWpQLFFBQVFhLFNBQVNzTyxFQUFFRixHQUFHbmEsRUFBRWdNLFFBQVEsSUFBSSw2QkFBbUMsSUFBSTdSLEVBQUVpbUIsSUFBSSxDQUFDLE1BQU0vRixHQUFHLE1BQU14TixRQUFRSSxNQUFNLDJHQUEyR29OLENBQUMsQ0FBQyxFQUFBNVosRUFBT3MyQixPQUFPNThCLEVBQUU0OEIsTUFBTSxNQUFNcDJCLEdBQUdDLEtBQUtBLEVBQUVJLEVBQUU1RyxLQUFLdUksU0FBU3NKLFlBQVl4TSxTQUFTLEtBQUtBLFNBQVN5SSxnQkFBZ0JsSCxFQUFFdkIsU0FBU3lJLGNBQWM1RixZQUFZM0YsRUFBRSxLQUFLQSxJQUFJcUUsRUFBRXJFLEdBQTBCcUUsRUFBRixJQUFyQkEsRUFBRWhELFFBQVEsU0FBZWdELEVBQUVrTCxPQUFPLEVBQUVsTCxFQUFFNkssUUFBUSxTQUFTLElBQUlNLFlBQVksS0FBSyxHQUFLLEdBQUd0TCxJQUFJSyxFQUFFL0csSUFBSSxJQUFJa2dCLEVBQUUsSUFBSWpPLGVBQWUsT0FBT2lPLEVBQUVoTyxLQUFLLE1BQU1sUyxHQUFFLEdBQUlrZ0IsRUFBRS9OLEtBQUssTUFBTStOLEVBQUU5TixjQUFjM0wsSUFBSTJNLEVBQUVwVCxJQUFJLElBQUlrZ0IsRUFBRSxJQUFJak8sZUFBZSxPQUFPaU8sRUFBRWhPLEtBQUssTUFBTWxTLEdBQUUsR0FBSWtnQixFQUFFN04sYUFBYSxjQUFjNk4sRUFBRS9OLEtBQUssTUFBTSxJQUFJckosV0FBV29YLEVBQUU1TixTQUFRLEdBQUlsTCxFQUFFLENBQUNwSCxFQUFFa2dCLEVBQUVGLEtBQUssSUFBSXJCLEVBQUUsSUFBSTFNLGVBQWUwTSxFQUFFek0sS0FBSyxNQUFNbFMsR0FBRSxHQUFJMmUsRUFBRXRNLGFBQWEsY0FBY3NNLEVBQUV2VyxPQUFPLEtBQWUsS0FBVnVXLEVBQUVwTSxRQUF1QixHQUFWb00sRUFBRXBNLFFBQVdvTSxFQUFFck0sU0FBUzROLEVBQUV2QixFQUFFck0sVUFBVTBOLEdBQUUsRUFBR3JCLEVBQUVuTSxRQUFRd04sRUFBRXJCLEVBQUV4TSxLQUFLLEtBQUksSUFBS3pMLFVBQVV5WixZQUFZLE1BQU0sRUFBQTdaLEVBQU82WixZQUFZK0YsS0FBSy9GLGFBQWEsSUFBSTdNLEVBQUVaLFFBQVFDLElBQUlDLEtBQUtGLFNBQVNhLEVBQUdiLFFBQVFJLE1BQU1GLEtBQUtGLFNBQVNoTSxJQUFJNE0sRUFBRSxJQUFJdFQsSUFBSTRULEVBQUVpcEIsVUFBVSxFQUFFNzhCLEVBQUUwRSxLQUFLLEtBQUssTUFDbnhFNk8sRUFBRyxJQUFJdlQsSUFBSTRULEVBQUVpcEIsVUFBVSxFQUFFNzhCLEVBQUUwRSxLQUFLLEtBQUssT0FDcEMsSUFBb0hnUCxFQUFoSEYsRUFBRTNOLEVBQUU0TSxPQUFPYSxFQUFFRyxFQUFFNU4sRUFBRWdOLFVBQVVVLEVBQUd6UixPQUFPOE8sT0FBTy9LLEVBQUVRLEdBQUdBLEVBQUUsS0FBS1IsRUFBRTJMLGNBQWNsTCxFQUFFVCxFQUFFMkwsYUFBYTNMLEVBQUVrTixPQUFPeE0sRUFBRVYsRUFBRWtOLE1BQWFsTixFQUFFbU4sYUFBYVUsRUFBRzdOLEVBQUVtTixZQUFZLElBQUlXLEVBQUc5TixFQUFFb04sZ0JBQWUsRUFBdUIsaUJBQWJDLGFBQXVCb0csR0FBRyxtQ0FBbUMsSUFBSXpGLEVBQUdTLEVBQUVDLEVBQVNFLEVBQUdLLEVBQUdDLEVBQUdDLEVBQUc3QixFQUFHZ0MsRUFBRU4sRUFBdkJMLEdBQUcsRUFBdUIsU0FBU1ksSUFBSyxJQUFJcFYsRUFBRTZULEVBQUd0QyxPQUFPMUwsRUFBRWlPLE1BQU1nQixFQUFHLElBQUkvTCxVQUFVL0ksR0FBRzZGLEVBQUVrTyxPQUFPLElBQUk5SyxXQUFXakosR0FBRzZGLEVBQUVtTyxPQUFPZ0IsRUFBRyxJQUFJOUwsV0FBV2xKLEdBQUc2RixFQUFFb08sT0FBT2MsRUFBRyxJQUFJak0sV0FBVzlJLEdBQUc2RixFQUFFcU8sUUFBUSxJQUFJbEwsWUFBWWhKLEdBQUc2RixFQUFFc08sUUFBUWhCLEVBQUcsSUFBSS9KLFlBQVlwSixHQUFHNkYsRUFBRXVPLFFBQVFlLEVBQUUsSUFBSTNOLGFBQWF4SCxHQUFHNkYsRUFBRXdPLFFBQVFRLEVBQUcsSUFBSTFMLGFBQWFuSixFQUFFLENBQUMsSUFBSXNWLEVBQUd6UCxFQUFFaTNCLGdCQUFnQixTQUFTLEdBQUcsU0FBU3huQixHQUFJZ0UsR0FBRyx3REFBd0RoRSxFQUFHLDBCQUEwQjNPLEVBQUVrTixFQUFHaE8sRUFBRWszQixnQkFBZ0IsR0FBR2wzQixFQUFFazNCLFdBQVdscEIsRUFBR2hPLEVBQUVrM0IsZ0JBQWdCLE1BQUdscEIsRUFBRyxJQUFJWCxZQUFZOHBCLE9BQU8sQ0FBQ0MsUUFBUTNuQixFQUFHLE1BQU00bkIsUUFBUSxNQUFNQyxRQUFPLEtBQVU1ckIsa0JBQWtCN0YsbUJBQW1CLE1BQU0rSCxFQUFFLCtOQUErTi9NLEdBQUcrTSxFQUFFLDZHQUE2RzdQLE1BQU0sY0FBY3dSLElBQUtFLEVBQUd6QixFQUFHdEMsT0FBTzVGLFdBQVcsSUFBSW1LLEVBQUcsR0FBR1AsRUFBRyxHQUFHaU0sRUFBRyxHQUFHeEwsRUFBRyxFQUFFLFNBQVNDLElBQUssT0FBT3RDLEdBQUksRUFBRXFDLENBQUUsQ0FBQyxJQUE4ZW9CLEVBQTFlNEIsRUFBRyxFQUFFRSxFQUFHLEtBQUtDLEdBQUcsS0FBSyxTQUFTaWtCLEtBQUtwa0IsSUFBS25ULEVBQUV1Yix3QkFBd0J2YixFQUFFdWIsdUJBQXVCcEksRUFBRyxDQUFDLFNBQVNxa0IsS0FBSyxHQUFHcmtCLElBQUtuVCxFQUFFdWIsd0JBQXdCdmIsRUFBRXViLHVCQUF1QnBJLEdBQVEsR0FBSkEsSUFBYSxPQUFMRSxJQUFZbUksY0FBY25JLEdBQUlBLEVBQUcsTUFBTUMsSUFBSSxDQUFDLElBQUluWixFQUFFbVosR0FBR0EsR0FBRyxLQUFLblosR0FBRyxDQUFDLENBQUMsU0FBU3NaLEdBQUd0WixHQUFHLE1BQU02RixFQUFFb1AsU0FBU3BQLEVBQUVvUCxRQUFRalYsR0FBc0J5VCxFQUFuQnpULEVBQUUsV0FBV0EsRUFBRSxLQUFTd1UsR0FBRyxFQUFHQyxFQUFHLEVBQUV6VSxFQUFFLElBQUlrVCxZQUFZZ0MsYUFBYWxWLEVBQUUsNENBQTRDb0csRUFBRXBHLEdBQUdBLENBQUMsQ0FBQyxTQUFTd1osR0FBR3haLEdBQUcsT0FBT0EsRUFBRW1SLFdBQVcsd0NBQXdDLENBQTRELFNBQVN5SSxHQUFHNVosR0FBRyxHQUFHQSxHQUFHb1gsR0FBSTFELEVBQUcsT0FBTyxJQUFJNUssV0FBVzRLLEdBQUksR0FBR04sRUFBRSxPQUFPQSxFQUFFcFQsR0FBRyxLQUFLLGlEQUFpRCxDQUEwVixTQUFTK1osR0FBRy9aLEVBQUVrZ0IsRUFBRUYsR0FBRyxPQUE1VyxTQUFZaGdCLEdBQUcsSUFBSTBULElBQUtsTixHQUFHQyxHQUFHLENBQUMsR0FBaUIsbUJBQVArTyxRQUFvQnhWLEVBQUVtUixXQUFXLFdBQVcsT0FBT3FFLE1BQU14VixFQUFFLENBQUN5VixZQUFZLGdCQUFnQkMsTUFBS3dLLElBQUksSUFBSUEsRUFBRXZLLEdBQUcsS0FBSyx1Q0FBdUMzVixFQUFFLElBQUksT0FBT2tnQixFQUFFdEssYUFBWSxJQUFJQyxPQUFNLElBQUkrRCxHQUFHNVosS0FBSSxHQUFHb0gsRUFBRSxPQUFPLElBQUlZLFNBQVEsQ0FBQ2tZLEVBQUVGLEtBQUs1WSxFQUFFcEgsR0FBRTJlLEdBQUd1QixFQUFFLElBQUlwWCxXQUFXNlYsS0FBSXFCLEVBQUMsR0FBRyxDQUFDLE9BQU9oWSxRQUFReUgsVUFBVWlHLE1BQUssSUFBSWtFLEdBQUc1WixJQUFHLENBQTJCOFosQ0FBRzlaLEdBQUcwVixNQUFLaUosR0FBR3pMLFlBQVk2QyxZQUFZNEksRUFBRXVCLEtBQUl4SyxNQUFLaUosR0FBR0EsSUFBR2pKLEtBQUtzSyxHQUFFckIsSUFBSWxMLEVBQUUsMENBQTBDa0wsR0FBR3JGLEdBQUdxRixFQUFDLEdBQUcsQ0FBNW5CbkYsR0FBakNwQyxFQUFHLGlDQUF1Q0EsRUFBR3RRLEVBQUVzUSxJQUErOUIsSUFBSTZDLEdBQUdDLEdBQUcsQ0FBQyxPQUFPbGEsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxRQUFRcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE9BQU9wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsYUFBYXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxVQUFVcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxNQUFNcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsT0FBT3BjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE9BQU9wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsT0FBT3BjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLFFBQVFwYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsUUFBUXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxRQUFRcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE9BQU9wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFH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RUFDZms0QyxFQUFPaDRDLE9BQVNBLEVBQ2hCLElBQUl5NkMsRUFBTXpDLEVBQU8vM0MsV0FBVyxNQUM1QitNLFFBQVFDLElBQUksNkJBQTZCb3NDLEVBQUlyNUMsd0JBQXdCcTVDLEVBQUl2NUMsU0FDekUyNkMsRUFBSXI0QyxVQUFVaTNDLEVBQUssRUFBRyxFQUFHdjVDLEVBQU9FLEdBRWhDbTRDLEVBQWlCc0MsRUFBSXA0QyxhQUFhLEVBQUcsRUFBR3ZDLEVBQU9FLEdBRS9DLE1BQU0wNkMsUUFBa0JsQyxFQUFtQkwsR0FJM0NsckMsRUFBSSw4QkFBOEJ5dEMsRUFBVTM2QyxXQUM1Q2tOLEVBQUksZ0NBQWdDeXRDLEVBQVV4NUMsS0FBSytLLE1BQU0sSUFBSyxXQUU5RCxNQUFNMHVDLEVBQU8sQ0FBRSxVQUFXRCxHQUNwQnI4QyxRQUFVKzVDLEVBQUssR0FFUDM5QixZQUFZRixNQUMxQnZOLFFBQVFDLElBQUksYUFBYzVPLEdBQzFCNjVDLFFBQXlCNzVDLEVBQUVxSCxJQUFJaTFDLEdBRS9CLE1BQU1DLFFBaE1WcDhDLGVBQWdDcThDLEdBQzVCLElBQUtDLE9BQU9ELEVBQ1I1dEMsRUFBSSxVQUFVNnRDLFNBQVNELEVBQWVDLFFBRTFDLE9BQU9ELEVBQWVDLElBQzFCLENBMkwrQkMsQ0FBaUI3QyxHQUM1QzhDLE1BQVFKLEVBQXNCLFFBQzlCSyxTQUFXOWpDLEtBQUsxRyxPQUFPdXFDLE9BQ3ZCRSxPQUFTRixNQUFNNzhDLFFBQVE4OEMsVUFFdkJaLEVBQW1CL0IsVUFBWSxVQUFVNEMsMkJBQTJCRixXQUVwRS9DLEVBQU9xQyxVQUFXLENBQ3RCLENBcUhtQ2EsQ0FBWTlCLEdBQy9CQSxFQUFJNTJDLElBQU0yM0MsRUFBV2dCLE1BQU0sRUFFL0JoQixFQUFXaUIsY0FBY3BCLEVBQU0sR0FDbkMsQ0FDSixDQUVKLENBRXNEcUIsRUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL29ydC1zYW0vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL29ydC1zYW0vLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3QvY2pzL29ydC53ZWJncHUubWluLmpzIiwid2VicGFjazovL29ydC1zYW0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vb3J0LXNhbS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL29ydC1zYW0vLi9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gIiwiLyohXG4gKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjE3LjAtZGV2LjIwMjMxMTAzLTE0MzlkYTM2ZmVcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cInVzZSBzdHJpY3RcIjt2YXIgX249T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBrbD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBCbD1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgTWw9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgTD0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBMdD0oZSx0KT0+KCk9Pih0fHxlKCh0PXtleHBvcnRzOnt9fSkuZXhwb3J0cyx0KSx0LmV4cG9ydHMpLGt0PShlLHQpPT57Zm9yKHZhciByIGluIHQpX24oZSxyLHtnZXQ6dFtyXSxlbnVtZXJhYmxlOiEwfSl9LERsPShlLHQscixhKT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgbiBvZiBCbCh0KSkhTWwuY2FsbChlLG4pJiZuIT09ciYmX24oZSxuLHtnZXQ6KCk9PnRbbl0sZW51bWVyYWJsZTohKGE9a2wodCxuKSl8fGEuZW51bWVyYWJsZX0pO3JldHVybiBlfTt2YXIgdnQ9ZT0+RGwoX24oe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZSk7dmFyIFdyLEJ0LGZ0LE5yLFZyPUwoKCk9PntcInVzZSBzdHJpY3RcIjtXcj1uZXcgTWFwLEJ0PVtdLGZ0PShlLHQscik9PntpZih0JiZ0eXBlb2YgdC5pbml0PT1cImZ1bmN0aW9uXCImJnR5cGVvZiB0LmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyPT1cImZ1bmN0aW9uXCIpe2xldCBhPVdyLmdldChlKTtpZihhPT09dm9pZCAwKVdyLnNldChlLHtiYWNrZW5kOnQscHJpb3JpdHk6cn0pO2Vsc2V7aWYoYS5wcmlvcml0eT5yKXJldHVybjtpZihhLnByaW9yaXR5PT09ciYmYS5iYWNrZW5kIT09dCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtlfVwiIHVzaW5nIHByaW9yaXR5ICR7cn1gKX1pZihyPj0wKXtsZXQgbj1CdC5pbmRleE9mKGUpO24hPT0tMSYmQnQuc3BsaWNlKG4sMSk7Zm9yKGxldCBzPTA7czxCdC5sZW5ndGg7cysrKWlmKFdyLmdldChCdFtzXSkucHJpb3JpdHk8PXIpe0J0LnNwbGljZShzLDAsZSk7cmV0dXJufUJ0LnB1c2goZSl9cmV0dXJufXRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSB2YWxpZCBiYWNrZW5kXCIpfSxOcj1hc3luYyBlPT57bGV0IHQ9ZS5sZW5ndGg9PT0wP0J0OmUscj1bXTtmb3IobGV0IGEgb2YgdCl7bGV0IG49V3IuZ2V0KGEpO2lmKG4pe2lmKG4uaW5pdGlhbGl6ZWQpcmV0dXJuIG4uYmFja2VuZDtpZihuLmFib3J0ZWQpY29udGludWU7bGV0IHM9ISFuLmluaXRQcm9taXNlO3RyeXtyZXR1cm4gc3x8KG4uaW5pdFByb21pc2U9bi5iYWNrZW5kLmluaXQoKSksYXdhaXQgbi5pbml0UHJvbWlzZSxuLmluaXRpYWxpemVkPSEwLG4uYmFja2VuZH1jYXRjaCh1KXtzfHxyLnB1c2goe25hbWU6YSxlcnI6dX0pLG4uYWJvcnRlZD0hMH1maW5hbGx5e2RlbGV0ZSBuLmluaXRQcm9taXNlfX19dGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke3IubWFwKGE9PmBbJHthLm5hbWV9XSAke2EuZXJyfWApLmpvaW4oXCIsIFwiKX1gKX19KTt2YXIgTGE9TCgoKT0+e1widXNlIHN0cmljdFwiO1ZyKCl9KTt2YXIgSGEsamE9TCgoKT0+e1widXNlIHN0cmljdFwiO0hhPVwiMS4xNy4wLWRldi4yMDIzMTEwMy0xNDM5ZGEzNmZlXCJ9KTt2YXIgcWEsT24sS2E9TCgoKT0+e1widXNlIHN0cmljdFwiO2phKCk7cWE9XCJ3YXJuaW5nXCIsT249e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246SGF9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTtxYT1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuIHFhfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KE9uLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIEllLFlhPUwoKCk9PntcInVzZSBzdHJpY3RcIjtLYSgpO0llPU9ufSk7dmFyIFhhLEphLFFhPUwoKCk9PntcInVzZSBzdHJpY3RcIjtYYT0oZSx0KT0+e2xldCByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7ci53aWR0aD1lLmRpbXNbM10sci5oZWlnaHQ9ZS5kaW1zWzJdO2xldCBhPXIuZ2V0Q29udGV4dChcIjJkXCIpO2lmKGEhPW51bGwpe2xldCBuLHM7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhuPWUuZGltc1syXSxzPWUuZGltc1szXSk6KG49ZS5kaW1zWzNdLHM9ZS5kaW1zWzJdKTtsZXQgdT10Py5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIixsPXQ/Lm5vcm0sbyxwO2w9PT12b2lkIDB8fGwubWVhbj09PXZvaWQgMD9vPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiBsLm1lYW49PVwibnVtYmVyXCI/bz1bbC5tZWFuLGwubWVhbixsLm1lYW4sbC5tZWFuXToobz1bbC5tZWFuWzBdLGwubWVhblsxXSxsLm1lYW5bMl0sMF0sbC5tZWFuWzNdIT09dm9pZCAwJiYob1szXT1sLm1lYW5bM10pKSxsPT09dm9pZCAwfHxsLmJpYXM9PT12b2lkIDA/cD1bMCwwLDAsMF06dHlwZW9mIGwuYmlhcz09XCJudW1iZXJcIj9wPVtsLmJpYXMsbC5iaWFzLGwuYmlhcyxsLmJpYXNdOihwPVtsLmJpYXNbMF0sbC5iaWFzWzFdLGwuYmlhc1syXSwwXSxsLmJpYXNbM10hPT12b2lkIDAmJihwWzNdPWwuYmlhc1szXSkpO2xldCBtPXMqbix5PTAsZz1tLHY9bSoyLCQ9LTE7dT09PVwiUkdCQVwiPyh5PTAsZz1tLHY9bSoyLCQ9bSozKTp1PT09XCJSR0JcIj8oeT0wLGc9bSx2PW0qMik6dT09PVwiUkJHXCImJih5PTAsdj1tLGc9bSoyKTtmb3IobGV0IGI9MDtiPHM7YisrKWZvcihsZXQgUz0wO1M8bjtTKyspe2xldCBJPShlLmRhdGFbeSsrXS1wWzBdKSpvWzBdLFQ9KGUuZGF0YVtnKytdLXBbMV0pKm9bMV0sQj0oZS5kYXRhW3YrK10tcFsyXSkqb1syXSxQPSQ9PT0tMT8yNTU6KGUuZGF0YVskKytdLXBbM10pKm9bM107YS5maWxsU3R5bGU9XCJyZ2JhKFwiK0krXCIsXCIrVCtcIixcIitCK1wiLFwiK1ArXCIpXCIsYS5maWxsUmVjdChTLGIsMSwxKX1yZXR1cm4gci50b0RhdGFVUkwoKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9LEphPShlLHQpPT57bGV0IHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIiksYTtpZihyIT1udWxsKXtsZXQgbixzLHU7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhuPWUuZGltc1syXSxzPWUuZGltc1sxXSx1PWUuZGltc1szXSk6KG49ZS5kaW1zWzNdLHM9ZS5kaW1zWzJdLHU9ZS5kaW1zWzFdKTtsZXQgbD10IT09dm9pZCAwJiZ0LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLG89dD8ubm9ybSxwLG07bz09PXZvaWQgMHx8by5tZWFuPT09dm9pZCAwP3A9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIG8ubWVhbj09XCJudW1iZXJcIj9wPVtvLm1lYW4sby5tZWFuLG8ubWVhbixvLm1lYW5dOihwPVtvLm1lYW5bMF0sby5tZWFuWzFdLG8ubWVhblsyXSwyNTVdLG8ubWVhblszXSE9PXZvaWQgMCYmKHBbM109by5tZWFuWzNdKSksbz09PXZvaWQgMHx8by5iaWFzPT09dm9pZCAwP209WzAsMCwwLDBdOnR5cGVvZiBvLmJpYXM9PVwibnVtYmVyXCI/bT1bby5iaWFzLG8uYmlhcyxvLmJpYXMsby5iaWFzXToobT1bby5iaWFzWzBdLG8uYmlhc1sxXSxvLmJpYXNbMl0sMF0sby5iaWFzWzNdIT09dm9pZCAwJiYobVszXT1vLmJpYXNbM10pKTtsZXQgeT1zKm47aWYodCE9PXZvaWQgMCYmKHQuZm9ybWF0IT09dm9pZCAwJiZ1PT09NCYmdC5mb3JtYXQhPT1cIlJHQkFcInx8dT09PTMmJnQuZm9ybWF0IT09XCJSR0JcIiYmdC5mb3JtYXQhPT1cIkJHUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgZm9ybWF0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXNcIik7bGV0IGc9NCx2PTAsJD0xLGI9MixTPTMsST0wLFQ9eSxCPXkqMixQPS0xO2w9PT1cIlJHQkFcIj8oST0wLFQ9eSxCPXkqMixQPXkqMyk6bD09PVwiUkdCXCI/KEk9MCxUPXksQj15KjIpOmw9PT1cIlJCR1wiJiYoST0wLEI9eSxUPXkqMiksYT1yLmNyZWF0ZUltYWdlRGF0YShuLHMpO2ZvcihsZXQgRD0wO0Q8cypuO3YrPWcsJCs9ZyxiKz1nLFMrPWcsRCsrKWEuZGF0YVt2XT0oZS5kYXRhW0krK10tbVswXSkqcFswXSxhLmRhdGFbJF09KGUuZGF0YVtUKytdLW1bMV0pKnBbMV0sYS5kYXRhW2JdPShlLmRhdGFbQisrXS1tWzJdKSpwWzJdLGEuZGF0YVtTXT1QPT09LTE/MjU1OihlLmRhdGFbUCsrXS1tWzNdKSpwWzNdfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTtyZXR1cm4gYX19KTt2YXIgVG4sWmEsZW8sdG8scm8sbm89TCgoKT0+e1widXNlIHN0cmljdFwiO1VyKCk7VG49KGUsdCk9PntpZihlPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWRcIik7aWYodC5oZWlnaHQ9PT12b2lkIDB8fHQud2lkdGg9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWRcIik7aWYodC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoXCJOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7bGV0e2hlaWdodDpyLHdpZHRoOmF9PXQsbj10Lm5vcm0/P3ttZWFuOjI1NSxiaWFzOjB9LHMsdTt0eXBlb2Ygbi5tZWFuPT1cIm51bWJlclwiP3M9W24ubWVhbixuLm1lYW4sbi5tZWFuLG4ubWVhbl06cz1bbi5tZWFuWzBdLG4ubWVhblsxXSxuLm1lYW5bMl0sbi5tZWFuWzNdPz8yNTVdLHR5cGVvZiBuLmJpYXM9PVwibnVtYmVyXCI/dT1bbi5iaWFzLG4uYmlhcyxuLmJpYXMsbi5iaWFzXTp1PVtuLmJpYXNbMF0sbi5iaWFzWzFdLG4uYmlhc1syXSxuLmJpYXNbM10/PzBdO2xldCBsPXQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCQVwiLG89dC50ZW5zb3JGb3JtYXQhPT12b2lkIDAmJnQudGVuc29yRm9ybWF0IT09dm9pZCAwP3QudGVuc29yRm9ybWF0OlwiUkdCXCIscD1yKmEsbT1vPT09XCJSR0JBXCI/bmV3IEZsb2F0MzJBcnJheShwKjQpOm5ldyBGbG9hdDMyQXJyYXkocCozKSx5PTQsZz0wLHY9MSwkPTIsYj0zLFM9MCxJPXAsVD1wKjIsQj0tMTtsPT09XCJSR0JcIiYmKHk9MyxnPTAsdj0xLCQ9MixiPS0xKSxvPT09XCJSR0JBXCI/Qj1wKjM6bz09PVwiUkJHXCI/KFM9MCxUPXAsST1wKjIpOm89PT1cIkJHUlwiJiYoVD0wLEk9cCxTPXAqMik7Zm9yKGxldCBEPTA7RDxwO0QrKyxnKz15LCQrPXksdis9eSxiKz15KW1bUysrXT0oZVtnXSt1WzBdKS9zWzBdLG1bSSsrXT0oZVt2XSt1WzFdKS9zWzFdLG1bVCsrXT0oZVskXSt1WzJdKS9zWzJdLEIhPT0tMSYmYiE9PS0xJiYobVtCKytdPShlW2JdK3VbM10pL3NbM10pO3JldHVybiBvPT09XCJSR0JBXCI/bmV3IEZlKFwiZmxvYXQzMlwiLG0sWzEsNCxyLGFdKTpuZXcgRmUoXCJmbG9hdDMyXCIsbSxbMSwzLHIsYV0pfSxaYT1hc3luYyhlLHQpPT57bGV0IHI9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8XCJ1XCImJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LGE9dHlwZW9mIEltYWdlRGF0YTxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlRGF0YSxuPXR5cGVvZiBJbWFnZUJpdG1hcDxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwLHM9dHlwZW9mIGU9PVwic3RyaW5nXCIsdSxsPXQ/P3t9O2lmKHIpe2xldCBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7by53aWR0aD1lLndpZHRoLG8uaGVpZ2h0PWUuaGVpZ2h0O2xldCBwPW8uZ2V0Q29udGV4dChcIjJkXCIpO2lmKHAhPW51bGwpe2xldCBtPWUuaGVpZ2h0LHk9ZS53aWR0aDtpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiYobT10LnJlc2l6ZWRIZWlnaHQseT10LnJlc2l6ZWRXaWR0aCksdCE9PXZvaWQgMCl7aWYobD10LHQudGVuc29yRm9ybWF0IT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50XCIpO2wudGVuc29yRm9ybWF0PVwiUkdCQVwiLGwuaGVpZ2h0PW0sbC53aWR0aD15fWVsc2UgbC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsbC5oZWlnaHQ9bSxsLndpZHRoPXk7cC5kcmF3SW1hZ2UoZSwwLDApLHU9cC5nZXRJbWFnZURhdGEoMCwwLHksbSkuZGF0YX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSBpZihhKXtsZXQgbyxwO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDA/KG89dC5yZXNpemVkSGVpZ2h0LHA9dC5yZXNpemVkV2lkdGgpOihvPWUuaGVpZ2h0LHA9ZS53aWR0aCksdCE9PXZvaWQgMCYmKGw9dCksbC5mb3JtYXQ9XCJSR0JBXCIsbC5oZWlnaHQ9byxsLndpZHRoPXAsdCE9PXZvaWQgMCl7bGV0IG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTttLndpZHRoPXAsbS5oZWlnaHQ9bztsZXQgeT1tLmdldENvbnRleHQoXCIyZFwiKTtpZih5IT1udWxsKXkucHV0SW1hZ2VEYXRhKGUsMCwwKSx1PXkuZ2V0SW1hZ2VEYXRhKDAsMCxwLG8pLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2UgdT1lLmRhdGF9ZWxzZSBpZihuKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtvLndpZHRoPWUud2lkdGgsby5oZWlnaHQ9ZS5oZWlnaHQ7bGV0IHA9by5nZXRDb250ZXh0KFwiMmRcIik7aWYocCE9bnVsbCl7bGV0IG09ZS5oZWlnaHQseT1lLndpZHRoO3JldHVybiBwLmRyYXdJbWFnZShlLDAsMCx5LG0pLHU9cC5nZXRJbWFnZURhdGEoMCwwLHksbSkuZGF0YSxsLmhlaWdodD1tLGwud2lkdGg9eSxUbih1LGwpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNle2lmKHMpcmV0dXJuIG5ldyBQcm9taXNlKChvLHApPT57bGV0IG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSx5PW0uZ2V0Q29udGV4dChcIjJkXCIpO2lmKCFlfHwheSlyZXR1cm4gcCgpO2xldCBnPW5ldyBJbWFnZTtnLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIsZy5zcmM9ZSxnLm9ubG9hZD0oKT0+e20ud2lkdGg9Zy53aWR0aCxtLmhlaWdodD1nLmhlaWdodCx5LmRyYXdJbWFnZShnLDAsMCxtLndpZHRoLG0uaGVpZ2h0KTtsZXQgdj15LmdldEltYWdlRGF0YSgwLDAsbS53aWR0aCxtLmhlaWdodCk7bC5oZWlnaHQ9bS5oZWlnaHQsbC53aWR0aD1tLndpZHRoLG8oVG4odi5kYXRhLGwpKX19KTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX1pZih1IT09dm9pZCAwKXJldHVybiBUbih1LGwpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfSxlbz0oZSx0KT0+e2xldHt3aWR0aDpyLGhlaWdodDphLGRvd25sb2FkOm4sZGlzcG9zZTpzfT10LHU9WzEsYSxyLDRdO3JldHVybiBuZXcgRmUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHR5cGU6XCJmbG9hdDMyXCIsdGV4dHVyZTplLGRpbXM6dSxkb3dubG9hZDpuLGRpc3Bvc2U6c30pfSx0bz0oZSx0KT0+e2xldHtkYXRhVHlwZTpyLGRpbXM6YSxkb3dubG9hZDpuLGRpc3Bvc2U6c309dDtyZXR1cm4gbmV3IEZlKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIix0eXBlOnI/P1wiZmxvYXQzMlwiLGdwdUJ1ZmZlcjplLGRpbXM6YSxkb3dubG9hZDpuLGRpc3Bvc2U6c30pfSxybz0oZSx0LHIpPT5uZXcgRmUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6ZSxkYXRhOnQsZGltczpyPz9bdC5sZW5ndGhdfSl9KTt2YXIgbHIsR3IsYW8sb28saW89TCgoKT0+e1widXNlIHN0cmljdFwiO2xyPW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImZsb2F0MTZcIixVaW50MTZBcnJheV0sW1wiaW50MTZcIixJbnQxNkFycmF5XSxbXCJpbnQzMlwiLEludDMyQXJyYXldLFtcImJvb2xcIixVaW50OEFycmF5XSxbXCJmbG9hdDY0XCIsRmxvYXQ2NEFycmF5XSxbXCJ1aW50MzJcIixVaW50MzJBcnJheV1dKSxHcj1uZXcgTWFwKFtbRmxvYXQzMkFycmF5LFwiZmxvYXQzMlwiXSxbVWludDhBcnJheSxcInVpbnQ4XCJdLFtJbnQ4QXJyYXksXCJpbnQ4XCJdLFtVaW50MTZBcnJheSxcInVpbnQxNlwiXSxbSW50MTZBcnJheSxcImludDE2XCJdLFtJbnQzMkFycmF5LFwiaW50MzJcIl0sW0Zsb2F0NjRBcnJheSxcImZsb2F0NjRcIl0sW1VpbnQzMkFycmF5LFwidWludDMyXCJdXSksYW89ITEsb289KCk9PntpZighYW8pe2FvPSEwO2xldCBlPXR5cGVvZiBCaWdJbnQ2NEFycmF5PFwidVwiJiZ0eXBlb2YgQmlnSW50NjRBcnJheS5mcm9tPT1cImZ1bmN0aW9uXCIsdD10eXBlb2YgQmlnVWludDY0QXJyYXk8XCJ1XCImJnR5cGVvZiBCaWdVaW50NjRBcnJheS5mcm9tPT1cImZ1bmN0aW9uXCI7ZSYmKGxyLnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSksR3Iuc2V0KEJpZ0ludDY0QXJyYXksXCJpbnQ2NFwiKSksdCYmKGxyLnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSxHci5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpfX19KTt2YXIgc28sdW8sbG89TCgoKT0+e1widXNlIHN0cmljdFwiO1VyKCk7c289ZT0+e2xldCB0PTE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBhPWVbcl07aWYodHlwZW9mIGEhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihhKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke2F9YCk7aWYoYTwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke2F9YCk7dCo9YX1yZXR1cm4gdH0sdW89KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBGZShlLnR5cGUsZS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IEZlKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmUuZGF0YSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyBGZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTplLnRleHR1cmUsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgRmUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjplLmdwdUJ1ZmZlcix0eXBlOmUudHlwZSxkaW1zOnR9KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdGVuc29yUmVzaGFwZTogdGVuc29yIGxvY2F0aW9uICR7ZS5sb2NhdGlvbn0gaXMgbm90IHN1cHBvcnRlZGApfX19KTt2YXIgRmUsVXI9TCgoKT0+e1widXNlIHN0cmljdFwiO1FhKCk7bm8oKTtpbygpO2xvKCk7RmU9Y2xhc3N7Y29uc3RydWN0b3IodCxyLGEpe29vKCk7bGV0IG4scztpZih0eXBlb2YgdD09XCJvYmplY3RcIiYmXCJsb2NhdGlvblwiaW4gdClzd2l0Y2godGhpcy5kYXRhTG9jYXRpb249dC5sb2NhdGlvbixuPXQudHlwZSxzPXQuZGltcyx0LmxvY2F0aW9uKXtjYXNlXCJjcHUtcGlubmVkXCI6e2xldCBsPWxyLmdldChuKTtpZighbCl0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtufVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBwaW5uZWQgYnVmZmVyYCk7aWYoISh0LmRhdGEgaW5zdGFuY2VvZiBsKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBidWZmZXIgc2hvdWxkIGJlIG9mIHR5cGUgJHtsLm5hbWV9YCk7dGhpcy5jcHVEYXRhPXQuZGF0YTticmVha31jYXNlXCJ0ZXh0dXJlXCI6e2lmKG4hPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtufVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSB0ZXh0dXJlYCk7dGhpcy5ncHVUZXh0dXJlRGF0YT10LnRleHR1cmUsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9Y2FzZVwiZ3B1LWJ1ZmZlclwiOntpZihuIT09XCJmbG9hdDMyXCImJm4hPT1cImZsb2F0MTZcIiYmbiE9PVwiaW50MzJcIiYmbiE9PVwiaW50NjRcIiYmbiE9PVwidWludDMyXCImJm4hPT1cImJvb2xcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtufVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgY29uc3RydWN0b3I6IHVuc3VwcG9ydGVkIGxvY2F0aW9uICcke3RoaXMuZGF0YUxvY2F0aW9ufSdgKX1lbHNle2xldCBsLG87aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpaWYobj10LG89YSx0PT09XCJzdHJpbmdcIil7aWYoIUFycmF5LmlzQXJyYXkocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgc3RyaW5nIHRlbnNvcidzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS5cIik7bD1yfWVsc2V7bGV0IHA9bHIuZ2V0KHQpO2lmKHA9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7dH0uYCk7aWYoQXJyYXkuaXNBcnJheShyKSl7aWYodD09PVwiZmxvYXQxNlwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDcmVhdGluZyBhIGZsb2F0MTYgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgVWludDE2QXJyYXkgYXMgZGF0YS5cIik7dD09PVwidWludDY0XCJ8fHQ9PT1cImludDY0XCI/bD1wLmZyb20ocixCaWdJbnQpOmw9cC5mcm9tKHIpfWVsc2UgaWYociBpbnN0YW5jZW9mIHApbD1yO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke259IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7cH1gKX1lbHNlIGlmKG89cixBcnJheS5pc0FycmF5KHQpKXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LlwiKTtsZXQgcD10eXBlb2YgdFswXTtpZihwPT09XCJzdHJpbmdcIiluPVwic3RyaW5nXCIsbD10O2Vsc2UgaWYocD09PVwiYm9vbGVhblwiKW49XCJib29sXCIsbD1VaW50OEFycmF5LmZyb20odCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke3B9LmApfWVsc2V7bGV0IHA9R3IuZ2V0KHQuY29uc3RydWN0b3IpO2lmKHA9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7dC5jb25zdHJ1Y3Rvcn0uYCk7bj1wLGw9dH1pZihvPT09dm9pZCAwKW89W2wubGVuZ3RoXTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KG8pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTtzPW8sdGhpcy5jcHVEYXRhPWwsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIn1sZXQgdT1zbyhzKTtpZih0aGlzLmNwdURhdGEmJnUhPT10aGlzLmNwdURhdGEubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3V9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTt0aGlzLnR5cGU9bix0aGlzLmRpbXM9cyx0aGlzLnNpemU9dX1zdGF0aWMgYXN5bmMgZnJvbUltYWdlKHQscil7cmV0dXJuIFphKHQscil9c3RhdGljIGZyb21UZXh0dXJlKHQscil7cmV0dXJuIGVvKHQscil9c3RhdGljIGZyb21HcHVCdWZmZXIodCxyKXtyZXR1cm4gdG8odCxyKX1zdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcih0LHIsYSl7cmV0dXJuIHJvKHQscixhKX10b0RhdGFVUkwodCl7cmV0dXJuIFhhKHRoaXMsdCl9dG9JbWFnZURhdGEodCl7cmV0dXJuIEphKHRoaXMsdCl9Z2V0IGRhdGEoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuY3B1RGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCBvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuXCIpO3JldHVybiB0aGlzLmNwdURhdGF9Z2V0IGxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9ufWdldCB0ZXh0dXJlKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdVRleHR1cmVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLlwiKTtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YX1nZXQgZ3B1QnVmZmVyKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdUJ1ZmZlckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuXCIpO3JldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGF9YXN5bmMgZ2V0RGF0YSh0KXtzd2l0Y2godGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZGF0YUxvY2F0aW9uKXtjYXNlXCJjcHVcIjpjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIHRoaXMuZGF0YTtjYXNlXCJ0ZXh0dXJlXCI6Y2FzZVwiZ3B1LWJ1ZmZlclwiOntpZighdGhpcy5kb3dubG9hZGVyKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci5cIik7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0cnl7dGhpcy5pc0Rvd25sb2FkaW5nPSEwO2xldCByPWF3YWl0IHRoaXMuZG93bmxvYWRlcigpO3JldHVybiB0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwiY3B1XCIsdGhpcy5jcHVEYXRhPXIsdCYmdGhpcy5kaXNwb3NlciYmKHRoaXMuZGlzcG9zZXIoKSx0aGlzLmRpc3Bvc2VyPXZvaWQgMCkscn1maW5hbGx5e3RoaXMuaXNEb3dubG9hZGluZz0hMX19ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApfX1kaXNwb3NlKCl7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSx0aGlzLmNwdURhdGE9dm9pZCAwLHRoaXMuZ3B1VGV4dHVyZURhdGE9dm9pZCAwLHRoaXMuZ3B1QnVmZmVyRGF0YT12b2lkIDAsdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmlzRG93bmxvYWRpbmc9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwibm9uZVwifWVuc3VyZVZhbGlkKCl7aWYodGhpcy5kYXRhTG9jYXRpb249PT1cIm5vbmVcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1yZXNoYXBlKHQpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRvd25sb2FkZXJ8fHRoaXMuZGlzcG9zZXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS5cIik7cmV0dXJuIHVvKHRoaXMsdCl9fX0pO3ZhciBVZSxGcj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VXIoKTtVZT1GZX0pO3ZhciBMcixjbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VnIoKTtGcigpO0xyPWNsYXNzIGV7Y29uc3RydWN0b3IodCl7dGhpcy5oYW5kbGVyPXR9YXN5bmMgcnVuKHQscixhKXtsZXQgbj17fSxzPXt9O2lmKHR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dCBpbnN0YW5jZW9mIFVlfHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IHU9ITA7aWYodHlwZW9mIHI9PVwib2JqZWN0XCIpe2lmKHI9PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYociBpbnN0YW5jZW9mIFVlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7dT0hMTtmb3IobGV0IHAgb2Ygcil7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHApPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke3B9LmApO25bcF09bnVsbH1pZih0eXBlb2YgYT09XCJvYmplY3RcIiYmYSE9PW51bGwpcz1hO2Vsc2UgaWYodHlwZW9mIGE8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgcD0hMSxtPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpO2ZvcihsZXQgeSBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKG0uaW5kZXhPZih5KSE9PS0xKXtsZXQgZz1yW3ldOyhnPT09bnVsbHx8ZyBpbnN0YW5jZW9mIFVlKSYmKHA9ITAsdT0hMSxuW3ldPWcpfWlmKHApe2lmKHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhIT09bnVsbClzPWE7ZWxzZSBpZih0eXBlb2YgYTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIHM9cn19ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IHAgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHR5cGVvZiB0W3BdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7cH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZih1KWZvcihsZXQgcCBvZiB0aGlzLm91dHB1dE5hbWVzKW5bcF09bnVsbDtsZXQgbD1hd2FpdCB0aGlzLmhhbmRsZXIucnVuKHQsbixzKSxvPXt9O2ZvcihsZXQgcCBpbiBsKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGwscCkpe2xldCBtPWxbcF07bSBpbnN0YW5jZW9mIFVlP29bcF09bTpvW3BdPW5ldyBVZShtLnR5cGUsbS5kYXRhLG0uZGltcyl9cmV0dXJuIG99YXN5bmMgcmVsZWFzZSgpe3JldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpfXN0YXRpYyBhc3luYyBjcmVhdGUodCxyLGEsbil7bGV0IHMsdT17fTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIil7aWYocz10LHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbCl1PXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtpZihzPXQsdHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKXU9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI8XCJ1XCImJnQgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcil7bGV0IHk9dCxnPTAsdj10LmJ5dGVMZW5ndGg7aWYodHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKXU9cjtlbHNlIGlmKHR5cGVvZiByPT1cIm51bWJlclwiKXtpZihnPXIsIU51bWJlci5pc1NhZmVJbnRlZ2VyKGcpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoZzwwfHxnPj15LmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7eS5ieXRlTGVuZ3RofSkuYCk7aWYodj10LmJ5dGVMZW5ndGgtZyx0eXBlb2YgYT09XCJudW1iZXJcIil7aWYodj1hLCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHY8PTB8fGcrdj55LmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7eS5ieXRlTGVuZ3RoLWd9XS5gKTtpZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpdT1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0eXBlb2YgYTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYSBudW1iZXIuXCIpfWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7cz1uZXcgVWludDhBcnJheSh5LGcsdil9ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO2xldCBvPSh1LmV4ZWN1dGlvblByb3ZpZGVyc3x8W10pLm1hcCh5PT50eXBlb2YgeT09XCJzdHJpbmdcIj95OnkubmFtZSksbT1hd2FpdChhd2FpdCBOcihvKSkuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIocyx1KTtyZXR1cm4gbmV3IGUobSl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCl9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc319fSk7dmFyIHBvLGZvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtjbygpO3BvPUxyfSk7dmFyIG1vPUwoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciB6bCxIcixobz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VnIoKTtGcigpO3psPVwiVHJhaW5pbmcgYmFja2VuZCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuIE1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgdGhlIGNvcnJlY3QgY29uZmlndXJhdGlvbiAmIFdlYkFzc2VtYmx5IGZpbGVzLlwiLEhyPWNsYXNzIGV7Y29uc3RydWN0b3IodCl7dGhpcy5oYW5kbGVyPXR9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc31zdGF0aWMgYXN5bmMgY3JlYXRlKHQscil7bGV0IGE9dC5ldmFsTW9kZWx8fFwiXCIsbj10Lm9wdGltaXplck1vZGVsfHxcIlwiLHM9cnx8e30sbD0ocy5leGVjdXRpb25Qcm92aWRlcnN8fFtdKS5tYXAocD0+dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwLm5hbWUpLG89YXdhaXQgTnIobCk7aWYoby5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKXtsZXQgcD1hd2FpdCBvLmNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIodC5jaGVja3BvaW50U3RhdGUsdC50cmFpbk1vZGVsLGEsbixzKTtyZXR1cm4gbmV3IGUocCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoemwpfXR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKHQscixhKXtsZXQgbj17fSxzPXt9O2lmKHR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dCBpbnN0YW5jZW9mIFVlfHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IHU9ITA7aWYodHlwZW9mIHI9PVwib2JqZWN0XCIpe2lmKHI9PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYociBpbnN0YW5jZW9mIFVlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7dT0hMTtmb3IobGV0IGwgb2Ygcil7aWYodHlwZW9mIGwhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKGwpPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke2x9LmApO25bbF09bnVsbH1pZih0eXBlb2YgYT09XCJvYmplY3RcIiYmYSE9PW51bGwpcz1hO2Vsc2UgaWYodHlwZW9mIGE8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgbD0hMSxvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpO2ZvcihsZXQgcCBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKG8uaW5kZXhPZihwKSE9PS0xKXtsZXQgbT1yW3BdOyhtPT09bnVsbHx8bSBpbnN0YW5jZW9mIFVlKSYmKGw9ITAsdT0hMSxuW3BdPW0pfWlmKGwpe2lmKHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhIT09bnVsbClzPWE7ZWxzZSBpZih0eXBlb2YgYTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIHM9cn19ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IGwgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHR5cGVvZiB0W2xdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZih1KWZvcihsZXQgbCBvZiB0aGlzLm91dHB1dE5hbWVzKW5bbF09bnVsbDtyZXR1cm5bbixzXX1jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyh0KXtsZXQgcj17fTtmb3IobGV0IGEgaW4gdClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LGEpKXtsZXQgbj10W2FdO24gaW5zdGFuY2VvZiBVZT9yW2FdPW46clthXT1uZXcgVWUobi50eXBlLG4uZGF0YSxuLmRpbXMpfXJldHVybiByfWFzeW5jIHJ1blRyYWluU3RlcCh0LHIsYSl7bGV0W24sc109dGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0LHIsYSksdT1hd2FpdCB0aGlzLmhhbmRsZXIucnVuVHJhaW5TdGVwKHQsbixzKTtyZXR1cm4gdGhpcy5jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyh1KX1hc3luYyBsb2FkUGFyYW1ldGVyc0J1ZmZlcih0LHIpe3Rocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpfWFzeW5jIGdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHQpe3Rocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpfWFzeW5jIHJlbGVhc2UoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKX19fSk7dmFyIGdvLHlvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtobygpO2dvPUhyfSk7dmFyIFJuPXt9O2t0KFJuLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5wbyxUZW5zb3I6KCk9PlVlLFRyYWluaW5nU2Vzc2lvbjooKT0+Z28sZW52OigpPT5JZSxyZWdpc3RlckJhY2tlbmQ6KCk9PmZ0fSk7dmFyICR0PUwoKCk9PntcInVzZSBzdHJpY3RcIjtMYSgpO1lhKCk7Zm8oKTtGcigpO21vKCk7eW8oKX0pO3ZhciBQbj17fTtrdChQbix7cmVhZEZpbGU6KCk9PldsfSk7dmFyIFdsLGtuPUwoKCk9PntXbD12b2lkIDB9KTt2YXIgQm49e307a3QoQm4se2pvaW46KCk9Pk5sfSk7dmFyIE5sLE1uPUwoKCk9PntObD12b2lkIDB9KTt2YXIgJG89THQoKHZvLERuKT0+e1widXNlIHN0cmljdFwiO3ZhciB3bz0oKCk9Pnt2YXIgZT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKGU9ZXx8X19maWxlbmFtZSksZnVuY3Rpb24odD17fSl7dmFyIHI9dCxhLG47ci5yZWFkeT1uZXcgUHJvbWlzZSgoZCxmKT0+e2E9ZCxuPWZ9KSxyLmpzZXBJbml0PShkLGYsdyxDLF8sRyxWLHVlKT0+e3IuWmE9ZCxyLk9hPWYsci5RYT13LHIuSmE9QyxyLlBhPV8sci5yYT1HLHIuUmE9VixyLlNhPXVlLGY9KFksWixKKT0+KC4uLmNlKT0+e2xldCBtZT1ZZSxFPVo/LigpO2NlPVkoLi4uY2UpO2xldCB0ZT1aPy4oKTtyZXR1cm4gRSE9PXRlJiYoWT10ZSxKKEUpLFo9Sj1udWxsKSxZZSE9bWU/X3IoKTpjZX0sdz1ZPT5hc3luYyguLi5aKT0+e3RyeXtpZihyLkRhKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7bGV0IEo9ci5EYT17VGE6WlswXSxlcnJvcnM6W119LGNlPWF3YWl0IFkoLi4uWik7aWYoci5EYSE9PUopdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO2QuZmx1c2goKTtsZXQgbWU9Si5lcnJvcnM7aWYoMDxtZS5sZW5ndGgpe2xldCBFPWF3YWl0IFByb21pc2UuYWxsKG1lKTtpZihFPUUuZmlsdGVyKHRlPT50ZSksMDxFLmxlbmd0aCl0aHJvdyBFcnJvcihFLmpvaW4oYFxuYCkpfXJldHVybiBjZX1maW5hbGx5e3IuRGE9bnVsbH19LHIuX09ydFJ1bj13KGYoci5fT3J0UnVuLCgpPT5yLl9PcnRSdW4sWT0+ci5fT3J0UnVuPVkpKSxyLl9PcnRSdW5XaXRoQmluZGluZz13KGYoci5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnIuX09ydFJ1bldpdGhCaW5kaW5nLFk9PnIuX09ydFJ1bldpdGhCaW5kaW5nPVkpKSxyLl9PcnRCaW5kSW5wdXQ9ZihyLl9PcnRCaW5kSW5wdXQsKCk9PnIuX09ydEJpbmRJbnB1dCxZPT5yLl9PcnRCaW5kSW5wdXQ9WSksci5qc2VwUmVnaXN0ZXJCdWZmZXI9KFksWixKLGNlKT0+ZC5yZWdpc3RlckJ1ZmZlcihZLFosSixjZSksci5qc2VwVW5yZWdpc3RlckJ1ZmZlcnM9WT0+e2QudW5yZWdpc3RlckJ1ZmZlcnMoWSl9LHIuanNlcEdldEJ1ZmZlcj1ZPT5kLmdldEJ1ZmZlcihZKSxyLmpzZXBDcmVhdGVEb3dubG9hZGVyPShZLFosSik9PmQuY3JlYXRlRG93bmxvYWRlcihZLFosSil9O3ZhciBzPU9iamVjdC5hc3NpZ24oe30sciksdT1cIi4vdGhpcy5wcm9ncmFtXCIsbD0oZCxmKT0+e3Rocm93IGZ9LG89dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIixwPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsbT10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIseT1cIlwiLGcsdiwkO2lmKG0pe3ZhciBiPShrbigpLHZ0KFBuKSksUz0oTW4oKSx2dChCbikpO3k9cD9TLmRpcm5hbWUoeSkrXCIvXCI6X19kaXJuYW1lK1wiL1wiLGc9KGQsZik9PihkPWQuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChkKTpTLm5vcm1hbGl6ZShkKSxiLnJlYWRGaWxlU3luYyhkLGY/dm9pZCAwOlwidXRmOFwiKSksJD1kPT4oZD1nKGQsITApLGQuYnVmZmVyfHwoZD1uZXcgVWludDhBcnJheShkKSksZCksdj0oZCxmLHcsQz0hMCk9PntkPWQuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChkKTpTLm5vcm1hbGl6ZShkKSxiLnJlYWRGaWxlKGQsQz92b2lkIDA6XCJ1dGY4XCIsKF8sRyk9PntfP3coXyk6ZihDP0cuYnVmZmVyOkcpfSl9LCFyLnRoaXNQcm9ncmFtJiYxPHByb2Nlc3MuYXJndi5sZW5ndGgmJih1PXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMiksbD0oZCxmKT0+e3Rocm93IHByb2Nlc3MuZXhpdENvZGU9ZCxmfSxyLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn1lbHNlKG98fHApJiYocD95PXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJih5PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxlJiYoeT1lKSx5LmluZGV4T2YoXCJibG9iOlwiKSE9PTA/eT15LnN1YnN0cigwLHkucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6eT1cIlwiLGc9ZD0+e3ZhciBmPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZi5vcGVuKFwiR0VUXCIsZCwhMSksZi5zZW5kKG51bGwpLGYucmVzcG9uc2VUZXh0fSxwJiYoJD1kPT57dmFyIGY9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBmLm9wZW4oXCJHRVRcIixkLCExKSxmLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZi5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGYucmVzcG9uc2UpfSksdj0oZCxmLHcpPT57dmFyIEM9bmV3IFhNTEh0dHBSZXF1ZXN0O0Mub3BlbihcIkdFVFwiLGQsITApLEMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixDLm9ubG9hZD0oKT0+e0Muc3RhdHVzPT0yMDB8fEMuc3RhdHVzPT0wJiZDLnJlc3BvbnNlP2YoQy5yZXNwb25zZSk6dygpfSxDLm9uZXJyb3I9dyxDLnNlbmQobnVsbCl9KTt2YXIgST1yLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFQ9ci5wcmludEVycnx8Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24ocixzKSxzPW51bGwsci50aGlzUHJvZ3JhbSYmKHU9ci50aGlzUHJvZ3JhbSksci5xdWl0JiYobD1yLnF1aXQpO3ZhciBCO3Iud2FzbUJpbmFyeSYmKEI9ci53YXNtQmluYXJ5KTt2YXIgUD1yLm5vRXhpdFJ1bnRpbWV8fCEwO3R5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIiYmcWUoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBELFIsVz0hMSxILEssbGUsTSxxLHhlLG9lO2Z1bmN0aW9uIHdlKCl7dmFyIGQ9RC5idWZmZXI7ci5IRUFQOD1LPW5ldyBJbnQ4QXJyYXkoZCksci5IRUFQMTY9bmV3IEludDE2QXJyYXkoZCksci5IRUFQMzI9TT1uZXcgSW50MzJBcnJheShkKSxyLkhFQVBVOD1sZT1uZXcgVWludDhBcnJheShkKSxyLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGQpLHIuSEVBUFUzMj1xPW5ldyBVaW50MzJBcnJheShkKSxyLkhFQVBGMzI9eGU9bmV3IEZsb2F0MzJBcnJheShkKSxyLkhFQVBGNjQ9b2U9bmV3IEZsb2F0NjRBcnJheShkKX12YXIgaj1bXSxTZT1bXSxUZT1bXTtmdW5jdGlvbiBFZSgpe3ZhciBkPXIucHJlUnVuLnNoaWZ0KCk7ai51bnNoaWZ0KGQpfXZhciBDZT0wLGd0PW51bGwsTGU9bnVsbDtmdW5jdGlvbiBxZShkKXt0aHJvdyByLm9uQWJvcnQmJnIub25BYm9ydChkKSxkPVwiQWJvcnRlZChcIitkK1wiKVwiLFQoZCksVz0hMCxIPTEsZD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLG4oZCksZH1mdW5jdGlvbiBVKGQpe3JldHVybiBkLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfXZhciBkZTtpZihkZT1cIm9ydC13YXNtLXNpbWQud2FzbVwiLCFVKGRlKSl7dmFyIHBlPWRlO2RlPXIubG9jYXRlRmlsZT9yLmxvY2F0ZUZpbGUocGUseSk6eStwZX1mdW5jdGlvbiBOZShkKXtpZihkPT1kZSYmQilyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQik7aWYoJClyZXR1cm4gJChkKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBIZShkKXtpZighQiYmKG98fHApKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIWQuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKGQse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZj0+e2lmKCFmLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitkK1wiJ1wiO3JldHVybiBmLmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+TmUoZCkpO2lmKHYpcmV0dXJuIG5ldyBQcm9taXNlKChmLHcpPT57dihkLEM9PmYobmV3IFVpbnQ4QXJyYXkoQykpLHcpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pk5lKGQpKX1mdW5jdGlvbiBPZShkLGYsdyl7cmV0dXJuIEhlKGQpLnRoZW4oQz0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQyxmKSkudGhlbihDPT5DKS50aGVuKHcsQz0+e1QoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitDKSxxZShDKX0pfWZ1bmN0aW9uIHplKGQsZil7dmFyIHc9ZGU7cmV0dXJuIEJ8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxVKHcpfHx3LnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxtfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9PZSh3LGQsZik6ZmV0Y2godyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihDPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhDLGQpLnRoZW4oZixmdW5jdGlvbihfKXtyZXR1cm4gVChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitfKSxUKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksT2UodyxkLGYpfSkpfXZhciBHZSxldD17OTEzNzkyOmQ9PntyLnJhKFwiQWJzXCIsZCx2b2lkIDApfSw5MTM4NDM6ZD0+e3IucmEoXCJOZWdcIixkLHZvaWQgMCl9LDkxMzg5NDpkPT57ci5yYShcIkZsb29yXCIsZCx2b2lkIDApfSw5MTM5NDc6ZD0+e3IucmEoXCJDZWlsXCIsZCx2b2lkIDApfSw5MTM5OTk6ZD0+e3IucmEoXCJSZWNpcHJvY2FsXCIsZCx2b2lkIDApfSw5MTQwNTc6ZD0+e3IucmEoXCJTcXJ0XCIsZCx2b2lkIDApfSw5MTQxMDk6ZD0+e3IucmEoXCJFeHBcIixkLHZvaWQgMCl9LDkxNDE2MDpkPT57ci5yYShcIkVyZlwiLGQsdm9pZCAwKX0sOTE0MjExOmQ9PntyLnJhKFwiU2lnbW9pZFwiLGQsdm9pZCAwKX0sOTE0MjY2OmQ9PntyLnJhKFwiTG9nXCIsZCx2b2lkIDApfSw5MTQzMTc6ZD0+e3IucmEoXCJTaW5cIixkLHZvaWQgMCl9LDkxNDM2ODpkPT57ci5yYShcIkNvc1wiLGQsdm9pZCAwKX0sOTE0NDE5OmQ9PntyLnJhKFwiVGFuXCIsZCx2b2lkIDApfSw5MTQ0NzA6ZD0+e3IucmEoXCJBc2luXCIsZCx2b2lkIDApfSw5MTQ1MjI6ZD0+e3IucmEoXCJBY29zXCIsZCx2b2lkIDApfSw5MTQ1NzQ6ZD0+e3IucmEoXCJBdGFuXCIsZCx2b2lkIDApfSw5MTQ2MjY6ZD0+e3IucmEoXCJTaW5oXCIsZCx2b2lkIDApfSw5MTQ2Nzg6ZD0+e3IucmEoXCJDb3NoXCIsZCx2b2lkIDApfSw5MTQ3MzA6ZD0+e3IucmEoXCJBc2luaFwiLGQsdm9pZCAwKX0sOTE0NzgzOmQ9PntyLnJhKFwiQWNvc2hcIixkLHZvaWQgMCl9LDkxNDgzNjpkPT57ci5yYShcIkF0YW5oXCIsZCx2b2lkIDApfSw5MTQ4ODk6ZD0+e3IucmEoXCJUYW5oXCIsZCx2b2lkIDApfSw5MTQ5NDE6ZD0+e3IucmEoXCJOb3RcIixkLHZvaWQgMCl9LDkxNDk5MjooZCxmLHcpPT57ci5yYShcIkNsaXBWMTBcIixkLHttaW46ZixtYXg6d30pfSw5MTUwNjQ6ZD0+e3IucmEoXCJDbGlwXCIsZCx2b2lkIDApfSw5MTUxMTY6KGQsZik9PntyLnJhKFwiRWx1XCIsZCx7YWxwaGE6Zn0pfSw5MTUxNzQ6ZD0+e3IucmEoXCJSZWx1XCIsZCx2b2lkIDApfSw5MTUyMjY6KGQsZik9PntyLnJhKFwiTGVha3lSZWx1XCIsZCx7YWxwaGE6Zn0pfSw5MTUyOTA6KGQsZik9PntyLnJhKFwiVGhyZXNob2xkZWRSZWx1XCIsZCx7YWxwaGE6Zn0pfSw5MTUzNjA6KGQsZik9PntyLnJhKFwiQ2FzdFwiLGQse3RvOmZ9KX0sOTE1NDE4OmQ9PntyLnJhKFwiQWRkXCIsZCx2b2lkIDApfSw5MTU0Njk6ZD0+e3IucmEoXCJTdWJcIixkLHZvaWQgMCl9LDkxNTUyMDpkPT57ci5yYShcIk11bFwiLGQsdm9pZCAwKX0sOTE1NTcxOmQ9PntyLnJhKFwiRGl2XCIsZCx2b2lkIDApfSw5MTU2MjI6ZD0+e3IucmEoXCJQb3dcIixkLHZvaWQgMCl9LDkxNTY3MzpkPT57ci5yYShcIkVxdWFsXCIsZCx2b2lkIDApfSw5MTU3MjY6ZD0+e3IucmEoXCJHcmVhdGVyXCIsZCx2b2lkIDApfSw5MTU3ODE6ZD0+e3IucmEoXCJHcmVhdGVyT3JFcXVhbFwiLGQsdm9pZCAwKX0sOTE1ODQzOmQ9PntyLnJhKFwiTGVzc1wiLGQsdm9pZCAwKX0sOTE1ODk1OmQ9PntyLnJhKFwiTGVzc09yRXF1YWxcIixkLHZvaWQgMCl9LDkxNTk1NDooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VNZWFuXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTYxMTg6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlTWF4XCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTYyODE6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlTWluXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTY0NDQ6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlUHJvZFwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE2NjA4OihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZVN1bVwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE2NzcxOihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZUwxXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTY5MzM6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlTDJcIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNzA5NTooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VMb2dTdW1cIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNzI2MTooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VTdW1TcXVhcmVcIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNzQzMDooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VMb2dTdW1FeHBcIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNzU5OTpkPT57ci5yYShcIldoZXJlXCIsZCx2b2lkIDApfSw5MTc2NTI6KGQsZix3KT0+e3IucmEoXCJUcmFuc3Bvc2VcIixkLHtwZXJtOmY/QXJyYXkuZnJvbShNLnN1YmFycmF5KHc+Pj4wLHcrZj4+PjApKTpbXX0pfSw5MTc3NjU6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSx0ZSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGQse2Zvcm1hdDpZP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6ZixkaWxhdGlvbnM6W3ddLGdyb3VwOkMsa2VybmVsX3NoYXBlOltfXSxwYWRzOltHLFZdLHN0cmlkZXM6W3VlXSx3SXNDb25zdDooKT0+ISFLW1o+Pj4wXSxvdXRwdXRQYWRkaW5nOko/QXJyYXkuZnJvbShNLnN1YmFycmF5KGNlPj4+MCxjZStKPj4+MCkpOltdLG91dHB1dFNoYXBlOm1lP0FycmF5LmZyb20oTS5zdWJhcnJheShFPj4+MCxFK21lPj4+MCkpOltdLGFjdGl2YXRpb246UmUodGUpfSl9LDkxODE3OTooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsZCx7Zm9ybWF0OnVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6ZixkaWxhdGlvbnM6QXJyYXkuZnJvbShNLnN1YmFycmF5KHc+Pj4wLHcrMj4+PjApKSxncm91cDpDLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKE0uc3ViYXJyYXkoRz4+PjAsRys0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShNLnN1YmFycmF5KFY+Pj4wLFYrMj4+PjApKSx3SXNDb25zdDooKT0+ISFLW1k+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8Wj9BcnJheS5mcm9tKE0uc3ViYXJyYXkoSj4+PjAsSitaPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8Y2U/QXJyYXkuZnJvbShNLnN1YmFycmF5KG1lPj4+MCxtZStjZT4+PjApKTpbXSxhY3RpdmF0aW9uOlJlKEUpfSl9LDkxODczNjooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFLHRlKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsZCx7Zm9ybWF0Olk/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpmLGRpbGF0aW9uczpbd10sZ3JvdXA6QyxrZXJuZWxfc2hhcGU6W19dLHBhZHM6W0csVl0sc3RyaWRlczpbdWVdLHdJc0NvbnN0OigpPT4hIUtbWj4+PjBdLG91dHB1dFBhZGRpbmc6Sj9BcnJheS5mcm9tKE0uc3ViYXJyYXkoY2U+Pj4wLGNlK0o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6bWU/QXJyYXkuZnJvbShNLnN1YmFycmF5KEU+Pj4wLEUrbWU+Pj4wKSk6W10sYWN0aXZhdGlvbjpSZSh0ZSl9KX0sOTE5MTUwOihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixkLHtmb3JtYXQ6dWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpmLGRpbGF0aW9uczpBcnJheS5mcm9tKE0uc3ViYXJyYXkodz4+PjAsdysyPj4+MCkpLGdyb3VwOkMsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rMj4+PjApKSxwYWRzOkFycmF5LmZyb20oTS5zdWJhcnJheShHPj4+MCxHKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKE0uc3ViYXJyYXkoVj4+PjAsVisyPj4+MCkpLHdJc0NvbnN0OigpPT4hIUtbWT4+PjBdLG91dHB1dFBhZGRpbmc6MDxaP0FycmF5LmZyb20oTS5zdWJhcnJheShKPj4+MCxKK1o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxjZT9BcnJheS5mcm9tKE0uc3ViYXJyYXkobWU+Pj4wLG1lK2NlPj4+MCkpOltdLGFjdGl2YXRpb246UmUoRSl9KX0sOTE5NzA3OihkLGYpPT57ci5yYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsZCx7Zm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTE5Nzk4OihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIkF2ZXJhZ2VQb29sXCIsZCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsY2VpbF9tb2RlOncsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOl8sZGlsYXRpb25zOltHLFZdLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbWixKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjAwODI6KGQsZik9PntyLnJhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixkLHtmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjAxNzM6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiQXZlcmFnZVBvb2xcIixkLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZixjZWlsX21vZGU6dyxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6XyxkaWxhdGlvbnM6W0csVl0sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltaLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMDQ1NzooZCxmKT0+e3IucmEoXCJHbG9iYWxNYXhQb29sXCIsZCx7Zm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwNTQ0OihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIk1heFBvb2xcIixkLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZixjZWlsX21vZGU6dyxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6XyxkaWxhdGlvbnM6W0csVl0sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltaLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMDgyNDooZCxmKT0+e3IucmEoXCJHbG9iYWxNYXhQb29sXCIsZCx7Zm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwOTExOihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIk1heFBvb2xcIixkLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZixjZWlsX21vZGU6dyxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6XyxkaWxhdGlvbnM6W0csVl0sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltaLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMTE5MTooZCxmLHcsQyxfKT0+e3IucmEoXCJHZW1tXCIsZCx7YWxwaGE6ZixiZXRhOncsdHJhbnNBOkMsdHJhbnNCOl99KX0sOTIxMjk1OmQ9PntyLnJhKFwiTWF0TXVsXCIsZCx2b2lkIDApfSw5MjEzNDk6KGQsZix3LEMpPT57ci5yYShcIkFyZ01heFwiLGQse2tlZXBEaW1zOiEhZixzZWxlY3RMYXN0SW5kZXg6ISF3LGF4aXM6Q30pfSw5MjE0NTc6KGQsZix3LEMpPT57ci5yYShcIkFyZ01pblwiLGQse2tlZXBEaW1zOiEhZixzZWxlY3RMYXN0SW5kZXg6ISF3LGF4aXM6Q30pfSw5MjE1NjU6KGQsZik9PntyLnJhKFwiU29mdG1heFwiLGQse2F4aXM6Zn0pfSw5MjE2Mjg6KGQsZik9PntyLnJhKFwiQ29uY2F0XCIsZCx7YXhpczpmfSl9LDkyMTY4ODooZCxmLHcsQyxfKT0+e3IucmEoXCJTcGxpdFwiLGQse2F4aXM6ZixudW1PdXRwdXRzOncsc3BsaXRTaXplczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTIxODMzOmQ9PntyLnJhKFwiRXhwYW5kXCIsZCx2b2lkIDApfSw5MjE4ODc6KGQsZik9PntyLnJhKFwiR2F0aGVyXCIsZCx7YXhpczpOdW1iZXIoZil9KX0sOTIxOTU4OihkLGYpPT57ci5yYShcIkdhdGhlckVsZW1lbnRzXCIsZCx7YXhpczpOdW1iZXIoZil9KX0sOTIyMDM3OihkLGYsdyxDLF8sRyxWLHVlLFksWixKKT0+e3IucmEoXCJSZXNpemVcIixkLHthbnRpYWxpYXM6ZixheGVzOnc/QXJyYXkuZnJvbShNLnN1YmFycmF5KEM+Pj4wLEMrdz4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpSZShfKSxjdWJpY0NvZWZmQTpHLGV4Y2x1ZGVPdXRzaWRlOlYsZXh0cmFwb2xhdGlvblZhbHVlOnVlLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpSZShZKSxtb2RlOlJlKFopLG5lYXJlc3RNb2RlOlJlKEopfSl9LDkyMjM4ODooZCxmLHcsQyxfLEcsVik9PntyLnJhKFwiU2xpY2VcIixkLHtzdGFydHM6Zj9BcnJheS5mcm9tKE0uc3ViYXJyYXkodz4+PjAsdytmPj4+MCkpOltdLGVuZHM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdLGF4ZXM6Rz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoVj4+PjAsVitHPj4+MCkpOltdfSl9LDkyMjYxOTpkPT57ci5yYShcIlRpbGVcIixkLHZvaWQgMCl9LDkyMjY3MTooZCxmLHcpPT57ci5yYShcIkxheWVyTm9ybWFsaXphdGlvblwiLGQse2F4aXM6TnVtYmVyKGYpLGVwc2lsb246TnVtYmVyKHcpfSl9LDkyMjc3ODooZCxmLHcpPT57ci5yYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGQse2Vwc2lsb246Zixmb3JtYXQ6dz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjI4OTI6KGQsZix3KT0+e3IucmEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixkLHtlcHNpbG9uOmYsZm9ybWF0Onc/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIzMDA2OmQ9PntyLnJhKFwiUmFuZ2VcIixkLHZvaWQgMCl9LDkyMzA1OTooZCxmKT0+e3IucmEoXCJFaW5zdW1cIixkLHtlcXVhdGlvbjpSZShmKX0pfSw5MjMxNDA6KGQsZix3LEMsXyk9PntyLnJhKFwiUGFkXCIsZCx7bW9kZTpmLHZhbHVlOncscGFkczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTIzMjcyOmQ9PntyLnJhKFwiR2VsdVwiLGQsdm9pZCAwKX0sOTIzMzI0OmQ9PntyLnJhKFwiQmlhc0FkZFwiLGQsdm9pZCAwKX0sOTIzMzc5OmQ9PntyLnJhKFwiQmlhc1NwbGl0R2VsdVwiLGQsdm9pZCAwKX0sOTIzNDQwOihkLGYpPT57ci5yYShcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixkLHtlcHNpbG9uOmZ9KX0sOTIzNTIxOihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lKT0+e3IucmEoXCJDb252XCIsZCx7Zm9ybWF0Olk/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZixkaWxhdGlvbnM6W3ddLGdyb3VwOkMsa2VybmVsX3NoYXBlOltfXSxwYWRzOkc/QXJyYXkuZnJvbShNLnN1YmFycmF5KFY+Pj4wLFYrRz4+PjApKTpbXSxzdHJpZGVzOlt1ZV0sd19pc19jb25zdDooKT0+ISFLW1o+Pj4wXSxhY3RpdmF0aW9uOlJlKEopLGFjdGl2YXRpb25fcGFyYW1zOmNlP0FycmF5LmZyb20oeGUuc3ViYXJyYXkobWU+Pj4wLG1lK2NlPj4+MCkpOltdfSl9LDkyMzkwMjooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJDb252XCIsZCx7Zm9ybWF0OmNlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsZGlsYXRpb25zOlt3LENdLGdyb3VwOl8sa2VybmVsX3NoYXBlOltHLFZdLHBhZHM6dWU/QXJyYXkuZnJvbShNLnN1YmFycmF5KFk+Pj4wLFkrdWU+Pj4wKSk6W10sc3RyaWRlczpbWixKXSx3X2lzX2NvbnN0OigpPT4hIUtbbWU+Pj4wXSxhY3RpdmF0aW9uOlJlKEUpLGFjdGl2YXRpb25fcGFyYW1zOnRlP0FycmF5LmZyb20oeGUuc3ViYXJyYXkoZmU+Pj4wLGZlK3RlPj4+MCkpOltdfSl9LDkyNDMwNDpkPT57ci5SYShkKX0sOTI0MzM4OihkLGYpPT5yLlNhKGQsZixyLkRhLlRhLHIuRGEuZXJyb3JzKSw5MjQ0NTA6ZD0+ci5PYShkKSw5MjQ0ODM6ZD0+ci5RYShkKSw5MjQ1MTU6KGQsZix3KT0+e3IuSmEoZCxmLHcsITApfSw5MjQ1NTQ6KGQsZix3KT0+e3IuSmEoZCxmLHcpfX07ZnVuY3Rpb24gS2UoZCl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2R9KWAsdGhpcy5zdGF0dXM9ZH12YXIgQXQ9ZD0+e2Zvcig7MDxkLmxlbmd0aDspZC5zaGlmdCgpKHIpfTtmdW5jdGlvbiBFdChkKXt0aGlzLkhhPWQtMjQsdGhpcy5NYT1mdW5jdGlvbihmKXtxW3RoaXMuSGErND4+Mj4+PjBdPWZ9LHRoaXMuTGE9ZnVuY3Rpb24oZil7cVt0aGlzLkhhKzg+PjI+Pj4wXT1mfSx0aGlzLllhPWZ1bmN0aW9uKGYsdyl7dGhpcy5LYSgpLHRoaXMuTWEoZiksdGhpcy5MYSh3KX0sdGhpcy5LYT1mdW5jdGlvbigpe3FbdGhpcy5IYSsxNj4+Mj4+PjBdPTB9fXZhciBqdD0wLCRyPTAsSmU9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLHF0PShkLGYsdyk9PntmPj4+PTA7dmFyIEM9Zit3O2Zvcih3PWY7ZFt3XSYmISh3Pj1DKTspKyt3O2lmKDE2PHctZiYmZC5idWZmZXImJkplKXJldHVybiBKZS5kZWNvZGUoZC5zdWJhcnJheShmLHcpKTtmb3IoQz1cIlwiO2Y8dzspe3ZhciBfPWRbZisrXTtpZihfJjEyOCl7dmFyIEc9ZFtmKytdJjYzO2lmKChfJjIyNCk9PTE5MilDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChfJjMxKTw8NnxHKTtlbHNle3ZhciBWPWRbZisrXSY2MztfPShfJjI0MCk9PTIyND8oXyYxNSk8PDEyfEc8PDZ8VjooXyY3KTw8MTh8Rzw8MTJ8Vjw8NnxkW2YrK10mNjMsNjU1MzY+Xz9DKz1TdHJpbmcuZnJvbUNoYXJDb2RlKF8pOihfLT02NTUzNixDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fF8+PjEwLDU2MzIwfF8mMTAyMykpfX1lbHNlIEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoXyl9cmV0dXJuIEN9LFJlPShkLGYpPT4oZD4+Pj0wKT9xdChsZSxkLGYpOlwiXCIsenQ9ZD0+e2Zvcih2YXIgZj0wLHc9MDt3PGQubGVuZ3RoOysrdyl7dmFyIEM9ZC5jaGFyQ29kZUF0KHcpOzEyNz49Qz9mKys6MjA0Nz49Qz9mKz0yOjU1Mjk2PD1DJiY1NzM0Mz49Qz8oZis9NCwrK3cpOmYrPTN9cmV0dXJuIGZ9LEt0PShkLGYsdyxDKT0+e2lmKHc+Pj49MCwhKDA8QykpcmV0dXJuIDA7dmFyIF89dztDPXcrQy0xO2Zvcih2YXIgRz0wO0c8ZC5sZW5ndGg7KytHKXt2YXIgVj1kLmNoYXJDb2RlQXQoRyk7aWYoNTUyOTY8PVYmJjU3MzQzPj1WKXt2YXIgdWU9ZC5jaGFyQ29kZUF0KCsrRyk7Vj02NTUzNisoKFYmMTAyMyk8PDEwKXx1ZSYxMDIzfWlmKDEyNz49Vil7aWYodz49QylicmVhaztmW3crKz4+PjBdPVZ9ZWxzZXtpZigyMDQ3Pj1WKXtpZih3KzE+PUMpYnJlYWs7Zlt3Kys+Pj4wXT0xOTJ8Vj4+Nn1lbHNle2lmKDY1NTM1Pj1WKXtpZih3KzI+PUMpYnJlYWs7Zlt3Kys+Pj4wXT0yMjR8Vj4+MTJ9ZWxzZXtpZih3KzM+PUMpYnJlYWs7Zlt3Kys+Pj4wXT0yNDB8Vj4+MTgsZlt3Kys+Pj4wXT0xMjh8Vj4+MTImNjN9Zlt3Kys+Pj4wXT0xMjh8Vj4+NiY2M31mW3crKz4+PjBdPTEyOHxWJjYzfX1yZXR1cm4gZlt3Pj4+MF09MCx3LV99LGx0PWQ9PmQlND09PTAmJihkJTEwMCE9PTB8fGQlNDAwPT09MCkseHI9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0sZHQ9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF0sV3Q9ZD0+e3ZhciBmPXp0KGQpKzEsdz1HdChmKTtyZXR1cm4gdyYmS3QoZCxsZSx3LGYpLHd9LHl0PVtdLE50PShkLGYpPT57eXQubGVuZ3RoPTA7dmFyIHc7Zm9yKGY+Pj0yO3c9bGVbZCsrPj4+MF07KWYrPXchPTEwNSZmLHl0LnB1c2godz09MTA1P01bZj4+PjBdOm9lW2YrKz4+PjFdKSwrK2Y7cmV0dXJuIHl0fSxWdD17fSxZdD0oKT0+e2lmKCFVdCl7dmFyIGQ9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86dXx8XCIuL3RoaXMucHJvZ3JhbVwifSxmO2ZvcihmIGluIFZ0KVZ0W2ZdPT09dm9pZCAwP2RlbGV0ZSBkW2ZdOmRbZl09VnRbZl07dmFyIHc9W107Zm9yKGYgaW4gZCl3LnB1c2goYCR7Zn09JHtkW2ZdfWApO1V0PXd9cmV0dXJuIFV0fSxVdCxTcj1bbnVsbCxbXSxbXV0sVmU9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxYdD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIEp0KGQpe3ZhciBmPUFycmF5KHp0KGQpKzEpO3JldHVybiBLdChkLGYsMCxmLmxlbmd0aCksZn1mdW5jdGlvbiBuZShkLGYsdyxDKXtmdW5jdGlvbiBfKEUsdGUsZmUpe2ZvcihFPXR5cGVvZiBFPT1cIm51bWJlclwiP0UudG9TdHJpbmcoKTpFfHxcIlwiO0UubGVuZ3RoPHRlOylFPWZlWzBdK0U7cmV0dXJuIEV9ZnVuY3Rpb24gRyhFLHRlKXtyZXR1cm4gXyhFLHRlLFwiMFwiKX1mdW5jdGlvbiBWKEUsdGUpe2Z1bmN0aW9uIGZlKHVyKXtyZXR1cm4gMD51cj8tMTowPHVyPzE6MH12YXIgcHQ7cmV0dXJuKHB0PWZlKEUuZ2V0RnVsbFllYXIoKS10ZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYocHQ9ZmUoRS5nZXRNb250aCgpLXRlLmdldE1vbnRoKCkpKT09PTAmJihwdD1mZShFLmdldERhdGUoKS10ZS5nZXREYXRlKCkpKSxwdH1mdW5jdGlvbiB1ZShFKXtzd2l0Y2goRS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBFO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBZKEUpe3ZhciB0ZT1FLkJhO2ZvcihFPW5ldyBEYXRlKG5ldyBEYXRlKEUuQ2ErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDx0ZTspe3ZhciBmZT1FLmdldE1vbnRoKCkscHQ9KGx0KEUuZ2V0RnVsbFllYXIoKSk/VmU6WHQpW2ZlXTtpZih0ZT5wdC1FLmdldERhdGUoKSl0ZS09cHQtRS5nZXREYXRlKCkrMSxFLnNldERhdGUoMSksMTE+ZmU/RS5zZXRNb250aChmZSsxKTooRS5zZXRNb250aCgwKSxFLnNldEZ1bGxZZWFyKEUuZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtFLnNldERhdGUoRS5nZXREYXRlKCkrdGUpO2JyZWFrfX1yZXR1cm4gZmU9bmV3IERhdGUoRS5nZXRGdWxsWWVhcigpKzEsMCw0KSx0ZT11ZShuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCw0KSksZmU9dWUoZmUpLDA+PVYodGUsRSk/MD49VihmZSxFKT9FLmdldEZ1bGxZZWFyKCkrMTpFLmdldEZ1bGxZZWFyKCk6RS5nZXRGdWxsWWVhcigpLTF9ZD4+Pj0wLGY+Pj49MCx3Pj4+PTAsQz4+Pj0wO3ZhciBaPU1bQys0MD4+Mj4+PjBdO0M9e1dhOk1bQz4+Mj4+PjBdLFZhOk1bQys0Pj4yPj4+MF0sRWE6TVtDKzg+PjI+Pj4wXSxJYTpNW0MrMTI+PjI+Pj4wXSxGYTpNW0MrMTY+PjI+Pj4wXSxDYTpNW0MrMjA+PjI+Pj4wXSx3YTpNW0MrMjQ+PjI+Pj4wXSxCYTpNW0MrMjg+PjI+Pj4wXSwkYTpNW0MrMzI+PjI+Pj4wXSxVYTpNW0MrMzY+PjI+Pj4wXSxYYTpaP1JlKFopOlwiXCJ9LHc9UmUodyksWj17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgSiBpbiBaKXc9dy5yZXBsYWNlKG5ldyBSZWdFeHAoSixcImdcIiksWltKXSk7dmFyIGNlPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksbWU9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO1o9e1wiJWFcIjpFPT5jZVtFLndhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6RT0+Y2VbRS53YV0sXCIlYlwiOkU9Pm1lW0UuRmFdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpFPT5tZVtFLkZhXSxcIiVDXCI6RT0+RygoRS5DYSsxOTAwKS8xMDB8MCwyKSxcIiVkXCI6RT0+RyhFLklhLDIpLFwiJWVcIjpFPT5fKEUuSWEsMixcIiBcIiksXCIlZ1wiOkU9PlkoRSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOkU9PlkoRSksXCIlSFwiOkU9PkcoRS5FYSwyKSxcIiVJXCI6RT0+KEU9RS5FYSxFPT0wP0U9MTI6MTI8RSYmKEUtPTEyKSxHKEUsMikpLFwiJWpcIjpFPT57Zm9yKHZhciB0ZT0wLGZlPTA7ZmU8PUUuRmEtMTt0ZSs9KGx0KEUuQ2ErMTkwMCk/VmU6WHQpW2ZlKytdKTtyZXR1cm4gRyhFLklhK3RlLDMpfSxcIiVtXCI6RT0+RyhFLkZhKzEsMiksXCIlTVwiOkU9PkcoRS5WYSwyKSxcIiVuXCI6KCk9PmBcbmAsXCIlcFwiOkU9PjA8PUUuRWEmJjEyPkUuRWE/XCJBTVwiOlwiUE1cIixcIiVTXCI6RT0+RyhFLldhLDIpLFwiJXRcIjooKT0+XCJcdFwiLFwiJXVcIjpFPT5FLndhfHw3LFwiJVVcIjpFPT5HKE1hdGguZmxvb3IoKEUuQmErNy1FLndhKS83KSwyKSxcIiVWXCI6RT0+e3ZhciB0ZT1NYXRoLmZsb29yKChFLkJhKzctKEUud2ErNiklNykvNyk7aWYoMj49KEUud2ErMzcxLUUuQmEtMiklNyYmdGUrKyx0ZSl0ZT09NTMmJihmZT0oRS53YSszNzEtRS5CYSklNyxmZT09NHx8ZmU9PTMmJmx0KEUuQ2EpfHwodGU9MSkpO2Vsc2V7dGU9NTI7dmFyIGZlPShFLndhKzctRS5CYS0xKSU3OyhmZT09NHx8ZmU9PTUmJmx0KEUuQ2ElNDAwLTEpKSYmdGUrK31yZXR1cm4gRyh0ZSwyKX0sXCIld1wiOkU9PkUud2EsXCIlV1wiOkU9PkcoTWF0aC5mbG9vcigoRS5CYSs3LShFLndhKzYpJTcpLzcpLDIpLFwiJXlcIjpFPT4oRS5DYSsxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6RT0+RS5DYSsxOTAwLFwiJXpcIjpFPT57RT1FLlVhO3ZhciB0ZT0wPD1FO3JldHVybiBFPU1hdGguYWJzKEUpLzYwLCh0ZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyhFLzYwKjEwMCtFJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6RT0+RS5YYSxcIiUlXCI6KCk9PlwiJVwifSx3PXcucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKTtmb3IoSiBpbiBaKXcuaW5jbHVkZXMoSikmJih3PXcucmVwbGFjZShuZXcgUmVnRXhwKEosXCJnXCIpLFpbSl0oQykpKTtyZXR1cm4gdz13LnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKSxKPUp0KHcpLEoubGVuZ3RoPmY/MDooSy5zZXQoSixkPj4+MCksSi5sZW5ndGgtMSl9ZnVuY3Rpb24gY3QoZCl7dHJ5e2QoKX1jYXRjaChmKXtxZShmKX19ZnVuY3Rpb24gQ3IoZCl7dmFyIGY9e30sdztmb3IodyBpbiBkKShmdW5jdGlvbihDKXt2YXIgXz1kW0NdO2ZbQ109dHlwZW9mIF89PVwiZnVuY3Rpb25cIj9mdW5jdGlvbigpe190LnB1c2goQyk7dHJ5e3JldHVybiBfLmFwcGx5KG51bGwsYXJndW1lbnRzKX1maW5hbGx5e1d8fChfdC5wb3AoKT09PUN8fHFlKCksWWUmJnR0PT09MSYmX3QubGVuZ3RoPT09MCYmKHR0PTAsY3QoaXIpLHR5cGVvZiBGaWJlcnM8XCJ1XCImJkZpYmVycy5hYigpKSl9fTpffSkodyk7cmV0dXJuIGZ9dmFyIHR0PTAsWWU9bnVsbCxJcj0wLF90PVtdLFF0PXt9LFp0PXt9LEFyPTAsT3Q9bnVsbCxFcj1bXTtmdW5jdGlvbiBfcigpe3JldHVybiBuZXcgUHJvbWlzZSgoZCxmKT0+e090PXtyZXNvbHZlOmQscmVqZWN0OmZ9fSl9ZnVuY3Rpb24gT3IoKXt2YXIgZD1HdCg2NTU0OCksZj1kKzEyO3FbZD4+Mj4+PjBdPWYscVtkKzQ+PjI+Pj4wXT1mKzY1NTM2LGY9X3RbMF07dmFyIHc9UXRbZl07cmV0dXJuIHc9PT12b2lkIDAmJih3PUFyKyssUXRbZl09dyxadFt3XT1mKSxNW2QrOD4+Mj4+PjBdPXcsZH1mdW5jdGlvbiBUcihkKXtpZighVyl7aWYodHQ9PT0wKXt2YXIgZj0hMSx3PSExO2QoKEM9MCk9PntpZighVyYmKElyPUMsZj0hMCx3KSl7dHQ9MixjdCgoKT0+RnQoWWUpKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5HYS5OYSYmQnJvd3Nlci5HYS5yZXN1bWUoKSxDPSExO3RyeXt2YXIgXz0oMCxSW1p0W01bWWUrOD4+Mj4+PjBdXV0pKCl9Y2F0Y2godWUpe189dWUsQz0hMH12YXIgRz0hMTtpZighWWUpe3ZhciBWPU90O1YmJihPdD1udWxsLChDP1YucmVqZWN0OlYucmVzb2x2ZSkoXyksRz0hMCl9aWYoQyYmIUcpdGhyb3cgX319KSx3PSEwLGZ8fCh0dD0xLFllPU9yKCksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuR2EuTmEmJkJyb3dzZXIuR2EucGF1c2UoKSxjdCgoKT0+b3IoWWUpKSl9ZWxzZSB0dD09PTI/KHR0PTAsY3QoVHQpLGVyKFllKSxZZT1udWxsLEVyLmZvckVhY2goQz0+e2lmKCFXKXRyeXtpZihDKCksIVApdHJ5e0g9SD1DPUgsUHx8KHIub25FeGl0JiZyLm9uRXhpdChDKSxXPSEwKSxsKEMsbmV3IEtlKEMpKX1jYXRjaChfKXtfIGluc3RhbmNlb2YgS2V8fF89PVwidW53aW5kXCJ8fGwoMSxfKX19Y2F0Y2goXyl7XyBpbnN0YW5jZW9mIEtlfHxfPT1cInVud2luZFwifHxsKDEsXyl9fSkpOnFlKGBpbnZhbGlkIHN0YXRlOiAke3R0fWApO3JldHVybiBJcn19ZnVuY3Rpb24gUnIoZCl7cmV0dXJuIFRyKGY9PntkKCkudGhlbihmKX0pfXZhciBQcj17bjpmdW5jdGlvbihkLGYsdyl7cmV0dXJuIFJyKGFzeW5jKCk9Pnthd2FpdCByLlBhKGQsZix3KX0pfSxhOmZ1bmN0aW9uKGQsZix3KXt0aHJvdyBkPj4+PTAsbmV3IEV0KGQpLllhKGY+Pj4wLHc+Pj4wKSxqdD1kLCRyKyssanR9LGc6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sSjpmdW5jdGlvbigpe30sejpmdW5jdGlvbigpe30sQjpmdW5jdGlvbigpe30sTDpmdW5jdGlvbigpe3JldHVybiAwfSxIOmZ1bmN0aW9uKCl7fSxDOmZ1bmN0aW9uKCl7fSxHOmZ1bmN0aW9uKCl7fSxsOmZ1bmN0aW9uKCl7fSxBOmZ1bmN0aW9uKCl7fSx4OmZ1bmN0aW9uKCl7fSxJOmZ1bmN0aW9uKCl7fSx5OmZ1bmN0aW9uKCl7fSxtOigpPT4hMCxxOmZ1bmN0aW9uKGQsZix3KXtkPWYrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWQ/KGQ+Pj4wKSs0Mjk0OTY3Mjk2KmY6TmFOLHc+Pj49MCxkPW5ldyBEYXRlKDFlMypkKSxNW3c+PjI+Pj4wXT1kLmdldFVUQ1NlY29uZHMoKSxNW3crND4+Mj4+PjBdPWQuZ2V0VVRDTWludXRlcygpLE1bdys4Pj4yPj4+MF09ZC5nZXRVVENIb3VycygpLE1bdysxMj4+Mj4+PjBdPWQuZ2V0VVRDRGF0ZSgpLE1bdysxNj4+Mj4+PjBdPWQuZ2V0VVRDTW9udGgoKSxNW3crMjA+PjI+Pj4wXT1kLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxNW3crMjQ+PjI+Pj4wXT1kLmdldFVUQ0RheSgpLE1bdysyOD4+Mj4+PjBdPShkLmdldFRpbWUoKS1EYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxyOmZ1bmN0aW9uKGQsZix3KXtkPWYrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWQ/KGQ+Pj4wKSs0Mjk0OTY3Mjk2KmY6TmFOLHc+Pj49MCxkPW5ldyBEYXRlKDFlMypkKSxNW3c+PjI+Pj4wXT1kLmdldFNlY29uZHMoKSxNW3crND4+Mj4+PjBdPWQuZ2V0TWludXRlcygpLE1bdys4Pj4yPj4+MF09ZC5nZXRIb3VycygpLE1bdysxMj4+Mj4+PjBdPWQuZ2V0RGF0ZSgpLE1bdysxNj4+Mj4+PjBdPWQuZ2V0TW9udGgoKSxNW3crMjA+PjI+Pj4wXT1kLmdldEZ1bGxZZWFyKCktMTkwMCxNW3crMjQ+PjI+Pj4wXT1kLmdldERheSgpLE1bdysyOD4+Mj4+PjBdPShsdChkLmdldEZ1bGxZZWFyKCkpP3hyOmR0KVtkLmdldE1vbnRoKCldK2QuZ2V0RGF0ZSgpLTF8MCxNW3crMzY+PjI+Pj4wXT0tKDYwKmQuZ2V0VGltZXpvbmVPZmZzZXQoKSksZj1uZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBDPW5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7TVt3KzMyPj4yPj4+MF09KGYhPUMmJmQuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oQyxmKSl8MH0sczpmdW5jdGlvbihkKXtkPj4+PTA7dmFyIGY9bmV3IERhdGUoTVtkKzIwPj4yPj4+MF0rMTkwMCxNW2QrMTY+PjI+Pj4wXSxNW2QrMTI+PjI+Pj4wXSxNW2QrOD4+Mj4+PjBdLE1bZCs0Pj4yPj4+MF0sTVtkPj4yPj4+MF0sMCksdz1NW2QrMzI+PjI+Pj4wXSxDPWYuZ2V0VGltZXpvbmVPZmZzZXQoKSxfPW5ldyBEYXRlKGYuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksRz1uZXcgRGF0ZShmLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLFY9TWF0aC5taW4oRyxfKTtyZXR1cm4gMD53P01bZCszMj4+Mj4+PjBdPSsoXyE9RyYmVj09Qyk6MDx3IT0oVj09QykmJihfPU1hdGgubWF4KEcsXyksZi5zZXRUaW1lKGYuZ2V0VGltZSgpKzZlNCooKDA8dz9WOl8pLUMpKSksTVtkKzI0Pj4yPj4+MF09Zi5nZXREYXkoKSxNW2QrMjg+PjI+Pj4wXT0obHQoZi5nZXRGdWxsWWVhcigpKT94cjpkdClbZi5nZXRNb250aCgpXStmLmdldERhdGUoKS0xfDAsTVtkPj4yPj4+MF09Zi5nZXRTZWNvbmRzKCksTVtkKzQ+PjI+Pj4wXT1mLmdldE1pbnV0ZXMoKSxNW2QrOD4+Mj4+PjBdPWYuZ2V0SG91cnMoKSxNW2QrMTI+PjI+Pj4wXT1mLmdldERhdGUoKSxNW2QrMTY+PjI+Pj4wXT1mLmdldE1vbnRoKCksTVtkKzIwPj4yPj4+MF09Zi5nZXRZZWFyKCksZD1mLmdldFRpbWUoKS8xZTMsdHIoKEdlPWQsMTw9K01hdGguYWJzKEdlKT8wPEdlPytNYXRoLmZsb29yKEdlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKEdlLSsofn5HZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCkpLGQ+Pj4wfSxvOmZ1bmN0aW9uKCl7cmV0dXJuLTUyfSxwOmZ1bmN0aW9uKCl7fSx2OmZ1bmN0aW9uKGQsZix3KXtmdW5jdGlvbiBDKFkpe3JldHVybihZPVkudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKSk/WVsxXTpcIkdNVFwifXc+Pj49MDt2YXIgXz1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksRz1uZXcgRGF0ZShfLDAsMSksVj1uZXcgRGF0ZShfLDYsMSk7Xz1HLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHVlPVYuZ2V0VGltZXpvbmVPZmZzZXQoKTtxW2Q+Pj4wPj4yPj4+MF09NjAqTWF0aC5tYXgoXyx1ZSksTVtmPj4+MD4+Mj4+PjBdPSsoXyE9dWUpLGQ9QyhHKSxmPUMoViksZD1XdChkKSxmPVd0KGYpLHVlPF8/KHFbdz4+Mj4+PjBdPWQscVt3KzQ+PjI+Pj4wXT1mKToocVt3Pj4yPj4+MF09ZixxW3crND4+Mj4+PjBdPWQpfSxlOigpPT57cWUoXCJcIil9LGI6ZnVuY3Rpb24oZCxmLHcpe3JldHVybiBkPj4+PTAsZj1OdChmPj4+MCx3Pj4+MCksZXRbZF0uYXBwbHkobnVsbCxmKX0saTpmdW5jdGlvbihkLGYsdyl7cmV0dXJuIGQ+Pj49MCxmPU50KGY+Pj4wLHc+Pj4wKSxldFtkXS5hcHBseShudWxsLGYpfSxoOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LHc6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sYzooKT0+cGVyZm9ybWFuY2Uubm93KCksSzpmdW5jdGlvbihkLGYsdyl7cmV0dXJuIGY+Pj49MCxsZS5jb3B5V2l0aGluKGQ+Pj4wPj4+MCxmPj4+MCxmKyh3Pj4+MCk+Pj4wKX0sdTpmdW5jdGlvbihkKXtkPj4+PTA7dmFyIGY9bGUubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8ZClyZXR1cm4hMTtmb3IodmFyIHc9MTs0Pj13O3cqPTIpe3ZhciBDPWYqKDErLjIvdyk7Qz1NYXRoLm1pbihDLGQrMTAwNjYzMjk2KTt2YXIgXz1NYXRoO0M9TWF0aC5tYXgoZCxDKTtlOntfPV8ubWluLmNhbGwoXyw0Mjk0OTAxNzYwLEMrKDY1NTM2LUMlNjU1MzYpJTY1NTM2KS1ELmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTY7dHJ5e0QuZ3JvdyhfKSx3ZSgpO3ZhciBHPTE7YnJlYWsgZX1jYXRjaHt9Rz12b2lkIDB9aWYoRylyZXR1cm4hMH1yZXR1cm4hMX0sRDpmdW5jdGlvbihkLGYpe2Q+Pj49MCxmPj4+PTA7dmFyIHc9MDtyZXR1cm4gWXQoKS5mb3JFYWNoKGZ1bmN0aW9uKEMsXyl7dmFyIEc9Zit3O2ZvcihfPXFbZCs0Kl8+PjI+Pj4wXT1HLEc9MDtHPEMubGVuZ3RoOysrRylLW18rKz4+MD4+PjBdPUMuY2hhckNvZGVBdChHKTtLW18+PjA+Pj4wXT0wLHcrPUMubGVuZ3RoKzF9KSwwfSxFOmZ1bmN0aW9uKGQsZil7ZD4+Pj0wLGY+Pj49MDt2YXIgdz1ZdCgpO3FbZD4+Mj4+PjBdPXcubGVuZ3RoO3ZhciBDPTA7cmV0dXJuIHcuZm9yRWFjaChmdW5jdGlvbihfKXtDKz1fLmxlbmd0aCsxfSkscVtmPj4yPj4+MF09QywwfSxmOigpPT41MixrOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSx0OmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxqOmZ1bmN0aW9uKGQsZix3LEMpe2Y+Pj49MCx3Pj4+PTAsQz4+Pj0wO2Zvcih2YXIgXz0wLEc9MDtHPHc7RysrKXt2YXIgVj1xW2Y+PjI+Pj4wXSx1ZT1xW2YrND4+Mj4+PjBdO2YrPTg7Zm9yKHZhciBZPTA7WTx1ZTtZKyspe3ZhciBaPWxlW1YrWT4+PjBdLEo9U3JbZF07Wj09PTB8fFo9PT0xMD8oKGQ9PT0xP0k6VCkocXQoSiwwKSksSi5sZW5ndGg9MCk6Si5wdXNoKFopfV8rPXVlfXJldHVybiBxW0M+PjI+Pj4wXT1fLDB9LEY6bmUsZDpmdW5jdGlvbihkLGYsdyxDKXtyZXR1cm4gbmUoZD4+PjAsZj4+PjAsdz4+PjAsQz4+PjApfX07KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZCh3KXtpZih3PXcuZXhwb3J0cyx3PUNyKHcpLFI9dz1idCh3KSxEPVIuTSx3ZSgpLFNlLnVuc2hpZnQoUi5OKSxDZS0tLHIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKENlKSxDZT09MCYmKGd0IT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoZ3QpLGd0PW51bGwpLExlKSl7dmFyIEM9TGU7TGU9bnVsbCxDKCl9cmV0dXJuIHd9dmFyIGY9e2E6UHJ9O2lmKENlKyssci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoQ2UpLHIuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gci5pbnN0YW50aWF0ZVdhc20oZixkKX1jYXRjaCh3KXtUKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdyksbih3KX1yZXR1cm4gemUoZixmdW5jdGlvbih3KXtkKHcuaW5zdGFuY2UpfSkuY2F0Y2gobikse319KSgpLHIuX09ydEluaXQ9KGQsZik9PihyLl9PcnRJbml0PVIuTykoZCxmKSxyLl9PcnRHZXRMYXN0RXJyb3I9KGQsZik9PihyLl9PcnRHZXRMYXN0RXJyb3I9Ui5QKShkLGYpLHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShkLGYsdyxDLF8sRyxWLHVlLFksWik9PihyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1SLlEpKGQsZix3LEMsXyxHLFYsdWUsWSxaKSxyLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0oZCxmKT0+KHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPVIuUikoZCxmKSxyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KGQsZix3KT0+KHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1SLlMpKGQsZix3KSxyLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KGQsZix3KT0+KHIuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1SLlQpKGQsZix3KSxyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZD0+KHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1SLlUpKGQpLHIuX09ydENyZWF0ZVNlc3Npb249KGQsZix3KT0+KHIuX09ydENyZWF0ZVNlc3Npb249Ui5WKShkLGYsdyksci5fT3J0UmVsZWFzZVNlc3Npb249ZD0+KHIuX09ydFJlbGVhc2VTZXNzaW9uPVIuVykoZCksci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0oZCxmLHcpPT4oci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1SLlgpKGQsZix3KSxyLl9PcnRHZXRJbnB1dE5hbWU9KGQsZik9PihyLl9PcnRHZXRJbnB1dE5hbWU9Ui5ZKShkLGYpLHIuX09ydEdldE91dHB1dE5hbWU9KGQsZik9PihyLl9PcnRHZXRPdXRwdXROYW1lPVIuWikoZCxmKSxyLl9PcnRGcmVlPWQ9PihyLl9PcnRGcmVlPVIuXykoZCksci5fT3J0Q3JlYXRlVGVuc29yPShkLGYsdyxDLF8sRyk9PihyLl9PcnRDcmVhdGVUZW5zb3I9Ui4kKShkLGYsdyxDLF8sRyksci5fT3J0R2V0VGVuc29yRGF0YT0oZCxmLHcsQyxfKT0+KHIuX09ydEdldFRlbnNvckRhdGE9Ui5hYSkoZCxmLHcsQyxfKSxyLl9PcnRSZWxlYXNlVGVuc29yPWQ9PihyLl9PcnRSZWxlYXNlVGVuc29yPVIuYmEpKGQpLHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGQsZix3LEMpPT4oci5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1SLmNhKShkLGYsdyxDKSxyLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oZCxmLHcpPT4oci5fT3J0QWRkUnVuQ29uZmlnRW50cnk9Ui5kYSkoZCxmLHcpLHIuX09ydFJlbGVhc2VSdW5PcHRpb25zPWQ9PihyLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1SLmVhKShkKSxyLl9PcnRDcmVhdGVCaW5kaW5nPWQ9PihyLl9PcnRDcmVhdGVCaW5kaW5nPVIuZmEpKGQpLHIuX09ydEJpbmRJbnB1dD0oZCxmLHcpPT4oci5fT3J0QmluZElucHV0PVIuZ2EpKGQsZix3KSxyLl9PcnRCaW5kT3V0cHV0PShkLGYsdyxDKT0+KHIuX09ydEJpbmRPdXRwdXQ9Ui5oYSkoZCxmLHcsQyksci5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9ZD0+KHIuX09ydENsZWFyQm91bmRPdXRwdXRzPVIuaWEpKGQpLHIuX09ydFJlbGVhc2VCaW5kaW5nPWQ9PihyLl9PcnRSZWxlYXNlQmluZGluZz1SLmphKShkKSxyLl9PcnRSdW5XaXRoQmluZGluZz0oZCxmLHcsQyxfKT0+KHIuX09ydFJ1bldpdGhCaW5kaW5nPVIua2EpKGQsZix3LEMsXyksci5fT3J0UnVuPShkLGYsdyxDLF8sRyxWLHVlKT0+KHIuX09ydFJ1bj1SLmxhKShkLGYsdyxDLF8sRyxWLHVlKSxyLl9PcnRFbmRQcm9maWxpbmc9ZD0+KHIuX09ydEVuZFByb2ZpbGluZz1SLm1hKShkKSxyLl9Kc2VwT3V0cHV0PShkLGYsdyk9PihyLl9Kc2VwT3V0cHV0PVIubmEpKGQsZix3KSxyLl9Kc2VwR2V0Tm9kZU5hbWU9ZD0+KHIuX0pzZXBHZXROb2RlTmFtZT1SLm9hKShkKTt2YXIgR3Q9ci5fbWFsbG9jPWQ9PihHdD1yLl9tYWxsb2M9Ui5wYSkoZCksZXI9ci5fZnJlZT1kPT4oZXI9ci5fZnJlZT1SLnFhKShkKSx0cj1kPT4odHI9Ui5zYSkoZCkscnI9KCk9Pihycj1SLnRhKSgpLG5yPWQ9Pihucj1SLnVhKShkKSxhcj1kPT4oYXI9Ui52YSkoZCksb3I9ZD0+KG9yPVIueGEpKGQpLGlyPSgpPT4oaXI9Ui55YSkoKSxGdD1kPT4oRnQ9Ui56YSkoZCksVHQ9KCk9PihUdD1SLkFhKSgpO3IuX19fc3RhcnRfZW1fanM9OTI0NTg3LHIuX19fc3RvcF9lbV9qcz05MjQ3NDg7ZnVuY3Rpb24gYnQoZCl7ZD1PYmplY3QuYXNzaWduKHt9LGQpO3ZhciBmPUM9PigpPT5DKCk+Pj4wLHc9Qz0+Xz0+QyhfKT4+PjA7cmV0dXJuIGQuX19lcnJub19sb2NhdGlvbj1mKGQuX19lcnJub19sb2NhdGlvbiksZC5tYWxsb2M9dyhkLm1hbGxvYyksZC5zdGFja1NhdmU9ZihkLnN0YWNrU2F2ZSksZC5zdGFja0FsbG9jPXcoZC5zdGFja0FsbG9jKSxkfXIuc3RhY2tBbGxvYz1hcixyLnN0YWNrU2F2ZT1ycixyLnN0YWNrUmVzdG9yZT1ucixyLlVURjhUb1N0cmluZz1SZSxyLnN0cmluZ1RvVVRGOD0oZCxmLHcpPT5LdChkLGxlLGYsdyksci5sZW5ndGhCeXRlc1VURjg9enQ7dmFyIFJ0O0xlPWZ1bmN0aW9uIGQoKXtSdHx8c3IoKSxSdHx8KExlPWQpfTtmdW5jdGlvbiBzcigpe2Z1bmN0aW9uIGQoKXtpZighUnQmJihSdD0hMCxyLmNhbGxlZFJ1bj0hMCwhVykpe2lmKEF0KFNlKSxhKHIpLHIub25SdW50aW1lSW5pdGlhbGl6ZWQmJnIub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxyLnBvc3RSdW4pZm9yKHR5cGVvZiByLnBvc3RSdW49PVwiZnVuY3Rpb25cIiYmKHIucG9zdFJ1bj1bci5wb3N0UnVuXSk7ci5wb3N0UnVuLmxlbmd0aDspe3ZhciBmPXIucG9zdFJ1bi5zaGlmdCgpO1RlLnVuc2hpZnQoZil9QXQoVGUpfX1pZighKDA8Q2UpKXtpZihyLnByZVJ1bilmb3IodHlwZW9mIHIucHJlUnVuPT1cImZ1bmN0aW9uXCImJihyLnByZVJ1bj1bci5wcmVSdW5dKTtyLnByZVJ1bi5sZW5ndGg7KUVlKCk7QXQoaiksMDxDZXx8KHIuc2V0U3RhdHVzPyhyLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dChmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtyLnNldFN0YXR1cyhcIlwiKX0sMSksZCgpfSwxKSk6ZCgpKX19aWYoci5wcmVJbml0KWZvcih0eXBlb2Ygci5wcmVJbml0PT1cImZ1bmN0aW9uXCImJihyLnByZUluaXQ9W3IucHJlSW5pdF0pOzA8ci5wcmVJbml0Lmxlbmd0aDspci5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIHNyKCksdC5yZWFkeX19KSgpO3R5cGVvZiB2bz09XCJvYmplY3RcIiYmdHlwZW9mIERuPT1cIm9iamVjdFwiP0RuLmV4cG9ydHM9d286dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9PndvKX0pO3ZhciB4bz1MdCgoKT0+e30pO3ZhciBTbz1MdCgoKT0+e30pO3ZhciBDbz17fTtrdChDbyx7Y3B1czooKT0+Vmx9KTt2YXIgVmwsSW89TCgoKT0+e1ZsPXZvaWQgMH0pO3ZhciBfbz1MdCgoRW8sem4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEFvPSgoKT0+e3ZhciBlPXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYoZT1lfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbih0PXt9KXtmdW5jdGlvbiByKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLENlfWZ1bmN0aW9uIGEoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksZ3R9ZnVuY3Rpb24gbigpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxMZX1mdW5jdGlvbiBzKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLHFlfWZ1bmN0aW9uIHUoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksVX1mdW5jdGlvbiBsKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLGRlfXZhciBvPXQscCxtO28ucmVhZHk9bmV3IFByb21pc2UoKGksYyk9PntwPWksbT1jfSksby5qc2VwSW5pdD0oaSxjLGgseCxBLGssTixhZSk9PntvLlFiPWksby53Yj1jLG8ueWI9aCxvLmpiPXgsby54Yj1BLG8uRWE9ayxvLnpiPU4sby5BYj1hZSxjPShlZSxRLHJlKT0+KC4uLmhlKT0+e2xldCBiZT1ydCxPPVE/LigpO2hlPWVlKC4uLmhlKTtsZXQgc2U9UT8uKCk7cmV0dXJuIE8hPT1zZSYmKGVlPXNlLHJlKE8pLFE9cmU9bnVsbCkscnQhPWJlP0lsKCk6aGV9LGg9ZWU9PmFzeW5jKC4uLlEpPT57dHJ5e2lmKG8uYmIpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIGFscmVhZHkgc3RhcnRlZFwiKTtsZXQgcmU9by5iYj17RmI6UVswXSxlcnJvcnM6W119LGhlPWF3YWl0IGVlKC4uLlEpO2lmKG8uYmIhPT1yZSl0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7aS5mbHVzaCgpO2xldCBiZT1yZS5lcnJvcnM7aWYoMDxiZS5sZW5ndGgpe2xldCBPPWF3YWl0IFByb21pc2UuYWxsKGJlKTtpZihPPU8uZmlsdGVyKHNlPT5zZSksMDxPLmxlbmd0aCl0aHJvdyBFcnJvcihPLmpvaW4oYFxuYCkpfXJldHVybiBoZX1maW5hbGx5e28uYmI9bnVsbH19LG8uX09ydFJ1bj1oKGMoby5fT3J0UnVuLCgpPT5vLl9PcnRSdW4sZWU9Pm8uX09ydFJ1bj1lZSkpLG8uX09ydFJ1bldpdGhCaW5kaW5nPWgoYyhvLl9PcnRSdW5XaXRoQmluZGluZywoKT0+by5fT3J0UnVuV2l0aEJpbmRpbmcsZWU9Pm8uX09ydFJ1bldpdGhCaW5kaW5nPWVlKSksby5fT3J0QmluZElucHV0PWMoby5fT3J0QmluZElucHV0LCgpPT5vLl9PcnRCaW5kSW5wdXQsZWU9Pm8uX09ydEJpbmRJbnB1dD1lZSksby5qc2VwUmVnaXN0ZXJCdWZmZXI9KGVlLFEscmUsaGUpPT5pLnJlZ2lzdGVyQnVmZmVyKGVlLFEscmUsaGUpLG8uanNlcFVucmVnaXN0ZXJCdWZmZXJzPWVlPT57aS51bnJlZ2lzdGVyQnVmZmVycyhlZSl9LG8uanNlcEdldEJ1ZmZlcj1lZT0+aS5nZXRCdWZmZXIoZWUpLG8uanNlcENyZWF0ZURvd25sb2FkZXI9KGVlLFEscmUpPT5pLmNyZWF0ZURvd25sb2FkZXIoZWUsUSxyZSl9O3ZhciB5PU9iamVjdC5hc3NpZ24oe30sbyksZz1cIi4vdGhpcy5wcm9ncmFtXCIsdj0oaSxjKT0+e3Rocm93IGN9LCQ9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIixiPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsUz10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIsST1vLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLFQ9XCJcIjtmdW5jdGlvbiBCKGkpe3JldHVybiBvLmxvY2F0ZUZpbGU/by5sb2NhdGVGaWxlKGksVCk6VCtpfXZhciBQLEQsUjtpZihTKXt2YXIgVz0oa24oKSx2dChQbikpLEg9KE1uKCksdnQoQm4pKTtUPWI/SC5kaXJuYW1lKFQpK1wiL1wiOl9fZGlybmFtZStcIi9cIixQPShjLGgpPT4oYz1jLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwoYyk6SC5ub3JtYWxpemUoYyksVy5yZWFkRmlsZVN5bmMoYyxoP3ZvaWQgMDpcInV0ZjhcIikpLFI9Yz0+KGM9UChjLCEwKSxjLmJ1ZmZlcnx8KGM9bmV3IFVpbnQ4QXJyYXkoYykpLGMpLEQ9KGMsaCx4LEE9ITApPT57Yz1jLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwoYyk6SC5ub3JtYWxpemUoYyksVy5yZWFkRmlsZShjLEE/dm9pZCAwOlwidXRmOFwiLChrLE4pPT57az94KGspOmgoQT9OLmJ1ZmZlcjpOKX0pfSwhby50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoZz1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHY9KGMsaCk9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWMsaH0sby5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7bGV0IGk7dHJ5e2k9eG8oKX1jYXRjaChjKXt0aHJvdyBjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKSxjfWdsb2JhbC5Xb3JrZXI9aS5Xb3JrZXJ9ZWxzZSgkfHxiKSYmKGI/VD1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoVD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksdHlwZW9mIGU8XCJ1XCImJmUmJihUPWUpLFQuaW5kZXhPZihcImJsb2I6XCIpIT09MD9UPVQuc3Vic3RyKDAsVC5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpUPVwiXCIsU3x8KFA9aT0+e3ZhciBjPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYy5vcGVuKFwiR0VUXCIsaSwhMSksYy5zZW5kKG51bGwpLGMucmVzcG9uc2VUZXh0fSxiJiYoUj1pPT57dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBjLm9wZW4oXCJHRVRcIixpLCExKSxjLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsYy5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGMucmVzcG9uc2UpfSksRD0oaSxjLGgpPT57dmFyIHg9bmV3IFhNTEh0dHBSZXF1ZXN0O3gub3BlbihcIkdFVFwiLGksITApLHgucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix4Lm9ubG9hZD0oKT0+e3guc3RhdHVzPT0yMDB8fHguc3RhdHVzPT0wJiZ4LnJlc3BvbnNlP2MoeC5yZXNwb25zZSk6aCgpfSx4Lm9uZXJyb3I9aCx4LnNlbmQobnVsbCl9KSk7UyYmdHlwZW9mIHBlcmZvcm1hbmNlPlwidVwiJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPVNvKCkucGVyZm9ybWFuY2UpO3ZhciBLPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksbGU9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1MmJihLPSguLi5pKT0+Vy53cml0ZVN5bmMoMSxpLmpvaW4oXCIgXCIpK2BcbmApLGxlPSguLi5pKT0+Vy53cml0ZVN5bmMoMixpLmpvaW4oXCIgXCIpK2BcbmApKTt2YXIgTT1vLnByaW50fHxLLHE9by5wcmludEVycnx8bGU7T2JqZWN0LmFzc2lnbihvLHkpLHk9bnVsbCxvLnRoaXNQcm9ncmFtJiYoZz1vLnRoaXNQcm9ncmFtKSxvLnF1aXQmJih2PW8ucXVpdCk7dmFyIHhlO28ud2FzbUJpbmFyeSYmKHhlPW8ud2FzbUJpbmFyeSk7dmFyIG9lPW8ubm9FeGl0UnVudGltZXx8ITA7dHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZKZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIHdlLGosU2UsVGU9ITEsRWUsQ2UsZ3QsTGUscWUsVSxkZTtmdW5jdGlvbiBwZSgpe3ZhciBpPXdlLmJ1ZmZlcjtvLkhFQVA4PUNlPW5ldyBJbnQ4QXJyYXkoaSksby5IRUFQMTY9bmV3IEludDE2QXJyYXkoaSksby5IRUFQMzI9TGU9bmV3IEludDMyQXJyYXkoaSksby5IRUFQVTg9Z3Q9bmV3IFVpbnQ4QXJyYXkoaSksby5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShpKSxvLkhFQVBVMzI9cWU9bmV3IFVpbnQzMkFycmF5KGkpLG8uSEVBUEYzMj1VPW5ldyBGbG9hdDMyQXJyYXkoaSksby5IRUFQRjY0PWRlPW5ldyBGbG9hdDY0QXJyYXkoaSl9dmFyIE5lPW8uSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKDUyNDI4ODA8PU5lfHxKZShcIklOSVRJQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBTVEFDS19TSVpFLCB3YXMgXCIrTmUrXCIhIChTVEFDS19TSVpFPTUyNDI4ODApXCIpLEkpd2U9by53YXNtTWVtb3J5O2Vsc2UgaWYoby53YXNtTWVtb3J5KXdlPW8ud2FzbU1lbW9yeTtlbHNlIGlmKHdlPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6TmUvNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSwhKHdlLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBxKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLFMmJnEoXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZC9vciByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO3BlKCksTmU9d2UuYnVmZmVyLmJ5dGVMZW5ndGg7dmFyIEhlPVtdLE9lPVtdLHplPVtdLEdlPTA7ZnVuY3Rpb24gZXQoKXtyZXR1cm4gb2V8fDA8R2V9dmFyIEtlPTAsQXQ9bnVsbCxFdD1udWxsO2Z1bmN0aW9uIGp0KCl7S2UrKyxvLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJm8ubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhLZSl9ZnVuY3Rpb24gJHIoKXtpZihLZS0tLG8ubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEtlKSxLZT09MCYmKEF0IT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoQXQpLEF0PW51bGwpLEV0KSl7dmFyIGk9RXQ7RXQ9bnVsbCxpKCl9fWZ1bmN0aW9uIEplKGkpe3Rocm93IG8ub25BYm9ydCYmby5vbkFib3J0KGkpLGk9XCJBYm9ydGVkKFwiK2krXCIpXCIscShpKSxUZT0hMCxFZT0xLGk9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihpK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxtKGkpLGl9ZnVuY3Rpb24gcXQoaSl7cmV0dXJuIGkuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9dmFyIFJlO1JlPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCIscXQoUmUpfHwoUmU9QihSZSkpO2Z1bmN0aW9uIHp0KGkpe2lmKGk9PVJlJiZ4ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGUpO2lmKFIpcmV0dXJuIFIoaSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gS3QoaSl7aWYoIXhlJiYoJHx8Yikpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYhaS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goaSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihjPT57aWYoIWMub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2krXCInXCI7cmV0dXJuIGMuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT56dChpKSk7aWYoRClyZXR1cm4gbmV3IFByb21pc2UoKGMsaCk9PntEKGkseD0+YyhuZXcgVWludDhBcnJheSh4KSksaCl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+enQoaSkpfWZ1bmN0aW9uIGx0KGksYyxoKXtyZXR1cm4gS3QoaSkudGhlbih4PT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh4LGMpKS50aGVuKHg9PngpLnRoZW4oaCx4PT57cShcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3gpLEplKHgpfSl9ZnVuY3Rpb24geHIoaSxjKXt2YXIgaD1SZTtyZXR1cm4geGV8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxxdChoKXx8aC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8U3x8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/bHQoaCxpLGMpOmZldGNoKGgse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oeD0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoeCxpKS50aGVuKGMsZnVuY3Rpb24oQSl7cmV0dXJuIHEoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrQSkscShcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLGx0KGgsaSxjKX0pKX12YXIgZHQsV3Q9ezkxNDk4ODppPT57by5FYShcIkFic1wiLGksdm9pZCAwKX0sOTE1MDM5Omk9PntvLkVhKFwiTmVnXCIsaSx2b2lkIDApfSw5MTUwOTA6aT0+e28uRWEoXCJGbG9vclwiLGksdm9pZCAwKX0sOTE1MTQzOmk9PntvLkVhKFwiQ2VpbFwiLGksdm9pZCAwKX0sOTE1MTk1Omk9PntvLkVhKFwiUmVjaXByb2NhbFwiLGksdm9pZCAwKX0sOTE1MjUzOmk9PntvLkVhKFwiU3FydFwiLGksdm9pZCAwKX0sOTE1MzA1Omk9PntvLkVhKFwiRXhwXCIsaSx2b2lkIDApfSw5MTUzNTY6aT0+e28uRWEoXCJFcmZcIixpLHZvaWQgMCl9LDkxNTQwNzppPT57by5FYShcIlNpZ21vaWRcIixpLHZvaWQgMCl9LDkxNTQ2MjppPT57by5FYShcIkxvZ1wiLGksdm9pZCAwKX0sOTE1NTEzOmk9PntvLkVhKFwiU2luXCIsaSx2b2lkIDApfSw5MTU1NjQ6aT0+e28uRWEoXCJDb3NcIixpLHZvaWQgMCl9LDkxNTYxNTppPT57by5FYShcIlRhblwiLGksdm9pZCAwKX0sOTE1NjY2Omk9PntvLkVhKFwiQXNpblwiLGksdm9pZCAwKX0sOTE1NzE4Omk9PntvLkVhKFwiQWNvc1wiLGksdm9pZCAwKX0sOTE1NzcwOmk9PntvLkVhKFwiQXRhblwiLGksdm9pZCAwKX0sOTE1ODIyOmk9PntvLkVhKFwiU2luaFwiLGksdm9pZCAwKX0sOTE1ODc0Omk9PntvLkVhKFwiQ29zaFwiLGksdm9pZCAwKX0sOTE1OTI2Omk9PntvLkVhKFwiQXNpbmhcIixpLHZvaWQgMCl9LDkxNTk3OTppPT57by5FYShcIkFjb3NoXCIsaSx2b2lkIDApfSw5MTYwMzI6aT0+e28uRWEoXCJBdGFuaFwiLGksdm9pZCAwKX0sOTE2MDg1Omk9PntvLkVhKFwiVGFuaFwiLGksdm9pZCAwKX0sOTE2MTM3Omk9PntvLkVhKFwiTm90XCIsaSx2b2lkIDApfSw5MTYxODg6KGksYyxoKT0+e28uRWEoXCJDbGlwVjEwXCIsaSx7bWluOmMsbWF4Omh9KX0sOTE2MjYwOmk9PntvLkVhKFwiQ2xpcFwiLGksdm9pZCAwKX0sOTE2MzEyOihpLGMpPT57by5FYShcIkVsdVwiLGkse2FscGhhOmN9KX0sOTE2MzcwOmk9PntvLkVhKFwiUmVsdVwiLGksdm9pZCAwKX0sOTE2NDIyOihpLGMpPT57by5FYShcIkxlYWt5UmVsdVwiLGkse2FscGhhOmN9KX0sOTE2NDg2OihpLGMpPT57by5FYShcIlRocmVzaG9sZGVkUmVsdVwiLGkse2FscGhhOmN9KX0sOTE2NTU2OihpLGMpPT57by5FYShcIkNhc3RcIixpLHt0bzpjfSl9LDkxNjYxNDppPT57by5FYShcIkFkZFwiLGksdm9pZCAwKX0sOTE2NjY1Omk9PntvLkVhKFwiU3ViXCIsaSx2b2lkIDApfSw5MTY3MTY6aT0+e28uRWEoXCJNdWxcIixpLHZvaWQgMCl9LDkxNjc2NzppPT57by5FYShcIkRpdlwiLGksdm9pZCAwKX0sOTE2ODE4Omk9PntvLkVhKFwiUG93XCIsaSx2b2lkIDApfSw5MTY4Njk6aT0+e28uRWEoXCJFcXVhbFwiLGksdm9pZCAwKX0sOTE2OTIyOmk9PntvLkVhKFwiR3JlYXRlclwiLGksdm9pZCAwKX0sOTE2OTc3Omk9PntvLkVhKFwiR3JlYXRlck9yRXF1YWxcIixpLHZvaWQgMCl9LDkxNzAzOTppPT57by5FYShcIkxlc3NcIixpLHZvaWQgMCl9LDkxNzA5MTppPT57by5FYShcIkxlc3NPckVxdWFsXCIsaSx2b2lkIDApfSw5MTcxNTA6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlTWVhblwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTczMTQ6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlTWF4XCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxNzQ3NzooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VNaW5cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE3NjQwOihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZVByb2RcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE3ODA0OihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZVN1bVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTc5Njc6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlTDFcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE4MTI5OihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZUwyXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxODI5MTooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VMb2dTdW1cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE4NDU3OihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZVN1bVNxdWFyZVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTg2MjY6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlTG9nU3VtRXhwXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxODc5NTppPT57by5FYShcIldoZXJlXCIsaSx2b2lkIDApfSw5MTg4NDg6KGksYyxoKT0+e28uRWEoXCJUcmFuc3Bvc2VcIixpLHtwZXJtOmM/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaD4+PjAsaCtjPj4+MCkpOltdfSl9LDkxODk2MTooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8sc2UpPT57by5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6ZWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbaF0sZ3JvdXA6eCxrZXJuZWxfc2hhcGU6W0FdLHBhZHM6W2ssTl0sc3RyaWRlczpbYWVdLHdJc0NvbnN0OigpPT4hIXIoKVtRPj4+MF0sb3V0cHV0UGFkZGluZzpyZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShoZT4+PjAsaGUrcmU+Pj4wKSk6W10sb3V0cHV0U2hhcGU6YmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTz4+PjAsTytiZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKHNlKX0pfSw5MTkzNzU6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPKT0+e28uRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OmFlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaD4+PjAsaCsyPj4+MCkpLGdyb3VwOngsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaz4+PjAsays0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTj4+PjAsTisyPj4+MCkpLHdJc0NvbnN0OigpPT4hIXIoKVtlZT4+PjBdLG91dHB1dFBhZGRpbmc6MDxRP0FycmF5LmZyb20obigpLnN1YmFycmF5KHJlPj4+MCxyZStRPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8aGU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoYmU+Pj4wLGJlK2hlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoTyl9KX0sOTE5OTMyOihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyxzZSk9PntvLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDplZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltoXSxncm91cDp4LGtlcm5lbF9zaGFwZTpbQV0scGFkczpbayxOXSxzdHJpZGVzOlthZV0sd0lzQ29uc3Q6KCk9PiEhcigpW1E+Pj4wXSxvdXRwdXRQYWRkaW5nOnJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGhlPj4+MCxoZStyZT4+PjApKTpbXSxvdXRwdXRTaGFwZTpiZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShPPj4+MCxPK2JlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoc2UpfSl9LDkyMDM0NjooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8pPT57by5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6YWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShoPj4+MCxoKzI+Pj4wKSksZ3JvdXA6eCxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShrPj4+MCxrKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShOPj4+MCxOKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcigpW2VlPj4+MF0sb3V0cHV0UGFkZGluZzowPFE/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkocmU+Pj4wLHJlK1E+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxoZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShiZT4+PjAsYmUraGU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShPKX0pfSw5MjA5MDM6KGksYyk9PntvLkVhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjA5OTQ6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPLHNlLHllKT0+e28uRWEoXCJBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOngsc3RvcmFnZV9vcmRlcjpBLGRpbGF0aW9uczpbayxOXSxrZXJuZWxfc2hhcGU6W2FlLGVlXSxwYWRzOltRLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjEyNzg6KGksYyk9PntvLkVhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjEzNjk6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPLHNlLHllKT0+e28uRWEoXCJBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOngsc3RvcmFnZV9vcmRlcjpBLGRpbGF0aW9uczpbayxOXSxrZXJuZWxfc2hhcGU6W2FlLGVlXSxwYWRzOltRLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjE2NTM6KGksYyk9PntvLkVhKFwiR2xvYmFsTWF4UG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMTc0MDooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8sc2UseWUpPT57by5FYShcIk1heFBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDp4LHN0b3JhZ2Vfb3JkZXI6QSxkaWxhdGlvbnM6W2ssTl0sa2VybmVsX3NoYXBlOlthZSxlZV0scGFkczpbUSxyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIyMDIwOihpLGMpPT57by5FYShcIkdsb2JhbE1heFBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjIxMDc6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPLHNlLHllKT0+e28uRWEoXCJNYXhQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6eCxzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltrLE5dLGtlcm5lbF9zaGFwZTpbYWUsZWVdLHBhZHM6W1EscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMjM4NzooaSxjLGgseCxBKT0+e28uRWEoXCJHZW1tXCIsaSx7YWxwaGE6YyxiZXRhOmgsdHJhbnNBOngsdHJhbnNCOkF9KX0sOTIyNDkxOmk9PntvLkVhKFwiTWF0TXVsXCIsaSx2b2lkIDApfSw5MjI1NDU6KGksYyxoLHgpPT57by5FYShcIkFyZ01heFwiLGkse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFoLGF4aXM6eH0pfSw5MjI2NTM6KGksYyxoLHgpPT57by5FYShcIkFyZ01pblwiLGkse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFoLGF4aXM6eH0pfSw5MjI3NjE6KGksYyk9PntvLkVhKFwiU29mdG1heFwiLGkse2F4aXM6Y30pfSw5MjI4MjQ6KGksYyk9PntvLkVhKFwiQ29uY2F0XCIsaSx7YXhpczpjfSl9LDkyMjg4NDooaSxjLGgseCxBKT0+e28uRWEoXCJTcGxpdFwiLGkse2F4aXM6YyxudW1PdXRwdXRzOmgsc3BsaXRTaXplczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MjMwMjk6aT0+e28uRWEoXCJFeHBhbmRcIixpLHZvaWQgMCl9LDkyMzA4MzooaSxjKT0+e28uRWEoXCJHYXRoZXJcIixpLHtheGlzOk51bWJlcihjKX0pfSw5MjMxNTQ6KGksYyk9PntvLkVhKFwiR2F0aGVyRWxlbWVudHNcIixpLHtheGlzOk51bWJlcihjKX0pfSw5MjMyMzM6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSk9PntvLkVhKFwiUmVzaXplXCIsaSx7YW50aWFsaWFzOmMsYXhlczpoP0FycmF5LmZyb20obigpLnN1YmFycmF5KHg+Pj4wLHgraD4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpWZShBKSxjdWJpY0NvZWZmQTprLGV4Y2x1ZGVPdXRzaWRlOk4sZXh0cmFwb2xhdGlvblZhbHVlOmFlLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpWZShlZSksbW9kZTpWZShRKSxuZWFyZXN0TW9kZTpWZShyZSl9KX0sOTIzNTg0OihpLGMsaCx4LEEsayxOKT0+e28uRWEoXCJTbGljZVwiLGkse3N0YXJ0czpjP0FycmF5LmZyb20obigpLnN1YmFycmF5KGg+Pj4wLGgrYz4+PjApKTpbXSxlbmRzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdLGF4ZXM6az9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShOPj4+MCxOK2s+Pj4wKSk6W119KX0sOTIzODE1Omk9PntvLkVhKFwiVGlsZVwiLGksdm9pZCAwKX0sOTIzODY3OihpLGMsaCk9PntvLkVhKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsaSx7YXhpczpOdW1iZXIoYyksZXBzaWxvbjpOdW1iZXIoaCl9KX0sOTIzOTc0OihpLGMsaCk9PntvLkVhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjpjLGZvcm1hdDpoP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNDA4ODooaSxjLGgpPT57by5FYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246Yyxmb3JtYXQ6aD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjQyMDI6aT0+e28uRWEoXCJSYW5nZVwiLGksdm9pZCAwKX0sOTI0MjU1OihpLGMpPT57by5FYShcIkVpbnN1bVwiLGkse2VxdWF0aW9uOlZlKGMpfSl9LDkyNDMzNjooaSxjLGgseCxBKT0+e28uRWEoXCJQYWRcIixpLHttb2RlOmMsdmFsdWU6aCxwYWRzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkyNDQ2ODppPT57by5FYShcIkdlbHVcIixpLHZvaWQgMCl9LDkyNDUyMDppPT57by5FYShcIkJpYXNBZGRcIixpLHZvaWQgMCl9LDkyNDU3NTppPT57by5FYShcIkJpYXNTcGxpdEdlbHVcIixpLHZvaWQgMCl9LDkyNDYzNjooaSxjKT0+e28uRWEoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjpjfSl9LDkyNDcxNzooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlKT0+e28uRWEoXCJDb252XCIsaSx7Zm9ybWF0OmVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsZGlsYXRpb25zOltoXSxncm91cDp4LGtlcm5lbF9zaGFwZTpbQV0scGFkczprP0FycmF5LmZyb20obigpLnN1YmFycmF5KE4+Pj4wLE4raz4+PjApKTpbXSxzdHJpZGVzOlthZV0sd19pc19jb25zdDooKT0+ISFyKClbUT4+PjBdLGFjdGl2YXRpb246VmUocmUpLGFjdGl2YXRpb25fcGFyYW1zOmhlP0FycmF5LmZyb20odSgpLnN1YmFycmF5KGJlPj4+MCxiZStoZT4+PjApKTpbXX0pfSw5MjUwOTg6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPLHNlLHllKT0+e28uRWEoXCJDb252XCIsaSx7Zm9ybWF0OmhlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsZGlsYXRpb25zOltoLHhdLGdyb3VwOkEsa2VybmVsX3NoYXBlOltrLE5dLHBhZHM6YWU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoZWU+Pj4wLGVlK2FlPj4+MCkpOltdLHN0cmlkZXM6W1EscmVdLHdfaXNfY29uc3Q6KCk9PiEhcigpW2JlPj4+MF0sYWN0aXZhdGlvbjpWZShPKSxhY3RpdmF0aW9uX3BhcmFtczpzZT9BcnJheS5mcm9tKHUoKS5zdWJhcnJheSh5ZT4+PjAseWUrc2U+Pj4wKSk6W119KX0sOTI1NTAwOmk9PntvLnpiKGkpfSw5MjU1MzQ6KGksYyk9Pm8uQWIoaSxjLG8uYmIuRmIsby5iYi5lcnJvcnMpLDkyNTY0NjppPT5vLndiKGkpLDkyNTY3OTppPT5vLnliKGkpLDkyNTcxMTooaSxjLGgpPT57by5qYihpLGMsaCwhMCl9LDkyNTc1MDooaSxjLGgpPT57by5qYihpLGMsaCl9fTtmdW5jdGlvbiB5dChpKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7aX0pYCx0aGlzLnN0YXR1cz1pfWZ1bmN0aW9uIE50KGkpe2kudGVybWluYXRlKCksaS5vbm1lc3NhZ2U9KCk9Pnt9fWZ1bmN0aW9uIFZ0KGkpeyhpPW5lLlFhW2ldKXx8SmUoKSxuZS5FYihpKX1mdW5jdGlvbiBZdChpKXt2YXIgYz1uZS50YigpO2lmKCFjKXJldHVybiA2O25lLllhLnB1c2goYyksbmUuUWFbaS5YYV09YyxjLlhhPWkuWGE7dmFyIGg9e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6aS5HYixhcmc6aS5yYixwdGhyZWFkX3B0cjppLlhhfTtyZXR1cm4gUyYmYy51bnJlZigpLGMucG9zdE1lc3NhZ2UoaCxpLk1iKSwwfXZhciBVdD10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsU3I9KGksYyxoKT0+e2M+Pj49MDt2YXIgeD1jK2g7Zm9yKGg9YztpW2hdJiYhKGg+PXgpOykrK2g7aWYoMTY8aC1jJiZpLmJ1ZmZlciYmVXQpcmV0dXJuIFV0LmRlY29kZShpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP2kuc2xpY2UoYyxoKTppLnN1YmFycmF5KGMsaCkpO2Zvcih4PVwiXCI7YzxoOyl7dmFyIEE9aVtjKytdO2lmKEEmMTI4KXt2YXIgaz1pW2MrK10mNjM7aWYoKEEmMjI0KT09MTkyKXgrPVN0cmluZy5mcm9tQ2hhckNvZGUoKEEmMzEpPDw2fGspO2Vsc2V7dmFyIE49aVtjKytdJjYzO0E9KEEmMjQwKT09MjI0PyhBJjE1KTw8MTJ8azw8NnxOOihBJjcpPDwxOHxrPDwxMnxOPDw2fGlbYysrXSY2Myw2NTUzNj5BP3grPVN0cmluZy5mcm9tQ2hhckNvZGUoQSk6KEEtPTY1NTM2LHgrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8QT4+MTAsNTYzMjB8QSYxMDIzKSl9fWVsc2UgeCs9U3RyaW5nLmZyb21DaGFyQ29kZShBKX1yZXR1cm4geH0sVmU9KGksYyk9PihpPj4+PTApP1NyKGEoKSxpLGMpOlwiXCI7ZnVuY3Rpb24gWHQoaSl7aWYoSSlyZXR1cm4gVigxLDEsaSk7RWU9aSxldCgpfHwobmUuSGIoKSxvLm9uRXhpdCYmby5vbkV4aXQoaSksVGU9ITApLHYoaSxuZXcgeXQoaSkpfXZhciBKdD1pPT57aWYoRWU9aSxJKXRocm93IENyKGkpLFwidW53aW5kXCI7WHQoaSl9LG5lPXthYjpbXSxZYTpbXSxtYjpbXSxRYTp7fSxnYjpmdW5jdGlvbigpe0k/bmUudmIoKTpuZS51YigpfSx1YjpmdW5jdGlvbigpe0hlLnVuc2hpZnQoKCk9PntqdCgpLG5lLkJiKCgpPT4kcigpKX0pfSx2YjpmdW5jdGlvbigpe25lLnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1uZS5EYixuZS50aHJlYWRJbml0VExTPW5lLmxiLG5lLnNldEV4aXRTdGF0dXM9bmUua2Isb2U9ITF9LGtiOmZ1bmN0aW9uKGkpe0VlPWl9LFNiOltcIiR0ZXJtaW5hdGVXb3JrZXJcIl0sSGI6ZnVuY3Rpb24oKXtmb3IodmFyIGkgb2YgbmUuWWEpTnQoaSk7Zm9yKGkgb2YgbmUuYWIpTnQoaSk7bmUuYWI9W10sbmUuWWE9W10sbmUuUWE9W119LEViOmZ1bmN0aW9uKGkpe3ZhciBjPWkuWGE7ZGVsZXRlIG5lLlFhW2NdLG5lLmFiLnB1c2goaSksbmUuWWEuc3BsaWNlKG5lLllhLmluZGV4T2YoaSksMSksaS5YYT0wLENuKGMpfSxEYjpmdW5jdGlvbigpe30sbGI6ZnVuY3Rpb24oKXtuZS5tYi5mb3JFYWNoKGk9PmkoKSl9LENiOmk9Pm5ldyBQcm9taXNlKGM9PntpLm9ubWVzc2FnZT1rPT57az1rLmRhdGE7dmFyIE49ay5jbWQ7aWYoay50YXJnZXRUaHJlYWQmJmsudGFyZ2V0VGhyZWFkIT1NcigpKXt2YXIgYWU9bmUuUWFbay5SYl07YWU/YWUucG9zdE1lc3NhZ2UoayxrLnRyYW5zZmVyTGlzdCk6cSgnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrTisnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytrLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2UgTj09PVwiY2hlY2tNYWlsYm94XCI/VHQoKTpOPT09XCJzcGF3blRocmVhZFwiP1l0KGspOk49PT1cImNsZWFudXBUaHJlYWRcIj9WdChrLnRocmVhZCk6Tj09PVwia2lsbFRocmVhZFwiPyhrPWsudGhyZWFkLE49bmUuUWFba10sZGVsZXRlIG5lLlFhW2tdLE50KE4pLENuKGspLG5lLllhLnNwbGljZShuZS5ZYS5pbmRleE9mKE4pLDEpLE4uWGE9MCk6Tj09PVwiY2FuY2VsVGhyZWFkXCI/bmUuUWFbay50aHJlYWRdLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pOk49PT1cImxvYWRlZFwiPyhpLmxvYWRlZD0hMCxjKGkpKTpOPT09XCJhbGVydFwiP2FsZXJ0KFwiVGhyZWFkIFwiK2sudGhyZWFkSWQrXCI6IFwiK2sudGV4dCk6ay50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiP2kucG9zdE1lc3NhZ2Uoayk6Tj09PVwiY2FsbEhhbmRsZXJcIj9vW2suaGFuZGxlcl0oLi4uay5hcmdzKTpOJiZxKFwid29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kIFwiK04pfSxpLm9uZXJyb3I9az0+e3Rocm93IHEoXCJ3b3JrZXIgc2VudCBhbiBlcnJvciEgXCIray5maWxlbmFtZStcIjpcIitrLmxpbmVubytcIjogXCIray5tZXNzYWdlKSxrfSxTJiYoaS5vbihcIm1lc3NhZ2VcIixmdW5jdGlvbihrKXtpLm9ubWVzc2FnZSh7ZGF0YTprfSl9KSxpLm9uKFwiZXJyb3JcIixmdW5jdGlvbihrKXtpLm9uZXJyb3Ioayl9KSk7dmFyIGg9W10seD1bXCJvbkV4aXRcIixcIm9uQWJvcnRcIixcInByaW50XCIsXCJwcmludEVyclwiXSxBO2ZvcihBIG9mIHgpby5oYXNPd25Qcm9wZXJ0eShBKSYmaC5wdXNoKEEpO2kucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIixoYW5kbGVyczpoLHVybE9yQmxvYjpvLm1haW5TY3JpcHRVcmxPckJsb2J8fGUsd2FzbU1lbW9yeTp3ZSx3YXNtTW9kdWxlOlNlfSl9KSxCYjpmdW5jdGlvbihpKXtpKCl9LHFiOmZ1bmN0aW9uKCl7dmFyIGk9QihcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud29ya2VyLmpzXCIpO2k9bmV3IFdvcmtlcihpKSxuZS5hYi5wdXNoKGkpfSx0YjpmdW5jdGlvbigpe3JldHVybiBuZS5hYi5sZW5ndGg9PTAmJihuZS5xYigpLG5lLkNiKG5lLmFiWzBdKSksbmUuYWIucG9wKCl9fTtvLlBUaHJlYWQ9bmU7dmFyIGN0PWk9Pntmb3IoOzA8aS5sZW5ndGg7KWkuc2hpZnQoKShvKX07by5lc3RhYmxpc2hTdGFja1NwYWNlPWZ1bmN0aW9uKCl7dmFyIGk9TXIoKSxjPW4oKVtpKzUyPj4yPj4+MF07aT1uKClbaSs1Nj4+Mj4+PjBdLERhKGMsYy1pKSxEcihjKX07ZnVuY3Rpb24gQ3IoaSl7aWYoSSlyZXR1cm4gVigyLDAsaSk7SnQoaSl9by5pbnZva2VFbnRyeVBvaW50PWZ1bmN0aW9uKGksYyl7aT16YS5hcHBseShudWxsLFtpLGNdKSxldCgpP25lLmtiKGkpOkluKGkpfTtmdW5jdGlvbiB0dChpKXt0aGlzLmZiPWktMjQsdGhpcy5wYj1mdW5jdGlvbihjKXtzKClbdGhpcy5mYis0Pj4yPj4+MF09Y30sdGhpcy5vYj1mdW5jdGlvbihjKXtzKClbdGhpcy5mYis4Pj4yPj4+MF09Y30sdGhpcy5nYj1mdW5jdGlvbihjLGgpe3RoaXMubmIoKSx0aGlzLnBiKGMpLHRoaXMub2IoaCl9LHRoaXMubmI9ZnVuY3Rpb24oKXtzKClbdGhpcy5mYisxNj4+Mj4+PjBdPTB9fXZhciBZZT0wLElyPTA7ZnVuY3Rpb24gX3QoaSxjLGgseCl7cmV0dXJuIEk/VigzLDEsaSxjLGgseCk6UXQoaSxjLGgseCl9ZnVuY3Rpb24gUXQoaSxjLGgseCl7aWYoaT4+Pj0wLGM+Pj49MCxoPj4+PTAseD4+Pj0wLHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4gcShcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpLDY7dmFyIEE9W107cmV0dXJuIEkmJkEubGVuZ3RoPT09MD9fdChpLGMsaCx4KTooaT17R2I6aCxYYTppLHJiOngsTWI6QX0sST8oaS5PYj1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2UoaSxBKSwwKTpZdChpKSl9ZnVuY3Rpb24gWnQoaSxjLGgpe3JldHVybiBJP1YoNCwxLGksYyxoKTowfWZ1bmN0aW9uIEFyKGksYyl7aWYoSSlyZXR1cm4gVig1LDEsaSxjKX12YXIgT3Q9aT0+e2Zvcih2YXIgYz0wLGg9MDtoPGkubGVuZ3RoOysraCl7dmFyIHg9aS5jaGFyQ29kZUF0KGgpOzEyNz49eD9jKys6MjA0Nz49eD9jKz0yOjU1Mjk2PD14JiY1NzM0Mz49eD8oYys9NCwrK2gpOmMrPTN9cmV0dXJuIGN9LEVyPShpLGMsaCx4KT0+e2lmKGg+Pj49MCwhKDA8eCkpcmV0dXJuIDA7dmFyIEE9aDt4PWgreC0xO2Zvcih2YXIgaz0wO2s8aS5sZW5ndGg7KytrKXt2YXIgTj1pLmNoYXJDb2RlQXQoayk7aWYoNTUyOTY8PU4mJjU3MzQzPj1OKXt2YXIgYWU9aS5jaGFyQ29kZUF0KCsrayk7Tj02NTUzNisoKE4mMTAyMyk8PDEwKXxhZSYxMDIzfWlmKDEyNz49Til7aWYoaD49eClicmVhaztjW2grKz4+PjBdPU59ZWxzZXtpZigyMDQ3Pj1OKXtpZihoKzE+PXgpYnJlYWs7Y1toKys+Pj4wXT0xOTJ8Tj4+Nn1lbHNle2lmKDY1NTM1Pj1OKXtpZihoKzI+PXgpYnJlYWs7Y1toKys+Pj4wXT0yMjR8Tj4+MTJ9ZWxzZXtpZihoKzM+PXgpYnJlYWs7Y1toKys+Pj4wXT0yNDB8Tj4+MTgsY1toKys+Pj4wXT0xMjh8Tj4+MTImNjN9Y1toKys+Pj4wXT0xMjh8Tj4+NiY2M31jW2grKz4+PjBdPTEyOHxOJjYzfX1yZXR1cm4gY1toPj4+MF09MCxoLUF9LF9yPShpLGMsaCk9PkVyKGksYSgpLGMsaCk7ZnVuY3Rpb24gT3IoaSxjKXtpZihJKXJldHVybiBWKDYsMSxpLGMpfWZ1bmN0aW9uIFRyKGksYyxoKXtpZihJKXJldHVybiBWKDcsMSxpLGMsaCl9ZnVuY3Rpb24gUnIoaSxjLGgpe3JldHVybiBJP1YoOCwxLGksYyxoKTowfWZ1bmN0aW9uIFByKGksYyl7aWYoSSlyZXR1cm4gVig5LDEsaSxjKX1mdW5jdGlvbiBHdChpLGMsaCl7aWYoSSlyZXR1cm4gVigxMCwxLGksYyxoKX1mdW5jdGlvbiBlcihpLGMsaCx4KXtpZihJKXJldHVybiBWKDExLDEsaSxjLGgseCl9ZnVuY3Rpb24gdHIoaSxjLGgseCl7aWYoSSlyZXR1cm4gVigxMiwxLGksYyxoLHgpfWZ1bmN0aW9uIHJyKGksYyxoLHgpe2lmKEkpcmV0dXJuIFYoMTMsMSxpLGMsaCx4KX1mdW5jdGlvbiBucihpKXtpZihJKXJldHVybiBWKDE0LDEsaSl9ZnVuY3Rpb24gYXIoaSxjKXtpZihJKXJldHVybiBWKDE1LDEsaSxjKX1mdW5jdGlvbiBvcihpLGMsaCl7aWYoSSlyZXR1cm4gVigxNiwxLGksYyxoKX12YXIgaXI9aT0+e2lmKCFUZSl0cnl7aWYoaSgpLCFldCgpKXRyeXtJP0luKEVlKTpKdChFZSl9Y2F0Y2goYyl7YyBpbnN0YW5jZW9mIHl0fHxjPT1cInVud2luZFwifHx2KDEsYyl9fWNhdGNoKGMpe2MgaW5zdGFuY2VvZiB5dHx8Yz09XCJ1bndpbmRcInx8digxLGMpfX07ZnVuY3Rpb24gRnQoaSl7aT4+Pj0wLHR5cGVvZiBBdG9taWNzLk5iPT1cImZ1bmN0aW9uXCImJihBdG9taWNzLk5iKG4oKSxpPj4yLGkpLnZhbHVlLnRoZW4oVHQpLGkrPTEyOCxBdG9taWNzLnN0b3JlKG4oKSxpPj4yLDEpKX1vLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdD1GdDtmdW5jdGlvbiBUdCgpe3ZhciBpPU1yKCk7aSYmKEZ0KGkpLGlyKCgpPT5CYSgpKSl9by5jaGVja01haWxib3g9VHQ7dmFyIGJ0PWk9PmklND09PTAmJihpJTEwMCE9PTB8fGklNDAwPT09MCksUnQ9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0sc3I9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gZChpLGMsaCx4LEEsayxOLGFlKXtyZXR1cm4gST9WKDE3LDEsaSxjLGgseCxBLGssTixhZSk6LTUyfWZ1bmN0aW9uIGYoaSxjLGgseCxBLGssTil7aWYoSSlyZXR1cm4gVigxOCwxLGksYyxoLHgsQSxrLE4pfXZhciB3PWk9Pnt2YXIgYz1PdChpKSsxLGg9U24oYyk7cmV0dXJuIGgmJl9yKGksaCxjKSxofSxDPVtdLF89KGksYyk9PntDLmxlbmd0aD0wO3ZhciBoO2ZvcihjPj49MjtoPWEoKVtpKys+Pj4wXTspYys9aCE9MTA1JmMsQy5wdXNoKGg9PTEwNT9uKClbYz4+PjBdOmwoKVtjKys+Pj4xXSksKytjO3JldHVybiBDfSxHPWk9Pnt2YXIgYz1BbigpO3JldHVybiBpPWkoKSxEcihjKSxpfTtmdW5jdGlvbiBWKGksYyl7dmFyIGg9YXJndW1lbnRzLmxlbmd0aC0yLHg9YXJndW1lbnRzO3JldHVybiBHKCgpPT57Zm9yKHZhciBBPUVuKDgqaCksaz1BPj4zLE49MDtOPGg7TisrKXt2YXIgYWU9eFsyK05dO2woKVtrK04+Pj4wXT1hZX1yZXR1cm4ga2EoaSxoLEEsYyl9KX12YXIgdWU9W10sWT17fSxaPSgpPT57aWYoIUope3ZhciBpPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmd8fFwiLi90aGlzLnByb2dyYW1cIn0sYztmb3IoYyBpbiBZKVlbY109PT12b2lkIDA/ZGVsZXRlIGlbY106aVtjXT1ZW2NdO3ZhciBoPVtdO2ZvcihjIGluIGkpaC5wdXNoKGAke2N9PSR7aVtjXX1gKTtKPWh9cmV0dXJuIEp9LEo7ZnVuY3Rpb24gY2UoaSxjKXtpZihJKXJldHVybiBWKDE5LDEsaSxjKTtpPj4+PTAsYz4+Pj0wO3ZhciBoPTA7cmV0dXJuIFooKS5mb3JFYWNoKGZ1bmN0aW9uKHgsQSl7dmFyIGs9YytoO2ZvcihBPXMoKVtpKzQqQT4+Mj4+PjBdPWssaz0wO2s8eC5sZW5ndGg7KytrKXIoKVtBKys+PjA+Pj4wXT14LmNoYXJDb2RlQXQoayk7cigpW0E+PjA+Pj4wXT0wLGgrPXgubGVuZ3RoKzF9KSwwfWZ1bmN0aW9uIG1lKGksYyl7aWYoSSlyZXR1cm4gVigyMCwxLGksYyk7aT4+Pj0wLGM+Pj49MDt2YXIgaD1aKCk7cygpW2k+PjI+Pj4wXT1oLmxlbmd0aDt2YXIgeD0wO3JldHVybiBoLmZvckVhY2goZnVuY3Rpb24oQSl7eCs9QS5sZW5ndGgrMX0pLHMoKVtjPj4yPj4+MF09eCwwfWZ1bmN0aW9uIEUoaSl7cmV0dXJuIEk/VigyMSwxLGkpOjUyfWZ1bmN0aW9uIHRlKGksYyxoLHgpe3JldHVybiBJP1YoMjIsMSxpLGMsaCx4KTo1Mn1mdW5jdGlvbiBmZShpLGMsaCx4LEEpe3JldHVybiBJP1YoMjMsMSxpLGMsaCx4LEEpOjcwfXZhciBwdD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gdXIoaSxjLGgseCl7aWYoSSlyZXR1cm4gVigyNCwxLGksYyxoLHgpO2M+Pj49MCxoPj4+PTAseD4+Pj0wO2Zvcih2YXIgQT0wLGs9MDtrPGg7aysrKXt2YXIgTj1zKClbYz4+Mj4+PjBdLGFlPXMoKVtjKzQ+PjI+Pj4wXTtjKz04O2Zvcih2YXIgZWU9MDtlZTxhZTtlZSsrKXt2YXIgUT1hKClbTitlZT4+PjBdLHJlPXB0W2ldO1E9PT0wfHxRPT09MTA/KChpPT09MT9NOnEpKFNyKHJlLDApKSxyZS5sZW5ndGg9MCk6cmUucHVzaChRKX1BKz1hZX1yZXR1cm4gcygpW3g+PjI+Pj4wXT1BLDB9dmFyIElhPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sQWE9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiB2bChpKXt2YXIgYz1BcnJheShPdChpKSsxKTtyZXR1cm4gRXIoaSxjLDAsYy5sZW5ndGgpLGN9dmFyICRsPShpLGMpPT57cigpLnNldChpLGM+Pj4wKX07ZnVuY3Rpb24gRWEoaSxjLGgseCl7ZnVuY3Rpb24gQShPLHNlLHllKXtmb3IoTz10eXBlb2YgTz09XCJudW1iZXJcIj9PLnRvU3RyaW5nKCk6T3x8XCJcIjtPLmxlbmd0aDxzZTspTz15ZVswXStPO3JldHVybiBPfWZ1bmN0aW9uIGsoTyxzZSl7cmV0dXJuIEEoTyxzZSxcIjBcIil9ZnVuY3Rpb24gTihPLHNlKXtmdW5jdGlvbiB5ZShGYSl7cmV0dXJuIDA+RmE/LTE6MDxGYT8xOjB9dmFyIFB0O3JldHVybihQdD15ZShPLmdldEZ1bGxZZWFyKCktc2UuZ2V0RnVsbFllYXIoKSkpPT09MCYmKFB0PXllKE8uZ2V0TW9udGgoKS1zZS5nZXRNb250aCgpKSk9PT0wJiYoUHQ9eWUoTy5nZXREYXRlKCktc2UuZ2V0RGF0ZSgpKSksUHR9ZnVuY3Rpb24gYWUoTyl7c3dpdGNoKE8uZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gTztjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gZWUoTyl7dmFyIHNlPU8uWmE7Zm9yKE89bmV3IERhdGUobmV3IERhdGUoTy4kYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHNlOyl7dmFyIHllPU8uZ2V0TW9udGgoKSxQdD0oYnQoTy5nZXRGdWxsWWVhcigpKT9JYTpBYSlbeWVdO2lmKHNlPlB0LU8uZ2V0RGF0ZSgpKXNlLT1QdC1PLmdldERhdGUoKSsxLE8uc2V0RGF0ZSgxKSwxMT55ZT9PLnNldE1vbnRoKHllKzEpOihPLnNldE1vbnRoKDApLE8uc2V0RnVsbFllYXIoTy5nZXRGdWxsWWVhcigpKzEpKTtlbHNle08uc2V0RGF0ZShPLmdldERhdGUoKStzZSk7YnJlYWt9fXJldHVybiB5ZT1uZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHNlPWFlKG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDQpKSx5ZT1hZSh5ZSksMD49TihzZSxPKT8wPj1OKHllLE8pP08uZ2V0RnVsbFllYXIoKSsxOk8uZ2V0RnVsbFllYXIoKTpPLmdldEZ1bGxZZWFyKCktMX1pPj4+PTAsYz4+Pj0wLGg+Pj49MCx4Pj4+PTA7dmFyIFE9bigpW3grNDA+PjI+Pj4wXTt4PXtLYjpuKClbeD4+Mj4+PjBdLEpiOm4oKVt4KzQ+PjI+Pj4wXSxjYjpuKClbeCs4Pj4yPj4+MF0saWI6bigpW3grMTI+PjI+Pj4wXSxlYjpuKClbeCsxNj4+Mj4+PjBdLCRhOm4oKVt4KzIwPj4yPj4+MF0sV2E6bigpW3grMjQ+PjI+Pj4wXSxaYTpuKClbeCsyOD4+Mj4+PjBdLFRiOm4oKVt4KzMyPj4yPj4+MF0sSWI6bigpW3grMzY+PjI+Pj4wXSxMYjpRP1ZlKFEpOlwiXCJ9LGg9VmUoaCksUT17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgcmUgaW4gUSloPWgucmVwbGFjZShuZXcgUmVnRXhwKHJlLFwiZ1wiKSxRW3JlXSk7dmFyIGhlPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksYmU9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO1E9e1wiJWFcIjpPPT5oZVtPLldhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6Tz0+aGVbTy5XYV0sXCIlYlwiOk89PmJlW08uZWJdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpPPT5iZVtPLmViXSxcIiVDXCI6Tz0+aygoTy4kYSsxOTAwKS8xMDB8MCwyKSxcIiVkXCI6Tz0+ayhPLmliLDIpLFwiJWVcIjpPPT5BKE8uaWIsMixcIiBcIiksXCIlZ1wiOk89PmVlKE8pLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpPPT5lZShPKSxcIiVIXCI6Tz0+ayhPLmNiLDIpLFwiJUlcIjpPPT4oTz1PLmNiLE89PTA/Tz0xMjoxMjxPJiYoTy09MTIpLGsoTywyKSksXCIlalwiOk89Pntmb3IodmFyIHNlPTAseWU9MDt5ZTw9Ty5lYi0xO3NlKz0oYnQoTy4kYSsxOTAwKT9JYTpBYSlbeWUrK10pO3JldHVybiBrKE8uaWIrc2UsMyl9LFwiJW1cIjpPPT5rKE8uZWIrMSwyKSxcIiVNXCI6Tz0+ayhPLkpiLDIpLFwiJW5cIjooKT0+YFxuYCxcIiVwXCI6Tz0+MDw9Ty5jYiYmMTI+Ty5jYj9cIkFNXCI6XCJQTVwiLFwiJVNcIjpPPT5rKE8uS2IsMiksXCIldFwiOigpPT5cIlx0XCIsXCIldVwiOk89Pk8uV2F8fDcsXCIlVVwiOk89PmsoTWF0aC5mbG9vcigoTy5aYSs3LU8uV2EpLzcpLDIpLFwiJVZcIjpPPT57dmFyIHNlPU1hdGguZmxvb3IoKE8uWmErNy0oTy5XYSs2KSU3KS83KTtpZigyPj0oTy5XYSszNzEtTy5aYS0yKSU3JiZzZSsrLHNlKXNlPT01MyYmKHllPShPLldhKzM3MS1PLlphKSU3LHllPT00fHx5ZT09MyYmYnQoTy4kYSl8fChzZT0xKSk7ZWxzZXtzZT01Mjt2YXIgeWU9KE8uV2ErNy1PLlphLTEpJTc7KHllPT00fHx5ZT09NSYmYnQoTy4kYSU0MDAtMSkpJiZzZSsrfXJldHVybiBrKHNlLDIpfSxcIiV3XCI6Tz0+Ty5XYSxcIiVXXCI6Tz0+ayhNYXRoLmZsb29yKChPLlphKzctKE8uV2ErNiklNykvNyksMiksXCIleVwiOk89PihPLiRhKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjpPPT5PLiRhKzE5MDAsXCIlelwiOk89PntPPU8uSWI7dmFyIHNlPTA8PU87cmV0dXJuIE89TWF0aC5hYnMoTykvNjAsKHNlP1wiK1wiOlwiLVwiKSsoXCIwMDAwXCIrKE8vNjAqMTAwK08lNjApKS5zbGljZSgtNCl9LFwiJVpcIjpPPT5PLkxiLFwiJSVcIjooKT0+XCIlXCJ9LGg9aC5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpO2ZvcihyZSBpbiBRKWguaW5jbHVkZXMocmUpJiYoaD1oLnJlcGxhY2UobmV3IFJlZ0V4cChyZSxcImdcIiksUVtyZV0oeCkpKTtyZXR1cm4gaD1oLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKSxyZT12bChoKSxyZS5sZW5ndGg+Yz8wOigkbChyZSxpKSxyZS5sZW5ndGgtMSl9ZnVuY3Rpb24ga3IoaSl7dHJ5e2koKX1jYXRjaChjKXtKZShjKX19ZnVuY3Rpb24geGwoaSl7dmFyIGM9e30saDtmb3IoaCBpbiBpKShmdW5jdGlvbih4KXt2YXIgQT1pW3hdO2NbeF09dHlwZW9mIEE9PVwiZnVuY3Rpb25cIj9mdW5jdGlvbigpe0JyLnB1c2goeCk7dHJ5e3JldHVybiBBLmFwcGx5KG51bGwsYXJndW1lbnRzKX1maW5hbGx5e1RlfHwoQnIucG9wKCk9PT14fHxKZSgpLHJ0JiZ3dD09PTEmJkJyLmxlbmd0aD09PTAmJih3dD0wLEdlKz0xLGtyKE5hKSx0eXBlb2YgRmliZXJzPFwidVwiJiZGaWJlcnMuVWIoKSkpfX06QX0pKGgpO3JldHVybiBjfXZhciB3dD0wLHJ0PW51bGwsX2E9MCxCcj1bXSxPYT17fSxUYT17fSxTbD0wLHhuPW51bGwsQ2w9W107ZnVuY3Rpb24gSWwoKXtyZXR1cm4gbmV3IFByb21pc2UoKGksYyk9Pnt4bj17cmVzb2x2ZTppLHJlamVjdDpjfX0pfWZ1bmN0aW9uIEFsKCl7dmFyIGk9U24oNjU1NDgpLGM9aSsxMjtzKClbaT4+Mj4+PjBdPWMscygpW2krND4+Mj4+PjBdPWMrNjU1MzYsYz1CclswXTt2YXIgaD1PYVtjXTtyZXR1cm4gaD09PXZvaWQgMCYmKGg9U2wrKyxPYVtjXT1oLFRhW2hdPWMpLGM9aCxuKClbaSs4Pj4yPj4+MF09YyxpfWZ1bmN0aW9uIEVsKCl7dmFyIGk9bigpW3J0Kzg+PjI+Pj4wXTtyZXR1cm4gaT1qW1RhW2ldXSwtLUdlLGkoKX1mdW5jdGlvbiBfbChpKXtpZighVGUpe2lmKHd0PT09MCl7dmFyIGM9ITEsaD0hMTtpKCh4PTApPT57aWYoIVRlJiYoX2E9eCxjPSEwLGgpKXt3dD0yLGtyKCgpPT5WYShydCkpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLmhiLnNiJiZCcm93c2VyLmhiLnJlc3VtZSgpLHg9ITE7dHJ5e3ZhciBBPUVsKCl9Y2F0Y2goYWUpe0E9YWUseD0hMH12YXIgaz0hMTtpZighcnQpe3ZhciBOPXhuO04mJih4bj1udWxsLCh4P04ucmVqZWN0Ok4ucmVzb2x2ZSkoQSksaz0hMCl9aWYoeCYmIWspdGhyb3cgQX19KSxoPSEwLGN8fCh3dD0xLHJ0PUFsKCksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuaGIuc2ImJkJyb3dzZXIuaGIucGF1c2UoKSxrcigoKT0+V2EocnQpKSl9ZWxzZSB3dD09PTI/KHd0PTAsa3IoVWEpLFJhKHJ0KSxydD1udWxsLENsLmZvckVhY2goeD0+aXIoeCkpKTpKZShgaW52YWxpZCBzdGF0ZTogJHt3dH1gKTtyZXR1cm4gX2F9fWZ1bmN0aW9uIE9sKGkpe3JldHVybiBfbChjPT57aSgpLnRoZW4oYyl9KX1uZS5nYigpO3ZhciBUbD1bbnVsbCxYdCxDcixfdCxadCxBcixPcixUcixScixQcixHdCxlcix0cixycixucixhcixvcixkLGYsY2UsbWUsRSx0ZSxmZSx1cl0sUmw9e3I6ZnVuY3Rpb24oaSxjLGgpe3JldHVybiBPbChhc3luYygpPT57YXdhaXQgby54YihpLGMsaCl9KX0sYjpmdW5jdGlvbihpLGMsaCl7dGhyb3cgaT4+Pj0wLG5ldyB0dChpKS5nYihjPj4+MCxoPj4+MCksWWU9aSxJcisrLFllfSxPOmZ1bmN0aW9uKGkpe1BhKGk+Pj4wLCFiLDEsISQsMTMxMDcyLCExKSxuZS5sYigpfSxsOmZ1bmN0aW9uKGkpe2k+Pj49MCxJP3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOml9KTpWdChpKX0sSTpRdCxpOlp0LFU6QXIsRTpPcixHOlRyLFY6UnIsUzpQcixLOkd0LFI6ZXIscDp0cixGOnJyLEM6bnIsVDphcixEOm9yLHE6KCk9PiEwLEE6ZnVuY3Rpb24oaSxjKXtpPj4+PTAsaT09Yz4+PjA/c2V0VGltZW91dCgoKT0+VHQoKSk6ST9wb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOmksY21kOlwiY2hlY2tNYWlsYm94XCJ9KTooaT1uZS5RYVtpXSkmJmkucG9zdE1lc3NhZ2Uoe2NtZDpcImNoZWNrTWFpbGJveFwifSl9LE06ZnVuY3Rpb24oKXtyZXR1cm4tMX0sTjpGdCxYOmZ1bmN0aW9uKGkpe1MmJm5lLlFhW2k+Pj4wXS5yZWYoKX0sdTpmdW5jdGlvbihpLGMsaCl7aT1jKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFpPyhpPj4+MCkrNDI5NDk2NzI5NipjOk5hTixoPj4+PTAsaT1uZXcgRGF0ZSgxZTMqaSksbigpW2g+PjI+Pj4wXT1pLmdldFVUQ1NlY29uZHMoKSxuKClbaCs0Pj4yPj4+MF09aS5nZXRVVENNaW51dGVzKCksbigpW2grOD4+Mj4+PjBdPWkuZ2V0VVRDSG91cnMoKSxuKClbaCsxMj4+Mj4+PjBdPWkuZ2V0VVRDRGF0ZSgpLG4oKVtoKzE2Pj4yPj4+MF09aS5nZXRVVENNb250aCgpLG4oKVtoKzIwPj4yPj4+MF09aS5nZXRVVENGdWxsWWVhcigpLTE5MDAsbigpW2grMjQ+PjI+Pj4wXT1pLmdldFVUQ0RheSgpLGk9KGkuZ2V0VGltZSgpLURhdGUuVVRDKGkuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsbigpW2grMjg+PjI+Pj4wXT1pfSx2OmZ1bmN0aW9uKGksYyxoKXtpPWMrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWk/KGk+Pj4wKSs0Mjk0OTY3Mjk2KmM6TmFOLGg+Pj49MCxpPW5ldyBEYXRlKDFlMyppKSxuKClbaD4+Mj4+PjBdPWkuZ2V0U2Vjb25kcygpLG4oKVtoKzQ+PjI+Pj4wXT1pLmdldE1pbnV0ZXMoKSxuKClbaCs4Pj4yPj4+MF09aS5nZXRIb3VycygpLG4oKVtoKzEyPj4yPj4+MF09aS5nZXREYXRlKCksbigpW2grMTY+PjI+Pj4wXT1pLmdldE1vbnRoKCksbigpW2grMjA+PjI+Pj4wXT1pLmdldEZ1bGxZZWFyKCktMTkwMCxuKClbaCsyND4+Mj4+PjBdPWkuZ2V0RGF5KCksYz0oYnQoaS5nZXRGdWxsWWVhcigpKT9SdDpzcilbaS5nZXRNb250aCgpXStpLmdldERhdGUoKS0xfDAsbigpW2grMjg+PjI+Pj4wXT1jLG4oKVtoKzM2Pj4yPj4+MF09LSg2MCppLmdldFRpbWV6b25lT2Zmc2V0KCkpLGM9bmV3IERhdGUoaS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgeD1uZXcgRGF0ZShpLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO2k9KGMhPXgmJmkuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oeCxjKSl8MCxuKClbaCszMj4+Mj4+PjBdPWl9LHc6ZnVuY3Rpb24oaSl7aT4+Pj0wO3ZhciBjPW5ldyBEYXRlKG4oKVtpKzIwPj4yPj4+MF0rMTkwMCxuKClbaSsxNj4+Mj4+PjBdLG4oKVtpKzEyPj4yPj4+MF0sbigpW2krOD4+Mj4+PjBdLG4oKVtpKzQ+PjI+Pj4wXSxuKClbaT4+Mj4+PjBdLDApLGg9bigpW2krMzI+PjI+Pj4wXSx4PWMuZ2V0VGltZXpvbmVPZmZzZXQoKSxBPW5ldyBEYXRlKGMuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksaz1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLE49TWF0aC5taW4oayxBKTtyZXR1cm4gMD5oP24oKVtpKzMyPj4yPj4+MF09KyhBIT1rJiZOPT14KTowPGghPShOPT14KSYmKEE9TWF0aC5tYXgoayxBKSxjLnNldFRpbWUoYy5nZXRUaW1lKCkrNmU0KigoMDxoP046QSkteCkpKSxuKClbaSsyND4+Mj4+PjBdPWMuZ2V0RGF5KCksaD0oYnQoYy5nZXRGdWxsWWVhcigpKT9SdDpzcilbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsbigpW2krMjg+PjI+Pj4wXT1oLG4oKVtpPj4yPj4+MF09Yy5nZXRTZWNvbmRzKCksbigpW2krND4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLG4oKVtpKzg+PjI+Pj4wXT1jLmdldEhvdXJzKCksbigpW2krMTI+PjI+Pj4wXT1jLmdldERhdGUoKSxuKClbaSsxNj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxuKClbaSsyMD4+Mj4+PjBdPWMuZ2V0WWVhcigpLGk9Yy5nZXRUaW1lKCkvMWUzLE1hKChkdD1pLDE8PStNYXRoLmFicyhkdCk/MDxkdD8rTWF0aC5mbG9vcihkdC80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChkdC0rKH5+ZHQ+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxpPj4+MH0sczpkLHQ6Zix6OmZ1bmN0aW9uKGksYyxoKXtmdW5jdGlvbiB4KFEpe3JldHVybihRPVEudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKSk/UVsxXTpcIkdNVFwifWk+Pj49MCxjPj4+PTAsaD4+Pj0wO3ZhciBBPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxrPW5ldyBEYXRlKEEsMCwxKSxOPW5ldyBEYXRlKEEsNiwxKTtBPWsuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgYWU9Ti5nZXRUaW1lem9uZU9mZnNldCgpLGVlPU1hdGgubWF4KEEsYWUpO3MoKVtpPj4yPj4+MF09NjAqZWUsbigpW2M+PjI+Pj4wXT0rKEEhPWFlKSxpPXgoayksYz14KE4pLGk9dyhpKSxjPXcoYyksYWU8QT8ocygpW2g+PjI+Pj4wXT1pLHMoKVtoKzQ+PjI+Pj4wXT1jKToocygpW2g+PjI+Pj4wXT1jLHMoKVtoKzQ+PjI+Pj4wXT1pKX0sZDooKT0+e0plKFwiXCIpfSxjOmZ1bmN0aW9uKGksYyxoKXtyZXR1cm4gaT4+Pj0wLGM9XyhjPj4+MCxoPj4+MCksV3RbaV0uYXBwbHkobnVsbCxjKX0sazpmdW5jdGlvbihpLGMsaCl7cmV0dXJuIGk+Pj49MCxjPV8oYz4+PjAsaD4+PjApLFd0W2ldLmFwcGx5KG51bGwsYyl9LG06ZnVuY3Rpb24oKXt9LGo6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sVzooKT0+e3Rocm93IEdlKz0xLFwidW53aW5kXCJ9LEI6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sZjooKT0+cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKSxnOmZ1bmN0aW9uKCl7cmV0dXJuIFM/KElvKCksdnQoQ28pKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5fSxMOmZ1bmN0aW9uKGksYyxoLHgpe2ZvcihuZS5QYj1jPj4+MCx1ZS5sZW5ndGg9aCxjPXg+Pj4wPj4zLHg9MDt4PGg7eCsrKXVlW3hdPWwoKVtjK3g+Pj4wXTtyZXR1cm4oMD5pP1d0Wy1pLTFdOlRsW2ldKS5hcHBseShudWxsLHVlKX0seTpmdW5jdGlvbihpKXtpPj4+PTA7dmFyIGM9YSgpLmxlbmd0aDtpZihpPD1jfHw0Mjk0OTAxNzYwPGkpcmV0dXJuITE7Zm9yKHZhciBoPTE7ND49aDtoKj0yKXt2YXIgeD1jKigxKy4yL2gpO3g9TWF0aC5taW4oeCxpKzEwMDY2MzI5Nik7dmFyIEE9TWF0aDt4PU1hdGgubWF4KGkseCk7ZTp7QT1BLm1pbi5jYWxsKEEsNDI5NDkwMTc2MCx4Kyg2NTUzNi14JTY1NTM2KSU2NTUzNiktd2UuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7d2UuZ3JvdyhBKSxwZSgpO3ZhciBrPTE7YnJlYWsgZX1jYXRjaHt9az12b2lkIDB9aWYoaylyZXR1cm4hMH1yZXR1cm4hMX0sUDpjZSxROm1lLEg6SnQsaDpFLG86dGUseDpmZSxuOnVyLGE6d2V8fG8ud2FzbU1lbW9yeSxKOkVhLGU6ZnVuY3Rpb24oaSxjLGgseCl7cmV0dXJuIEVhKGk+Pj4wLGM+Pj4wLGg+Pj4wLHg+Pj4wKX19OyhmdW5jdGlvbigpe2Z1bmN0aW9uIGkoaCx4KXtyZXR1cm4gaD1oLmV4cG9ydHMsaD14bChoKSxqPWg9UGwoaCksbmUubWIucHVzaChqLkRhKSxPZS51bnNoaWZ0KGouWSksU2U9eCwkcigpLGh9dmFyIGM9e2E6Umx9O2lmKGp0KCksby5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBvLmluc3RhbnRpYXRlV2FzbShjLGkpfWNhdGNoKGgpe3EoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitoKSxtKGgpfXJldHVybiB4cihjLGZ1bmN0aW9uKGgpe2koaC5pbnN0YW5jZSxoLm1vZHVsZSl9KS5jYXRjaChtKSx7fX0pKCksby5fT3J0SW5pdD0oaSxjKT0+KG8uX09ydEluaXQ9ai5aKShpLGMpLG8uX09ydEdldExhc3RFcnJvcj0oaSxjKT0+KG8uX09ydEdldExhc3RFcnJvcj1qLl8pKGksYyksby5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KGksYyxoLHgsQSxrLE4sYWUsZWUsUSk9PihvLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1qLiQpKGksYyxoLHgsQSxrLE4sYWUsZWUsUSksby5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGksYyk9PihvLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1qLmFhKShpLGMpLG8uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0oaSxjLGgpPT4oby5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPWouYmEpKGksYyxoKSxvLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KGksYyxoKT0+KG8uX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1qLmNhKShpLGMsaCksby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWk9PihvLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ai5kYSkoaSksby5fT3J0Q3JlYXRlU2Vzc2lvbj0oaSxjLGgpPT4oby5fT3J0Q3JlYXRlU2Vzc2lvbj1qLmVhKShpLGMsaCksby5fT3J0UmVsZWFzZVNlc3Npb249aT0+KG8uX09ydFJlbGVhc2VTZXNzaW9uPWouZmEpKGkpLG8uX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGksYyxoKT0+KG8uX09ydEdldElucHV0T3V0cHV0Q291bnQ9ai5nYSkoaSxjLGgpLG8uX09ydEdldElucHV0TmFtZT0oaSxjKT0+KG8uX09ydEdldElucHV0TmFtZT1qLmhhKShpLGMpLG8uX09ydEdldE91dHB1dE5hbWU9KGksYyk9PihvLl9PcnRHZXRPdXRwdXROYW1lPWouaWEpKGksYyksby5fT3J0RnJlZT1pPT4oby5fT3J0RnJlZT1qLmphKShpKSxvLl9PcnRDcmVhdGVUZW5zb3I9KGksYyxoLHgsQSxrKT0+KG8uX09ydENyZWF0ZVRlbnNvcj1qLmthKShpLGMsaCx4LEEsayksby5fT3J0R2V0VGVuc29yRGF0YT0oaSxjLGgseCxBKT0+KG8uX09ydEdldFRlbnNvckRhdGE9ai5sYSkoaSxjLGgseCxBKSxvLl9PcnRSZWxlYXNlVGVuc29yPWk9PihvLl9PcnRSZWxlYXNlVGVuc29yPWoubWEpKGkpLG8uX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGksYyxoLHgpPT4oby5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1qLm5hKShpLGMsaCx4KSxvLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oaSxjLGgpPT4oby5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ai5vYSkoaSxjLGgpLG8uX09ydFJlbGVhc2VSdW5PcHRpb25zPWk9PihvLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1qLnBhKShpKSxvLl9PcnRDcmVhdGVCaW5kaW5nPWk9PihvLl9PcnRDcmVhdGVCaW5kaW5nPWoucWEpKGkpLG8uX09ydEJpbmRJbnB1dD0oaSxjLGgpPT4oby5fT3J0QmluZElucHV0PWoucmEpKGksYyxoKSxvLl9PcnRCaW5kT3V0cHV0PShpLGMsaCx4KT0+KG8uX09ydEJpbmRPdXRwdXQ9ai5zYSkoaSxjLGgseCksby5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9aT0+KG8uX09ydENsZWFyQm91bmRPdXRwdXRzPWoudGEpKGkpLG8uX09ydFJlbGVhc2VCaW5kaW5nPWk9PihvLl9PcnRSZWxlYXNlQmluZGluZz1qLnVhKShpKSxvLl9PcnRSdW5XaXRoQmluZGluZz0oaSxjLGgseCxBKT0+KG8uX09ydFJ1bldpdGhCaW5kaW5nPWoudmEpKGksYyxoLHgsQSksby5fT3J0UnVuPShpLGMsaCx4LEEsayxOLGFlKT0+KG8uX09ydFJ1bj1qLndhKShpLGMsaCx4LEEsayxOLGFlKSxvLl9PcnRFbmRQcm9maWxpbmc9aT0+KG8uX09ydEVuZFByb2ZpbGluZz1qLnhhKShpKSxvLl9Kc2VwT3V0cHV0PShpLGMsaCk9PihvLl9Kc2VwT3V0cHV0PWoueWEpKGksYyxoKSxvLl9Kc2VwR2V0Tm9kZU5hbWU9aT0+KG8uX0pzZXBHZXROb2RlTmFtZT1qLnphKShpKTt2YXIgTXI9by5fcHRocmVhZF9zZWxmPSgpPT4oTXI9by5fcHRocmVhZF9zZWxmPWouQWEpKCksU249by5fbWFsbG9jPWk9PihTbj1vLl9tYWxsb2M9ai5CYSkoaSksUmE9by5fZnJlZT1pPT4oUmE9by5fZnJlZT1qLkNhKShpKTtvLl9fZW1zY3JpcHRlbl90bHNfaW5pdD0oKT0+KG8uX19lbXNjcmlwdGVuX3Rsc19pbml0PWouRGEpKCk7dmFyIFBhPW8uX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PShpLGMsaCx4LEEsayk9PihQYT1vLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1qLkZhKShpLGMsaCx4LEEsayk7by5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9KCk9PihvLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1qLkdhKSgpO3ZhciBrYT0oaSxjLGgseCk9PihrYT1qLkhhKShpLGMsaCx4KSxDbj1pPT4oQ249ai5JYSkoaSksSW49by5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9aT0+KEluPW8uX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWouSmEpKGkpLEJhPW8uX19lbXNjcmlwdGVuX2NoZWNrX21haWxib3g9KCk9PihCYT1vLl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94PWouS2EpKCksTWE9aT0+KE1hPWouTGEpKGkpLERhPShpLGMpPT4oRGE9ai5NYSkoaSxjKSxBbj0oKT0+KEFuPWouTmEpKCksRHI9aT0+KERyPWouT2EpKGkpLEVuPWk9PihFbj1qLlBhKShpKSx6YT1vLmR5bkNhbGxfaWk9KGksYyk9Pih6YT1vLmR5bkNhbGxfaWk9ai5SYSkoaSxjKSxXYT1pPT4oV2E9ai5TYSkoaSksTmE9KCk9PihOYT1qLlRhKSgpLFZhPWk9PihWYT1qLlVhKShpKSxVYT0oKT0+KFVhPWouVmEpKCk7by5fX19zdGFydF9lbV9qcz05MjU3ODMsby5fX19zdG9wX2VtX2pzPTkyNTk0NDtmdW5jdGlvbiBQbChpKXtpPU9iamVjdC5hc3NpZ24oe30saSk7dmFyIGM9eD0+KCk9PngoKT4+PjAsaD14PT5BPT54KEEpPj4+MDtyZXR1cm4gaS5fX2Vycm5vX2xvY2F0aW9uPWMoaS5fX2Vycm5vX2xvY2F0aW9uKSxpLnB0aHJlYWRfc2VsZj1jKGkucHRocmVhZF9zZWxmKSxpLm1hbGxvYz1oKGkubWFsbG9jKSxpLnN0YWNrU2F2ZT1jKGkuc3RhY2tTYXZlKSxpLnN0YWNrQWxsb2M9aChpLnN0YWNrQWxsb2MpLGl9by5rZWVwUnVudGltZUFsaXZlPWV0LG8ud2FzbU1lbW9yeT13ZSxvLnN0YWNrQWxsb2M9RW4sby5zdGFja1NhdmU9QW4sby5zdGFja1Jlc3RvcmU9RHIsby5VVEY4VG9TdHJpbmc9VmUsby5zdHJpbmdUb1VURjg9X3Isby5sZW5ndGhCeXRlc1VURjg9T3Qsby5FeGl0U3RhdHVzPXl0LG8uUFRocmVhZD1uZTt2YXIgenI7RXQ9ZnVuY3Rpb24gaSgpe3pyfHxHYSgpLHpyfHwoRXQ9aSl9O2Z1bmN0aW9uIEdhKCl7ZnVuY3Rpb24gaSgpe2lmKCF6ciYmKHpyPSEwLG8uY2FsbGVkUnVuPSEwLCFUZSkmJihJfHxjdChPZSkscChvKSxvLm9uUnVudGltZUluaXRpYWxpemVkJiZvLm9uUnVudGltZUluaXRpYWxpemVkKCksIUkpKXtpZihvLnBvc3RSdW4pZm9yKHR5cGVvZiBvLnBvc3RSdW49PVwiZnVuY3Rpb25cIiYmKG8ucG9zdFJ1bj1bby5wb3N0UnVuXSk7by5wb3N0UnVuLmxlbmd0aDspe3ZhciBjPW8ucG9zdFJ1bi5zaGlmdCgpO3plLnVuc2hpZnQoYyl9Y3QoemUpfX1pZighKDA8S2UpKWlmKEkpcChvKSxJfHxjdChPZSksc3RhcnRXb3JrZXIobyk7ZWxzZXtpZihvLnByZVJ1bilmb3IodHlwZW9mIG8ucHJlUnVuPT1cImZ1bmN0aW9uXCImJihvLnByZVJ1bj1bby5wcmVSdW5dKTtvLnByZVJ1bi5sZW5ndGg7KUhlLnVuc2hpZnQoby5wcmVSdW4uc2hpZnQoKSk7Y3QoSGUpLDA8S2V8fChvLnNldFN0YXR1cz8oby5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7by5zZXRTdGF0dXMoXCJcIil9LDEpLGkoKX0sMSkpOmkoKSl9fWlmKG8ucHJlSW5pdClmb3IodHlwZW9mIG8ucHJlSW5pdD09XCJmdW5jdGlvblwiJiYoby5wcmVJbml0PVtvLnByZUluaXRdKTswPG8ucHJlSW5pdC5sZW5ndGg7KW8ucHJlSW5pdC5wb3AoKSgpO3JldHVybiBHYSgpLHQucmVhZHl9fSkoKTt0eXBlb2YgRW89PVwib2JqZWN0XCImJnR5cGVvZiB6bj09XCJvYmplY3RcIj96bi5leHBvcnRzPUFvOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCYmZGVmaW5lKFtdLCgpPT5Bbyl9KTt2YXIgT289THQoKGdmLFVsKT0+e1VsLmV4cG9ydHM9J1widXNlIHN0cmljdFwiO3ZhciBNb2R1bGU9e30sRU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCI7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7dmFyIG5vZGVXb3JrZXJUaHJlYWRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxwYXJlbnRQb3J0PW5vZGVXb3JrZXJUaHJlYWRzLnBhcmVudFBvcnQ7cGFyZW50UG9ydC5vbihcIm1lc3NhZ2VcIixlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKTt2YXIgZnM9cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlLE1vZHVsZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6bm9kZVdvcmtlclRocmVhZHMuV29ya2VyLGltcG9ydFNjcmlwdHM6ZT0+KDAsZXZhbCkoZnMucmVhZEZpbGVTeW5jKGUsXCJ1dGY4XCIpK1wiLy8jIHNvdXJjZVVSTD1cIitlKSxwb3N0TWVzc2FnZTplPT5wYXJlbnRQb3J0LnBvc3RNZXNzYWdlKGUpLHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpEYXRlLm5vd319KX12YXIgaW5pdGlhbGl6ZWRKUz0hMTtmdW5jdGlvbiB0aHJlYWRQcmludEVycigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7ZnMud3JpdGVTeW5jKDIsZStgXFxuYCk7cmV0dXJufWNvbnNvbGUuZXJyb3IoZSl9ZnVuY3Rpb24gdGhyZWFkQWxlcnQoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6ZSx0aHJlYWRJZDpNb2R1bGUuX3B0aHJlYWRfc2VsZigpfSl9dmFyIGVycj10aHJlYWRQcmludEVycjtzZWxmLmFsZXJ0PXRocmVhZEFsZXJ0LE1vZHVsZS5pbnN0YW50aWF0ZVdhc209KGUsdCk9Pnt2YXIgYT1Nb2R1bGUud2FzbU1vZHVsZTtNb2R1bGUud2FzbU1vZHVsZT1udWxsO3ZhciByPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShhLGUpO3JldHVybiB0KHIpfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbj8/ZX07ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShlKXt0cnl7aWYoZS5kYXRhLmNtZD09PVwibG9hZFwiKXtsZXQgYT1bXTtzZWxmLm9ubWVzc2FnZT1yPT5hLnB1c2gociksc2VsZi5zdGFydFdvcmtlcj1yPT57TW9kdWxlPXIscG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRlZFwifSk7Zm9yKGxldCBzIG9mIGEpaGFuZGxlTWVzc2FnZShzKTtzZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlfSxNb2R1bGUud2FzbU1vZHVsZT1lLmRhdGEud2FzbU1vZHVsZTtmb3IoY29uc3QgciBvZiBlLmRhdGEuaGFuZGxlcnMpTW9kdWxlW3JdPSguLi5zKT0+e3Bvc3RNZXNzYWdlKHtjbWQ6XCJjYWxsSGFuZGxlclwiLGhhbmRsZXI6cixhcmdzOnN9KX07aWYoTW9kdWxlLndhc21NZW1vcnk9ZS5kYXRhLndhc21NZW1vcnksTW9kdWxlLmJ1ZmZlcj1Nb2R1bGUud2FzbU1lbW9yeS5idWZmZXIsTW9kdWxlLkVOVklST05NRU5UX0lTX1BUSFJFQUQ9ITAsdHlwZW9mIGUuZGF0YS51cmxPckJsb2I9PVwic3RyaW5nXCIpaW1wb3J0U2NyaXB0cyhlLmRhdGEudXJsT3JCbG9iKTtlbHNle3ZhciB0PVVSTC5jcmVhdGVPYmplY3RVUkwoZS5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyh0KSxVUkwucmV2b2tlT2JqZWN0VVJMKHQpfW9ydFdhc21UaHJlYWRlZChNb2R1bGUpfWVsc2UgaWYoZS5kYXRhLmNtZD09PVwicnVuXCIpe01vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQoZS5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0KGUuZGF0YS5wdGhyZWFkX3B0ciksTW9kdWxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxNb2R1bGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIoZS5kYXRhKSxNb2R1bGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksaW5pdGlhbGl6ZWRKU3x8KGluaXRpYWxpemVkSlM9ITApO3RyeXtNb2R1bGUuaW52b2tlRW50cnlQb2ludChlLmRhdGEuc3RhcnRfcm91dGluZSxlLmRhdGEuYXJnKX1jYXRjaChhKXtpZihhIT1cInVud2luZFwiKXRocm93IGF9fWVsc2UgZS5kYXRhLmNtZD09PVwiY2FuY2VsXCI/TW9kdWxlLl9wdGhyZWFkX3NlbGYoKSYmTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6ZS5kYXRhLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCJ8fChlLmRhdGEuY21kPT09XCJjaGVja01haWxib3hcIj9pbml0aWFsaXplZEpTJiZNb2R1bGUuY2hlY2tNYWlsYm94KCk6ZS5kYXRhLmNtZCYmKGVycihcIndvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgXCIrZS5kYXRhLmNtZCksZXJyKGUuZGF0YSkpKX1jYXRjaChhKXt0aHJvdyBNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkJiZNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkKCksYX19c2VsZi5vbm1lc3NhZ2U9aGFuZGxlTWVzc2FnZTtcXG4nfSk7dmFyIFJvLEdsLFduLE5uLGpyLFRvLEZsLExsLEhsLFBvLFBlLEh0PUwoKCk9PntcInVzZSBzdHJpY3RcIjtSbz0kbygpO0dsPV9vKCksTm49ITEsanI9ITEsVG89ITEsRmw9KCk9Pnt0cnl7cmV0dXJuIHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIj8hMToodHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSkpfWNhdGNoe3JldHVybiExfX0sTGw9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sSGw9KGUsdCk9PmU/dD9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20tc2ltZC53YXNtXCI6dD9cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLndhc21cIixQbz1hc3luYyBlPT57aWYoTm4pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGpyKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO2lmKFRvKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO2pyPSEwO2xldCB0PWUuaW5pdFRpbWVvdXQscj1lLm51bVRocmVhZHMsYT1lLnNpbWQsbj1yPjEmJkZsKCkscz1hJiZMbCgpLHU9ZS53YXNtUGF0aHMsbD10eXBlb2YgdT09XCJzdHJpbmdcIj91OnZvaWQgMCxvPUhsKHMsbikscD10eXBlb2YgdT09XCJvYmplY3RcIj91W29dOnZvaWQgMCxtPSExLHk9W107aWYodD4wJiZ5LnB1c2gobmV3IFByb21pc2UoZz0+e3NldFRpbWVvdXQoKCk9PnttPSEwLGcoKX0sdCl9KSkseS5wdXNoKG5ldyBQcm9taXNlKChnLHYpPT57bGV0ICQ9bj9HbDpSbyxiPXtsb2NhdGVGaWxlOihTLEkpPT57aWYobiYmUy5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJnR5cGVvZiBCbG9iPFwidVwiKXJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtPbygpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpO2lmKFMuZW5kc1dpdGgoXCIud2FzbVwiKSl7aWYocClyZXR1cm4gcDtsZXQgVD1sPz9JO3JldHVybiBvPT09XCJvcnQtd2FzbS1zaW1kLndhc21cIj9UK1wib3J0LXdhc20tc2ltZC5qc2VwLndhc21cIjpvPT09XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIj9UK1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIjpUK299cmV0dXJuIEkrU319O2lmKG4paWYodHlwZW9mIEJsb2I+XCJ1XCIpYi5tYWluU2NyaXB0VXJsT3JCbG9iPSh2b2lkIDApKF9fZGlybmFtZSxcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7bGV0IFM9YHZhciBvcnRXYXNtVGhyZWFkZWQ9JHskLnRvU3RyaW5nKCl9O2A7Yi5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFtTXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9JChiKS50aGVuKFM9Pntqcj0hMSxObj0hMCxXbj1TLGcoKX0sUz0+e2pyPSExLFRvPSEwLHYoUyl9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UoeSksbSl0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LFBlPSgpPT57aWYoTm4mJlduKXJldHVybiBXbjt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX19KTt2YXIgTWUsZHIsQWUscXI9TCgoKT0+e1widXNlIHN0cmljdFwiO0h0KCk7TWU9KGUsdCk9PntsZXQgcj1QZSgpLGE9ci5sZW5ndGhCeXRlc1VURjgoZSkrMSxuPXIuX21hbGxvYyhhKTtyZXR1cm4gci5zdHJpbmdUb1VURjgoZSxuLGEpLHQucHVzaChuKSxufSxkcj0oZSx0LHIsYSk9PntpZih0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwpe2lmKHIuaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtuLHNdKT0+e2xldCB1PXQ/dCtuOm47aWYodHlwZW9mIHM9PVwib2JqZWN0XCIpZHIocyx1K1wiLlwiLHIsYSk7ZWxzZSBpZih0eXBlb2Ygcz09XCJzdHJpbmdcInx8dHlwZW9mIHM9PVwibnVtYmVyXCIpYSh1LHMudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2Ygcz09XCJib29sZWFuXCIpYSh1LHM/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHN9YCl9KX0sQWU9ZT0+e2xldCB0PVBlKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgYT10LnN0YWNrQWxsb2MoOCk7dC5fT3J0R2V0TGFzdEVycm9yKGEsYSs0KTtsZXQgbj10LkhFQVAzMlthLzRdLHM9dC5IRUFQVTMyW2EvNCsxXSx1PXM/dC5VVEY4VG9TdHJpbmcocyk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtufSwgRVJST1JfTUVTU0FHRTogJHt1fWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fX0pO3ZhciBrbyxCbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SHQoKTtxcigpO2tvPWU9PntsZXQgdD1QZSgpLHI9MCxhPVtdLG49ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApbi5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApbi5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihuLnRlcm1pbmF0ZT0hMSk7bGV0IHM9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYocz1NZShlLnRhZyxhKSkscj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKG4ubG9nU2V2ZXJpdHlMZXZlbCxuLmxvZ1ZlcmJvc2l0eUxldmVsLCEhbi50ZXJtaW5hdGUscykscj09PTAmJkFlKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxlPy5leHRyYSE9PXZvaWQgMCYmZHIoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCh1LGwpPT57bGV0IG89TWUodSxhKSxwPU1lKGwsYSk7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkocixvLHApIT09MCYmQWUoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dX0gLSAke2x9LmApfSksW3IsYV19Y2F0Y2gocyl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKHIpLGEuZm9yRWFjaCh1PT50Ll9mcmVlKHUpKSxzfX19KTt2YXIgamwscWwsS2wsWWwsTW8sRG89TCgoKT0+e1widXNlIHN0cmljdFwiO0h0KCk7cXIoKTtqbD1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSxxbD1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0sS2w9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKHI9Pih0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LFlsPShlLHQscik9Pntmb3IobGV0IGEgb2YgdCl7bGV0IG49dHlwZW9mIGE9PVwic3RyaW5nXCI/YTphLm5hbWU7c3dpdGNoKG4pe2Nhc2VcInhubnBhY2tcIjpuPVwiWE5OUEFDS1wiO2JyZWFrO2Nhc2VcIndlYm5uXCI6aWYobj1cIldFQk5OXCIsdHlwZW9mIGEhPVwic3RyaW5nXCIpe2xldCB1PWE7aWYodT8uZGV2aWNlVHlwZSl7bGV0IGw9TWUoXCJkZXZpY2VUeXBlXCIsciksbz1NZSh1LmRldmljZVR5cGUscik7UGUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsbCxvKSE9PTAmJkFlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHt1LmRldmljZVR5cGV9LmApfWlmKHU/LnBvd2VyUHJlZmVyZW5jZSl7bGV0IGw9TWUoXCJwb3dlclByZWZlcmVuY2VcIixyKSxvPU1lKHUucG93ZXJQcmVmZXJlbmNlLHIpO1BlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGwsbykhPT0wJiZBZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwb3dlclByZWZlcmVuY2UnIC0gJHt1LnBvd2VyUHJlZmVyZW5jZX0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOmlmKG49XCJKU1wiLHR5cGVvZiBhIT1cInN0cmluZ1wiKXtsZXQgdT1hO2lmKHU/LnByZWZlcnJlZExheW91dCl7aWYodS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5DSFdcIiYmdS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke3UucHJlZmVycmVkTGF5b3V0fWApO2xldCBsPU1lKFwicHJlZmVycmVkTGF5b3V0XCIsciksbz1NZSh1LnByZWZlcnJlZExheW91dCxyKTtQZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxsLG8pIT09MCYmQWUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7dS5wcmVmZXJyZWRMYXlvdXR9LmApfX1icmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke259YCl9bGV0IHM9TWUobixyKTtQZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLHMpIT09MCYmQWUoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7bn0uYCl9fSxNbz1lPT57bGV0IHQ9UGUoKSxyPTAsYT1bXSxuPWV8fHt9O0tsKG4pO3RyeXtsZXQgcz1qbChuLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLHU9cWwobi5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIiksbD10eXBlb2Ygbi5sb2dJZD09XCJzdHJpbmdcIj9NZShuLmxvZ0lkLGEpOjAsbz1uLmxvZ1NldmVyaXR5TGV2ZWw/PzI7aWYoIU51bWJlci5pc0ludGVnZXIobyl8fG88MHx8bz40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b31gKTtsZXQgcD1uLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHApfHxwPDB8fHA+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3B9YCk7bGV0IG09dHlwZW9mIG4ub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9NZShuLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsYSk6MDtpZihyPXQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHMsISFuLmVuYWJsZUNwdU1lbUFyZW5hLCEhbi5lbmFibGVNZW1QYXR0ZXJuLHUsISFuLmVuYWJsZVByb2ZpbGluZywwLGwsbyxwLG0pLHI9PT0wJiZBZShcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLG4uZXhlY3V0aW9uUHJvdmlkZXJzJiZZbChyLG4uZXhlY3V0aW9uUHJvdmlkZXJzLGEpLG4uZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W3ksZ11vZiBPYmplY3QuZW50cmllcyhuLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgeSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHt5fWApO2lmKHR5cGVvZiBnIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihnKXx8ZzwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke2d9YCk7bGV0IHY9TWUoeSxhKTt0Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUocix2LGcpIT09MCYmQWUoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke3l9IC0gJHtnfS5gKX1yZXR1cm4gbi5leHRyYSE9PXZvaWQgMCYmZHIobi5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCh5LGcpPT57bGV0IHY9TWUoeSxhKSwkPU1lKGcsYSk7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHIsdiwkKSE9PTAmJkFlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHt5fSAtICR7Z30uYCl9KSxbcixhXX1jYXRjaChzKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHIpLGEuZm9yRWFjaCh1PT50Ll9mcmVlKHUpKSxzfX19KTt2YXIgVm4sY3IscHIsS3IsZnIsWXIsVW4sRGU9TCgoKT0+e1widXNlIHN0cmljdFwiO1ZuPWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiAxMDtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxjcj1lPT57c3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTA6cmV0dXJuXCJmbG9hdDE2XCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0scHI9ZT0+W3ZvaWQgMCw0LDEsMSwyLDIsNCw4LHZvaWQgMCwxLDIsOCw0LDgsdm9pZCAwLHZvaWQgMCx2b2lkIDBdW2VdLEtyPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHtlfWApfX0sZnI9ZT0+e3N3aXRjaChlKXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKX19LFlyPWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwiYm9vbFwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cInVpbnQzMlwiLFVuPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBYbCxKbCx6byxXbyxObyxRbCxfZSx4dD1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtYbD1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLEpsPShlLHQpPT57Y29uc29sZS5sb2coYFske1hsW2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxObz0oZSx0KT0+e3pvPWUsV289dH0sUWw9KGUsdCk9PntsZXQgcj1mcihlKSxhPWZyKHpvKTtyPj1hJiZKbChyLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSxfZT0oLi4uZSk9PntXbyYmUWwoLi4uZSl9fSk7dmFyIFZvLFVvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO1ZvPShlLHQpPT5uZXcoS3IodCkpKGUpfSk7dmFyIEdvPUwoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBYcixabCxGbyxGbixHbixMbyxIbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHQoKTtHbygpO1hyPWU9Pk1hdGguY2VpbChlLzE2KSoxNixabD0xLEZvPSgpPT5abCsrLEZuPWFzeW5jKGUsdCxyLGEpPT57bGV0IG49WHIocikscz1lLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bix1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3RyeXtsZXQgdT1lLmdldENvbW1hbmRFbmNvZGVyKCk7ZS5lbmRDb21wdXRlUGFzcygpLHUuY29weUJ1ZmZlclRvQnVmZmVyKHQsMCxzLDAsbiksZS5mbHVzaCgpLGF3YWl0IHMubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtsZXQgbD1zLmdldE1hcHBlZFJhbmdlKCk7aWYoYSl7bGV0IG89YSgpO3JldHVybiBvLnNldChuZXcgVWludDhBcnJheShsLDAscikpLG99ZWxzZSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobC5zbGljZSgwLHIpKX1maW5hbGx5e3MuZGVzdHJveSgpfX0sR249Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nPVtdLHRoaXMuYnVmZmVyc1BlbmRpbmc9W10sdGhpcy5leHRlcm5hbEJ1ZmZlcnM9bmV3IE1hcH11cGxvYWQodCxyKXtsZXQgYT1yLmJ1ZmZlcixuPXIuYnl0ZU9mZnNldCxzPXIuYnl0ZUxlbmd0aCx1PVhyKHMpLGw9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFsKXRocm93IG5ldyBFcnJvcihcImdwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3RcIik7aWYobC5vcmlnaW5hbFNpemUhPT1zKXRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2wub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7c31gKTtsZXQgbz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7bWFwcGVkQXRDcmVhdGlvbjohMCxzaXplOnUsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSkscD1vLmdldE1hcHBlZFJhbmdlKCk7bmV3IFVpbnQ4QXJyYXkocCkuc2V0KG5ldyBVaW50OEFycmF5KGEsbixzKSksby51bm1hcCgpO2xldCBtPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLG0uY29weUJ1ZmZlclRvQnVmZmVyKG8sMCxsLmdwdURhdGEuYnVmZmVyLDAsdSksX2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHt0fSlgKSx0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nLnB1c2gobyl9bWVtY3B5KHQscil7bGV0IGE9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFhKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2xldCBuPXRoaXMuc3RvcmFnZUNhY2hlLmdldChyKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2lmKGEub3JpZ2luYWxTaXplIT09bi5vcmlnaW5hbFNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZVwiKTtsZXQgcz1YcihhLm9yaWdpbmFsU2l6ZSksdT10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx1LmNvcHlCdWZmZXJUb0J1ZmZlcihhLmdwdURhdGEuYnVmZmVyLDAsbi5ncHVEYXRhLmJ1ZmZlciwwLHMpfXJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCxyLGEpe2xldCBuO2lmKGEpe2lmKG49dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KGEpLG49PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgYnVmZmVyIGlzIG5vdCByZWdpc3RlcmVkXCIpO2lmKHQ9PT1hKXJldHVybiBfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke259LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCksbjt0aGlzLmV4dGVybmFsQnVmZmVycy5kZWxldGUoYSl9ZWxzZSBuPUZvKCk7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChuLHtncHVEYXRhOntpZDpuLHR5cGU6MCxidWZmZXI6dH0sb3JpZ2luYWxTaXplOnJ9KSx0aGlzLmV4dGVybmFsQnVmZmVycy5zZXQodCxuKSxfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke259LCByZWdpc3RlcmVkLmApLG59dW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQpe2xldCByPXRoaXMuZXh0ZXJuYWxCdWZmZXJzLmdldCh0KTtyIT09dm9pZCAwJiYodGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHIpLHRoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZSh0KSxfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7cn1gKSl9Y3JlYXRlKHQscj1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKXtsZXQgYT1Ycih0KSxuLHM9KHImR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFLHU9KHImR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNO2lmKHN8fHUpe2xldCBvPXM/dGhpcy5mcmVlQnVmZmVyczp0aGlzLmZyZWVVbmlmb3JtQnVmZmVycyxwPW8uZ2V0KGEpO3B8fChwPVtdLG8uc2V0KGEscCkpLHAubGVuZ3RoPjA/bj1wLnBvcCgpOm49dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6YSx1c2FnZTpyfSl9ZWxzZSBuPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOmEsdXNhZ2U6cn0pO2xldCBsPXtpZDpGbygpLHR5cGU6MCxidWZmZXI6bn07cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChsLmlkLHtncHVEYXRhOmwsb3JpZ2luYWxTaXplOnR9KSxfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7dH0pID0+IGlkPSR7bC5pZH1gKSxsfWdldCh0KXtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpPy5ncHVEYXRhfXJlbGVhc2UodCl7bGV0IHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcInJlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0XCIpO3JldHVybiBfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHt0fSksIGdwdURhdGFJZD0ke3IuZ3B1RGF0YS5pZH1gKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUodCksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKHIuZ3B1RGF0YS5idWZmZXIpLHIub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKHQscil7bGV0IGE9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFhKXRocm93IG5ldyBFcnJvcihcImRhdGEgZG9lcyBub3QgZXhpc3RcIik7YXdhaXQgRm4odGhpcy5iYWNrZW5kLGEuZ3B1RGF0YS5idWZmZXIsYS5vcmlnaW5hbFNpemUscil9cmVmcmVzaFBlbmRpbmdCdWZmZXJzKCl7Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcpdC5kZXN0cm95KCk7dGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZz1bXTtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzUGVuZGluZykodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0U/dGhpcy5mcmVlQnVmZmVycy5nZXQodC5zaXplKS5wdXNoKHQpOih0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STT90aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQodC5zaXplKS5wdXNoKHQpOnQuZGVzdHJveSgpO3RoaXMuYnVmZmVyc1BlbmRpbmc9W119ZGlzcG9zZSgpe3RoaXMuZnJlZUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pfSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pfSksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaCh0PT57dC5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwfX0sTG89KC4uLmUpPT5uZXcgR24oLi4uZSl9KTt2YXIgTG4saWUsa2U9TCgoKT0+e1widXNlIHN0cmljdFwiO0xuPWNsYXNze2NvbnN0cnVjdG9yKHQpe09iamVjdC5hc3NpZ24odGhpcyx0KX1nZXQgY2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5fY2FjaGVLZXl8fCh0aGlzLl9jYWNoZUtleT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5zb3J0KCkubWFwKHQ9PmAke3RoaXNbdF19YCkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX0saWU9ZT0+bmV3IExuKGUpfSk7dmFyIEhuLG50LHosTXQsSnIsUXIsWnIsZ2U9TCgoKT0+e1widXNlIHN0cmljdFwiO0huPWNsYXNze3N0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxyKXtyZXR1cm4gdFsxXSE9PXJbMF0/dm9pZCAwOlt0WzBdLHJbMV1dfX0sbnQ9Y2xhc3N7c3RhdGljIGNhbGNTaGFwZSh0LHIsYT0hMSl7bGV0IG49dC5sZW5ndGgscz1yLmxlbmd0aDtpZihuPT09MClyZXR1cm4gcjtpZihzPT09MClyZXR1cm4gdDtsZXQgdT1NYXRoLm1heCh0Lmxlbmd0aCxyLmxlbmd0aCksbD1uZXcgQXJyYXkodSk7aWYoYSl7aWYobjwyfHxzPDIpcmV0dXJuO2xldCBvPUhuLmNhbGNNYXRNdWxTaGFwZShbdFtuLTJdLHRbbi0xXV0sW3Jbcy0yXSxyW3MtMV1dKTtpZihvPT09dm9pZCAwKXJldHVybjtbbFt1LTJdLGxbdS0xXV09b31mb3IobGV0IG89YT8zOjE7bzw9dTtvKyspe2xldCBwPW4tbzwwPzE6dFtuLW9dLG09cy1vPDA/MTpyW3Mtb107aWYocCE9PW0mJnA+MSYmbT4xKXJldHVybjtsW3Utb109TWF0aC5tYXgocCxtKX1yZXR1cm4gbH1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LHIpe2xldCBhPXQubGVuZ3RoLG49ci5sZW5ndGg7aWYoYT5uKXJldHVybiExO2ZvcihsZXQgcz0xO3M8PWE7cysrKWlmKHRbYS1zXSE9PTEmJnRbYS1zXSE9PXJbbi1zXSlyZXR1cm4hMTtyZXR1cm4hMH19LHo9Y2xhc3MgZXtzdGF0aWMgc2l6ZSh0KXtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCx0Lmxlbmd0aCl9c3RhdGljIHNpemVGcm9tRGltZW5zaW9uKHQscil7aWYocjwwfHxyPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtyfSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZVRvRGltZW5zaW9uKHQscil7aWYocjwwfHxyPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtyfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCxyKX1zdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsYSl7bGV0IG49MTtmb3IobGV0IHM9cjtzPGE7cysrKXtpZih0W3NdPDApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLlwiKTtuKj10W3NdfXJldHVybiBufXN0YXRpYyBjb21wdXRlU3RyaWRlcyh0KXtsZXQgcj10Lmxlbmd0aDtpZihyPT09MClyZXR1cm5bXTtpZihyPT09MSlyZXR1cm5bMV07bGV0IGE9bmV3IEFycmF5KHIpO2Fbci0xXT0xLGFbci0yXT10W3ItMV07Zm9yKGxldCBuPXItMztuPj0wOy0tbilhW25dPWFbbisxXSp0W24rMV07cmV0dXJuIGF9c3RhdGljIG5vcm1hbGl6ZUF4aXModCxyKXtpZih0PC1yJiZ0Pj1yKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3Qrcjp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQscil7cmV0dXJuIHQubWFwKGE9PnRoaXMubm9ybWFsaXplQXhpcyhhLHI/P3QubGVuZ3RoKSl9c3RhdGljIHNvcnRCYXNlZE9uUGVybSh0LHIpe3JldHVybiByP3IubWFwKGE9PnRbYV0pOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQscil7bGV0IGE9dC5sZW5ndGg7cmV0dXJuIHQubWFwKChuLHMpPT5uK3Jbc10rcltzK2FdKX1zdGF0aWMgYXJlRXF1YWwodCxyKXtyZXR1cm4gdC5sZW5ndGghPT1yLmxlbmd0aD8hMTp0LmV2ZXJ5KChhLG4pPT5hPT09cltuXSl9fSxNdD1jbGFzcyBle3N0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyh0LHIsYSxuLHMsdSl7aWYoIXQmJmEubGVuZ3RoIT09ci5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zXCIpO2lmKHQpZm9yKGxldCBsPTA7bDxyLmxlbmd0aC0yO2wrKylsPj1hLmxlbmd0aD9hLnB1c2gocltsKzJdKTphW2xdPXJbbCsyXTtmb3IobGV0IGw9MDtsPGEubGVuZ3RoO2wrKylpZihsPG4ubGVuZ3RoKXtpZihuW2xdPDApdGhyb3cgbmV3IEVycm9yKFwic3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBuLnB1c2goMSk7Zm9yKGxldCBsPTA7bDxhLmxlbmd0aDtsKyspaWYobDxzLmxlbmd0aCl7aWYoc1tsXTwwKXRocm93IG5ldyBFcnJvcihcImRpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBzLnB1c2goMSk7Zm9yKGxldCBsPTA7bDxhLmxlbmd0aCoyO2wrKylpZihsPHUubGVuZ3RoKXtpZih1W2xdPDApdGhyb3cgbmV3IEVycm9yKFwicGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHUucHVzaCgwKTtmb3IobGV0IGw9MDtsPGEubGVuZ3RoO2wrKyl7aWYoYVtsXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDBcIik7aWYodVtsXT49YVtsXXx8dVtsK2EubGVuZ3RoXT49YVtsXSl0aHJvdyBuZXcgRXJyb3IoXCJwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsXCIpfX1zdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHQscixhLG4scyx1LGwpe2lmKGwpe2lmKHMubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHIubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYobi5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IG89MDtvPHQubGVuZ3RoLTI7bysrKWUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFtvKyh1PzE6MildLHJbb10sYVtvXSxuW29dLHMsbyxvK3QubGVuZ3RoLTIsbCl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQscixhLG4scyx1LGwpe2lmKHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtsZXQgbz1bclswXSxyWzFdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIodCxyLG8sYSxuLHMsdSxsKSxvfXN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKHQscixhLG4scyx1LGwpe2lmKHQubGVuZ3RoPD0wfHxyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zXCIpO2xldCBvPVt0WzBdLHJbMF1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcighMSx0LG8sYSxuLHMsdSxsKSxvfXN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIodCxyLGEsbixzLHUsbCxvKXtpZih0KWZvcihsZXQgcD0wO3A8ci5sZW5ndGgtMjtwKyspYS5wdXNoKDEpO2Vsc2UgZm9yKGxldCBwPTA7cDxyLmxlbmd0aC0yO3ArKylhLnB1c2goZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShyW3ArMl0sbltwXSxzW3BdLHVbcF0sbCxwLHArci5sZW5ndGgtMixvKSl9c3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKHQscixhLG4scyx1LGwsbyl7bGV0IHA9YSoobi0xKSsxO2lmKG8mJm8hPT1cIk5PVFNFVFwiKXN3aXRjaChvKXtjYXNlXCJWQUxJRFwiOnJldHVybiBzW3VdPTAsc1tsXT0wLE1hdGguZmxvb3IoKHQtcCkvcisxKTtjYXNlXCJTQU1FX0xPV0VSXCI6Y2FzZVwiU0FNRV9VUFBFUlwiOmlmKGEhPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUlwiKTt7bGV0IHk9KCh0K3ItMSkvci0xKSpyK24tdDtyZXR1cm4gc1t1XT1NYXRoLmZsb29yKG89PT1cIlNBTUVfTE9XRVJcIj8oeSsxKS8yOnkvMiksc1tsXT15LXNbdV0sTWF0aC5mbG9vcigodCt5LW4pL3IrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9ZWxzZSByZXR1cm4gTWF0aC5mbG9vcigodCtzW3VdK3NbbF0tcCkvcisxKX19LEpyPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdCh0LHIsYSxuLHMpe2lmKHQubGVuZ3RoIT09Mnx8YS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCB1LGwsbztyPyh1PXRbMV0sbD10WzBdKToodT10WzBdLGw9dFsxXSk7bGV0IHA9LTE7aWYobj8obz1hWzBdLHA9MSk6KG89YVsxXSxwPTApLGFbcF0hPT1sKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZih1PD0wfHxvPD0wfHxsPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKHMmJiFudC5pc1ZhbGlkQnJvYWRjYXN0KHMsW3Usb10pKXRocm93IG5ldyBFcnJvcihcImdlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0XCIpO3JldHVyblt1LG8sbF19fSxRcj0tMzQwMjgyMzQ2NjM4NTI4ODZlMjIsWnI9MzQwMjgyMzQ2NjM4NTI4ODZlMjJ9KTt2YXIgZWQsam8sQmUscW4sbXQsUWUsRHQsU3QscW8sRixYLGpuLEtvLEtuLFlvLHZlPUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7ZWQ9NjQsam89KGUsdCk9PntpZih0PT09Myl0aHJvdyBuZXcgRXJyb3IoXCJ2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkXCIpO3N3aXRjaChlKXtjYXNlIDEwOnJldHVybiB0PjE/YHZlYyR7dH08ZjE2PmA6XCJmMTZcIjtjYXNlIDE6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMzI+YDpcImYzMlwiO2Nhc2UgNjpyZXR1cm4gdD4xP2B2ZWMke3R9PGkzMj5gOlwiaTMyXCI7Y2FzZSAxMjpyZXR1cm4gdD4xP2B2ZWMke3R9PHUzMj5gOlwidTMyXCI7Y2FzZSA3OmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJpMzJcIl07Y2FzZSAxMzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwidTMyXCJdO2Nhc2UgOTppZih0IT09NCl0aHJvdyBuZXcgRXJyb3IoXCJib29sIG11c3QgYmUgdmVjNFwiKTtyZXR1cm5bXCJ1MzJcIixcInZlYzQ8Ym9vbD5cIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxCZT0oZSx0PTEpPT57bGV0IHI9am8oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzBdfSxxbj1lPT5be3R5cGU6XCJ1aW50MzJcIixkYXRhOmV9LHt0eXBlOlwidWludDMyXCIsZGF0YTp6LmNvbXB1dGVTdHJpZGVzKGUpfV0sbXQ9ZT0+ZSU0PT09MD80OmUlMj09PTA/MjoxLFFlPShlPVwiZjMyXCIsdCxyPVwiMFwiKT0+IXR8fHQ9PT0xP2Ake2V9KCR7cn0pYDpgdmVjJHt0fTwke2V9Pigke3J9KWAsRHQ9KGUsdCxyKT0+ZT09PVwiZjMyXCI/cjp0PT09MT9gZjMyKCR7cn0pYDpgdmVjJHt0fWYoJHtyfSlgLFN0PShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLHFvPShlLHQscixhLG4pPT57bGV0IHM9dHlwZW9mIHI9PVwibnVtYmVyXCIsdT1zP3I6ci5sZW5ndGgsbD1bLi4ubmV3IEFycmF5KHUpLmtleXMoKV0sbz11PDI/XCJ1MzJcIjp1PD00P2B2ZWMke3V9PHUzMj5gOmBhcnJheTx1MzIsICR7dX0+YCxwPWpvKHQsbiksbT10eXBlb2YgcD09XCJzdHJpbmdcIj9wOnBbMV0seT10eXBlb2YgcD09XCJzdHJpbmdcIj9wOnBbMF0sZz17aW5kaWNlczpvLHZhbHVlOm0sc3RvcmFnZTp5LHRlbnNvcjp0fSx2PVU9PnR5cGVvZiBVPT1cInN0cmluZ1wiP1U6YCR7VX11YCwkPXtvZmZzZXRUb0luZGljZXM6ITEsaW5kaWNlc1RvT2Zmc2V0OiExLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiExLHNldDohMSxzZXRCeUluZGljZXM6ITEsZ2V0OiExLGdldEJ5SW5kaWNlczohMX0sYj1zP1widW5pZm9ybXMuXCI6XCJcIixTPWAke2J9JHtlfV9zaGFwZWAsST1gJHtifSR7ZX1fc3RyaWRlc2AsVD1cIlwiO2ZvcihsZXQgVT0wO1U8dS0xO1UrKylUKz1gXG4gICAgbGV0IGRpbSR7VX0gPSBjdXJyZW50IC8gJHtJfVske1V9XTtcbiAgICBsZXQgcmVzdCR7VX0gPSBjdXJyZW50ICUgJHtJfVske1V9XTtcbiAgICBpbmRpY2VzWyR7VX1dID0gZGltJHtVfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7VX07XG4gICAgYDtUKz1gaW5kaWNlc1ske3UtMX1dID0gY3VycmVudDtgO2xldCBCPXU8Mj9cIlwiOmBcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7Zy5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7Zy5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke1R9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gLFA9VT0+KCQub2Zmc2V0VG9JbmRpY2VzPSEwLHU8Mj9VOmBvMmlfJHtlfSgke1V9KWApLEQ9W107aWYodT49Milmb3IobGV0IFU9dS0xO1U+PTA7VS0tKUQucHVzaChgJHtJfVske1V9XSAqIChpbmRpY2VzWyR7VX1dKWApO2xldCBSPXU8Mj9cIlwiOmBcbiAgZm4gaTJvXyR7ZX0oaW5kaWNlczogJHtnLmluZGljZXN9KSAtPiB1MzIge1xuICAgIHJldHVybiAke0Quam9pbihcIitcIil9O1xuICB9YCxXPVU9PigkLmluZGljZXNUb09mZnNldD0hMCx1PDI/VTpgaTJvXyR7ZX0oJHtVfSlgKSxIPSguLi5VKT0+dT09PTA/XCIwdVwiOmAke2cuaW5kaWNlc30oJHtVLm1hcCh2KS5qb2luKFwiLFwiKX0pYCxLPShVLGRlKT0+dTwyP2Ake1V9YDpgJHtVfVske2RlfV1gLGxlPShVLGRlLHBlKT0+dTwyP2Ake1V9PSR7cGV9O2A6YCR7VX1bJHtkZX1dPSR7cGV9O2AsTT17fSxxPShVLGRlKT0+eyQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ9ITA7bGV0IHBlPWAke2RlLm5hbWV9YnJvYWRjYXN0ZWRJbmRpY2VzVG8ke2V9T2Zmc2V0YDtpZihwZSBpbiBNKXJldHVybmAke3BlfSgke1V9KWA7bGV0IE5lPVtdO2ZvcihsZXQgSGU9dS0xO0hlPj0wO0hlLS0pe2xldCBPZT1kZS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEhlK2RlLnJhbmstdSk7TmUucHVzaChgJHtLKEksSGUpfSAqICgke09lfSAlICR7SyhTLEhlKX0pYCl9cmV0dXJuIE1bcGVdPWBmbiAke3BlfShvdXRwdXRJbmRpY2VzOiAke2RlLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICAgcmV0dXJuICR7TmUubGVuZ3RoPjA/TmUuam9pbihcIitcIik6XCIwdVwifTtcbiAgICAgICAgICAgfWAsYCR7cGV9KCR7VX0pYH0seGU9KFUsZGUpPT4oKCk9PntpZihnLnN0b3JhZ2U9PT1nLnZhbHVlKXJldHVybmAke2V9WyR7VX1dPSR7ZGV9O2A7aWYoZy5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmZy52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYCR7ZX1bJHtVfV09dmVjMjx1MzI+KHUzMigke2RlfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7ZGV9IDwgMCkpO2A7aWYoZy5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmZy52YWx1ZT09PVwidTMyXCIpcmV0dXJuYCR7ZX1bJHtVfV09dmVjMjx1MzI+KHUzMigke2RlfSksIDB1KTtgO2lmKGcuc3RvcmFnZT09PVwidTMyXCImJmcudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gJHtlfVske1V9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke2RlfSkpO2A7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2cuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtnLnZhbHVlfSB5ZXRgKX0pKCksb2U9VT0+KCgpPT57aWYoZy5zdG9yYWdlPT09Zy52YWx1ZSlyZXR1cm5gJHtlfVske1V9XWA7aWYoZy5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmZy52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYGkzMigke2V9WyR7VX1dLngpYDtpZihnLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZnLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gdTMyKCR7ZX1bJHtVfV0ueClgO2lmKGcuc3RvcmFnZT09PVwidTMyXCImJmcudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gdmVjNDxib29sPihib29sKCR7ZX1bJHtVfV0gJiAweEZGdSksIGJvb2woJHtlfVske1V9XSAmIDB4RkYwMHUpLCBib29sKCR7ZX1bJHtVfV0gJiAweEZGMDAwMHUpLCBib29sKCR7ZX1bJHtVfV0gJiAweEZGMDAwMDAwdSkpYDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7Zy5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2cudmFsdWV9IHlldGApfSkoKSx3ZT11PDI/XCJcIjpgXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7Zy5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuICR7b2UoYGkyb18ke2V9KGluZGljZXMpYCl9O1xuICB9YCxqPXU8Mj9cIlwiOigoKT0+e2xldCBVPWwubWFwKHBlPT5gZCR7cGV9OiB1MzJgKS5qb2luKFwiLCBcIiksZGU9bC5tYXAocGU9PmBkJHtwZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBnZXRfJHtlfSgke1V9KSAtPiAke219IHtcbiAgICByZXR1cm4gZ2V0XyR7ZX1CeUluZGljZXMoJHtIKGRlKX0pO1xuICB9YH0pKCksU2U9KC4uLlUpPT57aWYoVS5sZW5ndGghPT11KXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3V9YCk7bGV0IGRlPVUubWFwKHYpLmpvaW4oXCIsXCIpO3JldHVybiB1PT09MD9vZShcIjB1XCIpOnU9PT0xP29lKGRlWzBdKTooJC5nZXQ9ITAsJC5nZXRCeUluZGljZXM9ITAsJC5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9KCR7ZGV9KWApfSxUZT1VPT51PDI/b2UoVSk6KCQuZ2V0QnlJbmRpY2VzPSEwLCQuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfUJ5SW5kaWNlcygke1V9KWApLEVlPXU8Mj9cIlwiOmBcbiAgZm4gc2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtnLmluZGljZXN9LCB2YWx1ZTogJHttfSkge1xuICAgICR7eGUoYGkyb18ke2V9KGluZGljZXMpYCxcInZhbHVlXCIpfVxuICB9YCxDZT11PDI/XCJcIjooKCk9PntsZXQgVT1sLm1hcChwZT0+YGQke3BlfTogdTMyYCkuam9pbihcIiwgXCIpLGRlPWwubWFwKHBlPT5gZCR7cGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gc2V0XyR7ZX0oJHtVfSwgdmFsdWU6ICR7bX0pIHtcbiAgICBzZXRfJHtlfUJ5SW5kaWNlcygke0goZGUpfSwgdmFsdWUpO1xuICB9YH0pKCk7cmV0dXJue2ltcGw6KCk9PntsZXQgVT1bXTtyZXR1cm4gc3x8KFUucHVzaChgY29uc3QgJHtTfSA9ICR7Zy5pbmRpY2VzfSgke3Iuam9pbihcIixcIil9KTtgKSxVLnB1c2goYGNvbnN0ICR7SX0gPSAke2cuaW5kaWNlc30oJHt6LmNvbXB1dGVTdHJpZGVzKHIpLmpvaW4oXCIsXCIpfSk7YCkpLCQub2Zmc2V0VG9JbmRpY2VzJiZVLnB1c2goQiksJC5pbmRpY2VzVG9PZmZzZXQmJlUucHVzaChSKSwkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0JiZPYmplY3QudmFsdWVzKE0pLmZvckVhY2goZGU9PlUucHVzaChkZSkpLCQuc2V0JiZVLnB1c2goQ2UpLCQuc2V0QnlJbmRpY2VzJiZVLnB1c2goRWUpLCQuZ2V0JiZVLnB1c2goaiksJC5nZXRCeUluZGljZXMmJlUucHVzaCh3ZSksVS5qb2luKGBcbmApfSx0eXBlOmcsb2Zmc2V0VG9JbmRpY2VzOlAsaW5kaWNlc1RvT2Zmc2V0OlcsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6cSxpbmRpY2VzOkgsaW5kaWNlc0dldDpLLGluZGljZXNTZXQ6bGUsc2V0OiguLi5VKT0+e2lmKFUubGVuZ3RoIT09dSsxKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3V9YCk7bGV0IGRlPVVbdV07aWYodHlwZW9mIGRlIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcInZhbHVlIG11c3QgYmUgc3RyaW5nXCIpO2xldCBwZT1VLnNsaWNlKDAsdSkubWFwKHYpLmpvaW4oXCIsXCIpO3JldHVybiB1PT09MD94ZShcIjB1XCIsZGUpOnU9PT0xP3hlKHBlWzBdLGRlKTooJC5zZXQ9ITAsJC5zZXRCeUluZGljZXM9ITAsJC5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9KCR7cGV9LCAke2RlfSlgKX0sc2V0QnlPZmZzZXQ6eGUsc2V0QnlJbmRpY2VzOihVLGRlKT0+dTwyP3hlKFUsZGUpOigkLnNldEJ5SW5kaWNlcz0hMCwkLmluZGljZXNUb09mZnNldD0hMCxgc2V0XyR7ZX1CeUluZGljZXMoJHtVfSwgJHtkZX0pO2ApLGdldDpTZSxnZXRCeU9mZnNldDpvZSxnZXRCeUluZGljZXM6VGUsdXNhZ2U6YT9cImlucHV0XCI6XCJvdXRwdXRcIixuYW1lOmUsc3RyaWRlczpJLHNoYXBlOlMscmFuazp1fX0sRj0oZSx0LHIsYT0xKT0+cW8oZSx0LHIsITAsYSksWD0oZSx0LHIsYT0xKT0+cW8oZSx0LHIsITEsYSksam49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cD10O3RoaXMuaW5kaWNlc0hlbHBlcnM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD1lZCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLGE9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdLHM9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLHU9cz9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmA6YEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2luZGV4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+YCxsPXM/XCJsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1wiOmBsZXQgZ2xvYmFsX2lkeCA9ICh3b3JrZ3JvdXBfaWQueiAqICR7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXSp0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdfXUgK1xuICAgICAgICAgIHdvcmtncm91cF9pZC55ICogJHt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzBdfXUgKyB3b3JrZ3JvdXBfaWQueCkgKiAke3IqYSpufXUgKyBsb2NhbF9pbmRleDtgO3JldHVybmBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtyfSwgJHthfSwgJHtufSlcbiAgZm4gbWFpbigke3V9KSB7XG4gICAgJHtsfVxuICBgfWRlY2xhcmVWYXJpYWJsZSh0LHIpe3RoaXMuaW5kaWNlc0hlbHBlcnMucHVzaCh0KSx0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOnQudHlwZS5pbmRpY2VzfSksdC5zdHJpZGVzLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnN0cmlkZXMucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6dC50eXBlLmluZGljZXN9KTtsZXQgYT10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLG49dC50eXBlLnN0b3JhZ2U7cmV0dXJuYEBncm91cCgwKSBAYmluZGluZygke3J9KSB2YXI8c3RvcmFnZSwgJHthfT4gJHt0Lm5hbWV9OiBhcnJheTwke259PjtgfWRlY2xhcmVWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQubWFwKHI9PnRoaXMuZGVjbGFyZVZhcmlhYmxlKHIsdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKGBcbmApfXJlZ2lzdGVyVW5pZm9ybSh0LHIpe3JldHVybiB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dCx0eXBlOnJ9KSx0aGlzfXVuaWZvcm1EZWNsYXJhdGlvbigpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCB0PVtdO2ZvcihsZXR7bmFtZTpyLHR5cGU6YX1vZiB0aGlzLnVuaWZvcm1zKXQucHVzaChgJHtyfToke2F9YCk7cmV0dXJuYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YH1nZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpe3JldHVybiB0aGlzLnVuaWZvcm1EZWNsYXJhdGlvbigpK3RoaXMuaW5kaWNlc0hlbHBlcnMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApfX0sS289ZT0+bmV3IGpuKGUpLEtuPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgsYT1bXTtmb3IobGV0IG49MDtuPHI7bisrKXtsZXQgcz1yLTEtbix1PWVbc118fDE7KHRbdC5sZW5ndGgtMS1uXXx8MSk+MSYmdT09PTEmJmEudW5zaGlmdChzKX1yZXR1cm4gYX0sWW89ZT0+ZTw9NH0pO3ZhciB0ZCxYbyxyZCxuZCxDdCxKbyxRbyxtcj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7dGQ9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxYbz0oZSx0KT0+dCYmdC5sZW5ndGghPT1lP1suLi5uZXcgQXJyYXkoZSkua2V5cygpXS5yZXZlcnNlKCk6dCxyZD0oZSx0KT0+ei5zb3J0QmFzZWRPblBlcm0oZSxYbyhlLmxlbmd0aCx0KSksbmQ9KGUsdCxyLGEpPT57bGV0IG49W107bi5wdXNoKGBmbiBwZXJtKGk6ICR7YS50eXBlLmluZGljZXN9KSAtPiAke3IudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2ApO2ZvcihsZXQgcz0wO3M8dDsrK3Mpbi5wdXNoKHIuaW5kaWNlc1NldChcImFcIixlW3NdLGBpWyR7c31dYCkpO3JldHVybiBuLnB1c2goXCJyZXR1cm4gYTt9XCIpLG4uam9pbihgXG5gKX0sQ3Q9KGUsdCk9PntsZXQgcj1lLmRhdGFUeXBlLGE9ZS5kaW1zLmxlbmd0aCxuPVhvKGEsdCkscz1ZbyhhKSx1PXJkKGUuZGltcyxuKSxsPXM/dS5sZW5ndGg6dSxvPXM/YTplLmRpbXMscD1YKFwib3V0cHV0XCIscixsKSxtPUYoXCJhXCIscixvKSx5PWc9PmBcbiAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhtLHApfVxuXG4gICR7bmQobixhLG0scCl9XG5cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7cC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLG0uZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YDtyZXR1cm57bmFtZTpcIlRyYW5zcG9zZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpzP1tcInJhbmtcIl06W1wiZGltc1wiXX0sZ2V0UnVuRGF0YTpnPT57bGV0IHY9ei5zaXplKHUpO3JldHVybntvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOmdbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh2LzY0KX0scHJvZ3JhbVVuaWZvcm1zOnM/W3t0eXBlOlwidWludDMyXCIsZGF0YTp2fSwuLi5xbihnWzBdLmRpbXMpLC4uLnFuKHUpXTpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOnZ9XX19LGdldFNoYWRlclNvdXJjZTp5fX0sSm89KGUsdCk9Pnt0ZChlLmlucHV0cyksZS5jb21wdXRlKEN0KGUuaW5wdXRzWzBdLHQucGVybSkpfSxRbz1lPT5pZSh7cGVybTplLnBlcm19KX0pO3ZhciBhZCxvZCxpZCxzZCx1ZCxsZCxkZCxjZCxwZCxmZCxhdCxabyxlaSx0aSxyaSxuaSxhaSxvaSxpaSxzaSx1aSxsaT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO2VuKCk7bXIoKTthZD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxvZD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGlkPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LHNkPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0sdWQ9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IGE9dC1lO2E8dDsrK2Epci5wdXNoKGEpO3JldHVybiByfSxsZD0oZSx0KT0+e2xldCByPVtdLGE9ZS5sZW5ndGg7Zm9yKGxldCBzPTA7czxhO3MrKyl0LmluZGV4T2Yocyk9PT0tMSYmci5wdXNoKGVbc10pO2xldCBuPXQubWFwKHM9PmVbc10pO3JldHVybltyLG5dfSxkZD0oZSx0KT0+e2xldCByPWUubGVuZ3RoK3QubGVuZ3RoLGE9W10sbj0wO2ZvcihsZXQgcz0wO3M8cjtzKyspdC5pbmRleE9mKHMpPT09LTE/YS5wdXNoKGVbbisrXSk6YS5wdXNoKDEpO3JldHVybiBhfSxjZD0oZSx0KT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKGVbZS5sZW5ndGgtci0xXSE9PXQtMS1yKXJldHVybiExO3JldHVybiEwfSxwZD0oZSx0KT0+e2xldCByPVtdO2lmKCFjZChlLHQpKXtmb3IobGV0IGE9MDthPHQ7KythKWUuaW5kZXhPZihhKT09PS0xJiZyLnB1c2goYSk7ZS5mb3JFYWNoKGE9PnIucHVzaChhKSl9cmV0dXJuIHJ9LGZkPShlLHQscixhLG4scyx1KT0+e2xldCBsPXJbMF0uZGltcyxvPXouc2l6ZShzKSxwPXouc2l6ZSh1KSxtPUYoXCJfQVwiLHJbMF0uZGF0YVR5cGUsbCkseT1YKFwib3V0cHV0XCIsbixzKSxnPTMyLHY9YFxuICAgICAgICAgIHZhcjx3b3JrZ3JvdXA+IGFCZXN0VmFsdWVzIDogYXJyYXk8JHt5LnR5cGUuc3RvcmFnZX0sICR7Z30+O1xuICAgICAgIGA7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTpiPT5gXG4gICAgICAgICR7Yi5yZWdpc3RlclVuaWZvcm0oXCJyZWR1Y2VTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhtLHkpfVxuICAgICAgICAke3Z9XG4gICAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XG4gICAgICAgICB9XG4gICAgICAgICAke2IubWFpblN0YXJ0KGcpfVxuICAgICAgICAgIGxldCBsb2NhbF9pZHggPSBsb2NhbF9pZC54O1xuXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7Z307XG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcblxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSAke3kudHlwZS5zdG9yYWdlfSgke2lkW2FdfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke2d9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSAke3kudHlwZS5zdG9yYWdlfSgke20uZ2V0QnlPZmZzZXQoXCJvZmZzZXQgKyBrXCIpfSk7XG4gICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7YWRbYV19O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oTGVuZ3RoLCAke2d9dSk7XG4gICAgICAgICBmb3IgKHZhciBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydTsgcmVkdWNlU2l6ZSA+IDF1O1xuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XG4gICAgICAgICAgIGxldCBpbnRlcnZhbCA9IERJVl9DRUlMKHJlZHVjZVNpemUsIDJ1KTtcbiAgICAgICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJlbnRTaXplKSB7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gJHtvZFthXX07XG4gICAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobG9jYWxfaWR4ID09IDB1KSB7XG4gICAgICAgICAgJHt5LnNldEJ5T2Zmc2V0KFwib3V0cHV0SW5kZXhcIixgJHthPT09XCJtZWFuXCI/YGJlc3RWYWx1ZSAvICR7eS50eXBlLnN0b3JhZ2V9KHVuaWZvcm1zLnJlZHVjZVNpemUpYDpgJHtzZFthXX1gfWApfTtcbiAgICAgICAgIH1cbiAgICAgICAgfWAsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Om99LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9XX0pfX0sYXQ9KGUsdCxyLGEpPT57bGV0IG49ZS5pbnB1dHMubGVuZ3RoPT09MT9yOlluKGUuaW5wdXRzLHIpLHM9bi5heGVzO3MubGVuZ3RoPT09MCYmIW4ubm9vcFdpdGhFbXB0eUF4ZXMmJihzPWUuaW5wdXRzWzBdLmRpbXMubWFwKCh2LCQpPT4kKSk7bGV0IHU9ei5ub3JtYWxpemVBeGVzKHMsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpLGw9dSxvPWUuaW5wdXRzWzBdLHA9cGQobCxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCk7cC5sZW5ndGg+MCYmKG89ZS5jb21wdXRlKEN0KGUuaW5wdXRzWzBdLHApLHtpbnB1dHM6WzBdLG91dHB1dHM6Wy0xXX0pWzBdLGw9dWQobC5sZW5ndGgsby5kaW1zLmxlbmd0aCkpO2xldFttLHldPWxkKG8uZGltcyxsKSxnPW07bi5rZWVwRGltcyYmKGc9ZGQobSx1KSksZS5jb21wdXRlKGZkKHQse2hpbnQ6bi5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxbb10sYSxlLmlucHV0c1swXS5kYXRhVHlwZSxnLHkpLHtpbnB1dHM6W29dfSl9LFpvPShlLHQpPT57YXQoZSxcIlJlZHVjZU1lYW5TaGFyZWRcIix0LFwibWVhblwiKX0sZWk9KGUsdCk9PnthdChlLFwiUmVkdWNlTDFTaGFyZWRcIix0LFwibDFcIil9LHRpPShlLHQpPT57YXQoZSxcIlJlZHVjZUwyU2hhcmVkXCIsdCxcImwyXCIpfSxyaT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VMb2dTdW1FeHBTaGFyZWRcIix0LFwibG9nU3VtRXhwXCIpfSxuaT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VNYXhTaGFyZWRcIix0LFwibWF4XCIpfSxhaT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VNaW5TaGFyZWRcIix0LFwibWluXCIpfSxvaT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VQcm9kU2hhcmVkXCIsdCxcInByb2RcIil9LGlpPShlLHQpPT57YXQoZSxcIlJlZHVjZVN1bVNoYXJlZFwiLHQsXCJzdW1cIil9LHNpPShlLHQpPT57YXQoZSxcIlJlZHVjZVN1bVNxdWFyZVNoYXJlZFwiLHQsXCJzdW1TcXVhcmVcIil9LHVpPShlLHQpPT57YXQoZSxcIlJlZHVjZUxvZ1N1bVNoYXJlZFwiLHQsXCJsb2dTdW1cIil9fSk7dmFyIG90LG1kLHRuLFluLGl0LGhkLGdkLHlkLGJkLHdkLHZkLCRkLHhkLFNkLENkLHN0LGRpLGNpLHBpLGZpLG1pLGhpLGdpLHlpLGJpLHdpLFplLGVuPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtsaSgpO290PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sbWQ9ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJcIl0sdG49KGUsdCxyLGEsbixzLHU9ITEsbD0hMSk9PntsZXQgbz1bXSxwPXJbMF0uZGltcyxtPXoubm9ybWFsaXplQXhlcyhuLHJbMF0uZGltcy5sZW5ndGgpLHk9IWwmJm0ubGVuZ3RoPT09MDtwLmZvckVhY2goKFcsSCk9Pnt5fHxtLmluZGV4T2YoSCk+PTA/dSYmby5wdXNoKDEpOm8ucHVzaChXKX0pO2xldCBnPVtdLHY9RihcIl9BXCIsclswXS5kYXRhVHlwZSxwKSwkPVgoXCJvdXRwdXRcIixzLG8pLGI9YSh2LCQsbSksUz1gaW5wdXRPZmZzZXQgPSAke3YuaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzXCIpfTtgLEk9YGxldCAke1N9O2AsVD1gdmFyICR7U307YCxCPWJbMV09PT1cIlwiP1wiXCI6VCxQPShiWzFdPT09XCJcIj9JOlMpK2BcbmArYlsyXTtmb3IobGV0IFc9MCxIPTA7VzxyWzBdLmRpbXMubGVuZ3RoO1crKyl5fHxtLmluZGV4T2YoVyk+PTA/KHUmJkgrKyxQPWBmb3IodmFyIGoke1d9OiB1MzIgPSAwOyBqJHtXfSA8ICR7clswXS5kaW1zW1ddfTsgaiR7V30rKykge1xuICAgICAgICAgICAgICAgICR7YlsyXS5pbmNsdWRlcyhcImxhc3RJbmRleFwiKT9gbGV0IGxhc3RJbmRleCA9IGoke1d9O2A6XCJcIn1cbiAgICAgICAgICAgICAgICAke3YuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFcsYGoke1d9YCl9XG4gICAgICAgICAgICAgICAgJHtQfVxuICAgICAgICAgICAgICB9YCk6KGcucHVzaChgJHt2LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixXLCQuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixIKSl9O2ApLEgrKyk7bGV0IEQ9ei5zaXplKG8pO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6dCxnZXRTaGFkZXJTb3VyY2U6Vz0+YFxuICAgICAgICAke1cuZGVjbGFyZVZhcmlhYmxlcyh2LCQpfVxuXG4gICAgICAgICR7Vy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke1cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhEKX1cbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3YudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICR7Zy5qb2luKGBcbmApfVxuICAgICAgICAgICR7YlswXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICAgJHtCfVxuICAgICAgICAgICR7YlsxXX1cbiAgICAgICAgICAke1B9XG4gICAgICAgICAgJHtiWzNdfVxuICAgICAgICAgICR7Yi5sZW5ndGg9PT00PyQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKTpiLnNsaWNlKDQpLmpvaW4oYFxuYCl9XG4gICAgICAgIH1gLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTpzfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoRC82NCl9fSl9fSxZbj0oZSx0KT0+e2xldCByPVtdO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChhPT5yLnB1c2goTnVtYmVyKGEpKSksaWUoe2F4ZXM6cixrZWVwRGltczp0LmtlZXBEaW1zLG5vb3BXaXRoRW1wdHlBeGVzOnQubm9vcFdpdGhFbXB0eUF4ZXN9KX0saXQ9KGUsdCxyLGEpPT57bGV0IG49ZS5pbnB1dHMscz1uLmxlbmd0aD09PTE/cjpZbihuLHIpO2UuY29tcHV0ZSh0bih0LHtoaW50OnMuY2FjaGVLZXl9LFtuWzBdXSxzLm5vb3BXaXRoRW1wdHlBeGVzJiZzLmF4ZXMubGVuZ3RoPT09MD9tZDphLHMuYXhlcyxuWzBdLmRhdGFUeXBlLHMua2VlcERpbXMscy5ub29wV2l0aEVtcHR5QXhlcykse2lucHV0czpbMF19KX0saGQ9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUxvZ1N1bVwiLHQsKGEsbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxnZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTDFcIix0LChhLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gYWJzKCR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcIlwiXSl9LHlkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMMlwiLHQsKGEsbik9PltgdmFyIHQgPSAke24udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7bi50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07IHZhbHVlICs9ICh0ICogdCk7YCxcInZhbHVlID0gc3FydCh2YWx1ZSk7XCJdKX0sYmQ9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUxvZ1N1bUV4cFwiLHQsKGEsbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBleHAoJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LHdkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VNYXhcIix0LChhLG4scyk9PntsZXQgdT1bXTtmb3IobGV0IGw9MDtsPGEucmFuaztsKyspKHMuaW5kZXhPZihsKT49MHx8cy5sZW5ndGg9PT0wKSYmdS5wdXNoKGEuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLGwsMCkpO3JldHVybltgJHt1LmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsYHZhbHVlID0gbWF4KHZhbHVlLCAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJcIl19KX0sdmQ9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZU1lYW5cIix0LChhLG4scyk9PntsZXQgdT0xO2ZvcihsZXQgbD0wO2w8YS5yYW5rO2wrKykocy5pbmRleE9mKGwpPj0wfHxzLmxlbmd0aD09PTApJiYodSo9ZS5pbnB1dHNbMF0uZGltc1tsXSk7cmV0dXJuW1widmFyIHN1bSA9IGYzMigwKTtcIixcIlwiLGBzdW0gKz0gZjMyKCR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxgbGV0IHZhbHVlID0gJHtuLnR5cGUudmFsdWV9KHN1bSAvICR7dX0pO2BdfSl9LCRkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VNaW5cIix0LChhLG4scyk9PntsZXQgdT1bXTtmb3IobGV0IGw9MDtsPGEucmFuaztsKyspKHMuaW5kZXhPZihsKT49MHx8cy5sZW5ndGg9PT0wKSYmdS5wdXNoKGBpbnB1dEluZGljZXNbJHtsfV0gPSAwO2ApO3JldHVybltgJHt1LmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJcIl19KX0seGQ9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZVByb2RcIix0LChhLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJcIl0pfSxTZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlU3VtXCIsdCwoYSxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwiXCJdKX0sQ2Q9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKGEsbik9PltgdmFyIHQgPSAke24udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7bi50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxzdD0oZSx0LHIpPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiEhcjtsZXQgYT0xLG49MTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl0LmluZGV4T2Yocyk9PT0tMT9hKj1lW3NdOm4qPWVbc107cmV0dXJuIG48MzImJmE+MTAyNH0sZGk9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT92ZChlLHQpOlpvKGUsdCl9LGNpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Z2QoZSx0KTplaShlLHQpfSxwaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3lkKGUsdCk6dGkoZSx0KX0sZmk9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9iZChlLHQpOnJpKGUsdCl9LG1pPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/d2QoZSx0KTpuaShlLHQpfSxoaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpPyRkKGUsdCk6YWkoZSx0KX0sZ2k9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT94ZChlLHQpOm9pKGUsdCl9LHlpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/U2QoZSx0KTppaShlLHQpfSxiaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0NkKGUsdCk6c2koZSx0KX0sd2k9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9oZChlLHQpOnVpKGUsdCl9LFplPWU9PmllKGUpfSk7dmFyIHZpLCRpLHhpLFNpLFhuLENpPUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2tlKCk7ZW4oKTt2aT1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSwkaT0oZSx0KT0+aWUoe2F4aXM6dC5heGlzLGtlZXBEaW1zOnQua2VlcERpbXMsc2VsZWN0TGFzdEluZGV4OnQuc2VsZWN0TGFzdEluZGV4fSkseGk9KGUsdCk9Pnt2aShlLmlucHV0cyk7bGV0IHI9KG4scyx1KT0+e2xldCBsPVtdO2ZvcihsZXQgbz0wO288bi5yYW5rO28rKykodS5pbmRleE9mKG8pPj0wfHx1Lmxlbmd0aD09PTApJiZsLnB1c2goYGlucHV0SW5kaWNlc1ske299XSA9IDA7YCk7cmV0dXJuW2Ake2wuam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XG52YXIgYmVzdEluZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIjw9XCI6XCI8XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcbiAgICAgICAgIGJlc3RJbmRleCA9IGkzMihsYXN0SW5kZXgpO1xuICAgICAgIH1gLFwiXCIscy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RJbmRleFwiKV19LGE9ZS5pbnB1dHMubGVuZ3RoPT09MT90OiRpKGUuaW5wdXRzLHQpO2UuY29tcHV0ZSh0bihcIkFyZ01pblwiLHtoaW50OmEuY2FjaGVLZXl9LFtlLmlucHV0c1swXV0scixbYS5heGlzXSw3LGEua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LFNpPShlLHQpPT57dmkoZS5pbnB1dHMpO2xldCByPShuLHMsdSk9PntsZXQgbD1bXTtmb3IobGV0IG89MDtvPG4ucmFuaztvKyspKHUuaW5kZXhPZihvKT49MHx8dS5sZW5ndGg9PT0wKSYmbC5wdXNoKGBpbnB1dEluZGljZXNbJHtvfV0gPSAwO2ApO3JldHVybltgJHtsLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xudmFyIGJlc3RJbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI+PVwiOlwiPlwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XG4gICAgICAgICBiZXN0SW5kZXggPSBpMzIobGFzdEluZGV4KTtcbiAgICAgICB9YCxcIlwiLHMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0SW5kZXhcIildfSxhPWUuaW5wdXRzLmxlbmd0aD09PTE/dDokaShlLmlucHV0cyx0KTtlLmNvbXB1dGUodG4oXCJhcmdNYXhcIix7aGludDphLmNhY2hlS2V5fSxbZS5pbnB1dHNbMF1dLHIsW2EuYXhpc10sNyxhLmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxYbj1lPT5pZShlKX0pO3ZhciBJZCxBZCxJaSxBaT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO0lkPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVszMjAsNjQwLDEyODBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIG9mIGNoYW5uZWxzIHNob3VsZCBiZSAzMjAsIDY0MCBvciAxMjgwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LEFkPWU9PntsZXQgdD1lWzBdLmRpbXMscj1lWzBdLmRpbXNbMl0sYT16LnNpemUodCkvNCxuPWVbMF0uZGF0YVR5cGUscz1GKFwiaW5wdXRcIixuLHQsNCksdT1GKFwiYmlhc1wiLG4sW3JdLDQpLGw9RihcInJlc2lkdWFsXCIsbix0LDQpLG89WChcIm91dHB1dFwiLG4sdCw0KTtyZXR1cm57bmFtZTpcIkJpYXNBZGRcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfX0pLGdldFNoYWRlclNvdXJjZTptPT5gXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtyfXUgLyA0O1xuICAke20uZGVjbGFyZVZhcmlhYmxlcyhzLHUsbCxvKX1cblxuICAke20ubWFpblN0YXJ0KCl9XG4gICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYSl9XG4gICAgbGV0IHZhbHVlID0gJHtzLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX1cbiAgICAgICsgJHt1LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAlIGNoYW5uZWxzXCIpfSArICR7bC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICR7by5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH19LElpPWU9PntJZChlLmlucHV0cyksZS5jb21wdXRlKEFkKGUuaW5wdXRzKSl9fSk7dmFyIEVkLCRlLEVpLF9pLE9pLFRpLFJpLFBpLGtpLEJpLE1pLEpuLF9kLERpLHppLFdpLE5pLHJuLFZpLG5uLFVpLEdpLEZpLExpLEhpLGppLHFpLEtpLFlpLFhpLEppLFFpLFppLGVzLHRzLHJzLG5zLFFuPUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7a2UoKTt2ZSgpO0VkPShlLHQscixhLG4scyk9PntsZXQgdT1NYXRoLmNlaWwodC80KSxsPVwiXCI7dHlwZW9mIG49PVwic3RyaW5nXCI/bD1gJHtufShhKWA6bD1uKFwiYVwiKTtsZXQgbz1GKFwiaW5wdXREYXRhXCIscixbdV0sNCkscD1YKFwib3V0cHV0RGF0YVwiLGEsW3VdLDQpO3JldHVybmBcbiAgJHtlLmRlY2xhcmVWYXJpYWJsZXMobyxwKX1cblxuICAke3M/P1wiXCJ9XG5cbiAgJHtlLm1haW5TdGFydCgpfVxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxuXG4gICAgbGV0IGEgPSAke28uZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke3Auc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbCl9XG4gIH1gfSwkZT0oZSx0LHIsYSxuLHM9ZS5kYXRhVHlwZSk9Pih7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om59LGdldFNoYWRlclNvdXJjZTp1PT5FZCh1LHouc2l6ZShlLmRpbXMpLGUuZGF0YVR5cGUscyxyLGEpLGdldFJ1bkRhdGE6dT0+KHtvdXRwdXRzOlt7ZGltczplLmRpbXMsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHouc2l6ZSh1WzBdLmRpbXMpLzY0LzQpfX0pfSksRWk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFic1wiLFwiYWJzXCIpKX0sX2k9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFjb3NcIixcImFjb3NcIikpfSxPaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQWNvc2hcIixcImFjb3NoXCIpKX0sVGk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFzaW5cIixcImFzaW5cIikpfSxSaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXNpbmhcIixcImFzaW5oXCIpKX0sUGk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkF0YW5cIixcImF0YW5cIikpfSxraT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXRhbmhcIixcImF0YW5oXCIpKX0sQmk9ZT0+aWUoZSksTWk9KGUsdCk9PntsZXQgcjtzd2l0Y2godC50byl7Y2FzZSAxMDpyPVwidmVjNDxmMTY+XCI7YnJlYWs7Y2FzZSAxOnI9XCJ2ZWM0PGYzMj5cIjticmVhaztjYXNlIDEyOnI9XCJ2ZWM0PHUzMj5cIjticmVhaztjYXNlIDY6cj1cInZlYzQ8aTMyPlwiO2JyZWFrO2Nhc2UgOTpyPVwidmVjNDxib29sPlwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHt0LnRvfWApfWUuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNhc3RcIixyLHZvaWQgMCx0LmNhY2hlS2V5LHQudG8pKX0sSm49KGUsdCk9PntsZXQgcj1CZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ2xpcFwiLGE9PmBjbGFtcCgke2F9LCBjbGlwX21pbl8sIGNsaXBfbWF4XylgLGBcbiAgICBjb25zdCBjbGlwX21pbl86IHZlYzQ8JHtyfT4gPSB2ZWM0KCR7cn0oJHt0Lm1pbn0pKTtcbiAgICBjb25zdCBjbGlwX21heF86IHZlYzQ8JHtyfT4gPSB2ZWM0KCR7cn0oJHt0Lm1heH0pKTtcbmAsdC5jYWNoZUtleSkse2lucHV0czpbMF19KX0sX2Q9ZT0+e2xldCB0PWUubGVuZ3RoPj0yP2VbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF06UXIscj1lLmxlbmd0aD49Mz9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOlpyO3JldHVybiBpZSh7bWluOnQsbWF4OnJ9KX0sRGk9ZT0+e2xldCB0PV9kKGUuaW5wdXRzKTtKbihlLHQpfSx6aT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LFdpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LE5pPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0scm49ZT0+aWUoZSksVmk9KGUsdCk9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJFbHVcIixyPT5gZWx1X3ZmMzIoJHtyfSlgLGBcbiAgY29uc3QgZWx1X2FscGhhXzogZjMyID0gZjMyKCR7dC5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogZjMyKSAtPiBmMzIge1xuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xuICB9XG5cbiAgZm4gZWx1X3ZmMzIodjogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj4ge1xuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xuICB9YCx0LmNhY2hlS2V5KSl9LG5uPShlLHQ9XCJmMzJcIik9PmBcbmNvbnN0IHIwOiAke3R9ID0gMC4zMjc1OTExO1xuY29uc3QgcjE6ICR7dH0gPSAwLjI1NDgyOTU5MjtcbmNvbnN0IHIyOiAke3R9ID0gLTAuMjg0NDk2NzM2O1xuY29uc3QgcjM6ICR7dH0gPSAxLjQyMTQxMzc0MTtcbmNvbnN0IHI0OiAke3R9ID0gLTEuNDUzMTUyMDI3O1xuY29uc3QgcjU6ICR7dH0gPSAxLjA2MTQwNTQyOTtcblxuZm4gZXJmX3ZmMzIodjogJHtlfSkgLT4gJHtlfSB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gLFVpPWU9PntsZXQgdD1CZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRXJmXCIscj0+YGVyZl92ZjMyKCR7cn0pYCxubihgdmVjNDwke3R9PmAsdCkpKX0sR2k9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkV4cFwiLFwiZXhwXCIpKX0sRmk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkZsb29yXCIsXCJmbG9vclwiKSl9LExpPWU9PntsZXQgdD1CZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiR2VsdVwiLHI9PmAwLjUgKiAke3J9ICogKDEuMCArIGVyZl92ZjMyKCR7cn0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsbm4oYHZlYzQ8JHt0fT5gLHQpKSl9LEhpPShlLHQpPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTGVha3lSZWx1XCIscj0+YHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7cn0sICR7cn0sICR7cn0gPj0gdmVjNDxmMzI+KDAuMCkpYCxgY29uc3QgbGVha3lfcmVsdV9hbHBoYV86IGYzMiA9IGYzMigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKX0samk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIk5vdFwiLHQ9PmAhJHt0fWApKX0scWk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIk5lZ1wiLHQ9PmAtJHt0fWApKX0sS2k9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlJlY2lwcm9jYWxcIix0PT5gMS4wLyR7dH1gKSl9LFlpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJSZWx1XCIsdD0+YHNlbGVjdCh2ZWM0PGYzMj4oMC4wKSwgJHt0fSwgJHt0fSA+IHZlYzQ8ZjMyPigwLjApKWApKX0sWGk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNpZ21vaWRcIix0PT5gKDEuMCAvICgxLjAgKyBleHAoLSR7dH0pKSlgKSl9LEppPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTaW5cIixcInNpblwiKSl9LFFpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTaW5oXCIsXCJzaW5oXCIpKX0sWmk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNxcnRcIixcInNxcnRcIikpfSxlcz1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiVGFuXCIsXCJ0YW5cIikpfSx0cz1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiVGFuaFwiLFwidGFuaFwiKSl9LHJzPShlLHQpPT4oZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIscj0+YHNlbGVjdCh2ZWM0PGYzMj4oMC4wKSwgJHtyfSwgJHtyfSA+IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfKWAsYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfOiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMCksbnM9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX19KTt2YXIgVGQsUmQsYXMsb3M9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtRbigpO1RkPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVsyNTYwLDUxMjAsMTAyNDBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwiaGlkZGVuIHN0YXRlIHNob3VsZCBiZSAyNTYwLCA1MTIwIG9yIDEwMjQwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LFJkPWU9PntsZXQgdD1lWzBdLmRpbXMuc2xpY2UoKTt0WzJdPXRbMl0vMjtsZXQgcj1GKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyw0KSxhPUYoXCJiaWFzXCIsZVswXS5kYXRhVHlwZSxbZVswXS5kaW1zWzJdXSw0KSxuPVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHQsNCkscz16LnNpemUodCkvNDtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpsPT5gXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xuXG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKHIsYSxuKX1cblxuICAke25uKFwidmVjNGZcIil9XG5cbiAgJHtsLm1haW5TdGFydCgpfVxuICAgICR7bC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHMpfVxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcbiAgICBsZXQgYmF0Y2hJbmRleCA9IGdsb2JhbF9pZHggLyBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xuICAgIGxldCB2YWx1ZVJpZ2h0ID0gaW5wdXRbaW5wdXRPZmZzZXQgKyBoYWxmQ2hhbm5lbHNdICsgYmlhc1tiaWFzSWR4ICsgaGFsZkNoYW5uZWxzXTtcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcblxuICAgICR7bi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlTGVmdCAqIGdlbHVSaWdodFwiKX1cbiAgfWB9fSxhcz1lPT57VGQoZS5pbnB1dHMpLGUuY29tcHV0ZShSZChlLmlucHV0cykpfX0pO3ZhciBQZCxrZCx1dCxpcyxzcyx1cyxscyxkcyxjcyxwcyxmcyxtcyxocyxncz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO3ZlKCk7UGQ9KGUsdCxyLGEsbixzLHUsbCxvLHAsbSk9PntsZXQgeT16LnNpemUoYSksZz1NYXRoLmNlaWwoeS80KSx2LCQ7dHlwZW9mIHU9PVwic3RyaW5nXCI/dj0kPShQLEQpPT5gJHt1fSgoJHtQfSksKCR7RH0pKWA6dHlwZW9mIHU9PVwiZnVuY3Rpb25cIj92PSQ9dToodj11LnNjYWxhciwkPXUudmVjdG9yKTtsZXQgYj1cIlwiLFM9WChcIm91dHB1dERhdGFcIixwLGEsNCksST1GKFwiYURhdGFcIixsLHQsNCksVD1GKFwiYkRhdGFcIixvLHIsNCk7aWYocyl7bGV0IFA9RD0+e2xldCBSPXouY29tcHV0ZVN0cmlkZXMoRCksVz1bXTtmb3IobGV0IEg9RC5sZW5ndGgtMTtIPj0wO0gtLSl7bGV0IEs9Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEgrYS5sZW5ndGgtRC5sZW5ndGgpO1cucHVzaChgJHtSW0hdfXUgKiAoJHtLfSAlICR7RFtIXX11KWApfXJldHVybiBXLmxlbmd0aD4wP1cuam9pbihcIitcIik6XCIwdVwifTtiPWBcbiAgICAgICAgICBmbiBjYWxjT2Zmc2V0QShvdXRwdXRJbmRpY2VzOiAke1MudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgIHJldHVybiAke1AodCl9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZuIGNhbGNPZmZzZXRCKG91dHB1dEluZGljZXM6ICR7Uy50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgcmV0dXJuICR7UChyKX07XG4gICAgICAgICAgfVxuICAgICAgICBgfWxldCBCO2lmKG4paWYocyl7bGV0IFA9ei5zaXplKHQpPT09MSxEPXouc2l6ZShyKT09PTE7UHx8RD9CPVMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsJChQP2Ake0kudHlwZS52YWx1ZX0oJHtJLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOkkuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLEQ/YCR7VC50eXBlLnZhbHVlfSgke1QuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6VC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTpCPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9IGNhbGNPZmZzZXRBKG91dHB1dEluZGljZXMpO1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSBjYWxjT2Zmc2V0QihvdXRwdXRJbmRpY2VzKTtcbiAgICAgICAgICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiwkKEkuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIiksVC5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKSkpfVxuICAgICAgICAgIGB9ZWxzZSBCPVMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsJChJLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxULmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCBQPShELFIsVz1cIlwiKT0+e2xldCBIPWBhRGF0YVtpbmRleEEke1J9XVtjb21wb25lbnRBJHtSfV1gLEs9YGJEYXRhW2luZGV4QiR7Un1dW2NvbXBvbmVudEIke1J9XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke1J9ID0gJHtTLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtSfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7Un0gPSBjYWxjT2Zmc2V0QShvdXRwdXRJbmRpY2VzJHtSfSk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7Un0gPSBjYWxjT2Zmc2V0QihvdXRwdXRJbmRpY2VzJHtSfSk7XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtSfSA9IG9mZnNldEEke1J9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtSfSA9IG9mZnNldEIke1J9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7Un0gPSBvZmZzZXRBJHtSfSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke1J9ID0gb2Zmc2V0QiR7Un0gJSA0dTtcbiAgICAgICAgICAgICR7RH1bJHtSfV0gPSAke1d9KCR7dihILEspfSk7XG4gICAgICAgICAgYH07cD09PTk/Qj1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7UChcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtQKFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke1AoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7UChcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOkI9YFxuICAgICAgICAgICAgJHtQKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHtQKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHtQKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHtQKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyhJLFQsUyl9XG5cbiAgICAgICAgJHttPz9cIlwifVxuICAgICAgICAke2J9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhnKX1cbiAgICAgICAgJHtCfVxuICAgICAgfWB9LGtkPShlLHQscixhLG4scyx1PXIuZGF0YVR5cGUpPT57bGV0IGw9IXouYXJlRXF1YWwoci5kaW1zLGEuZGltcyksbz1yLmRpbXMscD16LnNpemUoci5kaW1zKSxtPSExO2lmKGwpe2xldCB5PW50LmNhbGNTaGFwZShyLmRpbXMsYS5kaW1zLCExKTtpZigheSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtvPXkscD16LnNpemUobyk7bGV0IGc9ei5zaXplKHIuZGltcyk9PT0xLHY9ei5zaXplKGEuZGltcyk9PT0xLCQ9MTtmb3IobGV0IGI9MTtiPG8ubGVuZ3RoO2IrKyl7bGV0IFM9ci5kaW1zW3IuZGltcy5sZW5ndGgtYl0/PzEsST1hLmRpbXNbYS5kaW1zLmxlbmd0aC1iXT8/MTtpZihTPT09SSkkKj1TO2Vsc2UgYnJlYWt9KCQlND09PTB8fGd8fHYpJiYobT0hMCl9ZWxzZSBtPSEwO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6dH0sZ2V0U2hhZGVyU291cmNlOnk9PlBkKHksci5kaW1zLGEuZGltcyxvLG0sbCxuLHIuZGF0YVR5cGUsYS5kYXRhVHlwZSx1LHMpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NC80KX19KX19LHV0PShlLHQscixhLG4scyk9PntlLmNvbXB1dGUoa2QodCxuPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLHIsYSxzKSl9LGlzPWU9Pnt1dChlLFwiQWRkXCIsKHQscik9PmAke3R9KyR7cn1gKX0sc3M9ZT0+e3V0KGUsXCJEaXZcIiwodCxyKT0+YCR7dH0vJHtyfWApfSx1cz1lPT57dXQoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PT0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH09PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sbHM9ZT0+e3V0KGUsXCJNdWxcIiwodCxyKT0+YCR7dH0qJHtyfWApfSxkcz1lPT57bGV0IHQ9RihcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTt1dChlLFwiUG93XCIse3NjYWxhcjooYSxuKT0+YHBvd19jdXN0b20oJHthfSwke259KWAsdmVjdG9yOihhLG4pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHthfSwke259KWB9LGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCl9LGNzPWU9Pnt1dChlLFwiU3ViXCIsKHQscik9PmAke3R9LSR7cn1gKX0scHM9ZT0+e3V0KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PiR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT4ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGZzPWU9Pnt1dChlLFwiTGVzc1wiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTwke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxtcz1lPT57dXQoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9Pj0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0saHM9ZT0+e3V0KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTw9JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PD0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIE1kLERkLHpkLFdkLHlzLGJzLHdzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtNZD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IHQ9ZVswXS5kYXRhVHlwZSxyPWVbMF0uZGltcy5sZW5ndGg7Zm9yKGxldCBhIG9mIGUpe2lmKGEuZGF0YVR5cGUhPT10KXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlXCIpO2lmKGEuZGltcy5sZW5ndGghPT1yKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9fSxEZD1lPT5gXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX11OyBpICs9IDF1ICkge1xuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xuICB9YCx6ZD0oZSx0KT0+e2xldCByPWUubGVuZ3RoLGE9W107Zm9yKGxldCBuPTA7bjxyOysrbil7bGV0IHM9dC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixlW25dLmdldEJ5SW5kaWNlcyhcImluZGljZXNcIikpO3I9PT0xP2EucHVzaChzKTpuPT09MD9hLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7bn11KSB7ICR7c30gfWApOm49PT1yLTE/YS5wdXNoKGBlbHNlIHsgJHtzfSB9YCk6YS5wdXNoKGBlbHNlIGlmIChpbnB1dEluZGV4ID09ICR7bn0pIHsgJHtzfSB9YCl9cmV0dXJuIGEuam9pbihgXG5gKX0sV2Q9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKTtpZih0Pj1yLmxlbmd0aHx8dDwtMSpyLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7bGV0IGE9dDwwP3IubGVuZ3RoK3Q6dCxuPXIuc2xpY2UoMCk7Zm9yKGxldCB2PTE7djxlLmxlbmd0aDt2Kyspe2xldCAkPWVbdl0uZGltcy5zbGljZSgpO2ZvcihsZXQgYj0wO2I8ci5sZW5ndGg7YisrKWlmKGI9PT1hKW5bYV0rPSRbYl07ZWxzZSBpZihyW2JdIT09JFtiXSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1sZXQgcz16LnNpemUobiksdT1uZXcgQXJyYXkoZS5sZW5ndGgpLGw9bmV3IEFycmF5KGUubGVuZ3RoKSxvPWVbMF0uZGF0YVR5cGUscD0wO2ZvcihsZXQgdj0wO3Y8ZS5sZW5ndGg7Kyt2KXArPWVbdl0uZGltc1thXSx1W3ZdPXAsbFt2XT1GKGBpbnB1dCR7dn1gLG8sZVt2XS5kaW1zKTtsZXQgbT1YKFwib3V0cHV0XCIsbyxuKSx5PW0uaW5kaWNlc0dldChcImluZGljZXNcIixhKSxnPXY9PmBcbiAgJHt2LmRlY2xhcmVWYXJpYWJsZXMoLi4ubCxtKX1cblxuICBjb25zdCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke3UubGVuZ3RofT4oJHt1Lm1hcCgkPT5gJHskfXVgKS5qb2luKFwiLFwiKX0pO1xuICAke0RkKHUubGVuZ3RoKX1cblxuICAke3YubWFpblN0YXJ0KCl9XG4gICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke3l9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgJHt5fSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XG4gICAgfVxuXG4gICAgJHt6ZChsLG0pfVxuICB9YDtyZXR1cm57bmFtZTpcIkNvbmNhdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6Z319LHlzPShlLHQpPT57TWQoZS5pbnB1dHMpLGUuY29tcHV0ZShXZChlLmlucHV0cyx0LmF4aXMpKX0sYnM9ZT0+aWUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgV2UsYW4sb24sc249TCgoKT0+e1widXNlIHN0cmljdFwiO1dlPShlLHQpPT57c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuYHZlYzI8JHt0fT5gO2Nhc2UgMzpyZXR1cm5gdmVjMzwke3R9PmA7Y2FzZSA0OnJldHVybmB2ZWM0PCR7dH0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtlfS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19LGFuPShlLHQ9ITEscj0hMSxhPTMpPT5cIlwiLG9uPShlLHQpPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIC8vIFRPRE8gdW5jb21tZW50IHRoZSBmb2xsb3dpbmcgbGluZSB3aGVuIGFjdGl2YXRpb24gaXMgc3VwcG9ydGVkIGFib3ZlLlxuICAgICAgLy8gJHt0P1widmFsdWUgPSBhY3RpdmF0aW9uKHZhbHVlLCBjb29yZHMpO1wiOlwiXCJ9XG4gICAgICBgfSk7dmFyIHVuLFpuPUwoKCk9PntcInVzZSBzdHJpY3RcIjt1bj1gXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xufVxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICBvdXRTaGFwZVN0cmlkZXMueCwgb3V0U2hhcGVTdHJpZGVzLnksIG91dFNoYXBlU3RyaWRlcy56LCAxKSk7XG59XG5gfSk7dmFyIGxuLGRuLGhyPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2xuPShlLHQ9ITEpPT57c3dpdGNoKGUuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJ2YWx1ZSA9IG1heCh2YWx1ZSwgMC4wKTtcIn07Y2FzZVwiU2lnbW9pZFwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJ2YWx1ZSA9ICgxLjAgLyAoMS4wICsgZXhwKC12YWx1ZSkpKTtcIn07Y2FzZVwiQ2xpcFwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246YGNvbnN0IGNsaXBfbWluXz1mMzIoJHtlLmNsaXBNaW59KTtjb25zdCBjbGlwX21heF89ZjMyKCR7ZS5jbGlwTWF4fSk7YCxhcHBseUFjdGl2YXRpb246dD9cInZhbHVlID0gY2xhbXAodmFsdWUsIHZlYzQoY2xpcF9taW5fKSwgdmVjNChjbGlwX21heF8pKTtcIjpcInZhbHVlID0gY2xhbXAodmFsdWUsIGNsaXBfbWluXywgY2xpcF9tYXhfKTtcIn07ZGVmYXVsdDpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwiXCJ9fX0sZG49ZT0+e2xldCB0PWU/LmFjdGl2YXRpb258fFwiXCI7aWYodD09PVwiQ2xpcFwiKXtsZXRbcixhXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8W1FyLFpyXTtyZXR1cm57YWN0aXZhdGlvbjp0LGNsaXBNYXg6YSxjbGlwTWluOnIsYWN0aXZhdGlvbkNhY2hlS2V5OmAke3R9OiR7cn0sJHthfWB9fXJldHVybnthY3RpdmF0aW9uOnQsYWN0aXZhdGlvbkNhY2hlS2V5OnR9fX0pO3ZhciBOZCxWZCxncix2cyxVZCx5cixHZCxjbixicj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO2hyKCk7c24oKTtOZD0oZSx0KT0+ZT9gXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGA6YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYCxWZD0oZSx0KT0+ZT9gXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcbiAgICAgICAgJHt0PT09Mz9cIlwiOlwibGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTtcIn1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gOmBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gLGdyPShlLHQscj1cImYzMlwiLGEsbj0hMSxzPTMyLHU9ITEsbD0zMik9PntsZXQgbz10WzFdKmVbMV0scD10WzBdKmVbMF0sbT1uP286cyx5PW4/czpvLGc9bS90WzBdLHY9cy90WzFdO2lmKCEoKG4mJmc9PT00JiZlWzFdPT09NHx8IW4mJihnPT09M3x8Zz09PTQpKSYmbSV0WzBdPT09MCYmcyV0WzFdPT09MCYmZVswXT09PTQpKXRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke259IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtnfSBhbmQgd29ya1BlclRocmVhZFsxXSAke2VbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2d9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7bX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0uIHRpbGVJbm5lciAke3N9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt0WzFdfS4gY29sUGVyVGhyZWFkICR7ZVswXX0gbXVzdCBiZSA0LmApO3JldHVybmBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7Z308JHtyfT4sICR7bS9nfT4sICR7eX0+O1xudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke3J9PiwgJHtwL2VbMF19PiwgJHtzfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7Z307XG5jb25zdCB0aWxlSW5uZXIgPSAke3N9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xuXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcbiAgbGV0IGJhdGNoID0gJHt1P1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAke2E/YGxldCBiYXRjaEluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke299O1xuXG4gIGxldCBudW1UaWxlcyA9ICR7dT9gJHtNYXRoLmNlaWwobC9zKX1gOlwiKGRpbUlubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICB2YXIga1N0YXJ0ID0gJHt1P2BpMzIoZ2xvYmFsSWQueikgKiAke2x9YDpcIjBcIn07XG5cbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke3J9Piwgcm93UGVyVGhyZWFkPjtcblxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke3Z9O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHtOZChuLGEpfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHt2fTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke2E/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XG4gICAgICAgICAgJHtnPT09Mz9cIlwiOlwibGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdO1wifVxuXG4gICAgICAgICAgJHtWZChuLGcpfVxuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gIH1cblxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xuICB9XG59YH0sdnM9KGUsdCk9PmU/YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgOmBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYCxVZD1lPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIix5cj0oZSx0LHI9XCJmMzJcIixhLG49ITEscz0zMix1PSExLGw9MzIsbz0hMSk9PntsZXQgcD1lWzFdKnRbMV0sbT1lWzBdKnRbMF0seT1uP3A6cyxnPW4/czpwO2lmKCEoZyV0WzFdPT09MCYmeSV0WzBdPT09MCYmcyV0WzFdPT09MCkpdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7Z30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHt5fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7c30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtsZXQgdj1nL3RbMV0sJD15L3RbMF0sYj1zL3RbMV0sUz1vP2BcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7bX07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtnfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3l9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgICR7dnMobixhKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3N9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke219OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHthP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3RbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtuP2BtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XTtgOmBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XVtrXTtgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7dFswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGA6YFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5cbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcblxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke3Z9O1xubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAkeyR9O1xubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke2J9O1xuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHt2fTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHskfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHt2cyhuLGEpfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7Yn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHthP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgfVxuICB9XG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICR7VWQobil9XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcbn1cblxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gIH1cbn1cbmA7cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHt5fT4sICR7Z30+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHttfT4sICR7c30+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke3N9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gICAgbGV0IGJhdGNoID0gJHt1P1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAgICR7YT9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gICAgbGV0IG51bVRpbGVzID0gJHt1P2Ake01hdGguY2VpbChsL3MpfWA6XCIoZGltSW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gICAgdmFyIGtTdGFydCA9ICR7dT9gaTMyKGdsb2JhbElkLnopICogJHtsfWA6XCIwXCJ9O1xuXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XG5cbiAgICAvLyBXaXRob3V0IHRoaXMgaW5pdGlhbGl6YXRpb24gc3RyYW5nZSB2YWx1ZXMgc2hvdyB1cCBpbiBhY2MuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gMC4wO1xuICAgICAgfVxuICAgIH1cbiAgICAke1N9XG4gIH1cbmB9LEdkPShlLHQscixhLG4scz0hMSk9PntsZXQgdT1uWzBdLGw9blsxXSxvPW5bMl0scD1hWzBdLG09YVsxXSx5PWFbMl0sZz1hWzNdLHY9S24odSxvKSwkPUtuKGwsbyksYj1CZShhWzBdLnR5cGUudGVuc29yKSxTPSgpPT57bGV0IEI9bS5yYW5rLFA9cC5yYW5rLEQ9YHZhciBhSW5kaWNlczogJHttLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IFI9Qi0yLTEsVz1QLTE7Uj49MDtSLS0sVy0tKUQrPWBcbmFJbmRpY2VzWyR7Un1dID0gJHtQPjE/YGJhdGNoSW5kaWNlc1ske1d9XWA6XCJiYXRjaEluZGljZXNcIn07YDtyZXR1cm4gdi5mb3JFYWNoKFI9PntEKz1gXG5hSW5kaWNlc1ske1J9XSA9IDA7YH0pLEQrPWBcbmFJbmRpY2VzWyR7Qi0yfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBhSW5kaWNlc1ske0ItMX1dID0gdTMyKGNvbEluKTtgLER9LEk9KCk9PntsZXQgQj15LnJhbmssUD1wLnJhbmssRD1gdmFyIGJJbmRpY2VzOiAke3kudHlwZS5pbmRpY2VzfTtgO2ZvcihsZXQgUj1CLTItMSxXPVAtMTtSPj0wO1ItLSxXLS0pRCs9YFxuYkluZGljZXNbJHtSfV0gPSAke1A+MT9gYmF0Y2hJbmRpY2VzWyR7V31dYDpcImJhdGNoSW5kaWNlc1wifTtgO3JldHVybiAkLmZvckVhY2goUj0+e0QrPWBcbmJJbmRpY2VzWyR7Un1dID0gMDtgfSksRCs9YFxuYkluZGljZXNbJHtCLTJ9XSA9IHUzMihyb3cpO1xuICAgICAgICAgICAgICAgICAgIGJJbmRpY2VzWyR7Qi0xfV0gPSB1MzIoY29sSW4pO2AsRH07cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7cC50eXBlLmluZGljZXN9KSAtPiAke1dlKGUsYil9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7V2UoZSxiKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltSW5uZXIpXG4gICAgICB7XG4gICAgICAgICR7UygpfVxuICAgICAgICB2YWx1ZSA9ICR7bS5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtwLnR5cGUuaW5kaWNlc30pIC0+ICR7V2UoZSxiKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtXZShlLGIpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlcilcbiAgICAgIHtcbiAgICAgICAgJHtJKCl9XG4gICAgICAgIHZhbHVlID0gJHt5LmdldEJ5SW5kaWNlcyhcImJJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHtXZShlLGIpfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke3Q/YHZhbHVlID0gdmFsdWUgKyAke3M/XCJiaWFzW2NvbEluXVwiOmAke1dlKGUsYil9KGJpYXNbcm93XSlgfTtgOlwiXCJ9XG4gICAgICAgICR7cn1cbiAgICAgICAgJHtnLnNldEJ5SW5kaWNlcyhcInZlYzM8dTMyPihjb29yZHMpXCIsXCJ2YWx1ZVwiKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYH0sY249KGUsdCxyLGEsbj0hMSk9PntsZXQgcz1lWzBdLmRpbXMsdT1lWzFdLmRpbXMsbD1zLnNsaWNlKDAsLTIpLG89dS5zbGljZSgwLC0yKSxwPWE/YS5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLG09RihcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUscCkseT1bbV0sZz1bbCxvLHBdLHY9ei5zaXplKHApLCQ9c1tzLmxlbmd0aC0yXSxiPXNbcy5sZW5ndGgtMV0sUz11W3UubGVuZ3RoLTFdLEk9YiU0PT09MCYmUyU0PT09MCx7YWN0aXZhdGlvbkZ1bmN0aW9uOlQsYXBwbHlBY3RpdmF0aW9uOkJ9PWxuKHQsSSksUD0kPD04P1s0LDEsMV06WzQsNCwxXSxEPVs4LDgsMV0sUj1bTWF0aC5jZWlsKFMvRFswXS9QWzBdKSxNYXRoLmNlaWwoJC9EWzFdL1BbMV0pLE1hdGguY2VpbCh2L0RbMl0vUFsyXSldLFc9QmUoZVswXS5kYXRhVHlwZSksSD1JPzQ6MSxLPUYoXCJhXCIsZVswXS5kYXRhVHlwZSxbLi4ubCwkLGIvSF0sSCksbGU9RihcImJcIixlWzFdLmRhdGFUeXBlLFsuLi5vLGIsUy9IXSxIKSxNPVgoXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLFt2LCQsUy9IXSxIKTt5LnB1c2goSykseS5wdXNoKGxlKSx5LnB1c2goTSk7bGV0IHE9W0ssbGVdLHhlPWUubGVuZ3RoPjIsb2U9R2QoSCx4ZSxCLHksZyxuKTtpZih4ZSl7bGV0IGo9bj9IOjE7cS5wdXNoKEYoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaikpfWxldCB3ZT1qPT5gXG4gIGNvbnN0IGRpbUFPdXRlcjogaTMyID0gJHskfTtcbiAgY29uc3QgZGltQk91dGVyOiBpMzIgPSAke1N9O1xuICBjb25zdCBkaW1Jbm5lcjogaTMyID0gJHtifTtcbiAgJHtqLmRlY2xhcmVWYXJpYWJsZXMoLi4ucSxNKX1cbiAgJHtUfVxuICAke29lfVxuICAke0k/Z3IoUCxELFcsbSk6eXIoUCxELFcsbSl9XG4gICAgICAgICAgICAgICAgICAgJHttLmltcGwoKX1gO3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5hY3RpdmF0aW9uQ2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpSWzBdLHk6UlsxXSx6OlJbMl19fSksZ2V0U2hhZGVyU291cmNlOndlfX19KTt2YXIgRmQsJHMseHM9TCgoKT0+e1widXNlIHN0cmljdFwiO3h0KCk7Z2UoKTt2ZSgpO3NuKCk7Wm4oKTticigpO0ZkPShlLHQscixhLG49ITEscyx1PSExLGw9NCxvPTQscD00LG09XCJmMzJcIik9PntsZXQgeT1sZT0+e3N3aXRjaChsZSl7Y2FzZSAxOnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4XTtcIjtjYXNlIDM6cmV0dXJuYHJlc0RhdGEgPSB2ZWMzPCR7bX0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2xlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sZz1sZT0+e3N3aXRjaChsZSl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogd1NoYXBlWzNdICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIHdTaGFwZVszXSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtsZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LHY9ZT9gXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Um93LCB4Q29sLCB4Q2gpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcbiAgICBgLCQ9ZT9gXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93LFxuICAgICAgY29sIC8gb3V0V2lkdGgsXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XG4gICAgYCxiPWU/XCJ4U2hhcGVbMV1cIjpcInhTaGFwZVsyXVwiLFM9ZT9cInhTaGFwZVsyXVwiOlwieFNoYXBlWzNdXCIsST1lP1wicm93XCI6XCJjb2xcIixUPWU/XCJjb2xcIjpcInJvd1wiLEI9YFxuICAgIGxldCBpbkNoYW5uZWxzID0gd1NoYXBlWzJdO1xuICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcbiAgICBsZXQgb3V0Um93ID0gJHtJfSAvIG91dFdpZHRoO1xuICAgIGxldCBvdXRDb2wgPSAke0l9ICUgb3V0V2lkdGg7XG5cbiAgICBsZXQgV1JvdyA9ICR7VH0gLyAoZmlsdGVyRGltc1sxXSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHtUfSAvIGluQ2hhbm5lbHMgJSBmaWx0ZXJEaW1zWzFdO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogc3RyaWRlWzBdICsgZGlsYXRpb25bMF0gKiBXUm93IC0gcGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogc3RyaWRlWzFdICsgZGlsYXRpb25bMV0gKiBXQ29sIC0gcGFkWzFdO1xuICAgIGxldCB4Q2ggPSAke1R9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7V2UobCxtKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7Yn0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke1N9KSB7XG4gICAgICAke3Z9XG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHhTaGFwZSk7XG4gICAgICAke3kobCl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2AsUD1lP3QmJmE/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgJHtCfWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1Jbm5lcikge1xuICAgICAgJHtCfVxuICAgIH1cbiAgICByZXR1cm4gJHtXZShsLG0pfSgwLjApO2A6YSYmcj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtsfTtcbiAgICAke0J9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtsfTtcbiAgICBpZiAocm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XG4gICAgICAke0J9XG4gICAgfVxuICAgIHJldHVybiAke1dlKGwsbSl9KDAuMCk7YCxEPWAke2cobyl9YCxSPVdlKHAsbSksVz1lP1dlKGwsbSk6V2UobyxtKSxIPWU/V2UobyxtKTpXZShsLG0pO3JldHVybmBcbiAgICAke2FuKHMsdSxwPT09NCw0KX1cbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke1d9IHtcbiAgICAgICR7ZT9QOkR9XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtIfSB7XG4gICAgICAke2U/RDpQfVxuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke1J9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke3B9O1xuICAgICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1CT3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xuICAgICAgJHskfVxuICAgICAgJHtvbihuLHMpfVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWB9LCRzPShlLHQscixhLG4scyx1LGwpPT57bGV0IG89dC5mb3JtYXQ9PT1cIk5IV0NcIixwPW8/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxtPXJbMF0seT1vP3JbMl06clszXSxnPW8/clsxXTpyWzJdLHY9bz9yWzNdOnJbMV0sJD1vJiYocCU0PT09MHx8cCUzPT09MCkmJnYlND09PTAsYj1vP3Y6eSpnLFM9bz95Kmc6dixJPVs4LDgsMV0sVD1hPD04P1s0LDEsMV06WzQsNCwxXSxCPVtNYXRoLmNlaWwoYi9JWzBdL1RbMF0pLE1hdGguY2VpbChTL0lbMV0vVFsxXSksTWF0aC5jZWlsKG0vSVsyXS9UWzJdKV07X2UoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke0J9YCk7bGV0IFA9JD9vJiZwJTQhPT0wPzM6NDpUWzBdLEQ9SVsxXSpUWzFdLFI9SVswXSpUWzBdLFc9TWF0aC5tYXgoSVswXSpQLElbMV0pLEg9YSVEPT09MCxLPW4lUj09PTAsbGU9cyVXPT09MCxNPSQ/W1AsNCw0XTpbMSwxLDFdLHE9QmUoZVswXS5kYXRhVHlwZSkseGU9W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHg6IGFycmF5PCR7JCYmUD09PTQ/YHZlYzQ8JHtxfT5gOnF9PjtgLGBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHc6IGFycmF5PCR7JD9gdmVjNDwke3F9PmA6cX0+O2BdLG9lPWBcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7JD9gdmVjNDwke3F9PmA6cX0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAkeyQ/YHZlYzQ8JHtxfT5gOnF9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7JD9gdmVjNDwke3F9PmA6cX0pIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggJHskP1wiLyA0XCI6XCJcIn0sIHZhbHVlKTtcbiAgICAgIH1gO3JldHVybiB1JiYoeGUucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzOiBhcnJheTwkeyQ/YHZlYzQ8JHtxfT5gOnF9PjtgKSxvZSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAkeyQ/YHZlYzQ8JHtxfT5gOnF9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtvP1wid1wiOlwieVwifSR7JD9cIi8gNFwiOlwiXCJ9XTtcbiAgICAgICAgfWApLHtuYW1lOlwiQ29udjJETWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OkJbMF0seTpCWzFdLHo6QlsyXX19KSxnZXRTaGFkZXJTb3VyY2U6KCk9PmBcbiAgICAgICAgJHt1bn1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7eGUuam9pbihcIlwiKX1cbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7eGUubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdDogYXJyYXk8JHskP2B2ZWM0PCR7cX0+YDpxfT47XG4gICAgICAgIC8vQGdyb3VwKDApIEBiaW5kaW5nKCR7eGUubGVuZ3RoKzF9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICAgICAgIGNvbnN0IHhTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCB3U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzFdLmRpbXMuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtyLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IG91dFNoYXBlU3RyaWRlcyA6IHZlYzM8aTMyPiA9IHZlYzM8aTMyPigke3ouY29tcHV0ZVN0cmlkZXMocikuc2xpY2UoMCwzKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5rZXJuZWxTaGFwZVswXX0sICR7dC5rZXJuZWxTaGFwZVsxXX0pO1xuICAgICAgICBjb25zdCBwYWQgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LnBhZHNbMF19LCAke3QucGFkc1sxXX0pO1xuICAgICAgICBjb25zdCBzdHJpZGUgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LnN0cmlkZXNbMF19LCAke3Quc3RyaWRlc1sxXX0pO1xuICAgICAgICBjb25zdCBkaWxhdGlvbiA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3QuZGlsYXRpb25zWzBdfSwgJHt0LmRpbGF0aW9uc1sxXX0pO1xuICAgICAgICBjb25zdCBkaW1BT3V0ZXIgOiBpMzIgPSAke2F9O1xuICAgICAgICBjb25zdCBkaW1CT3V0ZXIgOiBpMzIgPSAke259O1xuICAgICAgICBjb25zdCBkaW1Jbm5lciA6IGkzMiA9ICR7c307XG4gICAgICAgICR7b2V9XG4gICAgICAgICR7RmQobyxILEssbGUsdSx0LmFjdGl2YXRpb24udG9Mb3dlckNhc2UoKSwhMSxNWzBdLE1bMV0sTVsyXSxxKX1cbiAgICAgICAgICAgICR7JD9ncihULEkscSx2b2lkIDAsIW8sVyk6eXIoVCxJLHEsdm9pZCAwLCFvLFcsITEsdm9pZCAwLGwpfWB9fX0pO3ZhciBlYSxTcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO3JhKCk7aHIoKTtlYT0oZSx0LHIpPT57bGV0IGE9ZS5sZW5ndGg+MixuPWE/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLHM9ZVswXS5kaW1zLHU9ZVsxXS5kaW1zLGw9dVswXS90Lmdyb3VwLHthY3RpdmF0aW9uRnVuY3Rpb246byxhcHBseUFjdGl2YXRpb246cH09bG4odCksbT10LmZvcm1hdD09PVwiTkhXQ1wiLHk9dGEocyx1LHQuZGlsYXRpb25zLHQucGFkcyx0LnN0cmlkZXMsbSksZz16LnNpemUoeSksdj1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx5KSwkPUYoXCJ4XCIsZVswXS5kYXRhVHlwZSxzKSxiPUYoXCJ3XCIsZVsxXS5kYXRhVHlwZSx1KSxTPVskLGJdO2EmJlMucHVzaChGKFwiYlwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zKSk7bGV0IEk9VD0+YFxuICBjb25zdCBzdHJpZGVzOiB2ZWMyPHUzMj4gPSB2ZWMyKCR7dC5zdHJpZGVzWzBdfXUsICR7dC5zdHJpZGVzWzFdfXUpO1xuICBjb25zdCBwYWRzOiB2ZWMyPHUzMj4gPSB2ZWMyKCR7dC5wYWRzWzBdfXUsICR7dC5wYWRzWzFdfXUpO1xuXG4gICR7VC5kZWNsYXJlVmFyaWFibGVzKC4uLlMsdil9XG5cbiAgJHtvfVxuXG4gICR7VC5tYWluU3RhcnQoKX1cbiAgICAke1QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhnKX1cblxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt2Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHttPzM6MX1dO1xuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7bT8xOjJ9XSwgb3V0cHV0SW5kaWNlc1ske20/MjozfV0pICogc3RyaWRlcyAtIHBhZHM7XG4gICAgbGV0IGdyb3VwX2lkOiB1MzIgPSBvdXRwdXRfY2hhbm5lbCAvICR7bH11O1xuXG4gICAgdmFyIHZhbHVlOiAke3YudHlwZS52YWx1ZX0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCAke3VbMV19dTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHt1WzFdfXUgKyB3SW5DaGFubmVsO1xuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCAke3VbMl19dTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogJHt0LmRpbGF0aW9uc1swXX11O1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSAke3NbbT8xOjJdfXUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8ICR7dVszXX11OyB3V2lkdGgrKykge1xuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqICR7dC5kaWxhdGlvbnNbMV19dTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49ICR7c1ttPzI6M119dSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHhWYWwgPSAke20/JC5nZXQoXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCIpOiQuZ2V0KFwiYmF0Y2hcIixcImlucHV0X2NoYW5uZWxcIixcInhIZWlnaHRcIixcInhXaWR0aFwiKX07XG4gICAgICAgICAgbGV0IHdWYWwgPSAke2IuZ2V0KFwib3V0cHV0X2NoYW5uZWxcIixcIndJbkNoYW5uZWxcIixcIndIZWlnaHRcIixcIndXaWR0aFwiKX07XG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICR7bn1cbiAgICAke3B9XG4gICAgJHt2LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gO3JldHVybntuYW1lOlwiR3JvdXBlZENvbnZcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnI/cih5KTp5LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChnLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6SX19fSk7dmFyIHRhLENzLExkLElzLG5hLEhkLGpkLGFhLHJhPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7eHMoKTticigpO1NzKCk7aHIoKTttcigpO3RhPShlLHQscixhLG4scyk9PntsZXQgdT1lWzBdLGw9ZS5zbGljZShzPzE6MixzPzM6NCksbz1sLmxlbmd0aCxwPXRbMF0seT10LnNsaWNlKDIpLm1hcCgoJCxiKT0+JCsoJC0xKSoocltiXS0xKSksdj1sLm1hcCgoJCxiKT0+JCthW2JdK2FbYitvXSkubWFwKCgkLGIpPT5NYXRoLmZsb29yKCgkLXlbYl0rbltiXSkvbltiXSkpO3JldHVybiB2LnNwbGljZSgwLDAsdSksdi5zcGxpY2Uocz8zOjEsMCxwKSx2fSxDcz1bMiwzLDEsMF0sTGQ9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IGNvbnYgMUQgYW5kIDJEXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCByPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxhPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKHIhPT1hKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMV0uZGltc1swXSE9PWVbMl0uZGltc1swXSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBuPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZih0LnBhZHMubGVuZ3RoIT09bioyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtuKjJ9RGApO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIil9LElzPShlLHQpPT57bGV0IHI9ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2ZvcihsZXQgcz0yO3M8dFsxXS5kaW1zLmxlbmd0aDsrK3MpcltzLTJdPT09MCYmKHJbcy0yXT10WzFdLmRpbXNbc10pO2xldCBhPWUucGFkcy5zbGljZSgpO010LmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLHIsYSxlLmZvcm1hdD09PVwiTkhXQ1wiLGUuYXV0b1BhZCk7bGV0IG49T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuLHtrZXJuZWxTaGFwZTpyLHBhZHM6YSxjYWNoZUtleTplLmNhY2hlS2V5fSksbn0sbmE9ZT0+e2xldCB0PWRuKGUpLHI9ZS5mb3JtYXQsYT1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLG49ZS5kaWxhdGlvbnMscz1lLmdyb3VwLHU9ZS5rZXJuZWxfc2hhcGUsbD1lLnBhZHMsbz1lLnN0cmlkZXMscD1lLndfaXNfY29uc3QoKTtyZXR1cm4gaWUoe2F1dG9QYWQ6YSxmb3JtYXQ6cixkaWxhdGlvbnM6bixncm91cDpzLGtlcm5lbFNoYXBlOnUscGFkczpsLHN0cmlkZXM6byx3SXNDb25zdDpwLC4uLnR9KX0sSGQ9KGUsdCxyKT0+e2xldCBhPUlzKHIsdCk7aWYoci5ncm91cCE9PTEpe2UuY29tcHV0ZShlYSh0LGEpKTtyZXR1cm59bGV0IG49ci5mb3JtYXQ9PT1cIk5IV0NcIixzPXQubGVuZ3RoPT09Myx1PXRbMF0uZGltc1tuPzE6Ml0sbD10WzBdLmRpbXNbbj8yOjNdLG89dFswXS5kaW1zW24/MzoxXSxwPXRbMV0uZGltc1syXSxtPXRbMV0uZGltc1szXSx5PXRhKHRbMF0uZGltcyx0WzFdLmRpbXMsci5kaWxhdGlvbnMsYS5wYWRzLHIuc3RyaWRlcyxuKSxnPXlbbj8xOjJdLHY9eVtuPzI6M10sJD15W24/MzoxXSxiPW4mJnA9PT11JiZtPT09bCYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MDtpZihifHxwPT09MSYmbT09PTEmJnIuZGlsYXRpb25zWzBdPT09MSYmci5kaWxhdGlvbnNbMV09PT0xJiZyLnN0cmlkZXNbMF09PT0xJiZyLnN0cmlkZXNbMV09PT0xJiZyLnBhZHNbMF09PT0wJiZyLnBhZHNbMV09PT0wKXtsZXQgUj15WzBdLFcsSCxLLGxlPVtdO2lmKG4pe2xldCBNPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKEN0KHRbMV0sQ3MpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07aWYoci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1NKSxiKXtsZXQgcT11KmwqbztXPXRbMF0ucmVzaGFwZShbMSxSLHFdKSxIPU0ucmVzaGFwZShbMSxxLCRdKSxLPVsxLFIsJF19ZWxzZSBXPXRbMF0ucmVzaGFwZShbUix1Kmwsb10pLEg9TS5yZXNoYXBlKFsxLG8sJF0pLEs9W1IsZyp2LCRdO2xlLnB1c2goVyksbGUucHVzaChIKX1lbHNlIFc9dFswXS5yZXNoYXBlKFtSLG8sdSpsXSksSD10WzFdLnJlc2hhcGUoWzEsJCxvXSksSz1bUiwkLGcqdl0sbGUucHVzaChIKSxsZS5wdXNoKFcpO3MmJmxlLnB1c2godFsyXSksZS5jb21wdXRlKGNuKGxlLGEseSxLLG4pLHtpbnB1dHM6bGV9KTtyZXR1cm59bGV0IFM9ITAsST1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShDdCh0WzFdLENzKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9SSk7bGV0IFQ9W3RbMF0sSV07cyYmVC5wdXNoKHRbMl0pO2xldCBCPW4/Zyp2OiQsUD1uPyQ6Zyp2LEQ9cCptKm87ZS5jb21wdXRlKCRzKFQsYSx5LEIsUCxELHMsUykse2lucHV0czpUfSl9LGpkPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixhPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZhLnB1c2goZS5pbnB1dHNbMl0pO2xldCBuPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0scz1bMV0uY29uY2F0KHQuc3RyaWRlcyksdT1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSxsPVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSksbz1Jcyh7Li4udCxwYWRzOm4sc3RyaWRlczpzLGRpbGF0aW9uczp1LGtlcm5lbFNoYXBlOmx9LGEpO2UuY29tcHV0ZShlYShhLG8scD0+cj9bcFswXSxwWzJdLHBbM11dOltdKSl9LGFhPShlLHQpPT57TGQoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zP2pkKGUsdCk6SGQoZSxlLmlucHV0cyx0KX19KTt2YXIgcWQsQXMsRXM9TCgoKT0+e1widXNlIHN0cmljdFwiO3h0KCk7Z2UoKTtzbigpO1puKCk7YnIoKTtxZD0oZSx0PSExLHIsYT0hMSxuPTQpPT57bGV0IHM9V2UobixcImYzMlwiKSx1PUk9Pntzd2l0Y2goSSl7Y2FzZSAxOnJldHVyblwicmV0dXJuIFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHdTaGFwZSldO1wiO2Nhc2UgNDpyZXR1cm5gXG4gICAgICAgICAgICBsZXQgY29vcmQxID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAxLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQyID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAyLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQzID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAzLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgdjAgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB3U2hhcGUpXTtcbiAgICAgICAgICAgIGxldCB2MSA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQxLCB3U2hhcGUpXTtcbiAgICAgICAgICAgIGxldCB2MiA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQyLCB3U2hhcGUpXTtcbiAgICAgICAgICAgIGxldCB2MyA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQzLCB3U2hhcGUpXTtcbiAgICAgICAgICAgIHJldHVybiB2ZWM0PGYzMj4odjAsIHYxLCB2MiwgdjMpO1xuICAgICAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0l9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxsPWU/YFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCBpWFIsIGlYQywgeENoKTtcbiAgICAgIGA6YFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIGlYUiwgaVhDKTtcbiAgICAgIGAsbz1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLHA9ZT9cIm91dEJhY2twcm9wWzFdXCI6XCJvdXRCYWNrcHJvcFsyXVwiLG09ZT9cIm91dEJhY2twcm9wWzJdXCI6XCJvdXRCYWNrcHJvcFszXVwiLHk9ZT9cInJvd1wiOlwiY29sXCIsZz1lP1wiY29sXCI6XCJyb3dcIix2PWBcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtlP1wib3V0QmFja3Byb3BbM11cIjpcIm91dEJhY2twcm9wWzFdXCJ9O1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xuICAgICAgbGV0IG91dFJvdyA9ICR7eX0gLyBvdXRXaWR0aDtcbiAgICAgIGxldCBvdXRDb2wgPSAke3l9ICUgb3V0V2lkdGg7XG5cbiAgICAgIGxldCBXUm93ID0gJHtnfSAvIChmaWx0ZXJEaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgV0NvbCA9ICR7Z30gLyBpbkNoYW5uZWxzICUgZmlsdGVyRGltc1sxXTtcbiAgICAgIGxldCB4UiA9IGYzMihvdXRSb3cgLSBwYWRzWzBdICsgZGlsYXRpb25bMF0gKiBXUm93KSAvIGYzMihzdHJpZGVzWzBdKTtcbiAgICAgIGxldCB4QyA9IGYzMihvdXRDb2wgLSBwYWRzWzFdICsgZGlsYXRpb25bMV0gKiBXQ29sKSAvIGYzMihzdHJpZGVzWzFdKTtcbiAgICAgIGlmICh4UiA8IDAuMCB8fCB4UiA+PSBmMzIoJHtwfSkgfHwgZnJhY3QoeFIpID4gMC4wKSB7XG4gICAgICAgIHJldHVybiAke3N9KDAuMCk7XG4gICAgICB9XG4gICAgICBpZiAoeEMgPCAwLjAgfHwgeEMgPj0gZjMyKCR7bX0pIHx8IGZyYWN0KHhDKSA+IDAuMCkge1xuICAgICAgICByZXR1cm4gJHtzfSgwLjApO1xuICAgICAgfVxuICAgICAgbGV0IGlYUiA9IGkzMih4Uik7XG4gICAgICBsZXQgaVhDID0gaTMyKHhDKTtcbiAgICAgIGxldCB4Q2ggPSAke2d9ICUgaW5DaGFubmVscztcbiAgICAgICR7bH1cbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB4U2hhcGUpLyR7bn1dO2AsJD1lP2BcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XG4gICAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUlubmVyKSB7XG4gICAgICAgICR7dn1cbiAgICAgIH1cbiAgICAgIHJldHVybiAke3N9KDAuMCk7YDpgXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xuICAgICAgaWYgKHJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xuICAgICAgICAke3Z9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHtzfSgwLjApO2AsYj1gXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xuICAgICAgbGV0IGluQ2hhbm5lbHMgPSAke2U/XCJvdXRCYWNrcHJvcFszXVwiOlwib3V0QmFja3Byb3BbMV1cIn07XG4gICAgICBsZXQgY29vcmRYID0gZmlsdGVyRGltcy54IC0gMSAtIHJvdyAvIChmaWx0ZXJEaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgY29vcmRZID0gZmlsdGVyRGltcy55IC0gMSAtIChyb3cgLyBpbkNoYW5uZWxzKSAlIGZpbHRlckRpbXNbMV07XG4gICAgICBpZiAoJHtlP1wicm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyXCI6XCJyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1BT3V0ZXJcIn0gICYmIGNvb3JkWCA+PSAwICYmIGNvb3JkWSA+PSAwKSB7XG4gICAgICAgIGxldCByb3dJbm5lciA9IHJvdyAlIGluQ2hhbm5lbHM7XG4gICAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sLCByb3dJbm5lcik7XG4gICAgICAgICR7dShuKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiAke3N9KDAuMCk7XG4gICAgICBgO3JldHVybmBcbiAgJHthbihyLGEsbj09PTQsNCl9XG4gIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7c30ge1xuICAgICR7ZT8kOmJ9XG4gIH1cblxuICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3N9IHtcbiAgICAke2U/YjokfVxuICB9XG5cbiAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbnB1dCA6ICR7c30pIHtcbiAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xuICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0O1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xuICAgICAgJHtvfVxuICAgICAgJHtvbih0LHIpfVxuICAgICAgcmVzdWx0W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3Jkcywgb3V0U2hhcGUpLyR7bn1dID0gdmFsdWU7XG4gICAgfVxuICB9YH0sQXM9KGUsdCxyLGEsbixzLHUsbCk9PntsZXQgbz10LmZvcm1hdD09PVwiTkhXQ1wiLHA9bz9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLG09clswXSx5PW8/clsyXTpyWzNdLGc9bz9yWzFdOnJbMl0sdj1vP3JbM106clsxXSwkPW8/cCU0PT09MCYmdiU0PT09MDp5JTQ9PT0wJiZ2JTQ9PT0wLGI9bz92OnkqZyxTPW8/eSpnOnYsST0kP1s4LDgsMV06W2I8PTR8fFM8PTQ/NDoxNixiPjQmJlM8PTQ/NDoxNiwxXSxUPSQ/WzQsNCwxXTpbYjw9ND8xOjQsYj40JiZTPD00PzE6NCwxXSxCPVtNYXRoLmNlaWwoYi9JWzBdL1RbMF0pLE1hdGguY2VpbChTL0lbMV0vVFsxXSksTWF0aC5jZWlsKG0vSVsyXS9UWzJdKV07X2UoXCJ2ZXJib3NlXCIsKCk9PmBbY29udl9iYWNrcHJvcF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtCfWApO2xldCBQPSQ/NDoxLEQ9TWF0aC5tYXgoSVswXSpQLElbMV0pLFI9W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHg6IGFycmF5PCR7JD9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtgLFwiQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBXOiBhcnJheTxmMzI+O1wiXSxXPVwiXCI7cmV0dXJuIHUmJihSLnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhczogYXJyYXk8JHskP1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O2ApLFcrPWBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHskP1widmVjNDxmMzI+XCI6XCJmMzJcIn0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke28/XCJ3XCI6XCJ5XCJ9JHskP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YCkse25hbWU6XCJDb252MkRUcmFuc3Bvc2VNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6QlswXSx5OkJbMV0sejpCWzJdfX0pLGdldFNoYWRlclNvdXJjZTooKT0+YFxuICAgICAgICAke3VufVxuICAgICAgICAke1Iuam9pbihgXG5gKX1cbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7Ui5sZW5ndGh9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0OiBhcnJheTwkeyQ/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifT47XG4gICAgICAgIGNvbnN0IG91dEJhY2twcm9wIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IHhTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCB3U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzFdLmRpbXMuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtyLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IG91dFNoYXBlU3RyaWRlcyA6IHZlYzM8aTMyPiA9IHZlYzM8aTMyPigke3ouY29tcHV0ZVN0cmlkZXMocikuc2xpY2UoMCwzKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5rZXJuZWxTaGFwZVtvPzE6Ml19LCAke3Qua2VybmVsU2hhcGVbbz8yOjNdfSk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSBmaWx0ZXJEaW1zICsgdmVjMjxpMzI+KFxuICAgICAgICAgICAgICAke3QuZGlsYXRpb25zWzBdPD0xPzA6KHQua2VybmVsU2hhcGVbbz8xOjJdLTEpKih0LmRpbGF0aW9uc1swXS0xKX0sXG4gICAgICAgICAgICAgICR7dC5kaWxhdGlvbnNbMV08PTE/MDoodC5rZXJuZWxTaGFwZVtvPzI6M10tMSkqKHQuZGlsYXRpb25zWzFdLTEpfSk7XG4gICAgICAgIGNvbnN0IHBhZHMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0pIC0gMSAtICgke3QucGFkc1swXSt0LnBhZHNbMl19KS8yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1sxXSkgLSAxIC0gKCR7dC5wYWRzWzFdK3QucGFkc1szXX0pLzIpO1xuICAgICAgICBjb25zdCBzdHJpZGVzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5zdHJpZGVzWzBdfSwgJHt0LnN0cmlkZXNbMV19KTtcbiAgICAgICAgY29uc3QgZGlsYXRpb24gOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LmRpbGF0aW9uc1swXX0sICR7dC5kaWxhdGlvbnNbMV19KTtcbiAgICAgICAgY29uc3QgZGltQU91dGVyIDogaTMyID0gJHthfTtcbiAgICAgICAgY29uc3QgZGltQk91dGVyIDogaTMyID0gJHtufTtcbiAgICAgICAgY29uc3QgZGltSW5uZXIgOiBpMzIgPSAke3N9O1xuICAgICAgICAke1d9XG4gICAgICAgICR7cWQobyx1LHQuYWN0aXZhdGlvbi50b0xvd2VyQ2FzZSgpLCExLFApfVxuICAgICAgICAkeyQ/Z3IoVCxJLFwiZjMyXCIsdm9pZCAwLCFvLEQpOnlyKFQsSSxcImYzMlwiLHZvaWQgMCwhbyxELCExLHZvaWQgMCxsKX1gfX19KTt2YXIgS2Qsb2EsX3M9TCgoKT0+e1widXNlIHN0cmljdFwiO3h0KCk7Z2UoKTt2ZSgpO0tkPShlLHQscixhLG4scyx1PSExLGwpPT57bGV0IG89ci5mb3JtYXQ9PT1cIk5IV0NcIixwPW8/MToyLG09bz8yOjMseT1vPzM6MSxnPXouc2l6ZShhKSx2PXU/MjoxLCQ9ci5ncm91cCxiPXRbMV0uZGltcyxTPWJbMF0vJCxJPWJbMV0sVD1gXG4gIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogdTMyLCB2YWx1ZSA6ICR7dT9gdmVjNDwke2x9PmA6bH0pIHtcbiAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7dT9gdmVjNDwke2x9PmA6bH0odmFsdWUpO1xuICB9YDtuJiYoVCs9YFxuICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PHUzMj4pIC0+ICR7dT9gdmVjNDwke2x9PmA6bH0ge1xuICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7bz9cIndcIjpcInlcIn0ke3U/XCIvIDRcIjpcIlwifV07XG4gICAgfWApO2xldCBCPXU/NDoxLFA9RihcIldcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcyxCKSxEPUYoXCJEeVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLEIpLFI9W0QsUF07biYmUi5wdXNoKEYoXCJiaWFzXCIsdFsyXS5kYXRhVHlwZSxbYVt5XV0sQikpO2xldCBXPVgoXCJyZXN1bHRcIix0WzBdLmRhdGFUeXBlLGEsQiksSD1ge1xuICAgICAgICBsZXQgYmF0Y2g6IHUzMiA9ICR7cz9cImdsb2JhbF9pZC56XCI6XCJ3b3JrZ3JvdXBfaWQuelwifSAvIG91dFNoYXBlWzFdO1xuICAgICAgICBsZXQgciA9ICR7cz9cImdsb2JhbF9pZC56XCI6XCJ3b3JrZ3JvdXBfaWQuelwifSAlIG91dFNoYXBlWzFdO1xuICAgICAgICBsZXQgYyA9ICR7cz9cImdsb2JhbF9pZC55XCI6XCJ3b3JrZ3JvdXBfaWQueVwifSAqICR7dn07XG4gICAgICAgIGxldCBkMTogdTMyID0gJHtzP1wiZ2xvYmFsX2lkLnhcIjpcIndvcmtncm91cF9pZC54XCJ9ICogNDtcblxuICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdmVjMjxpMzI+KHBhZHMpO1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgdmFyIGRvdFByb2Q6IGFycmF5PHZlYzQ8JHtsfT4sICR7dn0+O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7dn07IGkrKykge1xuICAgICAgICAgIGRvdFByb2RbaV0gPSB2ZWM0PCR7bH0+KDAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgZmlsdGVyRGltc1swXTsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICB2YXIgZHlSID0gKCR7bH0oZHlDb3JuZXIueCkgKyAke2x9KHdSKSkgLyAke2x9KHN0cmlkZXMueCk7XG4gICAgICAgICAgbGV0IHdSUGVybSA9IGZpbHRlckRpbXNbMF0gLSAxIC0gd1I7XG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtsfShvdXRCYWNrcHJvcFsxXSkgfHxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCB8fCB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgZmlsdGVyRGltc1sxXTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgIGxldCBkeUMgPSAoJHtsfShkeUNvcm5lci55KSArICR7bH0od0MpKSAvICR7bH0oc3RyaWRlcy55KTtcbiAgICAgICAgICAgIGxldCBkeUMyID0gKCR7bH0oZHlDb3JuZXIueSkgKyAxLjAgKyAke2x9KHdDKSkgLyAke2x9KHN0cmlkZXMueSk7XG4gICAgICAgICAgICBsZXQgd0NQZXJtID0gZmlsdGVyRGltc1sxXSAtIDEgLSB3QztcbiAgICAgICAgICAgIGlmICh3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJEeUNWYWwgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGJEeUNWYWwyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7bH0ob3V0QmFja3Byb3BbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBiRHlDVmFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHlDMiA8IDAuMCB8fCBkeUMyID49ICR7bH0ob3V0QmFja3Byb3BbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDMikgPiAwLjApIHtcbiAgICAgICAgICAgICAgYkR5Q1ZhbDIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgbGV0IGlkeUMyOiB1MzIgPSB1MzIoZHlDMik7XG4gICAgICAgICAgICBpZiAoYkR5Q1ZhbCAmJiBiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSBvdXRCYWNrcHJvcFszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDIgOnUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDJcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5Q1wiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7bH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcblxuICAgICAgICAgICAgICAgIHhWYWx1ZSA9ICAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XG5cbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHZlYzQ8JHtsfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJEeUNWYWwpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbJHt5fV07XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2x9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbM107XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtsfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdG1wdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7dn07IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2RbaV0gKyAke24/XCJiaWFzW2MraV1cIjpcIjAuMFwifTtcbiAgICAgICAgICAke1cuc2V0KFwiYmF0Y2hcIixcInJcIixcImMgKyBpXCIsXCJkMVwiLFwidmFsdWVcIil9O1xuICAgICAgICB9XG4gICAgICB9YCxLPWBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Vy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSAke1cuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XG4gICAgICAgICAgbGV0IGQxID0gJHtXLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIseSl9O1xuICAgICAgICAgIGxldCByID0gJHtXLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIscCl9O1xuICAgICAgICAgIGxldCBjID0gJHtXLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsbSl9O1xuICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSBwYWRzO1xuICAgICAgICAgIGxldCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyAke0l9O1xuICAgICAgICAgIGxldCB3T3V0Q2hhbm5lbCA9IGQxIC0gZ3JvdXBJZCAqICR7SX07XG4gICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgICAgdmFyIGRvdFByb2QgPSAwLjA7XG4gICAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgZWZmZWN0aXZlRmlsdGVyRGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgaWYgKHdSICUgZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeVIgPSAoJHtsfShkeVJDb3JuZXIpICsgJHtsfSh3UikpIC8gJHtsfShzdHJpZGVzWzBdKTtcbiAgICAgICAgICAgIGxldCB3UlBlcm0gPSBmaWx0ZXJEaW1zLnggLSAxIC0gd1IgLyBkaWxhdGlvbnMueDtcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7bH0ob3V0QmFja3Byb3BbJHtwfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcbiAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCBlZmZlY3RpdmVGaWx0ZXJEaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3QyAlIGRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7bH0oZHlDQ29ybmVyKSArICR7bH0od0MpKSAvICR7bH0oc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IGZpbHRlckRpbXMueSAtIDEgLSB3QyAvIGRpbGF0aW9ucy55O1xuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2x9KG91dEJhY2twcm9wWyR7bX1dKSB8fFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqICR7U307XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8ICR7U307IGQyID0gZDIgKyAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7bz9ELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDXCIsXCJpbnB1dENoYW5uZWxcIik6RC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRDaGFubmVsXCIsXCJpZHlSXCIsXCJpZHlDXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtQLmdldChcImlucHV0Q2hhbm5lbFwiLFwid091dENoYW5uZWxcIixcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiKX07XG4gICAgICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kICsgJHtuP1wiYmlhc1tkMV1cIjpcIjAuMFwifTtcbiAgICAgICAgICAke1cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICAgIGA7cmV0dXJuYFxuICAke2UuZGVjbGFyZVZhcmlhYmxlcyguLi5SLFcpfVxuICAke1R9XG4gIGNvbnN0IG91dFNoYXBlIDogdmVjNDx1MzI+ID0gdmVjNDx1MzI+KCR7YS5qb2luKFwiLFwiKX0pO1xuICBjb25zdCBvdXRCYWNrcHJvcCA6IHZlYzQ8dTMyPiA9IHZlYzQ8dTMyPigke3RbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xuICBjb25zdCBzdHJpZGVzIDogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcbiAgY29uc3QgZmlsdGVyRGltcyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke3Iua2VybmVsU2hhcGVbbz8xOjJdfSwgJHtyLmtlcm5lbFNoYXBlW28/MjozXX0pO1xuICBjb25zdCBkaWxhdGlvbnMgOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4oJHtyLmRpbGF0aW9uc1swXX0sICR7ci5kaWxhdGlvbnNbMV19KTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA6IHZlYzI8dTMyPiA9IGZpbHRlckRpbXMgKyB2ZWMyPHUzMj4oXG4gICAgICAgICAgJHtyLmRpbGF0aW9uc1swXTw9MT8wOihyLmtlcm5lbFNoYXBlW28/MToyXS0xKSooci5kaWxhdGlvbnNbMF0tMSl9LFxuICAgICAgICAgICR7ci5kaWxhdGlvbnNbMV08PTE/MDooci5rZXJuZWxTaGFwZVtvPzI6M10tMSkqKHIuZGlsYXRpb25zWzFdLTEpfSk7XG4gIGNvbnN0IHBhZHMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0pIC0gMSAtICgke3IucGFkc1swXStyLnBhZHNbMl19KS8yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdKSAtIDEgLSAoJHtyLnBhZHNbMV0rci5wYWRzWzNdfSkvMik7XG4gICAgJHtlLm1haW5TdGFydCgpfVxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGcpfTtcbiAgJHt1P0g6S319YH0sb2E9KGUsdCxyKT0+e2xldCBhPWUubGVuZ3RoPjIsbj10Lm91dHB1dFNoYXBlLHM9ei5zaXplKG4pLHU9W01hdGguY2VpbChzLzY0KSwxLDFdO19lKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHt1fWApO2xldCBsPUJlKGVbMF0uZGF0YVR5cGUpO3JldHVybntuYW1lOlwiQ29udlRyYW5zcG9zZTJEXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtkaXNwYXRjaEdyb3VwOnt4OnVbMF0seTp1WzFdLHo6dVsyXX0sb3V0cHV0czpbe2RpbXM6cj9yKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dfSksZ2V0U2hhZGVyU291cmNlOm89PktkKG8sZSx0LG4sYSx1WzFdPT09MSYmdVsyXT09PTEsITEsbCl9fX0pO3ZhciBZZCxYZCxKZCxPcyxUcyxRZCxaZCxlYyx0YyxScyxQcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7a2UoKTtFcygpO19zKCk7aHIoKTttcigpO1lkPShlLHQscixhLG4scyk9PihlLTEpKnQrcisoYS0xKSpuKzEtcyxYZD0oZSx0LHIsYSxuKT0+e2xldCBzPU1hdGguZmxvb3IoZS8yKTt0PT09XCJTQU1FX1VQUEVSXCI/KHJbYV09cyxyW25dPWUtcyk6dD09PVwiU0FNRV9MT1dFUlwiJiYoclthXT1lLXMscltuXT1zKX0sSmQ9KGUsdCxyLGEsbixzLHUsbCxvLHApPT57bGV0IG09ZS5sZW5ndGgtMix5PXAubGVuZ3RoPT09MDtpZihvLmxlbmd0aD09PTApZm9yKGxldCAkPTA7JDxtOysrJClvLnB1c2goMCk7bGV0IGc9ZVswXSx2PXRbbD8zOjFdKm47Zm9yKGxldCAkPTAsYj1lLmxlbmd0aC1tLShsPzE6MCk7JDxtOysrJCwrK2Ipe2xldCBTPWVbYl0sST15P1MqdVskXTpwWyRdLFQ9WWQoUyx1WyRdLHNbJF0sdFtiXSxyWyRdLEkpO1hkKFQsYSxzLCQsJCttKSx5JiZwLnB1c2godVskXSooUy0xKStvWyRdKyh0W2JdLTEpKnJbJF0rMS1zWyRdLXNbJCttXSl9cC5zcGxpY2UoMCwwLGcpLHAuc3BsaWNlKGw/MzoxLDAsdil9LE9zPShlLHQpPT57bGV0IHI9ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKGUua2VybmVsU2hhcGUubGVuZ3RoPT09MHx8ZS5rZXJuZWxTaGFwZS5yZWR1Y2UoKGcsdik9PmcqdiwxKT09PTApe3IubGVuZ3RoPTA7Zm9yKGxldCBnPTI7Zzx0WzFdLmRpbXMubGVuZ3RoOysrZylyLnB1c2godFsxXS5kaW1zW2ddKX1sZXQgYT1lLmZvcm1hdD09PVwiTkhXQ1wiO3Iuc3BsaWNlKDAsMCx0WzFdLmRpbXNbMF0pLHIuc3BsaWNlKGE/MzoxLDAsdFsxXS5kaW1zWzFdKTtsZXQgbj1lLnBhZHMuc2xpY2UoKSxzPWUub3V0cHV0U2hhcGUuc2xpY2UoKSx1PWUub3V0cHV0UGFkZGluZy5zbGljZSgpLGw9dFswXS5kaW1zLG89ZS5kaWxhdGlvbnMuc2xpY2UoKTtpZihvLnJlZHVjZSgoZyx2KT0+Zyt2LDApPT09MCl7bGV0IGc9dFswXS5kaW1zLmxlbmd0aC0yO289bmV3IEFycmF5KGcpLmZpbGwoMSl9bGV0IHA9ZS5zdHJpZGVzLnNsaWNlKCk7aWYocC5yZWR1Y2UoKGcsdik9PmcrdiwwKT09PTApe2xldCBnPXRbMF0uZGltcy5sZW5ndGgtMjtwPW5ldyBBcnJheShnKS5maWxsKDEpfUpkKGwscixvLGUuYXV0b1BhZCxlLmdyb3VwLG4scCxhLHUscyk7bGV0IG09T2JqZWN0LmFzc2lnbih7fSxlKSx5PWUuY2FjaGVLZXkrW3Iuam9pbihcIm4sXCIpLG4uam9pbihcIixcIikscC5qb2luKFwiLFwiKSx1LmpvaW4oXCIsXCIpLHMuam9pbihcIixcIiksby5qb2luKFwiLFwiKV0uam9pbihcIl9cIik7cmV0dXJuIE9iamVjdC5hc3NpZ24obSx7a2VybmVsU2hhcGU6cixwYWRzOm4sb3V0cHV0UGFkZGluZzp1LG91dHB1dFNoYXBlOnMsZGlsYXRpb25zOm8sc3RyaWRlczpwLGNhY2hlS2V5Onl9KSxtfSxUcz1lPT57bGV0IHQ9ZG4oZSkscj1lLmZvcm1hdCxhPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bdHlwZW9mIGUuYXV0b1BhZD5cInVcIj8wOmUuYXV0b1BhZF0sbj1lLmRpbGF0aW9ucyxzPWUuZ3JvdXAsdT1lLmtlcm5lbFNoYXBlLGw9ZS5wYWRzLG89ZS5zdHJpZGVzLHA9ZS53SXNDb25zdCgpLG09ZS5vdXRwdXRQYWRkaW5nLHk9ZS5vdXRwdXRTaGFwZTtyZXR1cm4gaWUoe2F1dG9QYWQ6YSxmb3JtYXQ6cixkaWxhdGlvbnM6bixncm91cDpzLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzptLG91dHB1dFNoYXBlOnkscGFkczpsLHN0cmlkZXM6byx3SXNDb25zdDpwLC4uLnR9KX0sUWQ9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sYT1lWzFdLmRpbXNbMF07aWYociE9PWEpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbj1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBzPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKG0seSk9Pm0reSwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3N9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKG0seSk9Pm0reSwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c31EYCk7aWYodC5wYWRzLnJlZHVjZSgobSx5KT0+bSt5LDApPjAmJnQucGFkcy5sZW5ndGghPT1zKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3MqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXMmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c31EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKG0seSk9Pm0reSwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LFpkPVsyLDMsMSwwXSxlYz0oZSx0LHIpPT57bGV0IGE9T3Mocix0KSxuPXIuZm9ybWF0PT09XCJOSFdDXCIscz10Lmxlbmd0aD09PTM7aWYoYS5ncm91cCE9PTEpe2UuY29tcHV0ZShvYSh0LGEpKTtyZXR1cm59bGV0IHU9YS5vdXRwdXRTaGFwZSxsPXVbbj8xOjJdLG89dVtuPzI6M10scD11W24/MzoxXSxtPXRbMV0uZGltc1syXSx5PXRbMV0uZGltc1szXSxnPXRbMF0uZGltc1tuPzM6MV0sdj1uP2wqbzpwLCQ9bj9wOmwqbyxiPW0qeSpnLFM9ITAsST1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShDdCh0WzFdLFpkKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9SSk7bGV0IFQ9W3RbMF0sSV07cyYmKCFuJiZ0WzJdLmRpbXMubGVuZ3RoPT09MT9ULnB1c2godFsyXS5yZXNoYXBlKFt0WzJdLmRpbXNbMF0sMSwxXSkpOlQucHVzaCh0WzJdKSksZS5jb21wdXRlKEFzKFQsYSx1LHYsJCxiLHMsUykse2lucHV0czpUfSl9LHRjPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixhPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTthLmxlbmd0aD09PTMmJmEucHVzaChlLmlucHV0c1syXSk7bGV0IG49dC5rZXJuZWxTaGFwZTsobi5sZW5ndGg9PT0wfHxuWzBdPT09MCkmJihuPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IHM9dC5kaWxhdGlvbnM7KHMubGVuZ3RoPT09MHx8c1swXT09PTApJiYocz1bMV0pO2xldCB1PXQuc3RyaWRlczsodS5sZW5ndGg9PT0wfHx1WzBdPT09MCkmJih1PVsxXSk7bGV0IGw9dC5wYWRzO2wubGVuZ3RoPT09MCYmKGw9WzAsMF0pLGw9WzAsbFswXSwwLGxbMV1dLHU9WzFdLmNvbmNhdCh1KSxzPVsxXS5jb25jYXQocyksbj1bMV0uY29uY2F0KG4pO2xldCBvPU9zKHsuLi50LHBhZHM6bCxzdHJpZGVzOnUsZGlsYXRpb25zOnMsa2VybmVsU2hhcGU6bn0sYSk7ZS5jb21wdXRlKG9hKGEsbyxwPT5yP1twWzBdLHBbMl0scFszXV06W3BbMF0scFsxXSxwWzNdXSkpfSxScz0oZSx0KT0+e1FkKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Mz90YyhlLHQpOmVjKGUsZS5pbnB1dHMsdCl9fSk7dmFyIGlhLHBuLGtzLHJjLG5jLHNhLHVhLGFjLEJzLE1zLERzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtpYT1cIlthLXpBLVpdfFxcXFwuXFxcXC5cXFxcLlwiLHBuPVwiKFwiK2lhK1wiKStcIixrcz1cIl5cIitwbitcIiRcIixyYz1cIihcIitwbitcIiwpKlwiK3BuLG5jPVwiXlwiK3JjK1wiJFwiLHNhPWNsYXNze2NvbnN0cnVjdG9yKHQ9LTEpe3RoaXMuc3ltYm9sVG9JbmRpY2VzPW5ldyBNYXAsdGhpcy5pbnB1dEluZGV4PXR9YWRkU3ltYm9sKHQscil7bGV0IGE9dGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHQpO2E9PT12b2lkIDA/YT1bcl06YS5wdXNoKHIpLHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldCh0LGEpfX0sdWE9Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLmVxdWF0aW9uPXI7dGhpcy5oYXNFbGxpcHNpcz0hMSx0aGlzLnN5bWJvbFRvSW5mbz1uZXcgTWFwLHRoaXMubGhzPW5ldyBBcnJheSx0aGlzLm91dHB1dERpbXM9W107bGV0W2Esbl09ci5pbmNsdWRlcyhcIi0+XCIpP3Iuc3BsaXQoXCItPlwiLDIpOltyLFwiXCJdO2lmKCFhLm1hdGNoKFJlZ0V4cChuYykpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7aWYoYS5zcGxpdChcIixcIikuZm9yRWFjaCgobCxvKT0+e2xldCBwPXRbb10uZGltcy5zbGljZSgpO2lmKCFsLm1hdGNoKFJlZ0V4cChrcykpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IG09dGhpcy5wcm9jZXNzVGVybShsLCEwLHAsbyk7dGhpcy5saHMucHVzaChtKX0pLG49PT1cIlwiKW4rPVsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldLmZpbHRlcigoW2wsb10pPT5vLmNvdW50PT09MXx8bD09PVwiLi4uXCIpLm1hcCgoW2xdKT0+bCkuam9pbihcIlwiKTtlbHNlIGlmKCFuLm1hdGNoKFJlZ0V4cChwbikpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTXCIpO24ubWF0Y2goUmVnRXhwKGlhLFwiZ1wiKSk/LmZvckVhY2gobD0+e2lmKGw9PT1cIi4uLlwiKXRoaXMub3V0cHV0RGltcz10aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtlbHNle2xldCBvPXRoaXMuc3ltYm9sVG9JbmZvLmdldChsKTtpZihvPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTIHN5bWJvbFwiKTt0aGlzLm91dHB1dERpbXMucHVzaChvLmRpbVZhbHVlKX19KSx0aGlzLnJocz10aGlzLnByb2Nlc3NUZXJtKG4sITAsdGhpcy5vdXRwdXREaW1zKX1hZGRTeW1ib2wodCxyLGEpe2xldCBuPXRoaXMuc3ltYm9sVG9JbmZvLmdldCh0KTtpZihuIT09dm9pZCAwKXtpZihuLmRpbVZhbHVlIT09ciYmbi5jb3VudCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc21hdGNoXCIpO24uY291bnQrKyxuLmlucHV0SW5kaWNlcy5wdXNoKGEpfWVsc2Ugbj17Y291bnQ6MSxkaW1WYWx1ZTpyLGlucHV0SW5kaWNlczpbYV19O3RoaXMuc3ltYm9sVG9JbmZvLnNldCh0LG4pfXByb2Nlc3NUZXJtKHQscixhLG49LTEpe2xldCBzPWEubGVuZ3RoLHU9ITEsbD1bXSxvPTA7aWYoIXQubWF0Y2goUmVnRXhwKGtzKSkmJiFyJiZ0IT09XCJcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBwPXQubWF0Y2goUmVnRXhwKGlhLFwiZ1wiKSksbT1uZXcgc2Eobik7cmV0dXJuIHA/LmZvckVhY2goKHksZyk9PntpZih5PT09XCIuLi5cIil7aWYodSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBlbGxpcHNpcyBpcyBhbGxvd2VkIHBlciBpbnB1dCB0ZXJtXCIpO3U9ITA7bGV0IHY9cy1wLmxlbmd0aCsxO2lmKHY8MCl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBvdXQgb2YgYm91bmRzXCIpO2lmKGw9YS5zbGljZShvLG8rdiksdGhpcy5oYXNFbGxpcHNpcyl7aWYodGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIT09bC5sZW5ndGh8fHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkhPT1sLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaFwiKX1lbHNlIGlmKHIpdGhpcy5oYXNFbGxpcHNpcz0hMCx0aGlzLmVsbGlwc2lzRGltcz1sO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIU1wiKTtmb3IobGV0ICQ9MDskPGwubGVuZ3RoOyQrKyl7bGV0IGI9U3RyaW5nLmZyb21DaGFyQ29kZShcIjBcIi5jaGFyQ29kZUF0KDApK2cpO20uYWRkU3ltYm9sKGIsZyskKSx0aGlzLmFkZFN5bWJvbChiLGFbbysrXSxuKX19ZWxzZSBtLmFkZFN5bWJvbCh5LGcpLHRoaXMuYWRkU3ltYm9sKHksYVtvKytdLG4pfSksbX19LGFjPShlLHQpPT57bGV0IHI9ZVswXS5kYXRhVHlwZSxhPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBCPTA7QjxlLmxlbmd0aDsrK0IpYVtCXT1GKGBpbnB1dCR7Qn1gLHIsZVtCXS5kaW1zKTtsZXQgbj10Lm91dHB1dERpbXMscz16LnNpemUobiksdT1YKFwib3V0cHV0XCIscixuKSxsPVtdLG89QXJyYXkuZnJvbSh0LnJocy5zeW1ib2xUb0luZGljZXMua2V5cygpKSxwPVwidmFyIHByb2QgPSAxLjA7XCIsbT1cInZhciBzdW0gPSAwLjA7XCIseT1cInN1bSArPSBwcm9kO1wiLGc9W10sdj1bXSwkPVtdLGI9W10sUz10LnN5bWJvbFRvSW5mby5zaXplPT09by5sZW5ndGg7dC5zeW1ib2xUb0luZm8uZm9yRWFjaCgoQixQKT0+e2lmKG8uaW5jbHVkZXMoUCkpe2xldCBEPW8uaW5kZXhPZihQKTt0Lmxocy5mb3JFYWNoKChSLFcpPT57aWYoQi5pbnB1dEluZGljZXMuaW5jbHVkZXMoVykpe2xldCBIPVIuc3ltYm9sVG9JbmRpY2VzLmdldChQKTtpZihIPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0guZm9yRWFjaChLPT57bC5wdXNoKGAke2FbV10uaW5kaWNlc1NldChgaW5wdXQke1d9SW5kaWNlc2AsSyx1LmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsRCkpfWApfSl9fSl9ZWxzZSB0Lmxocy5mb3JFYWNoKChELFIpPT57bGV0IFc9dC5zeW1ib2xUb0luZm8uZ2V0KFApO2lmKFc9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7aWYoVy5pbnB1dEluZGljZXMuaW5jbHVkZXMoUikpe2xldCBIPUQuc3ltYm9sVG9JbmRpY2VzLmdldChQKTtpZihIPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0guZm9yRWFjaChLPT57Zy5wdXNoKGAke2FbUl0uaW5kaWNlc1NldChgaW5wdXQke1J9SW5kaWNlc2AsSyxgJHtQfWApfWApfSksYi5wdXNoKGBwcm9kICo9ICR7YVtSXS5nZXRCeUluZGljZXMoYGlucHV0JHtSfUluZGljZXNgKX07YCl9fSksdi5wdXNoKGBmb3IodmFyICR7UH06IHUzMiA9IDA7ICR7UH0gPCAke3Quc3ltYm9sVG9JbmZvLmdldChQKT8uZGltVmFsdWV9OyAke1B9KyspIHtgKSwkLnB1c2goXCJ9XCIpfSk7bGV0IEk9Uz9bLi4ubCxgbGV0IHN1bSA9ICR7YS5tYXAoKEIsUCk9PkIuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7UH1JbmRpY2VzYCkpLmpvaW4oXCIgKiBcIil9O2BdOlsuLi5sLG0sLi4udiwuLi5nLHAsLi4uYix5LC4uLiRdLFQ9Qj0+YFxuICAgICAgJHtCLmRlY2xhcmVWYXJpYWJsZXMoLi4uYSx1KX1cblxuICAgICAgJHtCLm1haW5TdGFydCgpfVxuICAgICAgICAke0IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzKX1cbiAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke3Uub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICR7YS5tYXAoKFAsRCk9PmB2YXIgaW5wdXQke0R9SW5kaWNlczogJHthW0RdLnR5cGUuaW5kaWNlc307YCkuam9pbihgXG5gKX1cbiAgICAgICAgJHtJLmpvaW4oYFxuYCl9O1xuICAgICAgICAke3Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgfWA7cmV0dXJue25hbWU6XCJFaW5zdW1cIixzaGFkZXJDYWNoZTp7aGludDp0LmVxdWF0aW9ufSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpUfX0sQnM9KGUsdCk9PntsZXQgcj1uZXcgdWEoZS5pbnB1dHMsdC5lcXVhdGlvbik7ZS5jb21wdXRlKGFjKGUuaW5wdXRzLHIpKX0sTXM9ZT0+e2xldCB0PWUuZXF1YXRpb24ucmVwbGFjZSgvXFxzKy9nLFwiXCIpO3JldHVybiBpZSh7ZXF1YXRpb246dH0pfX0pO3ZhciBvYyx6cyxpYyxzYyxXcyxOcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO29jPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksYT1yLmxlbmd0aDx0Lmxlbmd0aD8wOnIubGVuZ3RoLXQubGVuZ3RoLG49dC5sZW5ndGg8ci5sZW5ndGg/MDp0Lmxlbmd0aC1yLmxlbmd0aDtmb3IoO2E8ci5sZW5ndGgmJm48dC5sZW5ndGg7KythLCsrbilpZihyW2FdIT09dFtuXSYmclthXSE9PTEmJnRbbl0hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSx6cz0oZSx0KT0+e2xldCByPWUubGVuZ3RoLXQubGVuZ3RoLGE9W107Zm9yKGxldCBuPTA7bjxyOysrbilhLnB1c2goZVtuXSk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pYS5wdXNoKHRbbl09PT0xP2VbbityXTp0W25dKTtyZXR1cm4gYX0saWM9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP3pzKGUsdCk6enModCxlKSxzYz1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLGE9aWModCxyKSxuPXouc2l6ZShhKSxzPWVbMF0uZGF0YVR5cGUsdT1GKFwiaW5wdXRcIixzLHQpLGw9WChcIm91dHB1dFwiLHMsYSksbz1wPT5gXG4gIGNvbnN0IGlucHV0U2hhcGUgPSAke3UuaW5kaWNlcyguLi50KX07XG4gICR7cC5kZWNsYXJlVmFyaWFibGVzKHUsbCl9XG4gICR7cC5tYWluU3RhcnQoKX1cbiAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobil9XG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgdmFyIGlucHV0SW5kaWNlczogJHt1LnR5cGUuaW5kaWNlc307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XG4gICAgICBpZiAoJHt1LmluZGljZXNHZXQoXCJpbnB1dFNoYXBlXCIsXCJpXCIpfSA9PSAxKSB7XG4gICAgICAgICR7dS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLGwuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixgaSArICR7YS5sZW5ndGgtdC5sZW5ndGh9YCkpfVxuICAgICAgfVxuICAgIH1cbiAgICAke2wuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIikpfVxuICB9YDtyZXR1cm57bmFtZTpcIkV4cGFuZFwiLHNoYWRlckNhY2hlOntoaW50OmAke2F9YH0sZ2V0U2hhZGVyU291cmNlOm8sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX19KX19LFdzPWU9PntvYyhlLmlucHV0cyksZS5jb21wdXRlKHNjKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciB1YyxsYyxWcyxVcyxHcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7dWM9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLlwiKX0sbGM9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsYT1lWzFdLmRpbXMsbj1yLmxlbmd0aCxzPXoubm9ybWFsaXplQXhpcyh0LmF4aXMsbiksdT1yLnNsaWNlKDApO3Uuc3BsaWNlKHMsMSwuLi5hKTtsZXQgbD1yW3NdLG89ei5zaXplKHUpLHA9RihcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksbT1GKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLHk9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdSksZz0oKT0+e2xldCAkPWEubGVuZ3RoLGI9YHZhciBpbmRpY2VzSW5kaWNlcyAgPSAke20udHlwZS5pbmRpY2VzfSgwKTtgO2ZvcihsZXQgUz0wO1M8JDtTKyspYis9YCR7JD4xP2BpbmRpY2VzSW5kaWNlc1ske1N9XWA6XCJpbmRpY2VzSW5kaWNlc1wifSA9ICR7dS5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlc1ske3MrU31dYDpcIm91dHB1dEluZGljZXNcIn07YDtiKz1gXG4gICAgICAgIHZhciBpZHggPSAke20uZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc0luZGljZXNcIil9O1xuICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgIGlkeCA9IGlkeCArICR7bH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFJbmRpY2VzID0gJHtwLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICBgO2ZvcihsZXQgUz0wLEk9MDtTPG47UysrKVM9PT1zPyhiKz1gJHtuPjE/YGRhdGFJbmRpY2VzWyR7U31dYDpcImRhdGFJbmRpY2VzXCJ9ID0gdTMyKGlkeCk7YCxJKz0kKTooYis9YCR7bj4xP2BkYXRhSW5kaWNlc1ske1N9XWA6XCJkYXRhSW5kaWNlc1wifSA9ICR7dS5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlc1ske0l9XWA6XCJvdXRwdXRJbmRpY2VzXCJ9O2AsSSsrKTtyZXR1cm4gYn0sdj0kPT5gXG4gICAgICAkeyQuZGVjbGFyZVZhcmlhYmxlcyhwLG0seSl9XG4gICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG8pfVxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgJHtnKCl9O1xuICAgICAgICBsZXQgdmFsdWUgPSAke3AuZ2V0QnlJbmRpY2VzKFwiZGF0YUluZGljZXNcIil9O1xuICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9fSksZ2V0U2hhZGVyU291cmNlOnZ9fSxWcz1lPT5pZSh7YXhpczplLmF4aXN9KSxVcz0oZSx0KT0+e2xldCByPWUuaW5wdXRzO3VjKHIpLGUuY29tcHV0ZShsYyhlLmlucHV0cyx0KSl9fSk7dmFyIGRjLGNjLEZzLExzLEhzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtkYz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxjYz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxhPWVbMF0uZGF0YVR5cGUsbj1yLmxlbmd0aCxzPXouY29tcHV0ZVN0cmlkZXMociksdT16LnNpemUociksbD1lWzFdLmRpbXMsbz1lWzFdLmRhdGFUeXBlLHA9ei5zaXplKGwpLG09ei5ub3JtYWxpemVBeGlzKHQuYXhpcyxuKSx5PXJbbV0sZz1sLnNsaWNlKDApLHY9ei5zaXplKGcpLCQ9RihcImlucHV0XCIsYSxyKSxiPUYoXCJpbmRpY2VzXCIsbyxbcF0pLFM9WChcIm91dHB1dFwiLGEsZyksST1UPT5gXG4gICAgICBjb25zdCBpbnB1dFN0cmlkZXMgPSBhcnJheTx1MzIsICR7cy5sZW5ndGh9Pigke3MubWFwKEI9PmAke0J9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAke1QuZGVjbGFyZVZhcmlhYmxlcygkLGIsUyl9XG4gICAgICAke1QubWFpblN0YXJ0KCl9XG4gICAgICAke1QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh2KX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgIHZhciBpZHggPSAke2IuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgIGlkeCA9IGlkeCArICR7eX07XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNPZmZzZXQgPSB1MzIoMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICBpZiAoaSA9PSAke219KSB7XG4gICAgICAgICAgc3JjT2Zmc2V0ICs9ICB1MzIoaWR4KSAqIGlucHV0U3RyaWRlc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcmNPZmZzZXQgKz0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCJpXCIpfSAqIGlucHV0U3RyaWRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgbmV2ZXIgaGl0IHRoaXMgd2l0aCB2YWxpZCB2YWx1ZXMgaW4gaW5kaWNlc1xuICAgICAgLy8gVGhpcyBpcyBhIGd1YXJkIGFnYWluc3QgbWFsaWNpb3VzIGRhdGEgaW4gdGhlIGluZGljZXMgaW5wdXRcbiAgICAgIGlmIChzcmNPZmZzZXQgPCAwIHx8IHNyY09mZnNldCA+PSAke3V9KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbc3JjT2Zmc2V0XTtcbiAgfWA7cmV0dXJue25hbWU6XCJHYXRoZXJFbGVtZW50c1wiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwodi82NCl9fSksZ2V0U2hhZGVyU291cmNlOkl9fSxGcz1lPT5pZSh7YXhpczplLmF4aXN9KSxMcz0oZSx0KT0+e2xldCByPWUuaW5wdXRzO2RjKHIpLGUuY29tcHV0ZShjYyhlLmlucHV0cyx0KSl9fSk7dmFyIHBjLGZjLG1jLGpzLHFzLEtzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtwYz1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0sZmM9KGUsdCxyKT0+e2lmKHIubGVuZ3RoPT09MClyZXR1cm5cIjB1XCI7bGV0IGE9ci5sZW5ndGg9PT0xJiZlIT09MXx8ci5sZW5ndGg9PT0yJiZyWzBdIT09ZSxuPXJbci5sZW5ndGgtMV0hPT10LHM9XCIwdVwiO3JldHVybiBhfHwocys9YCsgbSAqICR7cltyLmxlbmd0aC0xXX11YCksbnx8KHMrPVwiK25cIiksc30sbWM9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKSxhPWVbMV0uZGltcy5zbGljZSgpLFtuLHMsdV09SnIuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocix0LnRyYW5zQSxhLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxsPVtuLHNdO2lmKCFsKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBvPXouc2l6ZShsKSxwPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCP3A9XCJ2YWx1ZSArPSBhW2sgKiBNICsgbV0gKiBiW24gKiBLICsga107XCI6dC50cmFuc0EmJiF0LnRyYW5zQj9wPVwidmFsdWUgKz0gYVtrICogTSArIG1dICogYltrICogTiArIG5dO1wiOiF0LnRyYW5zQSYmdC50cmFuc0I/cD1cInZhbHVlICs9IGFbbSAqIEsgKyBrXSAqIGJbbiAqIEsgKyBrXTtcIjohdC50cmFuc0EmJiF0LnRyYW5zQiYmKHA9XCJ2YWx1ZSArPSBhW20gKiBLICsga10gKiBiW2sgKiBOICsgbl07XCIpO2xldCBtPUJlKGVbMF0uZGF0YVR5cGUpLHk9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IGFscGhhO1wiLGc9ZS5sZW5ndGg9PT0zP2B2YWx1ZSArPSBiZXRhICogY1ske2ZjKG4scyxlWzJdLmRpbXMpfV07YDpcIlwiLHY9W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGEgOiBhcnJheTwke219PjtgLGBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGIgOiBhcnJheTwke219PjtgXTtlLmxlbmd0aD09PTMmJnYucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBjIDogYXJyYXk8JHttfT47YCk7bGV0ICQ9Yj0+YFxuICBjb25zdCBNOiB1MzIgPSAke259dTtcbiAgY29uc3QgTjogdTMyID0gJHtzfXU7XG4gIGNvbnN0IEs6IHUzMiA9ICR7dX11O1xuICBjb25zdCBhbHBoYSA9ICR7bX0oJHt0LmFscGhhfSk7XG4gIGNvbnN0IGJldGEgPSAke219KCR7dC5iZXRhfSk7XG5cbiAgJHt2LmpvaW4oYFxuYCl9XG4gIEBncm91cCgwKSBAYmluZGluZygke2UubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7bX0+O1xuXG4gICR7Yi5tYWluU3RhcnQoKX1cbiAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkLnggLyBOO1xuICAgIGxldCBuID0gZ2xvYmFsX2lkLnggJSBOO1xuXG4gICAgdmFyIHZhbHVlID0gJHttfSgwKTtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazwke3V9dTsgaysrKSB7XG4gICAgICAke3B9XG4gICAgfVxuXG4gICAgJHt5fVxuICAgICR7Z31cbiAgICBvdXRwdXRbZ2xvYmFsX2lkLnhdID0gdmFsdWU7XG5cbiAgfWA7cmV0dXJue25hbWU6XCJHZW1tXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6JH19LGpzPShlLHQpPT57cGMoZS5pbnB1dHMpLGUuY29tcHV0ZShtYyhlLmlucHV0cyx0KSl9LHFzPWU9PmllKGUpfSk7dmFyIGhjLGdjLHljLGJjLFlzLFhzLEpzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7a2UoKTt2ZSgpO2hjPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCJ9LGdjPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9cixuPTIscz16LnNpemVUb0RpbWVuc2lvbihyLG4pLHU9ei5zaXplRnJvbURpbWVuc2lvbihyLG4pLGw9clsxXSxvPUYoXCJ4XCIsZVswXS5kYXRhVHlwZSxbclswXSxyWzFdLHVdKSxwPUYoXCJzY2FsZVwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxtPUYoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMpLHk9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsW3JbMF0sclsxXSx1XSksZz1bbyxwLG0seV0sdj1vLnR5cGUudmFsdWUsJD02NCxiPVM9PmBcblxuICBjb25zdCBDOiB1MzIgPSAke2x9O1xuICBjb25zdCBub3JtU2l6ZTogdTMyID0gJHt1fTtcbiAgY29uc3QgZXBzaWxvbjogZjMyID0gJHt0LmVwc2lsb259O1xuICB2YXI8d29ya2dyb3VwPiBtZWFuU2hhcmVkIDogJHt2fTtcbiAgdmFyPHdvcmtncm91cD4gc3F1YXJlZE5vcm1TaGFyZWQgOiAke3Z9O1xuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBTaGFyZWQgOiBhcnJheTwke3Z9LCAkeyR9PjtcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9ICR7JH11O1xuICAke1MuZGVjbGFyZVZhcmlhYmxlcyguLi5nKX1cbiAgJHtTLm1haW5TdGFydCgkKX1cbiAgICBsZXQgbm9ybSA9IGdsb2JhbF9pZHggLyB3b3JrZ3JvdXBTaXplO1xuICAgIGxldCBiYXRjaCA9IG5vcm0gLyBDO1xuICAgIGxldCBjaGFubmVsID0gbm9ybSAlIEM7XG4gICAgbGV0IGxvY2FsSW5kZXggPSBsb2NhbF9pZC54O1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIGluaXRpYWw6ICR7dn0gPSAwO1xuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgbm9ybVNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xuICAgICAgaW5pdGlhbCA9IGluaXRpYWwgKyAke28uZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSBpbml0aWFsO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWVhbiBvZiBjdXJyZW50IGNoYW5uZWwgZGF0YS5cbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cFNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxJbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSArIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4ICsgY3VyclNpemVdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBpZiAobG9jYWxJbmRleCA9PSAwKSB7XG4gICAgICBtZWFuU2hhcmVkID0gd29ya2dyb3VwU2hhcmVkWzBdIC8gJHt2fShub3JtU2l6ZSk7XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIC8vIHJlaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5LlxuICAgIGluaXRpYWwgPSAwO1xuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgbm9ybVNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xuICAgICAgbGV0IGRldmlhdGlvbiA9ICAke28uZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9IC0gbWVhblNoYXJlZDtcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsICsgZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSBpbml0aWFsO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3VtIG9mIHNxdWFyZSBvZiBkZXZpYXRpb24gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xuICAgICAgc3F1YXJlZE5vcm1TaGFyZWQgPSB3b3JrZ3JvdXBTaGFyZWRbMF07XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGxldCBpbnZTdGREZXYgPSAxIC8gc3FydChzcXVhcmVkTm9ybVNoYXJlZCAvICR7dn0obm9ybVNpemUpICsgZXBzaWxvbik7XG4gICAgbGV0IGNoYW5uZWxTY2FsZSA9IGludlN0ZERldiAqICR7cC5nZXRCeU9mZnNldChcImNoYW5uZWxcIil9O1xuICAgIGxldCBjaGFubmVsU2hpZnQgPSAke20uZ2V0QnlPZmZzZXQoXCJjaGFubmVsXCIpfSAtIG1lYW5TaGFyZWQgKiBjaGFubmVsU2NhbGU7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCBub3JtU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke28uZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9ICogY2hhbm5lbFNjYWxlICsgY2hhbm5lbFNoaWZ0O1xuICAgICAgJHt5LnNldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9YDtyZXR1cm57Li4uaGMsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnN9fSksZ2V0U2hhZGVyU291cmNlOmJ9fSx5Yz0oZSx0LHIsYSxuLHMsdSxsKT0+e2xldCBvPW10KHUpLHA9RihcImlucHV0XCIsdC5kYXRhVHlwZSx0LmRpbXMsbyksbT1GKFwic2NhbGVcIixyLmRhdGFUeXBlLHIuZGltcyxvKSx5PUYoXCJiaWFzXCIsYS5kYXRhVHlwZSxhLmRpbXMsbyksZz02NCx2PW89PT0xP1widmVjMmZcIjpgbWF0Mngke299ZmAsJD1vPT09MT9cImYzMlwiOmB2ZWMke299ZmAsYj0oRCxSKT0+YCR7dn0oJHtEfSwgJHtSfSlgLFM9bip1L28sST1NYXRoLmNlaWwocy9nKSxUPUQ9PmBcbiAgY29uc3QgSDogdTMyID0gJHtzfTtcbiAgY29uc3QgQzogdTMyID0gJHt1L299O1xuICBjb25zdCBpbWFnZVNpemU6IHUzMiA9ICR7cyp1L299O1xuXG4gICR7RC5kZWNsYXJlVmFyaWFibGVzKHApfVxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7dn0+O1xuXG4gICR7RC5tYWluU3RhcnQoZyl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAke2d9IC8gQztcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSAoZ2xvYmFsX2lkeCAvICR7Z30pICUgQztcbiAgICBsZXQgd2dJZCA9IGdsb2JhbF9pZHggJSAke2d9O1xuICAgIGxldCB3Z09mZnNldCA9IHdnSWQgKiAke0l9O1xuICAgIGlmICh3Z09mZnNldCA+PSBIKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHdnTWF4ID0gbWluKHdnT2Zmc2V0ICsgJHtJfSwgSCk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogaW1hZ2VTaXplICsgY3VycmVudENoYW5uZWxOdW1iZXI7XG4gICAgdmFyIHN1bSA9ICR7UWUoXCJmMzJcIixvKX07XG4gICAgdmFyIHNxdWFyZWRTdW0gPSAke1FlKFwiZjMyXCIsbyl9O1xuICAgIGZvciAodmFyIGk6IHUzMiA9IHdnT2Zmc2V0OyBpIDwgd2dNYXg7IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSAkeyR9KGlucHV0W29mZnNldCArIGkgKiBDXSk7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgc3F1YXJlZFN1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2IoXCJzdW1cIixcInNxdWFyZWRTdW1cIil9O1xuICB9YCxCPWUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVNZWFuXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6SlNPTi5zdHJpbmdpZnkoe2NvbXBvbmVudHM6byxuLGg6cyxjOnV9KX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpbbix1LGcsMl0sZGF0YVR5cGU6MX1dLGRpc3BhdGNoR3JvdXA6e3g6bip1L299fSksZ2V0U2hhZGVyU291cmNlOlR9LHtpbnB1dHM6W3RdLG91dHB1dHM6Wy0xXX0pWzBdLFA9RD0+YFxuICBjb25zdCBIOiB1MzIgPSAke3N9O1xuICBjb25zdCBDOiB1MzIgPSAke3Uvb307XG4gIGNvbnN0IGltYWdlU2l6ZTogdTMyID0gJHtnKnUvb307XG4gIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7bH07XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7dn0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlIDogYXJyYXk8JHttLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJpYXMgOiBhcnJheTwke3kudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHt2fT47XG5cbiAgJHtELm1haW5TdGFydCgpfVxuICAgICR7RC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFMpfVxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gQztcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSBnbG9iYWxfaWR4ICUgQztcblxuICAgIGxldCBvZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiBpbWFnZVNpemU7XG4gICAgdmFyIHN1bSA9ICR7UWUoXCJmMzJcIixvKX07XG4gICAgdmFyIHNxdWFyZWRTdW0gPSAke1FlKFwiZjMyXCIsbyl9O1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2d9OyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRbb2Zmc2V0ICsgaSArIGN1cnJlbnRDaGFubmVsTnVtYmVyICogJHtnfV07XG4gICAgICAgIHN1bSArPSB2YWx1ZVswXTtcbiAgICAgICAgc3F1YXJlZFN1bSArPSB2YWx1ZVsxXTtcbiAgICB9XG4gICAgc3VtID0gc3VtIC8gZjMyKEgpO1xuICAgIHNxdWFyZWRTdW0gPSBzcXVhcmVkU3VtIC8gZjMyKEgpO1xuICAgIGxldCBpbnZTdGREZXYgPSAxIC8gc3FydChzcXVhcmVkU3VtIC0gc3VtICogc3VtICsgZXBzaWxvbik7XG4gICAgbGV0IGNoYW5uZWxTY2FsZSA9IGludlN0ZERldiAqICR7JH0oc2NhbGVbY3VycmVudENoYW5uZWxOdW1iZXJdKTtcbiAgICBsZXQgY2hhbm5lbFNoaWZ0ID0gJHskfShiaWFzW2N1cnJlbnRDaGFubmVsTnVtYmVyXSkgLSBzdW0gKiBjaGFubmVsU2NhbGU7XG5cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2IoXCJjaGFubmVsU2NhbGVcIixcImNoYW5uZWxTaGlmdFwiKX07XG4gIH1gO3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlQ2hhbm5lbFNjYWxlU2hpZnRcIixzaGFkZXJDYWNoZTp7aGludDpKU09OLnN0cmluZ2lmeSh7Y29tcG9uZW50czpvLG4saDpzLGM6dSxlcHNpbG9uOmx9KX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpbbix1LDJdLGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChTLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6UH0se2lucHV0czpbQixyLGFdLG91dHB1dHM6Wy0xXX0pWzBdfSxiYz0oZSx0LHIpPT57bGV0IGE9dFswXS5kaW1zLG49YSxzPWFbMF0sdT1hW2EubGVuZ3RoLTFdLGw9ei5zaXplRnJvbURpbWVuc2lvbihhLDEpL3Usbz1tdCh1KSxwPXouc2l6ZShuKS9vLG09RihcImlucHV0XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsbykseT1YKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxuLG8pLGc9QmUodFswXS5kYXRhVHlwZSksdj1vPT09MT9cInZlYzJmXCI6YG1hdDJ4JHtvfWZgLCQ9bz09PTE/ZzpgdmVjJHtvfTwke2d9PmAsYj15YyhlLHRbMF0sdFsxXSx0WzJdLHMsbCx1LHIuZXBzaWxvbiksUz1JPT5gXG4gIGNvbnN0IEg6IHUzMiA9ICR7bH07XG4gIGNvbnN0IEM6IHUzMiA9ICR7dS9vfTtcblxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHttLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlSW5wdXQgOiBhcnJheTwke3Z9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3kudHlwZS5zdG9yYWdlfT47XG5cbiAgJHtJLm1haW5TdGFydCgpfVxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gKEMgKiBIKTtcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSBnbG9iYWxfaWR4ICUgQztcblxuICAgIGxldCBzY2FsZU9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIEMgKyBjdXJyZW50Q2hhbm5lbE51bWJlcjtcbiAgICBsZXQgc2NhbGUgPSBzY2FsZUlucHV0W3NjYWxlT2Zmc2V0XTtcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7JH0oc2NhbGVbMF0pLCAkeyR9KHNjYWxlWzFdKSk7XG4gIH1gO2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3IuY2FjaGVLZXl9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6U30se2lucHV0czpbdFswXSxiXX0pfSxZcz1lPT5pZSh7ZXBzaWxvbjplLmVwc2lsb24sZm9ybWF0OmUuZm9ybWF0fSksWHM9KGUsdCk9Pnt0LmZvcm1hdD09PVwiTkhXQ1wiP2JjKGUsZS5pbnB1dHMsdCk6ZS5jb21wdXRlKGdjKGUuaW5wdXRzLHQpKX19KTt2YXIgd2MsdmMsUXMsWnMsZXU9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtrZSgpO3ZlKCk7d2M9ZT0+e2lmKCFlfHxlLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy5cIil9LHZjPShlLHQscik9PntsZXQgYT1lWzBdLmRpbXMsbj1lWzFdLHM9ZVsyXSx1PWEsbD16Lm5vcm1hbGl6ZUF4aXModC5heGlzLGEubGVuZ3RoKSxvPXouc2l6ZVRvRGltZW5zaW9uKGEsbCkscD16LnNpemVGcm9tRGltZW5zaW9uKGEsbCksbT16LnNpemUobi5kaW1zKSx5PXM/ei5zaXplKHMuZGltcyk6MDtpZihtIT09cHx8cyYmeSE9PXApdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHtwfS5cbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7bX0gYW5kIGJpYXMgc2l6ZSBvZiAke3l9YCk7bGV0IGc9W107Zm9yKGxldCBQPTA7UDxhLmxlbmd0aDsrK1ApUDxsP2cucHVzaChhW1BdKTpnLnB1c2goMSk7bGV0IHY9bXQocCksJD1CZShlWzBdLmRhdGFUeXBlKSxiPVtGKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHYpLEYoXCJzY2FsZVwiLG4uZGF0YVR5cGUsbi5kaW1zLHYpXTtzJiZiLnB1c2goRihcImJpYXNcIixzLmRhdGFUeXBlLHMuZGltcyx2KSksYi5wdXNoKFgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHUsdikpO2xldCBTPXI+MSxJPXI+MjtTJiZiLnB1c2goWChcIm1lYW5EYXRhT3V0cHV0XCIsMSxnKSksSSYmYi5wdXNoKFgoXCJpbnZTdGRPdXRwdXRcIiwxLGcpKTtsZXQgVD1QPT5gXG4gIGNvbnN0IG5vcm1TaXplOiBmMzIgPSAke3B9O1xuICBjb25zdCBub3JtU2l6ZVZlY3Rvcml6ZWQ6IHUzMiA9ICR7cC92fTtcbiAgY29uc3QgZXBzaWxvbjogZjMyID0gJHt0LmVwc2lsb259O1xuXG4gICR7UC5kZWNsYXJlVmFyaWFibGVzKC4uLmIpfVxuICAke1AubWFpblN0YXJ0KCl9XG4gICAgJHtQLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobyl9XG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiBub3JtU2l6ZVZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5WZWN0b3IgPSAke1FlKFwiZjMyXCIsdil9O1xuICAgIHZhciBtZWFuU3F1YXJlVmVjdG9yID0gJHtRZShcImYzMlwiLHYpfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgbm9ybVNpemVWZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7RHQoJCx2LFwieFtoICsgb2Zmc2V0XVwiKX07XG4gICAgICBtZWFuVmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhblNxdWFyZVZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbWVhbiA9ICR7U3QoXCJtZWFuVmVjdG9yXCIsdil9IC8gbm9ybVNpemU7XG4gICAgbGV0IG1lYW5TcXVhcmUgPSBzcXJ0KCR7U3QoXCJtZWFuU3F1YXJlVmVjdG9yXCIsdil9IFxuICAgICAgLyBub3JtU2l6ZSAtIG1lYW4gKiBtZWFuICsgZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgbm9ybVNpemVWZWN0b3JpemVkOyBqKyspIHtcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7RHQoJCx2LFwieFtqICsgb2Zmc2V0XVwiKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke0R0KCQsdixcInNjYWxlW2pdXCIpfTtcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7YlswXS50eXBlLnZhbHVlfSgoZjMyaW5wdXQgLSBtZWFuKSAvIG1lYW5TcXVhcmUgKiBmMzJzY2FsZVxuICAgICAgICAke3M/YCsgJHtEdCgkLHYsXCJiaWFzW2pdXCIpfWA6XCJcIn1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgJHtTP1wibWVhbkRhdGFPdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuXCI6XCJcIn07XG4gICAgJHtJP1wiaW52U3RkT3V0cHV0W2dsb2JhbF9pZHhdID0gMSAvIG1lYW5TcXVhcmVcIjpcIlwifTtcbiAgfWAsQj1be2RpbXM6dSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIFMmJkIucHVzaCh7ZGltczpnLGRhdGFUeXBlOjF9KSxJJiZCLnB1c2goe2RpbXM6ZyxkYXRhVHlwZToxfSkse25hbWU6XCJMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke3J9fCR7ZS5sZW5ndGh9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOkIsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9fSksZ2V0U2hhZGVyU291cmNlOlR9fSxRcz1lPT5pZSh7YXhpczplLmF4aXMsZXBzaWxvbjplLmVwc2lsb259KSxacz0oZSx0KT0+e3djKGUuaW5wdXRzKSxlLmNvbXB1dGUodmMoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50KSl9fSk7dmFyICRjLHR1LHJ1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2JyKCk7JGM9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpfSx0dT1lPT57JGMoZS5pbnB1dHMpO2xldCB0PW50LmNhbGNTaGFwZShlLmlucHV0c1swXS5kaW1zLGUuaW5wdXRzWzFdLmRpbXMsITApO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7ZS5jb21wdXRlKGNuKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCIsYWN0aXZhdGlvbkNhY2hlS2V5OlwiXCJ9LHQpKX19KTt2YXIgeGMsU2MsQ2MsSWMsQWMsRWMsX2MsT2MsVGMsbnUsYXUsb3U9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtrZSgpO3ZlKCk7eGM9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIlRvbyBmZXcgaW5wdXRzXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGUgbXVzdCBiZSBmbG9hdC5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxTYz0oZSx0LHIsYSxuLHMsdSk9PntsZXQgbD1yLmxlbmd0aCxvPVwiXCI7Zm9yKGxldCBwPWwtMTtwPj0wOy0tcClvKz1gXG4gICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLHApfSkgLSAke25bcF19O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gJHtyW3BdfSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBrICogJHthW3BdfTtcbiAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgdmFsdWUgPSAke3N9KCR7dX0pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICR7b31cbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgIGB9LENjPShlLHQscixhLG4pPT57bGV0IHM9ci5sZW5ndGgsdT1cIlwiO2ZvcihsZXQgbD1zLTE7bD49MDstLWwpdSs9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbCl9KSAtICR7bltsXX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9ICR7MioocltsXS0xKX07XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSAke3JbbF19KSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogJHthW2xdfTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3V9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LEljPShlLHQscixhLG4pPT57bGV0IHM9ci5sZW5ndGgsdT1cIlwiO2ZvcihsZXQgbD1zLTE7bD49MDstLWwpdSs9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbCl9KSAtICR7bltsXX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gJHtyW2xdfSkge1xuICAgICAgICAgICAgICAgICAgayA9ICR7cltsXS0xfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke2FbbF19O1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7dX1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sQWM9KGUsdCxyLGEsbik9PntsZXQgcz1yLmxlbmd0aCx1PVwiXCI7Zm9yKGxldCBsPXMtMTtsPj0wOy0tbCl1Kz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixsKX0pIC0gJHtuW2xdfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9ICR7cltsXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49ICR7cltsXX0pIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gJHtyW2xdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke2FbbF19O1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7dX1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sRWM9KGUsdCxyLGEsbixzKT0+e3N3aXRjaChuLm1vZGUpe2Nhc2UgMDpyZXR1cm4gU2MoZSx0LHIsYSxuLnBhZHMscyxuLnZhbHVlKTtjYXNlIDE6cmV0dXJuIENjKGUsdCxyLGEsbi5wYWRzKTtjYXNlIDI6cmV0dXJuIEljKGUsdCxyLGEsbi5wYWRzKTtjYXNlIDM6cmV0dXJuIEFjKGUsdCxyLGEsbi5wYWRzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LF9jPShlLHQscixhKT0+e2xldCBuPXRbMF0uZGltcyxzPXoucGFkU2hhcGUobi5zbGljZSgpLHIucGFkcyksdT16LnNpemUocyksbD16LmNvbXB1dGVTdHJpZGVzKG4pLG89WChcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUscykscD1GKFwieFwiLHRbMF0uZGF0YVR5cGUsbiksbT1FYyhvLHMsbixsLHIsYSk7cmV0dXJuYFxuICAgICAgICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyhwLG8pfVxuICAgICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7YX0oMCk7XG4gICAgICAgICAgICAgICR7bX1cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgfWB9LE9jPShlLHQpPT57bGV0IHI9ei5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpO3JldHVybntuYW1lOlwiUGFkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh6LnNpemUocikvNjQpfX0pLGdldFNoYWRlclNvdXJjZTphPT5fYyhhLGUsdCxcImYzMlwiKX19LFRjPShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IHI9ZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksYT1lLmxlbmd0aD49MyYmZVsyXS5kYXRhP2VbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MCxuPWVbMF0uZGltcy5sZW5ndGgscz1uZXcgSW50MzJBcnJheSgyKm4pLmZpbGwoMCk7aWYoZS5sZW5ndGg+PTQpe2xldCBsPWVbM10uZ2V0QmlnSW50NjRBcnJheSgpO2ZvcihsZXQgbz0wO288bC5sZW5ndGg7bysrKXNbTnVtYmVyKGxbb10pXT1OdW1iZXIocltvXSksc1tOdW1iZXIobFtvXSkrbl09TnVtYmVyKHJbbytsLmxlbmd0aF0pfWVsc2Ugci5mb3JFYWNoKChsLG8pPT5zW051bWJlcihvKV09TnVtYmVyKGwpKTtsZXQgdT1bXTtyZXR1cm4gcy5mb3JFYWNoKGw9PnUucHVzaChsKSksaWUoe21vZGU6dC5tb2RlLHZhbHVlOmEscGFkczp1fSl9ZWxzZSByZXR1cm4gdH0sbnU9KGUsdCk9Pnt4YyhlLmlucHV0cyk7bGV0IHI9VGMoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKE9jKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9LGF1PWU9PntsZXQgdD1lLm1vZGUscj1lLnZhbHVlLGE9ZS5wYWRzO3JldHVybiBpZSh7bW9kZTp0LHZhbHVlOnIscGFkczphfSl9fSk7dmFyIGZuLGl1LHN1LHV1LGx1LGR1LGN1LHB1LGZ1LG11LGh1LGd1LHl1LGJ1LHd1LHZ1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtmbj1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgc3VwcG9ydHMgMS1EIG9yIDItRCBpbnB1dHMgb25seSBmb3Igbm93LlwiKX0saXU9KGUsdCxyKT0+e2xldCBhPXQuZm9ybWF0PT09XCJOSFdDXCIsbj1lLmRpbXMuc2xpY2UoKTthJiZuLnNwbGljZSgxLDAsbi5wb3AoKSk7bGV0IHM9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSx1PXQua2VybmVsU2hhcGUuc2xpY2UoKSxsPXQuc3RyaWRlcy5zbGljZSgpLG89cz90LmRpbGF0aW9ucy5zbGljZSgpOltdLHA9dC5wYWRzLnNsaWNlKCk7TXQuYWRqdXN0UG9vbEF0dHJpYnV0ZXMocixuLHUsbCxvLHApO2xldCBtPU10LmNvbXB1dGVQb29sT3V0cHV0U2hhcGUocixuLGwsbyx1LHAsdC5hdXRvUGFkKSx5PU9iamVjdC5hc3NpZ24oe30sdCk7cz9PYmplY3QuYXNzaWduKHkse2tlcm5lbFNoYXBlOnUsc3RyaWRlczpsLHBhZHM6cCxkaWxhdGlvbnM6byxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbih5LHtrZXJuZWxTaGFwZTp1LHN0cmlkZXM6bCxwYWRzOnAsY2FjaGVLZXk6dC5jYWNoZUtleX0pO2xldCBnPW0uc2xpY2UoKTtyZXR1cm4gZy5wdXNoKGcuc3BsaWNlKDEsMSlbMF0pLFt5LGE/ZzptXX0sc3U9KGUsdCxyLGEsbixzLHUsbCk9PntsZXQgbz1uLmZvcm1hdD09PVwiTkhXQ1wiLHA9cixtPXQudHlwZS52YWx1ZSx5PXAubGVuZ3RoLGc9ei5zaXplKGEpLHY9WChcIm91dHB1dFwiLHQudHlwZS50ZW5zb3IsYSk7aWYobi5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCAkPW4ua2VybmVsU2hhcGVbbi5rZXJuZWxTaGFwZS5sZW5ndGgtMV0sYj1uLnN0cmlkZXNbbi5zdHJpZGVzLmxlbmd0aC0xXSxTPW4ucGFkc1tuLnBhZHMubGVuZ3RoLzItMV0sST1uLnBhZHNbbi5wYWRzLmxlbmd0aC0xXSxUPXktKG8/MjoxKSxCPVwiXCIsUD1cIlwiLEQ9XCJcIjtpZihTK0khPT0wP0I9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHskfXU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtUfV0gPSBpbmRpY2VzWyR7VH1dICogJHtifSAtICR7U30gKyBpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7VH1dIDwgMCB8fCB4SW5kaWNlc1ske1R9XSA+PSAke3BbVF19KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke3N9XG4gICAgICAgICAgICAgICAgfWA6Qj1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAkeyR9dTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske1R9XSA9IGluZGljZXNbJHtUfV0gKiAke2J9IC0gJHtTfSArIGk7XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtzfVxuICAgICAgICAgICAgICAgIH1gLG4ua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IFc9bi5rZXJuZWxTaGFwZVtuLmtlcm5lbFNoYXBlLmxlbmd0aC0yXSxIPW4uc3RyaWRlc1tuLnN0cmlkZXMubGVuZ3RoLTJdLEs9bi5wYWRzW24ucGFkcy5sZW5ndGgvMi0yXSxsZT1uLnBhZHNbbi5wYWRzLmxlbmd0aC0yXSxNPXktKG8/MzoyKSxxPXBbTV07SytsZSE9PTA/UD1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCAke1d9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske019XSA9IGluZGljZXNbJHtNfV0gKiAke0h9IC0gJHtLfSArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtNfV0gPCAwIHx8IHhJbmRpY2VzWyR7TX1dID49ICR7cX0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKz0gJHskfTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA6UD1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCAke1d9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske019XSA9IGluZGljZXNbJHtNfV0gKiAke0h9IC0gJHtLfSArIGo7XG4gICAgICAgICAgICAgICAgYCxEPWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyh0LHYpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGcpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHt2Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlOiAke219ID0gJHttfSgke2x9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgICR7UH1cbiAgICAgICAgICAgICAgJHtCfVxuICAgICAgICAgICAgICAke0R9XG4gICAgICAgICAgICAgICR7dX1cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gfWVsc2V7aWYobyl0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0ICQ9ei5zaXplKG4ua2VybmVsU2hhcGUpLGI9ei5jb21wdXRlU3RyaWRlcyhuLmtlcm5lbFNoYXBlKSxTPWIubGVuZ3RoLEk9bi5wYWRzLmxlbmd0aCxUPW4ucGFkcy5yZWR1Y2UoKEQsUik9PkQrUiksQj1cIlwiO3JldHVybiBUP0I9YFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSBpbnB1dERpbXNbal0pIHtcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICR7c31cbiAgICAgICAgICAgICAgfWA6Qj1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgJHtzfVxuICAgICAgICAgICAgYCxgXG4gICAgICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyh0LHYpfVxuXG4gICAgICAgICAgICBjb25zdCBwYWRzID0gYXJyYXk8dTMyLCAke0l9Pigke24ucGFkcy5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RGltcyA9IGFycmF5PHUzMiwgJHt5fT4oJHtwLm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICAgICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IGFycmF5PHUzMiwgJHtTfT4oJHtiLm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICAgICAgY29uc3Qgc3RyaWRlcyA9IGFycmF5PHUzMiwgJHtTfT4oJHtuLnN0cmlkZXMubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZyl9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIGxldCB4SW5kaWNlcyA9ICR7di5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke1N9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke3YudHlwZS52YWx1ZX0oJHtsfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7JH11OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke1MtMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyBrZXJuZWxTdHJpZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiBrZXJuZWxTdHJpZGVzW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7Uy0xfV0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3ktU311OyBqIDwgJHt5fXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogc3RyaWRlc1tqIC0gJHt5LVN9dV1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3ktU311XSAtIHBhZHNbaiAtIDJ1XTtcbiAgICAgICAgICAgICAgICAgICR7Qn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3V9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH19LHV1PWU9Pih7Zm9ybWF0OmUuZm9ybWF0LGF1dG9QYWQ6W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxjZWlsTW9kZTplLmNlaWxfbW9kZSxrZXJuZWxTaGFwZTplLmtlcm5lbF9zaGFwZSxzdHJpZGVzOmUuc3RyaWRlcyxwYWRzOmUucGFkc30pLGx1PShlLHQscixhKT0+e2xldFtuLHNdPWl1KHQsYSxyKSx1PXouc2l6ZShuLmtlcm5lbFNoYXBlKSxsPUYoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMpLG89bC50eXBlLnZhbHVlLHA9XCJ2YWx1ZSArPSB4X3ZhbDtcIixtPVwiXCI7cmV0dXJuIG4uY291bnRJbmNsdWRlUGFkP20rPWB2YWx1ZSAvPSAke299KCR7dX0pO2A6bSs9YHZhbHVlIC89ICR7b30oJHt1fSAtIHBhZCk7YCx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmEuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoei5zaXplKHMpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6eT0+c3UoeSxsLHQuZGltcyxzLG4scCxtLFwiMC4wXCIpfX0sZHU9ZT0+e2xldCB0PWUuY291bnRfaW5jbHVkZV9wYWQhPT0wLHI9dXUoZSk7aWYoci5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtyZXR1cm4gaWUoe2NvdW50SW5jbHVkZVBhZDp0LC4uLnJ9KX0sY3U9KGUsdCk9PntmbihlLmlucHV0cyksZS5jb21wdXRlKGx1KFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LHB1PXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXSxjYWNoZUtleTpcIlwifSxmdT1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLnB1LGNhY2hlS2V5OnR9fSxtdT0oZSx0KT0+e2ZuKGUuaW5wdXRzKSxlLmNvbXB1dGUobHUoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX0saHU9KGUsdCxyLGEpPT57bGV0W24sc109aXUodCxhLHIpLHU9YFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgLGw9XCJcIixvPUYoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMpO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YS5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh6LnNpemUocykvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpwPT5zdShwLG8sdC5kaW1zLHMsbix1LGwsXCItMWU1XCIpfX0sZ3U9KGUsdCk9PntmbihlLmlucHV0cyksZS5jb21wdXRlKGh1KFwiTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0seXU9ZT0+e2xldCB0PWUuc3RvcmFnZV9vcmRlcixyPWUuZGlsYXRpb25zLGE9dXUoZSk7aWYodCE9PTApdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYoYS5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO3JldHVybiBpZSh7c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOnIsLi4uYX0pfSxidT1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLnB1LGNhY2hlS2V5OnR9fSx3dT0oZSx0KT0+e2ZuKGUuaW5wdXRzKSxlLmNvbXB1dGUoaHUoXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBQYyxrYywkdSx4dT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHQoKTtEZSgpO3ZlKCk7UGM9KGUsdCxyKT0+e2xldCBhPWU9PT10LG49ZTx0JiZyPDAscz1lPnQmJnI+MDtpZihhfHxufHxzKXRocm93IG5ldyBFcnJvcihcIlJhbmdlIHRoZXNlIGlucHV0cycgY29udGVudHMgYXJlIGludmFsaWQuXCIpfSxrYz0oZSx0LHIsYSk9PntsZXQgbj1NYXRoLmFicyhNYXRoLmNlaWwoKHQtZSkvcikpLHM9W25dLHU9bixsPVgoXCJvdXRwdXRcIixhLHMpLG89bC50eXBlLnN0b3JhZ2UscD1tPT5gXG4gICAgICAgICR7bS5kZWNsYXJlVmFyaWFibGVzKGwpfVxuICAgICAgICAke20ubWFpblN0YXJ0KCl9XG4gICAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke299KCR7ZX0pICsgJHtvfShnbG9iYWxfaWR4KSAqICR7b30oJHtyfSk7XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlJhbmdlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6W2UsdCxyXS5tYXAobT0+bS50b1N0cmluZygpKS5qb2luKFwiX1wiKX0sZ2V0U2hhZGVyU291cmNlOnAsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOmF9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh1LzY0KX19KX19LCR1PWU9PntsZXQgdD0wLHI9MCxhPTA7ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT02Pyh0PWUuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXSxhPWUuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXSk6ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT0xJiYodD1lLmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdLGE9ZS5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0pLEllLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmUGModCxyLGEpLGUuY29tcHV0ZShrYyh0LHIsYSxlLmlucHV0c1swXS5kYXRhVHlwZSkse2lucHV0czpbXX0pfX0pO3ZhciBCYyxNYyxEYyx6YyxXYyxOYyxWYyxVYyxHYyxGYyxMYyxIYyxqYyxxYyxLYyxTdSxDdSxJdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7QmM9KGUsdCk9PntpZihlLmV2ZXJ5KHI9PnI+MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmVcIil9KSksZS5sZW5ndGg+MCl7aWYodC5tb2RlPT09XCJsaW5lYXJcIil7aWYoIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgbGluZWFyIG1vZGVcIil9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSxNYz0oZSx0LHIpPT57dC5ldmVyeShuPT5uPj0wJiZuPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IGE9bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobixzKT0+YVtuXT1lW3NdKSxhfSxEYz0oZSx0LHIsYSxuLHMpPT57bGV0W3UsbCxvXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0scD1lWzBdLmRpbXMubGVuZ3RoO2lmKHU+MCYmZS5sZW5ndGg+dSYmZVt1XS5kaW1zLmxlbmd0aD4wKWVbdV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5zLnB1c2gobSkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYobD4wJiZlLmxlbmd0aD5sJiZlW2xdLmRpbXMubGVuZ3RoPjApe2lmKGVbbF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5hLnB1c2gobSkpLGEubGVuZ3RoIT09MCYmYS5sZW5ndGghPT1wJiZyPj0xOCYmYS5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7QmMoYSx0KSx0LmF4ZXMubGVuZ3RoPjAmJk1jKGEsdC5heGVzLHApLmZvckVhY2goKG0seSk9PmFbeV09bSl9aWYobz4wJiZlLmxlbmd0aD5vJiYoZVtvXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChtPT5uLnB1c2goTnVtYmVyKG0pKSksbi5sZW5ndGghPT1wfHxyPj0xOCYmbi5sZW5ndGg9PT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihhLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzaXplc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgcmFuayBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyl9aWYodHlwZW9mIGE8XCJ1XCImJnR5cGVvZiBuPFwidVwiJiZhLmxlbmd0aD4wJiZuLmxlbmd0aD5wKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBvbmx5IG9mIHNjYWxlcyBvciBzaXplcyB0byBiZSBzcGVjaWZpZWRcIil9LHpjPWU9PlwiZm4gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKHhSZXNpemVkOiBmMzIsIHhTY2FsZTogZjMyLCBsZW5ndGhSZXNpemVkOiBmMzIsICAgIGxlbmd0aE9yaWdpbmFsOiBmMzIsIHJvaVN0YXJ0OiBmMzIsIHJvaUVuZDogZjMyKSAtPiBmMzIgeyBcIisoKCk9Pntzd2l0Y2goZSl7Y2FzZVwiYXN5bW1ldHJpY1wiOnJldHVyblwicmV0dXJuIHhSZXNpemVkIC8geFNjYWxlO1wiO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVyblwiaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGUgLSAwLjU7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCI6cmV0dXJuXCJyZXR1cm4gKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZTtcIjtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuXCJpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4geFJlc2l6ZWQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSAvIChsZW5ndGhSZXNpemVkIC0gMSk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIjpyZXR1cm5cImlmIChsZW5ndGhSZXNpemVkID4gMSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb2lTdGFydCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpICsgICAgICAgICAgICAgICAgICAgICAgICAgICAoeFJlc2l6ZWQgKiAocm9pRW5kIC0gcm9pU3RhcnQpICogKGxlbmd0aE9yaWdpbmFsIC0gMSkpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKHJvaVN0YXJ0ICsgcm9pRW5kKSAqIGYzMihsZW5ndGhPcmlnaW5hbCAtIDEpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwiaGFsZl9waXhlbF9zeW1tZXRyaWNcIjpyZXR1cm5bXCJjb25zdCBvdXRwdXRXaWR0aCA9IHhTY2FsZSAqIGxlbmd0aFJlc2l6ZWQ7XCIsXCJjb25zdCBhZGp1c3RtZW50ID0gbGVuZ3RoUmVzaXplZCAvIG91dHB1dFdpZHRoO1wiLFwiY29uc3QgY2VudGVyID0gbGVuZ3RoT3JpZ2luYWwgLyAyO1wiLFwiY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcIixcInJldHVybiBvZmZzZXQgKyAoKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZSkgLSAwLjU7XCJdLmpvaW4oYFxuYCk7Y2FzZVwiaGFsZl9waXhlbFwiOnJldHVyblwicmV0dXJuICgoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlKSAtIDAuNTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLFdjPShlLHQpPT5cImZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6IGYzMiwgaXNEb3duU2FtcGxlOiBib29sKSAtPiBmMzIge1wiKygoKT0+e3N3aXRjaChlKXtjYXNlXCJyb3VuZF9wcmVmZXJfY2VpbFwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgIH1cIjtjYXNlXCJmbG9vclwiOnJldHVyblwicmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7XCI7Y2FzZVwiY2VpbFwiOnJldHVyblwicmV0dXJuIGNlaWwoeE9yaWdpbmFsKTtcIjtjYXNlXCJyb3VuZF9wcmVmZXJfZmxvb3JcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9vcih4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwic2ltcGxlXCI6ZGVmYXVsdDppZih0PDExKXJldHVyblwiaWYgKGlzRG93blNhbXBsZSkgICAgICAgICAgICAgICAgICAgICB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyAgICAgICAgICAgICAgICAgICAgIH1cIjt0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLE5jPShlLHQscik9PntsZXQgYT1uZXcgQXJyYXkocikuZmlsbCgwKS5jb25jYXQobmV3IEFycmF5KHIpLmZpbGwoMSkpLG49ZS5sZW5ndGg9PT0wP2E6ZS5zbGljZSgpO3JldHVybiB0Lmxlbmd0aD4wPyh0LmZvckVhY2goKHMsdSk9PnthW3NdPW5bdV0sYVt1K3JdPW5bdC5sZW5ndGgrdV19KSxhKTpufSxWYz0oZSx0LHIsYSk9PntsZXQgbj1bXTtpZihyLmxlbmd0aD4wKWlmKGEubGVuZ3RoPjApe2lmKGUuZm9yRWFjaChzPT5uLnB1c2gocykpLE1hdGgubWF4KC4uLmEpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMgaXMgb3V0IG9mIGJvdW5kXCIpO2EuZm9yRWFjaCgocyx1KT0+bltzXT1yW3VdKX1lbHNlIHIuZm9yRWFjaChzPT5uLnB1c2gocykpO2Vsc2V7aWYodC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLlwiKTtuPWUubWFwKChzLHUpPT5NYXRoLnJvdW5kKHMqdFt1XSkpfXJldHVybiBufSxVYz0oZSx0LHIsYSk9PntsZXQgbj0oKCk9Pntzd2l0Y2goYS5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gYS5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLmEuYXhlcy5tYXAodT0+clt1XSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4ucixOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiBhLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4uYS5heGVzLm1hcCh1PT5yW3VdKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi5yLE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHthLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7ci5maWxsKDEsMCxyLmxlbmd0aCk7bGV0IHM9ZS5zbGljZSgpO3JldHVybiBhLmF4ZXMubGVuZ3RoPjA/KGEuYXhlcy5mb3JFYWNoKHU9PnJbdV09biksYS5heGVzLmZvckVhY2godT0+c1t1XT1NYXRoLnJvdW5kKGVbdV0qclt1XSkpKTooci5maWxsKG4sMCxyLmxlbmd0aCkscy5mb3JFYWNoKCh1LGwpPT5zW2xdPU1hdGgucm91bmQodSpyW2xdKSkpLHN9LEdjPShlLHQscixhLG4pPT5gXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PGYzMiwgJHtyLmxlbmd0aH0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7dC5sZW5ndGh9Pigke3QubWFwKHM9PmAke3N9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGFycmF5PHUzMiwgJHtyLmxlbmd0aH0+KCR7ci5tYXAocz0+YCR7c311YCkuam9pbihcIixcIil9KTtcbiAgICAgIGNvbnN0IHNjYWxlcyA9IGFycmF5PGYzMiwgJHthLmxlbmd0aH0+KCR7YS5tYXAocz0+YCR7c31mYCkuam9pbihcIixcIil9KTtcbiAgICAgIGNvbnN0IHJvaSA9IGFycmF5PGYzMiwgJHtuLmxlbmd0aH0+KCR7bi5tYXAocz0+YCR7c31mYCkuam9pbihcIixcIil9KTtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXM6IGFycmF5PGYzMiwgJHtyLmxlbmd0aH0+O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke3IubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpcIm91dHB1dEluZGljZXNbaV1cIn07XG4gICAgICAgIGlmIChzY2FsZXNbaV0gPT0gMS4wKSB7XG4gICAgICAgICAgb3JpZ2luYWxJbmRpY2VzW2ldID0gZjMyKG91dHB1dEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcmlnaW5hbEluZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoZjMyKG91dHB1dEluZGV4KSwgc2NhbGVzW2ldLFxuICAgICAgICAgICAgICAgIGYzMihvdXRwdXRTaGFwZVtpXSksIGYzMihpbnB1dFNoYXBlW2ldKSwgcm9pW2ldLCByb2lbaSArICR7dC5sZW5ndGh9XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbEluZGljZXM7XG4gICAgfWAsRmM9KGUsdCxyLGEsbixzLHUpPT5gXG4gICAgZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHtyLmxlbmd0aH0+KCR7ci5tYXAobD0+YCR7bH11YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhcnJheTx1MzIsICR7YS5sZW5ndGh9Pigke2EubWFwKGw9PmAke2x9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IHNjYWxlcyA9IGFycmF5PGYzMiwgJHtuLmxlbmd0aH0+KCR7bi5tYXAobD0+YCR7bH1mYCkuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgcm9pID0gYXJyYXk8ZjMyLCAke3MubGVuZ3RofT4oJHtzLm1hcChsPT5gJHtsfWZgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHthLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7YS5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOlwib3V0cHV0SW5kaWNlc1tpXVwifTtcbiAgICAgICAgICB2YXIgaW5wdXRJbmRleDogdTMyO1xuICAgICAgICAgIGlmIChzY2FsZXNbaV0gPT0gMS4wKSB7XG4gICAgICAgICAgICBpbnB1dEluZGV4ID0gb3V0cHV0SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoZjMyKG91dHB1dEluZGV4KSwgc2NhbGVzW2ldLFxuICAgICAgICAgICAgICAgICAgICBmMzIob3V0cHV0U2hhcGVbaV0pLCBmMzIoaW5wdXRTaGFwZVtpXSksIHJvaVtpXSwgcm9pW2kgKyAke3IubGVuZ3RofV0pO1xuICAgICAgICAgICAgaWYgKCEke3V9IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCBmMzIoaW5wdXRTaGFwZVtpXSkpKSB7XG4gICAgICAgICAgICAgIGlmIChvcmlnaW5hbF9pZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxfaWR4ID4gKGYzMihpbnB1dFNoYXBlW2ldKSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IGlucHV0U2hhcGVbaV0gLSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0SW5kZXggPSB1MzIoZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKG9yaWdpbmFsX2lkeCwgc2NhbGVzW2ldIDwgMSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gdTMyKG9yaWdpbmFsX2lkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsXCJpbnB1dEluZGV4XCIpfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dEluZGljZXM7XG4gICAgfWAsTGM9KGUsdCk9PmBcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBib29sIHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7dC5sZW5ndGh9Pigke3QubWFwKHI9PmAke3J9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dEluZGV4ID0gJHt0Lmxlbmd0aD09PTE/XCJpbnB1dEluZGljZXNcIjpcImlucHV0SW5kaWNlc1tpXVwifTtcbiAgICAgICAgaWYgKGlucHV0SW5kZXggPCAwIHx8IGlucHV0SW5kZXggPj0gaW5wdXRTaGFwZVtpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWAsSGM9KGUsdCxyLGEsbixzLHUpPT57bGV0W2wsbyxwLG1dPXIubGVuZ3RoPT09Mj9bLTEsMCwxLC0xXTpuWzFdPT09MT9bMCwyLDMsMV06WzAsMSwyLDNdO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgcm93OiB1MzIsIGNvbDogdTMyKSAtPiBmMzIge1xuICAgICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICBpbnB1dEluZGljZXNbJHtvfV0gPSBtYXgoMCwgbWluKHJvdywgJHtyW29dfSAtIDEpKTtcbiAgICAgIGlucHV0SW5kaWNlc1ske3B9XSA9IG1heCgwLCBtaW4oY29sLCAke3JbcF19IC0gMSkpO1xuICAgICAgaWYgKCR7ci5sZW5ndGh9ID4gMikge1xuICAgICAgICBpbnB1dEluZGljZXNbJHttfV0gPSBjaGFubmVsO1xuICAgICAgICBpbnB1dEluZGljZXNbJHtsfV0gPSBiYXRjaDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gaW5wdXRbJHtlLmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc1wiKX1dO1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gZjMyIHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzKTtcbiAgICAgIHZhciByb3c6ZjMyID0gb3JpZ2luYWxJbmRpY2VzWyR7b31dO1xuICAgICAgdmFyIGNvbDpmMzIgPSBvcmlnaW5hbEluZGljZXNbJHtwfV07XG4gICAgICBpZiAoJHtzfSAmJiAocm93IDwgMCB8fCByb3cgPiAoJHtyW29dfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gJHtyW3BdfSAtIDEpKSB7XG4gICAgICAgIHJldHVybiAke3V9O1xuICAgICAgfVxuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7cltvXX0gLSAxKSk7XG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtyW3BdfSAtIDEpKTtcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9IDA7XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9IDA7XG4gICAgICBpZiAoJHtyLmxlbmd0aD4yfSkge1xuICAgICAgICBjaGFubmVsID0gdTMyKG9yaWdpbmFsSW5kaWNlc1ske219XSk7XG4gICAgICAgIGJhdGNoID0gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2x9XSk7XG4gICAgICB9XG4gICAgICB2YXIgeDExOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xuICAgICAgdmFyIHgyMTogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6IGYzMiA9IHJvdyAtIGYzMihyb3cxKTtcbiAgICAgIHZhciBkeDI6IGYzMiA9IGYzMihyb3cyICkgLSByb3c7XG4gICAgICB2YXIgZHkxID0gY29sIC0gZjMyKGNvbDEpO1xuICAgICAgdmFyIGR5MiA9IGYzMihjb2wyKSAtIGNvbDtcbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcbiAgICB9YH0samM9KGUsdCxyLGEsbixzLHUsbCxvLHApPT57bGV0W20seV09ci5sZW5ndGg9PT0yP1swLDFdOm5bMV09PT0xP1syLDNdOlsxLDJdLGc9dj0+e2xldCAkPXY9PT1tP1wicm93XCI6XCJjb2xcIjtyZXR1cm5gXG4gICAgICBmbiAkeyR9Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30sIG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiBmMzIge1xuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke2EubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpgb3V0cHV0SW5kaWNlc1ske3Z9XWB9O1xuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6IGYzMiA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShmMzIob3V0cHV0SW5kZXgpLCAke25bdl19LFxuICAgICAgICBmMzIoJHthW3ZdfSksIGYzMigke3Jbdl19KSwgJHtzW3ZdfSwgJHtzW3ZdfSArICR7ci5sZW5ndGh9KTtcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6IGYzMiA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcblxuICAgICAgICBpZiAoJHtsfSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7clt2XX0gLSAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gJHtvfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YTogYXJyYXk8ZjMyLCA0PiA9IGFycmF5PGYzMiwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHskfTogZjMyID0gb3JpZ2luYWxJZHggKyBmMzIoaSk7XG4gICAgICAgICAgaWYgKCR7JH0gPCAwIHx8ICR7JH0gPj0gJHtyW3ZdfSkge1xuICAgICAgICAgICAgaWYgKCR7cH0pIHtcbiAgICAgICAgICAgICAgY29lZnNbaSArIDFdID0gMC4wO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtsfSkge1xuICAgICAgICAgICAgICByZXR1cm4gJHtvfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICR7JH0gPSBtYXgoMCwgbWluKCR7JH0sICR7clt2XX0gLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnB1dEluZGljZXNDb3B5OiAke2UudHlwZS5pbmRpY2VzfSA9IGlucHV0SW5kaWNlcztcbiAgICAgICAgICBpbnB1dEluZGljZXNDb3B5WyR7dn1dID0gdTMyKCR7JH0pO1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHt2PT09bT9gaW5wdXRbJHtlLmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc0NvcHlcIil9XTtgOmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0SW5kaWNlc0NvcHksIG91dHB1dEluZGljZXMpO2B9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gfTtyZXR1cm5gXG4gICAgJHtnKG0pfTtcbiAgICAke2coeSl9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiBmMzIpIC0+IGFycmF5PGYzMiwgND4ge1xuICAgIHZhciBhYnNTID0gYWJzKHMpO1xuICAgIHZhciBjb2VmZnM6IGFycmF5PGYzMiwgND4gPSBhcnJheTxmMzIsIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogZjMyID0gMS4wIC0gYWJzUztcbiAgICB2YXIgdHdvTWludXNBYnNTOiBmMzIgPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogZjMyID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7dX0gKiBvbmVQbHVzQWJzUyAtIDUgKiAke3V9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7dX0pICogb25lUGx1c0Fic1MgLSA0ICogJHt1fTtcbiAgICBjb2VmZnNbMV0gPSAoKCR7dX0gKyAyKSAqIGFic1MgLSAoJHt1fSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcbiAgICBjb2VmZnNbMl0gPSAoKCR7dX0gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke3V9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7dX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHt1fSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHt1fSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHt1fTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5cbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8ZjMyLCA0PiwgY29lZnM6IGFycmF5PGYzMiwgND4pIC0+IGYzMiB7XG4gICAgdmFyIGNvZWZzU3VtOiBmMzIgPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XG4gIH1cblxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gZjMyIHtcbiAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSA9IG91dHB1dEluZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dEluZGljZXMsIG91dHB1dEluZGljZXMpO1xuICB9XG4gICAgYH0scWM9KGUsdCxyLGEsbixzKT0+e2xldCB1PWUuZGltcyxsPU5jKHMsdC5heGVzLHUubGVuZ3RoKSxvPVZjKHUsYSxuLHQuYXhlcykscD1hLnNsaWNlKCk7YS5sZW5ndGg9PT0wJiYocD11Lm1hcCgoUyxJKT0+Uz09PTA/MTpvW0ldL1MpLHQua2VlcEFzcGVjdFJhdGlvUG9saWN5IT09XCJzdHJldGNoXCImJihvPVVjKHUsbyxwLHQpKSk7bGV0IG09WChcIm91dHB1dFwiLGUuZGF0YVR5cGUsbykseT1GKFwiaW5wdXRcIixlLmRhdGFUeXBlLHUpLGc9ei5zaXplKG8pLHY9dS5sZW5ndGg9PT1vLmxlbmd0aCYmdS5ldmVyeSgoUyxJKT0+Uz09PW9bSV0pLCQ9dC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIsYj1TPT5gXG4gICAgICAke3pjKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpfTtcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtMYyh5LHUpfTtcbiAgICAgICAgICAgICAgJHtXYyh0Lm5lYXJlc3RNb2RlLHIpfTtcbiAgICAgICAgICAgICAgJHtGYyh5LG0sdSxvLHAsbCwkKX07XG4gICAgICAgICAgICAgIGA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke0djKG0sdSxvLHAsbCl9O1xuICAgICAgICAgICAgICAke0hjKHksbSx1LG8scCwkLHQuZXh0cmFwb2xhdGlvblZhbHVlKX07XG4gICAgICAgICAgICAgIGA7Y2FzZVwiY3ViaWNcIjpyZXR1cm5gXG4gICAgICAgICAgICAke2pjKHksbSx1LG8scCxsLHQuY3ViaWNDb2VmZkEsJCx0LmV4dHJhcG9sYXRpb25WYWx1ZSx0LmV4Y2x1ZGVPdXRzaWRlKX07XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xuICAgICAgJHtTLmRlY2xhcmVWYXJpYWJsZXMoeSxtKX1cbiAgICAgICR7Uy5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZyl9XG4gICAgICAgIGlmICgke3Z9KSB7XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHt5LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0SW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0SW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbJHt5LmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt0LmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzKTtcIjtjYXNlXCJjdWJpY1wiOnJldHVyblwib3V0cHV0W2dsb2JhbF9pZHhdID0gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xuICAgICAgICB9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlJlc2l6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7cn18JHtwLmxlbmd0aD4wP3A6XCJcIn18JHtuLmxlbmd0aD4wP246XCJcIn1gfSxnZXRTaGFkZXJTb3VyY2U6YixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGcvNjQpfX0pfX0sS2M9ZT0+e2xldCB0PWUuY3VzdG9tRGF0YUJ1ZmZlcjtyZXR1cm4gbmV3IFVpbnQzMkFycmF5KHQsdC5ieXRlT2Zmc2V0LDEpWzBdfSxTdT0oZSx0KT0+e2xldCByPVtdLGE9W10sbj1bXSxzPUtjKGUpO0RjKGUuaW5wdXRzLHQscyxyLGEsbiksZS5jb21wdXRlKHFjKGUuaW5wdXRzWzBdLHQscyxyLGEsbikse2lucHV0czpbMF19KX0sQ3U9ZT0+e2xldCB0PWUuYW50aWFsaWFzLHI9ZS5heGVzLGE9ZS5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSxuPWUuY3ViaWNDb2VmZkEscz1lLmV4Y2x1ZGVPdXRzaWRlIT09MCx1PWUuZXh0cmFwb2xhdGlvblZhbHVlLGw9ZS5rZWVwQXNwZWN0UmF0aW9Qb2xpY3ksbz1lLm1vZGUscD1lLm5lYXJlc3RNb2RlPT09XCJcIj9cInNpbXBsZVwiOmUubmVhcmVzdE1vZGU7cmV0dXJuIGllKHthbnRpYWxpYXM6dCxheGVzOnIsY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6YSxjdWJpY0NvZWZmQTpuLGV4Y2x1ZGVPdXRzaWRlOnMsZXh0cmFwb2xhdGlvblZhbHVlOnUsa2VlcEFzcGVjdFJhdGlvUG9saWN5OmwsbW9kZTpvLG5lYXJlc3RNb2RlOnB9KX19KTt2YXIgWWMsWGMsQXUsRXUsX3U9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtrZSgpO3ZlKCk7WWM9ZT0+e2lmKCFlfHxlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAzIGlucHV0cy5cIik7bGV0IHQ9ZVswXSxyPWVbMV0sYT1lWzJdO2lmKHQuZGF0YVR5cGUhPT1yLmRhdGFUeXBlfHx0LmRhdGFUeXBlIT09YS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGVcIik7aWYodC5kaW1zLmxlbmd0aCE9PTMmJnQuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgMkQgb3IgM0RcIik7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBiZSAyRCBvciAzRFwiKTtsZXQgbj10LmRpbXNbdC5kaW1zLmxlbmd0aC0xXSxzPXQuZGltc1t0LmRpbXMubGVuZ3RoLTJdO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0yXSE9PXMpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0XCIpO2lmKGEuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgYmUgMURcIik7aWYoYS5kaW1zW2EuZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihlLmxlbmd0aD4zKXtsZXQgdT1lWzNdO2lmKHUuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBiZSAxRFwiKTtpZih1LmRpbXNbdS5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9aWYoZS5sZW5ndGg+NCl7bGV0IHU9ZVs0XTtpZih1LmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgYmUgMURcIik7aWYodS5kaW1zW3UuZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfX0sWGM9KGUsdCxyLGEpPT57bGV0IG49ZVswXS5kaW1zLHM9ei5zaXplKG4pLHU9bixsPXMsbz1uLnNsaWNlKC0xKVswXSxwPWE/bi5zbGljZSgwLC0xKS5jb25jYXQoMSk6W10sbT1lLmxlbmd0aD4zLHk9ZS5sZW5ndGg+NCxnPWEmJnI+MSx2PWEmJnI+MiwkPXI+MyxiPW10KG8pLFM9W0YoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsYiksRihcInNraXBcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyxiKSxGKFwiZ2FtbWFcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxiKV07bSYmUy5wdXNoKEYoXCJiZXRhXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMsYikpLHkmJlMucHVzaChGKFwiYmlhc1wiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLGIpKSxTLnB1c2goWChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdSxiKSksZyYmUy5wdXNoKFgoXCJtZWFuT3V0cHV0XCIsMSxwKSksdiYmUy5wdXNoKFgoXCJpbnZTdGRPdXRwdXRcIiwxLHApKSwkJiZTLnB1c2goWChcImlucHV0U2tpcEJpYXNTdW1cIixlWzBdLmRhdGFUeXBlLHUsYikpO2xldCBJPUJlKGVbMF0uZGF0YVR5cGUpLFQ9UD0+YFxuICAgICAgY29uc3QgaGlkZGVuU2l6ZTogZjMyID0gJHtvfTtcbiAgICAgIGNvbnN0IGhpZGRlblNpemVWZWN0b3JpemVkOiB1MzIgPSAke28vYn07XG4gICAgICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke3QuZXBzaWxvbn07XG5cbiAgICAgICR7UC5kZWNsYXJlVmFyaWFibGVzKC4uLlMpfVxuXG4gICAgICAke1AubWFpblN0YXJ0KCl9XG4gICAgICAgICR7UC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGwvbyl9XG4gICAgICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ7XG4gICAgICAgIHZhciBzdW0gPSAke1FlKFwiZjMyXCIsYil9O1xuICAgICAgICB2YXIgc3F1YXJlU3VtID0gJHtRZShcImYzMlwiLGIpfTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IGhpZGRlblNpemVWZWN0b3JpemVkOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcFZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc1ZhbHVlID0gJHt5P1wiYmlhc1tpXVwiOlwiMC4wXCJ9O1xuICAgICAgICAgIGxldCBpbnB1dFZhbHVlID0geFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dFZhbHVlICsgc2tpcFZhbHVlICsgYmlhc1ZhbHVlO1xuICAgICAgICAgICR7JD9cImlucHV0U2tpcEJpYXNTdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcIjpcIlwifVxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xuICAgICAgICAgIGxldCBmMzJWYWx1ZSA9ICR7RHQoSSxiLFwidmFsdWVcIil9O1xuICAgICAgICAgIHN1bSArPSBmMzJWYWx1ZTtcbiAgICAgICAgICBzcXVhcmVTdW0gKz0gZjMyVmFsdWUgKiBmMzJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVhbiA9ICR7U3QoXCJzdW1cIixiKX0gLyBoaWRkZW5TaXplO1xuICAgICAgICBsZXQgdmFyaWFuY2UgPSBzcXJ0KCR7U3QoXCJzcXVhcmVTdW1cIixiKX0gLyBoaWRkZW5TaXplIC0gbWVhbiAqIG1lYW4gKyBlcHNpbG9uKTtcbiAgICAgICAgJHtnP1wibWVhbk91dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW47XCI6XCJcIn1cbiAgICAgICAgJHt2P1wiaW52U3RkT3V0cHV0W2dsb2JhbF9pZHhdID0gMS4wIC8gdmFyaWFuY2U7XCI6XCJcIn1cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IGhpZGRlblNpemVWZWN0b3JpemVkOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldIC0gJHtJfShtZWFuKSkgLyAke0l9KHZhcmlhbmNlKSAqIGdhbW1hW2ldXG4gICAgICAgICAgICsgJHttP1wiYmV0YVtpXVwiOlwiMC4wXCJ9O1xuICAgICAgICB9XG4gICAgICB9YCxCPVt7ZGltczp1LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gcj4xJiZCLnB1c2goe2RpbXM6cCxkYXRhVHlwZToxfSkscj4yJiZCLnB1c2goe2RpbXM6cCxkYXRhVHlwZToxfSkscj4zJiZCLnB1c2goe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSkse25hbWU6XCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0U2hhZGVyU291cmNlOlQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOkIsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC9vLzY0KX19KX19LEF1PShlLHQpPT57WWMoZS5pbnB1dHMpO2xldCBhPVswXTtlLm91dHB1dENvdW50PjEmJmEucHVzaCgtMyksZS5vdXRwdXRDb3VudD4yJiZhLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MyYmYS5wdXNoKDMpLGUuY29tcHV0ZShYYyhlLmlucHV0cyx0LGUub3V0cHV0Q291bnQsITEpLHtvdXRwdXRzOmF9KX0sRXU9ZT0+e2xldCB0PWUuZXBzaWxvbjtyZXR1cm4gaWUoe2Vwc2lsb246dH0pfX0pO3ZhciBKYyxtbixRYyxPdSxaYyxlcCxUdSxSdSxQdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO2tlKCk7dmUoKTtKYz0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChyLGEpPT57aWYoZVthKzFdLmRhdGFUeXBlIT09NiYmZVthKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7YX0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LG1uPShlLHQpPT57bGV0IHI9W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKGE9PnIucHVzaChOdW1iZXIoYSkpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2goYT0+ci5wdXNoKE51bWJlcihhKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gcn0sUWM9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1tbihlLDEpLGE9bW4oZSwyKSxuPW1uKGUsMyk7cmV0dXJuIG4ubGVuZ3RoPT09MCYmKG49Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLGllKHtzdGFydHM6cixlbmRzOmEsYXhlczpufSl9ZWxzZSByZXR1cm4gdH0sT3U9KGUsdCxyLGEsbik9PntsZXQgcz1lO3JldHVybiBlPDAmJihzKz1yW2FbdF1dKSxuW3RdPDA/TWF0aC5tYXgoMCxNYXRoLm1pbihzLHJbYVt0XV0tMSkpOk1hdGgubWF4KDAsTWF0aC5taW4ocyxyW2FbdF1dKSl9LFpjPShlLHQscixhKT0+YGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke3IubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7YS5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOlwib3V0cHV0SW5kaWNlc1tpXVwifTtcbiAgICAgICAgICAgIHZhciBpbnB1dEluZGV4ID0gb3V0cHV0SW5kZXggKiBzdGVwc1tpXSArIHN0YXJ0c1tpXSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dEluZGV4IC8gaW5wdXRTaGFwZVtpXTtcbiAgICAgICAgICAgIGlucHV0SW5kZXggPSBpbnB1dEluZGV4ICUgaW5wdXRTaGFwZVtpXTtcbiAgICAgICAgICAgIGlmIChzaWduc1tpXSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IGlucHV0U2hhcGVbaV0gLSBpbnB1dEluZGV4IC0gMXUgKyBzdGFydHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke3IubGVuZ3RoPT09MT9cImlucHV0SW5kaWNlc1wiOlwiaW5wdXRJbmRpY2VzW2ldXCJ9ID0gaW5wdXRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0SW5kaWNlcztcbiAgICAgIH1gLGVwPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9ei5zaXplKHIpLG49dC5heGVzLmxlbmd0aD4wP3oubm9ybWFsaXplQXhlcyh0LmF4ZXMsci5sZW5ndGgpOlsuLi5BcnJheShyLmxlbmd0aCkua2V5cygpXSxzPW1uKGUsNCk7cy5mb3JFYWNoKGI9PmIhPT0wfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJzdGVwIGNhbm5vdCBiZSAwXCIpfSkpLHMubGVuZ3RoPT09MCYmKHM9QXJyYXkobi5sZW5ndGgpLmZpbGwoMSkpO2xldCB1PXQuc3RhcnRzLm1hcCgoYixTKT0+T3UoYixTLHIsbixzKSksbD10LmVuZHMubWFwKChiLFMpPT5PdShiLFMscixuLHMpKTtpZihuLmxlbmd0aCE9PXIubGVuZ3RoKWZvcihsZXQgYj0wO2I8ci5sZW5ndGg7KytiKW4uaW5jbHVkZXMoYil8fCh1LnNwbGljZShiLDAsMCksbC5zcGxpY2UoYiwwLHJbYl0pLHMuc3BsaWNlKGIsMCwxKSk7bGV0IG89cy5tYXAoYj0+TWF0aC5zaWduKGIpKTtzLmZvckVhY2goKGIsUyxJKT0+e2lmKGI8MCl7bGV0IFQ9KGxbU10tdVtTXSkvYixCPXVbU10sUD1CK1Qqc1tTXTt1W1NdPVAsbFtTXT1CLElbU109LWJ9fSk7bGV0IHA9ci5zbGljZSgwKTtuLmZvckVhY2goKGIsUyk9PntwW2JdPU1hdGguY2VpbCgobFtiXS11W2JdKS9zW2JdKX0pO2xldCBtPXtkaW1zOnAsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0seT1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxwKSxnPUYoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsciksdj16LnNpemUocCksJD1iPT5gXG4gICAgICAke2IuZGVjbGFyZVZhcmlhYmxlcyhnLHkpfVxuICAgICAgICBjb25zdCBzaWducyA9IGFycmF5PGkzMiwgJHtvLmxlbmd0aH0+KCR7by5tYXAoUz0+YCR7U31pYCkuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgc3RhcnRzID0gYXJyYXk8dTMyLCAke3UubGVuZ3RofT4oJHt1Lm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBlbmRzID0gYXJyYXk8dTMyLCAke2wubGVuZ3RofT4oJHtsLm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBzdGVwcyA9IGFycmF5PHUzMiwgJHtzLmxlbmd0aH0+KCR7cy5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHtyLmxlbmd0aH0+KCR7ci5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcblxuICAgICAgICAke1pjKGcseSxyLHApfVxuICAgICAgICAke2IubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModil9XG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgbGV0IGlucHV0SW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzKTtcbiAgICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZy5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIikpfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJTbGljZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7ZVs0XT8uZGltcz8/XCJcIn1gfSxnZXRTaGFkZXJTb3VyY2U6JCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W21dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfX0pfX0sVHU9KGUsdCk9PntKYyhlLmlucHV0cyx0KTtsZXQgcj1RYyhlLmlucHV0cyx0KTtlLmNvbXB1dGUoZXAoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sUnU9ZT0+e2xldCB0PWUuc3RhcnRzLHI9ZS5lbmRzLGE9ZS5heGVzO3JldHVybiBpZSh7c3RhcnRzOnQsZW5kczpyLGF4ZXM6YX0pfX0pO3ZhciB0cCxycCxrdSxCdSxNdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7dHA9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LlwiKX0scnA9KGUsdCk9PntsZXQgcj1CZShlLmRhdGFUeXBlKSxhPWUuZGltcyxuPXouc2l6ZShhKSxzPTY0LHU9dC5heGlzO2lmKHU8MCYmKHU9YS5sZW5ndGgrdSksdTxhLmxlbmd0aC0xKXRocm93IG5ldyBFcnJvcihcInNvZnRtYXggb25seSBzdXBwb3J0cyBsYXN0IGF4aXMgZm9yIG5vdy5cIik7bGV0IGw9YVt1XSxvPW4vbCxwPW10KGwpLG09bC9wLHk9cD09PTE/cjpgdmVjJHtwfTwke3J9PmAsZz0oYixTKT0+Uz09PTQ/YG1heChtYXgoJHtifS54LCAke2J9LnkpLCBtYXgoJHtifS56LCAke2J9LncpKWA6Uz09PTI/YG1heCgke2J9LngsICR7Yn0ueSlgOlM9PT0zP2BtYXgobWF4KCR7Yn0ueCwgJHtifS55KSwgJHtifS56KWA6Yix2PXI9PT1cImYzMlwiP2B2YXIgdGhyZWFkTWF4ID0gJHt5fSgtMy40MDI4MjNlKzM4Zik7YDpgdmFyIHRocmVhZE1heCA9ICR7eX0oLTY1NTA0LjBoKTtgO3JldHVybntuYW1lOlwiU29mdG1heFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpvfX0pLGdldFNoYWRlclNvdXJjZTpiPT5gXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke3l9O1xuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHt5fTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7eX0sICR7c30+O1xuXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHggOiBhcnJheTwke3l9PjtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0IDogYXJyYXk8JHt5fT47XG5cbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke3l9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7eX0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtzfSwgMSwgMSlcbiAgICAgIGZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzdSkge1xuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZC54KTtcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZC54KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke3N9O1xuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XG4gICAgICAgIGxldCBjb2xzID0gJHttfTtcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSAke219O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XG4gICAgICAgICR7dn1cbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHt5fSgke2coXCJ0aHJlYWRTaGFyZWRbMF1cIixwKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHt5fSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt5fSgke1N0KFwidGhyZWFkU2hhcmVkWzBdXCIscCl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHJvd1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpIC8gcm93U3VtU2hhcmVkO1xuICAgICAgICAgIHNldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1gfX0sa3U9KGUsdCk9Pnt0cChlLmlucHV0cyksZS5jb21wdXRlKHJwKGUuaW5wdXRzWzBdLHQpKX0sQnU9ZT0+aWUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgbnAsYXAsb3AsaXAsc3AsRHUsenUsV3U9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO25wPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sYXA9KGUsdCk9PntsZXQgcj1bXSxhPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKSxhPXIubGVuZ3RoKSxpZSh7bnVtT3V0cHV0czphLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6cn0pfSxvcD1lPT5gXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbn1gLGlwPWU9PntsZXQgdD1lLmxlbmd0aCxyPVtdO2ZvcihsZXQgYT0wO2E8dDsrK2Epe2xldCBuPWVbYV0uc2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiLFwiaW5wdXRbZ2xvYmFsX2lkeF1cIik7dD09PTE/ci5wdXNoKG4pOmE9PT0wP3IucHVzaChgaWYgKG91dHB1dE51bWJlciA9PSAke2F9dSkgeyAke259IH1gKTphPT09dC0xP3IucHVzaChgZWxzZSB7ICR7bn0gfWApOnIucHVzaChgZWxzZSBpZiAob3V0cHV0TnVtYmVyID09ICR7YX0pIHsgJHtufSB9YCl9cmV0dXJuYFxuICAgICAgZm4gd3JpdGVCdWZmZXJEYXRhKG91dHB1dE51bWJlcjogdTMyLCBpbmRpY2VzOiAke2VbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7ci5qb2luKGBcbmApfVxuICAgICAgfWB9LHNwPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9ei5zaXplKHIpLG49ZVswXS5kYXRhVHlwZSxzPXIubGVuZ3RoLHU9dC5heGlzLGw9dTwwP3IubGVuZ3RoK3U6dSxvPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLHA9RihcImlucHV0XCIsbixyKSxtPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLHk9W10sZz1bXSx2PTA7Zm9yKGxldCBTPTA7Uzx0Lm51bU91dHB1dHM7UysrKXt2Kz10LnNwbGl0U2l6ZXNbU10sbVtTXT12O2xldCBJPXIuc2xpY2UoKTtJW3QuYXhpc109dC5zcGxpdFNpemVzW1NdLGcucHVzaChJKSxvW1NdPVgoYG91dHB1dCR7U31gLG4sZ1tTXSkseS5wdXNoKHtkaW1zOmdbU10sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pfWxldCAkPXM8Mj9cImluZGljZXNcIjpgaW5kaWNlc1ske2x9XWAsYj1TPT5gXG4gICR7Uy5kZWNsYXJlVmFyaWFibGVzKHAsLi4ubyl9XG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7bS5sZW5ndGh9Pigke20ubWFwKEk9PmAke0l9dWApLmpvaW4oXCIsXCIpfSk7XG4gICR7b3AobS5sZW5ndGgpfVxuICAke2lwKG8pfVxuXG4gICR7Uy5tYWluU3RhcnQoKX1cbiAgICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhhKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtwLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBvdXRwdXROdW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleCgkeyR9KTtcbiAgICBpZiAob3V0cHV0TnVtYmVyICE9IDApIHtcbiAgICAgICAgJHskfSAtPSBzaXplSW5Db25jYXRBeGlzW291dHB1dE51bWJlciAtIDF1XTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dE51bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XG4gIH1gO3JldHVybntuYW1lOlwiU3BsaXRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRTaGFkZXJTb3VyY2U6YixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6eSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX19KX19LER1PShlLHQpPT57bnAoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDphcChlLmlucHV0cyx0KTtlLmNvbXB1dGUoc3AoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0senU9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxhPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihhIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiBpZSh7YXhpczp0LG51bU91dHB1dHM6YSxzcGxpdFNpemVzOnJ9KX19KTt2YXIgTnUsdXAsbHAsZHAsVnUsVXU9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTt2ZSgpO051PWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSx1cD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTYmJmVbMF0uZGF0YVR5cGUhPT0xMil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlc1wiKTtpZihlWzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLURcIik7aWYoTnUoZVsxXSkubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yXCIpfSxscD0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7KythKXIucHVzaChlW2FdKnRbYV0pO3JldHVybiByfSxkcD1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9TnUoZVsxXSksYT1scCh0LHIpLG49ei5zaXplKGEpLHM9ZVswXS5kYXRhVHlwZSx1PUYoXCJpbnB1dFwiLHMsdCksbD1YKFwib3V0cHV0XCIscyxhKSxvPXA9PmBcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke3UuaW5kaWNlcyguLi50KX07XG4gICAgICAke3AuZGVjbGFyZVZhcmlhYmxlcyh1LGwpfVxuICAgICAgJHtwLm1haW5TdGFydCgpfVxuICAgICAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobil9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7bC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7dS50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIGxldCBpbnB1dERpbVZhbHVlID0gJHtsLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCJpXCIpfSAgJSAke3UuaW5kaWNlc0dldChcImlucHV0U2hhcGVcIixcImlcIil9O1xuXG4gICAgICAgICR7dS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsXCJpbnB1dERpbVZhbHVlXCIpfVxuICAgICAgfVxuICAgICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHUuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpKX1cbiAgICB9YDtyZXR1cm57bmFtZTpcIlRpbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyfWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9fSksZ2V0U2hhZGVyU291cmNlOm99fSxWdT1lPT57dXAoZS5pbnB1dHMpLGUuY29tcHV0ZShkcChlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgY3AscHAsR3UsRnU9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTt2ZSgpO2NwPShlLHQscixhLG4pPT57bGV0IHM9ei5zaXplKHIpLHU9TWF0aC5jZWlsKHMvNCksbD1YKFwib3V0cHV0RGF0YVwiLG4sciw0KSxvPUYoXCJhRGF0YVwiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLDQpLHA9RihcImJEYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMsNCksbT1GKFwiY0RhdGFcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyw0KSx5LGc9KHYsJCxiKT0+YHNlbGVjdCgkeyR9LCAke3Z9LCAke2J9KWA7aWYoIWEpeT1sLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGcoby5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikscC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksbS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCB2PSgkLGIsUz1cIlwiKT0+e2xldCBJPWBhRGF0YVtpbmRleEEke2J9XVtjb21wb25lbnRBJHtifV1gLFQ9YGJEYXRhW2luZGV4QiR7Yn1dW2NvbXBvbmVudEIke2J9XWAsQj1gYm9vbChjRGF0YVtpbmRleEMke2J9XSAmICR7NDI3ODE5MDA4MD4+PigzLWIpKjh9dSlgO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHtifSA9ICR7bC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7Yn11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke2J9ID0gJHtvLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHtifWAsbCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke2J9ID0gJHtwLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHtifWAsbCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEMke2J9ID0gJHttLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHtifWAsbCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7Yn0gPSBvZmZzZXRBJHtifSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7Yn0gPSBvZmZzZXRCJHtifSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QyR7Yn0gPSBvZmZzZXRDJHtifSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke2J9ID0gb2Zmc2V0QSR7Yn0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHtifSA9IG9mZnNldEIke2J9ICUgNHU7XG4gICAgICAgICAgICAkeyR9WyR7Yn1dID0gJHtTfSgke2coSSxULEIpfSk7XG4gICAgICAgICAgYH07bj09PTk/eT1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dihcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOnk9YFxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyhtLG8scCxsKX1cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cbiAgICAgICAgJHt5fVxuICAgICAgfWB9LHBwPWU9PntsZXQgdD1lWzFdLmRpbXMscj1lWzJdLmRpbXMsYT1lWzBdLmRpbXMsbj1lWzFdLmRhdGFUeXBlLHM9ISh6LmFyZUVxdWFsKHQscikmJnouYXJlRXF1YWwocixhKSksdT10LGw9ei5zaXplKHQpO2lmKHMpe2xldCBvPW50LmNhbGNTaGFwZShudC5jYWxjU2hhcGUodCxyLCExKSxhLCExKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO3U9byxsPXouc2l6ZSh1KX1yZXR1cm57bmFtZTpcIldoZXJlXCIsZ2V0U2hhZGVyU291cmNlOm89PmNwKG8sZSx1LHMsbiksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0LzQpfX0pfX0sR3U9ZT0+e2UuY29tcHV0ZShwcChlLmlucHV0cykpfX0pO3ZhciBMdSxIdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2koKTtBaSgpO29zKCk7Z3MoKTt3cygpO3JhKCk7UHMoKTtEcygpO05zKCk7R3MoKTtIcygpO0tzKCk7SnMoKTtldSgpO3J1KCk7b3UoKTt2dSgpO3h1KCk7ZW4oKTtJdSgpO191KCk7UHUoKTtNdSgpO1d1KCk7VXUoKTttcigpO1FuKCk7RnUoKTtMdT1uZXcgTWFwKFtbXCJBYnNcIixbRWldXSxbXCJBY29zXCIsW19pXV0sW1wiQWNvc2hcIixbT2ldXSxbXCJBZGRcIixbaXNdXSxbXCJBcmdNYXhcIixbU2ksWG5dXSxbXCJBcmdNaW5cIixbeGksWG5dXSxbXCJBc2luXCIsW1RpXV0sW1wiQXNpbmhcIixbUmldXSxbXCJBdGFuXCIsW1BpXV0sW1wiQXRhbmhcIixba2ldXSxbXCJBdmVyYWdlUG9vbFwiLFtjdSxkdV1dLFtcIkJpYXNBZGRcIixbSWldXSxbXCJCaWFzU3BsaXRHZWx1XCIsW2FzXV0sW1wiQ2FzdFwiLFtNaSxCaV1dLFtcIkNlaWxcIixbemldXSxbXCJDbGlwVjEwXCIsW0puXV0sW1wiQ2xpcFwiLFtEaV1dLFtcIkNvbmNhdFwiLFt5cyxic11dLFtcIkNvbnZcIixbYWEsbmFdXSxbXCJDb252VHJhbnNwb3NlXCIsW1JzLFRzXV0sW1wiQ29zXCIsW1dpXV0sW1wiQ29zaFwiLFtOaV1dLFtcIkRpdlwiLFtzc11dLFtcIkVpbnN1bVwiLFtCcyxNc11dLFtcIkVsdVwiLFtWaSxybl1dLFtcIkVxdWFsXCIsW3VzXV0sW1wiRXJmXCIsW1VpXV0sW1wiRXhwXCIsW0dpXV0sW1wiRXhwYW5kXCIsW1dzXV0sW1wiRmxvb3JcIixbRmldXSxbXCJGdXNlZENvbnZcIixbYWEsbmFdXSxbXCJHYXRoZXJcIixbVXMsVnNdXSxbXCJHYXRoZXJFbGVtZW50c1wiLFtMcyxGc11dLFtcIkdlbHVcIixbTGldXSxbXCJHZW1tXCIsW2pzLHFzXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbbXUsZnVdXSxbXCJHbG9iYWxNYXhQb29sXCIsW3d1LGJ1XV0sW1wiR3JlYXRlclwiLFtwc11dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW21zXV0sW1wiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsW1hzLFlzXV0sW1wiTGF5ZXJOb3JtYWxpemF0aW9uXCIsW1pzLFFzXV0sW1wiTGVha3lSZWx1XCIsW0hpLHJuXV0sW1wiTGVzc1wiLFtmc11dLFtcIkxlc3NPckVxdWFsXCIsW2hzXV0sW1wiTG9nXCIsW25zXV0sW1wiTWF0TXVsXCIsW3R1XV0sW1wiTWF4UG9vbFwiLFtndSx5dV1dLFtcIk11bFwiLFtsc11dLFtcIk5lZ1wiLFtxaV1dLFtcIk5vdFwiLFtqaV1dLFtcIlBhZFwiLFtudSxhdV1dLFtcIlBvd1wiLFtkc11dLFtcIlJhbmdlXCIsWyR1XV0sW1wiUmVjaXByb2NhbFwiLFtLaV1dLFtcIlJlZHVjZU1pblwiLFtoaSxaZV1dLFtcIlJlZHVjZU1lYW5cIixbZGksWmVdXSxbXCJSZWR1Y2VNYXhcIixbbWksWmVdXSxbXCJSZWR1Y2VTdW1cIixbeWksWmVdXSxbXCJSZWR1Y2VQcm9kXCIsW2dpLFplXV0sW1wiUmVkdWNlTDFcIixbY2ksWmVdXSxbXCJSZWR1Y2VMMlwiLFtwaSxaZV1dLFtcIlJlZHVjZUxvZ1N1bVwiLFt3aSxaZV1dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFtmaSxaZV1dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFtiaSxaZV1dLFtcIlJlbHVcIixbWWldXSxbXCJSZXNpemVcIixbU3UsQ3VdXSxbXCJTaWdtb2lkXCIsW1hpXV0sW1wiU2luXCIsW0ppXV0sW1wiU2luaFwiLFtRaV1dLFtcIlNsaWNlXCIsW1R1LFJ1XV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtBdSxFdV1dLFtcIlNwbGl0XCIsW0R1LHp1XV0sW1wiU3FydFwiLFtaaV1dLFtcIlNvZnRtYXhcIixba3UsQnVdXSxbXCJTdWJcIixbY3NdXSxbXCJUYW5cIixbZXNdXSxbXCJUYW5oXCIsW3RzXV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW3JzLHJuXV0sW1wiVGlsZVwiLFtWdV1dLFtcIlRyYW5zcG9zZVwiLFtKbyxRb11dLFtcIldoZXJlXCIsW0d1XV1dKX0pO3ZhciBobixqdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTt4dCgpO3ZlKCk7aG49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxyKXt0aGlzLnJlcG8uc2V0KHQscil9cnVuKHQscixhLG4scyx1LGwpe2xldCBvPXRoaXMuYmFja2VuZC5kZXZpY2UscD10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7cC5zZXRQaXBlbGluZSh0LmNvbXB1dGVQaXBlbGluZSk7bGV0IG09W107Zm9yKGxldCBnIG9mIG4pbS5wdXNoKHtiaW5kaW5nOm0ubGVuZ3RoLHJlc291cmNlOntidWZmZXI6Zy5idWZmZXJ9fSk7Zm9yKGxldCBnIG9mIHMpbS5wdXNoKHtiaW5kaW5nOm0ubGVuZ3RoLHJlc291cmNlOntidWZmZXI6Zy5idWZmZXJ9fSk7bCYmbS5wdXNoKHtiaW5kaW5nOm0ubGVuZ3RoLHJlc291cmNlOmx9KTtsZXQgeT1vLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnQuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOm0sbGFiZWw6dC5wcm9ncmFtSW5mby5uYW1lfSk7aWYocC5zZXRCaW5kR3JvdXAoMCx5KSxwLmRpc3BhdGNoV29ya2dyb3VwcyguLi51KSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5iYWNrZW5kLmlzUXVlcnlFbmFibGVkKCkpe3R5cGVvZiB0aGlzLmJhY2tlbmQucXVlcnlEYXRhPlwidVwiJiYodGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YT10aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHRoaXMuYmFja2VuZC5xdWVyeVNldENvdW50KjgsR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSkpO2xldCBnPXRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUodGhpcy5iYWNrZW5kLnF1ZXJ5U2V0Q291bnQqOCxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRHxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksdGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCkucmVzb2x2ZVF1ZXJ5U2V0KHRoaXMuYmFja2VuZC5xdWVyeVNldCwwLDIsdGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YS5idWZmZXIsMCksdGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCkuY29weUJ1ZmZlclRvQnVmZmVyKHRoaXMuYmFja2VuZC5xdWVyeURhdGEuYnVmZmVyLDAsZy5idWZmZXIsMCx0aGlzLmJhY2tlbmQucXVlcnlTZXRDb3VudCo4KSx0aGlzLmJhY2tlbmQuZmx1c2goKTtsZXQgdj10aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbElkLCQ9dGhpcy5iYWNrZW5kLmtlcm5lbHMuZ2V0KHYpLGI9YFskeyRbMF19XSAkeyRbMV19YDtnLmJ1ZmZlci5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCk9PntsZXQgUz1uZXcgQmlnVWludDY0QXJyYXkoZy5idWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSksST1TWzBdLFQ9U1sxXTtnLmJ1ZmZlci51bm1hcCgpLHR5cGVvZiB0aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZT5cInVcIiYmKHRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlPUkpO2xldCBCPU51bWJlcihJLXRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlKSxQPU51bWJlcihULXRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlKTtpZighTnVtYmVyLmlzU2FmZUludGVnZXIoQil8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihQKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2VcIik7dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZy5pZCk7bGV0IEQ9XCJcIjtyLmZvckVhY2goKFcsSCk9PntEKz1gaW5wdXRbJHtIfV06IFske1cuZGltc31dIHwgJHtjcihXLmRhdGFUeXBlKX0sIGB9KTtsZXQgUj1cIlwiO2EuZm9yRWFjaCgoVyxIKT0+e1IrPWBvdXRwdXRbJHtIfV06IFske1cuZGltc31dIHwgJHtjcihXLmRhdGFUeXBlKX0sIGB9KSxjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHt2fXwke2J9XCIgJHtEfSR7Un1leGVjdXRpb24gdGltZTogJHtQLUJ9IG5zYCl9KX10aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj0xNiYmdGhpcy5iYWNrZW5kLmZsdXNoKCl9ZGlzcG9zZSgpe31idWlsZCh0LHIpe2xldCBhPXRoaXMuYmFja2VuZC5kZXZpY2Usbj1bXTthLmZlYXR1cmVzLmhhcyhcInNoYWRlci1mMTZcIikmJm4ucHVzaChcImVuYWJsZSBmMTY7XCIpO2xldCBzPUtvKHIpLHU9dC5nZXRTaGFkZXJTb3VyY2UocyksbD1gJHtuLmpvaW4oYFxuYCl9XG4ke3MuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cbiR7dX1gLG89YS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6bCxsYWJlbDp0Lm5hbWV9KTtfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIHNoYWRlciBjb2RlOiAke2x9YCk7bGV0IHA9YS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2NvbXB1dGU6e21vZHVsZTpvLGVudHJ5UG9pbnQ6XCJtYWluXCJ9LGxheW91dDpcImF1dG9cIixsYWJlbDp0Lm5hbWV9KTtyZXR1cm57cHJvZ3JhbUluZm86dCxjb21wdXRlUGlwZWxpbmU6cH19bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUodCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LngsYT10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQueXx8MSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC56fHwxLHM9dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYocjw9cyYmYTw9cyYmbjw9cylyZXR1cm5bcixhLG5dO2xldCB1PXIqYSpuLGw9TWF0aC5jZWlsKE1hdGguc3FydCh1KSk7aWYobD5zKXtpZihsPU1hdGguY2VpbChNYXRoLmNicnQodSkpLGw+cyl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVybltsLGwsbF19ZWxzZSByZXR1cm5bbCxsLDFdfX19KTt2YXIgZnAsbXAsZ24scXU9TCgoKT0+e1widXNlIHN0cmljdFwiO3h0KCk7VW8oKTtIbygpO0h1KCk7anUoKTtmcD0oZSx0KT0+e2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHt0Lmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtlLmxlbmd0aH0uYCk7bGV0IHI9W107Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDsrK2Epe2xldCBuPWVbYV0uZGF0YVR5cGU7c3dpdGNoKHRbYV0pe2Nhc2VcIm5vbmVcIjp7ci5wdXNoKFwiXCIpO2JyZWFrfWNhc2VcInR5cGVcIjp7ci5wdXNoKGAke259YCk7YnJlYWt9Y2FzZVwicmFua1wiOntsZXQgcz1lW2FdLmRpbXMubGVuZ3RoO3IucHVzaChgJHtufTske3N9YCk7YnJlYWt9Y2FzZVwiZGltc1wiOntsZXQgcz1lW2FdLmRpbXMuam9pbihcIixcIik7ci5wdXNoKGAke259OyR7c31gKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHt0W2FdfWApfX1yZXR1cm4gci5qb2luKFwifFwiKX0sbXA9KGUsdCk9PntsZXQgcj1lLm5hbWU7cmV0dXJuIGUuc2hhZGVyQ2FjaGU/LmhpbnQmJihyKz1cIltcIitlLnNoYWRlckNhY2hlLmhpbnQrXCJdXCIpLHIrPWA6JHtmcCh0LGUuc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzPz9uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoXCJkaW1zXCIpKX1gLHJ9LGduPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wO3RoaXMucXVlcnlTZXRDb3VudD0yO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0KXtpZighbmF2aWdhdG9yLmdwdSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHcHVCYWNrZW5kOiBXZWJHUFUgaXMgbm90IGF2YWlsYWJsZS5cIik7bGV0IHI9YXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcIldlYkdwdUJhY2tlbmQ6IEZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuXCIpO3RoaXMuZW52PXQ7bGV0IGE9W10sbj17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOnIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOnIubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOnIubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczphfTtyLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmYS5wdXNoKFwidGltZXN0YW1wLXF1ZXJ5XCIpLHIuZmVhdHVyZXMuaGFzKFwic2hhZGVyLWYxNlwiKSYmYS5wdXNoKFwic2hhZGVyLWYxNlwiKSx0aGlzLmRldmljZT1hd2FpdCByLnJlcXVlc3REZXZpY2UobiksdGhpcy5ncHVEYXRhTWFuYWdlcj1Mbyh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBobih0aGlzKSx0aGlzLmtlcm5lbHM9bmV3IE1hcCx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhPW5ldyBNYXAsdGhpcy5rZXJuZWxDdXN0b21EYXRhPW5ldyBNYXAsTm8odC5sb2dMZXZlbCwhIXQuZGVidWcpLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPXM9PntzLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke3MuZXJyb3IubWVzc2FnZX1gKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImRldmljZVwiLHt2YWx1ZTp0aGlzLmRldmljZX0pfWRpc3Bvc2UoKXt0eXBlb2YgdGhpcy5xdWVyeVNldDxcInVcIiYmdGhpcy5xdWVyeVNldC5kZXN0cm95KCksdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCl9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtpZighdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpe2xldCB0PXt9O3RoaXMuaXNRdWVyeUVuYWJsZWQoKSYmKHR5cGVvZiB0aGlzLnF1ZXJ5U2V0PlwidVwiJiYodGhpcy5xdWVyeVNldD10aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7dHlwZTpcInRpbWVzdGFtcFwiLGNvdW50OnRoaXMucXVlcnlTZXRDb3VudH0pKSx0LnRpbWVzdGFtcFdyaXRlcz17cXVlcnlTZXQ6dGhpcy5xdWVyeVNldCxiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4OjAsZW5kT2ZQYXNzV3JpdGVJbmRleDoxfSksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9dGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLmJlZ2luQ29tcHV0ZVBhc3ModCl9cmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyfWVuZENvbXB1dGVQYXNzKCl7dGhpcy5jb21wdXRlUGFzc0VuY29kZXImJih0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsKX1mbHVzaCgpe3RoaXMuY29tbWFuZEVuY29kZXImJih0aGlzLmVuZENvbXB1dGVQYXNzKCksdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmdldENvbW1hbmRFbmNvZGVyKCkuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wKX1pc1F1ZXJ5RW5hYmxlZCgpe3JldHVybiEhKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZ01vZGU9PT1cImRlZmF1bHRcIil9cnVuKHQscixhLG4scyl7bGV0IHU9W107Zm9yKGxldCBJPTA7STxyLmxlbmd0aDsrK0kpe2xldCBUPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHJbSV0uZGF0YSk7aWYoIVQpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7cltJXS5kYXRhfWApO3VbSV09VH1sZXQgbD1tcCh0LHIpLG89dGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChsKSx7b3V0cHV0czpwLGRpc3BhdGNoR3JvdXA6bSxwcm9ncmFtVW5pZm9ybXM6eX09dC5nZXRSdW5EYXRhKHIpLGc9YS5sZW5ndGg9PT0wP3AubWFwKChJLFQpPT5UKTphO2lmKGcubGVuZ3RoIT09cC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke2cubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7cC5sZW5ndGh9LmApO2xldCB2PVtdLCQ9W107Zm9yKGxldCBJPTA7STxwLmxlbmd0aDsrK0kpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGdbSV0pfHxnW0ldPC0zfHxnW0ldPj1wLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke2dbSV19YCk7aWYoZ1tJXT09PS0zKWNvbnRpbnVlO2xldCBUPWdbSV09PT0tMSxCPWdbSV09PT0tMixQPVR8fEI/cyhwW0ldLmRhdGFUeXBlLHBbSV0uZGltcyk6bihnW0ldLHBbSV0uZGF0YVR5cGUscFtJXS5kaW1zKSxEPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KFAuZGF0YSk7aWYoIUQpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAke1AuZGF0YX1gKTtpZihUJiZ0aGlzLnRlbXBvcmFyeURhdGEucHVzaChEKSxCKXtsZXQgUj10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7Unx8KFI9W10sdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsUikpLFIucHVzaChEKX12LnB1c2goUCksJC5wdXNoKEQpfWxldCBiO2lmKHkpe2xldCBJPTAsVD0wLEI9W10sUD0xO3kuZm9yRWFjaChXPT57bGV0IEg9dHlwZW9mIFcuZGF0YT09XCJudW1iZXJcIj9bVy5kYXRhXTpXLmRhdGEsSztzd2l0Y2goSC5sZW5ndGgpe2Nhc2UgMTpLPTQ7YnJlYWs7Y2FzZSAyOks9ODticmVhaztjYXNlIDM6Sz0xNjticmVhaztjYXNlIDQ6Sz0xNjticmVhaztjYXNlIDU6Sz0xNjticmVhaztjYXNlIDY6Sz0xNjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsZW5ndGg6ICR7SC5sZW5ndGh9YCl9KFQ9PT01fHxUPT09NikmJihLPTE2KSxLPlAmJihQPUspLEk9TWF0aC5jZWlsKEkvSykqSyxUPUgubGVuZ3RoLEIucHVzaChJKSxJKz1ILmxlbmd0aCo0fSksST1NYXRoLmNlaWwoSS9QKSpQO2xldCBEPW5ldyBBcnJheUJ1ZmZlcihJKTt5LmZvckVhY2goKFcsSCk9PntsZXQgSz1CW0hdLGxlPXR5cGVvZiBXLmRhdGE9PVwibnVtYmVyXCI/W1cuZGF0YV06Vy5kYXRhO1cudHlwZT09PVwiaW50MzJcIj9uZXcgSW50MzJBcnJheShELEssbGUubGVuZ3RoKS5zZXQobGUpOlcudHlwZT09PVwidWludDMyXCI/bmV3IFVpbnQzMkFycmF5KEQsSyxsZS5sZW5ndGgpLnNldChsZSk6bmV3IEZsb2F0MzJBcnJheShELEssbGUubGVuZ3RoKS5zZXQobGUpfSk7bGV0IFI9dGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoSSxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTt0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihSLmJ1ZmZlciwwLEQsMCxJKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoUi5pZCksYj17b2Zmc2V0OjAsc2l6ZTpJLGJ1ZmZlcjpSLmJ1ZmZlcn19bGV0IFM9dGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShtKTtyZXR1cm4gb3x8KG89dGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZCh0LFMpLHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3QobCxvKSksX2UoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHtsfSkgd2l0aCAke1NbMF19eCR7U1sxXX14JHtTWzJdfWApLHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKG8scix2LHUsJCxTLGIpLHZ9dXBsb2FkKHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxyKX1tZW1jcHkodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LHIpfWFzeW5jIGRvd25sb2FkKHQscil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LHIpfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQscixhLG4pe2xldCBzPUx1LmdldCh0KTtpZighcyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTt0aGlzLmtlcm5lbHMuc2V0KHIsW3QsbixzWzBdLFtzWzFdLGFdXSl9cmVsZWFzZUtlcm5lbCh0KXtsZXQgcj10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0KTtpZihyKXtmb3IobGV0IGEgb2Ygcil0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoYS5pZCk7dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUodCl9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmRlbGV0ZSh0KSx0aGlzLmtlcm5lbHMuZGVsZXRlKHQpfWNvbXB1dGVLZXJuZWwodCxyLGEpe2xldCBuPXRoaXMua2VybmVscy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGNyZWF0ZWQ6ICR7dH1gKTtsZXRbcyx1LGwsb109bjtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZCE9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHtzfV0gJHt1fVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO3RoaXMuY3VycmVudEtlcm5lbElkPXQsb1swXSYmKG9bMV09b1swXShvWzFdKSxvWzBdPXZvaWQgMCksX2UoXCJpbmZvXCIsKCk9PmBbV2ViR1BVXSBTdGFydCB0byBydW4ga2VybmVsIFwiWyR7c31dICR7dX1cIi4uLmApO2xldCBwPXRoaXMuZW52LmRlYnVnO3RoaXMudGVtcG9yYXJ5RGF0YT1bXTt0cnl7cmV0dXJuIHAmJnRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKFwidmFsaWRhdGlvblwiKSxsKHIsb1sxXSksMH1jYXRjaChtKXtyZXR1cm4gYS5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7c31dICR7dX1cIiBmYWlsZWQuICR7bX1gKSksMX1maW5hbGx5e3AmJmEucHVzaCh0aGlzLmRldmljZS5wb3BFcnJvclNjb3BlKCkudGhlbihtPT5tP2BHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7c31dICR7dX1cIjogJHttLm1lc3NhZ2V9YDpudWxsKSk7Zm9yKGxldCBtIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UobS5pZCk7dGhpcy50ZW1wb3JhcnlEYXRhPVtdLHRoaXMuY3VycmVudEtlcm5lbElkPW51bGx9fXJlZ2lzdGVyQnVmZmVyKHQscixhLG4pe2xldCBzPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO3N8fChzPW5ldyBNYXAsdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQodCxzKSk7bGV0IHU9cy5nZXQociksbD10aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYSxuLHU/LlsxXSk7cmV0dXJuIHMuc2V0KHIsW2wsYV0pLGx9dW5yZWdpc3RlckJ1ZmZlcnModCl7bGV0IHI9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7ciYmKHIuZm9yRWFjaChhPT50aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihhWzFdKSksdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUodCkpfWdldEJ1ZmZlcih0KXtsZXQgcj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7dH1gKTtyZXR1cm4gci5idWZmZXJ9Y3JlYXRlRG93bmxvYWRlcih0LHIsYSl7cmV0dXJuIGFzeW5jKCk9PntsZXQgbj1hd2FpdCBGbih0aGlzLHQscik7cmV0dXJuIFZvKG4uYnVmZmVyLGEpfX19fSk7dmFyIEt1PXt9O2t0KEt1LHtpbml0OigpPT5ocH0pO3ZhciB3cixsYSxocCxZdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtxdSgpO3h0KCk7Z2UoKTt3cj1jbGFzcyBle2NvbnN0cnVjdG9yKHQscixhLG4pe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1yO3RoaXMuZGF0YT1hO3RoaXMuZGltcz1ufWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PXouc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ei5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PXouc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoei5zaXplKHQpIT09ei5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0sbGE9Y2xhc3N7Y29uc3RydWN0b3IodCxyLGEpe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPXI7dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO2xldCBuPXQuSEVBUFUzMixzPWE+PjI7dGhpcy5vcEtlcm5lbENvbnRleHQ9bltzKytdO2xldCB1PW5bcysrXTt0aGlzLm91dHB1dENvdW50PW5bcysrXSx0aGlzLmN1c3RvbURhdGFPZmZzZXQ9bltzKytdLHRoaXMuY3VzdG9tRGF0YVNpemU9bltzKytdO2xldCBsPVtdO2ZvcihsZXQgbz0wO288dTtvKyspe2xldCBwPW5bcysrXSxtPW5bcysrXSx5PW5bcysrXSxnPVtdO2ZvcihsZXQgdj0wO3Y8eTt2KyspZy5wdXNoKG5bcysrXSk7bC5wdXNoKG5ldyB3cih0LHAsbSxnKSl9dGhpcy5pbnB1dHM9bH1nZXQga2VybmVsQ3VzdG9tRGF0YSgpe3JldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGF9Z2V0IGN1c3RvbURhdGFCdWZmZXIoKXtyZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCx0aGlzLmN1c3RvbURhdGFPZmZzZXQrdGhpcy5jdXN0b21EYXRhU2l6ZSl9Y29tcHV0ZSh0LHIpe2xldCBhPXI/LmlucHV0cz8ubWFwKGw9PnR5cGVvZiBsPT1cIm51bWJlclwiP3RoaXMuaW5wdXRzW2xdOmwpPz90aGlzLmlucHV0cyxuPXI/Lm91dHB1dHM/P1tdLHM9KGwsbyxwKT0+bmV3IHdyKHRoaXMubW9kdWxlLG8sdGhpcy5vdXRwdXQobCxwKSxwKSx1PShsLG8pPT57bGV0IHA9cHIobCk7aWYoIXApdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7bH1gKTtsZXQgbT1wKnouc2l6ZShvKTtyZXR1cm4gbmV3IHdyKHRoaXMubW9kdWxlLGwsdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShtKS5pZCxvKX07cmV0dXJuIHRoaXMuYmFja2VuZC5ydW4odCxhLG4scyx1KX1vdXRwdXQodCxyKXtsZXQgYT10aGlzLm1vZHVsZS5zdGFja1NhdmUoKTt0cnl7bGV0IG49dGhpcy5tb2R1bGUuc3RhY2tBbGxvYygoMStyLmxlbmd0aCkqNCkscz1uPj4yO3RoaXMubW9kdWxlLkhFQVBVMzJbcysrXT1yLmxlbmd0aDtmb3IobGV0IHU9MDt1PHIubGVuZ3RoO3UrKyl0aGlzLm1vZHVsZS5IRUFQVTMyW3MrK109clt1XTtyZXR1cm4gdGhpcy5tb2R1bGUuX0pzZXBPdXRwdXQodGhpcy5vcEtlcm5lbENvbnRleHQsdCxuKX1jYXRjaChuKXt0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBrZXJuZWwncyBvdXRwdXRbJHt0fV0gd2l0aCBkaW1zIFske3J9XS4gSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuIEVycm9yOiAke259YCl9ZmluYWxseXt0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUoYSl9fX0saHA9YXN5bmMoZSx0KT0+e2xldCByPWUuanNlcEluaXQ7aWYociYmbmF2aWdhdG9yLmdwdSl7aWYoIXQud2FzbS5zaW1kKXRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgZm9yIFdlYkdQVT1PTiBhbmQgU0lNRD1PRkYuIFBsZWFzZSBzZXQgYGVudi53YXNtLnNpbWRgIHRvIHRydWUgd2hlbiB1c2luZyBXZWJHUFUgRVBcIik7bGV0IGE9bmV3IGduO2F3YWl0IGEuaW5pdGlhbGl6ZSh0KSxyKGEsbj0+YS5hbGxvYyhuKSxuPT5hLmZyZWUobiksKG4scyx1LGw9ITEpPT57aWYobClfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke259LCBkc3Q9JHtzfSwgc2l6ZT0ke3V9YCksYS5tZW1jcHkobixzKTtlbHNle19lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke259LCBncHVEYXRhSWQ9JHtzfSwgc2l6ZT0ke3V9YCk7bGV0IG89ZS5IRUFQVTguc3ViYXJyYXkobixuK3UpO2EudXBsb2FkKHMsbyl9fSxhc3luYyhuLHMsdSk9PntfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke259LCBkYXRhT2Zmc2V0PSR7c30sIHNpemU9JHt1fWApLGF3YWl0IGEuZG93bmxvYWQobiwoKT0+ZS5IRUFQVTguc3ViYXJyYXkocyxzK3UpKX0sKG4scyx1KT0+YS5jcmVhdGVLZXJuZWwobixzLHUsdC5kZWJ1Z3x8dC53ZWJncHUucHJvZmlsaW5nTW9kZT09PVwiZGVmYXVsdFwiP2UuVVRGOFRvU3RyaW5nKGUuX0pzZXBHZXROb2RlTmFtZShzKSk6YCR7c31gKSxuPT5hLnJlbGVhc2VLZXJuZWwobiksKG4scyx1LGwpPT57X2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7dX0sIGtlcm5lbD0ke259LCBjb250ZXh0RGF0YU9mZnNldD0ke3N9YCk7bGV0IG89bmV3IGxhKGUsYSxzKTtyZXR1cm4gYS5jb21wdXRlS2VybmVsKG4sbyxsKX0pfX19KTt2YXIgSnUsZ3AseXAsUXUsdnIsWnUsZGEsY2EsZWwsdGwsWHUscmwsbmwsYWwsb2w9TCgoKT0+e1widXNlIHN0cmljdFwiO0JvKCk7RG8oKTtEZSgpO0h0KCk7cXIoKTtKdT0hMSxncD1lPT57bGV0IHQ9UGUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBhPXQuc3RhY2tBbGxvYyg4KTtyZXR1cm4gdC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLGEsYSs0KSE9PTAmJkFlKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKSxbdC5IRUFQMzJbYS80XSx0LkhFQVAzMlthLzQrMV1dfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSx5cD0oZSx0KT0+e1BlKCkuX09ydEluaXQoZSx0KSE9PTAmJkFlKFwiQ2FuJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9LFF1PWFzeW5jIGU9Pnt5cChlLndhc20ubnVtVGhyZWFkcyxmcihlLmxvZ0xldmVsKSk7e2xldCB0PShZdSgpLHZ0KEt1KSkuaW5pdDthd2FpdCB0KFBlKCksZSl9SnU9ITB9LHZyPW5ldyBNYXAsWnU9KCk9Pkp1LGRhPWU9PntsZXQgdD1QZSgpLHI9dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7aWYocj09PTApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke2UuYnl0ZUxlbmd0aH0uYCk7cmV0dXJuIHQuSEVBUFU4LnNldChlLHIpLFtyLGUuYnl0ZUxlbmd0aF19LGNhPShlLHQpPT57bGV0IHI9UGUoKSxhPTAsbj0wLHM9MCx1PVtdLGw9W10sbz1bXTt0cnl7W24sdV09TW8odCksYT1yLl9PcnRDcmVhdGVTZXNzaW9uKGVbMF0sZVsxXSxuKSxhPT09MCYmQWUoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKTtsZXRbcCxtXT1ncChhKSx5PVtdLGc9W10sdj1bXTtmb3IobGV0IGI9MDtiPHA7YisrKXtsZXQgUz1yLl9PcnRHZXRJbnB1dE5hbWUoYSxiKTtTPT09MCYmQWUoXCJDYW4ndCBnZXQgYW4gaW5wdXQgbmFtZS5cIiksbC5wdXNoKFMpLHkucHVzaChyLlVURjhUb1N0cmluZyhTKSl9Zm9yKGxldCBiPTA7YjxtO2IrKyl7bGV0IFM9ci5fT3J0R2V0T3V0cHV0TmFtZShhLGIpO1M9PT0wJiZBZShcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZS5cIiksby5wdXNoKFMpO2xldCBJPXIuVVRGOFRvU3RyaW5nKFMpO2cucHVzaChJKTt7bGV0IFQ9dHlwZW9mIHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT1cInN0cmluZ1wiP3QucHJlZmVycmVkT3V0cHV0TG9jYXRpb246dD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24/LltJXT8/XCJjcHVcIjtpZihUIT09XCJjcHVcIiYmVCE9PVwiY3B1LXBpbm5lZFwiJiZUIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7VH0uYCk7di5wdXNoKFQpfX1sZXQgJD1udWxsO3JldHVybiB2LnNvbWUoYj0+Yj09PVwiZ3B1LWJ1ZmZlclwiKSYmKHM9ci5fT3J0Q3JlYXRlQmluZGluZyhhKSxzPT09MCYmQWUoXCJDYW4ndCBjcmVhdGUgSU8gYmluZGluZy5cIiksJD17aGFuZGxlOnMsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOnYsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDp2Lm1hcChiPT5VbihiKSl9KSx2ci5zZXQoYSxbYSxsLG8sJF0pLFthLHksZ119Y2F0Y2gocCl7dGhyb3cgbC5mb3JFYWNoKG09PnIuX09ydEZyZWUobSkpLG8uZm9yRWFjaChtPT5yLl9PcnRGcmVlKG0pKSxzIT09MCYmci5fT3J0UmVsZWFzZUJpbmRpbmcocyksYSE9PTAmJnIuX09ydFJlbGVhc2VTZXNzaW9uKGEpLHB9ZmluYWxseXtyLl9mcmVlKGVbMF0pLG4hPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobiksdS5mb3JFYWNoKHA9PnIuX2ZyZWUocCkpfX0sZWw9KGUsdCk9PntsZXQgcj1kYShlKTtyZXR1cm4gY2Eocix0KX0sdGw9ZT0+e2xldCB0PVBlKCkscj12ci5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbYSxuLHMsdV09cjt1JiZ0Ll9PcnRSZWxlYXNlQmluZGluZyh1LmhhbmRsZSksdC5qc2VwVW5yZWdpc3RlckJ1ZmZlcnM/LihlKSxuLmZvckVhY2gobD0+dC5fT3J0RnJlZShsKSkscy5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLHQuX09ydFJlbGVhc2VTZXNzaW9uKGEpLHZyLmRlbGV0ZShlKX0sWHU9KGUsdCxyLGEsbik9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgcz1QZSgpLHU9ZVswXSxsPWVbMV0sbz1lWzNdLHAsbTtpZih1PT09XCJzdHJpbmdcIiYmbz09PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2lmKG89PT1cImdwdS1idWZmZXJcIil7bGV0IHY9ZVsyXS5ncHVCdWZmZXIsJD1wcihWbih1KSk7bT1sLnJlZHVjZSgoYixTKT0+YipTLDEpKiQscD1zLmpzZXBSZWdpc3RlckJ1ZmZlcihhLG4sdixtKX1lbHNle2xldCB2PWVbMl07aWYoQXJyYXkuaXNBcnJheSh2KSl7bT00KnYubGVuZ3RoLHA9cy5fbWFsbG9jKG0pLHIucHVzaChwKTtsZXQgJD1wLzQ7Zm9yKGxldCBiPTA7Yjx2Lmxlbmd0aDtiKyspe2lmKHR5cGVvZiB2W2JdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7Yn0gaXMgbm90IGEgc3RyaW5nYCk7cy5IRUFQVTMyWyQrK109TWUodltiXSxyKX19ZWxzZSBtPXYuYnl0ZUxlbmd0aCxwPXMuX21hbGxvYyhtKSxyLnB1c2gocCkscy5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHYuYnVmZmVyLHYuYnl0ZU9mZnNldCxtKSxwKX1sZXQgeT1zLnN0YWNrU2F2ZSgpLGc9cy5zdGFja0FsbG9jKDQqbC5sZW5ndGgpO3RyeXtsZXQgdj1nLzQ7bC5mb3JFYWNoKGI9PnMuSEVBUDMyW3YrK109Yik7bGV0ICQ9cy5fT3J0Q3JlYXRlVGVuc29yKFZuKHUpLHAsbSxnLGwubGVuZ3RoLFVuKG8pKTskPT09MCYmQWUoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke2F9LCBpbmRleD0ke259LmApLHQucHVzaCgkKX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKHkpfX0scmw9YXN5bmMoZSx0LHIsYSxuLHMpPT57bGV0IHU9UGUoKSxsPXZyLmdldChlKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbbyxwLG0seV09bCxnPXQubGVuZ3RoLHY9YS5sZW5ndGgsJD0wLGI9W10sUz1bXSxJPVtdLFQ9W10sQj11LnN0YWNrU2F2ZSgpLFA9dS5zdGFja0FsbG9jKGcqNCksRD11LnN0YWNrQWxsb2MoZyo0KSxSPXUuc3RhY2tBbGxvYyh2KjQpLFc9dS5zdGFja0FsbG9jKHYqNCk7dHJ5e1skLGJdPWtvKHMpO2ZvcihsZXQgb2U9MDtvZTxnO29lKyspWHUocltvZV0sUyxULGUsdFtvZV0pO2ZvcihsZXQgb2U9MDtvZTx2O29lKyspWHUobltvZV0sSSxULGUsZythW29lXSk7bGV0IEg9UC80LEs9RC80LGxlPVIvNCxNPVcvNDtmb3IobGV0IG9lPTA7b2U8ZztvZSsrKXUuSEVBUFUzMltIKytdPVNbb2VdLHUuSEVBUFUzMltLKytdPXBbdFtvZV1dO2ZvcihsZXQgb2U9MDtvZTx2O29lKyspdS5IRUFQVTMyW2xlKytdPUlbb2VdLHUuSEVBUFUzMltNKytdPW1bYVtvZV1dO2lmKHkpe2xldHtoYW5kbGU6b2Usb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOndlLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6an09eTtpZihwLmxlbmd0aCE9PWcpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2d9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtwLmxlbmd0aH0pLmApO2ZvcihsZXQgU2U9MDtTZTxnO1NlKyspe2xldCBUZT10W1NlXTthd2FpdCB1Ll9PcnRCaW5kSW5wdXQob2UscFtUZV0sU1tTZV0pIT09MCYmQWUoYENhbid0IGJpbmQgaW5wdXRbJHtTZX1dIGZvciBzZXNzaW9uPSR7ZX0uYCl9Zm9yKGxldCBTZT0wO1NlPHY7U2UrKyl7bGV0IFRlPWFbU2VdO25bU2VdPy5bM10/dS5fT3J0QmluZE91dHB1dChvZSxtW1RlXSxJW1NlXSwwKSE9PTAmJkFlKGBDYW4ndCBiaW5kIHByZS1hbGxvY2F0ZWQgb3V0cHV0WyR7U2V9XSBmb3Igc2Vzc2lvbj0ke2V9LmApOnUuX09ydEJpbmRPdXRwdXQob2UsbVtUZV0sMCxqW1RlXSkhPT0wJiZBZShgQ2FuJ3QgYmluZCBvdXRwdXRbJHtTZX1dIHRvICR7d2VbU2VdfSBmb3Igc2Vzc2lvbj0ke2V9LmApfX1sZXQgcTt5P3E9YXdhaXQgdS5fT3J0UnVuV2l0aEJpbmRpbmcobyx5LmhhbmRsZSx2LFIsJCk6cT1hd2FpdCB1Ll9PcnRSdW4obyxELFAsZyxXLHYsUiwkKSxxIT09MCYmQWUoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IHhlPVtdO2ZvcihsZXQgb2U9MDtvZTx2O29lKyspe2xldCB3ZT11LkhFQVBVMzJbUi80K29lXTtpZih3ZT09PUlbb2VdKXt4ZS5wdXNoKG5bb2VdKTtjb250aW51ZX1sZXQgaj11LnN0YWNrU2F2ZSgpLFNlPXUuc3RhY2tBbGxvYyg0KjQpLFRlPSExLEVlLENlPTA7dHJ5e3UuX09ydEdldFRlbnNvckRhdGEod2UsU2UsU2UrNCxTZSs4LFNlKzEyKSE9PTAmJkFlKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7b2V9LmApO2xldCBMZT1TZS80LHFlPXUuSEVBUFUzMltMZSsrXTtDZT11LkhFQVBVMzJbTGUrK107bGV0IFU9dS5IRUFQVTMyW0xlKytdLGRlPXUuSEVBUFUzMltMZSsrXSxwZT1bXTtmb3IobGV0IE9lPTA7T2U8ZGU7T2UrKylwZS5wdXNoKHUuSEVBUFUzMltVLzQrT2VdKTt1Ll9PcnRGcmVlKFUpO2xldCBOZT1wZS5yZWR1Y2UoKE9lLHplKT0+T2UqemUsMSk7RWU9Y3IocWUpO2xldCBIZT15Py5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbYVtvZV1dO2lmKEVlPT09XCJzdHJpbmdcIil7aWYoSGU9PT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtsZXQgT2U9W10semU9Q2UvNDtmb3IobGV0IEdlPTA7R2U8TmU7R2UrKyl7bGV0IGV0PXUuSEVBUFUzMlt6ZSsrXSxLZT1HZT09PU5lLTE/dm9pZCAwOnUuSEVBUFUzMlt6ZV0tZXQ7T2UucHVzaCh1LlVURjhUb1N0cmluZyhldCxLZSkpfXhlLnB1c2goW0VlLHBlLE9lLFwiY3B1XCJdKX1lbHNlIGlmKEhlPT09XCJncHUtYnVmZmVyXCImJk5lPjApe2xldCBPZT11LmpzZXBHZXRCdWZmZXIoQ2UpLHplPXByKHFlKTtpZih6ZT09PXZvaWQgMHx8IVlyKEVlKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtFZX1gKTtUZT0hMCx4ZS5wdXNoKFtFZSxwZSx7Z3B1QnVmZmVyOk9lLGRvd25sb2FkOnUuanNlcENyZWF0ZURvd25sb2FkZXIoT2UsTmUqemUsRWUpLGRpc3Bvc2U6KCk9Pnt1Ll9PcnRSZWxlYXNlVGVuc29yKHdlKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZXtsZXQgT2U9S3IoRWUpLHplPW5ldyBPZShOZSk7bmV3IFVpbnQ4QXJyYXkoemUuYnVmZmVyLHplLmJ5dGVPZmZzZXQsemUuYnl0ZUxlbmd0aCkuc2V0KHUuSEVBUFU4LnN1YmFycmF5KENlLENlK3plLmJ5dGVMZW5ndGgpKSx4ZS5wdXNoKFtFZSxwZSx6ZSxcImNwdVwiXSl9fWZpbmFsbHl7dS5zdGFja1Jlc3RvcmUoaiksRWU9PT1cInN0cmluZ1wiJiZDZSYmdS5fZnJlZShDZSksVGV8fHUuX09ydFJlbGVhc2VUZW5zb3Iod2UpfX1yZXR1cm4geSYmdS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoeS5oYW5kbGUpLHhlfWZpbmFsbHl7dS5zdGFja1Jlc3RvcmUoQiksUy5mb3JFYWNoKEg9PnUuX09ydFJlbGVhc2VUZW5zb3IoSCkpLEkuZm9yRWFjaChIPT51Ll9PcnRSZWxlYXNlVGVuc29yKEgpKSxULmZvckVhY2goSD0+dS5fZnJlZShIKSksJCE9PTAmJnUuX09ydFJlbGVhc2VSdW5PcHRpb25zKCQpLGIuZm9yRWFjaChIPT51Ll9mcmVlKEgpKX19LG5sPWU9PntsZXQgdD1QZSgpLHI9dnIuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtsZXQgYT1yWzBdLG49dC5fT3J0RW5kUHJvZmlsaW5nKGEpO249PT0wJiZBZShcIkNhbid0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksdC5fT3J0RnJlZShuKX0sYWw9ZT0+e2xldCB0PVtdO2ZvcihsZXQgciBvZiBlKXtsZXQgYT1yWzJdOyFBcnJheS5pc0FycmF5KGEpJiZcImJ1ZmZlclwiaW4gYSYmdC5wdXNoKGEuYnVmZmVyKX1yZXR1cm4gdH19KTt2YXIgaWw9THQoKFV5LHdwKT0+e3dwLmV4cG9ydHM9Jy8qIVxcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMTcuMC1kZXYuMjAyMzExMDMtMTQzOWRhMzZmZVxcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cXG4gKi9cXG5cInVzZSBzdHJpY3RcIjsoKCk9Pnt2YXIgb249T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBTdT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBDdT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgQXU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgSD0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBKdD0oZSx0KT0+KCk9Pih0fHxlKCh0PXtleHBvcnRzOnt9fSkuZXhwb3J0cyx0KSx0LmV4cG9ydHMpLElyPShlLHQpPT57Zm9yKHZhciByIGluIHQpb24oZSxyLHtnZXQ6dFtyXSxlbnVtZXJhYmxlOiEwfSl9LEl1PShlLHQscixvKT0+e2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwifHx0eXBlb2YgdD09XCJmdW5jdGlvblwiKWZvcihsZXQgbiBvZiBDdSh0KSkhQXUuY2FsbChlLG4pJiZuIT09ciYmb24oZSxuLHtnZXQ6KCk9PnRbbl0sZW51bWVyYWJsZTohKG89U3UodCxuKSl8fG8uZW51bWVyYWJsZX0pO3JldHVybiBlfTt2YXIgTXQ9ZT0+SXUob24oe30sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZSk7dmFyIGFuPXt9O0lyKGFuLHtyZWFkRmlsZTooKT0+RXV9KTt2YXIgRXUsc249SCgoKT0+e0V1PXZvaWQgMH0pO3ZhciB1bj17fTtJcih1bix7am9pbjooKT0+VHV9KTt2YXIgVHUsbG49SCgoKT0+e1R1PXZvaWQgMH0pO3ZhciB1bz1KdCgoc28sZG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGlvPSgoKT0+e3ZhciBlPXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYoZT1lfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbih0PXt9KXt2YXIgcj10LG8sbjtyLnJlYWR5PW5ldyBQcm9taXNlKChsLHApPT57bz1sLG49cH0pLHIuanNlcEluaXQ9KGwscCxoLEMsVCxVLEcsdWUpPT57ci5aYT1sLHIuT2E9cCxyLlFhPWgsci5KYT1DLHIuUGE9VCxyLnJhPVUsci5SYT1HLHIuU2E9dWUscD0oWSxRLEopPT4oLi4uY2UpPT57bGV0IG1lPUhlLEU9UT8uKCk7Y2U9WSguLi5jZSk7bGV0IHRlPVE/LigpO3JldHVybiBFIT09dGUmJihZPXRlLEooRSksUT1KPW51bGwpLEhlIT1tZT9ncigpOmNlfSxoPVk9PmFzeW5jKC4uLlEpPT57dHJ5e2lmKHIuRGEpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIGFscmVhZHkgc3RhcnRlZFwiKTtsZXQgSj1yLkRhPXtUYTpRWzBdLGVycm9yczpbXX0sY2U9YXdhaXQgWSguLi5RKTtpZihyLkRhIT09Sil0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7bC5mbHVzaCgpO2xldCBtZT1KLmVycm9ycztpZigwPG1lLmxlbmd0aCl7bGV0IEU9YXdhaXQgUHJvbWlzZS5hbGwobWUpO2lmKEU9RS5maWx0ZXIodGU9PnRlKSwwPEUubGVuZ3RoKXRocm93IEVycm9yKEUuam9pbihgXFxuYCkpfXJldHVybiBjZX1maW5hbGx5e3IuRGE9bnVsbH19LHIuX09ydFJ1bj1oKHAoci5fT3J0UnVuLCgpPT5yLl9PcnRSdW4sWT0+ci5fT3J0UnVuPVkpKSxyLl9PcnRSdW5XaXRoQmluZGluZz1oKHAoci5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnIuX09ydFJ1bldpdGhCaW5kaW5nLFk9PnIuX09ydFJ1bldpdGhCaW5kaW5nPVkpKSxyLl9PcnRCaW5kSW5wdXQ9cChyLl9PcnRCaW5kSW5wdXQsKCk9PnIuX09ydEJpbmRJbnB1dCxZPT5yLl9PcnRCaW5kSW5wdXQ9WSksci5qc2VwUmVnaXN0ZXJCdWZmZXI9KFksUSxKLGNlKT0+bC5yZWdpc3RlckJ1ZmZlcihZLFEsSixjZSksci5qc2VwVW5yZWdpc3RlckJ1ZmZlcnM9WT0+e2wudW5yZWdpc3RlckJ1ZmZlcnMoWSl9LHIuanNlcEdldEJ1ZmZlcj1ZPT5sLmdldEJ1ZmZlcihZKSxyLmpzZXBDcmVhdGVEb3dubG9hZGVyPShZLFEsSik9PmwuY3JlYXRlRG93bmxvYWRlcihZLFEsSil9O3ZhciBzPU9iamVjdC5hc3NpZ24oe30sciksdT1cIi4vdGhpcy5wcm9ncmFtXCIsZD0obCxwKT0+e3Rocm93IHB9LGE9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIixtPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsZz10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIseD1cIlwiLGIsdyx2O2lmKGcpe3ZhciB5PShzbigpLE10KGFuKSksUz0obG4oKSxNdCh1bikpO3g9bT9TLmRpcm5hbWUoeCkrXCIvXCI6X19kaXJuYW1lK1wiL1wiLGI9KGwscCk9PihsPWwuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChsKTpTLm5vcm1hbGl6ZShsKSx5LnJlYWRGaWxlU3luYyhsLHA/dm9pZCAwOlwidXRmOFwiKSksdj1sPT4obD1iKGwsITApLGwuYnVmZmVyfHwobD1uZXcgVWludDhBcnJheShsKSksbCksdz0obCxwLGgsQz0hMCk9PntsPWwuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChsKTpTLm5vcm1hbGl6ZShsKSx5LnJlYWRGaWxlKGwsQz92b2lkIDA6XCJ1dGY4XCIsKFQsVSk9PntUP2goVCk6cChDP1UuYnVmZmVyOlUpfSl9LCFyLnRoaXNQcm9ncmFtJiYxPHByb2Nlc3MuYXJndi5sZW5ndGgmJih1PXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLGQ9KGwscCk9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWwscH0sci5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9ZWxzZShhfHxtKSYmKG0/eD1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoeD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksZSYmKHg9ZSkseC5pbmRleE9mKFwiYmxvYjpcIikhPT0wP3g9eC5zdWJzdHIoMCx4LnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOng9XCJcIixiPWw9Pnt2YXIgcD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHAub3BlbihcIkdFVFwiLGwsITEpLHAuc2VuZChudWxsKSxwLnJlc3BvbnNlVGV4dH0sbSYmKHY9bD0+e3ZhciBwPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gcC5vcGVuKFwiR0VUXCIsbCwhMSkscC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHAuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShwLnJlc3BvbnNlKX0pLHc9KGwscCxoKT0+e3ZhciBDPW5ldyBYTUxIdHRwUmVxdWVzdDtDLm9wZW4oXCJHRVRcIixsLCEwKSxDLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsQy5vbmxvYWQ9KCk9PntDLnN0YXR1cz09MjAwfHxDLnN0YXR1cz09MCYmQy5yZXNwb25zZT9wKEMucmVzcG9uc2UpOmgoKX0sQy5vbmVycm9yPWgsQy5zZW5kKG51bGwpfSk7dmFyIEE9ci5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxSPXIucHJpbnRFcnJ8fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKHIscykscz1udWxsLHIudGhpc1Byb2dyYW0mJih1PXIudGhpc1Byb2dyYW0pLHIucXVpdCYmKGQ9ci5xdWl0KTt2YXIgVztyLndhc21CaW5hcnkmJihXPXIud2FzbUJpbmFyeSk7dmFyIE09ci5ub0V4aXRSdW50aW1lfHwhMDt0eXBlb2YgV2ViQXNzZW1ibHkhPVwib2JqZWN0XCImJkxlKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgRCxfLHo9ITEsRixxLGxlLEIsSyx4ZSxhZTtmdW5jdGlvbiB3ZSgpe3ZhciBsPUQuYnVmZmVyO3IuSEVBUDg9cT1uZXcgSW50OEFycmF5KGwpLHIuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGwpLHIuSEVBUDMyPUI9bmV3IEludDMyQXJyYXkobCksci5IRUFQVTg9bGU9bmV3IFVpbnQ4QXJyYXkobCksci5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShsKSxyLkhFQVBVMzI9Sz1uZXcgVWludDMyQXJyYXkobCksci5IRUFQRjMyPXhlPW5ldyBGbG9hdDMyQXJyYXkobCksci5IRUFQRjY0PWFlPW5ldyBGbG9hdDY0QXJyYXkobCl9dmFyIGo9W10sU2U9W10sT2U9W107ZnVuY3Rpb24gSWUoKXt2YXIgbD1yLnByZVJ1bi5zaGlmdCgpO2oudW5zaGlmdChsKX12YXIgQ2U9MCxkdD1udWxsLE5lPW51bGw7ZnVuY3Rpb24gTGUobCl7dGhyb3cgci5vbkFib3J0JiZyLm9uQWJvcnQobCksbD1cIkFib3J0ZWQoXCIrbCtcIilcIixSKGwpLHo9ITAsRj0xLGw9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihsK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxuKGwpLGx9ZnVuY3Rpb24gTihsKXtyZXR1cm4gbC5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX12YXIgZGU7aWYoZGU9XCJvcnQtd2FzbS1zaW1kLndhc21cIiwhTihkZSkpe3ZhciBwZT1kZTtkZT1yLmxvY2F0ZUZpbGU/ci5sb2NhdGVGaWxlKHBlLHgpOngrcGV9ZnVuY3Rpb24gemUobCl7aWYobD09ZGUmJlcpcmV0dXJuIG5ldyBVaW50OEFycmF5KFcpO2lmKHYpcmV0dXJuIHYobCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gVWUobCl7aWYoIVcmJihhfHxtKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFsLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChsLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHA9PntpZighcC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitsK1wiXFwnXCI7cmV0dXJuIHAuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT56ZShsKSk7aWYodylyZXR1cm4gbmV3IFByb21pc2UoKHAsaCk9Pnt3KGwsQz0+cChuZXcgVWludDhBcnJheShDKSksaCl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+emUobCkpfWZ1bmN0aW9uIFRlKGwscCxoKXtyZXR1cm4gVWUobCkudGhlbihDPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShDLHApKS50aGVuKEM9PkMpLnRoZW4oaCxDPT57UihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK0MpLExlKEMpfSl9ZnVuY3Rpb24ga2UobCxwKXt2YXIgaD1kZTtyZXR1cm4gV3x8dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT1cImZ1bmN0aW9uXCJ8fE4oaCl8fGguc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fGd8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP1RlKGgsbCxwKTpmZXRjaChoLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKEM9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEMsbCkudGhlbihwLGZ1bmN0aW9uKFQpe3JldHVybiBSKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK1QpLFIoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxUZShoLGwscCl9KSl9dmFyIEdlLFhlPXs5MTM3OTI6bD0+e3IucmEoXCJBYnNcIixsLHZvaWQgMCl9LDkxMzg0MzpsPT57ci5yYShcIk5lZ1wiLGwsdm9pZCAwKX0sOTEzODk0Omw9PntyLnJhKFwiRmxvb3JcIixsLHZvaWQgMCl9LDkxMzk0NzpsPT57ci5yYShcIkNlaWxcIixsLHZvaWQgMCl9LDkxMzk5OTpsPT57ci5yYShcIlJlY2lwcm9jYWxcIixsLHZvaWQgMCl9LDkxNDA1NzpsPT57ci5yYShcIlNxcnRcIixsLHZvaWQgMCl9LDkxNDEwOTpsPT57ci5yYShcIkV4cFwiLGwsdm9pZCAwKX0sOTE0MTYwOmw9PntyLnJhKFwiRXJmXCIsbCx2b2lkIDApfSw5MTQyMTE6bD0+e3IucmEoXCJTaWdtb2lkXCIsbCx2b2lkIDApfSw5MTQyNjY6bD0+e3IucmEoXCJMb2dcIixsLHZvaWQgMCl9LDkxNDMxNzpsPT57ci5yYShcIlNpblwiLGwsdm9pZCAwKX0sOTE0MzY4Omw9PntyLnJhKFwiQ29zXCIsbCx2b2lkIDApfSw5MTQ0MTk6bD0+e3IucmEoXCJUYW5cIixsLHZvaWQgMCl9LDkxNDQ3MDpsPT57ci5yYShcIkFzaW5cIixsLHZvaWQgMCl9LDkxNDUyMjpsPT57ci5yYShcIkFjb3NcIixsLHZvaWQgMCl9LDkxNDU3NDpsPT57ci5yYShcIkF0YW5cIixsLHZvaWQgMCl9LDkxNDYyNjpsPT57ci5yYShcIlNpbmhcIixsLHZvaWQgMCl9LDkxNDY3ODpsPT57ci5yYShcIkNvc2hcIixsLHZvaWQgMCl9LDkxNDczMDpsPT57ci5yYShcIkFzaW5oXCIsbCx2b2lkIDApfSw5MTQ3ODM6bD0+e3IucmEoXCJBY29zaFwiLGwsdm9pZCAwKX0sOTE0ODM2Omw9PntyLnJhKFwiQXRhbmhcIixsLHZvaWQgMCl9LDkxNDg4OTpsPT57ci5yYShcIlRhbmhcIixsLHZvaWQgMCl9LDkxNDk0MTpsPT57ci5yYShcIk5vdFwiLGwsdm9pZCAwKX0sOTE0OTkyOihsLHAsaCk9PntyLnJhKFwiQ2xpcFYxMFwiLGwse21pbjpwLG1heDpofSl9LDkxNTA2NDpsPT57ci5yYShcIkNsaXBcIixsLHZvaWQgMCl9LDkxNTExNjoobCxwKT0+e3IucmEoXCJFbHVcIixsLHthbHBoYTpwfSl9LDkxNTE3NDpsPT57ci5yYShcIlJlbHVcIixsLHZvaWQgMCl9LDkxNTIyNjoobCxwKT0+e3IucmEoXCJMZWFreVJlbHVcIixsLHthbHBoYTpwfSl9LDkxNTI5MDoobCxwKT0+e3IucmEoXCJUaHJlc2hvbGRlZFJlbHVcIixsLHthbHBoYTpwfSl9LDkxNTM2MDoobCxwKT0+e3IucmEoXCJDYXN0XCIsbCx7dG86cH0pfSw5MTU0MTg6bD0+e3IucmEoXCJBZGRcIixsLHZvaWQgMCl9LDkxNTQ2OTpsPT57ci5yYShcIlN1YlwiLGwsdm9pZCAwKX0sOTE1NTIwOmw9PntyLnJhKFwiTXVsXCIsbCx2b2lkIDApfSw5MTU1NzE6bD0+e3IucmEoXCJEaXZcIixsLHZvaWQgMCl9LDkxNTYyMjpsPT57ci5yYShcIlBvd1wiLGwsdm9pZCAwKX0sOTE1NjczOmw9PntyLnJhKFwiRXF1YWxcIixsLHZvaWQgMCl9LDkxNTcyNjpsPT57ci5yYShcIkdyZWF0ZXJcIixsLHZvaWQgMCl9LDkxNTc4MTpsPT57ci5yYShcIkdyZWF0ZXJPckVxdWFsXCIsbCx2b2lkIDApfSw5MTU4NDM6bD0+e3IucmEoXCJMZXNzXCIsbCx2b2lkIDApfSw5MTU4OTU6bD0+e3IucmEoXCJMZXNzT3JFcXVhbFwiLGwsdm9pZCAwKX0sOTE1OTU0OihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZU1lYW5cIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNjExODoobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VNYXhcIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNjI4MToobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VNaW5cIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNjQ0NDoobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VQcm9kXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTY2MDg6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlU3VtXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTY3NzE6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlTDFcIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNjkzMzoobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VMMlwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE3MDk1OihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZUxvZ1N1bVwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE3MjYxOihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZVN1bVNxdWFyZVwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE3NDMwOihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZUxvZ1N1bUV4cFwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE3NTk5Omw9PntyLnJhKFwiV2hlcmVcIixsLHZvaWQgMCl9LDkxNzY1MjoobCxwLGgpPT57ci5yYShcIlRyYW5zcG9zZVwiLGwse3Blcm06cD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoaD4+PjAsaCtwPj4+MCkpOltdfSl9LDkxNzc2NToobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFLHRlKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsbCx7Zm9ybWF0Olk/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpwLGRpbGF0aW9uczpbaF0sZ3JvdXA6QyxrZXJuZWxfc2hhcGU6W1RdLHBhZHM6W1UsR10sc3RyaWRlczpbdWVdLHdJc0NvbnN0OigpPT4hIXFbUT4+PjBdLG91dHB1dFBhZGRpbmc6Sj9BcnJheS5mcm9tKEIuc3ViYXJyYXkoY2U+Pj4wLGNlK0o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6bWU/QXJyYXkuZnJvbShCLnN1YmFycmF5KEU+Pj4wLEUrbWU+Pj4wKSk6W10sYWN0aXZhdGlvbjpfZSh0ZSl9KX0sOTE4MTc5OihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixsLHtmb3JtYXQ6dWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpwLGRpbGF0aW9uczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoaD4+PjAsaCsyPj4+MCkpLGdyb3VwOkMsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrMj4+PjApKSxwYWRzOkFycmF5LmZyb20oQi5zdWJhcnJheShVPj4+MCxVKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoRz4+PjAsRysyPj4+MCkpLHdJc0NvbnN0OigpPT4hIXFbWT4+PjBdLG91dHB1dFBhZGRpbmc6MDxRP0FycmF5LmZyb20oQi5zdWJhcnJheShKPj4+MCxKK1E+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxjZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkobWU+Pj4wLG1lK2NlPj4+MCkpOltdLGFjdGl2YXRpb246X2UoRSl9KX0sOTE4NzM2OihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUsdGUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixsLHtmb3JtYXQ6WT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnAsZGlsYXRpb25zOltoXSxncm91cDpDLGtlcm5lbF9zaGFwZTpbVF0scGFkczpbVSxHXSxzdHJpZGVzOlt1ZV0sd0lzQ29uc3Q6KCk9PiEhcVtRPj4+MF0sb3V0cHV0UGFkZGluZzpKP0FycmF5LmZyb20oQi5zdWJhcnJheShjZT4+PjAsY2UrSj4+PjApKTpbXSxvdXRwdXRTaGFwZTptZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoRT4+PjAsRSttZT4+PjApKTpbXSxhY3RpdmF0aW9uOl9lKHRlKX0pfSw5MTkxNTA6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGwse2Zvcm1hdDp1ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnAsZGlsYXRpb25zOkFycmF5LmZyb20oQi5zdWJhcnJheShoPj4+MCxoKzI+Pj4wKSksZ3JvdXA6QyxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShCLnN1YmFycmF5KFU+Pj4wLFUrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oQi5zdWJhcnJheShHPj4+MCxHKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcVtZPj4+MF0sb3V0cHV0UGFkZGluZzowPFE/QXJyYXkuZnJvbShCLnN1YmFycmF5KEo+Pj4wLEorUT4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGNlP0FycmF5LmZyb20oQi5zdWJhcnJheShtZT4+PjAsbWUrY2U+Pj4wKSk6W10sYWN0aXZhdGlvbjpfZShFKX0pfSw5MTk3MDc6KGwscCk9PntyLnJhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixsLHtmb3JtYXQ6cD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MTk3OTg6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiQXZlcmFnZVBvb2xcIixsLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6cCxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6VCxkaWxhdGlvbnM6W1UsR10sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltRLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMDA4MjoobCxwKT0+e3IucmEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGwse2Zvcm1hdDpwP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDE3MzoobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJBdmVyYWdlUG9vbFwiLGwse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpwLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpULGRpbGF0aW9uczpbVSxHXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1EsSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIwNDU3OihsLHApPT57ci5yYShcIkdsb2JhbE1heFBvb2xcIixsLHtmb3JtYXQ6cD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjA1NDQ6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiTWF4UG9vbFwiLGwse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpwLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpULGRpbGF0aW9uczpbVSxHXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1EsSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIwODI0OihsLHApPT57ci5yYShcIkdsb2JhbE1heFBvb2xcIixsLHtmb3JtYXQ6cD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjA5MTE6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiTWF4UG9vbFwiLGwse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpwLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpULGRpbGF0aW9uczpbVSxHXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1EsSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIxMTkxOihsLHAsaCxDLFQpPT57ci5yYShcIkdlbW1cIixsLHthbHBoYTpwLGJldGE6aCx0cmFuc0E6Qyx0cmFuc0I6VH0pfSw5MjEyOTU6bD0+e3IucmEoXCJNYXRNdWxcIixsLHZvaWQgMCl9LDkyMTM0OToobCxwLGgsQyk9PntyLnJhKFwiQXJnTWF4XCIsbCx7a2VlcERpbXM6ISFwLHNlbGVjdExhc3RJbmRleDohIWgsYXhpczpDfSl9LDkyMTQ1NzoobCxwLGgsQyk9PntyLnJhKFwiQXJnTWluXCIsbCx7a2VlcERpbXM6ISFwLHNlbGVjdExhc3RJbmRleDohIWgsYXhpczpDfSl9LDkyMTU2NToobCxwKT0+e3IucmEoXCJTb2Z0bWF4XCIsbCx7YXhpczpwfSl9LDkyMTYyODoobCxwKT0+e3IucmEoXCJDb25jYXRcIixsLHtheGlzOnB9KX0sOTIxNjg4OihsLHAsaCxDLFQpPT57ci5yYShcIlNwbGl0XCIsbCx7YXhpczpwLG51bU91dHB1dHM6aCxzcGxpdFNpemVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MjE4MzM6bD0+e3IucmEoXCJFeHBhbmRcIixsLHZvaWQgMCl9LDkyMTg4NzoobCxwKT0+e3IucmEoXCJHYXRoZXJcIixsLHtheGlzOk51bWJlcihwKX0pfSw5MjE5NTg6KGwscCk9PntyLnJhKFwiR2F0aGVyRWxlbWVudHNcIixsLHtheGlzOk51bWJlcihwKX0pfSw5MjIwMzc6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEopPT57ci5yYShcIlJlc2l6ZVwiLGwse2FudGlhbGlhczpwLGF4ZXM6aD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoQz4+PjAsQytoPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOl9lKFQpLGN1YmljQ29lZmZBOlUsZXhjbHVkZU91dHNpZGU6RyxleHRyYXBvbGF0aW9uVmFsdWU6dWUsa2VlcEFzcGVjdFJhdGlvUG9saWN5Ol9lKFkpLG1vZGU6X2UoUSksbmVhcmVzdE1vZGU6X2UoSil9KX0sOTIyMzg4OihsLHAsaCxDLFQsVSxHKT0+e3IucmEoXCJTbGljZVwiLGwse3N0YXJ0czpwP0FycmF5LmZyb20oQi5zdWJhcnJheShoPj4+MCxoK3A+Pj4wKSk6W10sZW5kczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W10sYXhlczpVP0FycmF5LmZyb20oQi5zdWJhcnJheShHPj4+MCxHK1U+Pj4wKSk6W119KX0sOTIyNjE5Omw9PntyLnJhKFwiVGlsZVwiLGwsdm9pZCAwKX0sOTIyNjcxOihsLHAsaCk9PntyLnJhKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsbCx7YXhpczpOdW1iZXIocCksZXBzaWxvbjpOdW1iZXIoaCl9KX0sOTIyNzc4OihsLHAsaCk9PntyLnJhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsbCx7ZXBzaWxvbjpwLGZvcm1hdDpoP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMjg5MjoobCxwLGgpPT57ci5yYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGwse2Vwc2lsb246cCxmb3JtYXQ6aD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjMwMDY6bD0+e3IucmEoXCJSYW5nZVwiLGwsdm9pZCAwKX0sOTIzMDU5OihsLHApPT57ci5yYShcIkVpbnN1bVwiLGwse2VxdWF0aW9uOl9lKHApfSl9LDkyMzE0MDoobCxwLGgsQyxUKT0+e3IucmEoXCJQYWRcIixsLHttb2RlOnAsdmFsdWU6aCxwYWRzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MjMyNzI6bD0+e3IucmEoXCJHZWx1XCIsbCx2b2lkIDApfSw5MjMzMjQ6bD0+e3IucmEoXCJCaWFzQWRkXCIsbCx2b2lkIDApfSw5MjMzNzk6bD0+e3IucmEoXCJCaWFzU3BsaXRHZWx1XCIsbCx2b2lkIDApfSw5MjM0NDA6KGwscCk9PntyLnJhKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLGwse2Vwc2lsb246cH0pfSw5MjM1MjE6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUpPT57ci5yYShcIkNvbnZcIixsLHtmb3JtYXQ6WT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpwLGRpbGF0aW9uczpbaF0sZ3JvdXA6QyxrZXJuZWxfc2hhcGU6W1RdLHBhZHM6VT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoRz4+PjAsRytVPj4+MCkpOltdLHN0cmlkZXM6W3VlXSx3X2lzX2NvbnN0OigpPT4hIXFbUT4+PjBdLGFjdGl2YXRpb246X2UoSiksYWN0aXZhdGlvbl9wYXJhbXM6Y2U/QXJyYXkuZnJvbSh4ZS5zdWJhcnJheShtZT4+PjAsbWUrY2U+Pj4wKSk6W119KX0sOTIzOTAyOihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIkNvbnZcIixsLHtmb3JtYXQ6Y2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6cCxkaWxhdGlvbnM6W2gsQ10sZ3JvdXA6VCxrZXJuZWxfc2hhcGU6W1UsR10scGFkczp1ZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoWT4+PjAsWSt1ZT4+PjApKTpbXSxzdHJpZGVzOltRLEpdLHdfaXNfY29uc3Q6KCk9PiEhcVttZT4+PjBdLGFjdGl2YXRpb246X2UoRSksYWN0aXZhdGlvbl9wYXJhbXM6dGU/QXJyYXkuZnJvbSh4ZS5zdWJhcnJheShmZT4+PjAsZmUrdGU+Pj4wKSk6W119KX0sOTI0MzA0Omw9PntyLlJhKGwpfSw5MjQzMzg6KGwscCk9PnIuU2EobCxwLHIuRGEuVGEsci5EYS5lcnJvcnMpLDkyNDQ1MDpsPT5yLk9hKGwpLDkyNDQ4MzpsPT5yLlFhKGwpLDkyNDUxNToobCxwLGgpPT57ci5KYShsLHAsaCwhMCl9LDkyNDU1NDoobCxwLGgpPT57ci5KYShsLHAsaCl9fTtmdW5jdGlvbiBGZShsKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7bH0pYCx0aGlzLnN0YXR1cz1sfXZhciB5dD1sPT57Zm9yKDswPGwubGVuZ3RoOylsLnNoaWZ0KCkocil9O2Z1bmN0aW9uIGJ0KGwpe3RoaXMuSGE9bC0yNCx0aGlzLk1hPWZ1bmN0aW9uKHApe0tbdGhpcy5IYSs0Pj4yPj4+MF09cH0sdGhpcy5MYT1mdW5jdGlvbihwKXtLW3RoaXMuSGErOD4+Mj4+PjBdPXB9LHRoaXMuWWE9ZnVuY3Rpb24ocCxoKXt0aGlzLkthKCksdGhpcy5NYShwKSx0aGlzLkxhKGgpfSx0aGlzLkthPWZ1bmN0aW9uKCl7S1t0aGlzLkhhKzE2Pj4yPj4+MF09MH19dmFyIEJ0PTAsbHI9MCxLZT10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsa3Q9KGwscCxoKT0+e3A+Pj49MDt2YXIgQz1wK2g7Zm9yKGg9cDtsW2hdJiYhKGg+PUMpOykrK2g7aWYoMTY8aC1wJiZsLmJ1ZmZlciYmS2UpcmV0dXJuIEtlLmRlY29kZShsLnN1YmFycmF5KHAsaCkpO2ZvcihDPVwiXCI7cDxoOyl7dmFyIFQ9bFtwKytdO2lmKFQmMTI4KXt2YXIgVT1sW3ArK10mNjM7aWYoKFQmMjI0KT09MTkyKUMrPVN0cmluZy5mcm9tQ2hhckNvZGUoKFQmMzEpPDw2fFUpO2Vsc2V7dmFyIEc9bFtwKytdJjYzO1Q9KFQmMjQwKT09MjI0PyhUJjE1KTw8MTJ8VTw8NnxHOihUJjcpPDwxOHxVPDwxMnxHPDw2fGxbcCsrXSY2Myw2NTUzNj5UP0MrPVN0cmluZy5mcm9tQ2hhckNvZGUoVCk6KFQtPTY1NTM2LEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8VD4+MTAsNTYzMjB8VCYxMDIzKSl9fWVsc2UgQys9U3RyaW5nLmZyb21DaGFyQ29kZShUKX1yZXR1cm4gQ30sX2U9KGwscCk9PihsPj4+PTApP2t0KGxlLGwscCk6XCJcIixJdD1sPT57Zm9yKHZhciBwPTAsaD0wO2g8bC5sZW5ndGg7KytoKXt2YXIgQz1sLmNoYXJDb2RlQXQoaCk7MTI3Pj1DP3ArKzoyMDQ3Pj1DP3ArPTI6NTUyOTY8PUMmJjU3MzQzPj1DPyhwKz00LCsraCk6cCs9M31yZXR1cm4gcH0sRHQ9KGwscCxoLEMpPT57aWYoaD4+Pj0wLCEoMDxDKSlyZXR1cm4gMDt2YXIgVD1oO0M9aCtDLTE7Zm9yKHZhciBVPTA7VTxsLmxlbmd0aDsrK1Upe3ZhciBHPWwuY2hhckNvZGVBdChVKTtpZig1NTI5Njw9RyYmNTczNDM+PUcpe3ZhciB1ZT1sLmNoYXJDb2RlQXQoKytVKTtHPTY1NTM2KygoRyYxMDIzKTw8MTApfHVlJjEwMjN9aWYoMTI3Pj1HKXtpZihoPj1DKWJyZWFrO3BbaCsrPj4+MF09R31lbHNle2lmKDIwNDc+PUcpe2lmKGgrMT49QylicmVhaztwW2grKz4+PjBdPTE5MnxHPj42fWVsc2V7aWYoNjU1MzU+PUcpe2lmKGgrMj49QylicmVhaztwW2grKz4+PjBdPTIyNHxHPj4xMn1lbHNle2lmKGgrMz49QylicmVhaztwW2grKz4+PjBdPTI0MHxHPj4xOCxwW2grKz4+PjBdPTEyOHxHPj4xMiY2M31wW2grKz4+PjBdPTEyOHxHPj42JjYzfXBbaCsrPj4+MF09MTI4fEcmNjN9fXJldHVybiBwW2g+Pj4wXT0wLGgtVH0sYXQ9bD0+bCU0PT09MCYmKGwlMTAwIT09MHx8bCU0MDA9PT0wKSxkcj1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxpdD1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XSxFdD1sPT57dmFyIHA9SXQobCkrMSxoPVJ0KHApO3JldHVybiBoJiZEdChsLGxlLGgscCksaH0sY3Q9W10sVHQ9KGwscCk9PntjdC5sZW5ndGg9MDt2YXIgaDtmb3IocD4+PTI7aD1sZVtsKys+Pj4wXTspcCs9aCE9MTA1JnAsY3QucHVzaChoPT0xMDU/QltwPj4+MF06YWVbcCsrPj4+MV0pLCsrcDtyZXR1cm4gY3R9LE90PXt9LFd0PSgpPT57aWYoIV90KXt2YXIgbD17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzp1fHxcIi4vdGhpcy5wcm9ncmFtXCJ9LHA7Zm9yKHAgaW4gT3QpT3RbcF09PT12b2lkIDA/ZGVsZXRlIGxbcF06bFtwXT1PdFtwXTt2YXIgaD1bXTtmb3IocCBpbiBsKWgucHVzaChgJHtwfT0ke2xbcF19YCk7X3Q9aH1yZXR1cm4gX3R9LF90LGNyPVtudWxsLFtdLFtdXSxWZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLHp0PVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gVnQobCl7dmFyIHA9QXJyYXkoSXQobCkrMSk7cmV0dXJuIER0KGwscCwwLHAubGVuZ3RoKSxwfWZ1bmN0aW9uIG5lKGwscCxoLEMpe2Z1bmN0aW9uIFQoRSx0ZSxmZSl7Zm9yKEU9dHlwZW9mIEU9PVwibnVtYmVyXCI/RS50b1N0cmluZygpOkV8fFwiXCI7RS5sZW5ndGg8dGU7KUU9ZmVbMF0rRTtyZXR1cm4gRX1mdW5jdGlvbiBVKEUsdGUpe3JldHVybiBUKEUsdGUsXCIwXCIpfWZ1bmN0aW9uIEcoRSx0ZSl7ZnVuY3Rpb24gZmUoWHQpe3JldHVybiAwPlh0Py0xOjA8WHQ/MTowfXZhciB1dDtyZXR1cm4odXQ9ZmUoRS5nZXRGdWxsWWVhcigpLXRlLmdldEZ1bGxZZWFyKCkpKT09PTAmJih1dD1mZShFLmdldE1vbnRoKCktdGUuZ2V0TW9udGgoKSkpPT09MCYmKHV0PWZlKEUuZ2V0RGF0ZSgpLXRlLmdldERhdGUoKSkpLHV0fWZ1bmN0aW9uIHVlKEUpe3N3aXRjaChFLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIEU7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIFkoRSl7dmFyIHRlPUUuQmE7Zm9yKEU9bmV3IERhdGUobmV3IERhdGUoRS5DYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHRlOyl7dmFyIGZlPUUuZ2V0TW9udGgoKSx1dD0oYXQoRS5nZXRGdWxsWWVhcigpKT9WZTp6dClbZmVdO2lmKHRlPnV0LUUuZ2V0RGF0ZSgpKXRlLT11dC1FLmdldERhdGUoKSsxLEUuc2V0RGF0ZSgxKSwxMT5mZT9FLnNldE1vbnRoKGZlKzEpOihFLnNldE1vbnRoKDApLEUuc2V0RnVsbFllYXIoRS5nZXRGdWxsWWVhcigpKzEpKTtlbHNle0Uuc2V0RGF0ZShFLmdldERhdGUoKSt0ZSk7YnJlYWt9fXJldHVybiBmZT1uZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHRlPXVlKG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDQpKSxmZT11ZShmZSksMD49Ryh0ZSxFKT8wPj1HKGZlLEUpP0UuZ2V0RnVsbFllYXIoKSsxOkUuZ2V0RnVsbFllYXIoKTpFLmdldEZ1bGxZZWFyKCktMX1sPj4+PTAscD4+Pj0wLGg+Pj49MCxDPj4+PTA7dmFyIFE9QltDKzQwPj4yPj4+MF07Qz17V2E6QltDPj4yPj4+MF0sVmE6QltDKzQ+PjI+Pj4wXSxFYTpCW0MrOD4+Mj4+PjBdLElhOkJbQysxMj4+Mj4+PjBdLEZhOkJbQysxNj4+Mj4+PjBdLENhOkJbQysyMD4+Mj4+PjBdLHdhOkJbQysyND4+Mj4+PjBdLEJhOkJbQysyOD4+Mj4+PjBdLCRhOkJbQyszMj4+Mj4+PjBdLFVhOkJbQyszNj4+Mj4+PjBdLFhhOlE/X2UoUSk6XCJcIn0saD1fZShoKSxRPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciBKIGluIFEpaD1oLnJlcGxhY2UobmV3IFJlZ0V4cChKLFwiZ1wiKSxRW0pdKTt2YXIgY2U9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxtZT1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7UT17XCIlYVwiOkU9PmNlW0Uud2FdLnN1YnN0cmluZygwLDMpLFwiJUFcIjpFPT5jZVtFLndhXSxcIiViXCI6RT0+bWVbRS5GYV0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOkU9Pm1lW0UuRmFdLFwiJUNcIjpFPT5VKChFLkNhKzE5MDApLzEwMHwwLDIpLFwiJWRcIjpFPT5VKEUuSWEsMiksXCIlZVwiOkU9PlQoRS5JYSwyLFwiIFwiKSxcIiVnXCI6RT0+WShFKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6RT0+WShFKSxcIiVIXCI6RT0+VShFLkVhLDIpLFwiJUlcIjpFPT4oRT1FLkVhLEU9PTA/RT0xMjoxMjxFJiYoRS09MTIpLFUoRSwyKSksXCIlalwiOkU9Pntmb3IodmFyIHRlPTAsZmU9MDtmZTw9RS5GYS0xO3RlKz0oYXQoRS5DYSsxOTAwKT9WZTp6dClbZmUrK10pO3JldHVybiBVKEUuSWErdGUsMyl9LFwiJW1cIjpFPT5VKEUuRmErMSwyKSxcIiVNXCI6RT0+VShFLlZhLDIpLFwiJW5cIjooKT0+YFxcbmAsXCIlcFwiOkU9PjA8PUUuRWEmJjEyPkUuRWE/XCJBTVwiOlwiUE1cIixcIiVTXCI6RT0+VShFLldhLDIpLFwiJXRcIjooKT0+XCJcdFwiLFwiJXVcIjpFPT5FLndhfHw3LFwiJVVcIjpFPT5VKE1hdGguZmxvb3IoKEUuQmErNy1FLndhKS83KSwyKSxcIiVWXCI6RT0+e3ZhciB0ZT1NYXRoLmZsb29yKChFLkJhKzctKEUud2ErNiklNykvNyk7aWYoMj49KEUud2ErMzcxLUUuQmEtMiklNyYmdGUrKyx0ZSl0ZT09NTMmJihmZT0oRS53YSszNzEtRS5CYSklNyxmZT09NHx8ZmU9PTMmJmF0KEUuQ2EpfHwodGU9MSkpO2Vsc2V7dGU9NTI7dmFyIGZlPShFLndhKzctRS5CYS0xKSU3OyhmZT09NHx8ZmU9PTUmJmF0KEUuQ2ElNDAwLTEpKSYmdGUrK31yZXR1cm4gVSh0ZSwyKX0sXCIld1wiOkU9PkUud2EsXCIlV1wiOkU9PlUoTWF0aC5mbG9vcigoRS5CYSs3LShFLndhKzYpJTcpLzcpLDIpLFwiJXlcIjpFPT4oRS5DYSsxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6RT0+RS5DYSsxOTAwLFwiJXpcIjpFPT57RT1FLlVhO3ZhciB0ZT0wPD1FO3JldHVybiBFPU1hdGguYWJzKEUpLzYwLCh0ZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyhFLzYwKjEwMCtFJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6RT0+RS5YYSxcIiUlXCI6KCk9PlwiJVwifSxoPWgucmVwbGFjZSgvJSUvZyxcIlxcXFwwXFxcXDBcIik7Zm9yKEogaW4gUSloLmluY2x1ZGVzKEopJiYoaD1oLnJlcGxhY2UobmV3IFJlZ0V4cChKLFwiZ1wiKSxRW0pdKEMpKSk7cmV0dXJuIGg9aC5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpLEo9VnQoaCksSi5sZW5ndGg+cD8wOihxLnNldChKLGw+Pj4wKSxKLmxlbmd0aC0xKX1mdW5jdGlvbiBzdChsKXt0cnl7bCgpfWNhdGNoKHApe0xlKHApfX1mdW5jdGlvbiBwcihsKXt2YXIgcD17fSxoO2ZvcihoIGluIGwpKGZ1bmN0aW9uKEMpe3ZhciBUPWxbQ107cFtDXT10eXBlb2YgVD09XCJmdW5jdGlvblwiP2Z1bmN0aW9uKCl7d3QucHVzaChDKTt0cnl7cmV0dXJuIFQuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZpbmFsbHl7enx8KHd0LnBvcCgpPT09Q3x8TGUoKSxIZSYmSmU9PT0xJiZ3dC5sZW5ndGg9PT0wJiYoSmU9MCxzdChxdCksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLmFiKCkpKX19OlR9KShoKTtyZXR1cm4gcH12YXIgSmU9MCxIZT1udWxsLGZyPTAsd3Q9W10sR3Q9e30sTnQ9e30sbXI9MCx2dD1udWxsLGhyPVtdO2Z1bmN0aW9uIGdyKCl7cmV0dXJuIG5ldyBQcm9taXNlKChsLHApPT57dnQ9e3Jlc29sdmU6bCxyZWplY3Q6cH19KX1mdW5jdGlvbiB5cigpe3ZhciBsPVJ0KDY1NTQ4KSxwPWwrMTI7S1tsPj4yPj4+MF09cCxLW2wrND4+Mj4+PjBdPXArNjU1MzYscD13dFswXTt2YXIgaD1HdFtwXTtyZXR1cm4gaD09PXZvaWQgMCYmKGg9bXIrKyxHdFtwXT1oLE50W2hdPXApLEJbbCs4Pj4yPj4+MF09aCxsfWZ1bmN0aW9uIGJyKGwpe2lmKCF6KXtpZihKZT09PTApe3ZhciBwPSExLGg9ITE7bCgoQz0wKT0+e2lmKCF6JiYoZnI9QyxwPSEwLGgpKXtKZT0yLHN0KCgpPT5QdChIZSkpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkdhLk5hJiZCcm93c2VyLkdhLnJlc3VtZSgpLEM9ITE7dHJ5e3ZhciBUPSgwLF9bTnRbQltIZSs4Pj4yPj4+MF1dXSkoKX1jYXRjaCh1ZSl7VD11ZSxDPSEwfXZhciBVPSExO2lmKCFIZSl7dmFyIEc9dnQ7RyYmKHZ0PW51bGwsKEM/Ry5yZWplY3Q6Ry5yZXNvbHZlKShUKSxVPSEwKX1pZihDJiYhVSl0aHJvdyBUfX0pLGg9ITAscHx8KEplPTEsSGU9eXIoKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5HYS5OYSYmQnJvd3Nlci5HYS5wYXVzZSgpLHN0KCgpPT5LdChIZSkpKX1lbHNlIEplPT09Mj8oSmU9MCxzdCgkdCksVXQoSGUpLEhlPW51bGwsaHIuZm9yRWFjaChDPT57aWYoIXopdHJ5e2lmKEMoKSwhTSl0cnl7Rj1GPUM9RixNfHwoci5vbkV4aXQmJnIub25FeGl0KEMpLHo9ITApLGQoQyxuZXcgRmUoQykpfWNhdGNoKFQpe1QgaW5zdGFuY2VvZiBGZXx8VD09XCJ1bndpbmRcInx8ZCgxLFQpfX1jYXRjaChUKXtUIGluc3RhbmNlb2YgRmV8fFQ9PVwidW53aW5kXCJ8fGQoMSxUKX19KSk6TGUoYGludmFsaWQgc3RhdGU6ICR7SmV9YCk7cmV0dXJuIGZyfX1mdW5jdGlvbiB3cihsKXtyZXR1cm4gYnIocD0+e2woKS50aGVuKHApfSl9dmFyIHZyPXtuOmZ1bmN0aW9uKGwscCxoKXtyZXR1cm4gd3IoYXN5bmMoKT0+e2F3YWl0IHIuUGEobCxwLGgpfSl9LGE6ZnVuY3Rpb24obCxwLGgpe3Rocm93IGw+Pj49MCxuZXcgYnQobCkuWWEocD4+PjAsaD4+PjApLEJ0PWwsbHIrKyxCdH0sZzpmdW5jdGlvbigpe3JldHVybiAwfSxKOmZ1bmN0aW9uKCl7fSx6OmZ1bmN0aW9uKCl7fSxCOmZ1bmN0aW9uKCl7fSxMOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEg6ZnVuY3Rpb24oKXt9LEM6ZnVuY3Rpb24oKXt9LEc6ZnVuY3Rpb24oKXt9LGw6ZnVuY3Rpb24oKXt9LEE6ZnVuY3Rpb24oKXt9LHg6ZnVuY3Rpb24oKXt9LEk6ZnVuY3Rpb24oKXt9LHk6ZnVuY3Rpb24oKXt9LG06KCk9PiEwLHE6ZnVuY3Rpb24obCxwLGgpe2w9cCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhbD8obD4+PjApKzQyOTQ5NjcyOTYqcDpOYU4saD4+Pj0wLGw9bmV3IERhdGUoMWUzKmwpLEJbaD4+Mj4+PjBdPWwuZ2V0VVRDU2Vjb25kcygpLEJbaCs0Pj4yPj4+MF09bC5nZXRVVENNaW51dGVzKCksQltoKzg+PjI+Pj4wXT1sLmdldFVUQ0hvdXJzKCksQltoKzEyPj4yPj4+MF09bC5nZXRVVENEYXRlKCksQltoKzE2Pj4yPj4+MF09bC5nZXRVVENNb250aCgpLEJbaCsyMD4+Mj4+PjBdPWwuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLEJbaCsyND4+Mj4+PjBdPWwuZ2V0VVRDRGF5KCksQltoKzI4Pj4yPj4+MF09KGwuZ2V0VGltZSgpLURhdGUuVVRDKGwuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LHI6ZnVuY3Rpb24obCxwLGgpe2w9cCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhbD8obD4+PjApKzQyOTQ5NjcyOTYqcDpOYU4saD4+Pj0wLGw9bmV3IERhdGUoMWUzKmwpLEJbaD4+Mj4+PjBdPWwuZ2V0U2Vjb25kcygpLEJbaCs0Pj4yPj4+MF09bC5nZXRNaW51dGVzKCksQltoKzg+PjI+Pj4wXT1sLmdldEhvdXJzKCksQltoKzEyPj4yPj4+MF09bC5nZXREYXRlKCksQltoKzE2Pj4yPj4+MF09bC5nZXRNb250aCgpLEJbaCsyMD4+Mj4+PjBdPWwuZ2V0RnVsbFllYXIoKS0xOTAwLEJbaCsyND4+Mj4+PjBdPWwuZ2V0RGF5KCksQltoKzI4Pj4yPj4+MF09KGF0KGwuZ2V0RnVsbFllYXIoKSk/ZHI6aXQpW2wuZ2V0TW9udGgoKV0rbC5nZXREYXRlKCktMXwwLEJbaCszNj4+Mj4+PjBdPS0oNjAqbC5nZXRUaW1lem9uZU9mZnNldCgpKSxwPW5ldyBEYXRlKGwuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEM9bmV3IERhdGUobC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtCW2grMzI+PjI+Pj4wXT0ocCE9QyYmbC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihDLHApKXwwfSxzOmZ1bmN0aW9uKGwpe2w+Pj49MDt2YXIgcD1uZXcgRGF0ZShCW2wrMjA+PjI+Pj4wXSsxOTAwLEJbbCsxNj4+Mj4+PjBdLEJbbCsxMj4+Mj4+PjBdLEJbbCs4Pj4yPj4+MF0sQltsKzQ+PjI+Pj4wXSxCW2w+PjI+Pj4wXSwwKSxoPUJbbCszMj4+Mj4+PjBdLEM9cC5nZXRUaW1lem9uZU9mZnNldCgpLFQ9bmV3IERhdGUocC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxVPW5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCksRz1NYXRoLm1pbihVLFQpO3JldHVybiAwPmg/QltsKzMyPj4yPj4+MF09KyhUIT1VJiZHPT1DKTowPGghPShHPT1DKSYmKFQ9TWF0aC5tYXgoVSxUKSxwLnNldFRpbWUocC5nZXRUaW1lKCkrNmU0KigoMDxoP0c6VCktQykpKSxCW2wrMjQ+PjI+Pj4wXT1wLmdldERheSgpLEJbbCsyOD4+Mj4+PjBdPShhdChwLmdldEZ1bGxZZWFyKCkpP2RyOml0KVtwLmdldE1vbnRoKCldK3AuZ2V0RGF0ZSgpLTF8MCxCW2w+PjI+Pj4wXT1wLmdldFNlY29uZHMoKSxCW2wrND4+Mj4+PjBdPXAuZ2V0TWludXRlcygpLEJbbCs4Pj4yPj4+MF09cC5nZXRIb3VycygpLEJbbCsxMj4+Mj4+PjBdPXAuZ2V0RGF0ZSgpLEJbbCsxNj4+Mj4+PjBdPXAuZ2V0TW9udGgoKSxCW2wrMjA+PjI+Pj4wXT1wLmdldFllYXIoKSxsPXAuZ2V0VGltZSgpLzFlMyxMdCgoR2U9bCwxPD0rTWF0aC5hYnMoR2UpPzA8R2U/K01hdGguZmxvb3IoR2UvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgoR2UtKyh+fkdlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKSksbD4+PjB9LG86ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHA6ZnVuY3Rpb24oKXt9LHY6ZnVuY3Rpb24obCxwLGgpe2Z1bmN0aW9uIEMoWSl7cmV0dXJuKFk9WS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFxcXCgoW0EtWmEteiBdKylcXFxcKSQvKSk/WVsxXTpcIkdNVFwifWg+Pj49MDt2YXIgVD1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksVT1uZXcgRGF0ZShULDAsMSksRz1uZXcgRGF0ZShULDYsMSk7VD1VLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHVlPUcuZ2V0VGltZXpvbmVPZmZzZXQoKTtLW2w+Pj4wPj4yPj4+MF09NjAqTWF0aC5tYXgoVCx1ZSksQltwPj4+MD4+Mj4+PjBdPSsoVCE9dWUpLGw9QyhVKSxwPUMoRyksbD1FdChsKSxwPUV0KHApLHVlPFQ/KEtbaD4+Mj4+PjBdPWwsS1toKzQ+PjI+Pj4wXT1wKTooS1toPj4yPj4+MF09cCxLW2grND4+Mj4+PjBdPWwpfSxlOigpPT57TGUoXCJcIil9LGI6ZnVuY3Rpb24obCxwLGgpe3JldHVybiBsPj4+PTAscD1UdChwPj4+MCxoPj4+MCksWGVbbF0uYXBwbHkobnVsbCxwKX0saTpmdW5jdGlvbihsLHAsaCl7cmV0dXJuIGw+Pj49MCxwPVR0KHA+Pj4wLGg+Pj4wKSxYZVtsXS5hcHBseShudWxsLHApfSxoOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LHc6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sYzooKT0+cGVyZm9ybWFuY2Uubm93KCksSzpmdW5jdGlvbihsLHAsaCl7cmV0dXJuIHA+Pj49MCxsZS5jb3B5V2l0aGluKGw+Pj4wPj4+MCxwPj4+MCxwKyhoPj4+MCk+Pj4wKX0sdTpmdW5jdGlvbihsKXtsPj4+PTA7dmFyIHA9bGUubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8bClyZXR1cm4hMTtmb3IodmFyIGg9MTs0Pj1oO2gqPTIpe3ZhciBDPXAqKDErLjIvaCk7Qz1NYXRoLm1pbihDLGwrMTAwNjYzMjk2KTt2YXIgVD1NYXRoO0M9TWF0aC5tYXgobCxDKTtlOntUPVQubWluLmNhbGwoVCw0Mjk0OTAxNzYwLEMrKDY1NTM2LUMlNjU1MzYpJTY1NTM2KS1ELmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTY7dHJ5e0QuZ3JvdyhUKSx3ZSgpO3ZhciBVPTE7YnJlYWsgZX1jYXRjaHt9VT12b2lkIDB9aWYoVSlyZXR1cm4hMH1yZXR1cm4hMX0sRDpmdW5jdGlvbihsLHApe2w+Pj49MCxwPj4+PTA7dmFyIGg9MDtyZXR1cm4gV3QoKS5mb3JFYWNoKGZ1bmN0aW9uKEMsVCl7dmFyIFU9cCtoO2ZvcihUPUtbbCs0KlQ+PjI+Pj4wXT1VLFU9MDtVPEMubGVuZ3RoOysrVSlxW1QrKz4+MD4+PjBdPUMuY2hhckNvZGVBdChVKTtxW1Q+PjA+Pj4wXT0wLGgrPUMubGVuZ3RoKzF9KSwwfSxFOmZ1bmN0aW9uKGwscCl7bD4+Pj0wLHA+Pj49MDt2YXIgaD1XdCgpO0tbbD4+Mj4+PjBdPWgubGVuZ3RoO3ZhciBDPTA7cmV0dXJuIGguZm9yRWFjaChmdW5jdGlvbihUKXtDKz1ULmxlbmd0aCsxfSksS1twPj4yPj4+MF09QywwfSxmOigpPT41MixrOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSx0OmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxqOmZ1bmN0aW9uKGwscCxoLEMpe3A+Pj49MCxoPj4+PTAsQz4+Pj0wO2Zvcih2YXIgVD0wLFU9MDtVPGg7VSsrKXt2YXIgRz1LW3A+PjI+Pj4wXSx1ZT1LW3ArND4+Mj4+PjBdO3ArPTg7Zm9yKHZhciBZPTA7WTx1ZTtZKyspe3ZhciBRPWxlW0crWT4+PjBdLEo9Y3JbbF07UT09PTB8fFE9PT0xMD8oKGw9PT0xP0E6Uikoa3QoSiwwKSksSi5sZW5ndGg9MCk6Si5wdXNoKFEpfVQrPXVlfXJldHVybiBLW0M+PjI+Pj4wXT1ULDB9LEY6bmUsZDpmdW5jdGlvbihsLHAsaCxDKXtyZXR1cm4gbmUobD4+PjAscD4+PjAsaD4+PjAsQz4+PjApfX07KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbChoKXtpZihoPWguZXhwb3J0cyxoPXByKGgpLF89aD1wdChoKSxEPV8uTSx3ZSgpLFNlLnVuc2hpZnQoXy5OKSxDZS0tLHIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKENlKSxDZT09MCYmKGR0IT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoZHQpLGR0PW51bGwpLE5lKSl7dmFyIEM9TmU7TmU9bnVsbCxDKCl9cmV0dXJuIGh9dmFyIHA9e2E6dnJ9O2lmKENlKyssci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoQ2UpLHIuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gci5pbnN0YW50aWF0ZVdhc20ocCxsKX1jYXRjaChoKXtSKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIraCksbihoKX1yZXR1cm4ga2UocCxmdW5jdGlvbihoKXtsKGguaW5zdGFuY2UpfSkuY2F0Y2gobikse319KSgpLHIuX09ydEluaXQ9KGwscCk9PihyLl9PcnRJbml0PV8uTykobCxwKSxyLl9PcnRHZXRMYXN0RXJyb3I9KGwscCk9PihyLl9PcnRHZXRMYXN0RXJyb3I9Xy5QKShsLHApLHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShsLHAsaCxDLFQsVSxHLHVlLFksUSk9PihyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1fLlEpKGwscCxoLEMsVCxVLEcsdWUsWSxRKSxyLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0obCxwKT0+KHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPV8uUikobCxwKSxyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KGwscCxoKT0+KHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1fLlMpKGwscCxoKSxyLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KGwscCxoKT0+KHIuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1fLlQpKGwscCxoKSxyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9bD0+KHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1fLlUpKGwpLHIuX09ydENyZWF0ZVNlc3Npb249KGwscCxoKT0+KHIuX09ydENyZWF0ZVNlc3Npb249Xy5WKShsLHAsaCksci5fT3J0UmVsZWFzZVNlc3Npb249bD0+KHIuX09ydFJlbGVhc2VTZXNzaW9uPV8uVykobCksci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0obCxwLGgpPT4oci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1fLlgpKGwscCxoKSxyLl9PcnRHZXRJbnB1dE5hbWU9KGwscCk9PihyLl9PcnRHZXRJbnB1dE5hbWU9Xy5ZKShsLHApLHIuX09ydEdldE91dHB1dE5hbWU9KGwscCk9PihyLl9PcnRHZXRPdXRwdXROYW1lPV8uWikobCxwKSxyLl9PcnRGcmVlPWw9PihyLl9PcnRGcmVlPV8uXykobCksci5fT3J0Q3JlYXRlVGVuc29yPShsLHAsaCxDLFQsVSk9PihyLl9PcnRDcmVhdGVUZW5zb3I9Xy4kKShsLHAsaCxDLFQsVSksci5fT3J0R2V0VGVuc29yRGF0YT0obCxwLGgsQyxUKT0+KHIuX09ydEdldFRlbnNvckRhdGE9Xy5hYSkobCxwLGgsQyxUKSxyLl9PcnRSZWxlYXNlVGVuc29yPWw9PihyLl9PcnRSZWxlYXNlVGVuc29yPV8uYmEpKGwpLHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGwscCxoLEMpPT4oci5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1fLmNhKShsLHAsaCxDKSxyLl9PcnRBZGRSdW5Db25maWdFbnRyeT0obCxwLGgpPT4oci5fT3J0QWRkUnVuQ29uZmlnRW50cnk9Xy5kYSkobCxwLGgpLHIuX09ydFJlbGVhc2VSdW5PcHRpb25zPWw9PihyLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1fLmVhKShsKSxyLl9PcnRDcmVhdGVCaW5kaW5nPWw9PihyLl9PcnRDcmVhdGVCaW5kaW5nPV8uZmEpKGwpLHIuX09ydEJpbmRJbnB1dD0obCxwLGgpPT4oci5fT3J0QmluZElucHV0PV8uZ2EpKGwscCxoKSxyLl9PcnRCaW5kT3V0cHV0PShsLHAsaCxDKT0+KHIuX09ydEJpbmRPdXRwdXQ9Xy5oYSkobCxwLGgsQyksci5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9bD0+KHIuX09ydENsZWFyQm91bmRPdXRwdXRzPV8uaWEpKGwpLHIuX09ydFJlbGVhc2VCaW5kaW5nPWw9PihyLl9PcnRSZWxlYXNlQmluZGluZz1fLmphKShsKSxyLl9PcnRSdW5XaXRoQmluZGluZz0obCxwLGgsQyxUKT0+KHIuX09ydFJ1bldpdGhCaW5kaW5nPV8ua2EpKGwscCxoLEMsVCksci5fT3J0UnVuPShsLHAsaCxDLFQsVSxHLHVlKT0+KHIuX09ydFJ1bj1fLmxhKShsLHAsaCxDLFQsVSxHLHVlKSxyLl9PcnRFbmRQcm9maWxpbmc9bD0+KHIuX09ydEVuZFByb2ZpbGluZz1fLm1hKShsKSxyLl9Kc2VwT3V0cHV0PShsLHAsaCk9PihyLl9Kc2VwT3V0cHV0PV8ubmEpKGwscCxoKSxyLl9Kc2VwR2V0Tm9kZU5hbWU9bD0+KHIuX0pzZXBHZXROb2RlTmFtZT1fLm9hKShsKTt2YXIgUnQ9ci5fbWFsbG9jPWw9PihSdD1yLl9tYWxsb2M9Xy5wYSkobCksVXQ9ci5fZnJlZT1sPT4oVXQ9ci5fZnJlZT1fLnFhKShsKSxMdD1sPT4oTHQ9Xy5zYSkobCksRnQ9KCk9PihGdD1fLnRhKSgpLEh0PWw9PihIdD1fLnVhKShsKSxqdD1sPT4oanQ9Xy52YSkobCksS3Q9bD0+KEt0PV8ueGEpKGwpLHF0PSgpPT4ocXQ9Xy55YSkoKSxQdD1sPT4oUHQ9Xy56YSkobCksJHQ9KCk9PigkdD1fLkFhKSgpO3IuX19fc3RhcnRfZW1fanM9OTI0NTg3LHIuX19fc3RvcF9lbV9qcz05MjQ3NDg7ZnVuY3Rpb24gcHQobCl7bD1PYmplY3QuYXNzaWduKHt9LGwpO3ZhciBwPUM9PigpPT5DKCk+Pj4wLGg9Qz0+VD0+QyhUKT4+PjA7cmV0dXJuIGwuX19lcnJub19sb2NhdGlvbj1wKGwuX19lcnJub19sb2NhdGlvbiksbC5tYWxsb2M9aChsLm1hbGxvYyksbC5zdGFja1NhdmU9cChsLnN0YWNrU2F2ZSksbC5zdGFja0FsbG9jPWgobC5zdGFja0FsbG9jKSxsfXIuc3RhY2tBbGxvYz1qdCxyLnN0YWNrU2F2ZT1GdCxyLnN0YWNrUmVzdG9yZT1IdCxyLlVURjhUb1N0cmluZz1fZSxyLnN0cmluZ1RvVVRGOD0obCxwLGgpPT5EdChsLGxlLHAsaCksci5sZW5ndGhCeXRlc1VURjg9SXQ7dmFyIHh0O05lPWZ1bmN0aW9uIGwoKXt4dHx8WXQoKSx4dHx8KE5lPWwpfTtmdW5jdGlvbiBZdCgpe2Z1bmN0aW9uIGwoKXtpZigheHQmJih4dD0hMCxyLmNhbGxlZFJ1bj0hMCwheikpe2lmKHl0KFNlKSxvKHIpLHIub25SdW50aW1lSW5pdGlhbGl6ZWQmJnIub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxyLnBvc3RSdW4pZm9yKHR5cGVvZiByLnBvc3RSdW49PVwiZnVuY3Rpb25cIiYmKHIucG9zdFJ1bj1bci5wb3N0UnVuXSk7ci5wb3N0UnVuLmxlbmd0aDspe3ZhciBwPXIucG9zdFJ1bi5zaGlmdCgpO09lLnVuc2hpZnQocCl9eXQoT2UpfX1pZighKDA8Q2UpKXtpZihyLnByZVJ1bilmb3IodHlwZW9mIHIucHJlUnVuPT1cImZ1bmN0aW9uXCImJihyLnByZVJ1bj1bci5wcmVSdW5dKTtyLnByZVJ1bi5sZW5ndGg7KUllKCk7eXQoaiksMDxDZXx8KHIuc2V0U3RhdHVzPyhyLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dChmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtyLnNldFN0YXR1cyhcIlwiKX0sMSksbCgpfSwxKSk6bCgpKX19aWYoci5wcmVJbml0KWZvcih0eXBlb2Ygci5wcmVJbml0PT1cImZ1bmN0aW9uXCImJihyLnByZUluaXQ9W3IucHJlSW5pdF0pOzA8ci5wcmVJbml0Lmxlbmd0aDspci5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIFl0KCksdC5yZWFkeX19KSgpO3R5cGVvZiBzbz09XCJvYmplY3RcIiYmdHlwZW9mIGRuPT1cIm9iamVjdFwiP2RuLmV4cG9ydHM9aW86dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9PmlvKX0pO3ZhciBsbz1KdCgoKT0+e30pO3ZhciBjbz1KdCgoKT0+e30pO3ZhciBwbz17fTtJcihwbyx7Y3B1czooKT0+T3V9KTt2YXIgT3UsZm89SCgoKT0+e091PXZvaWQgMH0pO3ZhciBnbz1KdCgoaG8sY24pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG1vPSgoKT0+e3ZhciBlPXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYoZT1lfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbih0PXt9KXtmdW5jdGlvbiByKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLENlfWZ1bmN0aW9uIG8oKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksZHR9ZnVuY3Rpb24gbigpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxOZX1mdW5jdGlvbiBzKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLExlfWZ1bmN0aW9uIHUoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksTn1mdW5jdGlvbiBkKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLGRlfXZhciBhPXQsbSxnO2EucmVhZHk9bmV3IFByb21pc2UoKGksYyk9PnttPWksZz1jfSksYS5qc2VwSW5pdD0oaSxjLGYsJCxJLFAsVixvZSk9PnthLlFiPWksYS53Yj1jLGEueWI9ZixhLmpiPSQsYS54Yj1JLGEuRWE9UCxhLnpiPVYsYS5BYj1vZSxjPShlZSxaLHJlKT0+KC4uLmhlKT0+e2xldCBiZT1aZSxPPVo/LigpO2hlPWVlKC4uLmhlKTtsZXQgc2U9Wj8uKCk7cmV0dXJuIE8hPT1zZSYmKGVlPXNlLHJlKE8pLFo9cmU9bnVsbCksWmUhPWJlP2h1KCk6aGV9LGY9ZWU9PmFzeW5jKC4uLlopPT57dHJ5e2lmKGEuYmIpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIGFscmVhZHkgc3RhcnRlZFwiKTtsZXQgcmU9YS5iYj17RmI6WlswXSxlcnJvcnM6W119LGhlPWF3YWl0IGVlKC4uLlopO2lmKGEuYmIhPT1yZSl0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7aS5mbHVzaCgpO2xldCBiZT1yZS5lcnJvcnM7aWYoMDxiZS5sZW5ndGgpe2xldCBPPWF3YWl0IFByb21pc2UuYWxsKGJlKTtpZihPPU8uZmlsdGVyKHNlPT5zZSksMDxPLmxlbmd0aCl0aHJvdyBFcnJvcihPLmpvaW4oYFxcbmApKX1yZXR1cm4gaGV9ZmluYWxseXthLmJiPW51bGx9fSxhLl9PcnRSdW49ZihjKGEuX09ydFJ1biwoKT0+YS5fT3J0UnVuLGVlPT5hLl9PcnRSdW49ZWUpKSxhLl9PcnRSdW5XaXRoQmluZGluZz1mKGMoYS5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PmEuX09ydFJ1bldpdGhCaW5kaW5nLGVlPT5hLl9PcnRSdW5XaXRoQmluZGluZz1lZSkpLGEuX09ydEJpbmRJbnB1dD1jKGEuX09ydEJpbmRJbnB1dCwoKT0+YS5fT3J0QmluZElucHV0LGVlPT5hLl9PcnRCaW5kSW5wdXQ9ZWUpLGEuanNlcFJlZ2lzdGVyQnVmZmVyPShlZSxaLHJlLGhlKT0+aS5yZWdpc3RlckJ1ZmZlcihlZSxaLHJlLGhlKSxhLmpzZXBVbnJlZ2lzdGVyQnVmZmVycz1lZT0+e2kudW5yZWdpc3RlckJ1ZmZlcnMoZWUpfSxhLmpzZXBHZXRCdWZmZXI9ZWU9PmkuZ2V0QnVmZmVyKGVlKSxhLmpzZXBDcmVhdGVEb3dubG9hZGVyPShlZSxaLHJlKT0+aS5jcmVhdGVEb3dubG9hZGVyKGVlLFoscmUpfTt2YXIgeD1PYmplY3QuYXNzaWduKHt9LGEpLGI9XCIuL3RoaXMucHJvZ3JhbVwiLHc9KGksYyk9Pnt0aHJvdyBjfSx2PXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIseT10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLFM9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLEE9YS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxSPVwiXCI7ZnVuY3Rpb24gVyhpKXtyZXR1cm4gYS5sb2NhdGVGaWxlP2EubG9jYXRlRmlsZShpLFIpOlIraX12YXIgTSxELF87aWYoUyl7dmFyIHo9KHNuKCksTXQoYW4pKSxGPShsbigpLE10KHVuKSk7Uj15P0YuZGlybmFtZShSKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsTT0oYyxmKT0+KGM9Yy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGMpOkYubm9ybWFsaXplKGMpLHoucmVhZEZpbGVTeW5jKGMsZj92b2lkIDA6XCJ1dGY4XCIpKSxfPWM9PihjPU0oYywhMCksYy5idWZmZXJ8fChjPW5ldyBVaW50OEFycmF5KGMpKSxjKSxEPShjLGYsJCxJPSEwKT0+e2M9Yy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGMpOkYubm9ybWFsaXplKGMpLHoucmVhZEZpbGUoYyxJP3ZvaWQgMDpcInV0ZjhcIiwoUCxWKT0+e1A/JChQKTpmKEk/Vi5idWZmZXI6Vil9KX0sIWEudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKGI9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMiksdz0oYyxmKT0+e3Rocm93IHByb2Nlc3MuZXhpdENvZGU9YyxmfSxhLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIjtsZXQgaTt0cnl7aT1sbygpfWNhdGNoKGMpe3Rocm93IGNvbnNvbGUuZXJyb3IoXFwnVGhlIFwid29ya2VyX3RocmVhZHNcIiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG5vZGUuanMgYnVpbGQgLSBwZXJoYXBzIGEgbmV3ZXIgdmVyc2lvbiBpcyBuZWVkZWQ/XFwnKSxjfWdsb2JhbC5Xb3JrZXI9aS5Xb3JrZXJ9ZWxzZSh2fHx5KSYmKHk/Uj1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoUj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksdHlwZW9mIGU8XCJ1XCImJmUmJihSPWUpLFIuaW5kZXhPZihcImJsb2I6XCIpIT09MD9SPVIuc3Vic3RyKDAsUi5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpSPVwiXCIsU3x8KE09aT0+e3ZhciBjPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYy5vcGVuKFwiR0VUXCIsaSwhMSksYy5zZW5kKG51bGwpLGMucmVzcG9uc2VUZXh0fSx5JiYoXz1pPT57dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBjLm9wZW4oXCJHRVRcIixpLCExKSxjLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsYy5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGMucmVzcG9uc2UpfSksRD0oaSxjLGYpPT57dmFyICQ9bmV3IFhNTEh0dHBSZXF1ZXN0OyQub3BlbihcIkdFVFwiLGksITApLCQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIiwkLm9ubG9hZD0oKT0+eyQuc3RhdHVzPT0yMDB8fCQuc3RhdHVzPT0wJiYkLnJlc3BvbnNlP2MoJC5yZXNwb25zZSk6ZigpfSwkLm9uZXJyb3I9ZiwkLnNlbmQobnVsbCl9KSk7UyYmdHlwZW9mIHBlcmZvcm1hbmNlPlwidVwiJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPWNvKCkucGVyZm9ybWFuY2UpO3ZhciBxPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksbGU9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1MmJihxPSguLi5pKT0+ei53cml0ZVN5bmMoMSxpLmpvaW4oXCIgXCIpK2BcXG5gKSxsZT0oLi4uaSk9Pnoud3JpdGVTeW5jKDIsaS5qb2luKFwiIFwiKStgXFxuYCkpO3ZhciBCPWEucHJpbnR8fHEsSz1hLnByaW50RXJyfHxsZTtPYmplY3QuYXNzaWduKGEseCkseD1udWxsLGEudGhpc1Byb2dyYW0mJihiPWEudGhpc1Byb2dyYW0pLGEucXVpdCYmKHc9YS5xdWl0KTt2YXIgeGU7YS53YXNtQmluYXJ5JiYoeGU9YS53YXNtQmluYXJ5KTt2YXIgYWU9YS5ub0V4aXRSdW50aW1lfHwhMDt0eXBlb2YgV2ViQXNzZW1ibHkhPVwib2JqZWN0XCImJktlKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgd2UsaixTZSxPZT0hMSxJZSxDZSxkdCxOZSxMZSxOLGRlO2Z1bmN0aW9uIHBlKCl7dmFyIGk9d2UuYnVmZmVyO2EuSEVBUDg9Q2U9bmV3IEludDhBcnJheShpKSxhLkhFQVAxNj1uZXcgSW50MTZBcnJheShpKSxhLkhFQVAzMj1OZT1uZXcgSW50MzJBcnJheShpKSxhLkhFQVBVOD1kdD1uZXcgVWludDhBcnJheShpKSxhLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGkpLGEuSEVBUFUzMj1MZT1uZXcgVWludDMyQXJyYXkoaSksYS5IRUFQRjMyPU49bmV3IEZsb2F0MzJBcnJheShpKSxhLkhFQVBGNjQ9ZGU9bmV3IEZsb2F0NjRBcnJheShpKX12YXIgemU9YS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7aWYoNTI0Mjg4MDw9emV8fEtlKFwiSU5JVElBTF9NRU1PUlkgc2hvdWxkIGJlIGxhcmdlciB0aGFuIFNUQUNLX1NJWkUsIHdhcyBcIit6ZStcIiEgKFNUQUNLX1NJWkU9NTI0Mjg4MClcIiksQSl3ZT1hLndhc21NZW1vcnk7ZWxzZSBpZihhLndhc21NZW1vcnkpd2U9YS53YXNtTWVtb3J5O2Vsc2UgaWYod2U9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDp6ZS82NTUzNixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pLCEod2UuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IEsoXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksUyYmSyhcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kL29yIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7cGUoKSx6ZT13ZS5idWZmZXIuYnl0ZUxlbmd0aDt2YXIgVWU9W10sVGU9W10sa2U9W10sR2U9MDtmdW5jdGlvbiBYZSgpe3JldHVybiBhZXx8MDxHZX12YXIgRmU9MCx5dD1udWxsLGJ0PW51bGw7ZnVuY3Rpb24gQnQoKXtGZSsrLGEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmYS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEZlKX1mdW5jdGlvbiBscigpe2lmKEZlLS0sYS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZhLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoRmUpLEZlPT0wJiYoeXQhPT1udWxsJiYoY2xlYXJJbnRlcnZhbCh5dCkseXQ9bnVsbCksYnQpKXt2YXIgaT1idDtidD1udWxsLGkoKX19ZnVuY3Rpb24gS2UoaSl7dGhyb3cgYS5vbkFib3J0JiZhLm9uQWJvcnQoaSksaT1cIkFib3J0ZWQoXCIraStcIilcIixLKGkpLE9lPSEwLEllPTEsaT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGkrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGcoaSksaX1mdW5jdGlvbiBrdChpKXtyZXR1cm4gaS5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX12YXIgX2U7X2U9XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIixrdChfZSl8fChfZT1XKF9lKSk7ZnVuY3Rpb24gSXQoaSl7aWYoaT09X2UmJnhlKXJldHVybiBuZXcgVWludDhBcnJheSh4ZSk7aWYoXylyZXR1cm4gXyhpKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBEdChpKXtpZigheGUmJih2fHx5KSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFpLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChpLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGM9PntpZighYy5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitpK1wiXFwnXCI7cmV0dXJuIGMuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5JdChpKSk7aWYoRClyZXR1cm4gbmV3IFByb21pc2UoKGMsZik9PntEKGksJD0+YyhuZXcgVWludDhBcnJheSgkKSksZil9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+SXQoaSkpfWZ1bmN0aW9uIGF0KGksYyxmKXtyZXR1cm4gRHQoaSkudGhlbigkPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZSgkLGMpKS50aGVuKCQ9PiQpLnRoZW4oZiwkPT57SyhcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiKyQpLEtlKCQpfSl9ZnVuY3Rpb24gZHIoaSxjKXt2YXIgZj1fZTtyZXR1cm4geGV8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxrdChmKXx8Zi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8U3x8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/YXQoZixpLGMpOmZldGNoKGYse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oJD0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoJCxpKS50aGVuKGMsZnVuY3Rpb24oSSl7cmV0dXJuIEsoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrSSksSyhcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLGF0KGYsaSxjKX0pKX12YXIgaXQsRXQ9ezkxNDk4ODppPT57YS5FYShcIkFic1wiLGksdm9pZCAwKX0sOTE1MDM5Omk9PnthLkVhKFwiTmVnXCIsaSx2b2lkIDApfSw5MTUwOTA6aT0+e2EuRWEoXCJGbG9vclwiLGksdm9pZCAwKX0sOTE1MTQzOmk9PnthLkVhKFwiQ2VpbFwiLGksdm9pZCAwKX0sOTE1MTk1Omk9PnthLkVhKFwiUmVjaXByb2NhbFwiLGksdm9pZCAwKX0sOTE1MjUzOmk9PnthLkVhKFwiU3FydFwiLGksdm9pZCAwKX0sOTE1MzA1Omk9PnthLkVhKFwiRXhwXCIsaSx2b2lkIDApfSw5MTUzNTY6aT0+e2EuRWEoXCJFcmZcIixpLHZvaWQgMCl9LDkxNTQwNzppPT57YS5FYShcIlNpZ21vaWRcIixpLHZvaWQgMCl9LDkxNTQ2MjppPT57YS5FYShcIkxvZ1wiLGksdm9pZCAwKX0sOTE1NTEzOmk9PnthLkVhKFwiU2luXCIsaSx2b2lkIDApfSw5MTU1NjQ6aT0+e2EuRWEoXCJDb3NcIixpLHZvaWQgMCl9LDkxNTYxNTppPT57YS5FYShcIlRhblwiLGksdm9pZCAwKX0sOTE1NjY2Omk9PnthLkVhKFwiQXNpblwiLGksdm9pZCAwKX0sOTE1NzE4Omk9PnthLkVhKFwiQWNvc1wiLGksdm9pZCAwKX0sOTE1NzcwOmk9PnthLkVhKFwiQXRhblwiLGksdm9pZCAwKX0sOTE1ODIyOmk9PnthLkVhKFwiU2luaFwiLGksdm9pZCAwKX0sOTE1ODc0Omk9PnthLkVhKFwiQ29zaFwiLGksdm9pZCAwKX0sOTE1OTI2Omk9PnthLkVhKFwiQXNpbmhcIixpLHZvaWQgMCl9LDkxNTk3OTppPT57YS5FYShcIkFjb3NoXCIsaSx2b2lkIDApfSw5MTYwMzI6aT0+e2EuRWEoXCJBdGFuaFwiLGksdm9pZCAwKX0sOTE2MDg1Omk9PnthLkVhKFwiVGFuaFwiLGksdm9pZCAwKX0sOTE2MTM3Omk9PnthLkVhKFwiTm90XCIsaSx2b2lkIDApfSw5MTYxODg6KGksYyxmKT0+e2EuRWEoXCJDbGlwVjEwXCIsaSx7bWluOmMsbWF4OmZ9KX0sOTE2MjYwOmk9PnthLkVhKFwiQ2xpcFwiLGksdm9pZCAwKX0sOTE2MzEyOihpLGMpPT57YS5FYShcIkVsdVwiLGkse2FscGhhOmN9KX0sOTE2MzcwOmk9PnthLkVhKFwiUmVsdVwiLGksdm9pZCAwKX0sOTE2NDIyOihpLGMpPT57YS5FYShcIkxlYWt5UmVsdVwiLGkse2FscGhhOmN9KX0sOTE2NDg2OihpLGMpPT57YS5FYShcIlRocmVzaG9sZGVkUmVsdVwiLGkse2FscGhhOmN9KX0sOTE2NTU2OihpLGMpPT57YS5FYShcIkNhc3RcIixpLHt0bzpjfSl9LDkxNjYxNDppPT57YS5FYShcIkFkZFwiLGksdm9pZCAwKX0sOTE2NjY1Omk9PnthLkVhKFwiU3ViXCIsaSx2b2lkIDApfSw5MTY3MTY6aT0+e2EuRWEoXCJNdWxcIixpLHZvaWQgMCl9LDkxNjc2NzppPT57YS5FYShcIkRpdlwiLGksdm9pZCAwKX0sOTE2ODE4Omk9PnthLkVhKFwiUG93XCIsaSx2b2lkIDApfSw5MTY4Njk6aT0+e2EuRWEoXCJFcXVhbFwiLGksdm9pZCAwKX0sOTE2OTIyOmk9PnthLkVhKFwiR3JlYXRlclwiLGksdm9pZCAwKX0sOTE2OTc3Omk9PnthLkVhKFwiR3JlYXRlck9yRXF1YWxcIixpLHZvaWQgMCl9LDkxNzAzOTppPT57YS5FYShcIkxlc3NcIixpLHZvaWQgMCl9LDkxNzA5MTppPT57YS5FYShcIkxlc3NPckVxdWFsXCIsaSx2b2lkIDApfSw5MTcxNTA6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlTWVhblwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTczMTQ6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlTWF4XCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxNzQ3NzooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VNaW5cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE3NjQwOihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZVByb2RcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE3ODA0OihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZVN1bVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTc5Njc6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlTDFcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE4MTI5OihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZUwyXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxODI5MTooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VMb2dTdW1cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE4NDU3OihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZVN1bVNxdWFyZVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTg2MjY6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlTG9nU3VtRXhwXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxODc5NTppPT57YS5FYShcIldoZXJlXCIsaSx2b2lkIDApfSw5MTg4NDg6KGksYyxmKT0+e2EuRWEoXCJUcmFuc3Bvc2VcIixpLHtwZXJtOmM/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoZj4+PjAsZitjPj4+MCkpOltdfSl9LDkxODk2MTooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8sc2UpPT57YS5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6ZWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6JCxrZXJuZWxfc2hhcGU6W0ldLHBhZHM6W1AsVl0sc3RyaWRlczpbb2VdLHdJc0NvbnN0OigpPT4hIXIoKVtaPj4+MF0sb3V0cHV0UGFkZGluZzpyZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShoZT4+PjAsaGUrcmU+Pj4wKSk6W10sb3V0cHV0U2hhcGU6YmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTz4+PjAsTytiZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKHNlKX0pfSw5MTkzNzU6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPKT0+e2EuRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0Om9lP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoZj4+PjAsZisyPj4+MCkpLGdyb3VwOiQsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoUD4+PjAsUCs0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoVj4+PjAsVisyPj4+MCkpLHdJc0NvbnN0OigpPT4hIXIoKVtlZT4+PjBdLG91dHB1dFBhZGRpbmc6MDxaP0FycmF5LmZyb20obigpLnN1YmFycmF5KHJlPj4+MCxyZStaPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8aGU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoYmU+Pj4wLGJlK2hlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoTyl9KX0sOTE5OTMyOihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyxzZSk9PnthLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDplZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltmXSxncm91cDokLGtlcm5lbF9zaGFwZTpbSV0scGFkczpbUCxWXSxzdHJpZGVzOltvZV0sd0lzQ29uc3Q6KCk9PiEhcigpW1o+Pj4wXSxvdXRwdXRQYWRkaW5nOnJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGhlPj4+MCxoZStyZT4+PjApKTpbXSxvdXRwdXRTaGFwZTpiZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShPPj4+MCxPK2JlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoc2UpfSl9LDkyMDM0NjooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8pPT57YS5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6b2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShmPj4+MCxmKzI+Pj4wKSksZ3JvdXA6JCxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShQPj4+MCxQKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShWPj4+MCxWKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcigpW2VlPj4+MF0sb3V0cHV0UGFkZGluZzowPFo/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkocmU+Pj4wLHJlK1o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxoZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShiZT4+PjAsYmUraGU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShPKX0pfSw5MjA5MDM6KGksYyk9PnthLkVhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjA5OTQ6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPLHNlLHllKT0+e2EuRWEoXCJBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOiQsc3RvcmFnZV9vcmRlcjpJLGRpbGF0aW9uczpbUCxWXSxrZXJuZWxfc2hhcGU6W29lLGVlXSxwYWRzOltaLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjEyNzg6KGksYyk9PnthLkVhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjEzNjk6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPLHNlLHllKT0+e2EuRWEoXCJBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOiQsc3RvcmFnZV9vcmRlcjpJLGRpbGF0aW9uczpbUCxWXSxrZXJuZWxfc2hhcGU6W29lLGVlXSxwYWRzOltaLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjE2NTM6KGksYyk9PnthLkVhKFwiR2xvYmFsTWF4UG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMTc0MDooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8sc2UseWUpPT57YS5FYShcIk1heFBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDokLHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W1AsVl0sa2VybmVsX3NoYXBlOltvZSxlZV0scGFkczpbWixyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIyMDIwOihpLGMpPT57YS5FYShcIkdsb2JhbE1heFBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjIxMDc6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPLHNlLHllKT0+e2EuRWEoXCJNYXhQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6JCxzdG9yYWdlX29yZGVyOkksZGlsYXRpb25zOltQLFZdLGtlcm5lbF9zaGFwZTpbb2UsZWVdLHBhZHM6W1oscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMjM4NzooaSxjLGYsJCxJKT0+e2EuRWEoXCJHZW1tXCIsaSx7YWxwaGE6YyxiZXRhOmYsdHJhbnNBOiQsdHJhbnNCOkl9KX0sOTIyNDkxOmk9PnthLkVhKFwiTWF0TXVsXCIsaSx2b2lkIDApfSw5MjI1NDU6KGksYyxmLCQpPT57YS5FYShcIkFyZ01heFwiLGkse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFmLGF4aXM6JH0pfSw5MjI2NTM6KGksYyxmLCQpPT57YS5FYShcIkFyZ01pblwiLGkse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFmLGF4aXM6JH0pfSw5MjI3NjE6KGksYyk9PnthLkVhKFwiU29mdG1heFwiLGkse2F4aXM6Y30pfSw5MjI4MjQ6KGksYyk9PnthLkVhKFwiQ29uY2F0XCIsaSx7YXhpczpjfSl9LDkyMjg4NDooaSxjLGYsJCxJKT0+e2EuRWEoXCJTcGxpdFwiLGkse2F4aXM6YyxudW1PdXRwdXRzOmYsc3BsaXRTaXplczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MjMwMjk6aT0+e2EuRWEoXCJFeHBhbmRcIixpLHZvaWQgMCl9LDkyMzA4MzooaSxjKT0+e2EuRWEoXCJHYXRoZXJcIixpLHtheGlzOk51bWJlcihjKX0pfSw5MjMxNTQ6KGksYyk9PnthLkVhKFwiR2F0aGVyRWxlbWVudHNcIixpLHtheGlzOk51bWJlcihjKX0pfSw5MjMyMzM6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSk9PnthLkVhKFwiUmVzaXplXCIsaSx7YW50aWFsaWFzOmMsYXhlczpmP0FycmF5LmZyb20obigpLnN1YmFycmF5KCQ+Pj4wLCQrZj4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpWZShJKSxjdWJpY0NvZWZmQTpQLGV4Y2x1ZGVPdXRzaWRlOlYsZXh0cmFwb2xhdGlvblZhbHVlOm9lLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpWZShlZSksbW9kZTpWZShaKSxuZWFyZXN0TW9kZTpWZShyZSl9KX0sOTIzNTg0OihpLGMsZiwkLEksUCxWKT0+e2EuRWEoXCJTbGljZVwiLGkse3N0YXJ0czpjP0FycmF5LmZyb20obigpLnN1YmFycmF5KGY+Pj4wLGYrYz4+PjApKTpbXSxlbmRzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdLGF4ZXM6UD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShWPj4+MCxWK1A+Pj4wKSk6W119KX0sOTIzODE1Omk9PnthLkVhKFwiVGlsZVwiLGksdm9pZCAwKX0sOTIzODY3OihpLGMsZik9PnthLkVhKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsaSx7YXhpczpOdW1iZXIoYyksZXBzaWxvbjpOdW1iZXIoZil9KX0sOTIzOTc0OihpLGMsZik9PnthLkVhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjpjLGZvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNDA4ODooaSxjLGYpPT57YS5FYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246Yyxmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjQyMDI6aT0+e2EuRWEoXCJSYW5nZVwiLGksdm9pZCAwKX0sOTI0MjU1OihpLGMpPT57YS5FYShcIkVpbnN1bVwiLGkse2VxdWF0aW9uOlZlKGMpfSl9LDkyNDMzNjooaSxjLGYsJCxJKT0+e2EuRWEoXCJQYWRcIixpLHttb2RlOmMsdmFsdWU6ZixwYWRzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkyNDQ2ODppPT57YS5FYShcIkdlbHVcIixpLHZvaWQgMCl9LDkyNDUyMDppPT57YS5FYShcIkJpYXNBZGRcIixpLHZvaWQgMCl9LDkyNDU3NTppPT57YS5FYShcIkJpYXNTcGxpdEdlbHVcIixpLHZvaWQgMCl9LDkyNDYzNjooaSxjKT0+e2EuRWEoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjpjfSl9LDkyNDcxNzooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlKT0+e2EuRWEoXCJDb252XCIsaSx7Zm9ybWF0OmVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsZGlsYXRpb25zOltmXSxncm91cDokLGtlcm5lbF9zaGFwZTpbSV0scGFkczpQP0FycmF5LmZyb20obigpLnN1YmFycmF5KFY+Pj4wLFYrUD4+PjApKTpbXSxzdHJpZGVzOltvZV0sd19pc19jb25zdDooKT0+ISFyKClbWj4+PjBdLGFjdGl2YXRpb246VmUocmUpLGFjdGl2YXRpb25fcGFyYW1zOmhlP0FycmF5LmZyb20odSgpLnN1YmFycmF5KGJlPj4+MCxiZStoZT4+PjApKTpbXX0pfSw5MjUwOTg6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPLHNlLHllKT0+e2EuRWEoXCJDb252XCIsaSx7Zm9ybWF0OmhlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsZGlsYXRpb25zOltmLCRdLGdyb3VwOkksa2VybmVsX3NoYXBlOltQLFZdLHBhZHM6b2U/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoZWU+Pj4wLGVlK29lPj4+MCkpOltdLHN0cmlkZXM6W1oscmVdLHdfaXNfY29uc3Q6KCk9PiEhcigpW2JlPj4+MF0sYWN0aXZhdGlvbjpWZShPKSxhY3RpdmF0aW9uX3BhcmFtczpzZT9BcnJheS5mcm9tKHUoKS5zdWJhcnJheSh5ZT4+PjAseWUrc2U+Pj4wKSk6W119KX0sOTI1NTAwOmk9PnthLnpiKGkpfSw5MjU1MzQ6KGksYyk9PmEuQWIoaSxjLGEuYmIuRmIsYS5iYi5lcnJvcnMpLDkyNTY0NjppPT5hLndiKGkpLDkyNTY3OTppPT5hLnliKGkpLDkyNTcxMTooaSxjLGYpPT57YS5qYihpLGMsZiwhMCl9LDkyNTc1MDooaSxjLGYpPT57YS5qYihpLGMsZil9fTtmdW5jdGlvbiBjdChpKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7aX0pYCx0aGlzLnN0YXR1cz1pfWZ1bmN0aW9uIFR0KGkpe2kudGVybWluYXRlKCksaS5vbm1lc3NhZ2U9KCk9Pnt9fWZ1bmN0aW9uIE90KGkpeyhpPW5lLlFhW2ldKXx8S2UoKSxuZS5FYihpKX1mdW5jdGlvbiBXdChpKXt2YXIgYz1uZS50YigpO2lmKCFjKXJldHVybiA2O25lLllhLnB1c2goYyksbmUuUWFbaS5YYV09YyxjLlhhPWkuWGE7dmFyIGY9e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6aS5HYixhcmc6aS5yYixwdGhyZWFkX3B0cjppLlhhfTtyZXR1cm4gUyYmYy51bnJlZigpLGMucG9zdE1lc3NhZ2UoZixpLk1iKSwwfXZhciBfdD10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsY3I9KGksYyxmKT0+e2M+Pj49MDt2YXIgJD1jK2Y7Zm9yKGY9YztpW2ZdJiYhKGY+PSQpOykrK2Y7aWYoMTY8Zi1jJiZpLmJ1ZmZlciYmX3QpcmV0dXJuIF90LmRlY29kZShpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP2kuc2xpY2UoYyxmKTppLnN1YmFycmF5KGMsZikpO2ZvcigkPVwiXCI7YzxmOyl7dmFyIEk9aVtjKytdO2lmKEkmMTI4KXt2YXIgUD1pW2MrK10mNjM7aWYoKEkmMjI0KT09MTkyKSQrPVN0cmluZy5mcm9tQ2hhckNvZGUoKEkmMzEpPDw2fFApO2Vsc2V7dmFyIFY9aVtjKytdJjYzO0k9KEkmMjQwKT09MjI0PyhJJjE1KTw8MTJ8UDw8NnxWOihJJjcpPDwxOHxQPDwxMnxWPDw2fGlbYysrXSY2Myw2NTUzNj5JPyQrPVN0cmluZy5mcm9tQ2hhckNvZGUoSSk6KEktPTY1NTM2LCQrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ST4+MTAsNTYzMjB8SSYxMDIzKSl9fWVsc2UgJCs9U3RyaW5nLmZyb21DaGFyQ29kZShJKX1yZXR1cm4gJH0sVmU9KGksYyk9PihpPj4+PTApP2NyKG8oKSxpLGMpOlwiXCI7ZnVuY3Rpb24genQoaSl7aWYoQSlyZXR1cm4gRygxLDEsaSk7SWU9aSxYZSgpfHwobmUuSGIoKSxhLm9uRXhpdCYmYS5vbkV4aXQoaSksT2U9ITApLHcoaSxuZXcgY3QoaSkpfXZhciBWdD1pPT57aWYoSWU9aSxBKXRocm93IHByKGkpLFwidW53aW5kXCI7enQoaSl9LG5lPXthYjpbXSxZYTpbXSxtYjpbXSxRYTp7fSxnYjpmdW5jdGlvbigpe0E/bmUudmIoKTpuZS51YigpfSx1YjpmdW5jdGlvbigpe1VlLnVuc2hpZnQoKCk9PntCdCgpLG5lLkJiKCgpPT5scigpKX0pfSx2YjpmdW5jdGlvbigpe25lLnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1uZS5EYixuZS50aHJlYWRJbml0VExTPW5lLmxiLG5lLnNldEV4aXRTdGF0dXM9bmUua2IsYWU9ITF9LGtiOmZ1bmN0aW9uKGkpe0llPWl9LFNiOltcIiR0ZXJtaW5hdGVXb3JrZXJcIl0sSGI6ZnVuY3Rpb24oKXtmb3IodmFyIGkgb2YgbmUuWWEpVHQoaSk7Zm9yKGkgb2YgbmUuYWIpVHQoaSk7bmUuYWI9W10sbmUuWWE9W10sbmUuUWE9W119LEViOmZ1bmN0aW9uKGkpe3ZhciBjPWkuWGE7ZGVsZXRlIG5lLlFhW2NdLG5lLmFiLnB1c2goaSksbmUuWWEuc3BsaWNlKG5lLllhLmluZGV4T2YoaSksMSksaS5YYT0wLGVuKGMpfSxEYjpmdW5jdGlvbigpe30sbGI6ZnVuY3Rpb24oKXtuZS5tYi5mb3JFYWNoKGk9PmkoKSl9LENiOmk9Pm5ldyBQcm9taXNlKGM9PntpLm9ubWVzc2FnZT1QPT57UD1QLmRhdGE7dmFyIFY9UC5jbWQ7aWYoUC50YXJnZXRUaHJlYWQmJlAudGFyZ2V0VGhyZWFkIT1TcigpKXt2YXIgb2U9bmUuUWFbUC5SYl07b2U/b2UucG9zdE1lc3NhZ2UoUCxQLnRyYW5zZmVyTGlzdCk6SyhcXCdJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiXFwnK1YrXFwnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgXFwnK1AudGFyZ2V0VGhyZWFkK1wiLCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFcIil9ZWxzZSBWPT09XCJjaGVja01haWxib3hcIj8kdCgpOlY9PT1cInNwYXduVGhyZWFkXCI/V3QoUCk6Vj09PVwiY2xlYW51cFRocmVhZFwiP090KFAudGhyZWFkKTpWPT09XCJraWxsVGhyZWFkXCI/KFA9UC50aHJlYWQsVj1uZS5RYVtQXSxkZWxldGUgbmUuUWFbUF0sVHQoViksZW4oUCksbmUuWWEuc3BsaWNlKG5lLllhLmluZGV4T2YoViksMSksVi5YYT0wKTpWPT09XCJjYW5jZWxUaHJlYWRcIj9uZS5RYVtQLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6Vj09PVwibG9hZGVkXCI/KGkubG9hZGVkPSEwLGMoaSkpOlY9PT1cImFsZXJ0XCI/YWxlcnQoXCJUaHJlYWQgXCIrUC50aHJlYWRJZCtcIjogXCIrUC50ZXh0KTpQLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/aS5wb3N0TWVzc2FnZShQKTpWPT09XCJjYWxsSGFuZGxlclwiP2FbUC5oYW5kbGVyXSguLi5QLmFyZ3MpOlYmJksoXCJ3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgXCIrVil9LGkub25lcnJvcj1QPT57dGhyb3cgSyhcIndvcmtlciBzZW50IGFuIGVycm9yISBcIitQLmZpbGVuYW1lK1wiOlwiK1AubGluZW5vK1wiOiBcIitQLm1lc3NhZ2UpLFB9LFMmJihpLm9uKFwibWVzc2FnZVwiLGZ1bmN0aW9uKFApe2kub25tZXNzYWdlKHtkYXRhOlB9KX0pLGkub24oXCJlcnJvclwiLGZ1bmN0aW9uKFApe2kub25lcnJvcihQKX0pKTt2YXIgZj1bXSwkPVtcIm9uRXhpdFwiLFwib25BYm9ydFwiLFwicHJpbnRcIixcInByaW50RXJyXCJdLEk7Zm9yKEkgb2YgJClhLmhhc093blByb3BlcnR5KEkpJiZmLnB1c2goSSk7aS5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmYsdXJsT3JCbG9iOmEubWFpblNjcmlwdFVybE9yQmxvYnx8ZSx3YXNtTWVtb3J5OndlLHdhc21Nb2R1bGU6U2V9KX0pLEJiOmZ1bmN0aW9uKGkpe2koKX0scWI6ZnVuY3Rpb24oKXt2YXIgaT1XKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53b3JrZXIuanNcIik7aT1uZXcgV29ya2VyKGkpLG5lLmFiLnB1c2goaSl9LHRiOmZ1bmN0aW9uKCl7cmV0dXJuIG5lLmFiLmxlbmd0aD09MCYmKG5lLnFiKCksbmUuQ2IobmUuYWJbMF0pKSxuZS5hYi5wb3AoKX19O2EuUFRocmVhZD1uZTt2YXIgc3Q9aT0+e2Zvcig7MDxpLmxlbmd0aDspaS5zaGlmdCgpKGEpfTthLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgaT1TcigpLGM9bigpW2krNTI+PjI+Pj4wXTtpPW4oKVtpKzU2Pj4yPj4+MF0sWm4oYyxjLWkpLENyKGMpfTtmdW5jdGlvbiBwcihpKXtpZihBKXJldHVybiBHKDIsMCxpKTtWdChpKX1hLmludm9rZUVudHJ5UG9pbnQ9ZnVuY3Rpb24oaSxjKXtpPVFuLmFwcGx5KG51bGwsW2ksY10pLFhlKCk/bmUua2IoaSk6dG4oaSl9O2Z1bmN0aW9uIEplKGkpe3RoaXMuZmI9aS0yNCx0aGlzLnBiPWZ1bmN0aW9uKGMpe3MoKVt0aGlzLmZiKzQ+PjI+Pj4wXT1jfSx0aGlzLm9iPWZ1bmN0aW9uKGMpe3MoKVt0aGlzLmZiKzg+PjI+Pj4wXT1jfSx0aGlzLmdiPWZ1bmN0aW9uKGMsZil7dGhpcy5uYigpLHRoaXMucGIoYyksdGhpcy5vYihmKX0sdGhpcy5uYj1mdW5jdGlvbigpe3MoKVt0aGlzLmZiKzE2Pj4yPj4+MF09MH19dmFyIEhlPTAsZnI9MDtmdW5jdGlvbiB3dChpLGMsZiwkKXtyZXR1cm4gQT9HKDMsMSxpLGMsZiwkKTpHdChpLGMsZiwkKX1mdW5jdGlvbiBHdChpLGMsZiwkKXtpZihpPj4+PTAsYz4+Pj0wLGY+Pj49MCwkPj4+PTAsdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiBLKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgST1bXTtyZXR1cm4gQSYmSS5sZW5ndGg9PT0wP3d0KGksYyxmLCQpOihpPXtHYjpmLFhhOmkscmI6JCxNYjpJfSxBPyhpLk9iPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShpLEkpLDApOld0KGkpKX1mdW5jdGlvbiBOdChpLGMsZil7cmV0dXJuIEE/Ryg0LDEsaSxjLGYpOjB9ZnVuY3Rpb24gbXIoaSxjKXtpZihBKXJldHVybiBHKDUsMSxpLGMpfXZhciB2dD1pPT57Zm9yKHZhciBjPTAsZj0wO2Y8aS5sZW5ndGg7KytmKXt2YXIgJD1pLmNoYXJDb2RlQXQoZik7MTI3Pj0kP2MrKzoyMDQ3Pj0kP2MrPTI6NTUyOTY8PSQmJjU3MzQzPj0kPyhjKz00LCsrZik6Yys9M31yZXR1cm4gY30saHI9KGksYyxmLCQpPT57aWYoZj4+Pj0wLCEoMDwkKSlyZXR1cm4gMDt2YXIgST1mOyQ9ZiskLTE7Zm9yKHZhciBQPTA7UDxpLmxlbmd0aDsrK1Ape3ZhciBWPWkuY2hhckNvZGVBdChQKTtpZig1NTI5Njw9ViYmNTczNDM+PVYpe3ZhciBvZT1pLmNoYXJDb2RlQXQoKytQKTtWPTY1NTM2KygoViYxMDIzKTw8MTApfG9lJjEwMjN9aWYoMTI3Pj1WKXtpZihmPj0kKWJyZWFrO2NbZisrPj4+MF09Vn1lbHNle2lmKDIwNDc+PVYpe2lmKGYrMT49JClicmVhaztjW2YrKz4+PjBdPTE5MnxWPj42fWVsc2V7aWYoNjU1MzU+PVYpe2lmKGYrMj49JClicmVhaztjW2YrKz4+PjBdPTIyNHxWPj4xMn1lbHNle2lmKGYrMz49JClicmVhaztjW2YrKz4+PjBdPTI0MHxWPj4xOCxjW2YrKz4+PjBdPTEyOHxWPj4xMiY2M31jW2YrKz4+PjBdPTEyOHxWPj42JjYzfWNbZisrPj4+MF09MTI4fFYmNjN9fXJldHVybiBjW2Y+Pj4wXT0wLGYtSX0sZ3I9KGksYyxmKT0+aHIoaSxvKCksYyxmKTtmdW5jdGlvbiB5cihpLGMpe2lmKEEpcmV0dXJuIEcoNiwxLGksYyl9ZnVuY3Rpb24gYnIoaSxjLGYpe2lmKEEpcmV0dXJuIEcoNywxLGksYyxmKX1mdW5jdGlvbiB3cihpLGMsZil7cmV0dXJuIEE/Ryg4LDEsaSxjLGYpOjB9ZnVuY3Rpb24gdnIoaSxjKXtpZihBKXJldHVybiBHKDksMSxpLGMpfWZ1bmN0aW9uIFJ0KGksYyxmKXtpZihBKXJldHVybiBHKDEwLDEsaSxjLGYpfWZ1bmN0aW9uIFV0KGksYyxmLCQpe2lmKEEpcmV0dXJuIEcoMTEsMSxpLGMsZiwkKX1mdW5jdGlvbiBMdChpLGMsZiwkKXtpZihBKXJldHVybiBHKDEyLDEsaSxjLGYsJCl9ZnVuY3Rpb24gRnQoaSxjLGYsJCl7aWYoQSlyZXR1cm4gRygxMywxLGksYyxmLCQpfWZ1bmN0aW9uIEh0KGkpe2lmKEEpcmV0dXJuIEcoMTQsMSxpKX1mdW5jdGlvbiBqdChpLGMpe2lmKEEpcmV0dXJuIEcoMTUsMSxpLGMpfWZ1bmN0aW9uIEt0KGksYyxmKXtpZihBKXJldHVybiBHKDE2LDEsaSxjLGYpfXZhciBxdD1pPT57aWYoIU9lKXRyeXtpZihpKCksIVhlKCkpdHJ5e0E/dG4oSWUpOlZ0KEllKX1jYXRjaChjKXtjIGluc3RhbmNlb2YgY3R8fGM9PVwidW53aW5kXCJ8fHcoMSxjKX19Y2F0Y2goYyl7YyBpbnN0YW5jZW9mIGN0fHxjPT1cInVud2luZFwifHx3KDEsYyl9fTtmdW5jdGlvbiBQdChpKXtpPj4+PTAsdHlwZW9mIEF0b21pY3MuTmI9PVwiZnVuY3Rpb25cIiYmKEF0b21pY3MuTmIobigpLGk+PjIsaSkudmFsdWUudGhlbigkdCksaSs9MTI4LEF0b21pY3Muc3RvcmUobigpLGk+PjIsMSkpfWEuX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0PVB0O2Z1bmN0aW9uICR0KCl7dmFyIGk9U3IoKTtpJiYoUHQoaSkscXQoKCk9PlhuKCkpKX1hLmNoZWNrTWFpbGJveD0kdDt2YXIgcHQ9aT0+aSU0PT09MCYmKGklMTAwIT09MHx8aSU0MDA9PT0wKSx4dD1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxZdD1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiBsKGksYyxmLCQsSSxQLFYsb2Upe3JldHVybiBBP0coMTcsMSxpLGMsZiwkLEksUCxWLG9lKTotNTJ9ZnVuY3Rpb24gcChpLGMsZiwkLEksUCxWKXtpZihBKXJldHVybiBHKDE4LDEsaSxjLGYsJCxJLFAsVil9dmFyIGg9aT0+e3ZhciBjPXZ0KGkpKzEsZj1RcihjKTtyZXR1cm4gZiYmZ3IoaSxmLGMpLGZ9LEM9W10sVD0oaSxjKT0+e0MubGVuZ3RoPTA7dmFyIGY7Zm9yKGM+Pj0yO2Y9bygpW2krKz4+PjBdOyljKz1mIT0xMDUmYyxDLnB1c2goZj09MTA1P24oKVtjPj4+MF06ZCgpW2MrKz4+PjFdKSwrK2M7cmV0dXJuIEN9LFU9aT0+e3ZhciBjPXJuKCk7cmV0dXJuIGk9aSgpLENyKGMpLGl9O2Z1bmN0aW9uIEcoaSxjKXt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTIsJD1hcmd1bWVudHM7cmV0dXJuIFUoKCk9Pntmb3IodmFyIEk9bm4oOCpmKSxQPUk+PjMsVj0wO1Y8ZjtWKyspe3ZhciBvZT0kWzIrVl07ZCgpW1ArVj4+PjBdPW9lfXJldHVybiBZbihpLGYsSSxjKX0pfXZhciB1ZT1bXSxZPXt9LFE9KCk9PntpZighSil7dmFyIGk9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86Ynx8XCIuL3RoaXMucHJvZ3JhbVwifSxjO2ZvcihjIGluIFkpWVtjXT09PXZvaWQgMD9kZWxldGUgaVtjXTppW2NdPVlbY107dmFyIGY9W107Zm9yKGMgaW4gaSlmLnB1c2goYCR7Y309JHtpW2NdfWApO0o9Zn1yZXR1cm4gSn0sSjtmdW5jdGlvbiBjZShpLGMpe2lmKEEpcmV0dXJuIEcoMTksMSxpLGMpO2k+Pj49MCxjPj4+PTA7dmFyIGY9MDtyZXR1cm4gUSgpLmZvckVhY2goZnVuY3Rpb24oJCxJKXt2YXIgUD1jK2Y7Zm9yKEk9cygpW2krNCpJPj4yPj4+MF09UCxQPTA7UDwkLmxlbmd0aDsrK1ApcigpW0krKz4+MD4+PjBdPSQuY2hhckNvZGVBdChQKTtyKClbST4+MD4+PjBdPTAsZis9JC5sZW5ndGgrMX0pLDB9ZnVuY3Rpb24gbWUoaSxjKXtpZihBKXJldHVybiBHKDIwLDEsaSxjKTtpPj4+PTAsYz4+Pj0wO3ZhciBmPVEoKTtzKClbaT4+Mj4+PjBdPWYubGVuZ3RoO3ZhciAkPTA7cmV0dXJuIGYuZm9yRWFjaChmdW5jdGlvbihJKXskKz1JLmxlbmd0aCsxfSkscygpW2M+PjI+Pj4wXT0kLDB9ZnVuY3Rpb24gRShpKXtyZXR1cm4gQT9HKDIxLDEsaSk6NTJ9ZnVuY3Rpb24gdGUoaSxjLGYsJCl7cmV0dXJuIEE/RygyMiwxLGksYyxmLCQpOjUyfWZ1bmN0aW9uIGZlKGksYyxmLCQsSSl7cmV0dXJuIEE/RygyMywxLGksYyxmLCQsSSk6NzB9dmFyIHV0PVtudWxsLFtdLFtdXTtmdW5jdGlvbiBYdChpLGMsZiwkKXtpZihBKXJldHVybiBHKDI0LDEsaSxjLGYsJCk7Yz4+Pj0wLGY+Pj49MCwkPj4+PTA7Zm9yKHZhciBJPTAsUD0wO1A8ZjtQKyspe3ZhciBWPXMoKVtjPj4yPj4+MF0sb2U9cygpW2MrND4+Mj4+PjBdO2MrPTg7Zm9yKHZhciBlZT0wO2VlPG9lO2VlKyspe3ZhciBaPW8oKVtWK2VlPj4+MF0scmU9dXRbaV07Wj09PTB8fFo9PT0xMD8oKGk9PT0xP0I6SykoY3IocmUsMCkpLHJlLmxlbmd0aD0wKTpyZS5wdXNoKFopfUkrPW9lfXJldHVybiBzKClbJD4+Mj4+PjBdPUksMH12YXIgTm49WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxVbj1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIGR1KGkpe3ZhciBjPUFycmF5KHZ0KGkpKzEpO3JldHVybiBocihpLGMsMCxjLmxlbmd0aCksY312YXIgY3U9KGksYyk9PntyKCkuc2V0KGksYz4+PjApfTtmdW5jdGlvbiBMbihpLGMsZiwkKXtmdW5jdGlvbiBJKE8sc2UseWUpe2ZvcihPPXR5cGVvZiBPPT1cIm51bWJlclwiP08udG9TdHJpbmcoKTpPfHxcIlwiO08ubGVuZ3RoPHNlOylPPXllWzBdK087cmV0dXJuIE99ZnVuY3Rpb24gUChPLHNlKXtyZXR1cm4gSShPLHNlLFwiMFwiKX1mdW5jdGlvbiBWKE8sc2Upe2Z1bmN0aW9uIHllKGFvKXtyZXR1cm4gMD5hbz8tMTowPGFvPzE6MH12YXIgU3Q7cmV0dXJuKFN0PXllKE8uZ2V0RnVsbFllYXIoKS1zZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYoU3Q9eWUoTy5nZXRNb250aCgpLXNlLmdldE1vbnRoKCkpKT09PTAmJihTdD15ZShPLmdldERhdGUoKS1zZS5nZXREYXRlKCkpKSxTdH1mdW5jdGlvbiBvZShPKXtzd2l0Y2goTy5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBPO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBlZShPKXt2YXIgc2U9Ty5aYTtmb3IoTz1uZXcgRGF0ZShuZXcgRGF0ZShPLiRhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8c2U7KXt2YXIgeWU9Ty5nZXRNb250aCgpLFN0PShwdChPLmdldEZ1bGxZZWFyKCkpP05uOlVuKVt5ZV07aWYoc2U+U3QtTy5nZXREYXRlKCkpc2UtPVN0LU8uZ2V0RGF0ZSgpKzEsTy5zZXREYXRlKDEpLDExPnllP08uc2V0TW9udGgoeWUrMSk6KE8uc2V0TW9udGgoMCksTy5zZXRGdWxsWWVhcihPLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7Ty5zZXREYXRlKE8uZ2V0RGF0ZSgpK3NlKTticmVha319cmV0dXJuIHllPW5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSsxLDAsNCksc2U9b2UobmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsNCkpLHllPW9lKHllKSwwPj1WKHNlLE8pPzA+PVYoeWUsTyk/Ty5nZXRGdWxsWWVhcigpKzE6Ty5nZXRGdWxsWWVhcigpOk8uZ2V0RnVsbFllYXIoKS0xfWk+Pj49MCxjPj4+PTAsZj4+Pj0wLCQ+Pj49MDt2YXIgWj1uKClbJCs0MD4+Mj4+PjBdOyQ9e0tiOm4oKVskPj4yPj4+MF0sSmI6bigpWyQrND4+Mj4+PjBdLGNiOm4oKVskKzg+PjI+Pj4wXSxpYjpuKClbJCsxMj4+Mj4+PjBdLGViOm4oKVskKzE2Pj4yPj4+MF0sJGE6bigpWyQrMjA+PjI+Pj4wXSxXYTpuKClbJCsyND4+Mj4+PjBdLFphOm4oKVskKzI4Pj4yPj4+MF0sVGI6bigpWyQrMzI+PjI+Pj4wXSxJYjpuKClbJCszNj4+Mj4+PjBdLExiOlo/VmUoWik6XCJcIn0sZj1WZShmKSxaPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciByZSBpbiBaKWY9Zi5yZXBsYWNlKG5ldyBSZWdFeHAocmUsXCJnXCIpLFpbcmVdKTt2YXIgaGU9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxiZT1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Wj17XCIlYVwiOk89PmhlW08uV2FdLnN1YnN0cmluZygwLDMpLFwiJUFcIjpPPT5oZVtPLldhXSxcIiViXCI6Tz0+YmVbTy5lYl0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOk89PmJlW08uZWJdLFwiJUNcIjpPPT5QKChPLiRhKzE5MDApLzEwMHwwLDIpLFwiJWRcIjpPPT5QKE8uaWIsMiksXCIlZVwiOk89PkkoTy5pYiwyLFwiIFwiKSxcIiVnXCI6Tz0+ZWUoTykudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOk89PmVlKE8pLFwiJUhcIjpPPT5QKE8uY2IsMiksXCIlSVwiOk89PihPPU8uY2IsTz09MD9PPTEyOjEyPE8mJihPLT0xMiksUChPLDIpKSxcIiVqXCI6Tz0+e2Zvcih2YXIgc2U9MCx5ZT0wO3llPD1PLmViLTE7c2UrPShwdChPLiRhKzE5MDApP05uOlVuKVt5ZSsrXSk7cmV0dXJuIFAoTy5pYitzZSwzKX0sXCIlbVwiOk89PlAoTy5lYisxLDIpLFwiJU1cIjpPPT5QKE8uSmIsMiksXCIlblwiOigpPT5gXFxuYCxcIiVwXCI6Tz0+MDw9Ty5jYiYmMTI+Ty5jYj9cIkFNXCI6XCJQTVwiLFwiJVNcIjpPPT5QKE8uS2IsMiksXCIldFwiOigpPT5cIlx0XCIsXCIldVwiOk89Pk8uV2F8fDcsXCIlVVwiOk89PlAoTWF0aC5mbG9vcigoTy5aYSs3LU8uV2EpLzcpLDIpLFwiJVZcIjpPPT57dmFyIHNlPU1hdGguZmxvb3IoKE8uWmErNy0oTy5XYSs2KSU3KS83KTtpZigyPj0oTy5XYSszNzEtTy5aYS0yKSU3JiZzZSsrLHNlKXNlPT01MyYmKHllPShPLldhKzM3MS1PLlphKSU3LHllPT00fHx5ZT09MyYmcHQoTy4kYSl8fChzZT0xKSk7ZWxzZXtzZT01Mjt2YXIgeWU9KE8uV2ErNy1PLlphLTEpJTc7KHllPT00fHx5ZT09NSYmcHQoTy4kYSU0MDAtMSkpJiZzZSsrfXJldHVybiBQKHNlLDIpfSxcIiV3XCI6Tz0+Ty5XYSxcIiVXXCI6Tz0+UChNYXRoLmZsb29yKChPLlphKzctKE8uV2ErNiklNykvNyksMiksXCIleVwiOk89PihPLiRhKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjpPPT5PLiRhKzE5MDAsXCIlelwiOk89PntPPU8uSWI7dmFyIHNlPTA8PU87cmV0dXJuIE89TWF0aC5hYnMoTykvNjAsKHNlP1wiK1wiOlwiLVwiKSsoXCIwMDAwXCIrKE8vNjAqMTAwK08lNjApKS5zbGljZSgtNCl9LFwiJVpcIjpPPT5PLkxiLFwiJSVcIjooKT0+XCIlXCJ9LGY9Zi5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKTtmb3IocmUgaW4gWilmLmluY2x1ZGVzKHJlKSYmKGY9Zi5yZXBsYWNlKG5ldyBSZWdFeHAocmUsXCJnXCIpLFpbcmVdKCQpKSk7cmV0dXJuIGY9Zi5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpLHJlPWR1KGYpLHJlLmxlbmd0aD5jPzA6KGN1KHJlLGkpLHJlLmxlbmd0aC0xKX1mdW5jdGlvbiAkcihpKXt0cnl7aSgpfWNhdGNoKGMpe0tlKGMpfX1mdW5jdGlvbiBwdShpKXt2YXIgYz17fSxmO2ZvcihmIGluIGkpKGZ1bmN0aW9uKCQpe3ZhciBJPWlbJF07Y1skXT10eXBlb2YgST09XCJmdW5jdGlvblwiP2Z1bmN0aW9uKCl7eHIucHVzaCgkKTt0cnl7cmV0dXJuIEkuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZpbmFsbHl7T2V8fCh4ci5wb3AoKT09PSR8fEtlKCksWmUmJmZ0PT09MSYmeHIubGVuZ3RoPT09MCYmKGZ0PTAsR2UrPTEsJHIodG8pLHR5cGVvZiBGaWJlcnM8XCJ1XCImJkZpYmVycy5VYigpKSl9fTpJfSkoZik7cmV0dXJuIGN9dmFyIGZ0PTAsWmU9bnVsbCxGbj0wLHhyPVtdLEhuPXt9LGpuPXt9LGZ1PTAsWnI9bnVsbCxtdT1bXTtmdW5jdGlvbiBodSgpe3JldHVybiBuZXcgUHJvbWlzZSgoaSxjKT0+e1pyPXtyZXNvbHZlOmkscmVqZWN0OmN9fSl9ZnVuY3Rpb24gZ3UoKXt2YXIgaT1Rcig2NTU0OCksYz1pKzEyO3MoKVtpPj4yPj4+MF09YyxzKClbaSs0Pj4yPj4+MF09Yys2NTUzNixjPXhyWzBdO3ZhciBmPUhuW2NdO3JldHVybiBmPT09dm9pZCAwJiYoZj1mdSsrLEhuW2NdPWYsam5bZl09YyksYz1mLG4oKVtpKzg+PjI+Pj4wXT1jLGl9ZnVuY3Rpb24geXUoKXt2YXIgaT1uKClbWmUrOD4+Mj4+PjBdO3JldHVybiBpPWpbam5baV1dLC0tR2UsaSgpfWZ1bmN0aW9uIGJ1KGkpe2lmKCFPZSl7aWYoZnQ9PT0wKXt2YXIgYz0hMSxmPSExO2koKCQ9MCk9PntpZighT2UmJihGbj0kLGM9ITAsZikpe2Z0PTIsJHIoKCk9PnJvKFplKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuaGIuc2ImJkJyb3dzZXIuaGIucmVzdW1lKCksJD0hMTt0cnl7dmFyIEk9eXUoKX1jYXRjaChvZSl7ST1vZSwkPSEwfXZhciBQPSExO2lmKCFaZSl7dmFyIFY9WnI7ViYmKFpyPW51bGwsKCQ/Vi5yZWplY3Q6Vi5yZXNvbHZlKShJKSxQPSEwKX1pZigkJiYhUCl0aHJvdyBJfX0pLGY9ITAsY3x8KGZ0PTEsWmU9Z3UoKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5oYi5zYiYmQnJvd3Nlci5oYi5wYXVzZSgpLCRyKCgpPT5lbyhaZSkpKX1lbHNlIGZ0PT09Mj8oZnQ9MCwkcihubyksS24oWmUpLFplPW51bGwsbXUuZm9yRWFjaCgkPT5xdCgkKSkpOktlKGBpbnZhbGlkIHN0YXRlOiAke2Z0fWApO3JldHVybiBGbn19ZnVuY3Rpb24gd3UoaSl7cmV0dXJuIGJ1KGM9PntpKCkudGhlbihjKX0pfW5lLmdiKCk7dmFyIHZ1PVtudWxsLHp0LHByLHd0LE50LG1yLHlyLGJyLHdyLHZyLFJ0LFV0LEx0LEZ0LEh0LGp0LEt0LGwscCxjZSxtZSxFLHRlLGZlLFh0XSwkdT17cjpmdW5jdGlvbihpLGMsZil7cmV0dXJuIHd1KGFzeW5jKCk9Pnthd2FpdCBhLnhiKGksYyxmKX0pfSxiOmZ1bmN0aW9uKGksYyxmKXt0aHJvdyBpPj4+PTAsbmV3IEplKGkpLmdiKGM+Pj4wLGY+Pj4wKSxIZT1pLGZyKyssSGV9LE86ZnVuY3Rpb24oaSl7cW4oaT4+PjAsIXksMSwhdiwxMzEwNzIsITEpLG5lLmxiKCl9LGw6ZnVuY3Rpb24oaSl7aT4+Pj0wLEE/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6aX0pOk90KGkpfSxJOkd0LGk6TnQsVTptcixFOnlyLEc6YnIsVjp3cixTOnZyLEs6UnQsUjpVdCxwOkx0LEY6RnQsQzpIdCxUOmp0LEQ6S3QscTooKT0+ITAsQTpmdW5jdGlvbihpLGMpe2k+Pj49MCxpPT1jPj4+MD9zZXRUaW1lb3V0KCgpPT4kdCgpKTpBP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6aSxjbWQ6XCJjaGVja01haWxib3hcIn0pOihpPW5lLlFhW2ldKSYmaS5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX0sTTpmdW5jdGlvbigpe3JldHVybi0xfSxOOlB0LFg6ZnVuY3Rpb24oaSl7UyYmbmUuUWFbaT4+PjBdLnJlZigpfSx1OmZ1bmN0aW9uKGksYyxmKXtpPWMrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWk/KGk+Pj4wKSs0Mjk0OTY3Mjk2KmM6TmFOLGY+Pj49MCxpPW5ldyBEYXRlKDFlMyppKSxuKClbZj4+Mj4+PjBdPWkuZ2V0VVRDU2Vjb25kcygpLG4oKVtmKzQ+PjI+Pj4wXT1pLmdldFVUQ01pbnV0ZXMoKSxuKClbZis4Pj4yPj4+MF09aS5nZXRVVENIb3VycygpLG4oKVtmKzEyPj4yPj4+MF09aS5nZXRVVENEYXRlKCksbigpW2YrMTY+PjI+Pj4wXT1pLmdldFVUQ01vbnRoKCksbigpW2YrMjA+PjI+Pj4wXT1pLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxuKClbZisyND4+Mj4+PjBdPWkuZ2V0VVRDRGF5KCksaT0oaS5nZXRUaW1lKCktRGF0ZS5VVEMoaS5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MCxuKClbZisyOD4+Mj4+PjBdPWl9LHY6ZnVuY3Rpb24oaSxjLGYpe2k9YysyMDk3MTUyPj4+MDw0MTk0MzA1LSEhaT8oaT4+PjApKzQyOTQ5NjcyOTYqYzpOYU4sZj4+Pj0wLGk9bmV3IERhdGUoMWUzKmkpLG4oKVtmPj4yPj4+MF09aS5nZXRTZWNvbmRzKCksbigpW2YrND4+Mj4+PjBdPWkuZ2V0TWludXRlcygpLG4oKVtmKzg+PjI+Pj4wXT1pLmdldEhvdXJzKCksbigpW2YrMTI+PjI+Pj4wXT1pLmdldERhdGUoKSxuKClbZisxNj4+Mj4+PjBdPWkuZ2V0TW9udGgoKSxuKClbZisyMD4+Mj4+PjBdPWkuZ2V0RnVsbFllYXIoKS0xOTAwLG4oKVtmKzI0Pj4yPj4+MF09aS5nZXREYXkoKSxjPShwdChpLmdldEZ1bGxZZWFyKCkpP3h0Oll0KVtpLmdldE1vbnRoKCldK2kuZ2V0RGF0ZSgpLTF8MCxuKClbZisyOD4+Mj4+PjBdPWMsbigpW2YrMzY+PjI+Pj4wXT0tKDYwKmkuZ2V0VGltZXpvbmVPZmZzZXQoKSksYz1uZXcgRGF0ZShpLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciAkPW5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7aT0oYyE9JCYmaS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbigkLGMpKXwwLG4oKVtmKzMyPj4yPj4+MF09aX0sdzpmdW5jdGlvbihpKXtpPj4+PTA7dmFyIGM9bmV3IERhdGUobigpW2krMjA+PjI+Pj4wXSsxOTAwLG4oKVtpKzE2Pj4yPj4+MF0sbigpW2krMTI+PjI+Pj4wXSxuKClbaSs4Pj4yPj4+MF0sbigpW2krND4+Mj4+PjBdLG4oKVtpPj4yPj4+MF0sMCksZj1uKClbaSszMj4+Mj4+PjBdLCQ9Yy5nZXRUaW1lem9uZU9mZnNldCgpLEk9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxQPW5ldyBEYXRlKGMuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCksVj1NYXRoLm1pbihQLEkpO3JldHVybiAwPmY/bigpW2krMzI+PjI+Pj4wXT0rKEkhPVAmJlY9PSQpOjA8ZiE9KFY9PSQpJiYoST1NYXRoLm1heChQLEkpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGY/VjpJKS0kKSkpLG4oKVtpKzI0Pj4yPj4+MF09Yy5nZXREYXkoKSxmPShwdChjLmdldEZ1bGxZZWFyKCkpP3h0Oll0KVtjLmdldE1vbnRoKCldK2MuZ2V0RGF0ZSgpLTF8MCxuKClbaSsyOD4+Mj4+PjBdPWYsbigpW2k+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxuKClbaSs0Pj4yPj4+MF09Yy5nZXRNaW51dGVzKCksbigpW2krOD4+Mj4+PjBdPWMuZ2V0SG91cnMoKSxuKClbaSsxMj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLG4oKVtpKzE2Pj4yPj4+MF09Yy5nZXRNb250aCgpLG4oKVtpKzIwPj4yPj4+MF09Yy5nZXRZZWFyKCksaT1jLmdldFRpbWUoKS8xZTMsSm4oKGl0PWksMTw9K01hdGguYWJzKGl0KT8wPGl0PytNYXRoLmZsb29yKGl0LzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKGl0LSsofn5pdD4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCkpLGk+Pj4wfSxzOmwsdDpwLHo6ZnVuY3Rpb24oaSxjLGYpe2Z1bmN0aW9uICQoWil7cmV0dXJuKFo9Wi50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFxcXCgoW0EtWmEteiBdKylcXFxcKSQvKSk/WlsxXTpcIkdNVFwifWk+Pj49MCxjPj4+PTAsZj4+Pj0wO3ZhciBJPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxQPW5ldyBEYXRlKEksMCwxKSxWPW5ldyBEYXRlKEksNiwxKTtJPVAuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgb2U9Vi5nZXRUaW1lem9uZU9mZnNldCgpLGVlPU1hdGgubWF4KEksb2UpO3MoKVtpPj4yPj4+MF09NjAqZWUsbigpW2M+PjI+Pj4wXT0rKEkhPW9lKSxpPSQoUCksYz0kKFYpLGk9aChpKSxjPWgoYyksb2U8ST8ocygpW2Y+PjI+Pj4wXT1pLHMoKVtmKzQ+PjI+Pj4wXT1jKToocygpW2Y+PjI+Pj4wXT1jLHMoKVtmKzQ+PjI+Pj4wXT1pKX0sZDooKT0+e0tlKFwiXCIpfSxjOmZ1bmN0aW9uKGksYyxmKXtyZXR1cm4gaT4+Pj0wLGM9VChjPj4+MCxmPj4+MCksRXRbaV0uYXBwbHkobnVsbCxjKX0sazpmdW5jdGlvbihpLGMsZil7cmV0dXJuIGk+Pj49MCxjPVQoYz4+PjAsZj4+PjApLEV0W2ldLmFwcGx5KG51bGwsYyl9LG06ZnVuY3Rpb24oKXt9LGo6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sVzooKT0+e3Rocm93IEdlKz0xLFwidW53aW5kXCJ9LEI6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sZjooKT0+cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKSxnOmZ1bmN0aW9uKCl7cmV0dXJuIFM/KGZvKCksTXQocG8pKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5fSxMOmZ1bmN0aW9uKGksYyxmLCQpe2ZvcihuZS5QYj1jPj4+MCx1ZS5sZW5ndGg9ZixjPSQ+Pj4wPj4zLCQ9MDskPGY7JCsrKXVlWyRdPWQoKVtjKyQ+Pj4wXTtyZXR1cm4oMD5pP0V0Wy1pLTFdOnZ1W2ldKS5hcHBseShudWxsLHVlKX0seTpmdW5jdGlvbihpKXtpPj4+PTA7dmFyIGM9bygpLmxlbmd0aDtpZihpPD1jfHw0Mjk0OTAxNzYwPGkpcmV0dXJuITE7Zm9yKHZhciBmPTE7ND49ZjtmKj0yKXt2YXIgJD1jKigxKy4yL2YpOyQ9TWF0aC5taW4oJCxpKzEwMDY2MzI5Nik7dmFyIEk9TWF0aDskPU1hdGgubWF4KGksJCk7ZTp7ST1JLm1pbi5jYWxsKEksNDI5NDkwMTc2MCwkKyg2NTUzNi0kJTY1NTM2KSU2NTUzNiktd2UuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7d2UuZ3JvdyhJKSxwZSgpO3ZhciBQPTE7YnJlYWsgZX1jYXRjaHt9UD12b2lkIDB9aWYoUClyZXR1cm4hMH1yZXR1cm4hMX0sUDpjZSxROm1lLEg6VnQsaDpFLG86dGUseDpmZSxuOlh0LGE6d2V8fGEud2FzbU1lbW9yeSxKOkxuLGU6ZnVuY3Rpb24oaSxjLGYsJCl7cmV0dXJuIExuKGk+Pj4wLGM+Pj4wLGY+Pj4wLCQ+Pj4wKX19OyhmdW5jdGlvbigpe2Z1bmN0aW9uIGkoZiwkKXtyZXR1cm4gZj1mLmV4cG9ydHMsZj1wdShmKSxqPWY9eHUoZiksbmUubWIucHVzaChqLkRhKSxUZS51bnNoaWZ0KGouWSksU2U9JCxscigpLGZ9dmFyIGM9e2E6JHV9O2lmKEJ0KCksYS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBhLmluc3RhbnRpYXRlV2FzbShjLGkpfWNhdGNoKGYpe0soXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitmKSxnKGYpfXJldHVybiBkcihjLGZ1bmN0aW9uKGYpe2koZi5pbnN0YW5jZSxmLm1vZHVsZSl9KS5jYXRjaChnKSx7fX0pKCksYS5fT3J0SW5pdD0oaSxjKT0+KGEuX09ydEluaXQ9ai5aKShpLGMpLGEuX09ydEdldExhc3RFcnJvcj0oaSxjKT0+KGEuX09ydEdldExhc3RFcnJvcj1qLl8pKGksYyksYS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KGksYyxmLCQsSSxQLFYsb2UsZWUsWik9PihhLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1qLiQpKGksYyxmLCQsSSxQLFYsb2UsZWUsWiksYS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGksYyk9PihhLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1qLmFhKShpLGMpLGEuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0oaSxjLGYpPT4oYS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPWouYmEpKGksYyxmKSxhLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KGksYyxmKT0+KGEuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1qLmNhKShpLGMsZiksYS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWk9PihhLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ai5kYSkoaSksYS5fT3J0Q3JlYXRlU2Vzc2lvbj0oaSxjLGYpPT4oYS5fT3J0Q3JlYXRlU2Vzc2lvbj1qLmVhKShpLGMsZiksYS5fT3J0UmVsZWFzZVNlc3Npb249aT0+KGEuX09ydFJlbGVhc2VTZXNzaW9uPWouZmEpKGkpLGEuX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGksYyxmKT0+KGEuX09ydEdldElucHV0T3V0cHV0Q291bnQ9ai5nYSkoaSxjLGYpLGEuX09ydEdldElucHV0TmFtZT0oaSxjKT0+KGEuX09ydEdldElucHV0TmFtZT1qLmhhKShpLGMpLGEuX09ydEdldE91dHB1dE5hbWU9KGksYyk9PihhLl9PcnRHZXRPdXRwdXROYW1lPWouaWEpKGksYyksYS5fT3J0RnJlZT1pPT4oYS5fT3J0RnJlZT1qLmphKShpKSxhLl9PcnRDcmVhdGVUZW5zb3I9KGksYyxmLCQsSSxQKT0+KGEuX09ydENyZWF0ZVRlbnNvcj1qLmthKShpLGMsZiwkLEksUCksYS5fT3J0R2V0VGVuc29yRGF0YT0oaSxjLGYsJCxJKT0+KGEuX09ydEdldFRlbnNvckRhdGE9ai5sYSkoaSxjLGYsJCxJKSxhLl9PcnRSZWxlYXNlVGVuc29yPWk9PihhLl9PcnRSZWxlYXNlVGVuc29yPWoubWEpKGkpLGEuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGksYyxmLCQpPT4oYS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1qLm5hKShpLGMsZiwkKSxhLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oaSxjLGYpPT4oYS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ai5vYSkoaSxjLGYpLGEuX09ydFJlbGVhc2VSdW5PcHRpb25zPWk9PihhLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1qLnBhKShpKSxhLl9PcnRDcmVhdGVCaW5kaW5nPWk9PihhLl9PcnRDcmVhdGVCaW5kaW5nPWoucWEpKGkpLGEuX09ydEJpbmRJbnB1dD0oaSxjLGYpPT4oYS5fT3J0QmluZElucHV0PWoucmEpKGksYyxmKSxhLl9PcnRCaW5kT3V0cHV0PShpLGMsZiwkKT0+KGEuX09ydEJpbmRPdXRwdXQ9ai5zYSkoaSxjLGYsJCksYS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9aT0+KGEuX09ydENsZWFyQm91bmRPdXRwdXRzPWoudGEpKGkpLGEuX09ydFJlbGVhc2VCaW5kaW5nPWk9PihhLl9PcnRSZWxlYXNlQmluZGluZz1qLnVhKShpKSxhLl9PcnRSdW5XaXRoQmluZGluZz0oaSxjLGYsJCxJKT0+KGEuX09ydFJ1bldpdGhCaW5kaW5nPWoudmEpKGksYyxmLCQsSSksYS5fT3J0UnVuPShpLGMsZiwkLEksUCxWLG9lKT0+KGEuX09ydFJ1bj1qLndhKShpLGMsZiwkLEksUCxWLG9lKSxhLl9PcnRFbmRQcm9maWxpbmc9aT0+KGEuX09ydEVuZFByb2ZpbGluZz1qLnhhKShpKSxhLl9Kc2VwT3V0cHV0PShpLGMsZik9PihhLl9Kc2VwT3V0cHV0PWoueWEpKGksYyxmKSxhLl9Kc2VwR2V0Tm9kZU5hbWU9aT0+KGEuX0pzZXBHZXROb2RlTmFtZT1qLnphKShpKTt2YXIgU3I9YS5fcHRocmVhZF9zZWxmPSgpPT4oU3I9YS5fcHRocmVhZF9zZWxmPWouQWEpKCksUXI9YS5fbWFsbG9jPWk9PihRcj1hLl9tYWxsb2M9ai5CYSkoaSksS249YS5fZnJlZT1pPT4oS249YS5fZnJlZT1qLkNhKShpKTthLl9fZW1zY3JpcHRlbl90bHNfaW5pdD0oKT0+KGEuX19lbXNjcmlwdGVuX3Rsc19pbml0PWouRGEpKCk7dmFyIHFuPWEuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PShpLGMsZiwkLEksUCk9Pihxbj1hLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1qLkZhKShpLGMsZiwkLEksUCk7YS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9KCk9PihhLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1qLkdhKSgpO3ZhciBZbj0oaSxjLGYsJCk9PihZbj1qLkhhKShpLGMsZiwkKSxlbj1pPT4oZW49ai5JYSkoaSksdG49YS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9aT0+KHRuPWEuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWouSmEpKGkpLFhuPWEuX19lbXNjcmlwdGVuX2NoZWNrX21haWxib3g9KCk9PihYbj1hLl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94PWouS2EpKCksSm49aT0+KEpuPWouTGEpKGkpLFpuPShpLGMpPT4oWm49ai5NYSkoaSxjKSxybj0oKT0+KHJuPWouTmEpKCksQ3I9aT0+KENyPWouT2EpKGkpLG5uPWk9Pihubj1qLlBhKShpKSxRbj1hLmR5bkNhbGxfaWk9KGksYyk9PihRbj1hLmR5bkNhbGxfaWk9ai5SYSkoaSxjKSxlbz1pPT4oZW89ai5TYSkoaSksdG89KCk9Pih0bz1qLlRhKSgpLHJvPWk9Pihybz1qLlVhKShpKSxubz0oKT0+KG5vPWouVmEpKCk7YS5fX19zdGFydF9lbV9qcz05MjU3ODMsYS5fX19zdG9wX2VtX2pzPTkyNTk0NDtmdW5jdGlvbiB4dShpKXtpPU9iamVjdC5hc3NpZ24oe30saSk7dmFyIGM9JD0+KCk9PiQoKT4+PjAsZj0kPT5JPT4kKEkpPj4+MDtyZXR1cm4gaS5fX2Vycm5vX2xvY2F0aW9uPWMoaS5fX2Vycm5vX2xvY2F0aW9uKSxpLnB0aHJlYWRfc2VsZj1jKGkucHRocmVhZF9zZWxmKSxpLm1hbGxvYz1mKGkubWFsbG9jKSxpLnN0YWNrU2F2ZT1jKGkuc3RhY2tTYXZlKSxpLnN0YWNrQWxsb2M9ZihpLnN0YWNrQWxsb2MpLGl9YS5rZWVwUnVudGltZUFsaXZlPVhlLGEud2FzbU1lbW9yeT13ZSxhLnN0YWNrQWxsb2M9bm4sYS5zdGFja1NhdmU9cm4sYS5zdGFja1Jlc3RvcmU9Q3IsYS5VVEY4VG9TdHJpbmc9VmUsYS5zdHJpbmdUb1VURjg9Z3IsYS5sZW5ndGhCeXRlc1VURjg9dnQsYS5FeGl0U3RhdHVzPWN0LGEuUFRocmVhZD1uZTt2YXIgQXI7YnQ9ZnVuY3Rpb24gaSgpe0FyfHxvbygpLEFyfHwoYnQ9aSl9O2Z1bmN0aW9uIG9vKCl7ZnVuY3Rpb24gaSgpe2lmKCFBciYmKEFyPSEwLGEuY2FsbGVkUnVuPSEwLCFPZSkmJihBfHxzdChUZSksbShhKSxhLm9uUnVudGltZUluaXRpYWxpemVkJiZhLm9uUnVudGltZUluaXRpYWxpemVkKCksIUEpKXtpZihhLnBvc3RSdW4pZm9yKHR5cGVvZiBhLnBvc3RSdW49PVwiZnVuY3Rpb25cIiYmKGEucG9zdFJ1bj1bYS5wb3N0UnVuXSk7YS5wb3N0UnVuLmxlbmd0aDspe3ZhciBjPWEucG9zdFJ1bi5zaGlmdCgpO2tlLnVuc2hpZnQoYyl9c3Qoa2UpfX1pZighKDA8RmUpKWlmKEEpbShhKSxBfHxzdChUZSksc3RhcnRXb3JrZXIoYSk7ZWxzZXtpZihhLnByZVJ1bilmb3IodHlwZW9mIGEucHJlUnVuPT1cImZ1bmN0aW9uXCImJihhLnByZVJ1bj1bYS5wcmVSdW5dKTthLnByZVJ1bi5sZW5ndGg7KVVlLnVuc2hpZnQoYS5wcmVSdW4uc2hpZnQoKSk7c3QoVWUpLDA8RmV8fChhLnNldFN0YXR1cz8oYS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5zZXRTdGF0dXMoXCJcIil9LDEpLGkoKX0sMSkpOmkoKSl9fWlmKGEucHJlSW5pdClmb3IodHlwZW9mIGEucHJlSW5pdD09XCJmdW5jdGlvblwiJiYoYS5wcmVJbml0PVthLnByZUluaXRdKTswPGEucHJlSW5pdC5sZW5ndGg7KWEucHJlSW5pdC5wb3AoKSgpO3JldHVybiBvbygpLHQucmVhZHl9fSkoKTt0eXBlb2YgaG89PVwib2JqZWN0XCImJnR5cGVvZiBjbj09XCJvYmplY3RcIj9jbi5leHBvcnRzPW1vOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCYmZGVmaW5lKFtdLCgpPT5tbyl9KTt2YXIgeW89SnQoKG1jLF91KT0+e191LmV4cG9ydHM9XFwnXCJ1c2Ugc3RyaWN0XCI7dmFyIE1vZHVsZT17fSxFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIjtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXt2YXIgbm9kZVdvcmtlclRocmVhZHM9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLHBhcmVudFBvcnQ9bm9kZVdvcmtlclRocmVhZHMucGFyZW50UG9ydDtwYXJlbnRQb3J0Lm9uKFwibWVzc2FnZVwiLGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpO3ZhciBmcz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmUsTW9kdWxlLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpub2RlV29ya2VyVGhyZWFkcy5Xb3JrZXIsaW1wb3J0U2NyaXB0czplPT4oMCxldmFsKShmcy5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikrXCIvLyMgc291cmNlVVJMPVwiK2UpLHBvc3RNZXNzYWdlOmU9PnBhcmVudFBvcnQucG9zdE1lc3NhZ2UoZSkscGVyZm9ybWFuY2U6Z2xvYmFsLnBlcmZvcm1hbmNlfHx7bm93OkRhdGUubm93fX0pfXZhciBpbml0aWFsaXplZEpTPSExO2Z1bmN0aW9uIHRocmVhZFByaW50RXJyKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtmcy53cml0ZVN5bmMoMixlK2BcXFxcbmApO3JldHVybn1jb25zb2xlLmVycm9yKGUpfWZ1bmN0aW9uIHRocmVhZEFsZXJ0KCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OmUsdGhyZWFkSWQ6TW9kdWxlLl9wdGhyZWFkX3NlbGYoKX0pfXZhciBlcnI9dGhyZWFkUHJpbnRFcnI7c2VsZi5hbGVydD10aHJlYWRBbGVydCxNb2R1bGUuaW5zdGFudGlhdGVXYXNtPShlLHQpPT57dmFyIGE9TW9kdWxlLndhc21Nb2R1bGU7TW9kdWxlLndhc21Nb2R1bGU9bnVsbDt2YXIgcj1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoYSxlKTtyZXR1cm4gdChyKX0sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9O2Z1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZSl7dHJ5e2lmKGUuZGF0YS5jbWQ9PT1cImxvYWRcIil7bGV0IGE9W107c2VsZi5vbm1lc3NhZ2U9cj0+YS5wdXNoKHIpLHNlbGYuc3RhcnRXb3JrZXI9cj0+e01vZHVsZT1yLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2ZvcihsZXQgcyBvZiBhKWhhbmRsZU1lc3NhZ2Uocyk7c2VsZi5vbm1lc3NhZ2U9aGFuZGxlTWVzc2FnZX0sTW9kdWxlLndhc21Nb2R1bGU9ZS5kYXRhLndhc21Nb2R1bGU7Zm9yKGNvbnN0IHIgb2YgZS5kYXRhLmhhbmRsZXJzKU1vZHVsZVtyXT0oLi4ucyk9Pntwb3N0TWVzc2FnZSh7Y21kOlwiY2FsbEhhbmRsZXJcIixoYW5kbGVyOnIsYXJnczpzfSl9O2lmKE1vZHVsZS53YXNtTWVtb3J5PWUuZGF0YS53YXNtTWVtb3J5LE1vZHVsZS5idWZmZXI9TW9kdWxlLndhc21NZW1vcnkuYnVmZmVyLE1vZHVsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLHR5cGVvZiBlLmRhdGEudXJsT3JCbG9iPT1cInN0cmluZ1wiKWltcG9ydFNjcmlwdHMoZS5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgdD1VUkwuY3JlYXRlT2JqZWN0VVJMKGUuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHModCksVVJMLnJldm9rZU9iamVjdFVSTCh0KX1vcnRXYXNtVGhyZWFkZWQoTW9kdWxlKX1lbHNlIGlmKGUuZGF0YS5jbWQ9PT1cInJ1blwiKXtNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0KGUuZGF0YS5wdGhyZWFkX3B0ciwwLDAsMSksTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdChlLmRhdGEucHRocmVhZF9wdHIpLE1vZHVsZS5lc3RhYmxpc2hTdGFja1NwYWNlKCksTW9kdWxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKGUuZGF0YSksTW9kdWxlLlBUaHJlYWQudGhyZWFkSW5pdFRMUygpLGluaXRpYWxpemVkSlN8fChpbml0aWFsaXplZEpTPSEwKTt0cnl7TW9kdWxlLmludm9rZUVudHJ5UG9pbnQoZS5kYXRhLnN0YXJ0X3JvdXRpbmUsZS5kYXRhLmFyZyl9Y2F0Y2goYSl7aWYoYSE9XCJ1bndpbmRcIil0aHJvdyBhfX1lbHNlIGUuZGF0YS5jbWQ9PT1cImNhbmNlbFwiP01vZHVsZS5fcHRocmVhZF9zZWxmKCkmJk1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOmUuZGF0YS50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwifHwoZS5kYXRhLmNtZD09PVwiY2hlY2tNYWlsYm94XCI/aW5pdGlhbGl6ZWRKUyYmTW9kdWxlLmNoZWNrTWFpbGJveCgpOmUuZGF0YS5jbWQmJihlcnIoXCJ3b3JrZXIuanMgcmVjZWl2ZWQgdW5rbm93biBjb21tYW5kIFwiK2UuZGF0YS5jbWQpLGVycihlLmRhdGEpKSl9Y2F0Y2goYSl7dGhyb3cgTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCgpLGF9fXNlbGYub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2U7XFxcXG5cXCd9KTt2YXIgbW4sUXQsZXIsVHIsdHIsU28saG4sRGU9SCgoKT0+e1widXNlIHN0cmljdFwiO21uPWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiAxMDtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxRdD1lPT57c3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTA6cmV0dXJuXCJmbG9hdDE2XCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sZXI9ZT0+W3ZvaWQgMCw0LDEsMSwyLDIsNCw4LHZvaWQgMCwxLDIsOCw0LDgsdm9pZCAwLHZvaWQgMCx2b2lkIDBdW2VdLFRyPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHtlfWApfX0sdHI9ZT0+e3N3aXRjaChlKXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKX19LFNvPWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwiYm9vbFwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cInVpbnQzMlwiLGhuPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBWdSxHdSxDbyxBbyxJbyxOdSxFZSxtdD1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtWdT1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLEd1PShlLHQpPT57Y29uc29sZS5sb2coYFske1Z1W2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxJbz0oZSx0KT0+e0NvPWUsQW89dH0sTnU9KGUsdCk9PntsZXQgcj10cihlKSxvPXRyKENvKTtyPj1vJiZHdShyLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSxFZT0oLi4uZSk9PntBbyYmTnUoLi4uZSl9fSk7dmFyIEVvLFRvPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO0VvPShlLHQpPT5uZXcoVHIodCkpKGUpfSk7dmFyIE9vPUgoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBPcixVdSxfbyx5bixnbixSbyxQbz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bXQoKTtPbygpO09yPWU9Pk1hdGguY2VpbChlLzE2KSoxNixVdT0xLF9vPSgpPT5VdSsrLHluPWFzeW5jKGUsdCxyLG8pPT57bGV0IG49T3Iocikscz1lLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bix1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3RyeXtsZXQgdT1lLmdldENvbW1hbmRFbmNvZGVyKCk7ZS5lbmRDb21wdXRlUGFzcygpLHUuY29weUJ1ZmZlclRvQnVmZmVyKHQsMCxzLDAsbiksZS5mbHVzaCgpLGF3YWl0IHMubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtsZXQgZD1zLmdldE1hcHBlZFJhbmdlKCk7aWYobyl7bGV0IGE9bygpO3JldHVybiBhLnNldChuZXcgVWludDhBcnJheShkLDAscikpLGF9ZWxzZSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZC5zbGljZSgwLHIpKX1maW5hbGx5e3MuZGVzdHJveSgpfX0sZ249Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nPVtdLHRoaXMuYnVmZmVyc1BlbmRpbmc9W10sdGhpcy5leHRlcm5hbEJ1ZmZlcnM9bmV3IE1hcH11cGxvYWQodCxyKXtsZXQgbz1yLmJ1ZmZlcixuPXIuYnl0ZU9mZnNldCxzPXIuYnl0ZUxlbmd0aCx1PU9yKHMpLGQ9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImdwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3RcIik7aWYoZC5vcmlnaW5hbFNpemUhPT1zKXRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2Qub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7c31gKTtsZXQgYT10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7bWFwcGVkQXRDcmVhdGlvbjohMCxzaXplOnUsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSksbT1hLmdldE1hcHBlZFJhbmdlKCk7bmV3IFVpbnQ4QXJyYXkobSkuc2V0KG5ldyBVaW50OEFycmF5KG8sbixzKSksYS51bm1hcCgpO2xldCBnPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLGcuY29weUJ1ZmZlclRvQnVmZmVyKGEsMCxkLmdwdURhdGEuYnVmZmVyLDAsdSksRWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHt0fSlgKSx0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nLnB1c2goYSl9bWVtY3B5KHQscil7bGV0IG89dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFvKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2xldCBuPXRoaXMuc3RvcmFnZUNhY2hlLmdldChyKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2lmKG8ub3JpZ2luYWxTaXplIT09bi5vcmlnaW5hbFNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZVwiKTtsZXQgcz1PcihvLm9yaWdpbmFsU2l6ZSksdT10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx1LmNvcHlCdWZmZXJUb0J1ZmZlcihvLmdwdURhdGEuYnVmZmVyLDAsbi5ncHVEYXRhLmJ1ZmZlciwwLHMpfXJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCxyLG8pe2xldCBuO2lmKG8pe2lmKG49dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KG8pLG49PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgYnVmZmVyIGlzIG5vdCByZWdpc3RlcmVkXCIpO2lmKHQ9PT1vKXJldHVybiBFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke259LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCksbjt0aGlzLmV4dGVybmFsQnVmZmVycy5kZWxldGUobyl9ZWxzZSBuPV9vKCk7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChuLHtncHVEYXRhOntpZDpuLHR5cGU6MCxidWZmZXI6dH0sb3JpZ2luYWxTaXplOnJ9KSx0aGlzLmV4dGVybmFsQnVmZmVycy5zZXQodCxuKSxFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke259LCByZWdpc3RlcmVkLmApLG59dW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQpe2xldCByPXRoaXMuZXh0ZXJuYWxCdWZmZXJzLmdldCh0KTtyIT09dm9pZCAwJiYodGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHIpLHRoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZSh0KSxFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7cn1gKSl9Y3JlYXRlKHQscj1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKXtsZXQgbz1Pcih0KSxuLHM9KHImR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFLHU9KHImR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNO2lmKHN8fHUpe2xldCBhPXM/dGhpcy5mcmVlQnVmZmVyczp0aGlzLmZyZWVVbmlmb3JtQnVmZmVycyxtPWEuZ2V0KG8pO218fChtPVtdLGEuc2V0KG8sbSkpLG0ubGVuZ3RoPjA/bj1tLnBvcCgpOm49dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpyfSl9ZWxzZSBuPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm8sdXNhZ2U6cn0pO2xldCBkPXtpZDpfbygpLHR5cGU6MCxidWZmZXI6bn07cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChkLmlkLHtncHVEYXRhOmQsb3JpZ2luYWxTaXplOnR9KSxFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7dH0pID0+IGlkPSR7ZC5pZH1gKSxkfWdldCh0KXtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpPy5ncHVEYXRhfXJlbGVhc2UodCl7bGV0IHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcInJlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0XCIpO3JldHVybiBFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHt0fSksIGdwdURhdGFJZD0ke3IuZ3B1RGF0YS5pZH1gKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUodCksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKHIuZ3B1RGF0YS5idWZmZXIpLHIub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKHQscil7bGV0IG89dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFvKXRocm93IG5ldyBFcnJvcihcImRhdGEgZG9lcyBub3QgZXhpc3RcIik7YXdhaXQgeW4odGhpcy5iYWNrZW5kLG8uZ3B1RGF0YS5idWZmZXIsby5vcmlnaW5hbFNpemUscil9cmVmcmVzaFBlbmRpbmdCdWZmZXJzKCl7Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcpdC5kZXN0cm95KCk7dGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZz1bXTtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzUGVuZGluZykodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0U/dGhpcy5mcmVlQnVmZmVycy5nZXQodC5zaXplKS5wdXNoKHQpOih0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STT90aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQodC5zaXplKS5wdXNoKHQpOnQuZGVzdHJveSgpO3RoaXMuYnVmZmVyc1BlbmRpbmc9W119ZGlzcG9zZSgpe3RoaXMuZnJlZUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pfSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pfSksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaCh0PT57dC5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwfX0sUm89KC4uLmUpPT5uZXcgZ24oLi4uZSl9KTt2YXIgYm4saWUsUGU9SCgoKT0+e1widXNlIHN0cmljdFwiO2JuPWNsYXNze2NvbnN0cnVjdG9yKHQpe09iamVjdC5hc3NpZ24odGhpcyx0KX1nZXQgY2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5fY2FjaGVLZXl8fCh0aGlzLl9jYWNoZUtleT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5zb3J0KCkubWFwKHQ9PmAke3RoaXNbdF19YCkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX0saWU9ZT0+bmV3IGJuKGUpfSk7dmFyIHduLFFlLGssQ3QsX3IsUnIsUHIsZ2U9SCgoKT0+e1widXNlIHN0cmljdFwiO3duPWNsYXNze3N0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxyKXtyZXR1cm4gdFsxXSE9PXJbMF0/dm9pZCAwOlt0WzBdLHJbMV1dfX0sUWU9Y2xhc3N7c3RhdGljIGNhbGNTaGFwZSh0LHIsbz0hMSl7bGV0IG49dC5sZW5ndGgscz1yLmxlbmd0aDtpZihuPT09MClyZXR1cm4gcjtpZihzPT09MClyZXR1cm4gdDtsZXQgdT1NYXRoLm1heCh0Lmxlbmd0aCxyLmxlbmd0aCksZD1uZXcgQXJyYXkodSk7aWYobyl7aWYobjwyfHxzPDIpcmV0dXJuO2xldCBhPXduLmNhbGNNYXRNdWxTaGFwZShbdFtuLTJdLHRbbi0xXV0sW3Jbcy0yXSxyW3MtMV1dKTtpZihhPT09dm9pZCAwKXJldHVybjtbZFt1LTJdLGRbdS0xXV09YX1mb3IobGV0IGE9bz8zOjE7YTw9dTthKyspe2xldCBtPW4tYTwwPzE6dFtuLWFdLGc9cy1hPDA/MTpyW3MtYV07aWYobSE9PWcmJm0+MSYmZz4xKXJldHVybjtkW3UtYV09TWF0aC5tYXgobSxnKX1yZXR1cm4gZH1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LHIpe2xldCBvPXQubGVuZ3RoLG49ci5sZW5ndGg7aWYobz5uKXJldHVybiExO2ZvcihsZXQgcz0xO3M8PW87cysrKWlmKHRbby1zXSE9PTEmJnRbby1zXSE9PXJbbi1zXSlyZXR1cm4hMTtyZXR1cm4hMH19LGs9Y2xhc3MgZXtzdGF0aWMgc2l6ZSh0KXtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCx0Lmxlbmd0aCl9c3RhdGljIHNpemVGcm9tRGltZW5zaW9uKHQscil7aWYocjwwfHxyPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtyfSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZVRvRGltZW5zaW9uKHQscil7aWYocjwwfHxyPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtyfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCxyKX1zdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsbyl7bGV0IG49MTtmb3IobGV0IHM9cjtzPG87cysrKXtpZih0W3NdPDApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLlwiKTtuKj10W3NdfXJldHVybiBufXN0YXRpYyBjb21wdXRlU3RyaWRlcyh0KXtsZXQgcj10Lmxlbmd0aDtpZihyPT09MClyZXR1cm5bXTtpZihyPT09MSlyZXR1cm5bMV07bGV0IG89bmV3IEFycmF5KHIpO29bci0xXT0xLG9bci0yXT10W3ItMV07Zm9yKGxldCBuPXItMztuPj0wOy0tbilvW25dPW9bbisxXSp0W24rMV07cmV0dXJuIG99c3RhdGljIG5vcm1hbGl6ZUF4aXModCxyKXtpZih0PC1yJiZ0Pj1yKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3Qrcjp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQscil7cmV0dXJuIHQubWFwKG89PnRoaXMubm9ybWFsaXplQXhpcyhvLHI/P3QubGVuZ3RoKSl9c3RhdGljIHNvcnRCYXNlZE9uUGVybSh0LHIpe3JldHVybiByP3IubWFwKG89PnRbb10pOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQscil7bGV0IG89dC5sZW5ndGg7cmV0dXJuIHQubWFwKChuLHMpPT5uK3Jbc10rcltzK29dKX1zdGF0aWMgYXJlRXF1YWwodCxyKXtyZXR1cm4gdC5sZW5ndGghPT1yLmxlbmd0aD8hMTp0LmV2ZXJ5KChvLG4pPT5vPT09cltuXSl9fSxDdD1jbGFzcyBle3N0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyh0LHIsbyxuLHMsdSl7aWYoIXQmJm8ubGVuZ3RoIT09ci5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zXCIpO2lmKHQpZm9yKGxldCBkPTA7ZDxyLmxlbmd0aC0yO2QrKylkPj1vLmxlbmd0aD9vLnB1c2gocltkKzJdKTpvW2RdPXJbZCsyXTtmb3IobGV0IGQ9MDtkPG8ubGVuZ3RoO2QrKylpZihkPG4ubGVuZ3RoKXtpZihuW2RdPDApdGhyb3cgbmV3IEVycm9yKFwic3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBuLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxvLmxlbmd0aDtkKyspaWYoZDxzLmxlbmd0aCl7aWYoc1tkXTwwKXRocm93IG5ldyBFcnJvcihcImRpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBzLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxvLmxlbmd0aCoyO2QrKylpZihkPHUubGVuZ3RoKXtpZih1W2RdPDApdGhyb3cgbmV3IEVycm9yKFwicGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHUucHVzaCgwKTtmb3IobGV0IGQ9MDtkPG8ubGVuZ3RoO2QrKyl7aWYob1tkXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDBcIik7aWYodVtkXT49b1tkXXx8dVtkK28ubGVuZ3RoXT49b1tkXSl0aHJvdyBuZXcgRXJyb3IoXCJwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsXCIpfX1zdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHQscixvLG4scyx1LGQpe2lmKGQpe2lmKHMubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHIubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYobi5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoLTI7YSsrKWUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFthKyh1PzE6MildLHJbYV0sb1thXSxuW2FdLHMsYSxhK3QubGVuZ3RoLTIsZCl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQscixvLG4scyx1LGQpe2lmKHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtsZXQgYT1bclswXSxyWzFdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIodCxyLGEsbyxuLHMsdSxkKSxhfXN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKHQscixvLG4scyx1LGQpe2lmKHQubGVuZ3RoPD0wfHxyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zXCIpO2xldCBhPVt0WzBdLHJbMF1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcighMSx0LGEsbyxuLHMsdSxkKSxhfXN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIodCxyLG8sbixzLHUsZCxhKXtpZih0KWZvcihsZXQgbT0wO208ci5sZW5ndGgtMjttKyspby5wdXNoKDEpO2Vsc2UgZm9yKGxldCBtPTA7bTxyLmxlbmd0aC0yO20rKylvLnB1c2goZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShyW20rMl0sblttXSxzW21dLHVbbV0sZCxtLG0rci5sZW5ndGgtMixhKSl9c3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKHQscixvLG4scyx1LGQsYSl7bGV0IG09byoobi0xKSsxO2lmKGEmJmEhPT1cIk5PVFNFVFwiKXN3aXRjaChhKXtjYXNlXCJWQUxJRFwiOnJldHVybiBzW3VdPTAsc1tkXT0wLE1hdGguZmxvb3IoKHQtbSkvcisxKTtjYXNlXCJTQU1FX0xPV0VSXCI6Y2FzZVwiU0FNRV9VUFBFUlwiOmlmKG8hPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUlwiKTt7bGV0IHg9KCh0K3ItMSkvci0xKSpyK24tdDtyZXR1cm4gc1t1XT1NYXRoLmZsb29yKGE9PT1cIlNBTUVfTE9XRVJcIj8oeCsxKS8yOngvMiksc1tkXT14LXNbdV0sTWF0aC5mbG9vcigodCt4LW4pL3IrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9ZWxzZSByZXR1cm4gTWF0aC5mbG9vcigodCtzW3VdK3NbZF0tbSkvcisxKX19LF9yPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdCh0LHIsbyxuLHMpe2lmKHQubGVuZ3RoIT09Mnx8by5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCB1LGQsYTtyPyh1PXRbMV0sZD10WzBdKToodT10WzBdLGQ9dFsxXSk7bGV0IG09LTE7aWYobj8oYT1vWzBdLG09MSk6KGE9b1sxXSxtPTApLG9bbV0hPT1kKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZih1PD0wfHxhPD0wfHxkPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKHMmJiFRZS5pc1ZhbGlkQnJvYWRjYXN0KHMsW3UsYV0pKXRocm93IG5ldyBFcnJvcihcImdlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0XCIpO3JldHVyblt1LGEsZF19fSxScj0tMzQwMjgyMzQ2NjM4NTI4ODZlMjIsUHI9MzQwMjgyMzQ2NjM4NTI4ODZlMjJ9KTt2YXIgTHUsTW8sTWUsJG4sbHQscWUsQXQsaHQsQm8sTCxYLHZuLGtvLHhuLERvLHZlPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7THU9NjQsTW89KGUsdCk9PntpZih0PT09Myl0aHJvdyBuZXcgRXJyb3IoXCJ2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkXCIpO3N3aXRjaChlKXtjYXNlIDEwOnJldHVybiB0PjE/YHZlYyR7dH08ZjE2PmA6XCJmMTZcIjtjYXNlIDE6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMzI+YDpcImYzMlwiO2Nhc2UgNjpyZXR1cm4gdD4xP2B2ZWMke3R9PGkzMj5gOlwiaTMyXCI7Y2FzZSAxMjpyZXR1cm4gdD4xP2B2ZWMke3R9PHUzMj5gOlwidTMyXCI7Y2FzZSA3OmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJpMzJcIl07Y2FzZSAxMzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwidTMyXCJdO2Nhc2UgOTppZih0IT09NCl0aHJvdyBuZXcgRXJyb3IoXCJib29sIG11c3QgYmUgdmVjNFwiKTtyZXR1cm5bXCJ1MzJcIixcInZlYzQ8Ym9vbD5cIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxNZT0oZSx0PTEpPT57bGV0IHI9TW8oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzBdfSwkbj1lPT5be3R5cGU6XCJ1aW50MzJcIixkYXRhOmV9LHt0eXBlOlwidWludDMyXCIsZGF0YTprLmNvbXB1dGVTdHJpZGVzKGUpfV0sbHQ9ZT0+ZSU0PT09MD80OmUlMj09PTA/MjoxLHFlPShlPVwiZjMyXCIsdCxyPVwiMFwiKT0+IXR8fHQ9PT0xP2Ake2V9KCR7cn0pYDpgdmVjJHt0fTwke2V9Pigke3J9KWAsQXQ9KGUsdCxyKT0+ZT09PVwiZjMyXCI/cjp0PT09MT9gZjMyKCR7cn0pYDpgdmVjJHt0fWYoJHtyfSlgLGh0PShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLEJvPShlLHQscixvLG4pPT57bGV0IHM9dHlwZW9mIHI9PVwibnVtYmVyXCIsdT1zP3I6ci5sZW5ndGgsZD1bLi4ubmV3IEFycmF5KHUpLmtleXMoKV0sYT11PDI/XCJ1MzJcIjp1PD00P2B2ZWMke3V9PHUzMj5gOmBhcnJheTx1MzIsICR7dX0+YCxtPU1vKHQsbiksZz10eXBlb2YgbT09XCJzdHJpbmdcIj9tOm1bMV0seD10eXBlb2YgbT09XCJzdHJpbmdcIj9tOm1bMF0sYj17aW5kaWNlczphLHZhbHVlOmcsc3RvcmFnZTp4LHRlbnNvcjp0fSx3PU49PnR5cGVvZiBOPT1cInN0cmluZ1wiP046YCR7Tn11YCx2PXtvZmZzZXRUb0luZGljZXM6ITEsaW5kaWNlc1RvT2Zmc2V0OiExLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiExLHNldDohMSxzZXRCeUluZGljZXM6ITEsZ2V0OiExLGdldEJ5SW5kaWNlczohMX0seT1zP1widW5pZm9ybXMuXCI6XCJcIixTPWAke3l9JHtlfV9zaGFwZWAsQT1gJHt5fSR7ZX1fc3RyaWRlc2AsUj1cIlwiO2ZvcihsZXQgTj0wO048dS0xO04rKylSKz1gXFxuICAgIGxldCBkaW0ke059ID0gY3VycmVudCAvICR7QX1bJHtOfV07XFxuICAgIGxldCByZXN0JHtOfSA9IGN1cnJlbnQgJSAke0F9WyR7Tn1dO1xcbiAgICBpbmRpY2VzWyR7Tn1dID0gZGltJHtOfTtcXG4gICAgY3VycmVudCA9IHJlc3Qke059O1xcbiAgICBgO1IrPWBpbmRpY2VzWyR7dS0xfV0gPSBjdXJyZW50O2A7bGV0IFc9dTwyP1wiXCI6YFxcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7Yi5pbmRpY2VzfSB7XFxuICAgIHZhciBpbmRpY2VzOiAke2IuaW5kaWNlc307XFxuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xcbiAgICAke1J9XFxuICAgIHJldHVybiBpbmRpY2VzO1xcbiAgfWAsTT1OPT4odi5vZmZzZXRUb0luZGljZXM9ITAsdTwyP046YG8yaV8ke2V9KCR7Tn0pYCksRD1bXTtpZih1Pj0yKWZvcihsZXQgTj11LTE7Tj49MDtOLS0pRC5wdXNoKGAke0F9WyR7Tn1dICogKGluZGljZXNbJHtOfV0pYCk7bGV0IF89dTwyP1wiXCI6YFxcbiAgZm4gaTJvXyR7ZX0oaW5kaWNlczogJHtiLmluZGljZXN9KSAtPiB1MzIge1xcbiAgICByZXR1cm4gJHtELmpvaW4oXCIrXCIpfTtcXG4gIH1gLHo9Tj0+KHYuaW5kaWNlc1RvT2Zmc2V0PSEwLHU8Mj9OOmBpMm9fJHtlfSgke059KWApLEY9KC4uLk4pPT51PT09MD9cIjB1XCI6YCR7Yi5pbmRpY2VzfSgke04ubWFwKHcpLmpvaW4oXCIsXCIpfSlgLHE9KE4sZGUpPT51PDI/YCR7Tn1gOmAke059WyR7ZGV9XWAsbGU9KE4sZGUscGUpPT51PDI/YCR7Tn09JHtwZX07YDpgJHtOfVske2RlfV09JHtwZX07YCxCPXt9LEs9KE4sZGUpPT57di5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgcGU9YCR7ZGUubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKHBlIGluIEIpcmV0dXJuYCR7cGV9KCR7Tn0pYDtsZXQgemU9W107Zm9yKGxldCBVZT11LTE7VWU+PTA7VWUtLSl7bGV0IFRlPWRlLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsVWUrZGUucmFuay11KTt6ZS5wdXNoKGAke3EoQSxVZSl9ICogKCR7VGV9ICUgJHtxKFMsVWUpfSlgKX1yZXR1cm4gQltwZV09YGZuICR7cGV9KG91dHB1dEluZGljZXM6ICR7ZGUudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcXG4gICAgICAgICAgICAgcmV0dXJuICR7emUubGVuZ3RoPjA/emUuam9pbihcIitcIik6XCIwdVwifTtcXG4gICAgICAgICAgIH1gLGAke3BlfSgke059KWB9LHhlPShOLGRlKT0+KCgpPT57aWYoYi5zdG9yYWdlPT09Yi52YWx1ZSlyZXR1cm5gJHtlfVske059XT0ke2RlfTtgO2lmKGIuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmIudmFsdWU9PT1cImkzMlwiKXJldHVybmAke2V9WyR7Tn1dPXZlYzI8dTMyPih1MzIoJHtkZX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke2RlfSA8IDApKTtgO2lmKGIuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmIudmFsdWU9PT1cInUzMlwiKXJldHVybmAke2V9WyR7Tn1dPXZlYzI8dTMyPih1MzIoJHtkZX0pLCAwdSk7YDtpZihiLnN0b3JhZ2U9PT1cInUzMlwiJiZiLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYCR7ZX1bJHtOfV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHtkZX0pKTtgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtiLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7Yi52YWx1ZX0geWV0YCl9KSgpLGFlPU49PigoKT0+e2lmKGIuc3RvcmFnZT09PWIudmFsdWUpcmV0dXJuYCR7ZX1bJHtOfV1gO2lmKGIuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmIudmFsdWU9PT1cImkzMlwiKXJldHVybmBpMzIoJHtlfVske059XS54KWA7aWYoYi5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmYi52YWx1ZT09PVwidTMyXCIpcmV0dXJuYHUzMigke2V9WyR7Tn1dLngpYDtpZihiLnN0b3JhZ2U9PT1cInUzMlwiJiZiLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYHZlYzQ8Ym9vbD4oYm9vbCgke2V9WyR7Tn1dICYgMHhGRnUpLCBib29sKCR7ZX1bJHtOfV0gJiAweEZGMDB1KSwgYm9vbCgke2V9WyR7Tn1dICYgMHhGRjAwMDB1KSwgYm9vbCgke2V9WyR7Tn1dICYgMHhGRjAwMDAwMHUpKWA7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2Iuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtiLnZhbHVlfSB5ZXRgKX0pKCksd2U9dTwyP1wiXCI6YFxcbiAgZm4gZ2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtiLmluZGljZXN9KSAtPiAke2d9IHtcXG4gICAgcmV0dXJuICR7YWUoYGkyb18ke2V9KGluZGljZXMpYCl9O1xcbiAgfWAsaj11PDI/XCJcIjooKCk9PntsZXQgTj1kLm1hcChwZT0+YGQke3BlfTogdTMyYCkuam9pbihcIiwgXCIpLGRlPWQubWFwKHBlPT5gZCR7cGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcXG4gIGZuIGdldF8ke2V9KCR7Tn0pIC0+ICR7Z30ge1xcbiAgICByZXR1cm4gZ2V0XyR7ZX1CeUluZGljZXMoJHtGKGRlKX0pO1xcbiAgfWB9KSgpLFNlPSguLi5OKT0+e2lmKE4ubGVuZ3RoIT09dSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHt1fWApO2xldCBkZT1OLm1hcCh3KS5qb2luKFwiLFwiKTtyZXR1cm4gdT09PTA/YWUoXCIwdVwiKTp1PT09MT9hZShkZVswXSk6KHYuZ2V0PSEwLHYuZ2V0QnlJbmRpY2VzPSEwLHYuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfSgke2RlfSlgKX0sT2U9Tj0+dTwyP2FlKE4pOih2LmdldEJ5SW5kaWNlcz0hMCx2LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX1CeUluZGljZXMoJHtOfSlgKSxJZT11PDI/XCJcIjpgXFxuICBmbiBzZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2IuaW5kaWNlc30sIHZhbHVlOiAke2d9KSB7XFxuICAgICR7eGUoYGkyb18ke2V9KGluZGljZXMpYCxcInZhbHVlXCIpfVxcbiAgfWAsQ2U9dTwyP1wiXCI6KCgpPT57bGV0IE49ZC5tYXAocGU9PmBkJHtwZX06IHUzMmApLmpvaW4oXCIsIFwiKSxkZT1kLm1hcChwZT0+YGQke3BlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXFxuICBmbiBzZXRfJHtlfSgke059LCB2YWx1ZTogJHtnfSkge1xcbiAgICBzZXRfJHtlfUJ5SW5kaWNlcygke0YoZGUpfSwgdmFsdWUpO1xcbiAgfWB9KSgpO3JldHVybntpbXBsOigpPT57bGV0IE49W107cmV0dXJuIHN8fChOLnB1c2goYGNvbnN0ICR7U30gPSAke2IuaW5kaWNlc30oJHtyLmpvaW4oXCIsXCIpfSk7YCksTi5wdXNoKGBjb25zdCAke0F9ID0gJHtiLmluZGljZXN9KCR7ay5jb21wdXRlU3RyaWRlcyhyKS5qb2luKFwiLFwiKX0pO2ApKSx2Lm9mZnNldFRvSW5kaWNlcyYmTi5wdXNoKFcpLHYuaW5kaWNlc1RvT2Zmc2V0JiZOLnB1c2goXyksdi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCYmT2JqZWN0LnZhbHVlcyhCKS5mb3JFYWNoKGRlPT5OLnB1c2goZGUpKSx2LnNldCYmTi5wdXNoKENlKSx2LnNldEJ5SW5kaWNlcyYmTi5wdXNoKEllKSx2LmdldCYmTi5wdXNoKGopLHYuZ2V0QnlJbmRpY2VzJiZOLnB1c2god2UpLE4uam9pbihgXFxuYCl9LHR5cGU6YixvZmZzZXRUb0luZGljZXM6TSxpbmRpY2VzVG9PZmZzZXQ6eixicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDpLLGluZGljZXM6RixpbmRpY2VzR2V0OnEsaW5kaWNlc1NldDpsZSxzZXQ6KC4uLk4pPT57aWYoTi5sZW5ndGghPT11KzEpdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7dX1gKTtsZXQgZGU9Tlt1XTtpZih0eXBlb2YgZGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IHBlPU4uc2xpY2UoMCx1KS5tYXAodykuam9pbihcIixcIik7cmV0dXJuIHU9PT0wP3hlKFwiMHVcIixkZSk6dT09PTE/eGUocGVbMF0sZGUpOih2LnNldD0hMCx2LnNldEJ5SW5kaWNlcz0hMCx2LmluZGljZXNUb09mZnNldD0hMCxgc2V0XyR7ZX0oJHtwZX0sICR7ZGV9KWApfSxzZXRCeU9mZnNldDp4ZSxzZXRCeUluZGljZXM6KE4sZGUpPT51PDI/eGUoTixkZSk6KHYuc2V0QnlJbmRpY2VzPSEwLHYuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke059LCAke2RlfSk7YCksZ2V0OlNlLGdldEJ5T2Zmc2V0OmFlLGdldEJ5SW5kaWNlczpPZSx1c2FnZTpvP1wiaW5wdXRcIjpcIm91dHB1dFwiLG5hbWU6ZSxzdHJpZGVzOkEsc2hhcGU6UyxyYW5rOnV9fSxMPShlLHQscixvPTEpPT5CbyhlLHQsciwhMCxvKSxYPShlLHQscixvPTEpPT5CbyhlLHQsciwhMSxvKSx2bj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPXQ7dGhpcy5pbmRpY2VzSGVscGVycz1bXTt0aGlzLnVuaWZvcm1zPVtdO3RoaXMudmFyaWFibGVJbmRleD0wfWd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModCl7cmV0dXJuYGlmIChnbG9iYWxfaWR4ID49ICR7dHlwZW9mIHQ9PVwibnVtYmVyXCI/YCR7dH11YDp0fSkgeyByZXR1cm47IH1gfW1haW5TdGFydCh0PUx1KXtsZXQgcj10eXBlb2YgdD09XCJudW1iZXJcIj90OnRbMF0sbz10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMV0sbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMl0scz10aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdPT09MSYmdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXT09PTEsdT1zP2BAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmA6YEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2luZGV4IDogdTMyLFxcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPmAsZD1zP1wibGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDtcIjpgbGV0IGdsb2JhbF9pZHggPSAod29ya2dyb3VwX2lkLnogKiAke3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF0qdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXX11ICtcXG4gICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiAke3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF19dSArIHdvcmtncm91cF9pZC54KSAqICR7cipvKm59dSArIGxvY2FsX2luZGV4O2A7cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3J9LCAke299LCAke259KVxcbiAgZm4gbWFpbigke3V9KSB7XFxuICAgICR7ZH1cXG4gIGB9ZGVjbGFyZVZhcmlhYmxlKHQscil7dGhpcy5pbmRpY2VzSGVscGVycy5wdXNoKHQpLHQuc2hhcGUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc2hhcGUucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6dC50eXBlLmluZGljZXN9KSx0LnN0cmlkZXMuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc3RyaWRlcy5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTp0LnR5cGUuaW5kaWNlc30pO2xldCBvPXQudXNhZ2U9PT1cImlucHV0XCI/XCJyZWFkXCI6XCJyZWFkX3dyaXRlXCIsbj10LnR5cGUuc3RvcmFnZTtyZXR1cm5gQGdyb3VwKDApIEBiaW5kaW5nKCR7cn0pIHZhcjxzdG9yYWdlLCAke299PiAke3QubmFtZX06IGFycmF5PCR7bn0+O2B9ZGVjbGFyZVZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5tYXAocj0+dGhpcy5kZWNsYXJlVmFyaWFibGUocix0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oYFxcbmApfXJlZ2lzdGVyVW5pZm9ybSh0LHIpe3JldHVybiB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dCx0eXBlOnJ9KSx0aGlzfXVuaWZvcm1EZWNsYXJhdGlvbigpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCB0PVtdO2ZvcihsZXR7bmFtZTpyLHR5cGU6b31vZiB0aGlzLnVuaWZvcm1zKXQucHVzaChgJHtyfToke299YCk7cmV0dXJuYFxcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dC5qb2luKFwiLCBcIil9IH07XFxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7dGhpcy52YXJpYWJsZUluZGV4fSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztgfWdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCl7cmV0dXJuIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkrdGhpcy5pbmRpY2VzSGVscGVycy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxcbmApfX0sa289ZT0+bmV3IHZuKGUpLHhuPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgsbz1bXTtmb3IobGV0IG49MDtuPHI7bisrKXtsZXQgcz1yLTEtbix1PWVbc118fDE7KHRbdC5sZW5ndGgtMS1uXXx8MSk+MSYmdT09PTEmJm8udW5zaGlmdChzKX1yZXR1cm4gb30sRG89ZT0+ZTw9NH0pO3ZhciBGdSxXbyxIdSxqdSxndCx6byxWbyxycj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7RnU9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxXbz0oZSx0KT0+dCYmdC5sZW5ndGghPT1lP1suLi5uZXcgQXJyYXkoZSkua2V5cygpXS5yZXZlcnNlKCk6dCxIdT0oZSx0KT0+ay5zb3J0QmFzZWRPblBlcm0oZSxXbyhlLmxlbmd0aCx0KSksanU9KGUsdCxyLG8pPT57bGV0IG49W107bi5wdXNoKGBmbiBwZXJtKGk6ICR7by50eXBlLmluZGljZXN9KSAtPiAke3IudHlwZS5pbmRpY2VzfSB7XFxuICAgIHZhciBhOiAke3IudHlwZS5pbmRpY2VzfTtgKTtmb3IobGV0IHM9MDtzPHQ7KytzKW4ucHVzaChyLmluZGljZXNTZXQoXCJhXCIsZVtzXSxgaVske3N9XWApKTtyZXR1cm4gbi5wdXNoKFwicmV0dXJuIGE7fVwiKSxuLmpvaW4oYFxcbmApfSxndD0oZSx0KT0+e2xldCByPWUuZGF0YVR5cGUsbz1lLmRpbXMubGVuZ3RoLG49V28obyx0KSxzPURvKG8pLHU9SHUoZS5kaW1zLG4pLGQ9cz91Lmxlbmd0aDp1LGE9cz9vOmUuZGltcyxtPVgoXCJvdXRwdXRcIixyLGQpLGc9TChcImFcIixyLGEpLHg9Yj0+YFxcbiAgJHtiLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhnLG0pfVxcblxcbiAgJHtqdShuLG8sZyxtKX1cXG5cXG4gICR7Yi5tYWluU3RhcnQoKX1cXG4gICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cXG5cXG4gICAgbGV0IGluZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XFxuXFxuICAgICR7bS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixnLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cXG4gIH1gO3JldHVybntuYW1lOlwiVHJhbnNwb3NlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOnM/W1wicmFua1wiXTpbXCJkaW1zXCJdfSxnZXRSdW5EYXRhOmI9PntsZXQgdz1rLnNpemUodSk7cmV0dXJue291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6YlswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHcvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cz9be3R5cGU6XCJ1aW50MzJcIixkYXRhOnd9LC4uLiRuKGJbMF0uZGltcyksLi4uJG4odSldOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6d31dfX0sZ2V0U2hhZGVyU291cmNlOnh9fSx6bz0oZSx0KT0+e0Z1KGUuaW5wdXRzKSxlLmNvbXB1dGUoZ3QoZS5pbnB1dHNbMF0sdC5wZXJtKSl9LFZvPWU9PmllKHtwZXJtOmUucGVybX0pfSk7dmFyIEt1LHF1LFl1LFh1LEp1LFp1LFF1LGVsLHRsLHJsLGV0LEdvLE5vLFVvLExvLEZvLEhvLGpvLEtvLHFvLFlvLFhvPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7TXIoKTtycigpO0t1PXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGV4cChjYW5kaWRhdGUpXCIsbDE6XCJiZXN0VmFsdWUgKyBhYnMoY2FuZGlkYXRlKVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LHF1PXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwxOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0sWXU9e21heDpcIl9BW29mZnNldF1cIixtaW46XCJfQVtvZmZzZXRdXCIsbWVhbjpcIjBcIixzdW06XCIwXCIscHJvZDpcIjFcIixzdW1TcXVhcmU6XCIwXCIsbG9nU3VtRXhwOlwiMFwiLGwxOlwiMFwiLGwyOlwiMFwiLGxvZ1N1bTpcIjBcIn0sWHU9e21heDpcImJlc3RWYWx1ZVwiLG1pbjpcImJlc3RWYWx1ZVwiLHN1bTpcImJlc3RWYWx1ZVwiLHByb2Q6XCJiZXN0VmFsdWVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWVcIixsb2dTdW1FeHA6XCJsb2coYmVzdFZhbHVlKVwiLGwxOlwiYmVzdFZhbHVlXCIsbDI6XCJzcXJ0KGJlc3RWYWx1ZSlcIixsb2dTdW06XCJsb2coYmVzdFZhbHVlKVwifSxKdT0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgbz10LWU7bzx0OysrbylyLnB1c2gobyk7cmV0dXJuIHJ9LFp1PShlLHQpPT57bGV0IHI9W10sbz1lLmxlbmd0aDtmb3IobGV0IHM9MDtzPG87cysrKXQuaW5kZXhPZihzKT09PS0xJiZyLnB1c2goZVtzXSk7bGV0IG49dC5tYXAocz0+ZVtzXSk7cmV0dXJuW3Isbl19LFF1PShlLHQpPT57bGV0IHI9ZS5sZW5ndGgrdC5sZW5ndGgsbz1bXSxuPTA7Zm9yKGxldCBzPTA7czxyO3MrKyl0LmluZGV4T2Yocyk9PT0tMT9vLnB1c2goZVtuKytdKTpvLnB1c2goMSk7cmV0dXJuIG99LGVsPShlLHQpPT57Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpaWYoZVtlLmxlbmd0aC1yLTFdIT09dC0xLXIpcmV0dXJuITE7cmV0dXJuITB9LHRsPShlLHQpPT57bGV0IHI9W107aWYoIWVsKGUsdCkpe2ZvcihsZXQgbz0wO288dDsrK28pZS5pbmRleE9mKG8pPT09LTEmJnIucHVzaChvKTtlLmZvckVhY2gobz0+ci5wdXNoKG8pKX1yZXR1cm4gcn0scmw9KGUsdCxyLG8sbixzLHUpPT57bGV0IGQ9clswXS5kaW1zLGE9ay5zaXplKHMpLG09ay5zaXplKHUpLGc9TChcIl9BXCIsclswXS5kYXRhVHlwZSxkKSx4PVgoXCJvdXRwdXRcIixuLHMpLGI9MzIsdz1gXFxuICAgICAgICAgIHZhcjx3b3JrZ3JvdXA+IGFCZXN0VmFsdWVzIDogYXJyYXk8JHt4LnR5cGUuc3RvcmFnZX0sICR7Yn0+O1xcbiAgICAgICBgO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6dCxnZXRTaGFkZXJTb3VyY2U6eT0+YFxcbiAgICAgICAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGcseCl9XFxuICAgICAgICAke3d9XFxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcXG4gICAgICAgICB9XFxuICAgICAgICAgJHt5Lm1haW5TdGFydChiKX1cXG4gICAgICAgICAgbGV0IGxvY2FsX2lkeCA9IGxvY2FsX2lkLng7XFxuXFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke2J9O1xcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xcblxcbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gJHt4LnR5cGUuc3RvcmFnZX0oJHtZdVtvXX0pO1xcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcXG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke2J9KSB7XFxuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gJHt4LnR5cGUuc3RvcmFnZX0oJHtnLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtLdVtvXX07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHtifXUpO1xcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XFxuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XFxuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XFxuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcXG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7cXVbb119O1xcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XFxuICAgICAgICAgICB9XFxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XFxuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgICAgICAgfVxcblxcbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcXG4gICAgICAgICAgJHt4LnNldEJ5T2Zmc2V0KFwib3V0cHV0SW5kZXhcIixgJHtvPT09XCJtZWFuXCI/YGJlc3RWYWx1ZSAvICR7eC50eXBlLnN0b3JhZ2V9KHVuaWZvcm1zLnJlZHVjZVNpemUpYDpgJHtYdVtvXX1gfWApfTtcXG4gICAgICAgICB9XFxuICAgICAgICB9YCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6YX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6bX1dfSl9fSxldD0oZSx0LHIsbyk9PntsZXQgbj1lLmlucHV0cy5sZW5ndGg9PT0xP3I6U24oZS5pbnB1dHMscikscz1uLmF4ZXM7cy5sZW5ndGg9PT0wJiYhbi5ub29wV2l0aEVtcHR5QXhlcyYmKHM9ZS5pbnB1dHNbMF0uZGltcy5tYXAoKHcsdik9PnYpKTtsZXQgdT1rLm5vcm1hbGl6ZUF4ZXMocyxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCksZD11LGE9ZS5pbnB1dHNbMF0sbT10bChkLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTttLmxlbmd0aD4wJiYoYT1lLmNvbXB1dGUoZ3QoZS5pbnB1dHNbMF0sbSkse2lucHV0czpbMF0sb3V0cHV0czpbLTFdfSlbMF0sZD1KdShkLmxlbmd0aCxhLmRpbXMubGVuZ3RoKSk7bGV0W2cseF09WnUoYS5kaW1zLGQpLGI9ZztuLmtlZXBEaW1zJiYoYj1RdShnLHUpKSxlLmNvbXB1dGUocmwodCx7aGludDpuLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LFthXSxvLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGIseCkse2lucHV0czpbYV19KX0sR289KGUsdCk9PntldChlLFwiUmVkdWNlTWVhblNoYXJlZFwiLHQsXCJtZWFuXCIpfSxObz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VMMVNoYXJlZFwiLHQsXCJsMVwiKX0sVW89KGUsdCk9PntldChlLFwiUmVkdWNlTDJTaGFyZWRcIix0LFwibDJcIil9LExvPShlLHQpPT57ZXQoZSxcIlJlZHVjZUxvZ1N1bUV4cFNoYXJlZFwiLHQsXCJsb2dTdW1FeHBcIil9LEZvPShlLHQpPT57ZXQoZSxcIlJlZHVjZU1heFNoYXJlZFwiLHQsXCJtYXhcIil9LEhvPShlLHQpPT57ZXQoZSxcIlJlZHVjZU1pblNoYXJlZFwiLHQsXCJtaW5cIil9LGpvPShlLHQpPT57ZXQoZSxcIlJlZHVjZVByb2RTaGFyZWRcIix0LFwicHJvZFwiKX0sS289KGUsdCk9PntldChlLFwiUmVkdWNlU3VtU2hhcmVkXCIsdCxcInN1bVwiKX0scW89KGUsdCk9PntldChlLFwiUmVkdWNlU3VtU3F1YXJlU2hhcmVkXCIsdCxcInN1bVNxdWFyZVwiKX0sWW89KGUsdCk9PntldChlLFwiUmVkdWNlTG9nU3VtU2hhcmVkXCIsdCxcImxvZ1N1bVwiKX19KTt2YXIgdHQsbmwsQnIsU24scnQsb2wsYWwsaWwsc2wsdWwsbGwsZGwsY2wscGwsZmwsbnQsSm8sWm8sUW8sZWEsdGEscmEsbmEsb2EsYWEsaWEsWWUsTXI9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO1hvKCk7dHQ9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MiYmZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGVzIGlucHV0IGRpbXMuXCIpfSxubD1lPT5bXCJcIixcIlwiLGB2YXIgdmFsdWUgPSAke2UuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcIlwiXSxCcj0oZSx0LHIsbyxuLHMsdT0hMSxkPSExKT0+e2xldCBhPVtdLG09clswXS5kaW1zLGc9ay5ub3JtYWxpemVBeGVzKG4sclswXS5kaW1zLmxlbmd0aCkseD0hZCYmZy5sZW5ndGg9PT0wO20uZm9yRWFjaCgoeixGKT0+e3h8fGcuaW5kZXhPZihGKT49MD91JiZhLnB1c2goMSk6YS5wdXNoKHopfSk7bGV0IGI9W10sdz1MKFwiX0FcIixyWzBdLmRhdGFUeXBlLG0pLHY9WChcIm91dHB1dFwiLHMsYSkseT1vKHcsdixnKSxTPWBpbnB1dE9mZnNldCA9ICR7dy5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNcIil9O2AsQT1gbGV0ICR7U307YCxSPWB2YXIgJHtTfTtgLFc9eVsxXT09PVwiXCI/XCJcIjpSLE09KHlbMV09PT1cIlwiP0E6UykrYFxcbmAreVsyXTtmb3IobGV0IHo9MCxGPTA7ejxyWzBdLmRpbXMubGVuZ3RoO3orKyl4fHxnLmluZGV4T2Yoeik+PTA/KHUmJkYrKyxNPWBmb3IodmFyIGoke3p9OiB1MzIgPSAwOyBqJHt6fSA8ICR7clswXS5kaW1zW3pdfTsgaiR7en0rKykge1xcbiAgICAgICAgICAgICAgICAke3lbMl0uaW5jbHVkZXMoXCJsYXN0SW5kZXhcIik/YGxldCBsYXN0SW5kZXggPSBqJHt6fTtgOlwiXCJ9XFxuICAgICAgICAgICAgICAgICR7dy5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIseixgaiR7en1gKX1cXG4gICAgICAgICAgICAgICAgJHtNfVxcbiAgICAgICAgICAgICAgfWApOihiLnB1c2goYCR7dy5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIseix2LmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsRikpfTtgKSxGKyspO2xldCBEPWsuc2l6ZShhKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOno9PmBcXG4gICAgICAgICR7ei5kZWNsYXJlVmFyaWFibGVzKHcsdil9XFxuXFxuICAgICAgICAke3oubWFpblN0YXJ0KCl9XFxuICAgICAgICAgICR7ei5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKEQpfVxcbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3cudHlwZS5pbmRpY2VzfTtcXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgICAgICR7Yi5qb2luKGBcXG5gKX1cXG4gICAgICAgICAgJHt5WzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cXG4gICAgICAgICAgJHtXfVxcbiAgICAgICAgICAke3lbMV19XFxuICAgICAgICAgICR7TX1cXG4gICAgICAgICAgJHt5WzNdfVxcbiAgICAgICAgICAke3kubGVuZ3RoPT09ND92LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6eS5zbGljZSg0KS5qb2luKGBcXG5gKX1cXG4gICAgICAgIH1gLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpzfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoRC82NCl9fSl9fSxTbj0oZSx0KT0+e2xldCByPVtdO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChvPT5yLnB1c2goTnVtYmVyKG8pKSksaWUoe2F4ZXM6cixrZWVwRGltczp0LmtlZXBEaW1zLG5vb3BXaXRoRW1wdHlBeGVzOnQubm9vcFdpdGhFbXB0eUF4ZXN9KX0scnQ9KGUsdCxyLG8pPT57bGV0IG49ZS5pbnB1dHMscz1uLmxlbmd0aD09PTE/cjpTbihuLHIpO2UuY29tcHV0ZShCcih0LHtoaW50OnMuY2FjaGVLZXl9LFtuWzBdXSxzLm5vb3BXaXRoRW1wdHlBeGVzJiZzLmF4ZXMubGVuZ3RoPT09MD9ubDpvLHMuYXhlcyxuWzBdLmRhdGFUeXBlLHMua2VlcERpbXMscy5ub29wV2l0aEVtcHR5QXhlcykse2lucHV0czpbMF19KX0sb2w9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZUxvZ1N1bVwiLHQsKG8sbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxhbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlTDFcIix0LChvLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gYWJzKCR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcIlwiXSl9LGlsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VMMlwiLHQsKG8sbik9PltgdmFyIHQgPSAke24udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7bi50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07IHZhbHVlICs9ICh0ICogdCk7YCxcInZhbHVlID0gc3FydCh2YWx1ZSk7XCJdKX0sc2w9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZUxvZ1N1bUV4cFwiLHQsKG8sbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBleHAoJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LHVsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VNYXhcIix0LChvLG4scyk9PntsZXQgdT1bXTtmb3IobGV0IGQ9MDtkPG8ucmFuaztkKyspKHMuaW5kZXhPZihkKT49MHx8cy5sZW5ndGg9PT0wKSYmdS5wdXNoKG8uaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLGQsMCkpO3JldHVybltgJHt1LmpvaW4oYFxcbmApfWAsYHZhciB2YWx1ZSA9ICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwiXCJdfSl9LGxsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VNZWFuXCIsdCwobyxuLHMpPT57bGV0IHU9MTtmb3IobGV0IGQ9MDtkPG8ucmFuaztkKyspKHMuaW5kZXhPZihkKT49MHx8cy5sZW5ndGg9PT0wKSYmKHUqPWUuaW5wdXRzWzBdLmRpbXNbZF0pO3JldHVybltcInZhciBzdW0gPSBmMzIoMCk7XCIsXCJcIixgc3VtICs9IGYzMigke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsYGxldCB2YWx1ZSA9ICR7bi50eXBlLnZhbHVlfShzdW0gLyAke3V9KTtgXX0pfSxkbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlTWluXCIsdCwobyxuLHMpPT57bGV0IHU9W107Zm9yKGxldCBkPTA7ZDxvLnJhbms7ZCsrKShzLmluZGV4T2YoZCk+PTB8fHMubGVuZ3RoPT09MCkmJnUucHVzaChgaW5wdXRJbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7dS5qb2luKGBcXG5gKX1gLGB2YXIgdmFsdWUgPSAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxgdmFsdWUgPSBtaW4odmFsdWUsICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcIlwiXX0pfSxjbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlUHJvZFwiLHQsKG8sbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMSk7YCxcIlwiLGB2YWx1ZSAqPSAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcIlwiXSl9LHBsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VTdW1cIix0LChvLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJcIl0pfSxmbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlU3VtU3F1YXJlXCIsdCwobyxuKT0+W2B2YXIgdCA9ICR7bi50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtuLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcIlwiXSl9LG50PShlLHQscik9PntpZih0Lmxlbmd0aD09PTApcmV0dXJuISFyO2xldCBvPTEsbj0xO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKXQuaW5kZXhPZihzKT09PS0xP28qPWVbc106bio9ZVtzXTtyZXR1cm4gbjwzMiYmbz4xMDI0fSxKbz0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2xsKGUsdCk6R28oZSx0KX0sWm89KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9hbChlLHQpOk5vKGUsdCl9LFFvPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/aWwoZSx0KTpVbyhlLHQpfSxlYT0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3NsKGUsdCk6TG8oZSx0KX0sdGE9KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT91bChlLHQpOkZvKGUsdCl9LHJhPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/ZGwoZSx0KTpIbyhlLHQpfSxuYT0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2NsKGUsdCk6am8oZSx0KX0sb2E9KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9wbChlLHQpOktvKGUsdCl9LGFhPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/ZmwoZSx0KTpxbyhlLHQpfSxpYT0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP29sKGUsdCk6WW8oZSx0KX0sWWU9ZT0+aWUoZSl9KTt2YXIgc2EsdWEsbGEsZGEsQ24sY2E9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7UGUoKTtNcigpO3NhPWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkFyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LHVhPShlLHQpPT5pZSh7YXhpczp0LmF4aXMsa2VlcERpbXM6dC5rZWVwRGltcyxzZWxlY3RMYXN0SW5kZXg6dC5zZWxlY3RMYXN0SW5kZXh9KSxsYT0oZSx0KT0+e3NhKGUuaW5wdXRzKTtsZXQgcj0obixzLHUpPT57bGV0IGQ9W107Zm9yKGxldCBhPTA7YTxuLnJhbms7YSsrKSh1LmluZGV4T2YoYSk+PTB8fHUubGVuZ3RoPT09MCkmJmQucHVzaChgaW5wdXRJbmRpY2VzWyR7YX1dID0gMDtgKTtyZXR1cm5bYCR7ZC5qb2luKGBcXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XFxudmFyIGJlc3RJbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI8PVwiOlwiPFwifSB2YWx1ZSkge1xcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xcbiAgICAgICAgIGJlc3RJbmRleCA9IGkzMihsYXN0SW5kZXgpO1xcbiAgICAgICB9YCxcIlwiLHMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0SW5kZXhcIildfSxvPWUuaW5wdXRzLmxlbmd0aD09PTE/dDp1YShlLmlucHV0cyx0KTtlLmNvbXB1dGUoQnIoXCJBcmdNaW5cIix7aGludDpvLmNhY2hlS2V5fSxbZS5pbnB1dHNbMF1dLHIsW28uYXhpc10sNyxvLmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxkYT0oZSx0KT0+e3NhKGUuaW5wdXRzKTtsZXQgcj0obixzLHUpPT57bGV0IGQ9W107Zm9yKGxldCBhPTA7YTxuLnJhbms7YSsrKSh1LmluZGV4T2YoYSk+PTB8fHUubGVuZ3RoPT09MCkmJmQucHVzaChgaW5wdXRJbmRpY2VzWyR7YX1dID0gMDtgKTtyZXR1cm5bYCR7ZC5qb2luKGBcXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XFxudmFyIGJlc3RJbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI+PVwiOlwiPlwifSB2YWx1ZSkge1xcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xcbiAgICAgICAgIGJlc3RJbmRleCA9IGkzMihsYXN0SW5kZXgpO1xcbiAgICAgICB9YCxcIlwiLHMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0SW5kZXhcIildfSxvPWUuaW5wdXRzLmxlbmd0aD09PTE/dDp1YShlLmlucHV0cyx0KTtlLmNvbXB1dGUoQnIoXCJhcmdNYXhcIix7aGludDpvLmNhY2hlS2V5fSxbZS5pbnB1dHNbMF1dLHIsW28uYXhpc10sNyxvLmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxDbj1lPT5pZShlKX0pO3ZhciBtbCxobCxwYSxmYT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO21sPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVszMjAsNjQwLDEyODBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIG9mIGNoYW5uZWxzIHNob3VsZCBiZSAzMjAsIDY0MCBvciAxMjgwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LGhsPWU9PntsZXQgdD1lWzBdLmRpbXMscj1lWzBdLmRpbXNbMl0sbz1rLnNpemUodCkvNCxuPWVbMF0uZGF0YVR5cGUscz1MKFwiaW5wdXRcIixuLHQsNCksdT1MKFwiYmlhc1wiLG4sW3JdLDQpLGQ9TChcInJlc2lkdWFsXCIsbix0LDQpLGE9WChcIm91dHB1dFwiLG4sdCw0KTtyZXR1cm57bmFtZTpcIkJpYXNBZGRcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfX0pLGdldFNoYWRlclNvdXJjZTpnPT5gXFxuICBjb25zdCBjaGFubmVscyA9ICR7cn11IC8gNDtcXG4gICR7Zy5kZWNsYXJlVmFyaWFibGVzKHMsdSxkLGEpfVxcblxcbiAgJHtnLm1haW5TdGFydCgpfVxcbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvKX1cXG4gICAgbGV0IHZhbHVlID0gJHtzLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX1cXG4gICAgICArICR7dS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSBjaGFubmVsc1wiKX0gKyAke2QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgJHthLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XFxuICB9YH19LHBhPWU9PnttbChlLmlucHV0cyksZS5jb21wdXRlKGhsKGUuaW5wdXRzKSl9fSk7dmFyIGdsLCRlLG1hLGhhLGdhLHlhLGJhLHdhLHZhLCRhLHhhLEFuLHlsLFNhLENhLEFhLElhLGtyLEVhLERyLFRhLE9hLF9hLFJhLFBhLE1hLEJhLGthLERhLFdhLHphLFZhLEdhLE5hLFVhLExhLEZhLEluPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7UGUoKTt2ZSgpO2dsPShlLHQscixvLG4scyk9PntsZXQgdT1NYXRoLmNlaWwodC80KSxkPVwiXCI7dHlwZW9mIG49PVwic3RyaW5nXCI/ZD1gJHtufShhKWA6ZD1uKFwiYVwiKTtsZXQgYT1MKFwiaW5wdXREYXRhXCIscixbdV0sNCksbT1YKFwib3V0cHV0RGF0YVwiLG8sW3VdLDQpO3JldHVybmBcXG4gICR7ZS5kZWNsYXJlVmFyaWFibGVzKGEsbSl9XFxuXFxuICAke3M/P1wiXCJ9XFxuXFxuICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxcblxcbiAgICBsZXQgYSA9ICR7YS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xcbiAgICAke20uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZCl9XFxuICB9YH0sJGU9KGUsdCxyLG8sbixzPWUuZGF0YVR5cGUpPT4oe25hbWU6dCxzaGFkZXJDYWNoZTp7aGludDpufSxnZXRTaGFkZXJTb3VyY2U6dT0+Z2wodSxrLnNpemUoZS5kaW1zKSxlLmRhdGFUeXBlLHMscixvKSxnZXRSdW5EYXRhOnU9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUodVswXS5kaW1zKS82NC80KX19KX0pLG1hPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LGhhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sZ2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LHlhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sYmE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFzaW5oXCIsXCJhc2luaFwiKSl9LHdhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sdmE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LCRhPWU9PmllKGUpLHhhPShlLHQpPT57bGV0IHI7c3dpdGNoKHQudG8pe2Nhc2UgMTA6cj1cInZlYzQ8ZjE2PlwiO2JyZWFrO2Nhc2UgMTpyPVwidmVjNDxmMzI+XCI7YnJlYWs7Y2FzZSAxMjpyPVwidmVjNDx1MzI+XCI7YnJlYWs7Y2FzZSA2OnI9XCJ2ZWM0PGkzMj5cIjticmVhaztjYXNlIDk6cj1cInZlYzQ8Ym9vbD5cIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgXFwndG9cXCcgZnJvbSBcXCdDYXN0XFwnIG9wZXJhdG9yKTogJHt0LnRvfWApfWUuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNhc3RcIixyLHZvaWQgMCx0LmNhY2hlS2V5LHQudG8pKX0sQW49KGUsdCk9PntsZXQgcj1NZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ2xpcFwiLG89PmBjbGFtcCgke299LCBjbGlwX21pbl8sIGNsaXBfbWF4XylgLGBcXG4gICAgY29uc3QgY2xpcF9taW5fOiB2ZWM0PCR7cn0+ID0gdmVjNCgke3J9KCR7dC5taW59KSk7XFxuICAgIGNvbnN0IGNsaXBfbWF4XzogdmVjNDwke3J9PiA9IHZlYzQoJHtyfSgke3QubWF4fSkpO1xcbmAsdC5jYWNoZUtleSkse2lucHV0czpbMF19KX0seWw9ZT0+e2xldCB0PWUubGVuZ3RoPj0yP2VbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF06UnIscj1lLmxlbmd0aD49Mz9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOlByO3JldHVybiBpZSh7bWluOnQsbWF4OnJ9KX0sU2E9ZT0+e2xldCB0PXlsKGUuaW5wdXRzKTtBbihlLHQpfSxDYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LEFhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LElhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sa3I9ZT0+aWUoZSksRWE9KGUsdCk9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJFbHVcIixyPT5gZWx1X3ZmMzIoJHtyfSlgLGBcXG4gIGNvbnN0IGVsdV9hbHBoYV86IGYzMiA9IGYzMigke3QuYWxwaGF9KTtcXG5cXG4gIGZuIGVsdV9mMzIoYTogZjMyKSAtPiBmMzIge1xcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcXG4gIH1cXG5cXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+IHtcXG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XFxuICB9YCx0LmNhY2hlS2V5KSl9LERyPShlLHQ9XCJmMzJcIik9PmBcXG5jb25zdCByMDogJHt0fSA9IDAuMzI3NTkxMTtcXG5jb25zdCByMTogJHt0fSA9IDAuMjU0ODI5NTkyO1xcbmNvbnN0IHIyOiAke3R9ID0gLTAuMjg0NDk2NzM2O1xcbmNvbnN0IHIzOiAke3R9ID0gMS40MjE0MTM3NDE7XFxuY29uc3QgcjQ6ICR7dH0gPSAtMS40NTMxNTIwMjc7XFxuY29uc3QgcjU6ICR7dH0gPSAxLjA2MTQwNTQyOTtcXG5cXG5mbiBlcmZfdmYzMih2OiAke2V9KSAtPiAke2V9IHtcXG4gIGxldCBhYnN2ID0gYWJzKHYpO1xcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcXG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xcbn1gLFRhPWU9PntsZXQgdD1NZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRXJmXCIscj0+YGVyZl92ZjMyKCR7cn0pYCxEcihgdmVjNDwke3R9PmAsdCkpKX0sT2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkV4cFwiLFwiZXhwXCIpKX0sX2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkZsb29yXCIsXCJmbG9vclwiKSl9LFJhPWU9PntsZXQgdD1NZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiR2VsdVwiLHI9PmAwLjUgKiAke3J9ICogKDEuMCArIGVyZl92ZjMyKCR7cn0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsRHIoYHZlYzQ8JHt0fT5gLHQpKSl9LFBhPShlLHQpPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTGVha3lSZWx1XCIscj0+YHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7cn0sICR7cn0sICR7cn0gPj0gdmVjNDxmMzI+KDAuMCkpYCxgY29uc3QgbGVha3lfcmVsdV9hbHBoYV86IGYzMiA9IGYzMigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKX0sTWE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIk5vdFwiLHQ9PmAhJHt0fWApKX0sQmE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIk5lZ1wiLHQ9PmAtJHt0fWApKX0sa2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlJlY2lwcm9jYWxcIix0PT5gMS4wLyR7dH1gKSl9LERhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJSZWx1XCIsdD0+YHNlbGVjdCh2ZWM0PGYzMj4oMC4wKSwgJHt0fSwgJHt0fSA+IHZlYzQ8ZjMyPigwLjApKWApKX0sV2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNpZ21vaWRcIix0PT5gKDEuMCAvICgxLjAgKyBleHAoLSR7dH0pKSlgKSl9LHphPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTaW5cIixcInNpblwiKSl9LFZhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTaW5oXCIsXCJzaW5oXCIpKX0sR2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNxcnRcIixcInNxcnRcIikpfSxOYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiVGFuXCIsXCJ0YW5cIikpfSxVYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiVGFuaFwiLFwidGFuaFwiKSl9LExhPShlLHQpPT4oZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIscj0+YHNlbGVjdCh2ZWM0PGYzMj4oMC4wKSwgJHtyfSwgJHtyfSA+IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfKWAsYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfOiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMCksRmE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX19KTt2YXIgd2wsdmwsSGEsamE9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtJbigpO3dsPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVsyNTYwLDUxMjAsMTAyNDBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwiaGlkZGVuIHN0YXRlIHNob3VsZCBiZSAyNTYwLCA1MTIwIG9yIDEwMjQwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LHZsPWU9PntsZXQgdD1lWzBdLmRpbXMuc2xpY2UoKTt0WzJdPXRbMl0vMjtsZXQgcj1MKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyw0KSxvPUwoXCJiaWFzXCIsZVswXS5kYXRhVHlwZSxbZVswXS5kaW1zWzJdXSw0KSxuPVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHQsNCkscz1rLnNpemUodCkvNDtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpkPT5gXFxuICBjb25zdCBNX1NRUlQyID0gc3FydCgyLjApO1xcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtlWzBdLmRpbXNbMl0vNC8yfXU7XFxuXFxuICAke2QuZGVjbGFyZVZhcmlhYmxlcyhyLG8sbil9XFxuXFxuICAke0RyKFwidmVjNGZcIil9XFxuXFxuICAke2QubWFpblN0YXJ0KCl9XFxuICAgICR7ZC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHMpfVxcbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XFxuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcXG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcXG5cXG4gICAgJHtuLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVMZWZ0ICogZ2VsdVJpZ2h0XCIpfVxcbiAgfWB9fSxIYT1lPT57d2woZS5pbnB1dHMpLGUuY29tcHV0ZSh2bChlLmlucHV0cykpfX0pO3ZhciAkbCx4bCxvdCxLYSxxYSxZYSxYYSxKYSxaYSxRYSxlaSx0aSxyaSxuaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO3ZlKCk7JGw9KGUsdCxyLG8sbixzLHUsZCxhLG0sZyk9PntsZXQgeD1rLnNpemUobyksYj1NYXRoLmNlaWwoeC80KSx3LHY7dHlwZW9mIHU9PVwic3RyaW5nXCI/dz12PShNLEQpPT5gJHt1fSgoJHtNfSksKCR7RH0pKWA6dHlwZW9mIHU9PVwiZnVuY3Rpb25cIj93PXY9dToodz11LnNjYWxhcix2PXUudmVjdG9yKTtsZXQgeT1cIlwiLFM9WChcIm91dHB1dERhdGFcIixtLG8sNCksQT1MKFwiYURhdGFcIixkLHQsNCksUj1MKFwiYkRhdGFcIixhLHIsNCk7aWYocyl7bGV0IE09RD0+e2xldCBfPWsuY29tcHV0ZVN0cmlkZXMoRCksej1bXTtmb3IobGV0IEY9RC5sZW5ndGgtMTtGPj0wO0YtLSl7bGV0IHE9Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEYrby5sZW5ndGgtRC5sZW5ndGgpO3oucHVzaChgJHtfW0ZdfXUgKiAoJHtxfSAlICR7RFtGXX11KWApfXJldHVybiB6Lmxlbmd0aD4wP3ouam9pbihcIitcIik6XCIwdVwifTt5PWBcXG4gICAgICAgICAgZm4gY2FsY09mZnNldEEob3V0cHV0SW5kaWNlczogJHtTLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XFxuICAgICAgICAgICAgcmV0dXJuICR7TSh0KX07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm4gY2FsY09mZnNldEIob3V0cHV0SW5kaWNlczogJHtTLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XFxuICAgICAgICAgICAgcmV0dXJuICR7TShyKX07XFxuICAgICAgICAgIH1cXG4gICAgICAgIGB9bGV0IFc7aWYobilpZihzKXtsZXQgTT1rLnNpemUodCk9PT0xLEQ9ay5zaXplKHIpPT09MTtNfHxEP1c9Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix2KE0/YCR7QS50eXBlLnZhbHVlfSgke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6QS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksRD9gJHtSLnR5cGUudmFsdWV9KCR7Ui5nZXRCeU9mZnNldChcIjBcIil9LngpYDpSLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpOlc9YFxcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldEEgPSBjYWxjT2Zmc2V0QShvdXRwdXRJbmRpY2VzKTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9IGNhbGNPZmZzZXRCKG91dHB1dEluZGljZXMpO1xcbiAgICAgICAgICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix2KEEuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIiksUi5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKSkpfVxcbiAgICAgICAgICBgfWVsc2UgVz1TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHYoQS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksUi5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2lmKCFzKXRocm93IG5ldyBFcnJvcihcIm5vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLlwiKTtsZXQgTT0oRCxfLHo9XCJcIik9PntsZXQgRj1gYURhdGFbaW5kZXhBJHtffV1bY29tcG9uZW50QSR7X31dYCxxPWBiRGF0YVtpbmRleEIke199XVtjb21wb25lbnRCJHtffV1gO3JldHVybmBcXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7X30gPSAke1Mub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke199dWApfTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7X30gPSBjYWxjT2Zmc2V0QShvdXRwdXRJbmRpY2VzJHtffSk7XFxuICAgICAgICAgICAgbGV0IG9mZnNldEIke199ID0gY2FsY09mZnNldEIob3V0cHV0SW5kaWNlcyR7X30pO1xcbiAgICAgICAgICAgIGxldCBpbmRleEEke199ID0gb2Zmc2V0QSR7X30gLyA0dTtcXG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtffSA9IG9mZnNldEIke199IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke199ID0gb2Zmc2V0QSR7X30gJSA0dTtcXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7X30gPSBvZmZzZXRCJHtffSAlIDR1O1xcbiAgICAgICAgICAgICR7RH1bJHtffV0gPSAke3p9KCR7dyhGLHEpfSk7XFxuICAgICAgICAgIGB9O209PT05P1c9YFxcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xcbiAgICAgICAgICAgICR7TShcImRhdGFcIiwwLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7TShcImRhdGFcIiwxLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7TShcImRhdGFcIiwyLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7TShcImRhdGFcIiwzLFwidTMyXCIpfVxcbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpXPWBcXG4gICAgICAgICAgICAke00oXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMCl9XFxuICAgICAgICAgICAgJHtNKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxcbiAgICAgICAgICAgICR7TShcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cXG4gICAgICAgICAgICAke00oXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMyl9XFxuICAgICAgICAgIGB9cmV0dXJuYFxcbiAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXMoQSxSLFMpfVxcblxcbiAgICAgICAgJHtnPz9cIlwifVxcbiAgICAgICAgJHt5fVxcblxcbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYil9XFxuICAgICAgICAke1d9XFxuICAgICAgfWB9LHhsPShlLHQscixvLG4scyx1PXIuZGF0YVR5cGUpPT57bGV0IGQ9IWsuYXJlRXF1YWwoci5kaW1zLG8uZGltcyksYT1yLmRpbXMsbT1rLnNpemUoci5kaW1zKSxnPSExO2lmKGQpe2xldCB4PVFlLmNhbGNTaGFwZShyLmRpbXMsby5kaW1zLCExKTtpZigheCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2E9eCxtPWsuc2l6ZShhKTtsZXQgYj1rLnNpemUoci5kaW1zKT09PTEsdz1rLnNpemUoby5kaW1zKT09PTEsdj0xO2ZvcihsZXQgeT0xO3k8YS5sZW5ndGg7eSsrKXtsZXQgUz1yLmRpbXNbci5kaW1zLmxlbmd0aC15XT8/MSxBPW8uZGltc1tvLmRpbXMubGVuZ3RoLXldPz8xO2lmKFM9PT1BKXYqPVM7ZWxzZSBicmVha30odiU0PT09MHx8Ynx8dykmJihnPSEwKX1lbHNlIGc9ITA7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0fSxnZXRTaGFkZXJTb3VyY2U6eD0+JGwoeCxyLmRpbXMsby5kaW1zLGEsZyxkLG4sci5kYXRhVHlwZSxvLmRhdGFUeXBlLHUscyksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0LzQpfX0pfX0sb3Q9KGUsdCxyLG8sbixzKT0+e2UuY29tcHV0ZSh4bCh0LG4/P1wiXCIsZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0scixvLHMpKX0sS2E9ZT0+e290KGUsXCJBZGRcIiwodCxyKT0+YCR7dH0rJHtyfWApfSxxYT1lPT57b3QoZSxcIkRpdlwiLCh0LHIpPT5gJHt0fS8ke3J9YCl9LFlhPWU9PntvdChlLFwiRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH09PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT09JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxYYT1lPT57b3QoZSxcIk11bFwiLCh0LHIpPT5gJHt0fSoke3J9YCl9LEphPWU9PntsZXQgdD1MKFwiaW5wdXRcIixlLmlucHV0c1swXS5kYXRhVHlwZSxlLmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO290KGUsXCJQb3dcIix7c2NhbGFyOihvLG4pPT5gcG93X2N1c3RvbSgke299LCR7bn0pYCx2ZWN0b3I6KG8sbik9PmBwb3dfdmVjdG9yX2N1c3RvbSgke299LCR7bn0pYH0sYFxcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XFxuICAgICAgaWYgKGIgPT0gJHt0fSgwLjApKSB7XFxuICAgICAgICByZXR1cm4gJHt0fSgxLjApO1xcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xcbiAgICAgICAgcmV0dXJuICR7dH0ocG93KGYzMihhKSwgZjMyKGIpKSk7IC8vIE5hTlxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xcbiAgICB9XFxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dH0+LCBiIDogdmVjNDwke3R9PikgLT4gdmVjNDwke3R9PiB7XFxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XFxuICAgICAgcmV0dXJuIHZlYzQ8JHt0fT4ocG93X2N1c3RvbShhLngsIGIueCksIHBvd19jdXN0b20oYS55LCBiLnkpLCBwb3dfY3VzdG9tKGEueiwgYi56KSwgcG93X2N1c3RvbShhLncsIGIudykpO1xcbiAgICB9XFxuICAgICAgYCl9LFphPWU9PntvdChlLFwiU3ViXCIsKHQscik9PmAke3R9LSR7cn1gKX0sUWE9ZT0+e290KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PiR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT4ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGVpPWU9PntvdChlLFwiTGVzc1wiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTwke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSx0aT1lPT57b3QoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9Pj0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0scmk9ZT0+e290KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTw9JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PD0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIENsLEFsLElsLEVsLG9pLGFpLGlpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtDbD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IHQ9ZVswXS5kYXRhVHlwZSxyPWVbMF0uZGltcy5sZW5ndGg7Zm9yKGxldCBvIG9mIGUpe2lmKG8uZGF0YVR5cGUhPT10KXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlXCIpO2lmKG8uZGltcy5sZW5ndGghPT1yKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9fSxBbD1lPT5gXFxuICBmbiBjYWxjdWxhdGVJbnB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XFxuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XFxuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xcbiAgICAgICAgcmV0dXJuIGk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiAke2V9dTtcXG4gIH1gLElsPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgsbz1bXTtmb3IobGV0IG49MDtuPHI7KytuKXtsZXQgcz10LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGVbbl0uZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKSk7cj09PTE/by5wdXNoKHMpOm49PT0wP28ucHVzaChgaWYgKGlucHV0SW5kZXggPT0gJHtufXUpIHsgJHtzfSB9YCk6bj09PXItMT9vLnB1c2goYGVsc2UgeyAke3N9IH1gKTpvLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtufSkgeyAke3N9IH1gKX1yZXR1cm4gby5qb2luKGBcXG5gKX0sRWw9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKTtpZih0Pj1yLmxlbmd0aHx8dDwtMSpyLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtsZXQgbz10PDA/ci5sZW5ndGgrdDp0LG49ci5zbGljZSgwKTtmb3IobGV0IHc9MTt3PGUubGVuZ3RoO3crKyl7bGV0IHY9ZVt3XS5kaW1zLnNsaWNlKCk7Zm9yKGxldCB5PTA7eTxyLmxlbmd0aDt5KyspaWYoeT09PW8pbltvXSs9dlt5XTtlbHNlIGlmKHJbeV0hPT12W3ldKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWxldCBzPWsuc2l6ZShuKSx1PW5ldyBBcnJheShlLmxlbmd0aCksZD1uZXcgQXJyYXkoZS5sZW5ndGgpLGE9ZVswXS5kYXRhVHlwZSxtPTA7Zm9yKGxldCB3PTA7dzxlLmxlbmd0aDsrK3cpbSs9ZVt3XS5kaW1zW29dLHVbd109bSxkW3ddPUwoYGlucHV0JHt3fWAsYSxlW3ddLmRpbXMpO2xldCBnPVgoXCJvdXRwdXRcIixhLG4pLHg9Zy5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pLGI9dz0+YFxcbiAgJHt3LmRlY2xhcmVWYXJpYWJsZXMoLi4uZCxnKX1cXG5cXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7dS5sZW5ndGh9Pigke3UubWFwKHY9PmAke3Z9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAke0FsKHUubGVuZ3RoKX1cXG5cXG4gICR7dy5tYWluU3RhcnQoKX1cXG4gICAgJHt3Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocyl9XFxuXFxuICAgIHZhciBpbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcblxcbiAgICBsZXQgaW5wdXRJbmRleCA9IGNhbGN1bGF0ZUlucHV0SW5kZXgoJHt4fSk7XFxuICAgIGlmIChpbnB1dEluZGV4ICE9IDB1KSB7XFxuICAgICAgJHt4fSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XFxuICAgIH1cXG5cXG4gICAgJHtJbChkLGcpfVxcbiAgfWA7cmV0dXJue25hbWU6XCJDb25jYXRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9fSksZ2V0U2hhZGVyU291cmNlOmJ9fSxvaT0oZSx0KT0+e0NsKGUuaW5wdXRzKSxlLmNvbXB1dGUoRWwoZS5pbnB1dHMsdC5heGlzKSl9LGFpPWU9PmllKHtheGlzOmUuYXhpc30pfSk7dmFyIFdlLFdyLHpyLFZyPUgoKCk9PntcInVzZSBzdHJpY3RcIjtXZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxXcj0oZSx0PSExLHI9ITEsbz0zKT0+XCJcIix6cj0oZSx0KT0+YFxcbiAgICAgICR7ZT9cInZhbHVlID0gdmFsdWUgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKTtcIjpcIlwifVxcbiAgICAgIC8vIFRPRE8gdW5jb21tZW50IHRoZSBmb2xsb3dpbmcgbGluZSB3aGVuIGFjdGl2YXRpb24gaXMgc3VwcG9ydGVkIGFib3ZlLlxcbiAgICAgIC8vICR7dD9cInZhbHVlID0gYWN0aXZhdGlvbih2YWx1ZSwgY29vcmRzKTtcIjpcIlwifVxcbiAgICAgIGB9KTt2YXIgR3IsRW49SCgoKT0+e1widXNlIHN0cmljdFwiO0dyPWBcXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XFxufVxcbmZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XFxuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxcbiAgICBvdXRTaGFwZVN0cmlkZXMueCwgb3V0U2hhcGVTdHJpZGVzLnksIG91dFNoYXBlU3RyaWRlcy56LCAxKSk7XFxufVxcbmB9KTt2YXIgTnIsVXIsbnI9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7TnI9KGUsdD0hMSk9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcInZhbHVlID0gbWF4KHZhbHVlLCAwLjApO1wifTtjYXNlXCJTaWdtb2lkXCI6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcInZhbHVlID0gKDEuMCAvICgxLjAgKyBleHAoLXZhbHVlKSkpO1wifTtjYXNlXCJDbGlwXCI6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpgY29uc3QgY2xpcF9taW5fPWYzMigke2UuY2xpcE1pbn0pO2NvbnN0IGNsaXBfbWF4Xz1mMzIoJHtlLmNsaXBNYXh9KTtgLGFwcGx5QWN0aXZhdGlvbjp0P1widmFsdWUgPSBjbGFtcCh2YWx1ZSwgdmVjNChjbGlwX21pbl8pLCB2ZWM0KGNsaXBfbWF4XykpO1wiOlwidmFsdWUgPSBjbGFtcCh2YWx1ZSwgY2xpcF9taW5fLCBjbGlwX21heF8pO1wifTtkZWZhdWx0OnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJcIn19fSxVcj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJDbGlwXCIpe2xldFtyLG9dPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbUnIsUHJdO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDpvLGNsaXBNaW46cixhY3RpdmF0aW9uQ2FjaGVLZXk6YCR7dH06JHtyfSwke299YH19cmV0dXJue2FjdGl2YXRpb246dCxhY3RpdmF0aW9uQ2FjaGVLZXk6dH19fSk7dmFyIFRsLE9sLG9yLHNpLF9sLGFyLFJsLExyLGlyPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7bnIoKTtWcigpO1RsPShlLHQpPT5lP2BcXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgICAgIGA6YFxcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgICAgIGAsT2w9KGUsdCk9PmU/YFxcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcXG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XFxuICAgICAgICAke3Q9PT0zP1wiXCI6XCJsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddO1wifVxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldO1wifVxcbiAgICAgICAgfWA6YFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTtcIn1cXG4gICAgICAgIH1gLG9yPShlLHQscj1cImYzMlwiLG8sbj0hMSxzPTMyLHU9ITEsZD0zMik9PntsZXQgYT10WzFdKmVbMV0sbT10WzBdKmVbMF0sZz1uP2E6cyx4PW4/czphLGI9Zy90WzBdLHc9cy90WzFdO2lmKCEoKG4mJmI9PT00JiZlWzFdPT09NHx8IW4mJihiPT09M3x8Yj09PTQpKSYmZyV0WzBdPT09MCYmcyV0WzFdPT09MCYmZVswXT09PTQpKXRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke259IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtifSBhbmQgd29ya1BlclRocmVhZFsxXSAke2VbMV19IG11c3QgYmUgNC5cXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHtifSBtdXN0IGJlIDMgb3IgNC5cXG4gIHRpbGVBV2lkdGggJHtnfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfS4gdGlsZUlubmVyICR7c30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3RbMV19LiBjb2xQZXJUaHJlYWQgJHtlWzBdfSBtdXN0IGJlIDQuYCk7cmV0dXJuYFxcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7Yn08JHtyfT4sICR7Zy9ifT4sICR7eH0+O1xcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHtyfT4sICR7bS9lWzBdfT4sICR7c30+O1xcblxcbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XFxuY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcXG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHtifTtcXG5jb25zdCB0aWxlSW5uZXIgPSAke3N9O1xcblxcbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcXG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcXG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XFxuXFxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XFxuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xcbiAgbGV0IGJhdGNoID0gJHt1P1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xcbiAgJHtvP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtvLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cXG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7YX07XFxuXFxuICBsZXQgbnVtVGlsZXMgPSAke3U/YCR7TWF0aC5jZWlsKGQvcyl9YDpcIihkaW1Jbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcXG4gIHZhciBrU3RhcnQgPSAke3U/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcXG5cXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHtyfT4sIHJvd1BlclRocmVhZD47XFxuXFxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHt3fTtcXG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XFxuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XFxuICAgICAgICAgICR7VGwobixvKX1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3d9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7bz9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgIH1cXG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XFxuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XFxuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcXG4gICAgICAgICAgJHtiPT09Mz9cIlwiOlwibGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdO1wifVxcblxcbiAgICAgICAgICAke09sKG4sYil9XFxuICAgICAgfVxcblxcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xcbiAgfVxcbn1gfSxzaT0oZSx0KT0+ZT9gXFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgICAgICAgICBgOmBcXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgICAgIGAsX2w9ZT0+ZT9cImxldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddO1wiOlwibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107XCIsYXI9KGUsdCxyPVwiZjMyXCIsbyxuPSExLHM9MzIsdT0hMSxkPTMyLGE9ITEpPT57bGV0IG09ZVsxXSp0WzFdLGc9ZVswXSp0WzBdLHg9bj9tOnMsYj1uP3M6bTtpZighKGIldFsxXT09PTAmJngldFswXT09PTAmJnMldFsxXT09PTApKXRocm93IG5ldyBFcnJvcihgdGlsZUFIaWdodCAke2J9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19LCB0aWxlQVdpZHRoICR7eH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0sIHRpbGVJbm5lciAke3N9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19YCk7bGV0IHc9Yi90WzFdLHY9eC90WzBdLHk9cy90WzFdLFM9YT9gXFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcXG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHttfTtcXG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHtnfTtcXG5cXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXFxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7Yn07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XFxuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7eH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XFxuICAgICAgICAgICR7c2kobixvKX1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtzfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7Z307IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XFxuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke28/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcXG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3RbMF19XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtuP2BtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XTtgOmBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XVtrXTtgfVxcbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICB9XFxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19O1xcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7dFswXX07XFxuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBgOmBcXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XFxuXFxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcXG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7bX07XFxuXFxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke3d9O1xcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHt2fTtcXG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7eX07XFxuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXFxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XFxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXFxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHt3fTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7dn07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcXG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xcbiAgICAgICR7c2kobixvKX1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7eX07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcXG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XFxuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHtvP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgIH1cXG4gIH1cXG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxcbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgJHtfbChuKX1cXG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcXG59XFxuXFxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XFxuICB9XFxufVxcbmA7cmV0dXJuYFxcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7eH0+LCAke2J9PjtcXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke2d9PiwgJHtzfT47XFxuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcXG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7c307XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXFxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xcbiAgICBsZXQgYmF0Y2ggPSAke3U/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XFxuICAgICR7bz9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7by5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XFxuICAgIGxldCBudW1UaWxlcyA9ICR7dT9gJHtNYXRoLmNlaWwoZC9zKX1gOlwiKGRpbUlubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xcbiAgICB2YXIga1N0YXJ0ID0gJHt1P2BpMzIoZ2xvYmFsSWQueikgKiAke2R9YDpcIjBcIn07XFxuXFxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xcblxcbiAgICAvLyBXaXRob3V0IHRoaXMgaW5pdGlhbGl6YXRpb24gc3RyYW5nZSB2YWx1ZXMgc2hvdyB1cCBpbiBhY2MuXFxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gMC4wO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAke1N9XFxuICB9XFxuYH0sUmw9KGUsdCxyLG8sbixzPSExKT0+e2xldCB1PW5bMF0sZD1uWzFdLGE9blsyXSxtPW9bMF0sZz1vWzFdLHg9b1syXSxiPW9bM10sdz14bih1LGEpLHY9eG4oZCxhKSx5PU1lKG9bMF0udHlwZS50ZW5zb3IpLFM9KCk9PntsZXQgVz1nLnJhbmssTT1tLnJhbmssRD1gdmFyIGFJbmRpY2VzOiAke2cudHlwZS5pbmRpY2VzfTtgO2ZvcihsZXQgXz1XLTItMSx6PU0tMTtfPj0wO18tLSx6LS0pRCs9YFxcbmFJbmRpY2VzWyR7X31dID0gJHtNPjE/YGJhdGNoSW5kaWNlc1ske3p9XWA6XCJiYXRjaEluZGljZXNcIn07YDtyZXR1cm4gdy5mb3JFYWNoKF89PntEKz1gXFxuYUluZGljZXNbJHtffV0gPSAwO2B9KSxEKz1gXFxuYUluZGljZXNbJHtXLTJ9XSA9IHUzMihyb3cpO1xcbiAgICAgICAgICAgICAgICAgICBhSW5kaWNlc1ske1ctMX1dID0gdTMyKGNvbEluKTtgLER9LEE9KCk9PntsZXQgVz14LnJhbmssTT1tLnJhbmssRD1gdmFyIGJJbmRpY2VzOiAke3gudHlwZS5pbmRpY2VzfTtgO2ZvcihsZXQgXz1XLTItMSx6PU0tMTtfPj0wO18tLSx6LS0pRCs9YFxcbmJJbmRpY2VzWyR7X31dID0gJHtNPjE/YGJhdGNoSW5kaWNlc1ske3p9XWA6XCJiYXRjaEluZGljZXNcIn07YDtyZXR1cm4gdi5mb3JFYWNoKF89PntEKz1gXFxuYkluZGljZXNbJHtffV0gPSAwO2B9KSxEKz1gXFxuYkluZGljZXNbJHtXLTJ9XSA9IHUzMihyb3cpO1xcbiAgICAgICAgICAgICAgICAgICBiSW5kaWNlc1ske1ctMX1dID0gdTMyKGNvbEluKTtgLER9O3JldHVybmBcXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHttLnR5cGUuaW5kaWNlc30pIC0+ICR7V2UoZSx5KX0ge1xcbiAgICAgIHZhciB2YWx1ZSA9ICR7V2UoZSx5KX0oMC4wKTtcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xcbiAgICAgIGlmKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1Jbm5lcilcXG4gICAgICB7XFxuICAgICAgICAke1MoKX1cXG4gICAgICAgIHZhbHVlID0gJHtnLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7bS50eXBlLmluZGljZXN9KSAtPiAke1dlKGUseSl9IHtcXG4gICAgICB2YXIgdmFsdWUgPSAke1dlKGUseSl9KDAuMCk7XFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcXG4gICAgICBpZihyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXIpXFxuICAgICAge1xcbiAgICAgICAgJHtBKCl9XFxuICAgICAgICB2YWx1ZSA9ICR7eC5nZXRCeUluZGljZXMoXCJiSW5kaWNlc1wiKX07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcblxcbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHtXZShlLHkpfSkge1xcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XFxuICAgICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XFxuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcXG4gICAgICAgICR7dD9gdmFsdWUgPSB2YWx1ZSArICR7cz9cImJpYXNbY29sSW5dXCI6YCR7V2UoZSx5KX0oYmlhc1tyb3ddKWB9O2A6XCJcIn1cXG4gICAgICAgICR7cn1cXG4gICAgICAgICR7Yi5zZXRCeUluZGljZXMoXCJ2ZWMzPHUzMj4oY29vcmRzKVwiLFwidmFsdWVcIil9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGB9LExyPShlLHQscixvLG49ITEpPT57bGV0IHM9ZVswXS5kaW1zLHU9ZVsxXS5kaW1zLGQ9cy5zbGljZSgwLC0yKSxhPXUuc2xpY2UoMCwtMiksbT1vP28uc2xpY2UoMCwtMik6ci5zbGljZSgwLC0yKSxnPUwoXCJiYXRjaERpbXNcIixlWzBdLmRhdGFUeXBlLG0pLHg9W2ddLGI9W2QsYSxtXSx3PWsuc2l6ZShtKSx2PXNbcy5sZW5ndGgtMl0seT1zW3MubGVuZ3RoLTFdLFM9dVt1Lmxlbmd0aC0xXSxBPXklND09PTAmJlMlND09PTAse2FjdGl2YXRpb25GdW5jdGlvbjpSLGFwcGx5QWN0aXZhdGlvbjpXfT1Ocih0LEEpLE09djw9OD9bNCwxLDFdOls0LDQsMV0sRD1bOCw4LDFdLF89W01hdGguY2VpbChTL0RbMF0vTVswXSksTWF0aC5jZWlsKHYvRFsxXS9NWzFdKSxNYXRoLmNlaWwody9EWzJdL01bMl0pXSx6PU1lKGVbMF0uZGF0YVR5cGUpLEY9QT80OjEscT1MKFwiYVwiLGVbMF0uZGF0YVR5cGUsWy4uLmQsdix5L0ZdLEYpLGxlPUwoXCJiXCIsZVsxXS5kYXRhVHlwZSxbLi4uYSx5LFMvRl0sRiksQj1YKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxbdyx2LFMvRl0sRik7eC5wdXNoKHEpLHgucHVzaChsZSkseC5wdXNoKEIpO2xldCBLPVtxLGxlXSx4ZT1lLmxlbmd0aD4yLGFlPVJsKEYseGUsVyx4LGIsbik7aWYoeGUpe2xldCBqPW4/RjoxO0sucHVzaChMKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGopKX1sZXQgd2U9aj0+YFxcbiAgY29uc3QgZGltQU91dGVyOiBpMzIgPSAke3Z9O1xcbiAgY29uc3QgZGltQk91dGVyOiBpMzIgPSAke1N9O1xcbiAgY29uc3QgZGltSW5uZXI6IGkzMiA9ICR7eX07XFxuICAke2ouZGVjbGFyZVZhcmlhYmxlcyguLi5LLEIpfVxcbiAgJHtSfVxcbiAgJHthZX1cXG4gICR7QT9vcihNLEQseixnKTphcihNLEQseixnKX1cXG4gICAgICAgICAgICAgICAgICAgJHtnLmltcGwoKX1gO3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5hY3RpdmF0aW9uQ2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpfWzBdLHk6X1sxXSx6Ol9bMl19fSksZ2V0U2hhZGVyU291cmNlOndlfX19KTt2YXIgUGwsdWksbGk9SCgoKT0+e1widXNlIHN0cmljdFwiO210KCk7Z2UoKTt2ZSgpO1ZyKCk7RW4oKTtpcigpO1BsPShlLHQscixvLG49ITEscyx1PSExLGQ9NCxhPTQsbT00LGc9XCJmMzJcIik9PntsZXQgeD1sZT0+e3N3aXRjaChsZSl7Y2FzZSAxOnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4XTtcIjtjYXNlIDM6cmV0dXJuYHJlc0RhdGEgPSB2ZWMzPCR7Z30+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2xlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sYj1sZT0+e3N3aXRjaChsZSl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogd1NoYXBlWzNdICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIHdTaGFwZVszXSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtsZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LHc9ZT9gXFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcXG4gICAgYDpgXFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcXG4gICAgYCx2PWU/YFxcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxcbiAgICAgIGJhdGNoLFxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxcbiAgICAgIGNvbCk7XFxuICAgIGA6YFxcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxcbiAgICAgIGJhdGNoLFxcbiAgICAgIHJvdyxcXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XFxuICAgIGAseT1lP1wieFNoYXBlWzFdXCI6XCJ4U2hhcGVbMl1cIixTPWU/XCJ4U2hhcGVbMl1cIjpcInhTaGFwZVszXVwiLEE9ZT9cInJvd1wiOlwiY29sXCIsUj1lP1wiY29sXCI6XCJyb3dcIixXPWBcXG4gICAgbGV0IGluQ2hhbm5lbHMgPSB3U2hhcGVbMl07XFxuICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcXG4gICAgbGV0IG91dFJvdyA9ICR7QX0gLyBvdXRXaWR0aDtcXG4gICAgbGV0IG91dENvbCA9ICR7QX0gJSBvdXRXaWR0aDtcXG5cXG4gICAgbGV0IFdSb3cgPSAke1J9IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcXG4gICAgbGV0IFdDb2wgPSAke1J9IC8gaW5DaGFubmVscyAlIGZpbHRlckRpbXNbMV07XFxuICAgIGxldCB4Um93ID0gb3V0Um93ICogc3RyaWRlWzBdICsgZGlsYXRpb25bMF0gKiBXUm93IC0gcGFkWzBdO1xcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHN0cmlkZVsxXSArIGRpbGF0aW9uWzFdICogV0NvbCAtIHBhZFsxXTtcXG4gICAgbGV0IHhDaCA9ICR7Un0gJSBpbkNoYW5uZWxzO1xcbiAgICB2YXIgcmVzRGF0YSA9ICR7V2UoZCxnKX0oMC4wKTtcXG4gICAgLy8gVGhlIGJvdW5kcyBjaGVja2luZyBpcyBhbHdheXMgbmVlZGVkIHNpbmNlIHdlIHVzZSBpdCB0byBwYWQgemVybyBmb3JcXG4gICAgLy8gdGhlIFxcJ3NhbWVcXCcgcGFkZGluZyB0eXBlLlxcbiAgICBpZiAoeFJvdyA+PSAwICYmIHhSb3cgPCAke3l9ICYmIHhDb2wgPj0gMCAmJiB4Q29sIDwgJHtTfSkge1xcbiAgICAgICR7d31cXG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHhTaGFwZSk7XFxuICAgICAgJHt4KGQpfVxcbiAgICB9XFxuICAgIHJldHVybiByZXNEYXRhO2AsTT1lP3QmJm8/YFxcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xcbiAgICAke1d9YDpgXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XFxuICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltSW5uZXIpIHtcXG4gICAgICAke1d9XFxuICAgIH1cXG4gICAgcmV0dXJuICR7V2UoZCxnKX0oMC4wKTtgOm8mJnI/YFxcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xcbiAgICAke1d9YDpgXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XFxuICAgIGlmIChyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcXG4gICAgICAke1d9XFxuICAgIH1cXG4gICAgcmV0dXJuICR7V2UoZCxnKX0oMC4wKTtgLEQ9YCR7YihhKX1gLF89V2UobSxnKSx6PWU/V2UoZCxnKTpXZShhLGcpLEY9ZT9XZShhLGcpOldlKGQsZyk7cmV0dXJuYFxcbiAgICAke1dyKHMsdSxtPT09NCw0KX1cXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHt6fSB7XFxuICAgICAgJHtlP006RH1cXG4gICAgfVxcblxcbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke0Z9IHtcXG4gICAgICAke2U/RDpNfVxcbiAgICB9XFxuXFxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke199KSB7XFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHttfTtcXG4gICAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUJPdXRlcilcXG4gICAgICB7XFxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcXG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XFxuICAgICAgJHt2fVxcbiAgICAgICR7enIobixzKX1cXG4gICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcXG4gICAgICB9XFxuICAgIH1gfSx1aT0oZSx0LHIsbyxuLHMsdSxkKT0+e2xldCBhPXQuZm9ybWF0PT09XCJOSFdDXCIsbT1hP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sZz1yWzBdLHg9YT9yWzJdOnJbM10sYj1hP3JbMV06clsyXSx3PWE/clszXTpyWzFdLHY9YSYmKG0lND09PTB8fG0lMz09PTApJiZ3JTQ9PT0wLHk9YT93OngqYixTPWE/eCpiOncsQT1bOCw4LDFdLFI9bzw9OD9bNCwxLDFdOls0LDQsMV0sVz1bTWF0aC5jZWlsKHkvQVswXS9SWzBdKSxNYXRoLmNlaWwoUy9BWzFdL1JbMV0pLE1hdGguY2VpbChnL0FbMl0vUlsyXSldO0VlKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtXfWApO2xldCBNPXY/YSYmbSU0IT09MD8zOjQ6UlswXSxEPUFbMV0qUlsxXSxfPUFbMF0qUlswXSx6PU1hdGgubWF4KEFbMF0qTSxBWzFdKSxGPW8lRD09PTAscT1uJV89PT0wLGxlPXMlej09PTAsQj12P1tNLDQsNF06WzEsMSwxXSxLPU1lKGVbMF0uZGF0YVR5cGUpLHhlPVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4OiBhcnJheTwke3YmJk09PT00P2B2ZWM0PCR7S30+YDpLfT47YCxgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiB3OiBhcnJheTwke3Y/YHZlYzQ8JHtLfT5gOkt9PjtgXSxhZT1gXFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHt2P2B2ZWM0PCR7S30+YDpLfSkge1xcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3Y/YHZlYzQ8JHtLfT5gOkt9KHZhbHVlKTtcXG4gICAgICB9XFxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHt2P2B2ZWM0PCR7S30+YDpLfSkge1xcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcXG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7dj9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XFxuICAgICAgfWA7cmV0dXJuIHUmJih4ZS5wdXNoKGBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJpYXM6IGFycmF5PCR7dj9gdmVjNDwke0t9PmA6S30+O2ApLGFlKz1gXFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke3Y/YHZlYzQ8JHtLfT5gOkt9IHtcXG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7YT9cIndcIjpcInlcIn0ke3Y/XCIvIDRcIjpcIlwifV07XFxuICAgICAgICB9YCkse25hbWU6XCJDb252MkRNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6V1swXSx5OldbMV0sejpXWzJdfX0pLGdldFNoYWRlclNvdXJjZTooKT0+YFxcbiAgICAgICAgJHtHcn1cXG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XFxuICAgICAgICAke3hlLmpvaW4oXCJcIil9XFxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt4ZS5sZW5ndGh9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0OiBhcnJheTwke3Y/YHZlYzQ8JHtLfT5gOkt9PjtcXG4gICAgICAgIC8vQGdyb3VwKDApIEBiaW5kaW5nKCR7eGUubGVuZ3RoKzF9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xcblxcbiAgICAgICAgY29uc3QgeFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCB3U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzFdLmRpbXMuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IG91dFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ci5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgb3V0U2hhcGVTdHJpZGVzIDogdmVjMzxpMzI+ID0gdmVjMzxpMzI+KCR7ay5jb21wdXRlU3RyaWRlcyhyKS5zbGljZSgwLDMpLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5rZXJuZWxTaGFwZVswXX0sICR7dC5rZXJuZWxTaGFwZVsxXX0pO1xcbiAgICAgICAgY29uc3QgcGFkIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5wYWRzWzBdfSwgJHt0LnBhZHNbMV19KTtcXG4gICAgICAgIGNvbnN0IHN0cmlkZSA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Quc3RyaWRlc1swXX0sICR7dC5zdHJpZGVzWzFdfSk7XFxuICAgICAgICBjb25zdCBkaWxhdGlvbiA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3QuZGlsYXRpb25zWzBdfSwgJHt0LmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgY29uc3QgZGltQU91dGVyIDogaTMyID0gJHtvfTtcXG4gICAgICAgIGNvbnN0IGRpbUJPdXRlciA6IGkzMiA9ICR7bn07XFxuICAgICAgICBjb25zdCBkaW1Jbm5lciA6IGkzMiA9ICR7c307XFxuICAgICAgICAke2FlfVxcbiAgICAgICAgJHtQbChhLEYscSxsZSx1LHQuYWN0aXZhdGlvbi50b0xvd2VyQ2FzZSgpLCExLEJbMF0sQlsxXSxCWzJdLEspfVxcbiAgICAgICAgICAgICR7dj9vcihSLEEsSyx2b2lkIDAsIWEseik6YXIoUixBLEssdm9pZCAwLCFhLHosITEsdm9pZCAwLGQpfWB9fX0pO3ZhciBUbixkaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO19uKCk7bnIoKTtUbj0oZSx0LHIpPT57bGV0IG89ZS5sZW5ndGg+MixuPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLHM9ZVswXS5kaW1zLHU9ZVsxXS5kaW1zLGQ9dVswXS90Lmdyb3VwLHthY3RpdmF0aW9uRnVuY3Rpb246YSxhcHBseUFjdGl2YXRpb246bX09TnIodCksZz10LmZvcm1hdD09PVwiTkhXQ1wiLHg9T24ocyx1LHQuZGlsYXRpb25zLHQucGFkcyx0LnN0cmlkZXMsZyksYj1rLnNpemUoeCksdz1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx4KSx2PUwoXCJ4XCIsZVswXS5kYXRhVHlwZSxzKSx5PUwoXCJ3XCIsZVsxXS5kYXRhVHlwZSx1KSxTPVt2LHldO28mJlMucHVzaChMKFwiYlwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zKSk7bGV0IEE9Uj0+YFxcbiAgY29uc3Qgc3RyaWRlczogdmVjMjx1MzI+ID0gdmVjMigke3Quc3RyaWRlc1swXX11LCAke3Quc3RyaWRlc1sxXX11KTtcXG4gIGNvbnN0IHBhZHM6IHZlYzI8dTMyPiA9IHZlYzIoJHt0LnBhZHNbMF19dSwgJHt0LnBhZHNbMV19dSk7XFxuXFxuICAke1IuZGVjbGFyZVZhcmlhYmxlcyguLi5TLHcpfVxcblxcbiAgJHthfVxcblxcbiAgJHtSLm1haW5TdGFydCgpfVxcbiAgICAke1IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhiKX1cXG5cXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke3cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcXG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7Zz8zOjF9XTtcXG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtnPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7Zz8yOjN9XSkgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgbGV0IGdyb3VwX2lkOiB1MzIgPSBvdXRwdXRfY2hhbm5lbCAvICR7ZH11O1xcblxcbiAgICB2YXIgdmFsdWU6ICR7dy50eXBlLnZhbHVlfSA9ICR7dy50eXBlLnZhbHVlfSgwKTtcXG4gICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCAke3VbMV19dTsgd0luQ2hhbm5lbCsrKSB7XFxuICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7dVsxXX11ICsgd0luQ2hhbm5lbDtcXG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8ICR7dVsyXX11OyB3SGVpZ2h0KyspIHtcXG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogJHt0LmRpbGF0aW9uc1swXX11O1xcblxcbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49ICR7c1tnPzE6Ml19dSkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8ICR7dVszXX11OyB3V2lkdGgrKykge1xcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3QuZGlsYXRpb25zWzFdfXU7XFxuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gJHtzW2c/MjozXX11KSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGV0IHhWYWwgPSAke2c/di5nZXQoXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCIpOnYuZ2V0KFwiYmF0Y2hcIixcImlucHV0X2NoYW5uZWxcIixcInhIZWlnaHRcIixcInhXaWR0aFwiKX07XFxuICAgICAgICAgIGxldCB3VmFsID0gJHt5LmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7bn1cXG4gICAgJHttfVxcbiAgICAke3cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cXG4gIH1gO3JldHVybntuYW1lOlwiR3JvdXBlZENvbnZcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnI/cih4KTp4LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChiLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6QX19fSk7dmFyIE9uLGNpLE1sLHBpLFJuLEJsLGtsLFBuLF9uPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7bGkoKTtpcigpO2RpKCk7bnIoKTtycigpO09uPShlLHQscixvLG4scyk9PntsZXQgdT1lWzBdLGQ9ZS5zbGljZShzPzE6MixzPzM6NCksYT1kLmxlbmd0aCxtPXRbMF0seD10LnNsaWNlKDIpLm1hcCgodix5KT0+disodi0xKSooclt5XS0xKSksdz1kLm1hcCgodix5KT0+ditvW3ldK29beSthXSkubWFwKCh2LHkpPT5NYXRoLmZsb29yKCh2LXhbeV0rblt5XSkvblt5XSkpO3JldHVybiB3LnNwbGljZSgwLDAsdSksdy5zcGxpY2Uocz8zOjEsMCxtKSx3fSxjaT1bMiwzLDEsMF0sTWw9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IGNvbnYgMUQgYW5kIDJEXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCByPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxvPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKHIhPT1vKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMV0uZGltc1swXSE9PWVbMl0uZGltc1swXSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBuPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZih0LnBhZHMubGVuZ3RoIT09bioyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtuKjJ9RGApO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIil9LHBpPShlLHQpPT57bGV0IHI9ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2ZvcihsZXQgcz0yO3M8dFsxXS5kaW1zLmxlbmd0aDsrK3MpcltzLTJdPT09MCYmKHJbcy0yXT10WzFdLmRpbXNbc10pO2xldCBvPWUucGFkcy5zbGljZSgpO0N0LmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLHIsbyxlLmZvcm1hdD09PVwiTkhXQ1wiLGUuYXV0b1BhZCk7bGV0IG49T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuLHtrZXJuZWxTaGFwZTpyLHBhZHM6byxjYWNoZUtleTplLmNhY2hlS2V5fSksbn0sUm49ZT0+e2xldCB0PVVyKGUpLHI9ZS5mb3JtYXQsbz1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLG49ZS5kaWxhdGlvbnMscz1lLmdyb3VwLHU9ZS5rZXJuZWxfc2hhcGUsZD1lLnBhZHMsYT1lLnN0cmlkZXMsbT1lLndfaXNfY29uc3QoKTtyZXR1cm4gaWUoe2F1dG9QYWQ6byxmb3JtYXQ6cixkaWxhdGlvbnM6bixncm91cDpzLGtlcm5lbFNoYXBlOnUscGFkczpkLHN0cmlkZXM6YSx3SXNDb25zdDptLC4uLnR9KX0sQmw9KGUsdCxyKT0+e2xldCBvPXBpKHIsdCk7aWYoci5ncm91cCE9PTEpe2UuY29tcHV0ZShUbih0LG8pKTtyZXR1cm59bGV0IG49ci5mb3JtYXQ9PT1cIk5IV0NcIixzPXQubGVuZ3RoPT09Myx1PXRbMF0uZGltc1tuPzE6Ml0sZD10WzBdLmRpbXNbbj8yOjNdLGE9dFswXS5kaW1zW24/MzoxXSxtPXRbMV0uZGltc1syXSxnPXRbMV0uZGltc1szXSx4PU9uKHRbMF0uZGltcyx0WzFdLmRpbXMsci5kaWxhdGlvbnMsby5wYWRzLHIuc3RyaWRlcyxuKSxiPXhbbj8xOjJdLHc9eFtuPzI6M10sdj14W24/MzoxXSx5PW4mJm09PT11JiZnPT09ZCYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MDtpZih5fHxtPT09MSYmZz09PTEmJnIuZGlsYXRpb25zWzBdPT09MSYmci5kaWxhdGlvbnNbMV09PT0xJiZyLnN0cmlkZXNbMF09PT0xJiZyLnN0cmlkZXNbMV09PT0xJiZyLnBhZHNbMF09PT0wJiZyLnBhZHNbMV09PT0wKXtsZXQgXz14WzBdLHosRixxLGxlPVtdO2lmKG4pe2xldCBCPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKGd0KHRbMV0sY2kpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07aWYoci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1CKSx5KXtsZXQgSz11KmQqYTt6PXRbMF0ucmVzaGFwZShbMSxfLEtdKSxGPUIucmVzaGFwZShbMSxLLHZdKSxxPVsxLF8sdl19ZWxzZSB6PXRbMF0ucmVzaGFwZShbXyx1KmQsYV0pLEY9Qi5yZXNoYXBlKFsxLGEsdl0pLHE9W18sYip3LHZdO2xlLnB1c2goeiksbGUucHVzaChGKX1lbHNlIHo9dFswXS5yZXNoYXBlKFtfLGEsdSpkXSksRj10WzFdLnJlc2hhcGUoWzEsdixhXSkscT1bXyx2LGIqd10sbGUucHVzaChGKSxsZS5wdXNoKHopO3MmJmxlLnB1c2godFsyXSksZS5jb21wdXRlKExyKGxlLG8seCxxLG4pLHtpbnB1dHM6bGV9KTtyZXR1cm59bGV0IFM9ITAsQT1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShndCh0WzFdLGNpKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9QSk7bGV0IFI9W3RbMF0sQV07cyYmUi5wdXNoKHRbMl0pO2xldCBXPW4/Yip3OnYsTT1uP3Y6Yip3LEQ9bSpnKmE7ZS5jb21wdXRlKHVpKFIsbyx4LFcsTSxELHMsUykse2lucHV0czpSfSl9LGtsPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixvPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZvLnB1c2goZS5pbnB1dHNbMl0pO2xldCBuPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0scz1bMV0uY29uY2F0KHQuc3RyaWRlcyksdT1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSxkPVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSksYT1waSh7Li4udCxwYWRzOm4sc3RyaWRlczpzLGRpbGF0aW9uczp1LGtlcm5lbFNoYXBlOmR9LG8pO2UuY29tcHV0ZShUbihvLGEsbT0+cj9bbVswXSxtWzJdLG1bM11dOltdKSl9LFBuPShlLHQpPT57TWwoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zP2tsKGUsdCk6QmwoZSxlLmlucHV0cyx0KX19KTt2YXIgRGwsZmksbWk9SCgoKT0+e1widXNlIHN0cmljdFwiO210KCk7Z2UoKTtWcigpO0VuKCk7aXIoKTtEbD0oZSx0PSExLHIsbz0hMSxuPTQpPT57bGV0IHM9V2UobixcImYzMlwiKSx1PUE9Pntzd2l0Y2goQSl7Y2FzZSAxOnJldHVyblwicmV0dXJuIFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHdTaGFwZSldO1wiO2Nhc2UgNDpyZXR1cm5gXFxuICAgICAgICAgICAgbGV0IGNvb3JkMSA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMSwgcm93SW5uZXIpO1xcbiAgICAgICAgICAgIGxldCBjb29yZDIgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDIsIHJvd0lubmVyKTtcXG4gICAgICAgICAgICBsZXQgY29vcmQzID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAzLCByb3dJbm5lcik7XFxuICAgICAgICAgICAgbGV0IHYwID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgd1NoYXBlKV07XFxuICAgICAgICAgICAgbGV0IHYxID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDEsIHdTaGFwZSldO1xcbiAgICAgICAgICAgIGxldCB2MiA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQyLCB3U2hhcGUpXTtcXG4gICAgICAgICAgICBsZXQgdjMgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMywgd1NoYXBlKV07XFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPih2MCwgdjEsIHYyLCB2Myk7XFxuICAgICAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0F9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxkPWU/YFxcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgaVhSLCBpWEMsIHhDaCk7XFxuICAgICAgYDpgXFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIGlYUiwgaVhDKTtcXG4gICAgICBgLGE9ZT9gXFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXFxuICAgICAgYmF0Y2gsXFxuICAgICAgcm93IC8gb3V0V2lkdGgsXFxuICAgICAgcm93ICUgb3V0V2lkdGgsXFxuICAgICAgY29sKTtcXG4gICAgYDpgXFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXFxuICAgICAgYmF0Y2gsXFxuICAgICAgcm93LFxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcXG4gICAgYCxtPWU/XCJvdXRCYWNrcHJvcFsxXVwiOlwib3V0QmFja3Byb3BbMl1cIixnPWU/XCJvdXRCYWNrcHJvcFsyXVwiOlwib3V0QmFja3Byb3BbM11cIix4PWU/XCJyb3dcIjpcImNvbFwiLGI9ZT9cImNvbFwiOlwicm93XCIsdz1gXFxuICAgICAgbGV0IGluQ2hhbm5lbHMgPSAke2U/XCJvdXRCYWNrcHJvcFszXVwiOlwib3V0QmFja3Byb3BbMV1cIn07XFxuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xcbiAgICAgIGxldCBvdXRSb3cgPSAke3h9IC8gb3V0V2lkdGg7XFxuICAgICAgbGV0IG91dENvbCA9ICR7eH0gJSBvdXRXaWR0aDtcXG5cXG4gICAgICBsZXQgV1JvdyA9ICR7Yn0gLyAoZmlsdGVyRGltc1sxXSAqIGluQ2hhbm5lbHMpO1xcbiAgICAgIGxldCBXQ29sID0gJHtifSAvIGluQ2hhbm5lbHMgJSBmaWx0ZXJEaW1zWzFdO1xcbiAgICAgIGxldCB4UiA9IGYzMihvdXRSb3cgLSBwYWRzWzBdICsgZGlsYXRpb25bMF0gKiBXUm93KSAvIGYzMihzdHJpZGVzWzBdKTtcXG4gICAgICBsZXQgeEMgPSBmMzIob3V0Q29sIC0gcGFkc1sxXSArIGRpbGF0aW9uWzFdICogV0NvbCkgLyBmMzIoc3RyaWRlc1sxXSk7XFxuICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49IGYzMigke219KSB8fCBmcmFjdCh4UikgPiAwLjApIHtcXG4gICAgICAgIHJldHVybiAke3N9KDAuMCk7XFxuICAgICAgfVxcbiAgICAgIGlmICh4QyA8IDAuMCB8fCB4QyA+PSBmMzIoJHtnfSkgfHwgZnJhY3QoeEMpID4gMC4wKSB7XFxuICAgICAgICByZXR1cm4gJHtzfSgwLjApO1xcbiAgICAgIH1cXG4gICAgICBsZXQgaVhSID0gaTMyKHhSKTtcXG4gICAgICBsZXQgaVhDID0gaTMyKHhDKTtcXG4gICAgICBsZXQgeENoID0gJHtifSAlIGluQ2hhbm5lbHM7XFxuICAgICAgJHtkfVxcbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB4U2hhcGUpLyR7bn1dO2Asdj1lP2BcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xcbiAgICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltSW5uZXIpIHtcXG4gICAgICAgICR7d31cXG4gICAgICB9XFxuICAgICAgcmV0dXJuICR7c30oMC4wKTtgOmBcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xcbiAgICAgIGlmIChyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcXG4gICAgICAgICR7d31cXG4gICAgICB9XFxuICAgICAgcmV0dXJuICR7c30oMC4wKTtgLHk9YFxcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XFxuICAgICAgbGV0IGluQ2hhbm5lbHMgPSAke2U/XCJvdXRCYWNrcHJvcFszXVwiOlwib3V0QmFja3Byb3BbMV1cIn07XFxuICAgICAgbGV0IGNvb3JkWCA9IGZpbHRlckRpbXMueCAtIDEgLSByb3cgLyAoZmlsdGVyRGltc1sxXSAqIGluQ2hhbm5lbHMpO1xcbiAgICAgIGxldCBjb29yZFkgPSBmaWx0ZXJEaW1zLnkgLSAxIC0gKHJvdyAvIGluQ2hhbm5lbHMpICUgZmlsdGVyRGltc1sxXTtcXG4gICAgICBpZiAoJHtlP1wicm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyXCI6XCJyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1BT3V0ZXJcIn0gICYmIGNvb3JkWCA+PSAwICYmIGNvb3JkWSA+PSAwKSB7XFxuICAgICAgICBsZXQgcm93SW5uZXIgPSByb3cgJSBpbkNoYW5uZWxzO1xcbiAgICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wsIHJvd0lubmVyKTtcXG4gICAgICAgICR7dShuKX1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuICR7c30oMC4wKTtcXG4gICAgICBgO3JldHVybmBcXG4gICR7V3IocixvLG49PT00LDQpfVxcbiAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtzfSB7XFxuICAgICR7ZT92Onl9XFxuICB9XFxuXFxuICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3N9IHtcXG4gICAgJHtlP3k6dn1cXG4gIH1cXG5cXG4gIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW5wdXQgOiAke3N9KSB7XFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XFxuICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XFxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbnB1dDtcXG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XFxuICAgICAgJHthfVxcbiAgICAgICR7enIodCxyKX1cXG4gICAgICByZXN1bHRbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzLCBvdXRTaGFwZSkvJHtufV0gPSB2YWx1ZTtcXG4gICAgfVxcbiAgfWB9LGZpPShlLHQscixvLG4scyx1LGQpPT57bGV0IGE9dC5mb3JtYXQ9PT1cIk5IV0NcIixtPWE/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxnPXJbMF0seD1hP3JbMl06clszXSxiPWE/clsxXTpyWzJdLHc9YT9yWzNdOnJbMV0sdj1hP20lND09PTAmJnclND09PTA6eCU0PT09MCYmdyU0PT09MCx5PWE/dzp4KmIsUz1hP3gqYjp3LEE9dj9bOCw4LDFdOlt5PD00fHxTPD00PzQ6MTYseT40JiZTPD00PzQ6MTYsMV0sUj12P1s0LDQsMV06W3k8PTQ/MTo0LHk+NCYmUzw9ND8xOjQsMV0sVz1bTWF0aC5jZWlsKHkvQVswXS9SWzBdKSxNYXRoLmNlaWwoUy9BWzFdL1JbMV0pLE1hdGguY2VpbChnL0FbMl0vUlsyXSldO0VlKFwidmVyYm9zZVwiLCgpPT5gW2NvbnZfYmFja3Byb3BfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7V31gKTtsZXQgTT12PzQ6MSxEPU1hdGgubWF4KEFbMF0qTSxBWzFdKSxfPVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4OiBhcnJheTwke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifT47YCxcIkBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gVzogYXJyYXk8ZjMyPjtcIl0sej1cIlwiO3JldHVybiB1JiYoXy5wdXNoKGBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJpYXM6IGFycmF5PCR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtgKSx6Kz1gXFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifSB7XFxuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2E/XCJ3XCI6XCJ5XCJ9JHt2P1wiLyA0XCI6XCJcIn1dO1xcbiAgICAgICAgfWApLHtuYW1lOlwiQ29udjJEVHJhbnNwb3NlTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OldbMF0seTpXWzFdLHo6V1syXX19KSxnZXRTaGFkZXJTb3VyY2U6KCk9PmBcXG4gICAgICAgICR7R3J9XFxuICAgICAgICAke18uam9pbihgXFxuYCl9XFxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtfLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PCR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtcXG4gICAgICAgIGNvbnN0IG91dEJhY2twcm9wIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCB4U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzBdLmRpbXMuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHdTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMV0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtyLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBvdXRTaGFwZVN0cmlkZXMgOiB2ZWMzPGkzMj4gPSB2ZWMzPGkzMj4oJHtrLmNvbXB1dGVTdHJpZGVzKHIpLnNsaWNlKDAsMykuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0Lmtlcm5lbFNoYXBlW2E/MToyXX0sICR7dC5rZXJuZWxTaGFwZVthPzI6M119KTtcXG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSBmaWx0ZXJEaW1zICsgdmVjMjxpMzI+KFxcbiAgICAgICAgICAgICAgJHt0LmRpbGF0aW9uc1swXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2E/MToyXS0xKSoodC5kaWxhdGlvbnNbMF0tMSl9LFxcbiAgICAgICAgICAgICAgJHt0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2E/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSl9KTtcXG4gICAgICAgIGNvbnN0IHBhZHMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0pIC0gMSAtICgke3QucGFkc1swXSt0LnBhZHNbMl19KS8yLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0pIC0gMSAtICgke3QucGFkc1sxXSt0LnBhZHNbM119KS8yKTtcXG4gICAgICAgIGNvbnN0IHN0cmlkZXMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LnN0cmlkZXNbMF19LCAke3Quc3RyaWRlc1sxXX0pO1xcbiAgICAgICAgY29uc3QgZGlsYXRpb24gOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LmRpbGF0aW9uc1swXX0sICR7dC5kaWxhdGlvbnNbMV19KTtcXG4gICAgICAgIGNvbnN0IGRpbUFPdXRlciA6IGkzMiA9ICR7b307XFxuICAgICAgICBjb25zdCBkaW1CT3V0ZXIgOiBpMzIgPSAke259O1xcbiAgICAgICAgY29uc3QgZGltSW5uZXIgOiBpMzIgPSAke3N9O1xcbiAgICAgICAgJHt6fVxcbiAgICAgICAgJHtEbChhLHUsdC5hY3RpdmF0aW9uLnRvTG93ZXJDYXNlKCksITEsTSl9XFxuICAgICAgICAke3Y/b3IoUixBLFwiZjMyXCIsdm9pZCAwLCFhLEQpOmFyKFIsQSxcImYzMlwiLHZvaWQgMCwhYSxELCExLHZvaWQgMCxkKX1gfX19KTt2YXIgV2wsTW4saGk9SCgoKT0+e1widXNlIHN0cmljdFwiO210KCk7Z2UoKTt2ZSgpO1dsPShlLHQscixvLG4scyx1PSExLGQpPT57bGV0IGE9ci5mb3JtYXQ9PT1cIk5IV0NcIixtPWE/MToyLGc9YT8yOjMseD1hPzM6MSxiPWsuc2l6ZShvKSx3PXU/MjoxLHY9ci5ncm91cCx5PXRbMV0uZGltcyxTPXlbMF0vdixBPXlbMV0sUj1gXFxuICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IHUzMiwgdmFsdWUgOiAke3U/YHZlYzQ8JHtkfT5gOmR9KSB7XFxuICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt1P2B2ZWM0PCR7ZH0+YDpkfSh2YWx1ZSk7XFxuICB9YDtuJiYoUis9YFxcbiAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDx1MzI+KSAtPiAke3U/YHZlYzQ8JHtkfT5gOmR9IHtcXG4gICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHthP1wid1wiOlwieVwifSR7dT9cIi8gNFwiOlwiXCJ9XTtcXG4gICAgfWApO2xldCBXPXU/NDoxLE09TChcIldcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcyxXKSxEPUwoXCJEeVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLFcpLF89W0QsTV07biYmXy5wdXNoKEwoXCJiaWFzXCIsdFsyXS5kYXRhVHlwZSxbb1t4XV0sVykpO2xldCB6PVgoXCJyZXN1bHRcIix0WzBdLmRhdGFUeXBlLG8sVyksRj1ge1xcbiAgICAgICAgbGV0IGJhdGNoOiB1MzIgPSAke3M/XCJnbG9iYWxfaWQuelwiOlwid29ya2dyb3VwX2lkLnpcIn0gLyBvdXRTaGFwZVsxXTtcXG4gICAgICAgIGxldCByID0gJHtzP1wiZ2xvYmFsX2lkLnpcIjpcIndvcmtncm91cF9pZC56XCJ9ICUgb3V0U2hhcGVbMV07XFxuICAgICAgICBsZXQgYyA9ICR7cz9cImdsb2JhbF9pZC55XCI6XCJ3b3JrZ3JvdXBfaWQueVwifSAqICR7d307XFxuICAgICAgICBsZXQgZDE6IHUzMiA9ICR7cz9cImdsb2JhbF9pZC54XCI6XCJ3b3JrZ3JvdXBfaWQueFwifSAqIDQ7XFxuXFxuICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdmVjMjxpMzI+KHBhZHMpO1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIHZhciBkb3RQcm9kOiBhcnJheTx2ZWM0PCR7ZH0+LCAke3d9PjtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt3fTsgaSsrKSB7XFxuICAgICAgICAgIGRvdFByb2RbaV0gPSB2ZWM0PCR7ZH0+KDAuMCk7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCBmaWx0ZXJEaW1zWzBdOyB3UiA9IHdSICsgMSkge1xcbiAgICAgICAgICB2YXIgZHlSID0gKCR7ZH0oZHlDb3JuZXIueCkgKyAke2R9KHdSKSkgLyAke2R9KHN0cmlkZXMueCk7XFxuICAgICAgICAgIGxldCB3UlBlcm0gPSBmaWx0ZXJEaW1zWzBdIC0gMSAtIHdSO1xcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2R9KG91dEJhY2twcm9wWzFdKSB8fFxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCB8fCB3UlBlcm0gPCAwKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCBmaWx0ZXJEaW1zWzFdOyB3QyA9IHdDICsgMSkge1xcbiAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkfShkeUNvcm5lci55KSArICR7ZH0od0MpKSAvICR7ZH0oc3RyaWRlcy55KTtcXG4gICAgICAgICAgICBsZXQgZHlDMiA9ICgke2R9KGR5Q29ybmVyLnkpICsgMS4wICsgJHtkfSh3QykpIC8gJHtkfShzdHJpZGVzLnkpO1xcbiAgICAgICAgICAgIGxldCB3Q1Blcm0gPSBmaWx0ZXJEaW1zWzFdIC0gMSAtIHdDO1xcbiAgICAgICAgICAgIGlmICh3Q1Blcm0gPCAwKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIGJEeUNWYWwgPSB0cnVlO1xcbiAgICAgICAgICAgIHZhciBiRHlDVmFsMiA9IHRydWU7XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtkfShvdXRCYWNrcHJvcFsyXSkgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgYkR5Q1ZhbCA9IGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoZHlDMiA8IDAuMCB8fCBkeUMyID49ICR7ZH0ob3V0QmFja3Byb3BbMl0pIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QzIpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBiRHlDVmFsMiA9IGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XFxuICAgICAgICAgICAgbGV0IGlkeUMyOiB1MzIgPSB1MzIoZHlDMik7XFxuICAgICAgICAgICAgaWYgKGJEeUNWYWwgJiYgYkR5Q1ZhbDIpIHtcXG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IG91dEJhY2twcm9wWzNdO1xcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDIgOnUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDFcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDJcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcXG5cXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5Q1wiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2R9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2RbMF0gPSBkb3RQcm9kWzBdICsgdG1wdmFsO1xcblxcbiAgICAgICAgICAgICAgICB4VmFsdWUgPSAgJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDMlwiLFwiZDJcIil9O1xcblxcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHZlYzQ8JHtkfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbCkge1xcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbJHt4fV07XFxuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMlwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xcblxcbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsMikge1xcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbM107XFxuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMlwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xcblxcbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDMlwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2R9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdG1wdmFsO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7d307IGkgPSBpICsgMSkge1xcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kW2ldICsgJHtuP1wiYmlhc1tjK2ldXCI6XCIwLjBcIn07XFxuICAgICAgICAgICR7ei5zZXQoXCJiYXRjaFwiLFwiclwiLFwiYyArIGlcIixcImQxXCIsXCJ2YWx1ZVwiKX07XFxuICAgICAgICB9XFxuICAgICAgfWAscT1gXFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt6Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgICBsZXQgYmF0Y2ggPSAke3ouaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XFxuICAgICAgICAgIGxldCBkMSA9ICR7ei5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHgpfTtcXG4gICAgICAgICAgbGV0IHIgPSAke3ouaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixtKX07XFxuICAgICAgICAgIGxldCBjID0gJHt6LmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsZyl9O1xcbiAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gcGFkcztcXG4gICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gJHtBfTtcXG4gICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogJHtBfTtcXG4gICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgICB2YXIgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgZWZmZWN0aXZlRmlsdGVyRGltcy54OyB3UiA9IHdSICsgMSkge1xcbiAgICAgICAgICAgIGlmICh3UiAlIGRpbGF0aW9ucy54ICE9IDApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgZHlSID0gKCR7ZH0oZHlSQ29ybmVyKSArICR7ZH0od1IpKSAvICR7ZH0oc3RyaWRlc1swXSk7XFxuICAgICAgICAgICAgbGV0IHdSUGVybSA9IGZpbHRlckRpbXMueCAtIDEgLSB3UiAvIGRpbGF0aW9ucy54O1xcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZH0ob3V0QmFja3Byb3BbJHttfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcXG4gICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcXG5cXG4gICAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCBlZmZlY3RpdmVGaWx0ZXJEaW1zLnk7IHdDID0gd0MgKyAxKSB7XFxuICAgICAgICAgICAgICBpZiAod0MgJSBkaWxhdGlvbnMueSAhPSAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgbGV0IGR5QyA9ICgke2R9KGR5Q0Nvcm5lcikgKyAke2R9KHdDKSkgLyAke2R9KHN0cmlkZXMueSk7XFxuICAgICAgICAgICAgICBsZXQgd0NQZXJtID0gZmlsdGVyRGltcy55IC0gMSAtIHdDIC8gZGlsYXRpb25zLnk7XFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2R9KG91dEJhY2twcm9wWyR7Z31dKSB8fFxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcXG4gICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogJHtTfTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8ICR7U307IGQyID0gZDIgKyAxKSB7XFxuICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke2E/RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5Q1wiLFwiaW5wdXRDaGFubmVsXCIpOkQuZ2V0KFwiYmF0Y2hcIixcImlucHV0Q2hhbm5lbFwiLFwiaWR5UlwiLFwiaWR5Q1wiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUgPSAke00uZ2V0KFwiaW5wdXRDaGFubmVsXCIsXCJ3T3V0Q2hhbm5lbFwiLFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIpfTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbCA9IGlucHV0Q2hhbm5lbCArIDE7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2QgKyAke24/XCJiaWFzW2QxXVwiOlwiMC4wXCJ9O1xcbiAgICAgICAgICAke3ouc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICR7ZS5kZWNsYXJlVmFyaWFibGVzKC4uLl8seil9XFxuICAke1J9XFxuICBjb25zdCBvdXRTaGFwZSA6IHZlYzQ8dTMyPiA9IHZlYzQ8dTMyPigke28uam9pbihcIixcIil9KTtcXG4gIGNvbnN0IG91dEJhY2twcm9wIDogdmVjNDx1MzI+ID0gdmVjNDx1MzI+KCR7dFswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XFxuICBjb25zdCBzdHJpZGVzIDogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4oJHtyLmtlcm5lbFNoYXBlW2E/MToyXX0sICR7ci5rZXJuZWxTaGFwZVthPzI6M119KTtcXG4gIGNvbnN0IGRpbGF0aW9ucyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke3IuZGlsYXRpb25zWzBdfSwgJHtyLmRpbGF0aW9uc1sxXX0pO1xcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA6IHZlYzI8dTMyPiA9IGZpbHRlckRpbXMgKyB2ZWMyPHUzMj4oXFxuICAgICAgICAgICR7ci5kaWxhdGlvbnNbMF08PTE/MDooci5rZXJuZWxTaGFwZVthPzE6Ml0tMSkqKHIuZGlsYXRpb25zWzBdLTEpfSxcXG4gICAgICAgICAgJHtyLmRpbGF0aW9uc1sxXTw9MT8wOihyLmtlcm5lbFNoYXBlW2E/MjozXS0xKSooci5kaWxhdGlvbnNbMV0tMSl9KTtcXG4gIGNvbnN0IHBhZHMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0pIC0gMSAtICgke3IucGFkc1swXStyLnBhZHNbMl19KS8yLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1sxXSkgLSAxIC0gKCR7ci5wYWRzWzFdK3IucGFkc1szXX0pLzIpO1xcbiAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGIpfTtcXG4gICR7dT9GOnF9fWB9LE1uPShlLHQscik9PntsZXQgbz1lLmxlbmd0aD4yLG49dC5vdXRwdXRTaGFwZSxzPWsuc2l6ZShuKSx1PVtNYXRoLmNlaWwocy82NCksMSwxXTtFZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7dX1gKTtsZXQgZD1NZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7ZGlzcGF0Y2hHcm91cDp7eDp1WzBdLHk6dVsxXSx6OnVbMl19LG91dHB1dHM6W3tkaW1zOnI/cihuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XX0pLGdldFNoYWRlclNvdXJjZTphPT5XbChhLGUsdCxuLG8sdVsxXT09PTEmJnVbMl09PT0xLCExLGQpfX19KTt2YXIgemwsVmwsR2wsZ2kseWksTmwsVWwsTGwsRmwsYmksd2k9SCgoKT0+e1widXNlIHN0cmljdFwiO1BlKCk7bWkoKTtoaSgpO25yKCk7cnIoKTt6bD0oZSx0LHIsbyxuLHMpPT4oZS0xKSp0K3IrKG8tMSkqbisxLXMsVmw9KGUsdCxyLG8sbik9PntsZXQgcz1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW29dPXMscltuXT1lLXMpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbb109ZS1zLHJbbl09cyl9LEdsPShlLHQscixvLG4scyx1LGQsYSxtKT0+e2xldCBnPWUubGVuZ3RoLTIseD1tLmxlbmd0aD09PTA7aWYoYS5sZW5ndGg9PT0wKWZvcihsZXQgdj0wO3Y8ZzsrK3YpYS5wdXNoKDApO2xldCBiPWVbMF0sdz10W2Q/MzoxXSpuO2ZvcihsZXQgdj0wLHk9ZS5sZW5ndGgtZy0oZD8xOjApO3Y8ZzsrK3YsKyt5KXtsZXQgUz1lW3ldLEE9eD9TKnVbdl06bVt2XSxSPXpsKFMsdVt2XSxzW3ZdLHRbeV0sclt2XSxBKTtWbChSLG8scyx2LHYrZykseCYmbS5wdXNoKHVbdl0qKFMtMSkrYVt2XSsodFt5XS0xKSpyW3ZdKzEtc1t2XS1zW3YrZ10pfW0uc3BsaWNlKDAsMCxiKSxtLnNwbGljZShkPzM6MSwwLHcpfSxnaT0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKChiLHcpPT5iKncsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgYj0yO2I8dFsxXS5kaW1zLmxlbmd0aDsrK2Ipci5wdXNoKHRbMV0uZGltc1tiXSl9bGV0IG89ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShvPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG49ZS5wYWRzLnNsaWNlKCkscz1lLm91dHB1dFNoYXBlLnNsaWNlKCksdT1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxkPXRbMF0uZGltcyxhPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYoYS5yZWR1Y2UoKGIsdyk9PmIrdywwKT09PTApe2xldCBiPXRbMF0uZGltcy5sZW5ndGgtMjthPW5ldyBBcnJheShiKS5maWxsKDEpfWxldCBtPWUuc3RyaWRlcy5zbGljZSgpO2lmKG0ucmVkdWNlKChiLHcpPT5iK3csMCk9PT0wKXtsZXQgYj10WzBdLmRpbXMubGVuZ3RoLTI7bT1uZXcgQXJyYXkoYikuZmlsbCgxKX1HbChkLHIsYSxlLmF1dG9QYWQsZS5ncm91cCxuLG0sbyx1LHMpO2xldCBnPU9iamVjdC5hc3NpZ24oe30sZSkseD1lLmNhY2hlS2V5K1tyLmpvaW4oXCJuLFwiKSxuLmpvaW4oXCIsXCIpLG0uam9pbihcIixcIiksdS5qb2luKFwiLFwiKSxzLmpvaW4oXCIsXCIpLGEuam9pbihcIixcIildLmpvaW4oXCJfXCIpO3JldHVybiBPYmplY3QuYXNzaWduKGcse2tlcm5lbFNoYXBlOnIscGFkczpuLG91dHB1dFBhZGRpbmc6dSxvdXRwdXRTaGFwZTpzLGRpbGF0aW9uczphLHN0cmlkZXM6bSxjYWNoZUtleTp4fSksZ30seWk9ZT0+e2xldCB0PVVyKGUpLHI9ZS5mb3JtYXQsbz1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG49ZS5kaWxhdGlvbnMscz1lLmdyb3VwLHU9ZS5rZXJuZWxTaGFwZSxkPWUucGFkcyxhPWUuc3RyaWRlcyxtPWUud0lzQ29uc3QoKSxnPWUub3V0cHV0UGFkZGluZyx4PWUub3V0cHV0U2hhcGU7cmV0dXJuIGllKHthdXRvUGFkOm8sZm9ybWF0OnIsZGlsYXRpb25zOm4sZ3JvdXA6cyxrZXJuZWxTaGFwZTp1LG91dHB1dFBhZGRpbmc6ZyxvdXRwdXRTaGFwZTp4LHBhZHM6ZCxzdHJpZGVzOmEsd0lzQ29uc3Q6bSwuLi50fSl9LE5sPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLG89ZVsxXS5kaW1zWzBdO2lmKHIhPT1vKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7bGV0IG49ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMl0uZGltc1swXSE9PW4pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgcz1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMucmVkdWNlKChnLHgpPT5nK3gsMCk+MCYmdC5kaWxhdGlvbnMubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzfURgKTtpZih0LnN0cmlkZXMucmVkdWNlKChnLHgpPT5nK3gsMCk+MCYmdC5zdHJpZGVzLmxlbmd0aCE9PXMpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3N9RGApO2lmKHQucGFkcy5yZWR1Y2UoKGcseCk9PmcreCwwKT4wJiZ0LnBhZHMubGVuZ3RoIT09cyoyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzKjJ9RGApO2lmKHQub3V0cHV0UGFkZGluZy5sZW5ndGghPT1zJiZ0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke3N9RGApO2lmKHQua2VybmVsU2hhcGUucmVkdWNlKChnLHgpPT5nK3gsMCk+MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZih0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PTAmJnQub3V0cHV0U2hhcGUubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3V0cHV0IHNoYXBlXCIpfSxVbD1bMiwzLDEsMF0sTGw9KGUsdCxyKT0+e2xldCBvPWdpKHIsdCksbj1yLmZvcm1hdD09PVwiTkhXQ1wiLHM9dC5sZW5ndGg9PT0zO2lmKG8uZ3JvdXAhPT0xKXtlLmNvbXB1dGUoTW4odCxvKSk7cmV0dXJufWxldCB1PW8ub3V0cHV0U2hhcGUsZD11W24/MToyXSxhPXVbbj8yOjNdLG09dVtuPzM6MV0sZz10WzFdLmRpbXNbMl0seD10WzFdLmRpbXNbM10sYj10WzBdLmRpbXNbbj8zOjFdLHc9bj9kKmE6bSx2PW4/bTpkKmEseT1nKngqYixTPSEwLEE9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoZ3QodFsxXSxVbCkse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPUEpO2xldCBSPVt0WzBdLEFdO3MmJighbiYmdFsyXS5kaW1zLmxlbmd0aD09PTE/Ui5wdXNoKHRbMl0ucmVzaGFwZShbdFsyXS5kaW1zWzBdLDEsMV0pKTpSLnB1c2godFsyXSkpLGUuY29tcHV0ZShmaShSLG8sdSx3LHYseSxzLFMpLHtpbnB1dHM6Un0pfSxGbD0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbz1bZS5pbnB1dHNbMF0ucmVzaGFwZShyP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07by5sZW5ndGg9PT0zJiZvLnB1c2goZS5pbnB1dHNbMl0pO2xldCBuPXQua2VybmVsU2hhcGU7KG4ubGVuZ3RoPT09MHx8blswXT09PTApJiYobj1bZS5pbnB1dHNbMV0uZGltc1syXV0pO2xldCBzPXQuZGlsYXRpb25zOyhzLmxlbmd0aD09PTB8fHNbMF09PT0wKSYmKHM9WzFdKTtsZXQgdT10LnN0cmlkZXM7KHUubGVuZ3RoPT09MHx8dVswXT09PTApJiYodT1bMV0pO2xldCBkPXQucGFkcztkLmxlbmd0aD09PTAmJihkPVswLDBdKSxkPVswLGRbMF0sMCxkWzFdXSx1PVsxXS5jb25jYXQodSkscz1bMV0uY29uY2F0KHMpLG49WzFdLmNvbmNhdChuKTtsZXQgYT1naSh7Li4udCxwYWRzOmQsc3RyaWRlczp1LGRpbGF0aW9uczpzLGtlcm5lbFNoYXBlOm59LG8pO2UuY29tcHV0ZShNbihvLGEsbT0+cj9bbVswXSxtWzJdLG1bM11dOlttWzBdLG1bMV0sbVszXV0pKX0sYmk9KGUsdCk9PntObChlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTM/RmwoZSx0KTpMbChlLGUuaW5wdXRzLHQpfX0pO3ZhciBCbixGcix2aSxIbCxqbCxrbixEbixLbCwkaSx4aSxTaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7Qm49XCJbYS16QS1aXXxcXFxcXFxcXC5cXFxcXFxcXC5cXFxcXFxcXC5cIixGcj1cIihcIitCbitcIikrXCIsdmk9XCJeXCIrRnIrXCIkXCIsSGw9XCIoXCIrRnIrXCIsKSpcIitGcixqbD1cIl5cIitIbCtcIiRcIixrbj1jbGFzc3tjb25zdHJ1Y3Rvcih0PS0xKXt0aGlzLnN5bWJvbFRvSW5kaWNlcz1uZXcgTWFwLHRoaXMuaW5wdXRJbmRleD10fWFkZFN5bWJvbCh0LHIpe2xldCBvPXRoaXMuc3ltYm9sVG9JbmRpY2VzLmdldCh0KTtvPT09dm9pZCAwP289W3JdOm8ucHVzaChyKSx0aGlzLnN5bWJvbFRvSW5kaWNlcy5zZXQodCxvKX19LERuPWNsYXNze2NvbnN0cnVjdG9yKHQscil7dGhpcy5lcXVhdGlvbj1yO3RoaXMuaGFzRWxsaXBzaXM9ITEsdGhpcy5zeW1ib2xUb0luZm89bmV3IE1hcCx0aGlzLmxocz1uZXcgQXJyYXksdGhpcy5vdXRwdXREaW1zPVtdO2xldFtvLG5dPXIuaW5jbHVkZXMoXCItPlwiKT9yLnNwbGl0KFwiLT5cIiwyKTpbcixcIlwiXTtpZighby5tYXRjaChSZWdFeHAoamwpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2lmKG8uc3BsaXQoXCIsXCIpLmZvckVhY2goKGQsYSk9PntsZXQgbT10W2FdLmRpbXMuc2xpY2UoKTtpZighZC5tYXRjaChSZWdFeHAodmkpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBnPXRoaXMucHJvY2Vzc1Rlcm0oZCwhMCxtLGEpO3RoaXMubGhzLnB1c2goZyl9KSxuPT09XCJcIiluKz1bLi4udGhpcy5zeW1ib2xUb0luZm8uZW50cmllcygpXS5maWx0ZXIoKFtkLGFdKT0+YS5jb3VudD09PTF8fGQ9PT1cIi4uLlwiKS5tYXAoKFtkXSk9PmQpLmpvaW4oXCJcIik7ZWxzZSBpZighbi5tYXRjaChSZWdFeHAoRnIpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIU1wiKTtuLm1hdGNoKFJlZ0V4cChCbixcImdcIikpPy5mb3JFYWNoKGQ9PntpZihkPT09XCIuLi5cIil0aGlzLm91dHB1dERpbXM9dGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7ZWxzZXtsZXQgYT10aGlzLnN5bWJvbFRvSW5mby5nZXQoZCk7aWYoYT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIUyBzeW1ib2xcIik7dGhpcy5vdXRwdXREaW1zLnB1c2goYS5kaW1WYWx1ZSl9fSksdGhpcy5yaHM9dGhpcy5wcm9jZXNzVGVybShuLCEwLHRoaXMub3V0cHV0RGltcyl9YWRkU3ltYm9sKHQscixvKXtsZXQgbj10aGlzLnN5bWJvbFRvSW5mby5nZXQodCk7aWYobiE9PXZvaWQgMCl7aWYobi5kaW1WYWx1ZSE9PXImJm4uY291bnQhPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbiBtaXNtYXRjaFwiKTtuLmNvdW50Kyssbi5pbnB1dEluZGljZXMucHVzaChvKX1lbHNlIG49e2NvdW50OjEsZGltVmFsdWU6cixpbnB1dEluZGljZXM6W29dfTt0aGlzLnN5bWJvbFRvSW5mby5zZXQodCxuKX1wcm9jZXNzVGVybSh0LHIsbyxuPS0xKXtsZXQgcz1vLmxlbmd0aCx1PSExLGQ9W10sYT0wO2lmKCF0Lm1hdGNoKFJlZ0V4cCh2aSkpJiYhciYmdCE9PVwiXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgbT10Lm1hdGNoKFJlZ0V4cChCbixcImdcIikpLGc9bmV3IGtuKG4pO3JldHVybiBtPy5mb3JFYWNoKCh4LGIpPT57aWYoeD09PVwiLi4uXCIpe2lmKHUpdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybVwiKTt1PSEwO2xldCB3PXMtbS5sZW5ndGgrMTtpZih3PDApdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihkPW8uc2xpY2UoYSxhK3cpLHRoaXMuaGFzRWxsaXBzaXMpe2lmKHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCE9PWQubGVuZ3RofHx0aGlzLmVsbGlwc2lzRGltcy50b1N0cmluZygpIT09ZC50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIGRpbWVuc2lvbnMgbWlzbWF0Y2hcIil9ZWxzZSBpZihyKXRoaXMuaGFzRWxsaXBzaXM9ITAsdGhpcy5lbGxpcHNpc0RpbXM9ZDtlbHNlIHRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFNcIik7Zm9yKGxldCB2PTA7djxkLmxlbmd0aDt2Kyspe2xldCB5PVN0cmluZy5mcm9tQ2hhckNvZGUoXCIwXCIuY2hhckNvZGVBdCgwKStiKTtnLmFkZFN5bWJvbCh5LGIrdiksdGhpcy5hZGRTeW1ib2woeSxvW2ErK10sbil9fWVsc2UgZy5hZGRTeW1ib2woeCxiKSx0aGlzLmFkZFN5bWJvbCh4LG9bYSsrXSxuKX0pLGd9fSxLbD0oZSx0KT0+e2xldCByPWVbMF0uZGF0YVR5cGUsbz1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgVz0wO1c8ZS5sZW5ndGg7KytXKW9bV109TChgaW5wdXQke1d9YCxyLGVbV10uZGltcyk7bGV0IG49dC5vdXRwdXREaW1zLHM9ay5zaXplKG4pLHU9WChcIm91dHB1dFwiLHIsbiksZD1bXSxhPUFycmF5LmZyb20odC5yaHMuc3ltYm9sVG9JbmRpY2VzLmtleXMoKSksbT1cInZhciBwcm9kID0gMS4wO1wiLGc9XCJ2YXIgc3VtID0gMC4wO1wiLHg9XCJzdW0gKz0gcHJvZDtcIixiPVtdLHc9W10sdj1bXSx5PVtdLFM9dC5zeW1ib2xUb0luZm8uc2l6ZT09PWEubGVuZ3RoO3Quc3ltYm9sVG9JbmZvLmZvckVhY2goKFcsTSk9PntpZihhLmluY2x1ZGVzKE0pKXtsZXQgRD1hLmluZGV4T2YoTSk7dC5saHMuZm9yRWFjaCgoXyx6KT0+e2lmKFcuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKHopKXtsZXQgRj1fLnN5bWJvbFRvSW5kaWNlcy5nZXQoTSk7aWYoRj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtGLmZvckVhY2gocT0+e2QucHVzaChgJHtvW3pdLmluZGljZXNTZXQoYGlucHV0JHt6fUluZGljZXNgLHEsdS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEQpKX1gKX0pfX0pfWVsc2UgdC5saHMuZm9yRWFjaCgoRCxfKT0+e2xldCB6PXQuc3ltYm9sVG9JbmZvLmdldChNKTtpZih6PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO2lmKHouaW5wdXRJbmRpY2VzLmluY2x1ZGVzKF8pKXtsZXQgRj1ELnN5bWJvbFRvSW5kaWNlcy5nZXQoTSk7aWYoRj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtGLmZvckVhY2gocT0+e2IucHVzaChgJHtvW19dLmluZGljZXNTZXQoYGlucHV0JHtffUluZGljZXNgLHEsYCR7TX1gKX1gKX0pLHkucHVzaChgcHJvZCAqPSAke29bX10uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7X31JbmRpY2VzYCl9O2ApfX0pLHcucHVzaChgZm9yKHZhciAke019OiB1MzIgPSAwOyAke019IDwgJHt0LnN5bWJvbFRvSW5mby5nZXQoTSk/LmRpbVZhbHVlfTsgJHtNfSsrKSB7YCksdi5wdXNoKFwifVwiKX0pO2xldCBBPVM/Wy4uLmQsYGxldCBzdW0gPSAke28ubWFwKChXLE0pPT5XLmdldEJ5SW5kaWNlcyhgaW5wdXQke019SW5kaWNlc2ApKS5qb2luKFwiICogXCIpfTtgXTpbLi4uZCxnLC4uLncsLi4uYixtLC4uLnkseCwuLi52XSxSPVc9PmBcXG4gICAgICAke1cuZGVjbGFyZVZhcmlhYmxlcyguLi5vLHUpfVxcblxcbiAgICAgICR7Vy5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7Vy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHMpfVxcbiAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke3Uub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAke28ubWFwKChNLEQpPT5gdmFyIGlucHV0JHtEfUluZGljZXM6ICR7b1tEXS50eXBlLmluZGljZXN9O2ApLmpvaW4oYFxcbmApfVxcbiAgICAgICAgJHtBLmpvaW4oYFxcbmApfTtcXG4gICAgICAgICR7dS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInN1bVwiKX07XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJFaW5zdW1cIixzaGFkZXJDYWNoZTp7aGludDp0LmVxdWF0aW9ufSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpSfX0sJGk9KGUsdCk9PntsZXQgcj1uZXcgRG4oZS5pbnB1dHMsdC5lcXVhdGlvbik7ZS5jb21wdXRlKEtsKGUuaW5wdXRzLHIpKX0seGk9ZT0+e2xldCB0PWUuZXF1YXRpb24ucmVwbGFjZSgvXFxcXHMrL2csXCJcIik7cmV0dXJuIGllKHtlcXVhdGlvbjp0fSl9fSk7dmFyIHFsLENpLFlsLFhsLEFpLElpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7cWw9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuXCIpO2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxvPXIubGVuZ3RoPHQubGVuZ3RoPzA6ci5sZW5ndGgtdC5sZW5ndGgsbj10Lmxlbmd0aDxyLmxlbmd0aD8wOnQubGVuZ3RoLXIubGVuZ3RoO2Zvcig7bzxyLmxlbmd0aCYmbjx0Lmxlbmd0aDsrK28sKytuKWlmKHJbb10hPT10W25dJiZyW29dIT09MSYmdFtuXSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIHNoYXBlIHRvIGJlIGJyb2FkY2FzdGFibGUgdG8gaW5wdXRcIil9LENpPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgtdC5sZW5ndGgsbz1bXTtmb3IobGV0IG49MDtuPHI7KytuKW8ucHVzaChlW25dKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbilvLnB1c2godFtuXT09PTE/ZVtuK3JdOnRbbl0pO3JldHVybiBvfSxZbD0oZSx0KT0+ZS5sZW5ndGg+dC5sZW5ndGg/Q2koZSx0KTpDaSh0LGUpLFhsPWU9PntsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbz1ZbCh0LHIpLG49ay5zaXplKG8pLHM9ZVswXS5kYXRhVHlwZSx1PUwoXCJpbnB1dFwiLHMsdCksZD1YKFwib3V0cHV0XCIscyxvKSxhPW09PmBcXG4gIGNvbnN0IGlucHV0U2hhcGUgPSAke3UuaW5kaWNlcyguLi50KX07XFxuICAke20uZGVjbGFyZVZhcmlhYmxlcyh1LGQpfVxcbiAgJHttLm1haW5TdGFydCgpfVxcbiAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobil9XFxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3UudHlwZS5pbmRpY2VzfTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XFxuICAgICAgaWYgKCR7dS5pbmRpY2VzR2V0KFwiaW5wdXRTaGFwZVwiLFwiaVwiKX0gPT0gMSkge1xcbiAgICAgICAgJHt1LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIiwwKX1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJHt1LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIixkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsYGkgKyAke28ubGVuZ3RoLXQubGVuZ3RofWApKX1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHUuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpKX1cXG4gIH1gO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7b31gfSxnZXRTaGFkZXJTb3VyY2U6YSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfX0pfX0sQWk9ZT0+e3FsKGUuaW5wdXRzKSxlLmNvbXB1dGUoWGwoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIEpsLFpsLEVpLFRpLE9pPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtKbD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpfSxabD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxvPWVbMV0uZGltcyxuPXIubGVuZ3RoLHM9ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxuKSx1PXIuc2xpY2UoMCk7dS5zcGxpY2UocywxLC4uLm8pO2xldCBkPXJbc10sYT1rLnNpemUodSksbT1MKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxnPUwoXCJpbnB1dEluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcykseD1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx1KSxiPSgpPT57bGV0IHY9by5sZW5ndGgseT1gdmFyIGluZGljZXNJbmRpY2VzICA9ICR7Zy50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBTPTA7Uzx2O1MrKyl5Kz1gJHt2PjE/YGluZGljZXNJbmRpY2VzWyR7U31dYDpcImluZGljZXNJbmRpY2VzXCJ9ID0gJHt1Lmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzWyR7cytTfV1gOlwib3V0cHV0SW5kaWNlc1wifTtgO3krPWBcXG4gICAgICAgIHZhciBpZHggPSAke2cuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc0luZGljZXNcIil9O1xcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcXG4gICAgICAgICAgaWR4ID0gaWR4ICsgJHtkfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBkYXRhSW5kaWNlcyA9ICR7bS50eXBlLmluZGljZXN9KDApO1xcbiAgICAgIGA7Zm9yKGxldCBTPTAsQT0wO1M8bjtTKyspUz09PXM/KHkrPWAke24+MT9gZGF0YUluZGljZXNbJHtTfV1gOlwiZGF0YUluZGljZXNcIn0gPSB1MzIoaWR4KTtgLEErPXYpOih5Kz1gJHtuPjE/YGRhdGFJbmRpY2VzWyR7U31dYDpcImRhdGFJbmRpY2VzXCJ9ID0gJHt1Lmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzWyR7QX1dYDpcIm91dHB1dEluZGljZXNcIn07YCxBKyspO3JldHVybiB5fSx3PXY9PmBcXG4gICAgICAke3YuZGVjbGFyZVZhcmlhYmxlcyhtLGcseCl9XFxuICAgICAgJHt2Lm1haW5TdGFydCgpfVxcbiAgICAgICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYSl9XFxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7eC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICR7YigpfTtcXG4gICAgICAgIGxldCB2YWx1ZSA9ICR7bS5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XFxuICAgICAgICAke3guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJHYXRoZXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfX0pLGdldFNoYWRlclNvdXJjZTp3fX0sRWk9ZT0+aWUoe2F4aXM6ZS5heGlzfSksVGk9KGUsdCk9PntsZXQgcj1lLmlucHV0cztKbChyKSxlLmNvbXB1dGUoWmwoZS5pbnB1dHMsdCkpfX0pO3ZhciBRbCxlZCxfaSxSaSxQaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7UWw9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxcbiAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgaW5wdXQgdGVuc29ycyBiZSBvZiBzYW1lIHJhbmsuYCl9LGVkPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG89ZVswXS5kYXRhVHlwZSxuPXIubGVuZ3RoLHM9ay5jb21wdXRlU3RyaWRlcyhyKSx1PWsuc2l6ZShyKSxkPWVbMV0uZGltcyxhPWVbMV0uZGF0YVR5cGUsbT1rLnNpemUoZCksZz1rLm5vcm1hbGl6ZUF4aXModC5heGlzLG4pLHg9cltnXSxiPWQuc2xpY2UoMCksdz1rLnNpemUoYiksdj1MKFwiaW5wdXRcIixvLHIpLHk9TChcImluZGljZXNcIixhLFttXSksUz1YKFwib3V0cHV0XCIsbyxiKSxBPVI9PmBcXG4gICAgICBjb25zdCBpbnB1dFN0cmlkZXMgPSBhcnJheTx1MzIsICR7cy5sZW5ndGh9Pigke3MubWFwKFc9PmAke1d9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgJHtSLmRlY2xhcmVWYXJpYWJsZXModix5LFMpfVxcbiAgICAgICR7Ui5tYWluU3RhcnQoKX1cXG4gICAgICAke1IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh3KX1cXG5cXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgICB2YXIgaWR4ID0gJHt5LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgaWYgKGlkeCA8IDApIHtcXG4gICAgICAgIGlkeCA9IGlkeCArICR7eH07XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzcmNPZmZzZXQgPSB1MzIoMCk7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XFxuICAgICAgICBpZiAoaSA9PSAke2d9KSB7XFxuICAgICAgICAgIHNyY09mZnNldCArPSAgdTMyKGlkeCkgKiBpbnB1dFN0cmlkZXNbaV07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzcmNPZmZzZXQgKz0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCJpXCIpfSAqIGlucHV0U3RyaWRlc1tpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gU2hvdWxkIG5ldmVyIGhpdCB0aGlzIHdpdGggdmFsaWQgdmFsdWVzIGluIGluZGljZXNcXG4gICAgICAvLyBUaGlzIGlzIGEgZ3VhcmQgYWdhaW5zdCBtYWxpY2lvdXMgZGF0YSBpbiB0aGUgaW5kaWNlcyBpbnB1dFxcbiAgICAgIGlmIChzcmNPZmZzZXQgPCAwIHx8IHNyY09mZnNldCA+PSAke3V9KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W3NyY09mZnNldF07XFxuICB9YDtyZXR1cm57bmFtZTpcIkdhdGhlckVsZW1lbnRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpiLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh3LzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6QX19LF9pPWU9PmllKHtheGlzOmUuYXhpc30pLFJpPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7UWwociksZS5jb21wdXRlKGVkKGUuaW5wdXRzLHQpKX19KTt2YXIgdGQscmQsbmQsTWksQmksa2k9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO3RkPWU9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IG51bWJlci5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzJdLmRpbXMubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT1lWzFdLmRhdGFUeXBlfHxlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfSxyZD0oZSx0LHIpPT57aWYoci5sZW5ndGg9PT0wKXJldHVyblwiMHVcIjtsZXQgbz1yLmxlbmd0aD09PTEmJmUhPT0xfHxyLmxlbmd0aD09PTImJnJbMF0hPT1lLG49cltyLmxlbmd0aC0xXSE9PXQscz1cIjB1XCI7cmV0dXJuIG98fChzKz1gKyBtICogJHtyW3IubGVuZ3RoLTFdfXVgKSxufHwocys9XCIrblwiKSxzfSxuZD0oZSx0KT0+e2xldCByPWVbMF0uZGltcy5zbGljZSgpLG89ZVsxXS5kaW1zLnNsaWNlKCksW24scyx1XT1fci5nZXRTaGFwZU9mR2VtbVJlc3VsdChyLHQudHJhbnNBLG8sdC50cmFuc0IsZS5sZW5ndGg9PT0zP2VbMl0uZGltczp2b2lkIDApLGQ9W24sc107aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgYT1rLnNpemUoZCksbT1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj9tPVwidmFsdWUgKz0gYVtrICogTSArIG1dICogYltuICogSyArIGtdO1wiOnQudHJhbnNBJiYhdC50cmFuc0I/bT1cInZhbHVlICs9IGFbayAqIE0gKyBtXSAqIGJbayAqIE4gKyBuXTtcIjohdC50cmFuc0EmJnQudHJhbnNCP209XCJ2YWx1ZSArPSBhW20gKiBLICsga10gKiBiW24gKiBLICsga107XCI6IXQudHJhbnNBJiYhdC50cmFuc0ImJihtPVwidmFsdWUgKz0gYVttICogSyArIGtdICogYltrICogTiArIG5dO1wiKTtsZXQgZz1NZShlWzBdLmRhdGFUeXBlKSx4PXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSBhbHBoYTtcIixiPWUubGVuZ3RoPT09Mz9gdmFsdWUgKz0gYmV0YSAqIGNbJHtyZChuLHMsZVsyXS5kaW1zKX1dO2A6XCJcIix3PVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBhIDogYXJyYXk8JHtnfT47YCxgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBiIDogYXJyYXk8JHtnfT47YF07ZS5sZW5ndGg9PT0zJiZ3LnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYyA6IGFycmF5PCR7Z30+O2ApO2xldCB2PXk9PmBcXG4gIGNvbnN0IE06IHUzMiA9ICR7bn11O1xcbiAgY29uc3QgTjogdTMyID0gJHtzfXU7XFxuICBjb25zdCBLOiB1MzIgPSAke3V9dTtcXG4gIGNvbnN0IGFscGhhID0gJHtnfSgke3QuYWxwaGF9KTtcXG4gIGNvbnN0IGJldGEgPSAke2d9KCR7dC5iZXRhfSk7XFxuXFxuICAke3cuam9pbihgXFxuYCl9XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtlLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2d9PjtcXG5cXG4gICR7eS5tYWluU3RhcnQoKX1cXG4gICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYSl9XFxuXFxuICAgIGxldCBtID0gZ2xvYmFsX2lkLnggLyBOO1xcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54ICUgTjtcXG5cXG4gICAgdmFyIHZhbHVlID0gJHtnfSgwKTtcXG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8JHt1fXU7IGsrKykge1xcbiAgICAgICR7bX1cXG4gICAgfVxcblxcbiAgICAke3h9XFxuICAgICR7Yn1cXG4gICAgb3V0cHV0W2dsb2JhbF9pZC54XSA9IHZhbHVlO1xcblxcbiAgfWA7cmV0dXJue25hbWU6XCJHZW1tXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6dn19LE1pPShlLHQpPT57dGQoZS5pbnB1dHMpLGUuY29tcHV0ZShuZChlLmlucHV0cyx0KSl9LEJpPWU9PmllKGUpfSk7dmFyIG9kLGFkLGlkLHNkLERpLFdpLHppPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7UGUoKTt2ZSgpO29kPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCJ9LGFkPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG89cixuPTIscz1rLnNpemVUb0RpbWVuc2lvbihyLG4pLHU9ay5zaXplRnJvbURpbWVuc2lvbihyLG4pLGQ9clsxXSxhPUwoXCJ4XCIsZVswXS5kYXRhVHlwZSxbclswXSxyWzFdLHVdKSxtPUwoXCJzY2FsZVwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxnPUwoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMpLHg9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsW3JbMF0sclsxXSx1XSksYj1bYSxtLGcseF0sdz1hLnR5cGUudmFsdWUsdj02NCx5PVM9PmBcXG5cXG4gIGNvbnN0IEM6IHUzMiA9ICR7ZH07XFxuICBjb25zdCBub3JtU2l6ZTogdTMyID0gJHt1fTtcXG4gIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7dC5lcHNpbG9ufTtcXG4gIHZhcjx3b3JrZ3JvdXA+IG1lYW5TaGFyZWQgOiAke3d9O1xcbiAgdmFyPHdvcmtncm91cD4gc3F1YXJlZE5vcm1TaGFyZWQgOiAke3d9O1xcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwU2hhcmVkIDogYXJyYXk8JHt3fSwgJHt2fT47XFxuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gJHt2fXU7XFxuICAke1MuZGVjbGFyZVZhcmlhYmxlcyguLi5iKX1cXG4gICR7Uy5tYWluU3RhcnQodil9XFxuICAgIGxldCBub3JtID0gZ2xvYmFsX2lkeCAvIHdvcmtncm91cFNpemU7XFxuICAgIGxldCBiYXRjaCA9IG5vcm0gLyBDO1xcbiAgICBsZXQgY2hhbm5lbCA9IG5vcm0gJSBDO1xcbiAgICBsZXQgbG9jYWxJbmRleCA9IGxvY2FsX2lkLng7XFxuXFxuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxcbiAgICB2YXIgaW5pdGlhbDogJHt3fSA9IDA7XFxuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgbm9ybVNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsICsgJHthLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfTtcXG4gICAgfVxcbiAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSBpbml0aWFsO1xcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWVhbiBvZiBjdXJyZW50IGNoYW5uZWwgZGF0YS5cXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcXG4gICAgICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSArIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4ICsgY3VyclNpemVdO1xcbiAgICAgIH1cXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgIH1cXG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xcbiAgICAgIG1lYW5TaGFyZWQgPSB3b3JrZ3JvdXBTaGFyZWRbMF0gLyAke3d9KG5vcm1TaXplKTtcXG4gICAgfVxcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgIC8vIHJlaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5LlxcbiAgICBpbml0aWFsID0gMDtcXG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCBub3JtU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XFxuICAgICAgbGV0IGRldmlhdGlvbiA9ICAke2EuZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9IC0gbWVhblNoYXJlZDtcXG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArIGRldmlhdGlvbiAqIGRldmlhdGlvbjtcXG4gICAgfVxcbiAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSBpbml0aWFsO1xcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3VtIG9mIHNxdWFyZSBvZiBkZXZpYXRpb24gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXFxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcXG4gICAgICBpZiAobG9jYWxJbmRleCA8IGN1cnJTaXplKSB7XFxuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcXG4gICAgICB9XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICB9XFxuICAgIGlmIChsb2NhbEluZGV4ID09IDApIHtcXG4gICAgICBzcXVhcmVkTm9ybVNoYXJlZCA9IHdvcmtncm91cFNoYXJlZFswXTtcXG4gICAgfVxcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgIGxldCBpbnZTdGREZXYgPSAxIC8gc3FydChzcXVhcmVkTm9ybVNoYXJlZCAvICR7d30obm9ybVNpemUpICsgZXBzaWxvbik7XFxuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiAke20uZ2V0QnlPZmZzZXQoXCJjaGFubmVsXCIpfTtcXG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9ICR7Zy5nZXRCeU9mZnNldChcImNoYW5uZWxcIil9IC0gbWVhblNoYXJlZCAqIGNoYW5uZWxTY2FsZTtcXG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCBub3JtU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XFxuICAgICAgbGV0IHZhbHVlID0gJHthLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSAqIGNoYW5uZWxTY2FsZSArIGNoYW5uZWxTaGlmdDtcXG4gICAgICAke3guc2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIixcInZhbHVlXCIpfTtcXG4gICAgfVxcbiAgfWA7cmV0dXJuey4uLm9kLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpzfX0pLGdldFNoYWRlclNvdXJjZTp5fX0saWQ9KGUsdCxyLG8sbixzLHUsZCk9PntsZXQgYT1sdCh1KSxtPUwoXCJpbnB1dFwiLHQuZGF0YVR5cGUsdC5kaW1zLGEpLGc9TChcInNjYWxlXCIsci5kYXRhVHlwZSxyLmRpbXMsYSkseD1MKFwiYmlhc1wiLG8uZGF0YVR5cGUsby5kaW1zLGEpLGI9NjQsdz1hPT09MT9cInZlYzJmXCI6YG1hdDJ4JHthfWZgLHY9YT09PTE/XCJmMzJcIjpgdmVjJHthfWZgLHk9KEQsXyk9PmAke3d9KCR7RH0sICR7X30pYCxTPW4qdS9hLEE9TWF0aC5jZWlsKHMvYiksUj1EPT5gXFxuICBjb25zdCBIOiB1MzIgPSAke3N9O1xcbiAgY29uc3QgQzogdTMyID0gJHt1L2F9O1xcbiAgY29uc3QgaW1hZ2VTaXplOiB1MzIgPSAke3MqdS9hfTtcXG5cXG4gICR7RC5kZWNsYXJlVmFyaWFibGVzKG0pfVxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3d9PjtcXG5cXG4gICR7RC5tYWluU3RhcnQoYil9XFxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gJHtifSAvIEM7XFxuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IChnbG9iYWxfaWR4IC8gJHtifSkgJSBDO1xcbiAgICBsZXQgd2dJZCA9IGdsb2JhbF9pZHggJSAke2J9O1xcbiAgICBsZXQgd2dPZmZzZXQgPSB3Z0lkICogJHtBfTtcXG4gICAgaWYgKHdnT2Zmc2V0ID49IEgpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsZXQgd2dNYXggPSBtaW4od2dPZmZzZXQgKyAke0F9LCBIKTtcXG5cXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIGltYWdlU2l6ZSArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xcbiAgICB2YXIgc3VtID0gJHtxZShcImYzMlwiLGEpfTtcXG4gICAgdmFyIHNxdWFyZWRTdW0gPSAke3FlKFwiZjMyXCIsYSl9O1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSB3Z09mZnNldDsgaSA8IHdnTWF4OyBpKyspIHtcXG4gICAgICAgIGxldCB2YWx1ZSA9ICR7dn0oaW5wdXRbb2Zmc2V0ICsgaSAqIENdKTtcXG4gICAgICAgIHN1bSArPSB2YWx1ZTtcXG4gICAgICAgIHNxdWFyZWRTdW0gKz0gdmFsdWUgKiB2YWx1ZTtcXG4gICAgfVxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3koXCJzdW1cIixcInNxdWFyZWRTdW1cIil9O1xcbiAgfWAsVz1lLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlTWVhblwiLHNoYWRlckNhY2hlOntoaW50OkpTT04uc3RyaW5naWZ5KHtjb21wb25lbnRzOmEsbixoOnMsYzp1fSl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6W24sdSxiLDJdLGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4Om4qdS9hfX0pLGdldFNoYWRlclNvdXJjZTpSfSx7aW5wdXRzOlt0XSxvdXRwdXRzOlstMV19KVswXSxNPUQ9PmBcXG4gIGNvbnN0IEg6IHUzMiA9ICR7c307XFxuICBjb25zdCBDOiB1MzIgPSAke3UvYX07XFxuICBjb25zdCBpbWFnZVNpemU6IHUzMiA9ICR7Yip1L2F9O1xcbiAgY29uc3QgZXBzaWxvbjogZjMyID0gJHtkfTtcXG5cXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke3d9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGUgOiBhcnJheTwke2cudHlwZS5zdG9yYWdlfT47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJpYXMgOiBhcnJheTwke3gudHlwZS5zdG9yYWdlfT47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7d30+O1xcblxcbiAgJHtELm1haW5TdGFydCgpfVxcbiAgICAke0QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhTKX1cXG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyBDO1xcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSBnbG9iYWxfaWR4ICUgQztcXG5cXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIGltYWdlU2l6ZTtcXG4gICAgdmFyIHN1bSA9ICR7cWUoXCJmMzJcIixhKX07XFxuICAgIHZhciBzcXVhcmVkU3VtID0gJHtxZShcImYzMlwiLGEpfTtcXG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7Yn07IGkrKykge1xcbiAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRbb2Zmc2V0ICsgaSArIGN1cnJlbnRDaGFubmVsTnVtYmVyICogJHtifV07XFxuICAgICAgICBzdW0gKz0gdmFsdWVbMF07XFxuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlWzFdO1xcbiAgICB9XFxuICAgIHN1bSA9IHN1bSAvIGYzMihIKTtcXG4gICAgc3F1YXJlZFN1bSA9IHNxdWFyZWRTdW0gLyBmMzIoSCk7XFxuICAgIGxldCBpbnZTdGREZXYgPSAxIC8gc3FydChzcXVhcmVkU3VtIC0gc3VtICogc3VtICsgZXBzaWxvbik7XFxuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiAke3Z9KHNjYWxlW2N1cnJlbnRDaGFubmVsTnVtYmVyXSk7XFxuICAgIGxldCBjaGFubmVsU2hpZnQgPSAke3Z9KGJpYXNbY3VycmVudENoYW5uZWxOdW1iZXJdKSAtIHN1bSAqIGNoYW5uZWxTY2FsZTtcXG5cXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt5KFwiY2hhbm5lbFNjYWxlXCIsXCJjaGFubmVsU2hpZnRcIil9O1xcbiAgfWA7cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OkpTT04uc3RyaW5naWZ5KHtjb21wb25lbnRzOmEsbixoOnMsYzp1LGVwc2lsb246ZH0pfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOltuLHUsMl0sZGF0YVR5cGU6MX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKFMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpNfSx7aW5wdXRzOltXLHIsb10sb3V0cHV0czpbLTFdfSlbMF19LHNkPShlLHQscik9PntsZXQgbz10WzBdLmRpbXMsbj1vLHM9b1swXSx1PW9bby5sZW5ndGgtMV0sZD1rLnNpemVGcm9tRGltZW5zaW9uKG8sMSkvdSxhPWx0KHUpLG09ay5zaXplKG4pL2EsZz1MKFwiaW5wdXRcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyxhKSx4PVgoXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLG4sYSksYj1NZSh0WzBdLmRhdGFUeXBlKSx3PWE9PT0xP1widmVjMmZcIjpgbWF0Mngke2F9ZmAsdj1hPT09MT9iOmB2ZWMke2F9PCR7Yn0+YCx5PWlkKGUsdFswXSx0WzFdLHRbMl0scyxkLHUsci5lcHNpbG9uKSxTPUE9PmBcXG4gIGNvbnN0IEg6IHUzMiA9ICR7ZH07XFxuICBjb25zdCBDOiB1MzIgPSAke3UvYX07XFxuXFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHtnLnR5cGUuc3RvcmFnZX0+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZUlucHV0IDogYXJyYXk8JHt3fT47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7eC50eXBlLnN0b3JhZ2V9PjtcXG5cXG4gICR7QS5tYWluU3RhcnQoKX1cXG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAoQyAqIEgpO1xcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSBnbG9iYWxfaWR4ICUgQztcXG5cXG4gICAgbGV0IHNjYWxlT2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogQyArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xcbiAgICBsZXQgc2NhbGUgPSBzY2FsZUlucHV0W3NjYWxlT2Zmc2V0XTtcXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke3Z9KHNjYWxlWzBdKSwgJHt2fShzY2FsZVsxXSkpO1xcbiAgfWA7ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ci5jYWNoZUtleX1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfX0pLGdldFNoYWRlclNvdXJjZTpTfSx7aW5wdXRzOlt0WzBdLHldfSl9LERpPWU9PmllKHtlcHNpbG9uOmUuZXBzaWxvbixmb3JtYXQ6ZS5mb3JtYXR9KSxXaT0oZSx0KT0+e3QuZm9ybWF0PT09XCJOSFdDXCI/c2QoZSxlLmlucHV0cyx0KTplLmNvbXB1dGUoYWQoZS5pbnB1dHMsdCkpfX0pO3ZhciB1ZCxsZCxWaSxHaSxOaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO1BlKCk7dmUoKTt1ZD1lPT57aWYoIWV8fGUubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLlwiKX0sbGQ9KGUsdCxyKT0+e2xldCBvPWVbMF0uZGltcyxuPWVbMV0scz1lWzJdLHU9byxkPWsubm9ybWFsaXplQXhpcyh0LmF4aXMsby5sZW5ndGgpLGE9ay5zaXplVG9EaW1lbnNpb24obyxkKSxtPWsuc2l6ZUZyb21EaW1lbnNpb24obyxkKSxnPWsuc2l6ZShuLmRpbXMpLHg9cz9rLnNpemUocy5kaW1zKTowO2lmKGchPT1tfHxzJiZ4IT09bSl0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke219LlxcbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxcbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke2d9IGFuZCBiaWFzIHNpemUgb2YgJHt4fWApO2xldCBiPVtdO2ZvcihsZXQgTT0wO008by5sZW5ndGg7KytNKU08ZD9iLnB1c2gob1tNXSk6Yi5wdXNoKDEpO2xldCB3PWx0KG0pLHY9TWUoZVswXS5kYXRhVHlwZSkseT1bTChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyx3KSxMKFwic2NhbGVcIixuLmRhdGFUeXBlLG4uZGltcyx3KV07cyYmeS5wdXNoKEwoXCJiaWFzXCIscy5kYXRhVHlwZSxzLmRpbXMsdykpLHkucHVzaChYKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx1LHcpKTtsZXQgUz1yPjEsQT1yPjI7UyYmeS5wdXNoKFgoXCJtZWFuRGF0YU91dHB1dFwiLDEsYikpLEEmJnkucHVzaChYKFwiaW52U3RkT3V0cHV0XCIsMSxiKSk7bGV0IFI9TT0+YFxcbiAgY29uc3Qgbm9ybVNpemU6IGYzMiA9ICR7bX07XFxuICBjb25zdCBub3JtU2l6ZVZlY3Rvcml6ZWQ6IHUzMiA9ICR7bS93fTtcXG4gIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7dC5lcHNpbG9ufTtcXG5cXG4gICR7TS5kZWNsYXJlVmFyaWFibGVzKC4uLnkpfVxcbiAgJHtNLm1haW5TdGFydCgpfVxcbiAgICAke00uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhhKX1cXG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiBub3JtU2l6ZVZlY3Rvcml6ZWQ7XFxuICAgIHZhciBtZWFuVmVjdG9yID0gJHtxZShcImYzMlwiLHcpfTtcXG4gICAgdmFyIG1lYW5TcXVhcmVWZWN0b3IgPSAke3FlKFwiZjMyXCIsdyl9O1xcblxcbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IG5vcm1TaXplVmVjdG9yaXplZDsgaCsrKSB7XFxuICAgICAgbGV0IHZhbHVlID0gJHtBdCh2LHcsXCJ4W2ggKyBvZmZzZXRdXCIpfTtcXG4gICAgICBtZWFuVmVjdG9yICs9IHZhbHVlO1xcbiAgICAgIG1lYW5TcXVhcmVWZWN0b3IgKz0gdmFsdWUgKiB2YWx1ZTtcXG4gICAgfVxcbiAgICBsZXQgbWVhbiA9ICR7aHQoXCJtZWFuVmVjdG9yXCIsdyl9IC8gbm9ybVNpemU7XFxuICAgIGxldCBtZWFuU3F1YXJlID0gc3FydCgke2h0KFwibWVhblNxdWFyZVZlY3RvclwiLHcpfSBcXG4gICAgICAvIG5vcm1TaXplIC0gbWVhbiAqIG1lYW4gKyBlcHNpbG9uKTtcXG5cXG4gICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8IG5vcm1TaXplVmVjdG9yaXplZDsgaisrKSB7XFxuICAgICAgbGV0IGYzMmlucHV0ID0gJHtBdCh2LHcsXCJ4W2ogKyBvZmZzZXRdXCIpfTtcXG4gICAgICBsZXQgZjMyc2NhbGUgPSAke0F0KHYsdyxcInNjYWxlW2pdXCIpfTtcXG4gICAgICBvdXRwdXRbaiArIG9mZnNldF0gPSAke3lbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0IC0gbWVhbikgLyBtZWFuU3F1YXJlICogZjMyc2NhbGVcXG4gICAgICAgICR7cz9gKyAke0F0KHYsdyxcImJpYXNbal1cIil9YDpcIlwifVxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgJHtTP1wibWVhbkRhdGFPdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuXCI6XCJcIn07XFxuICAgICR7QT9cImludlN0ZE91dHB1dFtnbG9iYWxfaWR4XSA9IDEgLyBtZWFuU3F1YXJlXCI6XCJcIn07XFxuICB9YCxXPVt7ZGltczp1LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gUyYmVy5wdXNoKHtkaW1zOmIsZGF0YVR5cGU6MX0pLEEmJlcucHVzaCh7ZGltczpiLGRhdGFUeXBlOjF9KSx7bmFtZTpcIkxheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7cn18JHtlLmxlbmd0aH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VyxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6Un19LFZpPWU9PmllKHtheGlzOmUuYXhpcyxlcHNpbG9uOmUuZXBzaWxvbn0pLEdpPShlLHQpPT57dWQoZS5pbnB1dHMpLGUuY29tcHV0ZShsZChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgZGQsVWksTGk9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7aXIoKTtkZD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltc1tlWzBdLmRpbXMubGVuZ3RoLTFdIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMl0pdGhyb3cgbmV3IEVycm9yKFwic2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC5cIil9LFVpPWU9PntkZChlLmlucHV0cyk7bGV0IHQ9UWUuY2FsY1NoYXBlKGUuaW5wdXRzWzBdLmRpbXMsZS5pbnB1dHNbMV0uZGltcywhMCk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2UuY29tcHV0ZShMcihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwiLGFjdGl2YXRpb25DYWNoZUtleTpcIlwifSx0KSl9fSk7dmFyIGNkLHBkLGZkLG1kLGhkLGdkLHlkLGJkLHdkLEZpLEhpLGppPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7UGUoKTt2ZSgpO2NkPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gZmV3IGlucHV0c1wiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQuXCIpO2lmKGUubGVuZ3RoPj0yKXtsZXQgdD1lWzBdLmRpbXMubGVuZ3RoKjI9PT1lWzFdLmRpbXNbMF07aWYoZS5sZW5ndGg9PT00JiYodD1lWzNdLmRpbXNbMF0qMj09PWVbMV0uZGltc1swXSksIXQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhZHMgc2hvdWxkIGJlIGEgMUQgdGVuc29yIG9mIHNoYXBlIFsyICogaW5wdXRfcmFua10gb3IgWzIgKiBudW1fYXhlc10uXCIpfX0scGQ9KGUsdCxyLG8sbixzLHUpPT57bGV0IGQ9ci5sZW5ndGgsYT1cIlwiO2ZvcihsZXQgbT1kLTE7bT49MDstLW0pYSs9YFxcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbSl9KSAtICR7blttXX07XFxuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGsgPj0gJHtyW21dfSkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG9mZnNldCArPSBrICogJHtvW21dfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgICAgICB2YWx1ZSA9ICR7c30oJHt1fSk7XFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XFxuICAgICAgICAgICAgdmFyIGsgPSAwO1xcbiAgICAgICAgICAgICR7YX1cXG4gICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcXG4gICAgICAgICAgfVxcbiAgICAgIGB9LGZkPShlLHQscixvLG4pPT57bGV0IHM9ci5sZW5ndGgsdT1cIlwiO2ZvcihsZXQgZD1zLTE7ZD49MDstLWQpdSs9YFxcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGQpfSkgLSAke25bZF19O1xcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcXG4gICAgICAgICAgICAgICAgICBrID0gLWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9ICR7MioocltkXS0xKX07XFxuICAgICAgICAgICAgICAgICAgayA9IGsgJSBfMm5fMTtcXG4gICAgICAgICAgICAgICAgICBpZihrID49ICR7cltkXX0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogJHtvW2RdfTtcXG4gICAgICAgICAgICBgO3JldHVybmBcXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xcbiAgICAgICAgICAgICAgJHt1fVxcbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XFxuICAgICAgICAgIGB9LG1kPShlLHQscixvLG4pPT57bGV0IHM9ci5sZW5ndGgsdT1cIlwiO2ZvcihsZXQgZD1zLTE7ZD49MDstLWQpdSs9YFxcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGQpfSkgLSAke25bZF19O1xcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcXG4gICAgICAgICAgICAgICAgICBrID0gMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoayA+PSAke3JbZF19KSB7XFxuICAgICAgICAgICAgICAgICAgayA9ICR7cltkXS0xfTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7b1tkXX07XFxuICAgICAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgICAgICAgICR7dX1cXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xcbiAgICAgICAgICBgfSxoZD0oZSx0LHIsbyxuKT0+e2xldCBzPXIubGVuZ3RoLHU9XCJcIjtmb3IobGV0IGQ9cy0xO2Q+PTA7LS1kKXUrPWBcXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixkKX0pIC0gJHtuW2RdfTtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSAge1xcbiAgICAgICAgICAgICAgICAgIGsgKz0gJHtyW2RdfTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoayA+PSAke3JbZF19KSB7XFxuICAgICAgICAgICAgICAgICAgayAtPSAke3JbZF19O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogJHtvW2RdfTtcXG4gICAgICAgICAgICBgO3JldHVybmBcXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xcbiAgICAgICAgICAgICAgJHt1fVxcbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XFxuICAgICAgICAgIGB9LGdkPShlLHQscixvLG4scyk9Pntzd2l0Y2gobi5tb2RlKXtjYXNlIDA6cmV0dXJuIHBkKGUsdCxyLG8sbi5wYWRzLHMsbi52YWx1ZSk7Y2FzZSAxOnJldHVybiBmZChlLHQscixvLG4ucGFkcyk7Y2FzZSAyOnJldHVybiBtZChlLHQscixvLG4ucGFkcyk7Y2FzZSAzOnJldHVybiBoZChlLHQscixvLG4ucGFkcyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVcIil9fSx5ZD0oZSx0LHIsbyk9PntsZXQgbj10WzBdLmRpbXMscz1rLnBhZFNoYXBlKG4uc2xpY2UoKSxyLnBhZHMpLHU9ay5zaXplKHMpLGQ9ay5jb21wdXRlU3RyaWRlcyhuKSxhPVgoXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLHMpLG09TChcInhcIix0WzBdLmRhdGFUeXBlLG4pLGc9Z2QoYSxzLG4sZCxyLG8pO3JldHVybmBcXG4gICAgICAgICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKG0sYSl9XFxuICAgICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cXG5cXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcblxcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtvfSgwKTtcXG4gICAgICAgICAgICAgICR7Z31cXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xcbiAgICAgICAgICB9YH0sYmQ9KGUsdCk9PntsZXQgcj1rLnBhZFNoYXBlKGVbMF0uZGltcy5zbGljZSgpLHQucGFkcyk7cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGsuc2l6ZShyKS82NCl9fSksZ2V0U2hhZGVyU291cmNlOm89PnlkKG8sZSx0LFwiZjMyXCIpfX0sd2Q9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxvPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTowLG49ZVswXS5kaW1zLmxlbmd0aCxzPW5ldyBJbnQzMkFycmF5KDIqbikuZmlsbCgwKTtpZihlLmxlbmd0aD49NCl7bGV0IGQ9ZVszXS5nZXRCaWdJbnQ2NEFycmF5KCk7Zm9yKGxldCBhPTA7YTxkLmxlbmd0aDthKyspc1tOdW1iZXIoZFthXSldPU51bWJlcihyW2FdKSxzW051bWJlcihkW2FdKStuXT1OdW1iZXIoclthK2QubGVuZ3RoXSl9ZWxzZSByLmZvckVhY2goKGQsYSk9PnNbTnVtYmVyKGEpXT1OdW1iZXIoZCkpO2xldCB1PVtdO3JldHVybiBzLmZvckVhY2goZD0+dS5wdXNoKGQpKSxpZSh7bW9kZTp0Lm1vZGUsdmFsdWU6byxwYWRzOnV9KX1lbHNlIHJldHVybiB0fSxGaT0oZSx0KT0+e2NkKGUuaW5wdXRzKTtsZXQgcj13ZChlLmlucHV0cyx0KTtlLmNvbXB1dGUoYmQoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sSGk9ZT0+e2xldCB0PWUubW9kZSxyPWUudmFsdWUsbz1lLnBhZHM7cmV0dXJuIGllKHttb2RlOnQsdmFsdWU6cixwYWRzOm99KX19KTt2YXIgSHIsS2kscWksWWksWGksSmksWmksUWksZXMsdHMscnMsbnMsb3MsYXMsaXMsc3M9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO0hyPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyBzdXBwb3J0cyAxLUQgb3IgMi1EIGlucHV0cyBvbmx5IGZvciBub3cuXCIpfSxLaT0oZSx0LHIpPT57bGV0IG89dC5mb3JtYXQ9PT1cIk5IV0NcIixuPWUuZGltcy5zbGljZSgpO28mJm4uc3BsaWNlKDEsMCxuLnBvcCgpKTtsZXQgcz1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGlsYXRpb25zXCIpLHU9dC5rZXJuZWxTaGFwZS5zbGljZSgpLGQ9dC5zdHJpZGVzLnNsaWNlKCksYT1zP3QuZGlsYXRpb25zLnNsaWNlKCk6W10sbT10LnBhZHMuc2xpY2UoKTtDdC5hZGp1c3RQb29sQXR0cmlidXRlcyhyLG4sdSxkLGEsbSk7bGV0IGc9Q3QuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShyLG4sZCxhLHUsbSx0LmF1dG9QYWQpLHg9T2JqZWN0LmFzc2lnbih7fSx0KTtzP09iamVjdC5hc3NpZ24oeCx7a2VybmVsU2hhcGU6dSxzdHJpZGVzOmQscGFkczptLGRpbGF0aW9uczphLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKHgse2tlcm5lbFNoYXBlOnUsc3RyaWRlczpkLHBhZHM6bSxjYWNoZUtleTp0LmNhY2hlS2V5fSk7bGV0IGI9Zy5zbGljZSgpO3JldHVybiBiLnB1c2goYi5zcGxpY2UoMSwxKVswXSksW3gsbz9iOmddfSxxaT0oZSx0LHIsbyxuLHMsdSxkKT0+e2xldCBhPW4uZm9ybWF0PT09XCJOSFdDXCIsbT1yLGc9dC50eXBlLnZhbHVlLHg9bS5sZW5ndGgsYj1rLnNpemUobyksdz1YKFwib3V0cHV0XCIsdC50eXBlLnRlbnNvcixvKTtpZihuLmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IHY9bi5rZXJuZWxTaGFwZVtuLmtlcm5lbFNoYXBlLmxlbmd0aC0xXSx5PW4uc3RyaWRlc1tuLnN0cmlkZXMubGVuZ3RoLTFdLFM9bi5wYWRzW24ucGFkcy5sZW5ndGgvMi0xXSxBPW4ucGFkc1tuLnBhZHMubGVuZ3RoLTFdLFI9eC0oYT8yOjEpLFc9XCJcIixNPVwiXCIsRD1cIlwiO2lmKFMrQSE9PTA/Vz1gXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHt2fXU7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Un1dID0gaW5kaWNlc1ske1J9XSAqICR7eX0gLSAke1N9ICsgaTtcXG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtSfV0gPCAwIHx8IHhJbmRpY2VzWyR7Un1dID49ICR7bVtSXX0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICAgJHtzfVxcbiAgICAgICAgICAgICAgICB9YDpXPWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke3Z9dTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtSfV0gPSBpbmRpY2VzWyR7Un1dICogJHt5fSAtICR7U30gKyBpO1xcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICAgJHtzfVxcbiAgICAgICAgICAgICAgICB9YCxuLmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCB6PW4ua2VybmVsU2hhcGVbbi5rZXJuZWxTaGFwZS5sZW5ndGgtMl0sRj1uLnN0cmlkZXNbbi5zdHJpZGVzLmxlbmd0aC0yXSxxPW4ucGFkc1tuLnBhZHMubGVuZ3RoLzItMl0sbGU9bi5wYWRzW24ucGFkcy5sZW5ndGgtMl0sQj14LShhPzM6MiksSz1tW0JdO3ErbGUhPT0wP009YFxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8ICR7en11OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske0J9XSA9IGluZGljZXNbJHtCfV0gKiAke0Z9IC0gJHtxfSArIGo7XFxuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7Qn1dIDwgMCB8fCB4SW5kaWNlc1ske0J9XSA+PSAke0t9KSB7XFxuICAgICAgICAgICAgICAgICAgICBwYWQrPSAke3Z9O1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgYDpNPWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCAke3p9dTsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtCfV0gPSBpbmRpY2VzWyR7Qn1dICogJHtGfSAtICR7cX0gKyBqO1xcbiAgICAgICAgICAgICAgICBgLEQ9YFxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGB9cmV0dXJuYFxcbiAgICAgICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKHQsdyl9XFxuXFxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYil9XFxuXFxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgICAgICAgICAgIHZhciB2YWx1ZTogJHtnfSA9ICR7Z30oJHtkfSk7XFxuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcXG4gICAgICAgICAgICAgICR7TX1cXG4gICAgICAgICAgICAgICR7V31cXG4gICAgICAgICAgICAgICR7RH1cXG4gICAgICAgICAgICAgICR7dX1cXG5cXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1gfWVsc2V7aWYoYSl0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0IHY9ay5zaXplKG4ua2VybmVsU2hhcGUpLHk9ay5jb21wdXRlU3RyaWRlcyhuLmtlcm5lbFNoYXBlKSxTPXkubGVuZ3RoLEE9bi5wYWRzLmxlbmd0aCxSPW4ucGFkcy5yZWR1Y2UoKEQsXyk9PkQrXyksVz1cIlwiO3JldHVybiBSP1c9YFxcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gaW5wdXREaW1zW2pdKSB7XFxuICAgICAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XFxuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICR7c31cXG4gICAgICAgICAgICAgIH1gOlc9YFxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICR7c31cXG4gICAgICAgICAgICBgLGBcXG4gICAgICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyh0LHcpfVxcblxcbiAgICAgICAgICAgIGNvbnN0IHBhZHMgPSBhcnJheTx1MzIsICR7QX0+KCR7bi5wYWRzLm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RGltcyA9IGFycmF5PHUzMiwgJHt4fT4oJHttLm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbFN0cmlkZXMgPSBhcnJheTx1MzIsICR7U30+KCR7eS5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgICAgICBjb25zdCBzdHJpZGVzID0gYXJyYXk8dTMyLCAke1N9Pigke24uc3RyaWRlcy5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcXG5cXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhiKX1cXG5cXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgICAgICAgbGV0IHhJbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcblxcbiAgICAgICAgICAgICAgdmFyIG9mZnNldHM6IGFycmF5PHUzMiwgJHtTfT47XFxuXFxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke3cudHlwZS52YWx1ZX0oJHtkfSk7XFxuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcXG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke3Z9dTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke1MtMX11OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gb2Zmc2V0IC8ga2VybmVsU3RyaWRlc1tqXTtcXG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqIGtlcm5lbFN0cmlkZXNbal07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske1MtMX1dID0gb2Zmc2V0O1xcblxcbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHt4LVN9dTsgaiA8ICR7eH11OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke3gtU311XVxcbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3gtU311XSAtIHBhZHNbaiAtIDJ1XTtcXG4gICAgICAgICAgICAgICAgICAke1d9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAke3V9XFxuXFxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9YH19LFlpPWU9Pih7Zm9ybWF0OmUuZm9ybWF0LGF1dG9QYWQ6W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxjZWlsTW9kZTplLmNlaWxfbW9kZSxrZXJuZWxTaGFwZTplLmtlcm5lbF9zaGFwZSxzdHJpZGVzOmUuc3RyaWRlcyxwYWRzOmUucGFkc30pLFhpPShlLHQscixvKT0+e2xldFtuLHNdPUtpKHQsbyxyKSx1PWsuc2l6ZShuLmtlcm5lbFNoYXBlKSxkPUwoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMpLGE9ZC50eXBlLnZhbHVlLG09XCJ2YWx1ZSArPSB4X3ZhbDtcIixnPVwiXCI7cmV0dXJuIG4uY291bnRJbmNsdWRlUGFkP2crPWB2YWx1ZSAvPSAke2F9KCR7dX0pO2A6Zys9YHZhbHVlIC89ICR7YX0oJHt1fSAtIHBhZCk7YCx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50Om8uY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoay5zaXplKHMpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6eD0+cWkoeCxkLHQuZGltcyxzLG4sbSxnLFwiMC4wXCIpfX0sSmk9ZT0+e2xldCB0PWUuY291bnRfaW5jbHVkZV9wYWQhPT0wLHI9WWkoZSk7aWYoci5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtyZXR1cm4gaWUoe2NvdW50SW5jbHVkZVBhZDp0LC4uLnJ9KX0sWmk9KGUsdCk9PntIcihlLmlucHV0cyksZS5jb21wdXRlKFhpKFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LFFpPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXSxjYWNoZUtleTpcIlwifSxlcz1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLlFpLGNhY2hlS2V5OnR9fSx0cz0oZSx0KT0+e0hyKGUuaW5wdXRzKSxlLmNvbXB1dGUoWGkoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX0scnM9KGUsdCxyLG8pPT57bGV0W24sc109S2kodCxvLHIpLHU9YFxcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XFxuICAgIGAsZD1cIlwiLGE9TChcInhcIix0LmRhdGFUeXBlLHQuZGltcyk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpvLmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGsuc2l6ZShzKS82NCl9fSksZ2V0U2hhZGVyU291cmNlOm09PnFpKG0sYSx0LmRpbXMscyxuLHUsZCxcIi0xZTVcIil9fSxucz0oZSx0KT0+e0hyKGUuaW5wdXRzKSxlLmNvbXB1dGUocnMoXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxvcz1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLHI9ZS5kaWxhdGlvbnMsbz1ZaShlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihvLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7cmV0dXJuIGllKHtzdG9yYWdlT3JkZXI6dCxkaWxhdGlvbnM6ciwuLi5vfSl9LGFzPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4uUWksY2FjaGVLZXk6dH19LGlzPShlLHQpPT57SHIoZS5pbnB1dHMpLGUuY29tcHV0ZShycyhcIkdsb2JhbE1heFBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9fSk7dmFyIGpyPUgoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciB1cz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7anIoKX0pO3ZhciBscyxkcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bHM9XCIxLjE3LjAtZGV2LjIwMjMxMTAzLTE0MzlkYTM2ZmVcIn0pO3ZhciBjcyxXbixwcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZHMoKTtjcz1cIndhcm5pbmdcIixXbj17d2FzbTp7fSx3ZWJnbDp7fSx3ZWJncHU6e30sdmVyc2lvbnM6e2NvbW1vbjpsc30sc2V0IGxvZ0xldmVsKGUpe2lmKGUhPT12b2lkIDApe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wifHxbXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihlKT09PS0xKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApO2NzPWV9fSxnZXQgbG9nTGV2ZWwoKXtyZXR1cm4gY3N9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoV24sXCJsb2dMZXZlbFwiLHtlbnVtZXJhYmxlOiEwfSl9KTt2YXIgZnMsbXM9SCgoKT0+e1widXNlIHN0cmljdFwiO3BzKCk7ZnM9V259KTt2YXIgaHM9SCgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGdzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtLcigpfSk7dmFyIGJzPUgoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciB3cz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7S3IoKX0pO3ZhciBLcj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aHMoKTtncygpO2JzKCk7d3MoKX0pO3ZhciBxcj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7S3IoKX0pO3ZhciB2cz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7anIoKTtxcigpfSk7dmFyICRzPUgoKCk9PntcInVzZSBzdHJpY3RcIjt2cygpfSk7dmFyIHhzPUgoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBTcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7anIoKTtxcigpfSk7dmFyIENzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtTcygpfSk7dmFyIEFzPUgoKCk9PntcInVzZSBzdHJpY3RcIjt1cygpO21zKCk7JHMoKTtxcigpO3hzKCk7Q3MoKX0pO3ZhciBTZCxDZCxJcyxFcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7QXMoKTtEZSgpO3ZlKCk7U2Q9KGUsdCxyKT0+e2xldCBvPWU9PT10LG49ZTx0JiZyPDAscz1lPnQmJnI+MDtpZihvfHxufHxzKXRocm93IG5ldyBFcnJvcihcIlJhbmdlIHRoZXNlIGlucHV0c1xcJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LENkPShlLHQscixvKT0+e2xldCBuPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9yKSkscz1bbl0sdT1uLGQ9WChcIm91dHB1dFwiLG8scyksYT1kLnR5cGUuc3RvcmFnZSxtPWc9PmBcXG4gICAgICAgICR7Zy5kZWNsYXJlVmFyaWFibGVzKGQpfVxcbiAgICAgICAgJHtnLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XFxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2F9KCR7ZX0pICsgJHthfShnbG9iYWxfaWR4KSAqICR7YX0oJHtyfSk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSYW5nZVwiLHNoYWRlckNhY2hlOntoaW50OltlLHQscl0ubWFwKGc9PmcudG9TdHJpbmcoKSkuam9pbihcIl9cIil9LGdldFNoYWRlclNvdXJjZTptLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwodS82NCl9fSl9fSxJcz1lPT57bGV0IHQ9MCxyPTAsbz0wO2UuaW5wdXRzWzBdLmRhdGFUeXBlPT09Nj8odD1lLmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRJbnQzMkFycmF5KClbMF0sbz1lLmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF0pOmUuaW5wdXRzWzBdLmRhdGFUeXBlPT09MSYmKHQ9ZS5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxvPWUuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdKSxmcy53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJlNkKHQscixvKSxlLmNvbXB1dGUoQ2QodCxyLG8sZS5pbnB1dHNbMF0uZGF0YVR5cGUpLHtpbnB1dHM6W119KX19KTt2YXIgQWQsSWQsRWQsVGQsT2QsX2QsUmQsUGQsTWQsQmQsa2QsRGQsV2QsemQsVmQsVHMsT3MsX3M9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO0FkPShlLHQpPT57aWYoZS5ldmVyeShyPT5yPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGxpbmVhciBtb2RlXCIpfWVsc2UgaWYodC5tb2RlPT09XCJjdWJpY1wiJiYhKGUubGVuZ3RoPT09Mnx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBjdWJpYyBtb2RlXCIpfX0sSWQ9KGUsdCxyKT0+e3QuZXZlcnkobj0+bj49MCYmbjxyfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgYXhlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmUgYW5kIGxlc3MgdGhhbiByYW5rXCIpfSkpO2xldCBvPW5ldyBBcnJheShyKS5maWxsKDEpO3JldHVybiB0LmZvckVhY2goKG4scyk9Pm9bbl09ZVtzXSksb30sRWQ9KGUsdCxyLG8sbixzKT0+e2xldFt1LGQsYV09cj4xMD9bMSwyLDNdOlstMSxlLmxlbmd0aD4xPzE6LTEsLTFdLG09ZVswXS5kaW1zLmxlbmd0aDtpZih1PjAmJmUubGVuZ3RoPnUmJmVbdV0uZGltcy5sZW5ndGg+MCllW3VdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goZz0+cy5wdXNoKGcpKTtlbHNlIGlmKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBSb0kgaW5wdXQgdG8gYmUgc3BlY2lmaWVkIHdoZW4gY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgaXMgdGZDcm9wQW5kUmVzaXplXCIpO2lmKGQ+MCYmZS5sZW5ndGg+ZCYmZVtkXS5kaW1zLmxlbmd0aD4wKXtpZihlW2RdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goZz0+by5wdXNoKGcpKSxvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09bSYmcj49MTgmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO0FkKG8sdCksdC5heGVzLmxlbmd0aD4wJiZJZChvLHQuYXhlcyxtKS5mb3JFYWNoKChnLHgpPT5vW3hdPWcpfWlmKGE+MCYmZS5sZW5ndGg+YSYmKGVbYV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goZz0+bi5wdXNoKE51bWJlcihnKSkpLG4ubGVuZ3RoIT09bXx8cj49MTgmJm4ubGVuZ3RoPT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYoby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcXCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWRcXCcpO2lmKG4ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXFwnUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZFxcJyl9aWYodHlwZW9mIG88XCJ1XCImJnR5cGVvZiBuPFwidVwiJiZvLmxlbmd0aD4wJiZuLmxlbmd0aD5tKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBvbmx5IG9mIHNjYWxlcyBvciBzaXplcyB0byBiZSBzcGVjaWZpZWRcIil9LFRkPWU9PlwiZm4gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKHhSZXNpemVkOiBmMzIsIHhTY2FsZTogZjMyLCBsZW5ndGhSZXNpemVkOiBmMzIsICAgIGxlbmd0aE9yaWdpbmFsOiBmMzIsIHJvaVN0YXJ0OiBmMzIsIHJvaUVuZDogZjMyKSAtPiBmMzIgeyBcIisoKCk9Pntzd2l0Y2goZSl7Y2FzZVwiYXN5bW1ldHJpY1wiOnJldHVyblwicmV0dXJuIHhSZXNpemVkIC8geFNjYWxlO1wiO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVyblwiaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGUgLSAwLjU7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCI6cmV0dXJuXCJyZXR1cm4gKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZTtcIjtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuXCJpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4geFJlc2l6ZWQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSAvIChsZW5ndGhSZXNpemVkIC0gMSk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIjpyZXR1cm5cImlmIChsZW5ndGhSZXNpemVkID4gMSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb2lTdGFydCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpICsgICAgICAgICAgICAgICAgICAgICAgICAgICAoeFJlc2l6ZWQgKiAocm9pRW5kIC0gcm9pU3RhcnQpICogKGxlbmd0aE9yaWdpbmFsIC0gMSkpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKHJvaVN0YXJ0ICsgcm9pRW5kKSAqIGYzMihsZW5ndGhPcmlnaW5hbCAtIDEpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwiaGFsZl9waXhlbF9zeW1tZXRyaWNcIjpyZXR1cm5bXCJjb25zdCBvdXRwdXRXaWR0aCA9IHhTY2FsZSAqIGxlbmd0aFJlc2l6ZWQ7XCIsXCJjb25zdCBhZGp1c3RtZW50ID0gbGVuZ3RoUmVzaXplZCAvIG91dHB1dFdpZHRoO1wiLFwiY29uc3QgY2VudGVyID0gbGVuZ3RoT3JpZ2luYWwgLyAyO1wiLFwiY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcIixcInJldHVybiBvZmZzZXQgKyAoKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZSkgLSAwLjU7XCJdLmpvaW4oYFxcbmApO2Nhc2VcImhhbGZfcGl4ZWxcIjpyZXR1cm5cInJldHVybiAoKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZSkgLSAwLjU7XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixPZD0oZSx0KT0+XCJmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiBmMzIsIGlzRG93blNhbXBsZTogYm9vbCkgLT4gZjMyIHtcIisoKCk9Pntzd2l0Y2goZSl7Y2FzZVwicm91bmRfcHJlZmVyX2NlaWxcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICB9XCI7Y2FzZVwiZmxvb3JcIjpyZXR1cm5cInJldHVybiBmbG9vcih4T3JpZ2luYWwpO1wiO2Nhc2VcImNlaWxcIjpyZXR1cm5cInJldHVybiBjZWlsKHhPcmlnaW5hbCk7XCI7Y2FzZVwicm91bmRfcHJlZmVyX2Zsb29yXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInNpbXBsZVwiOmRlZmF1bHQ6aWYodDwxMSlyZXR1cm5cImlmIChpc0Rvd25TYW1wbGUpICAgICAgICAgICAgICAgICAgICAgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgICAgICAgICAgICAgICAgICAgICB9XCI7dGhyb3cgbmV3IEVycm9yKGBOZWFyZXN0IG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixfZD0oZSx0LHIpPT57bGV0IG89bmV3IEFycmF5KHIpLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyKS5maWxsKDEpKSxuPWUubGVuZ3RoPT09MD9vOmUuc2xpY2UoKTtyZXR1cm4gdC5sZW5ndGg+MD8odC5mb3JFYWNoKChzLHUpPT57b1tzXT1uW3VdLG9bdStyXT1uW3QubGVuZ3RoK3VdfSksbyk6bn0sUmQ9KGUsdCxyLG8pPT57bGV0IG49W107aWYoci5sZW5ndGg+MClpZihvLmxlbmd0aD4wKXtpZihlLmZvckVhY2gocz0+bi5wdXNoKHMpKSxNYXRoLm1heCguLi5vKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzIGlzIG91dCBvZiBib3VuZFwiKTtvLmZvckVhY2goKHMsdSk9Pm5bc109clt1XSl9ZWxzZSByLmZvckVhY2gocz0+bi5wdXNoKHMpKTtlbHNle2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy5cIik7bj1lLm1hcCgocyx1KT0+TWF0aC5yb3VuZChzKnRbdV0pKX1yZXR1cm4gbn0sUGQ9KGUsdCxyLG8pPT57bGV0IG49KCgpPT57c3dpdGNoKG8ua2VlcEFzcGVjdFJhdGlvUG9saWN5KXtjYXNlXCJub3RfbGFyZ2VyXCI6cmV0dXJuIG8uYXhlcy5sZW5ndGg+MD9NYXRoLm1pbiguLi5vLmF4ZXMubWFwKHU9PnJbdV0pLE51bWJlci5NQVhfVkFMVUUpOk1hdGgubWluKC4uLnIsTnVtYmVyLk1BWF9WQUxVRSk7Y2FzZVwibm90X3NtYWxsZXJcIjpyZXR1cm4gby5heGVzLmxlbmd0aD4wP01hdGgubWF4KC4uLm8uYXhlcy5tYXAodT0+clt1XSksTnVtYmVyLk1JTl9WQUxVRSk6TWF0aC5tYXgoLi4ucixOdW1iZXIuTUlOX1ZBTFVFKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgS2VlcCBhc3BlY3QgcmF0aW8gcG9saWN5ICR7by5rZWVwQXNwZWN0UmF0aW9Qb2xpY3l9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpO3IuZmlsbCgxLDAsci5sZW5ndGgpO2xldCBzPWUuc2xpY2UoKTtyZXR1cm4gby5heGVzLmxlbmd0aD4wPyhvLmF4ZXMuZm9yRWFjaCh1PT5yW3VdPW4pLG8uYXhlcy5mb3JFYWNoKHU9PnNbdV09TWF0aC5yb3VuZChlW3VdKnJbdV0pKSk6KHIuZmlsbChuLDAsci5sZW5ndGgpLHMuZm9yRWFjaCgodSxkKT0+c1tkXT1NYXRoLnJvdW5kKHUqcltkXSkpKSxzfSxNZD0oZSx0LHIsbyxuKT0+YFxcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8ZjMyLCAke3IubGVuZ3RofT4ge1xcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7dC5sZW5ndGh9Pigke3QubWFwKHM9PmAke3N9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhcnJheTx1MzIsICR7ci5sZW5ndGh9Pigke3IubWFwKHM9PmAke3N9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgY29uc3Qgc2NhbGVzID0gYXJyYXk8ZjMyLCAke28ubGVuZ3RofT4oJHtvLm1hcChzPT5gJHtzfWZgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgIGNvbnN0IHJvaSA9IGFycmF5PGYzMiwgJHtuLmxlbmd0aH0+KCR7bi5tYXAocz0+YCR7c31mYCkuam9pbihcIixcIil9KTtcXG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzOiBhcnJheTxmMzIsICR7ci5sZW5ndGh9PjtcXG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XFxuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke3IubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpcIm91dHB1dEluZGljZXNbaV1cIn07XFxuICAgICAgICBpZiAoc2NhbGVzW2ldID09IDEuMCkge1xcbiAgICAgICAgICBvcmlnaW5hbEluZGljZXNbaV0gPSBmMzIob3V0cHV0SW5kZXgpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgb3JpZ2luYWxJbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGYzMihvdXRwdXRJbmRleCksIHNjYWxlc1tpXSxcXG4gICAgICAgICAgICAgICAgZjMyKG91dHB1dFNoYXBlW2ldKSwgZjMyKGlucHV0U2hhcGVbaV0pLCByb2lbaV0sIHJvaVtpICsgJHt0Lmxlbmd0aH1dKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9yaWdpbmFsSW5kaWNlcztcXG4gICAgfWAsQmQ9KGUsdCxyLG8sbixzLHUpPT5gXFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XFxuICAgICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3IubGVuZ3RofT4oJHtyLm1hcChkPT5gJHtkfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhcnJheTx1MzIsICR7by5sZW5ndGh9Pigke28ubWFwKGQ9PmAke2R9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBzY2FsZXMgPSBhcnJheTxmMzIsICR7bi5sZW5ndGh9Pigke24ubWFwKGQ9PmAke2R9ZmApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCByb2kgPSBhcnJheTxmMzIsICR7cy5sZW5ndGh9Pigke3MubWFwKGQ9PmAke2R9ZmApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcXG4gICAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7by5sZW5ndGh9OyBpKyspIHtcXG4gICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHtvLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6XCJvdXRwdXRJbmRpY2VzW2ldXCJ9O1xcbiAgICAgICAgICB2YXIgaW5wdXRJbmRleDogdTMyO1xcbiAgICAgICAgICBpZiAoc2NhbGVzW2ldID09IDEuMCkge1xcbiAgICAgICAgICAgIGlucHV0SW5kZXggPSBvdXRwdXRJbmRleDtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGYzMihvdXRwdXRJbmRleCksIHNjYWxlc1tpXSxcXG4gICAgICAgICAgICAgICAgICAgIGYzMihvdXRwdXRTaGFwZVtpXSksIGYzMihpbnB1dFNoYXBlW2ldKSwgcm9pW2ldLCByb2lbaSArICR7ci5sZW5ndGh9XSk7XFxuICAgICAgICAgICAgaWYgKCEke3V9IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCBmMzIoaW5wdXRTaGFwZVtpXSkpKSB7XFxuICAgICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gMDtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxfaWR4ID4gKGYzMihpbnB1dFNoYXBlW2ldKSAtIDEpKSB7XFxuICAgICAgICAgICAgICAgIGlucHV0SW5kZXggPSBpbnB1dFNoYXBlW2ldIC0gMTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlucHV0SW5kZXggPSB1MzIoZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKG9yaWdpbmFsX2lkeCwgc2NhbGVzW2ldIDwgMSkpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gdTMyKG9yaWdpbmFsX2lkeCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsXCJpbnB1dEluZGV4XCIpfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGlucHV0SW5kaWNlcztcXG4gICAgfWAsa2Q9KGUsdCk9PmBcXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHt0Lmxlbmd0aH0+KCR7dC5tYXAocj0+YCR7cn11YCkuam9pbihcIixcIil9KTtcXG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XFxuICAgICAgICB2YXIgaW5wdXRJbmRleCA9ICR7dC5sZW5ndGg9PT0xP1wiaW5wdXRJbmRpY2VzXCI6XCJpbnB1dEluZGljZXNbaV1cIn07XFxuICAgICAgICBpZiAoaW5wdXRJbmRleCA8IDAgfHwgaW5wdXRJbmRleCA+PSBpbnB1dFNoYXBlW2ldKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1gLERkPShlLHQscixvLG4scyx1KT0+e2xldFtkLGEsbSxnXT1yLmxlbmd0aD09PTI/Wy0xLDAsMSwtMV06blsxXT09PTE/WzAsMiwzLDFdOlswLDEsMiwzXTtyZXR1cm5gXFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+IGYzMiB7XFxuICAgICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XFxuICAgICAgaW5wdXRJbmRpY2VzWyR7YX1dID0gbWF4KDAsIG1pbihyb3csICR7clthXX0gLSAxKSk7XFxuICAgICAgaW5wdXRJbmRpY2VzWyR7bX1dID0gbWF4KDAsIG1pbihjb2wsICR7clttXX0gLSAxKSk7XFxuICAgICAgaWYgKCR7ci5sZW5ndGh9ID4gMikge1xcbiAgICAgICAgaW5wdXRJbmRpY2VzWyR7Z31dID0gY2hhbm5lbDtcXG4gICAgICAgIGlucHV0SW5kaWNlc1ske2R9XSA9IGJhdGNoO1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIGlucHV0WyR7ZS5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNcIil9XTtcXG4gICAgfVxcblxcbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+IGYzMiB7XFxuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXMpO1xcbiAgICAgIHZhciByb3c6ZjMyID0gb3JpZ2luYWxJbmRpY2VzWyR7YX1dO1xcbiAgICAgIHZhciBjb2w6ZjMyID0gb3JpZ2luYWxJbmRpY2VzWyR7bX1dO1xcbiAgICAgIGlmICgke3N9ICYmIChyb3cgPCAwIHx8IHJvdyA+ICgke3JbYV19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAke3JbbV19IC0gMSkpIHtcXG4gICAgICAgIHJldHVybiAke3V9O1xcbiAgICAgIH1cXG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtyW2FdfSAtIDEpKTtcXG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtyW21dfSAtIDEpKTtcXG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XFxuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XFxuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcXG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gMDtcXG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9IDA7XFxuICAgICAgaWYgKCR7ci5sZW5ndGg+Mn0pIHtcXG4gICAgICAgIGNoYW5uZWwgPSB1MzIob3JpZ2luYWxJbmRpY2VzWyR7Z31dKTtcXG4gICAgICAgIGJhdGNoID0gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2R9XSk7XFxuICAgICAgfVxcbiAgICAgIHZhciB4MTE6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xcbiAgICAgIHZhciB4MTI6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xcbiAgICAgIHZhciB4MjE6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xcbiAgICAgIHZhciB4MjI6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xcbiAgICAgIHZhciBkeDE6IGYzMiA9IHJvdyAtIGYzMihyb3cxKTtcXG4gICAgICB2YXIgZHgyOiBmMzIgPSBmMzIocm93MiApIC0gcm93O1xcbiAgICAgIHZhciBkeTEgPSBjb2wgLSBmMzIoY29sMSk7XFxuICAgICAgdmFyIGR5MiA9IGYzMihjb2wyKSAtIGNvbDtcXG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XFxuICAgIH1gfSxXZD0oZSx0LHIsbyxuLHMsdSxkLGEsbSk9PntsZXRbZyx4XT1yLmxlbmd0aD09PTI/WzAsMV06blsxXT09PTE/WzIsM106WzEsMl0sYj13PT57bGV0IHY9dz09PWc/XCJyb3dcIjpcImNvbFwiO3JldHVybmBcXG4gICAgICBmbiAke3Z9Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30sIG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiBmMzIge1xcbiAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHtvLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6YG91dHB1dEluZGljZXNbJHt3fV1gfTtcXG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogZjMyID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGYzMihvdXRwdXRJbmRleCksICR7blt3XX0sXFxuICAgICAgICBmMzIoJHtvW3ddfSksIGYzMigke3Jbd119KSwgJHtzW3ddfSwgJHtzW3ddfSArICR7ci5sZW5ndGh9KTtcXG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiBmMzIgPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcXG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xcblxcbiAgICAgICAgaWYgKCR7ZH0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke3Jbd119IC0gMSkpKSB7XFxuICAgICAgICAgIHJldHVybiAke2F9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PGYzMiwgND4gPSBhcnJheTxmMzIsIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xcbiAgICAgICAgICB2YXIgJHt2fTogZjMyID0gb3JpZ2luYWxJZHggKyBmMzIoaSk7XFxuICAgICAgICAgIGlmICgke3Z9IDwgMCB8fCAke3Z9ID49ICR7clt3XX0pIHtcXG4gICAgICAgICAgICBpZiAoJHttfSkge1xcbiAgICAgICAgICAgICAgY29lZnNbaSArIDFdID0gMC4wO1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICgke2R9KSB7XFxuICAgICAgICAgICAgICByZXR1cm4gJHthfTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgJHt2fSA9IG1heCgwLCBtaW4oJHt2fSwgJHtyW3ddfSAtIDEpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlc0NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRJbmRpY2VzO1xcbiAgICAgICAgICBpbnB1dEluZGljZXNDb3B5WyR7d31dID0gdTMyKCR7dn0pO1xcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7dz09PWc/YGlucHV0WyR7ZS5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNDb3B5XCIpfV07YDpgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRJbmRpY2VzQ29weSwgb3V0cHV0SW5kaWNlcyk7YH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XFxuICAgICAgfWB9O3JldHVybmBcXG4gICAgJHtiKGcpfTtcXG4gICAgJHtiKHgpfTtcXG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6IGYzMikgLT4gYXJyYXk8ZjMyLCA0PiB7XFxuICAgIHZhciBhYnNTID0gYWJzKHMpO1xcbiAgICB2YXIgY29lZmZzOiBhcnJheTxmMzIsIDQ+ID0gYXJyYXk8ZjMyLCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICB2YXIgb25lTWludXNBYnNTOiBmMzIgPSAxLjAgLSBhYnNTO1xcbiAgICB2YXIgdHdvTWludXNBYnNTOiBmMzIgPSAyLjAgLSBhYnNTO1xcbiAgICB2YXIgb25lUGx1c0Fic1M6IGYzMiA9IDEuMCArIGFic1M7XFxuICAgIGNvZWZmc1swXSA9ICgoJHt1fSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7dX0pICogb25lUGx1c0Fic1MgKyA4ICogJHt1fSkgKiBvbmVQbHVzQWJzUyAtIDQgKiAke3V9O1xcbiAgICBjb2VmZnNbMV0gPSAoKCR7dX0gKyAyKSAqIGFic1MgLSAoJHt1fSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcXG4gICAgY29lZmZzWzJdID0gKCgke3V9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHt1fSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XFxuICAgIGNvZWZmc1szXSA9ICgoJHt1fSAqIHR3b01pbnVzQWJzUyAtIDUgKiAke3V9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke3V9KSAqIHR3b01pbnVzQWJzUyAtIDQgKiAke3V9O1xcbiAgICByZXR1cm4gY29lZmZzO1xcbiAgfVxcblxcbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8ZjMyLCA0PiwgY29lZnM6IGFycmF5PGYzMiwgND4pIC0+IGYzMiB7XFxuICAgIHZhciBjb2Vmc1N1bTogZjMyID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XFxuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcXG4gIH1cXG5cXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiBmMzIge1xcbiAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSA9IG91dHB1dEluZGljZXM7XFxuICAgIHJldHVybiBjb2xDdWJpY0ludGVycG9sYXRpb24oaW5wdXRJbmRpY2VzLCBvdXRwdXRJbmRpY2VzKTtcXG4gIH1cXG4gICAgYH0semQ9KGUsdCxyLG8sbixzKT0+e2xldCB1PWUuZGltcyxkPV9kKHMsdC5heGVzLHUubGVuZ3RoKSxhPVJkKHUsbyxuLHQuYXhlcyksbT1vLnNsaWNlKCk7by5sZW5ndGg9PT0wJiYobT11Lm1hcCgoUyxBKT0+Uz09PTA/MTphW0FdL1MpLHQua2VlcEFzcGVjdFJhdGlvUG9saWN5IT09XCJzdHJldGNoXCImJihhPVBkKHUsYSxtLHQpKSk7bGV0IGc9WChcIm91dHB1dFwiLGUuZGF0YVR5cGUsYSkseD1MKFwiaW5wdXRcIixlLmRhdGFUeXBlLHUpLGI9ay5zaXplKGEpLHc9dS5sZW5ndGg9PT1hLmxlbmd0aCYmdS5ldmVyeSgoUyxBKT0+Uz09PWFbQV0pLHY9dC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIseT1TPT5gXFxuICAgICAgJHtUZCh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKX07XFxuICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxcbiAgICAgICAgICAgICAgJHtrZCh4LHUpfTtcXG4gICAgICAgICAgICAgICR7T2QodC5uZWFyZXN0TW9kZSxyKX07XFxuICAgICAgICAgICAgICAke0JkKHgsZyx1LGEsbSxkLHYpfTtcXG4gICAgICAgICAgICAgIGA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYFxcbiAgICAgICAgICAgICAgJHtNZChnLHUsYSxtLGQpfTtcXG4gICAgICAgICAgICAgICR7RGQoeCxnLHUsYSxtLHYsdC5leHRyYXBvbGF0aW9uVmFsdWUpfTtcXG4gICAgICAgICAgICAgIGA7Y2FzZVwiY3ViaWNcIjpyZXR1cm5gXFxuICAgICAgICAgICAgJHtXZCh4LGcsdSxhLG0sZCx0LmN1YmljQ29lZmZBLHYsdC5leHRyYXBvbGF0aW9uVmFsdWUsdC5leGNsdWRlT3V0c2lkZSl9O1xcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIkludmFsaWQgcmVzaXplIG1vZGVcIil9fSkoKX07XFxuICAgICAgJHtTLmRlY2xhcmVWYXJpYWJsZXMoeCxnKX1cXG4gICAgICAke1MubWFpblN0YXJ0KCl9XFxuICAgICAgICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhiKX1cXG4gICAgICAgIGlmICgke3d9KSB7XFxuICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke2cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7eC50eXBlLmluZGljZXN9O1xcbiAgICAgICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gaW5wdXRJbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlcyk7XFxuICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0SW5kaWNlcykpIHtcXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0WyR7eC5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt0LmV4dHJhcG9sYXRpb25WYWx1ZX07XFxuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwibGluZWFyXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlcyk7XCI7Y2FzZVwiY3ViaWNcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXMpO1wiO2RlZmF1bHQ6dGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2l6ZSBtb2RlOiAke3QubW9kZX1gKX19KSgpfTtcXG4gICAgICAgIH1cXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlJlc2l6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7cn18JHttLmxlbmd0aD4wP206XCJcIn18JHtuLmxlbmd0aD4wP246XCJcIn1gfSxnZXRTaGFkZXJTb3VyY2U6eSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGIvNjQpfX0pfX0sVmQ9ZT0+e2xldCB0PWUuY3VzdG9tRGF0YUJ1ZmZlcjtyZXR1cm4gbmV3IFVpbnQzMkFycmF5KHQsdC5ieXRlT2Zmc2V0LDEpWzBdfSxUcz0oZSx0KT0+e2xldCByPVtdLG89W10sbj1bXSxzPVZkKGUpO0VkKGUuaW5wdXRzLHQscyxyLG8sbiksZS5jb21wdXRlKHpkKGUuaW5wdXRzWzBdLHQscyxyLG8sbikse2lucHV0czpbMF19KX0sT3M9ZT0+e2xldCB0PWUuYW50aWFsaWFzLHI9ZS5heGVzLG89ZS5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSxuPWUuY3ViaWNDb2VmZkEscz1lLmV4Y2x1ZGVPdXRzaWRlIT09MCx1PWUuZXh0cmFwb2xhdGlvblZhbHVlLGQ9ZS5rZWVwQXNwZWN0UmF0aW9Qb2xpY3ksYT1lLm1vZGUsbT1lLm5lYXJlc3RNb2RlPT09XCJcIj9cInNpbXBsZVwiOmUubmVhcmVzdE1vZGU7cmV0dXJuIGllKHthbnRpYWxpYXM6dCxheGVzOnIsY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6byxjdWJpY0NvZWZmQTpuLGV4Y2x1ZGVPdXRzaWRlOnMsZXh0cmFwb2xhdGlvblZhbHVlOnUsa2VlcEFzcGVjdFJhdGlvUG9saWN5OmQsbW9kZTphLG5lYXJlc3RNb2RlOm19KX19KTt2YXIgR2QsTmQsUnMsUHMsTXM9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtQZSgpO3ZlKCk7R2Q9ZT0+e2lmKCFlfHxlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAzIGlucHV0cy5cIik7bGV0IHQ9ZVswXSxyPWVbMV0sbz1lWzJdO2lmKHQuZGF0YVR5cGUhPT1yLmRhdGFUeXBlfHx0LmRhdGFUeXBlIT09by5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGVcIik7aWYodC5kaW1zLmxlbmd0aCE9PTMmJnQuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgMkQgb3IgM0RcIik7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBiZSAyRCBvciAzRFwiKTtsZXQgbj10LmRpbXNbdC5kaW1zLmxlbmd0aC0xXSxzPXQuZGltc1t0LmRpbXMubGVuZ3RoLTJdO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0yXSE9PXMpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0XCIpO2lmKG8uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgYmUgMURcIik7aWYoby5kaW1zW28uZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihlLmxlbmd0aD4zKXtsZXQgdT1lWzNdO2lmKHUuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBiZSAxRFwiKTtpZih1LmRpbXNbdS5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9aWYoZS5sZW5ndGg+NCl7bGV0IHU9ZVs0XTtpZih1LmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgYmUgMURcIik7aWYodS5kaW1zW3UuZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfX0sTmQ9KGUsdCxyLG8pPT57bGV0IG49ZVswXS5kaW1zLHM9ay5zaXplKG4pLHU9bixkPXMsYT1uLnNsaWNlKC0xKVswXSxtPW8/bi5zbGljZSgwLC0xKS5jb25jYXQoMSk6W10sZz1lLmxlbmd0aD4zLHg9ZS5sZW5ndGg+NCxiPW8mJnI+MSx3PW8mJnI+Mix2PXI+Myx5PWx0KGEpLFM9W0woXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMseSksTChcInNraXBcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyx5KSxMKFwiZ2FtbWFcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyx5KV07ZyYmUy5wdXNoKEwoXCJiZXRhXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMseSkpLHgmJlMucHVzaChMKFwiYmlhc1wiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLHkpKSxTLnB1c2goWChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdSx5KSksYiYmUy5wdXNoKFgoXCJtZWFuT3V0cHV0XCIsMSxtKSksdyYmUy5wdXNoKFgoXCJpbnZTdGRPdXRwdXRcIiwxLG0pKSx2JiZTLnB1c2goWChcImlucHV0U2tpcEJpYXNTdW1cIixlWzBdLmRhdGFUeXBlLHUseSkpO2xldCBBPU1lKGVbMF0uZGF0YVR5cGUpLFI9TT0+YFxcbiAgICAgIGNvbnN0IGhpZGRlblNpemU6IGYzMiA9ICR7YX07XFxuICAgICAgY29uc3QgaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ6IHUzMiA9ICR7YS95fTtcXG4gICAgICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke3QuZXBzaWxvbn07XFxuXFxuICAgICAgJHtNLmRlY2xhcmVWYXJpYWJsZXMoLi4uUyl9XFxuXFxuICAgICAgJHtNLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtNLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZC9hKX1cXG4gICAgICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ7XFxuICAgICAgICB2YXIgc3VtID0gJHtxZShcImYzMlwiLHkpfTtcXG4gICAgICAgIHZhciBzcXVhcmVTdW0gPSAke3FlKFwiZjMyXCIseSl9O1xcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IGhpZGRlblNpemVWZWN0b3JpemVkOyBpKyspIHtcXG4gICAgICAgICAgbGV0IHNraXBWYWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XFxuICAgICAgICAgIGxldCBiaWFzVmFsdWUgPSAke3g/XCJiaWFzW2ldXCI6XCIwLjBcIn07XFxuICAgICAgICAgIGxldCBpbnB1dFZhbHVlID0geFtvZmZzZXQgKyBpXTtcXG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRWYWx1ZSArIHNraXBWYWx1ZSArIGJpYXNWYWx1ZTtcXG4gICAgICAgICAgJHt2P1wiaW5wdXRTa2lwQmlhc1N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XFxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xcbiAgICAgICAgICBsZXQgZjMyVmFsdWUgPSAke0F0KEEseSxcInZhbHVlXCIpfTtcXG4gICAgICAgICAgc3VtICs9IGYzMlZhbHVlO1xcbiAgICAgICAgICBzcXVhcmVTdW0gKz0gZjMyVmFsdWUgKiBmMzJWYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBtZWFuID0gJHtodChcInN1bVwiLHkpfSAvIGhpZGRlblNpemU7XFxuICAgICAgICBsZXQgdmFyaWFuY2UgPSBzcXJ0KCR7aHQoXCJzcXVhcmVTdW1cIix5KX0gLyBoaWRkZW5TaXplIC0gbWVhbiAqIG1lYW4gKyBlcHNpbG9uKTtcXG4gICAgICAgICR7Yj9cIm1lYW5PdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XFxuICAgICAgICAke3c/XCJpbnZTdGRPdXRwdXRbZ2xvYmFsX2lkeF0gPSAxLjAgLyB2YXJpYW5jZTtcIjpcIlwifVxcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IGhpZGRlblNpemVWZWN0b3JpemVkOyBpKyspIHtcXG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAtICR7QX0obWVhbikpIC8gJHtBfSh2YXJpYW5jZSkgKiBnYW1tYVtpXVxcbiAgICAgICAgICAgKyAke2c/XCJiZXRhW2ldXCI6XCIwLjBcIn07XFxuICAgICAgICB9XFxuICAgICAgfWAsVz1be2RpbXM6dSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIHI+MSYmVy5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MiYmVy5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MyYmVy5wdXNoKHtkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFNoYWRlclNvdXJjZTpSLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpXLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvYS82NCl9fSl9fSxScz0oZSx0KT0+e0dkKGUuaW5wdXRzKTtsZXQgbz1bMF07ZS5vdXRwdXRDb3VudD4xJiZvLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MiYmby5wdXNoKC0zKSxlLm91dHB1dENvdW50PjMmJm8ucHVzaCgzKSxlLmNvbXB1dGUoTmQoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50LCExKSx7b3V0cHV0czpvfSl9LFBzPWU9PntsZXQgdD1lLmVwc2lsb247cmV0dXJuIGllKHtlcHNpbG9uOnR9KX19KTt2YXIgVWQsWXIsTGQsQnMsRmQsSGQsa3MsRHMsV3M9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtQZSgpO3ZlKCk7VWQ9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtpZih0LmF4ZXMubGVuZ3RoIT09MCl7aWYodC5heGVzLmxlbmd0aCE9PXQuc3RhcnRzLmxlbmd0aHx8dC5heGVzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcywgc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIil9ZWxzZSBpZih0LnN0YXJ0cy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO2Uuc2xpY2UoMSkuZm9yRWFjaCgocixvKT0+e2lmKGVbbysxXS5kYXRhVHlwZSE9PTYmJmVbbysxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke299IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKX0pfSxZcj0oZSx0KT0+e2xldCByPVtdO2lmKGUubGVuZ3RoPnQpaWYoZVt0XS5kYXRhVHlwZT09PTcpZVt0XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChvPT5yLnB1c2goTnVtYmVyKG8pKSk7ZWxzZSBpZihlW3RdLmRhdGFUeXBlPT09NillW3RdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHt0fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7cmV0dXJuIHJ9LExkPShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IHI9WXIoZSwxKSxvPVlyKGUsMiksbj1ZcihlLDMpO3JldHVybiBuLmxlbmd0aD09PTAmJihuPVsuLi5BcnJheShlWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldKSxpZSh7c3RhcnRzOnIsZW5kczpvLGF4ZXM6bn0pfWVsc2UgcmV0dXJuIHR9LEJzPShlLHQscixvLG4pPT57bGV0IHM9ZTtyZXR1cm4gZTwwJiYocys9cltvW3RdXSksblt0XTwwP01hdGgubWF4KDAsTWF0aC5taW4ocyxyW29bdF1dLTEpKTpNYXRoLm1heCgwLE1hdGgubWluKHMscltvW3RdXSkpfSxGZD0oZSx0LHIsbyk9PmBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcXG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XFxuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtyLmxlbmd0aH07IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHtvLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6XCJvdXRwdXRJbmRpY2VzW2ldXCJ9O1xcbiAgICAgICAgICAgIHZhciBpbnB1dEluZGV4ID0gb3V0cHV0SW5kZXggKiBzdGVwc1tpXSArIHN0YXJ0c1tpXSArIGNhcnJ5O1xcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRJbmRleCAvIGlucHV0U2hhcGVbaV07XFxuICAgICAgICAgICAgaW5wdXRJbmRleCA9IGlucHV0SW5kZXggJSBpbnB1dFNoYXBlW2ldO1xcbiAgICAgICAgICAgIGlmIChzaWduc1tpXSA8IDApIHtcXG4gICAgICAgICAgICAgIGlucHV0SW5kZXggPSBpbnB1dFNoYXBlW2ldIC0gaW5wdXRJbmRleCAtIDF1ICsgc3RhcnRzW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAke3IubGVuZ3RoPT09MT9cImlucHV0SW5kaWNlc1wiOlwiaW5wdXRJbmRpY2VzW2ldXCJ9ID0gaW5wdXRJbmRleDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gaW5wdXRJbmRpY2VzO1xcbiAgICAgIH1gLEhkPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG89ay5zaXplKHIpLG49dC5heGVzLmxlbmd0aD4wP2subm9ybWFsaXplQXhlcyh0LmF4ZXMsci5sZW5ndGgpOlsuLi5BcnJheShyLmxlbmd0aCkua2V5cygpXSxzPVlyKGUsNCk7cy5mb3JFYWNoKHk9PnkhPT0wfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJzdGVwIGNhbm5vdCBiZSAwXCIpfSkpLHMubGVuZ3RoPT09MCYmKHM9QXJyYXkobi5sZW5ndGgpLmZpbGwoMSkpO2xldCB1PXQuc3RhcnRzLm1hcCgoeSxTKT0+QnMoeSxTLHIsbixzKSksZD10LmVuZHMubWFwKCh5LFMpPT5Ccyh5LFMscixuLHMpKTtpZihuLmxlbmd0aCE9PXIubGVuZ3RoKWZvcihsZXQgeT0wO3k8ci5sZW5ndGg7Kyt5KW4uaW5jbHVkZXMoeSl8fCh1LnNwbGljZSh5LDAsMCksZC5zcGxpY2UoeSwwLHJbeV0pLHMuc3BsaWNlKHksMCwxKSk7bGV0IGE9cy5tYXAoeT0+TWF0aC5zaWduKHkpKTtzLmZvckVhY2goKHksUyxBKT0+e2lmKHk8MCl7bGV0IFI9KGRbU10tdVtTXSkveSxXPXVbU10sTT1XK1Iqc1tTXTt1W1NdPU0sZFtTXT1XLEFbU109LXl9fSk7bGV0IG09ci5zbGljZSgwKTtuLmZvckVhY2goKHksUyk9PnttW3ldPU1hdGguY2VpbCgoZFt5XS11W3ldKS9zW3ldKX0pO2xldCBnPXtkaW1zOm0sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0seD1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxtKSxiPUwoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsciksdz1rLnNpemUobSksdj15PT5gXFxuICAgICAgJHt5LmRlY2xhcmVWYXJpYWJsZXMoYix4KX1cXG4gICAgICAgIGNvbnN0IHNpZ25zID0gYXJyYXk8aTMyLCAke2EubGVuZ3RofT4oJHthLm1hcChTPT5gJHtTfWlgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgc3RhcnRzID0gYXJyYXk8dTMyLCAke3UubGVuZ3RofT4oJHt1Lm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3QgZW5kcyA9IGFycmF5PHUzMiwgJHtkLmxlbmd0aH0+KCR7ZC5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHN0ZXBzID0gYXJyYXk8dTMyLCAke3MubGVuZ3RofT4oJHtzLm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHtyLmxlbmd0aH0+KCR7ci5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcXG5cXG4gICAgICAgICR7RmQoYix4LHIsbSl9XFxuICAgICAgICAke3kubWFpblN0YXJ0KCl9XFxuICAgICAgICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHcpfVxcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7eC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgbGV0IGlucHV0SW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzKTtcXG4gICAgICAgICAgJHt4LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGIuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpKX1cXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtlWzRdPy5kaW1zPz9cIlwifWB9LGdldFNoYWRlclNvdXJjZTp2LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbZ10sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9fSl9fSxrcz0oZSx0KT0+e1VkKGUuaW5wdXRzLHQpO2xldCByPUxkKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShIZChlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxEcz1lPT57bGV0IHQ9ZS5zdGFydHMscj1lLmVuZHMsbz1lLmF4ZXM7cmV0dXJuIGllKHtzdGFydHM6dCxlbmRzOnIsYXhlczpvfSl9fSk7dmFyIGpkLEtkLHpzLFZzLEdzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtqZD1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IG9wIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxLZD0oZSx0KT0+e2xldCByPU1lKGUuZGF0YVR5cGUpLG89ZS5kaW1zLG49ay5zaXplKG8pLHM9NjQsdT10LmF4aXM7aWYodTwwJiYodT1vLmxlbmd0aCt1KSx1PG8ubGVuZ3RoLTEpdGhyb3cgbmV3IEVycm9yKFwic29mdG1heCBvbmx5IHN1cHBvcnRzIGxhc3QgYXhpcyBmb3Igbm93LlwiKTtsZXQgZD1vW3VdLGE9bi9kLG09bHQoZCksZz1kL20seD1tPT09MT9yOmB2ZWMke219PCR7cn0+YCxiPSh5LFMpPT5TPT09ND9gbWF4KG1heCgke3l9LngsICR7eX0ueSksIG1heCgke3l9LnosICR7eX0udykpYDpTPT09Mj9gbWF4KCR7eX0ueCwgJHt5fS55KWA6Uz09PTM/YG1heChtYXgoJHt5fS54LCAke3l9LnkpLCAke3l9LnopYDp5LHc9cj09PVwiZjMyXCI/YHZhciB0aHJlYWRNYXggPSAke3h9KC0zLjQwMjgyM2UrMzhmKTtgOmB2YXIgdGhyZWFkTWF4ID0gJHt4fSgtNjU1MDQuMGgpO2A7cmV0dXJue25hbWU6XCJTb2Z0bWF4XCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OmF9fSksZ2V0U2hhZGVyU291cmNlOnk9PmBcXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke3h9O1xcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7eH07XFxuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHt4fSwgJHtzfT47XFxuXFxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4IDogYXJyYXk8JHt4fT47XFxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQgOiBhcnJheTwke3h9PjtcXG5cXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt4fSB7XFxuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xcbiAgICAgIH1cXG5cXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7eH0pIHtcXG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XFxuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XFxuICAgICAgfVxcblxcbiAgICAgIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3N9LCAxLCAxKVxcbiAgICAgIGZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzdSkge1xcbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWQueCk7XFxuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkLngpO1xcbiAgICAgICAgY29uc3Qgd2cgPSAke3N9O1xcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xcbiAgICAgICAgbGV0IGNvbHMgPSAke2d9O1xcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSAke2d9O1xcblxcbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcXG4gICAgICAgICR7d31cXG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcXG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcXG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XFxuICAgICAgICB9XFxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XFxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcXG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcXG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XFxuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XFxuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7eH0oJHtiKFwidGhyZWFkU2hhcmVkWzBdXCIsbSl9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXFxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHt4fSgwLjApO1xcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcXG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XFxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcXG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcXG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt4fSgke2h0KFwidGhyZWFkU2hhcmVkWzBdXCIsbSl9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcXG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpIC8gcm93U3VtU2hhcmVkO1xcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1gfX0senM9KGUsdCk9PntqZChlLmlucHV0cyksZS5jb21wdXRlKEtkKGUuaW5wdXRzWzBdLHQpKX0sVnM9ZT0+aWUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgcWQsWWQsWGQsSmQsWmQsTnMsVXMsTHM9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO3FkPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sWWQ9KGUsdCk9PntsZXQgcj1bXSxvPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKSxvPXIubGVuZ3RoKSxpZSh7bnVtT3V0cHV0czpvLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6cn0pfSxYZD1lPT5gXFxuZm4gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcXG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcXG4gICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xcbiAgICAgICAgcmV0dXJuIGk7XFxuICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gJHtlfXU7XFxufWAsSmQ9ZT0+e2xldCB0PWUubGVuZ3RoLHI9W107Zm9yKGxldCBvPTA7bzx0Oysrbyl7bGV0IG49ZVtvXS5zZXRCeUluZGljZXMoXCJpbmRpY2VzXCIsXCJpbnB1dFtnbG9iYWxfaWR4XVwiKTt0PT09MT9yLnB1c2gobik6bz09PTA/ci5wdXNoKGBpZiAob3V0cHV0TnVtYmVyID09ICR7b311KSB7ICR7bn0gfWApOm89PT10LTE/ci5wdXNoKGBlbHNlIHsgJHtufSB9YCk6ci5wdXNoKGBlbHNlIGlmIChvdXRwdXROdW1iZXIgPT0gJHtvfSkgeyAke259IH1gKX1yZXR1cm5gXFxuICAgICAgZm4gd3JpdGVCdWZmZXJEYXRhKG91dHB1dE51bWJlcjogdTMyLCBpbmRpY2VzOiAke2VbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XFxuICAgICAgICAke3Iuam9pbihgXFxuYCl9XFxuICAgICAgfWB9LFpkPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG89ay5zaXplKHIpLG49ZVswXS5kYXRhVHlwZSxzPXIubGVuZ3RoLHU9dC5heGlzLGQ9dTwwP3IubGVuZ3RoK3U6dSxhPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLG09TChcImlucHV0XCIsbixyKSxnPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLHg9W10sYj1bXSx3PTA7Zm9yKGxldCBTPTA7Uzx0Lm51bU91dHB1dHM7UysrKXt3Kz10LnNwbGl0U2l6ZXNbU10sZ1tTXT13O2xldCBBPXIuc2xpY2UoKTtBW3QuYXhpc109dC5zcGxpdFNpemVzW1NdLGIucHVzaChBKSxhW1NdPVgoYG91dHB1dCR7U31gLG4sYltTXSkseC5wdXNoKHtkaW1zOmJbU10sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pfWxldCB2PXM8Mj9cImluZGljZXNcIjpgaW5kaWNlc1ske2R9XWAseT1TPT5gXFxuICAke1MuZGVjbGFyZVZhcmlhYmxlcyhtLC4uLmEpfVxcbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtnLmxlbmd0aH0+KCR7Zy5tYXAoQT0+YCR7QX11YCkuam9pbihcIixcIil9KTtcXG4gICR7WGQoZy5sZW5ndGgpfVxcbiAgJHtKZChhKX1cXG5cXG4gICR7Uy5tYWluU3RhcnQoKX1cXG4gICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobyl9XFxuXFxuICAgIHZhciBpbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICBsZXQgb3V0cHV0TnVtYmVyID0gY2FsY3VsYXRlT3V0cHV0SW5kZXgoJHt2fSk7XFxuICAgIGlmIChvdXRwdXROdW1iZXIgIT0gMCkge1xcbiAgICAgICAgJHt2fSAtPSBzaXplSW5Db25jYXRBeGlzW291dHB1dE51bWJlciAtIDF1XTtcXG4gICAgfVxcbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0TnVtYmVyLCBpbmRpY2VzLCBnbG9iYWxfaWR4KTtcXG4gIH1gO3JldHVybntuYW1lOlwiU3BsaXRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRTaGFkZXJTb3VyY2U6eSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6eCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX19KX19LE5zPShlLHQpPT57cWQoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDpZZChlLmlucHV0cyx0KTtlLmNvbXB1dGUoWmQoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sVXM9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxvPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihvIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiBpZSh7YXhpczp0LG51bU91dHB1dHM6byxzcGxpdFNpemVzOnJ9KX19KTt2YXIgRnMsUWQsZWMsdGMsSHMsanM9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTt2ZSgpO0ZzPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxRZD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTYmJmVbMF0uZGF0YVR5cGUhPT0xMil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlc1wiKTtpZihlWzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLURcIik7aWYoRnMoZVsxXSkubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yXCIpfSxlYz0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKXIucHVzaChlW29dKnRbb10pO3JldHVybiByfSx0Yz1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9RnMoZVsxXSksbz1lYyh0LHIpLG49ay5zaXplKG8pLHM9ZVswXS5kYXRhVHlwZSx1PUwoXCJpbnB1dFwiLHMsdCksZD1YKFwib3V0cHV0XCIscyxvKSxhPW09PmBcXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gJHt1LmluZGljZXMoLi4udCl9O1xcbiAgICAgICR7bS5kZWNsYXJlVmFyaWFibGVzKHUsZCl9XFxuICAgICAgJHttLm1haW5TdGFydCgpfVxcbiAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG4pfVxcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7dS50eXBlLmluZGljZXN9O1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xcbiAgICAgICAgbGV0IGlucHV0RGltVmFsdWUgPSAke2QuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixcImlcIil9ICAlICR7dS5pbmRpY2VzR2V0KFwiaW5wdXRTaGFwZVwiLFwiaVwiKX07XFxuXFxuICAgICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLFwiaW5wdXREaW1WYWx1ZVwiKX1cXG4gICAgICB9XFxuICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHUuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpKX1cXG4gICAgfWA7cmV0dXJue25hbWU6XCJUaWxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cn1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfX0pLGdldFNoYWRlclNvdXJjZTphfX0sSHM9ZT0+e1FkKGUuaW5wdXRzKSxlLmNvbXB1dGUodGMoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHJjLG5jLEtzLHFzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7dmUoKTtyYz0oZSx0LHIsbyxuKT0+e2xldCBzPWsuc2l6ZShyKSx1PU1hdGguY2VpbChzLzQpLGQ9WChcIm91dHB1dERhdGFcIixuLHIsNCksYT1MKFwiYURhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcyw0KSxtPUwoXCJiRGF0YVwiLHRbMl0uZGF0YVR5cGUsdFsyXS5kaW1zLDQpLGc9TChcImNEYXRhXCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsNCkseCxiPSh3LHYseSk9PmBzZWxlY3QoJHt2fSwgJHt3fSwgJHt5fSlgO2lmKCFvKXg9ZC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixiKGEuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLG0uZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLGcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtsZXQgdz0odix5LFM9XCJcIik9PntsZXQgQT1gYURhdGFbaW5kZXhBJHt5fV1bY29tcG9uZW50QSR7eX1dYCxSPWBiRGF0YVtpbmRleEIke3l9XVtjb21wb25lbnRCJHt5fV1gLFc9YGJvb2woY0RhdGFbaW5kZXhDJHt5fV0gJiAkezQyNzgxOTAwODA+Pj4oMy15KSo4fXUpYDtyZXR1cm5gXFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3l9ID0gJHtkLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHt5fXVgKX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldEEke3l9ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt5fWAsZCl9O1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHt5fSA9ICR7bS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eX1gLGQpfTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QyR7eX0gPSAke2cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3l9YCxkKX07XFxuICAgICAgICAgICAgbGV0IGluZGV4QSR7eX0gPSBvZmZzZXRBJHt5fSAvIDR1O1xcbiAgICAgICAgICAgIGxldCBpbmRleEIke3l9ID0gb2Zmc2V0QiR7eX0gLyA0dTtcXG4gICAgICAgICAgICBsZXQgaW5kZXhDJHt5fSA9IG9mZnNldEMke3l9IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3l9ID0gb2Zmc2V0QSR7eX0gJSA0dTtcXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7eX0gPSBvZmZzZXRCJHt5fSAlIDR1O1xcbiAgICAgICAgICAgICR7dn1bJHt5fV0gPSAke1N9KCR7YihBLFIsVyl9KTtcXG4gICAgICAgICAgYH07bj09PTk/eD1gXFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XFxuICAgICAgICAgICAgJHt3KFwiZGF0YVwiLDAsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHt3KFwiZGF0YVwiLDEsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHt3KFwiZGF0YVwiLDIsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHt3KFwiZGF0YVwiLDMsXCJ1MzJcIil9XFxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOng9YFxcbiAgICAgICAgICAgICR7dyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cXG4gICAgICAgICAgICAke3coXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XFxuICAgICAgICAgICAgJHt3KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxcbiAgICAgICAgICAgICR7dyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cXG4gICAgICAgICAgYH1yZXR1cm5gXFxuICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyhnLGEsbSxkKX1cXG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxcbiAgICAgICAgJHt4fVxcbiAgICAgIH1gfSxuYz1lPT57bGV0IHQ9ZVsxXS5kaW1zLHI9ZVsyXS5kaW1zLG89ZVswXS5kaW1zLG49ZVsxXS5kYXRhVHlwZSxzPSEoay5hcmVFcXVhbCh0LHIpJiZrLmFyZUVxdWFsKHIsbykpLHU9dCxkPWsuc2l6ZSh0KTtpZihzKXtsZXQgYT1RZS5jYWxjU2hhcGUoUWUuY2FsY1NoYXBlKHQsciwhMSksbywhMSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO3U9YSxkPWsuc2l6ZSh1KX1yZXR1cm57bmFtZTpcIldoZXJlXCIsZ2V0U2hhZGVyU291cmNlOmE9PnJjKGEsZSx1LHMsbiksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0LzQpfX0pfX0sS3M9ZT0+e2UuY29tcHV0ZShuYyhlLmlucHV0cykpfX0pO3ZhciBZcyxYcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Y2EoKTtmYSgpO2phKCk7bmkoKTtpaSgpO19uKCk7d2koKTtTaSgpO0lpKCk7T2koKTtQaSgpO2tpKCk7emkoKTtOaSgpO0xpKCk7amkoKTtzcygpO0VzKCk7TXIoKTtfcygpO01zKCk7V3MoKTtHcygpO0xzKCk7anMoKTtycigpO0luKCk7cXMoKTtZcz1uZXcgTWFwKFtbXCJBYnNcIixbbWFdXSxbXCJBY29zXCIsW2hhXV0sW1wiQWNvc2hcIixbZ2FdXSxbXCJBZGRcIixbS2FdXSxbXCJBcmdNYXhcIixbZGEsQ25dXSxbXCJBcmdNaW5cIixbbGEsQ25dXSxbXCJBc2luXCIsW3lhXV0sW1wiQXNpbmhcIixbYmFdXSxbXCJBdGFuXCIsW3dhXV0sW1wiQXRhbmhcIixbdmFdXSxbXCJBdmVyYWdlUG9vbFwiLFtaaSxKaV1dLFtcIkJpYXNBZGRcIixbcGFdXSxbXCJCaWFzU3BsaXRHZWx1XCIsW0hhXV0sW1wiQ2FzdFwiLFt4YSwkYV1dLFtcIkNlaWxcIixbQ2FdXSxbXCJDbGlwVjEwXCIsW0FuXV0sW1wiQ2xpcFwiLFtTYV1dLFtcIkNvbmNhdFwiLFtvaSxhaV1dLFtcIkNvbnZcIixbUG4sUm5dXSxbXCJDb252VHJhbnNwb3NlXCIsW2JpLHlpXV0sW1wiQ29zXCIsW0FhXV0sW1wiQ29zaFwiLFtJYV1dLFtcIkRpdlwiLFtxYV1dLFtcIkVpbnN1bVwiLFskaSx4aV1dLFtcIkVsdVwiLFtFYSxrcl1dLFtcIkVxdWFsXCIsW1lhXV0sW1wiRXJmXCIsW1RhXV0sW1wiRXhwXCIsW09hXV0sW1wiRXhwYW5kXCIsW0FpXV0sW1wiRmxvb3JcIixbX2FdXSxbXCJGdXNlZENvbnZcIixbUG4sUm5dXSxbXCJHYXRoZXJcIixbVGksRWldXSxbXCJHYXRoZXJFbGVtZW50c1wiLFtSaSxfaV1dLFtcIkdlbHVcIixbUmFdXSxbXCJHZW1tXCIsW01pLEJpXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbdHMsZXNdXSxbXCJHbG9iYWxNYXhQb29sXCIsW2lzLGFzXV0sW1wiR3JlYXRlclwiLFtRYV1dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW3RpXV0sW1wiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsW1dpLERpXV0sW1wiTGF5ZXJOb3JtYWxpemF0aW9uXCIsW0dpLFZpXV0sW1wiTGVha3lSZWx1XCIsW1BhLGtyXV0sW1wiTGVzc1wiLFtlaV1dLFtcIkxlc3NPckVxdWFsXCIsW3JpXV0sW1wiTG9nXCIsW0ZhXV0sW1wiTWF0TXVsXCIsW1VpXV0sW1wiTWF4UG9vbFwiLFtucyxvc11dLFtcIk11bFwiLFtYYV1dLFtcIk5lZ1wiLFtCYV1dLFtcIk5vdFwiLFtNYV1dLFtcIlBhZFwiLFtGaSxIaV1dLFtcIlBvd1wiLFtKYV1dLFtcIlJhbmdlXCIsW0lzXV0sW1wiUmVjaXByb2NhbFwiLFtrYV1dLFtcIlJlZHVjZU1pblwiLFtyYSxZZV1dLFtcIlJlZHVjZU1lYW5cIixbSm8sWWVdXSxbXCJSZWR1Y2VNYXhcIixbdGEsWWVdXSxbXCJSZWR1Y2VTdW1cIixbb2EsWWVdXSxbXCJSZWR1Y2VQcm9kXCIsW25hLFllXV0sW1wiUmVkdWNlTDFcIixbWm8sWWVdXSxbXCJSZWR1Y2VMMlwiLFtRbyxZZV1dLFtcIlJlZHVjZUxvZ1N1bVwiLFtpYSxZZV1dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFtlYSxZZV1dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFthYSxZZV1dLFtcIlJlbHVcIixbRGFdXSxbXCJSZXNpemVcIixbVHMsT3NdXSxbXCJTaWdtb2lkXCIsW1dhXV0sW1wiU2luXCIsW3phXV0sW1wiU2luaFwiLFtWYV1dLFtcIlNsaWNlXCIsW2tzLERzXV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtScyxQc11dLFtcIlNwbGl0XCIsW05zLFVzXV0sW1wiU3FydFwiLFtHYV1dLFtcIlNvZnRtYXhcIixbenMsVnNdXSxbXCJTdWJcIixbWmFdXSxbXCJUYW5cIixbTmFdXSxbXCJUYW5oXCIsW1VhXV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW0xhLGtyXV0sW1wiVGlsZVwiLFtIc11dLFtcIlRyYW5zcG9zZVwiLFt6byxWb11dLFtcIldoZXJlXCIsW0tzXV1dKX0pO3ZhciBYcixKcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTttdCgpO3ZlKCk7WHI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxyKXt0aGlzLnJlcG8uc2V0KHQscil9cnVuKHQscixvLG4scyx1LGQpe2xldCBhPXRoaXMuYmFja2VuZC5kZXZpY2UsbT10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7bS5zZXRQaXBlbGluZSh0LmNvbXB1dGVQaXBlbGluZSk7bGV0IGc9W107Zm9yKGxldCBiIG9mIG4pZy5wdXNoKHtiaW5kaW5nOmcubGVuZ3RoLHJlc291cmNlOntidWZmZXI6Yi5idWZmZXJ9fSk7Zm9yKGxldCBiIG9mIHMpZy5wdXNoKHtiaW5kaW5nOmcubGVuZ3RoLHJlc291cmNlOntidWZmZXI6Yi5idWZmZXJ9fSk7ZCYmZy5wdXNoKHtiaW5kaW5nOmcubGVuZ3RoLHJlc291cmNlOmR9KTtsZXQgeD1hLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnQuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOmcsbGFiZWw6dC5wcm9ncmFtSW5mby5uYW1lfSk7aWYobS5zZXRCaW5kR3JvdXAoMCx4KSxtLmRpc3BhdGNoV29ya2dyb3VwcyguLi51KSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5iYWNrZW5kLmlzUXVlcnlFbmFibGVkKCkpe3R5cGVvZiB0aGlzLmJhY2tlbmQucXVlcnlEYXRhPlwidVwiJiYodGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YT10aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHRoaXMuYmFja2VuZC5xdWVyeVNldENvdW50KjgsR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSkpO2xldCBiPXRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUodGhpcy5iYWNrZW5kLnF1ZXJ5U2V0Q291bnQqOCxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRHxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksdGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCkucmVzb2x2ZVF1ZXJ5U2V0KHRoaXMuYmFja2VuZC5xdWVyeVNldCwwLDIsdGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YS5idWZmZXIsMCksdGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCkuY29weUJ1ZmZlclRvQnVmZmVyKHRoaXMuYmFja2VuZC5xdWVyeURhdGEuYnVmZmVyLDAsYi5idWZmZXIsMCx0aGlzLmJhY2tlbmQucXVlcnlTZXRDb3VudCo4KSx0aGlzLmJhY2tlbmQuZmx1c2goKTtsZXQgdz10aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbElkLHY9dGhpcy5iYWNrZW5kLmtlcm5lbHMuZ2V0KHcpLHk9YFske3ZbMF19XSAke3ZbMV19YDtiLmJ1ZmZlci5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCk9PntsZXQgUz1uZXcgQmlnVWludDY0QXJyYXkoYi5idWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSksQT1TWzBdLFI9U1sxXTtiLmJ1ZmZlci51bm1hcCgpLHR5cGVvZiB0aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZT5cInVcIiYmKHRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlPUEpO2xldCBXPU51bWJlcihBLXRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlKSxNPU51bWJlcihSLXRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlKTtpZighTnVtYmVyLmlzU2FmZUludGVnZXIoVyl8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihNKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2VcIik7dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoYi5pZCk7bGV0IEQ9XCJcIjtyLmZvckVhY2goKHosRik9PntEKz1gaW5wdXRbJHtGfV06IFske3ouZGltc31dIHwgJHtRdCh6LmRhdGFUeXBlKX0sIGB9KTtsZXQgXz1cIlwiO28uZm9yRWFjaCgoeixGKT0+e18rPWBvdXRwdXRbJHtGfV06IFske3ouZGltc31dIHwgJHtRdCh6LmRhdGFUeXBlKX0sIGB9KSxjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHt3fXwke3l9XCIgJHtEfSR7X31leGVjdXRpb24gdGltZTogJHtNLVd9IG5zYCl9KX10aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj0xNiYmdGhpcy5iYWNrZW5kLmZsdXNoKCl9ZGlzcG9zZSgpe31idWlsZCh0LHIpe2xldCBvPXRoaXMuYmFja2VuZC5kZXZpY2Usbj1bXTtvLmZlYXR1cmVzLmhhcyhcInNoYWRlci1mMTZcIikmJm4ucHVzaChcImVuYWJsZSBmMTY7XCIpO2xldCBzPWtvKHIpLHU9dC5nZXRTaGFkZXJTb3VyY2UocyksZD1gJHtuLmpvaW4oYFxcbmApfVxcbiR7cy5hZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zfVxcbiR7dX1gLGE9by5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6ZCxsYWJlbDp0Lm5hbWV9KTtFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIHNoYWRlciBjb2RlOiAke2R9YCk7bGV0IG09by5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2NvbXB1dGU6e21vZHVsZTphLGVudHJ5UG9pbnQ6XCJtYWluXCJ9LGxheW91dDpcImF1dG9cIixsYWJlbDp0Lm5hbWV9KTtyZXR1cm57cHJvZ3JhbUluZm86dCxjb21wdXRlUGlwZWxpbmU6bX19bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUodCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0Lngsbz10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQueXx8MSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC56fHwxLHM9dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYocjw9cyYmbzw9cyYmbjw9cylyZXR1cm5bcixvLG5dO2xldCB1PXIqbypuLGQ9TWF0aC5jZWlsKE1hdGguc3FydCh1KSk7aWYoZD5zKXtpZihkPU1hdGguY2VpbChNYXRoLmNicnQodSkpLGQ+cyl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVybltkLGQsZF19ZWxzZSByZXR1cm5bZCxkLDFdfX19KTt2YXIgb2MsYWMsSnIsWnM9SCgoKT0+e1widXNlIHN0cmljdFwiO210KCk7VG8oKTtQbygpO1hzKCk7SnMoKTtvYz0oZSx0KT0+e2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHt0Lmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtlLmxlbmd0aH0uYCk7bGV0IHI9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pe2xldCBuPWVbb10uZGF0YVR5cGU7c3dpdGNoKHRbb10pe2Nhc2VcIm5vbmVcIjp7ci5wdXNoKFwiXCIpO2JyZWFrfWNhc2VcInR5cGVcIjp7ci5wdXNoKGAke259YCk7YnJlYWt9Y2FzZVwicmFua1wiOntsZXQgcz1lW29dLmRpbXMubGVuZ3RoO3IucHVzaChgJHtufTske3N9YCk7YnJlYWt9Y2FzZVwiZGltc1wiOntsZXQgcz1lW29dLmRpbXMuam9pbihcIixcIik7ci5wdXNoKGAke259OyR7c31gKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHt0W29dfWApfX1yZXR1cm4gci5qb2luKFwifFwiKX0sYWM9KGUsdCk9PntsZXQgcj1lLm5hbWU7cmV0dXJuIGUuc2hhZGVyQ2FjaGU/LmhpbnQmJihyKz1cIltcIitlLnNoYWRlckNhY2hlLmhpbnQrXCJdXCIpLHIrPWA6JHtvYyh0LGUuc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzPz9uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoXCJkaW1zXCIpKX1gLHJ9LEpyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wO3RoaXMucXVlcnlTZXRDb3VudD0yO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0KXtpZighbmF2aWdhdG9yLmdwdSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHcHVCYWNrZW5kOiBXZWJHUFUgaXMgbm90IGF2YWlsYWJsZS5cIik7bGV0IHI9YXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcIldlYkdwdUJhY2tlbmQ6IEZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuXCIpO3RoaXMuZW52PXQ7bGV0IG89W10sbj17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOnIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOnIubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOnIubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczpvfTtyLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmby5wdXNoKFwidGltZXN0YW1wLXF1ZXJ5XCIpLHIuZmVhdHVyZXMuaGFzKFwic2hhZGVyLWYxNlwiKSYmby5wdXNoKFwic2hhZGVyLWYxNlwiKSx0aGlzLmRldmljZT1hd2FpdCByLnJlcXVlc3REZXZpY2UobiksdGhpcy5ncHVEYXRhTWFuYWdlcj1Sbyh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBYcih0aGlzKSx0aGlzLmtlcm5lbHM9bmV3IE1hcCx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhPW5ldyBNYXAsdGhpcy5rZXJuZWxDdXN0b21EYXRhPW5ldyBNYXAsSW8odC5sb2dMZXZlbCwhIXQuZGVidWcpLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPXM9PntzLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke3MuZXJyb3IubWVzc2FnZX1gKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImRldmljZVwiLHt2YWx1ZTp0aGlzLmRldmljZX0pfWRpc3Bvc2UoKXt0eXBlb2YgdGhpcy5xdWVyeVNldDxcInVcIiYmdGhpcy5xdWVyeVNldC5kZXN0cm95KCksdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCl9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtpZighdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpe2xldCB0PXt9O3RoaXMuaXNRdWVyeUVuYWJsZWQoKSYmKHR5cGVvZiB0aGlzLnF1ZXJ5U2V0PlwidVwiJiYodGhpcy5xdWVyeVNldD10aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7dHlwZTpcInRpbWVzdGFtcFwiLGNvdW50OnRoaXMucXVlcnlTZXRDb3VudH0pKSx0LnRpbWVzdGFtcFdyaXRlcz17cXVlcnlTZXQ6dGhpcy5xdWVyeVNldCxiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4OjAsZW5kT2ZQYXNzV3JpdGVJbmRleDoxfSksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9dGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLmJlZ2luQ29tcHV0ZVBhc3ModCl9cmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyfWVuZENvbXB1dGVQYXNzKCl7dGhpcy5jb21wdXRlUGFzc0VuY29kZXImJih0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsKX1mbHVzaCgpe3RoaXMuY29tbWFuZEVuY29kZXImJih0aGlzLmVuZENvbXB1dGVQYXNzKCksdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmdldENvbW1hbmRFbmNvZGVyKCkuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wKX1pc1F1ZXJ5RW5hYmxlZCgpe3JldHVybiEhKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZ01vZGU9PT1cImRlZmF1bHRcIil9cnVuKHQscixvLG4scyl7bGV0IHU9W107Zm9yKGxldCBBPTA7QTxyLmxlbmd0aDsrK0Epe2xldCBSPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHJbQV0uZGF0YSk7aWYoIVIpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7cltBXS5kYXRhfWApO3VbQV09Un1sZXQgZD1hYyh0LHIpLGE9dGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChkKSx7b3V0cHV0czptLGRpc3BhdGNoR3JvdXA6Zyxwcm9ncmFtVW5pZm9ybXM6eH09dC5nZXRSdW5EYXRhKHIpLGI9by5sZW5ndGg9PT0wP20ubWFwKChBLFIpPT5SKTpvO2lmKGIubGVuZ3RoIT09bS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke2IubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7bS5sZW5ndGh9LmApO2xldCB3PVtdLHY9W107Zm9yKGxldCBBPTA7QTxtLmxlbmd0aDsrK0Epe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGJbQV0pfHxiW0FdPC0zfHxiW0FdPj1tLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke2JbQV19YCk7aWYoYltBXT09PS0zKWNvbnRpbnVlO2xldCBSPWJbQV09PT0tMSxXPWJbQV09PT0tMixNPVJ8fFc/cyhtW0FdLmRhdGFUeXBlLG1bQV0uZGltcyk6bihiW0FdLG1bQV0uZGF0YVR5cGUsbVtBXS5kaW1zKSxEPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KE0uZGF0YSk7aWYoIUQpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAke00uZGF0YX1gKTtpZihSJiZ0aGlzLnRlbXBvcmFyeURhdGEucHVzaChEKSxXKXtsZXQgXz10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7X3x8KF89W10sdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsXykpLF8ucHVzaChEKX13LnB1c2goTSksdi5wdXNoKEQpfWxldCB5O2lmKHgpe2xldCBBPTAsUj0wLFc9W10sTT0xO3guZm9yRWFjaCh6PT57bGV0IEY9dHlwZW9mIHouZGF0YT09XCJudW1iZXJcIj9bei5kYXRhXTp6LmRhdGEscTtzd2l0Y2goRi5sZW5ndGgpe2Nhc2UgMTpxPTQ7YnJlYWs7Y2FzZSAyOnE9ODticmVhaztjYXNlIDM6cT0xNjticmVhaztjYXNlIDQ6cT0xNjticmVhaztjYXNlIDU6cT0xNjticmVhaztjYXNlIDY6cT0xNjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsZW5ndGg6ICR7Ri5sZW5ndGh9YCl9KFI9PT01fHxSPT09NikmJihxPTE2KSxxPk0mJihNPXEpLEE9TWF0aC5jZWlsKEEvcSkqcSxSPUYubGVuZ3RoLFcucHVzaChBKSxBKz1GLmxlbmd0aCo0fSksQT1NYXRoLmNlaWwoQS9NKSpNO2xldCBEPW5ldyBBcnJheUJ1ZmZlcihBKTt4LmZvckVhY2goKHosRik9PntsZXQgcT1XW0ZdLGxlPXR5cGVvZiB6LmRhdGE9PVwibnVtYmVyXCI/W3ouZGF0YV06ei5kYXRhO3oudHlwZT09PVwiaW50MzJcIj9uZXcgSW50MzJBcnJheShELHEsbGUubGVuZ3RoKS5zZXQobGUpOnoudHlwZT09PVwidWludDMyXCI/bmV3IFVpbnQzMkFycmF5KEQscSxsZS5sZW5ndGgpLnNldChsZSk6bmV3IEZsb2F0MzJBcnJheShELHEsbGUubGVuZ3RoKS5zZXQobGUpfSk7bGV0IF89dGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoQSxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTt0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihfLmJ1ZmZlciwwLEQsMCxBKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoXy5pZCkseT17b2Zmc2V0OjAsc2l6ZTpBLGJ1ZmZlcjpfLmJ1ZmZlcn19bGV0IFM9dGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShnKTtyZXR1cm4gYXx8KGE9dGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZCh0LFMpLHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3QoZCxhKSksRWUoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHtkfSkgd2l0aCAke1NbMF19eCR7U1sxXX14JHtTWzJdfWApLHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKGEscix3LHUsdixTLHkpLHd9dXBsb2FkKHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxyKX1tZW1jcHkodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LHIpfWFzeW5jIGRvd25sb2FkKHQscil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LHIpfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQscixvLG4pe2xldCBzPVlzLmdldCh0KTtpZighcyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTt0aGlzLmtlcm5lbHMuc2V0KHIsW3QsbixzWzBdLFtzWzFdLG9dXSl9cmVsZWFzZUtlcm5lbCh0KXtsZXQgcj10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0KTtpZihyKXtmb3IobGV0IG8gb2Ygcil0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2Uoby5pZCk7dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUodCl9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmRlbGV0ZSh0KSx0aGlzLmtlcm5lbHMuZGVsZXRlKHQpfWNvbXB1dGVLZXJuZWwodCxyLG8pe2xldCBuPXRoaXMua2VybmVscy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGNyZWF0ZWQ6ICR7dH1gKTtsZXRbcyx1LGQsYV09bjtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZCE9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHtzfV0gJHt1fVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO3RoaXMuY3VycmVudEtlcm5lbElkPXQsYVswXSYmKGFbMV09YVswXShhWzFdKSxhWzBdPXZvaWQgMCksRWUoXCJpbmZvXCIsKCk9PmBbV2ViR1BVXSBTdGFydCB0byBydW4ga2VybmVsIFwiWyR7c31dICR7dX1cIi4uLmApO2xldCBtPXRoaXMuZW52LmRlYnVnO3RoaXMudGVtcG9yYXJ5RGF0YT1bXTt0cnl7cmV0dXJuIG0mJnRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKFwidmFsaWRhdGlvblwiKSxkKHIsYVsxXSksMH1jYXRjaChnKXtyZXR1cm4gby5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7c31dICR7dX1cIiBmYWlsZWQuICR7Z31gKSksMX1maW5hbGx5e20mJm8ucHVzaCh0aGlzLmRldmljZS5wb3BFcnJvclNjb3BlKCkudGhlbihnPT5nP2BHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7c31dICR7dX1cIjogJHtnLm1lc3NhZ2V9YDpudWxsKSk7Zm9yKGxldCBnIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZy5pZCk7dGhpcy50ZW1wb3JhcnlEYXRhPVtdLHRoaXMuY3VycmVudEtlcm5lbElkPW51bGx9fXJlZ2lzdGVyQnVmZmVyKHQscixvLG4pe2xldCBzPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO3N8fChzPW5ldyBNYXAsdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQodCxzKSk7bGV0IHU9cy5nZXQociksZD10aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIobyxuLHU/LlsxXSk7cmV0dXJuIHMuc2V0KHIsW2Qsb10pLGR9dW5yZWdpc3RlckJ1ZmZlcnModCl7bGV0IHI9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7ciYmKHIuZm9yRWFjaChvPT50aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihvWzFdKSksdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUodCkpfWdldEJ1ZmZlcih0KXtsZXQgcj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7dH1gKTtyZXR1cm4gci5idWZmZXJ9Y3JlYXRlRG93bmxvYWRlcih0LHIsbyl7cmV0dXJuIGFzeW5jKCk9PntsZXQgbj1hd2FpdCB5bih0aGlzLHQscik7cmV0dXJuIEVvKG4uYnVmZmVyLG8pfX19fSk7dmFyIFFzPXt9O0lyKFFzLHtpbml0OigpPT5pY30pO3ZhciBzcix6bixpYyxldT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtacygpO210KCk7Z2UoKTtzcj1jbGFzcyBle2NvbnN0cnVjdG9yKHQscixvLG4pe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1yO3RoaXMuZGF0YT1vO3RoaXMuZGltcz1ufWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PWsuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ay5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PWsuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoay5zaXplKHQpIT09ay5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0sem49Y2xhc3N7Y29uc3RydWN0b3IodCxyLG8pe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPXI7dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO2xldCBuPXQuSEVBUFUzMixzPW8+PjI7dGhpcy5vcEtlcm5lbENvbnRleHQ9bltzKytdO2xldCB1PW5bcysrXTt0aGlzLm91dHB1dENvdW50PW5bcysrXSx0aGlzLmN1c3RvbURhdGFPZmZzZXQ9bltzKytdLHRoaXMuY3VzdG9tRGF0YVNpemU9bltzKytdO2xldCBkPVtdO2ZvcihsZXQgYT0wO2E8dTthKyspe2xldCBtPW5bcysrXSxnPW5bcysrXSx4PW5bcysrXSxiPVtdO2ZvcihsZXQgdz0wO3c8eDt3KyspYi5wdXNoKG5bcysrXSk7ZC5wdXNoKG5ldyBzcih0LG0sZyxiKSl9dGhpcy5pbnB1dHM9ZH1nZXQga2VybmVsQ3VzdG9tRGF0YSgpe3JldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGF9Z2V0IGN1c3RvbURhdGFCdWZmZXIoKXtyZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCx0aGlzLmN1c3RvbURhdGFPZmZzZXQrdGhpcy5jdXN0b21EYXRhU2l6ZSl9Y29tcHV0ZSh0LHIpe2xldCBvPXI/LmlucHV0cz8ubWFwKGQ9PnR5cGVvZiBkPT1cIm51bWJlclwiP3RoaXMuaW5wdXRzW2RdOmQpPz90aGlzLmlucHV0cyxuPXI/Lm91dHB1dHM/P1tdLHM9KGQsYSxtKT0+bmV3IHNyKHRoaXMubW9kdWxlLGEsdGhpcy5vdXRwdXQoZCxtKSxtKSx1PShkLGEpPT57bGV0IG09ZXIoZCk7aWYoIW0pdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZH1gKTtsZXQgZz1tKmsuc2l6ZShhKTtyZXR1cm4gbmV3IHNyKHRoaXMubW9kdWxlLGQsdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShnKS5pZCxhKX07cmV0dXJuIHRoaXMuYmFja2VuZC5ydW4odCxvLG4scyx1KX1vdXRwdXQodCxyKXtsZXQgbz10aGlzLm1vZHVsZS5zdGFja1NhdmUoKTt0cnl7bGV0IG49dGhpcy5tb2R1bGUuc3RhY2tBbGxvYygoMStyLmxlbmd0aCkqNCkscz1uPj4yO3RoaXMubW9kdWxlLkhFQVBVMzJbcysrXT1yLmxlbmd0aDtmb3IobGV0IHU9MDt1PHIubGVuZ3RoO3UrKyl0aGlzLm1vZHVsZS5IRUFQVTMyW3MrK109clt1XTtyZXR1cm4gdGhpcy5tb2R1bGUuX0pzZXBPdXRwdXQodGhpcy5vcEtlcm5lbENvbnRleHQsdCxuKX1jYXRjaChuKXt0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBrZXJuZWxcXCdzIG91dHB1dFske3R9XSB3aXRoIGRpbXMgWyR7cn1dLiBJZiB5b3UgYXJlIHJ1bm5pbmcgd2l0aCBwcmUtYWxsb2NhdGVkIG91dHB1dCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3V0cHV0IHR5cGUvZGltcyBhcmUgY29ycmVjdC4gRXJyb3I6ICR7bn1gKX1maW5hbGx5e3RoaXMubW9kdWxlLnN0YWNrUmVzdG9yZShvKX19fSxpYz1hc3luYyhlLHQpPT57bGV0IHI9ZS5qc2VwSW5pdDtpZihyJiZuYXZpZ2F0b3IuZ3B1KXtpZighdC53YXNtLnNpbWQpdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCBmb3IgV2ViR1BVPU9OIGFuZCBTSU1EPU9GRi4gUGxlYXNlIHNldCBgZW52Lndhc20uc2ltZGAgdG8gdHJ1ZSB3aGVuIHVzaW5nIFdlYkdQVSBFUFwiKTtsZXQgbz1uZXcgSnI7YXdhaXQgby5pbml0aWFsaXplKHQpLHIobyxuPT5vLmFsbG9jKG4pLG49Pm8uZnJlZShuKSwobixzLHUsZD0hMSk9PntpZihkKUVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7bn0sIGRzdD0ke3N9LCBzaXplPSR7dX1gKSxvLm1lbWNweShuLHMpO2Vsc2V7RWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7bn0sIGdwdURhdGFJZD0ke3N9LCBzaXplPSR7dX1gKTtsZXQgYT1lLkhFQVBVOC5zdWJhcnJheShuLG4rdSk7by51cGxvYWQocyxhKX19LGFzeW5jKG4scyx1KT0+e0VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0NwdTogZ3B1RGF0YUlkPSR7bn0sIGRhdGFPZmZzZXQ9JHtzfSwgc2l6ZT0ke3V9YCksYXdhaXQgby5kb3dubG9hZChuLCgpPT5lLkhFQVBVOC5zdWJhcnJheShzLHMrdSkpfSwobixzLHUpPT5vLmNyZWF0ZUtlcm5lbChuLHMsdSx0LmRlYnVnfHx0LndlYmdwdS5wcm9maWxpbmdNb2RlPT09XCJkZWZhdWx0XCI/ZS5VVEY4VG9TdHJpbmcoZS5fSnNlcEdldE5vZGVOYW1lKHMpKTpgJHtzfWApLG49Pm8ucmVsZWFzZUtlcm5lbChuKSwobixzLHUsZCk9PntFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHt1fSwga2VybmVsPSR7bn0sIGNvbnRleHREYXRhT2Zmc2V0PSR7c31gKTtsZXQgYT1uZXcgem4oZSxvLHMpO3JldHVybiBvLmNvbXB1dGVLZXJuZWwobixhLGQpfSl9fX0pO3ZhciB3bzt3bz11bygpO3ZhciBSdT1nbygpLHBuLGZuPSExLEVyPSExLGJvPSExLFB1PSgpPT57dHJ5e3JldHVybiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCI/ITE6KHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaHtyZXR1cm4hMX19LE11PSgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LEJ1PShlLHQpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXNpbWQud2FzbVwiOnQ/XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCIsdm89YXN5bmMgZT0+e2lmKGZuKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihFcil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBkZXRlY3RlZC5cIik7aWYoYm8pdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBmYWlsZWQuXCIpO0VyPSEwO2xldCB0PWUuaW5pdFRpbWVvdXQscj1lLm51bVRocmVhZHMsbz1lLnNpbWQsbj1yPjEmJlB1KCkscz1vJiZNdSgpLHU9ZS53YXNtUGF0aHMsZD10eXBlb2YgdT09XCJzdHJpbmdcIj91OnZvaWQgMCxhPUJ1KHMsbiksbT10eXBlb2YgdT09XCJvYmplY3RcIj91W2FdOnZvaWQgMCxnPSExLHg9W107aWYodD4wJiZ4LnB1c2gobmV3IFByb21pc2UoYj0+e3NldFRpbWVvdXQoKCk9PntnPSEwLGIoKX0sdCl9KSkseC5wdXNoKG5ldyBQcm9taXNlKChiLHcpPT57bGV0IHY9bj9SdTp3byx5PXtsb2NhdGVGaWxlOihTLEEpPT57aWYobiYmUy5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJnR5cGVvZiBCbG9iPFwidVwiKXJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt5bygpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpO2lmKFMuZW5kc1dpdGgoXCIud2FzbVwiKSl7aWYobSlyZXR1cm4gbTtsZXQgUj1kPz9BO3JldHVybiBhPT09XCJvcnQtd2FzbS1zaW1kLndhc21cIj9SK1wib3J0LXdhc20tc2ltZC5qc2VwLndhc21cIjphPT09XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIj9SK1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIjpSK2F9cmV0dXJuIEErU319O2lmKG4paWYodHlwZW9mIEJsb2I+XCJ1XCIpeS5tYWluU2NyaXB0VXJsT3JCbG9iPSh2b2lkIDApKF9fZGlybmFtZSxcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7bGV0IFM9YHZhciBvcnRXYXNtVGhyZWFkZWQ9JHt2LnRvU3RyaW5nKCl9O2A7eS5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFtTXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9dih5KS50aGVuKFM9PntFcj0hMSxmbj0hMCxwbj1TLGIoKX0sUz0+e0VyPSExLGJvPSEwLHcoUyl9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UoeCksZyl0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LFJlPSgpPT57aWYoZm4mJnBuKXJldHVybiBwbjt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX07dmFyIEJlPShlLHQpPT57bGV0IHI9UmUoKSxvPXIubGVuZ3RoQnl0ZXNVVEY4KGUpKzEsbj1yLl9tYWxsb2Mobyk7cmV0dXJuIHIuc3RyaW5nVG9VVEY4KGUsbixvKSx0LnB1c2gobiksbn0sWnQ9KGUsdCxyLG8pPT57aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXtpZihyLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtyLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbbixzXSk9PntsZXQgdT10P3QrbjpuO2lmKHR5cGVvZiBzPT1cIm9iamVjdFwiKVp0KHMsdStcIi5cIixyLG8pO2Vsc2UgaWYodHlwZW9mIHM9PVwic3RyaW5nXCJ8fHR5cGVvZiBzPT1cIm51bWJlclwiKW8odSxzLnRvU3RyaW5nKCkpO2Vsc2UgaWYodHlwZW9mIHM9PVwiYm9vbGVhblwiKW8odSxzP1wiMVwiOlwiMFwiKTtlbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuXFwndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHN9YCl9KX0sQWU9ZT0+e2xldCB0PVJlKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgbz10LnN0YWNrQWxsb2MoOCk7dC5fT3J0R2V0TGFzdEVycm9yKG8sbys0KTtsZXQgbj10LkhFQVAzMltvLzRdLHM9dC5IRUFQVTMyW28vNCsxXSx1PXM/dC5VVEY4VG9TdHJpbmcocyk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtufSwgRVJST1JfTUVTU0FHRTogJHt1fWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fTt2YXIgJG89ZT0+e2xldCB0PVJlKCkscj0wLG89W10sbj1lfHx7fTt0cnl7aWYoZT8ubG9nU2V2ZXJpdHlMZXZlbD09PXZvaWQgMCluLmxvZ1NldmVyaXR5TGV2ZWw9MjtlbHNlIGlmKHR5cGVvZiBlLmxvZ1NldmVyaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nU2V2ZXJpdHlMZXZlbCl8fGUubG9nU2V2ZXJpdHlMZXZlbDwwfHxlLmxvZ1NldmVyaXR5TGV2ZWw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZihlPy5sb2dWZXJib3NpdHlMZXZlbD09PXZvaWQgMCluLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZih0eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO2U/LnRlcm1pbmF0ZT09PXZvaWQgMCYmKG4udGVybWluYXRlPSExKTtsZXQgcz0wO3JldHVybiBlPy50YWchPT12b2lkIDAmJihzPUJlKGUudGFnLG8pKSxyPXQuX09ydENyZWF0ZVJ1bk9wdGlvbnMobi5sb2dTZXZlcml0eUxldmVsLG4ubG9nVmVyYm9zaXR5TGV2ZWwsISFuLnRlcm1pbmF0ZSxzKSxyPT09MCYmQWUoXCJDYW5cXCd0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksZT8uZXh0cmEhPT12b2lkIDAmJlp0KGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwodSxkKT0+e2xldCBhPUJlKHUsbyksbT1CZShkLG8pO3QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHIsYSxtKSE9PTAmJkFlKGBDYW5cXCd0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dX0gLSAke2R9LmApfSksW3Isb119Y2F0Y2gocyl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKHIpLG8uZm9yRWFjaCh1PT50Ll9mcmVlKHUpKSxzfX07dmFyIGt1PWU9Pntzd2l0Y2goZSl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7ZX1gKX19LER1PWU9Pntzd2l0Y2goZSl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke2V9YCl9fSxXdT1lPT57ZS5leHRyYXx8KGUuZXh0cmE9e30pLGUuZXh0cmEuc2Vzc2lvbnx8KGUuZXh0cmEuc2Vzc2lvbj17fSk7bGV0IHQ9ZS5leHRyYS5zZXNzaW9uO3QudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseXx8KHQudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseT1cIjFcIiksZS5leGVjdXRpb25Qcm92aWRlcnMmJmUuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUocj0+KHR5cGVvZiByPT1cInN0cmluZ1wiP3I6ci5uYW1lKT09PVwid2ViZ3B1XCIpJiYoZS5lbmFibGVNZW1QYXR0ZXJuPSExKX0senU9KGUsdCxyKT0+e2ZvcihsZXQgbyBvZiB0KXtsZXQgbj10eXBlb2Ygbz09XCJzdHJpbmdcIj9vOm8ubmFtZTtzd2l0Y2gobil7Y2FzZVwieG5ucGFja1wiOm49XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2Vibm5cIjppZihuPVwiV0VCTk5cIix0eXBlb2YgbyE9XCJzdHJpbmdcIil7bGV0IHU9bztpZih1Py5kZXZpY2VUeXBlKXtsZXQgZD1CZShcImRldmljZVR5cGVcIixyKSxhPUJlKHUuZGV2aWNlVHlwZSxyKTtSZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxkLGEpIT09MCYmQWUoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6IFxcJ2RldmljZVR5cGVcXCcgLSAke3UuZGV2aWNlVHlwZX0uYCl9aWYodT8ucG93ZXJQcmVmZXJlbmNlKXtsZXQgZD1CZShcInBvd2VyUHJlZmVyZW5jZVwiLHIpLGE9QmUodS5wb3dlclByZWZlcmVuY2Uscik7UmUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsZCxhKSE9PTAmJkFlKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdwb3dlclByZWZlcmVuY2VcXCcgLSAke3UucG93ZXJQcmVmZXJlbmNlfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYobj1cIkpTXCIsdHlwZW9mIG8hPVwic3RyaW5nXCIpe2xldCB1PW87aWYodT8ucHJlZmVycmVkTGF5b3V0KXtpZih1LnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZ1LnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyIFxcJ05DSFdcXCcgb3IgXFwnTkhXQ1xcJzogJHt1LnByZWZlcnJlZExheW91dH1gKTtsZXQgZD1CZShcInByZWZlcnJlZExheW91dFwiLHIpLGE9QmUodS5wcmVmZXJyZWRMYXlvdXQscik7UmUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsZCxhKSE9PTAmJkFlKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdwcmVmZXJyZWRMYXlvdXRcXCcgLSAke3UucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtufWApfWxldCBzPUJlKG4scik7UmUoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxzKSE9PTAmJkFlKGBDYW5cXCd0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7bn0uYCl9fSx4bz1lPT57bGV0IHQ9UmUoKSxyPTAsbz1bXSxuPWV8fHt9O1d1KG4pO3RyeXtsZXQgcz1rdShuLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLHU9RHUobi5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIiksZD10eXBlb2Ygbi5sb2dJZD09XCJzdHJpbmdcIj9CZShuLmxvZ0lkLG8pOjAsYT1uLmxvZ1NldmVyaXR5TGV2ZWw/PzI7aWYoIU51bWJlci5pc0ludGVnZXIoYSl8fGE8MHx8YT40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7YX1gKTtsZXQgbT1uLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG0pfHxtPDB8fG0+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke219YCk7bGV0IGc9dHlwZW9mIG4ub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9CZShuLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsbyk6MDtpZihyPXQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHMsISFuLmVuYWJsZUNwdU1lbUFyZW5hLCEhbi5lbmFibGVNZW1QYXR0ZXJuLHUsISFuLmVuYWJsZVByb2ZpbGluZywwLGQsYSxtLGcpLHI9PT0wJiZBZShcIkNhblxcJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksbi5leGVjdXRpb25Qcm92aWRlcnMmJnp1KHIsbi5leGVjdXRpb25Qcm92aWRlcnMsbyksbi5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbeCxiXW9mIE9iamVjdC5lbnRyaWVzKG4uZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiB4IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke3h9YCk7aWYodHlwZW9mIGIhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGIpfHxiPDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7Yn1gKTtsZXQgdz1CZSh4LG8pO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShyLHcsYikhPT0wJiZBZShgQ2FuXFwndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHt4fSAtICR7Yn0uYCl9cmV0dXJuIG4uZXh0cmEhPT12b2lkIDAmJlp0KG4uZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoeCxiKT0+e2xldCB3PUJlKHgsbyksdj1CZShiLG8pO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShyLHcsdikhPT0wJiZBZShgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHt4fSAtICR7Yn0uYCl9KSxbcixvXX1jYXRjaChzKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHIpLG8uZm9yRWFjaCh1PT50Ll9mcmVlKHUpKSxzfX07RGUoKTt2YXIgcnU9ITEsc2M9ZT0+e2xldCB0PVJlKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgbz10LnN0YWNrQWxsb2MoOCk7cmV0dXJuIHQuX09ydEdldElucHV0T3V0cHV0Q291bnQoZSxvLG8rNCkhPT0wJiZBZShcIkNhblxcJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKSxbdC5IRUFQMzJbby80XSx0LkhFQVAzMltvLzQrMV1dfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSx1Yz0oZSx0KT0+e1JlKCkuX09ydEluaXQoZSx0KSE9PTAmJkFlKFwiQ2FuXFwndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sbnU9YXN5bmMgZT0+e3VjKGUud2FzbS5udW1UaHJlYWRzLHRyKGUubG9nTGV2ZWwpKTt7bGV0IHQ9KGV1KCksTXQoUXMpKS5pbml0O2F3YWl0IHQoUmUoKSxlKX1ydT0hMH0sdXI9bmV3IE1hcCxvdT0oKT0+cnUsVm49ZT0+e2xldCB0PVJlKCkscj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihyPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSxHbj0oZSx0KT0+e2xldCByPVJlKCksbz0wLG49MCxzPTAsdT1bXSxkPVtdLGE9W107dHJ5e1tuLHVdPXhvKHQpLG89ci5fT3J0Q3JlYXRlU2Vzc2lvbihlWzBdLGVbMV0sbiksbz09PTAmJkFlKFwiQ2FuXFwndCBjcmVhdGUgYSBzZXNzaW9uLlwiKTtsZXRbbSxnXT1zYyhvKSx4PVtdLGI9W10sdz1bXTtmb3IobGV0IHk9MDt5PG07eSsrKXtsZXQgUz1yLl9PcnRHZXRJbnB1dE5hbWUobyx5KTtTPT09MCYmQWUoXCJDYW5cXCd0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxkLnB1c2goUykseC5wdXNoKHIuVVRGOFRvU3RyaW5nKFMpKX1mb3IobGV0IHk9MDt5PGc7eSsrKXtsZXQgUz1yLl9PcnRHZXRPdXRwdXROYW1lKG8seSk7Uz09PTAmJkFlKFwiQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLGEucHVzaChTKTtsZXQgQT1yLlVURjhUb1N0cmluZyhTKTtiLnB1c2goQSk7e2xldCBSPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bQV0/P1wiY3B1XCI7aWYoUiE9PVwiY3B1XCImJlIhPT1cImNwdS1waW5uZWRcIiYmUiE9PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke1J9LmApO3cucHVzaChSKX19bGV0IHY9bnVsbDtyZXR1cm4gdy5zb21lKHk9Pnk9PT1cImdwdS1idWZmZXJcIikmJihzPXIuX09ydENyZWF0ZUJpbmRpbmcobykscz09PTAmJkFlKFwiQ2FuXFwndCBjcmVhdGUgSU8gYmluZGluZy5cIiksdj17aGFuZGxlOnMsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOncsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDp3Lm1hcCh5PT5obih5KSl9KSx1ci5zZXQobyxbbyxkLGEsdl0pLFtvLHgsYl19Y2F0Y2gobSl7dGhyb3cgZC5mb3JFYWNoKGc9PnIuX09ydEZyZWUoZykpLGEuZm9yRWFjaChnPT5yLl9PcnRGcmVlKGcpKSxzIT09MCYmci5fT3J0UmVsZWFzZUJpbmRpbmcocyksbyE9PTAmJnIuX09ydFJlbGVhc2VTZXNzaW9uKG8pLG19ZmluYWxseXtyLl9mcmVlKGVbMF0pLG4hPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobiksdS5mb3JFYWNoKG09PnIuX2ZyZWUobSkpfX0sYXU9KGUsdCk9PntsZXQgcj1WbihlKTtyZXR1cm4gR24ocix0KX0saXU9ZT0+e2xldCB0PVJlKCkscj11ci5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbbyxuLHMsdV09cjt1JiZ0Ll9PcnRSZWxlYXNlQmluZGluZyh1LmhhbmRsZSksdC5qc2VwVW5yZWdpc3RlckJ1ZmZlcnM/LihlKSxuLmZvckVhY2goZD0+dC5fT3J0RnJlZShkKSkscy5mb3JFYWNoKGQ9PnQuX09ydEZyZWUoZCkpLHQuX09ydFJlbGVhc2VTZXNzaW9uKG8pLHVyLmRlbGV0ZShlKX0sdHU9KGUsdCxyLG8sbik9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgcz1SZSgpLHU9ZVswXSxkPWVbMV0sYT1lWzNdLG0sZztpZih1PT09XCJzdHJpbmdcIiYmYT09PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2lmKGE9PT1cImdwdS1idWZmZXJcIil7bGV0IHc9ZVsyXS5ncHVCdWZmZXIsdj1lcihtbih1KSk7Zz1kLnJlZHVjZSgoeSxTKT0+eSpTLDEpKnYsbT1zLmpzZXBSZWdpc3RlckJ1ZmZlcihvLG4sdyxnKX1lbHNle2xldCB3PWVbMl07aWYoQXJyYXkuaXNBcnJheSh3KSl7Zz00KncubGVuZ3RoLG09cy5fbWFsbG9jKGcpLHIucHVzaChtKTtsZXQgdj1tLzQ7Zm9yKGxldCB5PTA7eTx3Lmxlbmd0aDt5Kyspe2lmKHR5cGVvZiB3W3ldIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7eX0gaXMgbm90IGEgc3RyaW5nYCk7cy5IRUFQVTMyW3YrK109QmUod1t5XSxyKX19ZWxzZSBnPXcuYnl0ZUxlbmd0aCxtPXMuX21hbGxvYyhnKSxyLnB1c2gobSkscy5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHcuYnVmZmVyLHcuYnl0ZU9mZnNldCxnKSxtKX1sZXQgeD1zLnN0YWNrU2F2ZSgpLGI9cy5zdGFja0FsbG9jKDQqZC5sZW5ndGgpO3RyeXtsZXQgdz1iLzQ7ZC5mb3JFYWNoKHk9PnMuSEVBUDMyW3crK109eSk7bGV0IHY9cy5fT3J0Q3JlYXRlVGVuc29yKG1uKHUpLG0sZyxiLGQubGVuZ3RoLGhuKGEpKTt2PT09MCYmQWUoYENhblxcJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7b30sIGluZGV4PSR7bn0uYCksdC5wdXNoKHYpfWZpbmFsbHl7cy5zdGFja1Jlc3RvcmUoeCl9fSxzdT1hc3luYyhlLHQscixvLG4scyk9PntsZXQgdT1SZSgpLGQ9dXIuZ2V0KGUpO2lmKCFkKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFthLG0sZyx4XT1kLGI9dC5sZW5ndGgsdz1vLmxlbmd0aCx2PTAseT1bXSxTPVtdLEE9W10sUj1bXSxXPXUuc3RhY2tTYXZlKCksTT11LnN0YWNrQWxsb2MoYio0KSxEPXUuc3RhY2tBbGxvYyhiKjQpLF89dS5zdGFja0FsbG9jKHcqNCksej11LnN0YWNrQWxsb2Modyo0KTt0cnl7W3YseV09JG8ocyk7Zm9yKGxldCBhZT0wO2FlPGI7YWUrKyl0dShyW2FlXSxTLFIsZSx0W2FlXSk7Zm9yKGxldCBhZT0wO2FlPHc7YWUrKyl0dShuW2FlXSxBLFIsZSxiK29bYWVdKTtsZXQgRj1NLzQscT1ELzQsbGU9Xy80LEI9ei80O2ZvcihsZXQgYWU9MDthZTxiO2FlKyspdS5IRUFQVTMyW0YrK109U1thZV0sdS5IRUFQVTMyW3ErK109bVt0W2FlXV07Zm9yKGxldCBhZT0wO2FlPHc7YWUrKyl1LkhFQVBVMzJbbGUrK109QVthZV0sdS5IRUFQVTMyW0IrK109Z1tvW2FlXV07aWYoeCl7bGV0e2hhbmRsZTphZSxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6d2Usb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDpqfT14O2lmKG0ubGVuZ3RoIT09Yil0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7Yn0pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbFxcJ3MgaW5wdXQgY291bnQgKCR7bS5sZW5ndGh9KS5gKTtmb3IobGV0IFNlPTA7U2U8YjtTZSsrKXtsZXQgT2U9dFtTZV07YXdhaXQgdS5fT3J0QmluZElucHV0KGFlLG1bT2VdLFNbU2VdKSE9PTAmJkFlKGBDYW5cXCd0IGJpbmQgaW5wdXRbJHtTZX1dIGZvciBzZXNzaW9uPSR7ZX0uYCl9Zm9yKGxldCBTZT0wO1NlPHc7U2UrKyl7bGV0IE9lPW9bU2VdO25bU2VdPy5bM10/dS5fT3J0QmluZE91dHB1dChhZSxnW09lXSxBW1NlXSwwKSE9PTAmJkFlKGBDYW5cXCd0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtTZX1dIGZvciBzZXNzaW9uPSR7ZX0uYCk6dS5fT3J0QmluZE91dHB1dChhZSxnW09lXSwwLGpbT2VdKSE9PTAmJkFlKGBDYW5cXCd0IGJpbmQgb3V0cHV0WyR7U2V9XSB0byAke3dlW1NlXX0gZm9yIHNlc3Npb249JHtlfS5gKX19bGV0IEs7eD9LPWF3YWl0IHUuX09ydFJ1bldpdGhCaW5kaW5nKGEseC5oYW5kbGUsdyxfLHYpOks9YXdhaXQgdS5fT3J0UnVuKGEsRCxNLGIseix3LF8sdiksSyE9PTAmJkFlKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2xldCB4ZT1bXTtmb3IobGV0IGFlPTA7YWU8dzthZSsrKXtsZXQgd2U9dS5IRUFQVTMyW18vNCthZV07aWYod2U9PT1BW2FlXSl7eGUucHVzaChuW2FlXSk7Y29udGludWV9bGV0IGo9dS5zdGFja1NhdmUoKSxTZT11LnN0YWNrQWxsb2MoNCo0KSxPZT0hMSxJZSxDZT0wO3RyeXt1Ll9PcnRHZXRUZW5zb3JEYXRhKHdlLFNlLFNlKzQsU2UrOCxTZSsxMikhPT0wJiZBZShgQ2FuXFwndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7YWV9LmApO2xldCBOZT1TZS80LExlPXUuSEVBUFUzMltOZSsrXTtDZT11LkhFQVBVMzJbTmUrK107bGV0IE49dS5IRUFQVTMyW05lKytdLGRlPXUuSEVBUFUzMltOZSsrXSxwZT1bXTtmb3IobGV0IFRlPTA7VGU8ZGU7VGUrKylwZS5wdXNoKHUuSEVBUFUzMltOLzQrVGVdKTt1Ll9PcnRGcmVlKE4pO2xldCB6ZT1wZS5yZWR1Y2UoKFRlLGtlKT0+VGUqa2UsMSk7SWU9UXQoTGUpO2xldCBVZT14Py5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbb1thZV1dO2lmKEllPT09XCJzdHJpbmdcIil7aWYoVWU9PT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtsZXQgVGU9W10sa2U9Q2UvNDtmb3IobGV0IEdlPTA7R2U8emU7R2UrKyl7bGV0IFhlPXUuSEVBUFUzMltrZSsrXSxGZT1HZT09PXplLTE/dm9pZCAwOnUuSEVBUFUzMltrZV0tWGU7VGUucHVzaCh1LlVURjhUb1N0cmluZyhYZSxGZSkpfXhlLnB1c2goW0llLHBlLFRlLFwiY3B1XCJdKX1lbHNlIGlmKFVlPT09XCJncHUtYnVmZmVyXCImJnplPjApe2xldCBUZT11LmpzZXBHZXRCdWZmZXIoQ2UpLGtlPWVyKExlKTtpZihrZT09PXZvaWQgMHx8IVNvKEllKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtJZX1gKTtPZT0hMCx4ZS5wdXNoKFtJZSxwZSx7Z3B1QnVmZmVyOlRlLGRvd25sb2FkOnUuanNlcENyZWF0ZURvd25sb2FkZXIoVGUsemUqa2UsSWUpLGRpc3Bvc2U6KCk9Pnt1Ll9PcnRSZWxlYXNlVGVuc29yKHdlKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZXtsZXQgVGU9VHIoSWUpLGtlPW5ldyBUZSh6ZSk7bmV3IFVpbnQ4QXJyYXkoa2UuYnVmZmVyLGtlLmJ5dGVPZmZzZXQsa2UuYnl0ZUxlbmd0aCkuc2V0KHUuSEVBUFU4LnN1YmFycmF5KENlLENlK2tlLmJ5dGVMZW5ndGgpKSx4ZS5wdXNoKFtJZSxwZSxrZSxcImNwdVwiXSl9fWZpbmFsbHl7dS5zdGFja1Jlc3RvcmUoaiksSWU9PT1cInN0cmluZ1wiJiZDZSYmdS5fZnJlZShDZSksT2V8fHUuX09ydFJlbGVhc2VUZW5zb3Iod2UpfX1yZXR1cm4geCYmdS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoeC5oYW5kbGUpLHhlfWZpbmFsbHl7dS5zdGFja1Jlc3RvcmUoVyksUy5mb3JFYWNoKEY9PnUuX09ydFJlbGVhc2VUZW5zb3IoRikpLEEuZm9yRWFjaChGPT51Ll9PcnRSZWxlYXNlVGVuc29yKEYpKSxSLmZvckVhY2goRj0+dS5fZnJlZShGKSksdiE9PTAmJnUuX09ydFJlbGVhc2VSdW5PcHRpb25zKHYpLHkuZm9yRWFjaChGPT51Ll9mcmVlKEYpKX19LHV1PWU9PntsZXQgdD1SZSgpLHI9dXIuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtsZXQgbz1yWzBdLG49dC5fT3J0RW5kUHJvZmlsaW5nKG8pO249PT0wJiZBZShcIkNhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG4pfSxsdT1lPT57bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpe2xldCBvPXJbMl07IUFycmF5LmlzQXJyYXkobykmJlwiYnVmZmVyXCJpbiBvJiZ0LnB1c2goby5idWZmZXIpfXJldHVybiB0fTtzZWxmLm9ubWVzc2FnZT1lPT57c3dpdGNoKGUuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjp0cnl7dm8oZS5kYXRhLmluKS50aGVuKCgpPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwifSksdD0+cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LXdhc21cIixlcnI6dH0pKX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiaW5pdC1vcnRcIjp0cnl7bnUoZS5kYXRhLmluKS50aGVuKCgpPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCJ9KSx0PT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCIsZXJyOnR9KSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2FsbG9jYXRlXCI6dHJ5e2xldHttb2RlbDp0fT1lLmRhdGEuaW4scj1Wbih0KTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLG91dDpyfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcImNyZWF0ZV9maW5hbGl6ZVwiOnRyeXtsZXR7bW9kZWxkYXRhOnQsb3B0aW9uczpyfT1lLmRhdGEuaW4sbz1Hbih0LHIpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsb3V0Om99KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlXCI6dHJ5e2xldHttb2RlbDp0LG9wdGlvbnM6cn09ZS5kYXRhLmluLG89YXUodCxyKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZVwiLG91dDpvfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcInJlbGVhc2VcIjp0cnl7bGV0IHQ9ZS5kYXRhLmluO2l1KHQpLHBvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJydW5cIjp0cnl7bGV0e3Nlc3Npb25JZDp0LGlucHV0SW5kaWNlczpyLGlucHV0czpvLG91dHB1dEluZGljZXM6bixvcHRpb25zOnN9PWUuZGF0YS5pbjtzdSh0LHIsbyxuLHMpLnRoZW4odT0+e3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsb3V0OnV9LGx1KHUpKX0sdT0+e3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsZXJyOnV9KX0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsZXJyOnR9KX1icmVhaztjYXNlXCJlbmQtcHJvZmlsaW5nXCI6dHJ5e2xldCB0PWUuZGF0YS5pbjt1dSh0KSxwb3N0TWVzc2FnZSh7dHlwZTpcImVuZC1wcm9maWxpbmdcIn0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGVycjp0fSl9YnJlYWs7Y2FzZVwiaXMtb3J0LWVudi1pbml0aWFsaXplZFwiOnRyeXtsZXQgdD1vdSgpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiaXMtb3J0LWVudi1pbml0aWFsaXplZFwiLG91dDp0fSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpcy1vcnQtZW52LWluaXRpYWxpemVkXCIsZXJyOnR9KX1icmVhaztkZWZhdWx0On19O30pKCk7XFxuLyoqXFxuICogQGxpY2Vuc2VcXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XFxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxcbiAqXFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxuICpcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAqL1xcbi8qKlxcbiAqIEBsaWNlbnNlXFxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXG4gKlxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcbiAqXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gKi9cXG4vKipcXG4gKiBAbGljZW5zZVxcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXFxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XFxuICpcXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcXG4gKlxcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICovXFxuJ30pO3ZhciBodCxqZSxibiwkYSx4YSxwYSxmYSxtYSxoYSxnYSx5YSxiYSx3YSx2YSxJdCx2cCx5bixzbCx1bCxsbCxkbCxTYSxjbCxwbCxmbCxtbCxDYT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHQoKTtvbCgpO0h0KCk7aHQ9KCk9PiEhSWUud2FzbS5wcm94eSYmdHlwZW9mIGRvY3VtZW50PFwidVwiLGJuPSExLCRhPSExLHhhPSExLG1hPVtdLGhhPVtdLGdhPVtdLHlhPVtdLGJhPVtdLHdhPVtdLHZhPVtdLEl0PSgpPT57aWYoYm58fCEkYXx8eGF8fCFqZSl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSx2cD1lPT57c3dpdGNoKGUuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjpibj0hMSxlLmRhdGEuZXJyPyh4YT0hMCxwYVsxXShlLmRhdGEuZXJyKSk6KCRhPSEwLHBhWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6ZS5kYXRhLmVycj9mYVsxXShlLmRhdGEuZXJyKTpmYVswXSgpO2JyZWFrO2Nhc2VcImNyZWF0ZV9hbGxvY2F0ZVwiOmUuZGF0YS5lcnI/bWEuc2hpZnQoKVsxXShlLmRhdGEuZXJyKTptYS5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZV9maW5hbGl6ZVwiOmUuZGF0YS5lcnI/aGEuc2hpZnQoKVsxXShlLmRhdGEuZXJyKTpoYS5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZVwiOmUuZGF0YS5lcnI/Z2Euc2hpZnQoKVsxXShlLmRhdGEuZXJyKTpnYS5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcInJlbGVhc2VcIjplLmRhdGEuZXJyP3lhLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6eWEuc2hpZnQoKVswXSgpO2JyZWFrO2Nhc2VcInJ1blwiOmUuZGF0YS5lcnI/YmEuc2hpZnQoKVsxXShlLmRhdGEuZXJyKTpiYS5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjplLmRhdGEuZXJyP3dhLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6d2Euc2hpZnQoKVswXSgpO2JyZWFrO2Nhc2VcImlzLW9ydC1lbnYtaW5pdGlhbGl6ZWRcIjplLmRhdGEuZXJyP3ZhLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6dmEuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztkZWZhdWx0On19LHluPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjOnZvaWQgMCxzbD1hc3luYygpPT57aWYoaHQoKSl7aWYoJGEpcmV0dXJuO2lmKGJuKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7aWYoeGEpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtyZXR1cm4gYm49ITAsSWUud2FzbS53YXNtUGF0aHM9PT12b2lkIDAmJnluJiZ5bi5pbmRleE9mKFwiYmxvYjpcIikhPT0wJiYoSWUud2FzbS53YXNtUGF0aHM9eW4uc3Vic3RyKDAsK3luLmxhc3RJbmRleE9mKFwiL1wiKSsxKSksbmV3IFByb21pc2UoKGUsdCk9PntqZT8udGVybWluYXRlKCk7bGV0IHI9VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbaWwoKV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTtqZT1uZXcgV29ya2VyKHIse25hbWU6XCJvcnQtd2FzbS1wcm94eS13b3JrZXJcIn0pLGplLm9uZXJyb3I9bj0+dChuKSxqZS5vbm1lc3NhZ2U9dnAsVVJMLnJldm9rZU9iamVjdFVSTChyKSxwYT1bZSx0XTtsZXQgYT17dHlwZTpcImluaXQtd2FzbVwiLGluOkllLndhc219O2plLnBvc3RNZXNzYWdlKGEpfSl9ZWxzZSByZXR1cm4gUG8oSWUud2FzbSl9LHVsPWFzeW5jIGU9PntpZihodCgpKXJldHVybiBJdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57ZmE9W3Qscl07bGV0IGE9e3R5cGU6XCJpbml0LW9ydFwiLGluOmV9O2plLnBvc3RNZXNzYWdlKGEpfSk7YXdhaXQgUXUoZSl9LGxsPWFzeW5jIGU9Pmh0KCk/KEl0KCksbmV3IFByb21pc2UoKHQscik9PnttYS5wdXNoKFt0LHJdKTtsZXQgYT17dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGluOnttb2RlbDplfX07amUucG9zdE1lc3NhZ2UoYSxbZS5idWZmZXJdKX0pKTpkYShlKSxkbD1hc3luYyhlLHQpPT5odCgpPyhJdCgpLG5ldyBQcm9taXNlKChyLGEpPT57aGEucHVzaChbcixhXSk7bGV0IG49e3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixpbjp7bW9kZWxkYXRhOmUsb3B0aW9uczp0fX07amUucG9zdE1lc3NhZ2Uobil9KSk6Y2EoZSx0KSxTYT1hc3luYyhlLHQpPT57aWYoaHQoKSl7aWYodD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7cmV0dXJuIEl0KCksbmV3IFByb21pc2UoKHIsYSk9PntnYS5wdXNoKFtyLGFdKTtsZXQgbj17dHlwZTpcImNyZWF0ZVwiLGluOnttb2RlbDplLG9wdGlvbnM6dH19O2plLnBvc3RNZXNzYWdlKG4sW2UuYnVmZmVyXSl9KX1lbHNlIHJldHVybiBlbChlLHQpfSxjbD1hc3luYyBlPT57aWYoaHQoKSlyZXR1cm4gSXQoKSxuZXcgUHJvbWlzZSgodCxyKT0+e3lhLnB1c2goW3Qscl0pO2xldCBhPXt0eXBlOlwicmVsZWFzZVwiLGluOmV9O2plLnBvc3RNZXNzYWdlKGEpfSk7dGwoZSl9LHBsPWFzeW5jKGUsdCxyLGEsbixzKT0+e2lmKGh0KCkpe2lmKHIuc29tZSh1PT51WzNdIT09XCJjcHVcIikpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7aWYobi5zb21lKHU9PnUpKXRocm93IG5ldyBFcnJvcihcInByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7cmV0dXJuIEl0KCksbmV3IFByb21pc2UoKHUsbCk9PntiYS5wdXNoKFt1LGxdKTtsZXQgbz1yLHA9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnQsaW5wdXRzOm8sb3V0cHV0SW5kaWNlczphLG9wdGlvbnM6c319O2plLnBvc3RNZXNzYWdlKHAsYWwobykpfSl9ZWxzZSByZXR1cm4gcmwoZSx0LHIsYSxuLHMpfSxmbD1hc3luYyBlPT57aWYoaHQoKSlyZXR1cm4gSXQoKSxuZXcgUHJvbWlzZSgodCxyKT0+e3dhLnB1c2goW3Qscl0pO2xldCBhPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O2plLnBvc3RNZXNzYWdlKGEpfSk7bmwoZSl9LG1sPWFzeW5jKCk9Pmh0KCk/KEl0KCksbmV3IFByb21pc2UoKGUsdCk9Pnt2YS5wdXNoKFtlLHRdKTtsZXQgcj17dHlwZTpcImlzLW9ydC1lbnYtaW5pdGlhbGl6ZWRcIn07amUucG9zdE1lc3NhZ2Uocil9KSk6WnUoKX0pO3ZhciB3bixobCwkcCx2bixnbD1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHQoKTtDYSgpO0RlKCk7aGw9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlLmxvY2F0aW9ufSBmb3IgJHt0KCl9YCl9fSwkcD1lPT57c3dpdGNoKGVbM10pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgVWUoZVswXSxlWzJdLGVbMV0pO2Nhc2VcImdwdS1idWZmZXJcIjp7bGV0IHQ9ZVswXTtpZighWXIodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7bGV0e2dwdUJ1ZmZlcjpyLGRvd25sb2FkOmEsZGlzcG9zZTpufT1lWzJdO3JldHVybiBVZS5mcm9tR3B1QnVmZmVyKHIse2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOmEsZGlzcG9zZTpufSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlWzNdfWApfX0sdm49Y2xhc3N7YXN5bmMgY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKHQpe2xldCByPWF3YWl0IGZldGNoKHQpO2lmKHIuc3RhdHVzIT09MjAwKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgbW9kZWw6ICR7dH1gKTtsZXQgYT1hd2FpdCByLmFycmF5QnVmZmVyKCk7cmV0dXJuIGxsKG5ldyBVaW50OEFycmF5KGEpKX1hc3luYyBsb2FkTW9kZWwodCxyKXtpZihhd2FpdCBtbCgpfHwod258fCh3bj11bChJZSkpLGF3YWl0IHduLHduPXZvaWQgMCksdHlwZW9mIHQ9PVwic3RyaW5nXCIpaWYodHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSl7bGV0IGE9YXdhaXQodm9pZCAwKSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0IFNhKGEscil9ZWxzZXtsZXQgYT1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0IGRsKGEscil9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgU2EodCxyKX1hc3luYyBkaXNwb3NlKCl7cmV0dXJuIGNsKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxyLGEpe2xldCBuPVtdLHM9W107T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaChnPT57bGV0IHY9Z1swXSwkPWdbMV0sYj10aGlzLmlucHV0TmFtZXMuaW5kZXhPZih2KTtpZihiPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke3Z9J2ApO24ucHVzaCgkKSxzLnB1c2goYil9KTtsZXQgdT1bXSxsPVtdO09iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goZz0+e2xldCB2PWdbMF0sJD1nWzFdLGI9dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHYpO2lmKGI9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke3Z9J2ApO3UucHVzaCgkKSxsLnB1c2goYil9KTtsZXQgbz1uLm1hcCgoZyx2KT0+aGwoZywoKT0+YGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbc1t2XV19XCJgKSkscD11Lm1hcCgoZyx2KT0+Zz9obChnLCgpPT5gb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW2xbdl1dfVwiYCk6bnVsbCksbT1hd2FpdCBwbCh0aGlzLnNlc3Npb25JZCxzLG8sbCxwLGEpLHk9e307Zm9yKGxldCBnPTA7ZzxtLmxlbmd0aDtnKyspeVt0aGlzLm91dHB1dE5hbWVzW2xbZ11dXT11W2ddPz8kcChtW2ddKTtyZXR1cm4geX1zdGFydFByb2ZpbGluZygpe31lbmRQcm9maWxpbmcoKXtmbCh0aGlzLnNlc3Npb25JZCl9fX0pO3ZhciB4cCwkbix5bD1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHQoKTtDYSgpO2dsKCk7eHA9KCk9PntpZigodHlwZW9mIEllLndhc20uaW5pdFRpbWVvdXQhPVwibnVtYmVyXCJ8fEllLndhc20uaW5pdFRpbWVvdXQ8MCkmJihJZS53YXNtLmluaXRUaW1lb3V0PTApLHR5cGVvZiBJZS53YXNtLnNpbWQhPVwiYm9vbGVhblwiJiYoSWUud2FzbS5zaW1kPSEwKSx0eXBlb2YgSWUud2FzbS5wcm94eSE9XCJib29sZWFuXCImJihJZS53YXNtLnByb3h5PSExKSx0eXBlb2YgSWUud2FzbS5udW1UaHJlYWRzIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihJZS53YXNtLm51bVRocmVhZHMpfHxJZS53YXNtLm51bVRocmVhZHM8PTApe2xldCBlPXR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCI/KHZvaWQgMCkoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7SWUud2FzbS5udW1UaHJlYWRzPU1hdGgubWluKDQsTWF0aC5jZWlsKChlfHwxKS8yKSl9fSwkbj1jbGFzc3thc3luYyBpbml0KCl7eHAoKSxhd2FpdCBzbCgpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQscil7bGV0IGE9bmV3IHZuO3JldHVybiBhd2FpdCBhLmxvYWRNb2RlbCh0LHIpLFByb21pc2UucmVzb2x2ZShhKX19fSk7dmFyIGJsPXt9O2t0KGJsLHt3YXNtQmFja2VuZDooKT0+U3B9KTt2YXIgU3Asd2w9TCgoKT0+e1widXNlIHN0cmljdFwiO3lsKCk7U3A9bmV3ICRufSk7dmFyIElwPXt9O2t0KElwLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5wbyxUZW5zb3I6KCk9PlVlLFRyYWluaW5nU2Vzc2lvbjooKT0+Z28sZGVmYXVsdDooKT0+Q3AsZW52OigpPT5JZSxyZWdpc3RlckJhY2tlbmQ6KCk9PmZ0fSk7bW9kdWxlLmV4cG9ydHM9dnQoSXApOyR0KCk7JHQoKTskdCgpO3ZhciBibz1cIjEuMTcuMC1kZXYuMjAyMzExMDMtMTQzOWRhMzZmZVwiO3ZhciBDcD1Sbjt7bGV0IGU9KHdsKCksdnQoYmwpKS53YXNtQmFja2VuZDt0eXBlb2YgbmF2aWdhdG9yPFwidVwiJiZuYXZpZ2F0b3IuZ3B1JiZmdChcIndlYmdwdVwiLGUsNSksZnQoXCJjcHVcIixlLDEwKSxmdChcIndhc21cIixlLDEwKSxmdChcInhubnBhY2tcIixlLDkpLGZ0KFwid2Vibm5cIixlLDkpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZS52ZXJzaW9ucyxcIndlYlwiLHt2YWx1ZTpibyxlbnVtZXJhYmxlOiEwfSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQud2ViZ3B1Lm1pbi5qcy5tYXBcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsImNvbnN0IG9ydCA9IHJlcXVpcmUoJ29ubnhydW50aW1lLXdlYi93ZWJncHUnKTtcblxuY29uc3QgTUFYX1dJRFRIID0gMjg7XG5jb25zdCBNQVhfSEVJR0hUID0gMjg7XG5jb25zdCBNT0RFTF9XSURUSCA9IDI4O1xuY29uc3QgTU9ERUxfSEVJR0hUID0gMjg7XG5cbmNvbnN0IE1PREVMX01BUCA9IHtcbiAgICBzYW1fYjogW1wibW9kZWxzL21uaXN0X2Nubi5vbm54XCJdLFxufTtcblxuY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKCk7XG5cbm9ydC5lbnYud2FzbS5udW1UaHJlYWRzID0gY29uZmlnLnRocmVhZHM7XG5vcnQuZW52Lndhc20ucHJveHkgPSB0cnVlO1xuXG5sZXQgY2FudmFzO1xubGV0IGZpbGVpbjtcbmxldCBkZWNvZGVyX2xhdGVuY3k7XG5cbnZhciBpbWFnZV9lbWJlZGRpbmdzO1xudmFyIHNlc3MgPSBbXTtcbnZhciBpbWFnZUltYWdlRGF0YTtcblxuZnVuY3Rpb24gbG9nKGkpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdHVzJykuaW5uZXJUZXh0ICs9IGBcXG5bJHtwZXJmb3JtYW5jZS5ub3coKS50b0ZpeGVkKDMpfV0gYCArIGk7XG4gICAgY29uc29sZS5sb2coaSk7XG59XG5cbi8qKlxuICogZ2V0IHNvbWUgcGFyYW1ldGVycyBmcm9tIHVybFxuICovXG5mdW5jdGlvbiBnZXRDb25maWcoKSB7XG4gICAgY29uc3QgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBtb2RlbDogXCJzYW1fYlwiLFxuICAgICAgICBwcm92aWRlcjogXCJ3ZWJncHVcIixcbiAgICAgICAgZGV2aWNlOiBcImdwdVwiLFxuICAgICAgICB0aHJlYWRzOiBcIjFcIixcbiAgICB9O1xuICAgIGxldCB2YXJzID0gcXVlcnkuc3BsaXQoXCImXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcGFpciA9IHZhcnNbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBpZiAocGFpclswXSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZ1twYWlyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gYXJndW1lbnQ6IFwiICsgcGFpclswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uZmlnLnRocmVhZHMgPSBwYXJzZUludChjb25maWcudGhyZWFkcyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzaXplVGVuc29yKG9yaWdpbmFsVGVuc29yKSB7XG4gICAgLy8gQXNzdW1pbmcgJ29yaWdpbmFsVGVuc29yJyBpcyB5b3VyIE9OTlggUnVudGltZSBXZWIgdGVuc29yIHdpdGggZGltZW5zaW9ucyBbMSwgMywgMjgsIDI4XVxuICAgIC8vIGNvbnN0IG9yaWdpbmFsU2hhcGUgPSBvcmlnaW5hbFRlbnNvci5kaW1zOyAvLyBHZXQgdGhlIG9yaWdpbmFsIHRlbnNvcidzIGRpbWVuc2lvbnNcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3JcbiAgICAvLyBjb25zdCB0b3RhbEVsZW1lbnRzID0gb3JpZ2luYWxTaGFwZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKiB2YWwpO1xuXG4gICAgLy8gQXNzdW1pbmcgJ29yaWdpbmFsRGF0YScgaXMgeW91ciBGbG9hdDMyQXJyYXkgY29udGFpbmluZyB0aGUgdGVuc29yJ3MgZGF0YVxuICAgIGNvbnN0IG9yaWdpbmFsRGF0YSA9IG9yaWdpbmFsVGVuc29yLmRhdGE7XG5cbiAgICAvLyBSZXNoYXBlIHRoZSB0ZW5zb3IgdG8gWzEsIDEsIDI4LCAyOF1cbiAgICBjb25zdCByZXNoYXBlZFRlbnNvciA9IG5ldyBvcnQuVGVuc29yKG9yaWdpbmFsRGF0YS5zbGljZSgwLCAyOCoyOCksIFsxLCAxLCAyOCwgMjhdKTsgLy8gQWRqdXN0IHRoZSBuZXcgc2hhcGUgYXMgbmVlZGVkXG5cbiAgICAvLyAncmVzaGFwZWRUZW5zb3InIG5vdyBjb250YWlucyB0aGUgZGF0YSBmcm9tICdvcmlnaW5hbFRlbnNvcicgYnV0IHdpdGggdGhlIG5ldyBzaGFwZSBbMSwgMSwgMjgsIDI4XVxuICAgIGxvZyhgcmVzaGFwZWRUZW5zb3IgaXMgJHtyZXNoYXBlZFRlbnNvci5kaW1zfWApO1xuICAgIHJldHVybiByZXNoYXBlZFRlbnNvcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbXVsdGlwbHlUZW5zb3IodGVuc29yLCBzY2FsYXIpIHtcbiAgICAvLyBBc3N1bWluZyAndGVuc29yJyBpcyB5b3VyIE9OTlggUnVudGltZSBXZWIgdGVuc29yXG4gICAgY29uc3QgZGF0YSA9IHRlbnNvci5kYXRhO1xuXG4gICAgLy8gTXVsdGlwbHkgZXZlcnkgZWxlbWVudCBieSAyNTVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSAqPSBzY2FsYXI7XG4gICAgfTtcblxuICAgIHJldHVybiB0ZW5zb3I7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEtleXNBbmRWYWx1ZXMob3JpZ2luYWxPYmplY3QpIHtcbiAgICBmb3IgKGtleSBpbiBvcmlnaW5hbE9iamVjdCkge1xuICAgICAgICBsb2coYG9iamVjdFske2tleX1dOiAke29yaWdpbmFsT2JqZWN0W2tleV19YCk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW5hbE9iamVjdFtrZXldO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpZldoaXRlQmFja2dyb3VuZChpbWdBcnIsIHRocmVzaG9sZCA9IDAuMykge1xuICAgIC8vIEFzc3VtaW5nICdpbWdBcnInIGlzIGEgSmF2YVNjcmlwdCBhcnJheSBvciB0eXBlZCBhcnJheSByZXByZXNlbnRpbmcgaW1hZ2UgZGF0YVxuICAgIC8vIGNvbnN0IGJhY2tncm91bmRWYWx1ZSA9IDI1NTsgLy8gVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgY29uc3QgYmFja2dyb3VuZFZhbHVlID0gMTsgLy8gVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXG5cbiAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBiYWNrZ3JvdW5kIHZhbHVlXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvLyBBc3N1bWluZyAndGVuc29yJyBpcyB5b3VyIE9OTlggUnVudGltZSBXZWIgdGVuc29yXG4gICAgY29uc3QgZGF0YSA9IGltZ0Fyci5kYXRhO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGJyZWFrO1xuICAgICAgICBpZiAoZGF0YVtpXSA9PSBiYWNrZ3JvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGxvZyhgZGF0YSAke2l9IGlzICR7ZGF0YVtpXX1gKTtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQgKyAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiBiYWNrZ3JvdW5kIHBpeGVsc1xuICAgIC8vIGNvbnN0IHBlcmNlbnQgPSBjb3VudCAvIGltZ0Fyci5sZW5ndGg7XG4gICAgdmFyIHBlcmNlbnQgPSBjb3VudCAvIDc4NDtcblxuICAgIGxvZyhgcGVyY2VudCB3aGl0ZW5lc3NzIGlzICR7cGVyY2VudH07IGNvdW50IGlzICR7Y291bnR9OyAke2ltZ0Fyci5kaW1zfWApXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgcGVyY2VudGFnZSBleGNlZWRzIHRoZSB0aHJlc2hvbGRcbiAgICBpZiAocGVyY2VudCA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW52ZXJ0SW1hZ2UoaW1nQXJyKSB7XG4gICAgY29uc3QgZGF0YSA9IGltZ0Fyci5kYXRhO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSAxIC0gZGF0YVtpXTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltZ0Fycjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2VEYXRhRnJvbVRlbnNvcihpbWFnZVRlbnNvciwgd2lkdGgsIGhlaWdodCkge1xuICAgIC8vIENvbnZlcnQgdGhlIHRlbnNvciBkYXRhIHRvIGEgcmVndWxhciBhcnJheSAoQXNzdW1pbmcgaXQncyBhIEZsb2F0MzJBcnJheSBvciBzaW1pbGFyKVxuICAgIHRlbnNvckRhdGEgPSBBcnJheS5mcm9tKGltYWdlVGVuc29yLmRhdGEpO1xuICAgIHRlbnNvckRhdGEgPSB0ZW5zb3JEYXRhLm1hcCh2YWx1ZSA9PiB2YWx1ZSAqIDI1NSk7XG5cbiAgICBjb25zb2xlLmxvZyhgW2h0bWxEaXNwbGF5SW1hZ2VdIHRlbnNvckRhdGEubGVuZ3RoOiAke3RlbnNvckRhdGEubGVuZ3RofWApXG5cbiAgICBjb25zdCBncmF5c2NhbGVEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRlbnNvckRhdGEpO1xuXG4gICAgY29uc3QgcmdiYURhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTsgLy8gUkdCQSBwaXhlbCBkYXRhXG5cbiAgICAvLyBQb3B1bGF0ZSB0aGUgUkdCQSBwaXhlbCBkYXRhIHdpdGggdGhlIGdyYXlzY2FsZSB2YWx1ZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoICogaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgY29uc3QgZ3JheXNjYWxlVmFsdWUgPSBncmF5c2NhbGVEYXRhW2ldO1xuXG4gICAgICAgIC8vIFNldCB0aGUgc2FtZSBncmF5c2NhbGUgdmFsdWUgZm9yIFJHQkEgY2hhbm5lbHMgKFIsIEcsIEIsIEEpXG4gICAgICAgIGNvbnN0IHBpeGVsSW5kZXggPSBpICogNDtcbiAgICAgICAgcmdiYURhdGFbcGl4ZWxJbmRleF0gPSBncmF5c2NhbGVWYWx1ZTsgLy8gUmVkIGNoYW5uZWxcbiAgICAgICAgcmdiYURhdGFbcGl4ZWxJbmRleCArIDFdID0gZ3JheXNjYWxlVmFsdWU7IC8vIEdyZWVuIGNoYW5uZWxcbiAgICAgICAgcmdiYURhdGFbcGl4ZWxJbmRleCArIDJdID0gZ3JheXNjYWxlVmFsdWU7IC8vIEJsdWUgY2hhbm5lbFxuICAgICAgICByZ2JhRGF0YVtwaXhlbEluZGV4ICsgM10gPSAyNTU7IC8vIEFscGhhIGNoYW5uZWwgKGZ1bGx5IG9wYXF1ZSlcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gSW1hZ2VEYXRhIG9iamVjdCBmcm9tIHRoZSBSR0JBIHBpeGVsIGRhdGFcbiAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKHJnYmFEYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNvbnNvbGUubG9nKGBbaHRtbERpc3BsYXlJbWFnZV0gaW1hZ2VEYXRhOiAke2ltYWdlRGF0YX0jIyNgKVxuXG4gICAgLy8gVXNlIGltYWdlRGF0YSB3aXRoIGEgY2FudmFzLCBwdXRJbWFnZURhdGEoKSwgb3Igb3RoZXIgY2FudmFzIG9wZXJhdGlvbnNcbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuXG5hc3luYyBmdW5jdGlvbiBodG1sRGlzcGxheUltYWdlKGltYWdlVGVuc29yLCBlbGVtZW50SUQsIHdpZHRoPTI4LCBoZWlnaHQ9MjgpIHtcbiAgICAvLyB3aWR0aCA9IGltYWdlVGVuc29yLmRpbXNbMl07XG4gICAgLy8gaGVpZ2h0ID0gaW1hZ2VUZW5zb3IuZGltc1szXTtcblxuICAgIGNvbnNvbGUubG9nKGBbaHRtbERpc3BsYXlJbWFnZV0gaW1hZ2VUZW5zb3I6ICR7d2lkdGh9LCAke2hlaWdodH0jIyNgKTtcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGF3YWl0IGdldEltYWdlRGF0YUZyb21UZW5zb3IoaW1hZ2VUZW5zb3IsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgLy8gQ3JlYXRlIGEgY2FudmFzIGFuZCBkcmF3IHRoZSBpbWFnZSBkYXRhIG9udG8gaXRcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgIC8vIENvbnZlcnQgdGhlIGNhbnZhcyBjb250ZW50IHRvIGEgZGF0YSBVUkxcbiAgICBjb25zdCBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7IC8vIENoYW5nZSAnaW1hZ2UvcG5nJyB0byB0aGUgZGVzaXJlZCBpbWFnZSBmb3JtYXRcblxuICAgIGNvbnN0IGltZ0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SUQpO1xuICAgIGltZ0VsZW1lbnQuc3JjID0gZGF0YVVSTDtcbn1cblxuLypcbiogaW52ZXJ0IGEgd2hpdGUgYmFja2dyb3VuZCB0byBibGFjayBvciByZW1haW4gc28gaWYgYmxhY2tcbiovXG5hc3luYyBmdW5jdGlvbiBpbnZlcnRXaGl0ZUJhY2tncm91bmQoaW1nQXJyKSB7XG4gICAgaXNXaGl0ZSA9IGF3YWl0IGlmV2hpdGVCYWNrZ3JvdW5kKGltZ0Fycik7XG4gICAgLy8gaXNXaGl0ZSA9IHRydWU7XG4gICAgaWYgKGlzV2hpdGUgPT0gdHJ1ZSkge1xuICAgICAgICAvLyBpbnZlcnQgaW1hZ2VcbiAgICAgICAgbG9nKGB5YWF5ISBpbWFnZSBpcyB3aGl0ZSBiYWNrZ3JvdW5kOyBnb3R0YSBpbnZlcnQhYCk7XG4gICAgICAgIGltZ0FyciA9IGF3YWl0IGludmVydEltYWdlKGltZ0Fycik7XG4gICAgICAgIHJldHVybiBpbWdBcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKGBub28hIGltZyBpcyBOT1Qgd2hpdGUgYmFja2dyb3VuZGApO1xuICAgICAgICByZXR1cm4gaW1nQXJyO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW1hZ2VQcmVwcm9jZXNzaW5nKGltZ0Fycikge1xuXG4gICAgLy8gMSwgMSwgMjgsIDI4XG4gICAgaW1nQXJyID0gYXdhaXQgb3J0LlRlbnNvci5mcm9tSW1hZ2UoaW1nQXJyLCBvcHRpb25zID0ge3Jlc2l6ZWRXaWR0aDogTU9ERUxfV0lEVEgsIHJlc2l6ZWRIZWlnaHQ6IE1PREVMX0hFSUdIVH0pO1xuXG4gICAgLy8gYWJjID0gYXdhaXQgaWZXaGl0ZUJhY2tncm91bmQoaW1nQXJyKTtcblxuICAgIGltZ0FyciA9IGF3YWl0IHJlc2l6ZVRlbnNvcihpbWdBcnIpO1xuXG4gICAgLy8gZmluZF93aGl0ZV9iYWNrZ3JvdW5kXG4gICAgaW1nQXJyID0gYXdhaXQgaW52ZXJ0V2hpdGVCYWNrZ3JvdW5kKGltZ0Fycik7XG4gICAgLy8gYml0d2lzZV9ub3RcbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZ0FyciwgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcblxuICAgIHJldHVybiBpbWdBcnI7IFxuXG59XG5cbi8qKlxuICogaGFuZGxlciBjYWxsZWQgd2hlbiBpbWFnZSBhdmFpbGFibGVcbiAqIHJ1biB0aGUgbW9kZWwgKGVuY29kZXIpIG9uIHRoZSBpbWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVJbWFnZShpbWcpIHtcbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZywgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZywgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcblxuICAgIGNvbnN0IHByZWRpY3Rpb25fZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdGlvbi1lbGVtZW50XCIpO1xuICAgIC8vIHByZWRpY3Rpb25fZWxlbWVudC5pbm5lclRleHQgPSBcIlwiO1xuICAgIGZpbGVpbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgLy8gZGVjb2Rlcl9sYXRlbmN5LmlubmVyVGV4dCA9IFwiXCI7XG4gICAgY2FudmFzLnN0eWxlLmN1cnNvciA9IFwid2FpdFwiO1xuICAgIGltYWdlX2VtYmVkZGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHdpZHRoID0gaW1nLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG4gICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCA+IE1BWF9XSURUSCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogKE1BWF9XSURUSCAvIHdpZHRoKTtcbiAgICAgICAgICAgIHdpZHRoID0gTUFYX1dJRFRIO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhlaWdodCA+IE1BWF9IRUlHSFQpIHtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggKiAoTUFYX0hFSUdIVCAvIGhlaWdodCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBNQVhfSEVJR0hUO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb25zb2xlLmxvZyhgW2hhbmRsZUltYWdlXSBpbWcuaGVpZ2h0OiAke2ltZy5oZWlnaHR9IyMjIGltZy53aWR0aDogJHtpbWcud2lkdGh9YClcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpbWFnZUltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjb25zdCBpbWdUZW5zb3IgPSBhd2FpdCBpbWFnZVByZXByb2Nlc3NpbmcoaW1hZ2VJbWFnZURhdGEpO1xuXG4gICAgLy8gYXdhaXQgaHRtbERpc3BsYXlJbWFnZShpbWdUZW5zb3IsICdkZWJ1Zy1pbWFnZScpOyAvLyBmb3IgREVCVUdHSU5HXG5cbiAgICBsb2coYCMjI2ltZ1RlbnNvci5kaW1zIGlzIHRoaXM6ICR7aW1nVGVuc29yLmRpbXN9IyMjYCk7XG4gICAgbG9nKGAjIyNpbWdUZW5zb3Igc2FtcGxlIGlzIHRoaXM6ICR7aW1nVGVuc29yLmRhdGEuc2xpY2UoMTEwLCAxMTkpfSMjI2ApO1xuICAgIFxuICAgIGNvbnN0IGZlZWQgPSB7IFwiaW5wdXQuMVwiOiBpbWdUZW5zb3IgfTtcbiAgICBjb25zdCBzID0gYXdhaXQgc2Vzc1swXTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc29sZS5sb2coXCJbZGVidWddIHM6XCIsIHMpXG4gICAgaW1hZ2VfZW1iZWRkaW5ncyA9IGF3YWl0IHMucnVuKGZlZWQpOyAvLyBNT0RFTC5GT1JXQVJEXG5cbiAgICBjb25zdCBlbWJfcHJvcGVydHkgPSBhd2FpdCBnZXRLZXlzQW5kVmFsdWVzKGltYWdlX2VtYmVkZGluZ3MpO1xuICAgIHByb2JzID0gZW1iX3Byb3BlcnR5WydjcHVEYXRhJ107XG4gICAgbWF4X3Byb2IgPSBNYXRoLm1heCguLi5wcm9icyk7XG4gICAgbWF4SW5kID0gcHJvYnMuaW5kZXhPZihtYXhfcHJvYik7XG5cbiAgICBwcmVkaWN0aW9uX2VsZW1lbnQuaW5uZXJUZXh0ID0gYENsYXNzOiAke21heEluZH0jIyNQcm9iYWJpbGl0aWVzOiAke3Byb2JzfSMjI2A7XG5cbiAgICBmaWxlaW4uZGlzYWJsZWQgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIGZldGNoIGFuZCBjYWNoZSB1cmxcblVzZXMgZnVuY3Rpb25zOlxuMS4gbG9nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kQ2FjaGUodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihcIm9ubnhcIik7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5jbGVhcl9jYWNoZSkge2NhY2hlLmRlbGV0ZSh1cmwpO31cblxuICAgICAgICBsZXQgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaCh1cmwpO1xuICAgICAgICBpZiAoY2FjaGVkUmVzcG9uc2UgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZS5hZGQodXJsKTtcbiAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2godXJsKTtcbiAgICAgICAgICAgIGxvZyhgJHt1cmx9IChmcm9tIG5ldHdvcmspYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2coYCR7dXJsfSAoZnJvbSBjYWNoZSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2FjaGVkUmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nKGAke3VybH0gKGZyb20gbmV0d29yaylgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybCkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICB9XG59XG5cbi8qXG4gKiBsb2FkIGVuY29kZXIgYW5kIGRlY29kZXIgc2VxdWVudGlhbGx5XG5Vc2VzIGZ1bmN0aW9uczpcbjEuIGZldGNoQW5kQ2FjaGVcbjIuIGhhbmRsZUltYWdlIChtb2RlbCBmb3J3YXJkKVxuMy4gbG9nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRfbW9kZWwobW9kZWwsIGlkeCwgaW1nKSB7XG4gICAgLy8gLS0tIHNlbGVjdCBkZXZpY2Ugd2Vibm4gb3Igd2ViZ3B1XG4gICAgbGV0IHByb3ZpZGVyID0gY29uZmlnLnByb3ZpZGVyO1xuICAgIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSBcIndlYm5uXCI6XG4gICAgICAgICAgICBpZiAoIShcIm1sXCIgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlYm5uIGlzIE5PVCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIndlYm5uXCIsXG4gICAgICAgICAgICAgICAgZGV2aWNlVHlwZTogY29uZmlnLmRldmljZSxcbiAgICAgICAgICAgICAgICBwb3dlclByZWZlcmVuY2U6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2ViZ3B1XCI6XG4gICAgICAgICAgICBpZiAoIW5hdmlnYXRvci5ncHUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJncHUgaXMgTk9UIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBvcHQgPSB7IGV4ZWN1dGlvblByb3ZpZGVyczogW3Byb3ZpZGVyXSB9O1xuICAgIC8vIC0tLSBzZWxlY3QgZGV2aWNlIHdlYm5uIG9yIHdlYmdwdVxuXG4gICAgbG9nKGBbbG9hZF9tb2RlbF0gaWR4IGlzIHdoYXQ/ICR7aWR4fWApXG5cbiAgICBmZXRjaEFuZENhY2hlKG1vZGVsW2lkeF0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgc2Vzc1tpZHhdID0gb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKGRhdGEsIG9wdCk7IC8vIGRhdGEgYW5kIGRldmljZVxuXG4gICAgICAgIC8vIC0tIHVzZWxlc3MgZ2FyYmFnZVxuICAgICAgICBzZXNzW2lkeF0udGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsb2coYCR7bW9kZWxbaWR4XX0gbG9hZGVkLiB5b3lgKTtcbiAgICAgICAgICAgIGlmIChpZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZyhcIltsb2FkX21vZGVsXSBpZHggaXMgMDsgc28gZ29pbmcgZm9yIG5leHQgcmVjdXJzaW9uIG9mIG1vZGVsXCIpO1xuICAgICAgICAgICAgICAgIC8vIGxvYWRfbW9kZWwobW9kZWwsIDEpOyAvLyByZWN1cnNpdmUgbG9hZF9tb2RlbCA/XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBsb2coYCR7bW9kZWxbaWR4XX0gZmFpbGVkIHdpdGggJHtlfS5gKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW1nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvZyhcImltZyBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICAgICAgLy8gaGFuZGxlSW1hZ2UoaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtsb2coXCJpbWcgaXMgbm90IHVuZGVmaW5lZCFcIil9XG4gICAgICAgIC8vIC0tIHVzZWxlc3MgZ2FyYmFnZVxuXG4gICAgfSlcbn1cblxuLypcbnVzZXMgdGhlIGZ1bmN0aW9uczpcbjEuIGxvYWRfbW9kZWxcbjIuIGhhbmRsZUltYWdlIChlbmNvZGVyKVxuMy4gaGFuZGxlQ2xpY2sgKGRlY29kZXIpXG40LiBsb2dcbiovXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICAgIGNvbnN0IG1vZGVsID0gTU9ERUxfTUFQW2NvbmZpZy5tb2RlbF07IC8vIGxvYWQgdGhlIG1vZGVsIChlbmNvZGVyIG9yIGRlY29kZXIpID9cbiAgICAvLyAtLS0gWzFdIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgdXNlclxuICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW1nX2NhbnZhc1wiKTtcbiAgICAvLyBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcbiAgICAvLyBjYW52YXMuc3R5bGUuY3Vyc29yID0gXCJ3YWl0XCI7XG5cbiAgICBmaWxlaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGUtaW5cIik7XG4gICAgLy8gZGVjb2Rlcl9sYXRlbmN5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWNvZGVyX2xhdGVuY3lcIik7XG5cbiAgICBsZXQgaW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcmlnaW5hbC1pbWFnZVwiKTtcbiAgICAvLyAtLS0gWzFdIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgdXNlclxuXG4gICAgY29uc29sZS5sb2coXCJbZGVidWddIEJFRk9SRSBtb2RlbCBsb2FkaW5nLi4uXCIpXG4gICAgbG9hZF9tb2RlbChtb2RlbCwgMCwgaW1nKS50aGVuKCgpID0+IHt9LCAoZSkgPT4ge2xvZyhlKTt9KTsgLy8gW0VYVF9GVU5DXSBsb2FkX21vZGVsXG4gICAgY29uc29sZS5sb2coXCJbZGVidWddIG1vZGVsIGxvYWRlZDsgc2VzczpcIiwgc2VzcylcbiAgICAvLyBsb2FkX21vZGVsKG1vZGVsLCAwLCBpbWcpLnRoZW4oKCkgPT4ge30sIChlKSA9PiB7fSk7IC8vIFtFWFRfRlVOQ10gbG9hZF9tb2RlbFxuXG4gICAgLy8gLS0tIFsyXSBpbWFnZSB1cGxvYWRcbiAgICBmaWxlaW4ub25jaGFuZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBldnQudGFyZ2V0IHx8IHdpbmRvdy5ldmVudC5zcmMsIGZpbGVzID0gdGFyZ2V0LmZpbGVzO1xuICAgICAgICBpZiAoRmlsZVJlYWRlciAmJiBmaWxlcyAmJiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiBoYW5kbGVJbWFnZShpbWcpOyAvLyBbRVhUX0ZVTkNdIGhhbmRsZUltYWdlXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGVzWzBdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gLS0tIFsyXSBpbWFnZSB1cGxvYWRcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4geyBtYWluKCk7IH0pO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImEiLCJpIiwic2VsZiIsIldyIiwiQnQiLCJmdCIsIk5yIiwiSGEiLCJxYSIsIk9uIiwiSWUiLCJYYSIsIkphIiwiVG4iLCJaYSIsImVvIiwidG8iLCJybyIsImxyIiwiR3IiLCJhbyIsIm9vIiwic28iLCJ1byIsIkZlIiwiVWUiLCJMciIsInBvIiwiSHIiLCJnbyIsIl9uIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrbCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIkJsIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIk1sIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJMIiwiZSIsInQiLCJMdCIsImt0IiwiciIsImdldCIsImVudW1lcmFibGUiLCJ2dCIsIm4iLCJjYWxsIiwiRGwiLCJ2YWx1ZSIsIlZyIiwiTWFwIiwiaW5pdCIsImNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyIiwiVHlwZUVycm9yIiwic2V0IiwiYmFja2VuZCIsInByaW9yaXR5IiwiRXJyb3IiLCJpbmRleE9mIiwic3BsaWNlIiwicyIsImxlbmd0aCIsInB1c2giLCJhc3luYyIsImluaXRpYWxpemVkIiwiYWJvcnRlZCIsImluaXRQcm9taXNlIiwidSIsIm5hbWUiLCJlcnIiLCJtYXAiLCJqb2luIiwiTGEiLCJqYSIsIkthIiwid2FzbSIsIndlYmdsIiwid2ViZ3B1IiwidmVyc2lvbnMiLCJjb21tb24iLCJsb2dMZXZlbCIsIllhIiwiUWEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aCIsImRpbXMiLCJoZWlnaHQiLCJnZXRDb250ZXh0IiwidGVuc29yTGF5b3V0IiwibyIsInAiLCJmb3JtYXQiLCJsIiwibm9ybSIsIm1lYW4iLCJiaWFzIiwibSIsInkiLCJnIiwidiIsIiQiLCJiIiwiUyIsIkkiLCJkYXRhIiwiVCIsIkIiLCJQIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0b0RhdGFVUkwiLCJjcmVhdGVJbWFnZURhdGEiLCJEIiwibm8iLCJVciIsInRlbnNvckZvcm1hdCIsIkZsb2F0MzJBcnJheSIsIkhUTUxJbWFnZUVsZW1lbnQiLCJJbWFnZURhdGEiLCJJbWFnZUJpdG1hcCIsInJlc2l6ZWRIZWlnaHQiLCJyZXNpemVkV2lkdGgiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJQcm9taXNlIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsInNyYyIsIm9ubG9hZCIsInB1dEltYWdlRGF0YSIsImRvd25sb2FkIiwiZGlzcG9zZSIsImxvY2F0aW9uIiwidHlwZSIsInRleHR1cmUiLCJkYXRhVHlwZSIsImdwdUJ1ZmZlciIsImlvIiwiVWludDhBcnJheSIsIkludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJVaW50MzJBcnJheSIsIkJpZ0ludDY0QXJyYXkiLCJmcm9tIiwiQmlnVWludDY0QXJyYXkiLCJsbyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJSYW5nZUVycm9yIiwiY29uc3RydWN0b3IiLCJ0aGlzIiwiZGF0YUxvY2F0aW9uIiwiY3B1RGF0YSIsImdwdVRleHR1cmVEYXRhIiwiZG93bmxvYWRlciIsImRpc3Bvc2VyIiwiZ3B1QnVmZmVyRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsIkJpZ0ludCIsInNpemUiLCJmcm9tSW1hZ2UiLCJmcm9tVGV4dHVyZSIsImZyb21HcHVCdWZmZXIiLCJmcm9tUGlubmVkQnVmZmVyIiwidG9JbWFnZURhdGEiLCJlbnN1cmVWYWxpZCIsImdldERhdGEiLCJpc0Rvd25sb2FkaW5nIiwicmVzaGFwZSIsIkZyIiwiY28iLCJoYW5kbGVyIiwicnVuIiwib3V0cHV0TmFtZXMiLCJpbnB1dE5hbWVzIiwicmVsZWFzZSIsImNyZWF0ZSIsIkFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiZXhlY3V0aW9uUHJvdmlkZXJzIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJmbyIsIm1vIiwiaG8iLCJldmFsTW9kZWwiLCJvcHRpbWl6ZXJNb2RlbCIsImNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIiLCJjaGVja3BvaW50U3RhdGUiLCJ0cmFpbk1vZGVsIiwidHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAiLCJjb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyIsInJ1blRyYWluU3RlcCIsImxvYWRQYXJhbWV0ZXJzQnVmZmVyIiwiZ2V0Q29udGlndW91c1BhcmFtZXRlcnMiLCJ5byIsIlJuIiwiSW5mZXJlbmNlU2Vzc2lvbiIsIlRlbnNvciIsIlRyYWluaW5nU2Vzc2lvbiIsImVudiIsInJlZ2lzdGVyQmFja2VuZCIsIiR0IiwiUG4iLCJyZWFkRmlsZSIsIldsIiwia24iLCJCbiIsIk5sIiwiTW4iLCIkbyIsInZvIiwiRG4iLCJ3byIsImN1cnJlbnRTY3JpcHQiLCJfX2ZpbGVuYW1lIiwicmVhZHkiLCJkIiwiZiIsImpzZXBJbml0IiwidyIsIkMiLCJfIiwiRyIsIlYiLCJ1ZSIsIk9hIiwiUGEiLCJyYSIsIlJhIiwiU2EiLCJZIiwiWiIsIkoiLCJjZSIsIm1lIiwiWWUiLCJFIiwidGUiLCJPdCIsInJlc29sdmUiLCJyZWplY3QiLCJEYSIsIlRhIiwiZXJyb3JzIiwiZmx1c2giLCJhbGwiLCJmaWx0ZXIiLCJfT3J0UnVuIiwiX09ydFJ1bldpdGhCaW5kaW5nIiwiX09ydEJpbmRJbnB1dCIsImpzZXBSZWdpc3RlckJ1ZmZlciIsInJlZ2lzdGVyQnVmZmVyIiwianNlcFVucmVnaXN0ZXJCdWZmZXJzIiwidW5yZWdpc3RlckJ1ZmZlcnMiLCJqc2VwR2V0QnVmZmVyIiwiZ2V0QnVmZmVyIiwianNlcENyZWF0ZURvd25sb2FkZXIiLCJjcmVhdGVEb3dubG9hZGVyIiwiYXNzaWduIiwid2luZG93IiwiaW1wb3J0U2NyaXB0cyIsInByb2Nlc3MiLCJub2RlIiwiZGlybmFtZSIsIl9fZGlybmFtZSIsInN0YXJ0c1dpdGgiLCJVUkwiLCJub3JtYWxpemUiLCJyZWFkRmlsZVN5bmMiLCJidWZmZXIiLCJ0aGlzUHJvZ3JhbSIsImFyZ3YiLCJyZXBsYWNlIiwic2xpY2UiLCJleGl0Q29kZSIsImluc3BlY3QiLCJocmVmIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZW5kIiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJvbmVycm9yIiwicHJpbnQiLCJjb25zb2xlIiwibG9nIiwiYmluZCIsInByaW50RXJyIiwiZXJyb3IiLCJxdWl0Iiwid2FzbUJpbmFyeSIsIm5vRXhpdFJ1bnRpbWUiLCJXZWJBc3NlbWJseSIsInFlIiwiUiIsIkgiLCJLIiwibGUiLCJNIiwicSIsInhlIiwib2UiLCJXIiwid2UiLCJIRUFQOCIsIkhFQVAxNiIsIkhFQVAzMiIsIkhFQVBVOCIsIkhFQVBVMTYiLCJIRUFQVTMyIiwiSEVBUEYzMiIsIkhFQVBGNjQiLCJqIiwiU2UiLCJUZSIsIkVlIiwicHJlUnVuIiwic2hpZnQiLCJ1bnNoaWZ0IiwiZGUiLCJDZSIsImd0IiwiTGUiLCJvbkFib3J0IiwiUnVudGltZUVycm9yIiwiVSIsInBlIiwibG9jYXRlRmlsZSIsIk5lIiwiT2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsIm9rIiwiYXJyYXlCdWZmZXIiLCJjYXRjaCIsIkhlIiwiaW5zdGFudGlhdGUiLCJHZSIsImV0IiwibWluIiwibWF4IiwiYWxwaGEiLCJrZWVwRGltcyIsIm5vb3BXaXRoRW1wdHlBeGVzIiwiYXhlcyIsInN1YmFycmF5IiwicGVybSIsImF1dG9QYWQiLCJkaWxhdGlvbnMiLCJncm91cCIsImtlcm5lbF9zaGFwZSIsInBhZHMiLCJzdHJpZGVzIiwid0lzQ29uc3QiLCJvdXRwdXRQYWRkaW5nIiwib3V0cHV0U2hhcGUiLCJhY3RpdmF0aW9uIiwiUmUiLCJrZXJuZWxTaGFwZSIsImZlIiwiYXV0b19wYWQiLCJjZWlsX21vZGUiLCJjb3VudF9pbmNsdWRlX3BhZCIsInN0b3JhZ2Vfb3JkZXIiLCJiZXRhIiwidHJhbnNBIiwidHJhbnNCIiwic2VsZWN0TGFzdEluZGV4IiwiYXhpcyIsIm51bU91dHB1dHMiLCJzcGxpdFNpemVzIiwiYW50aWFsaWFzIiwiY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUiLCJjdWJpY0NvZWZmQSIsImV4Y2x1ZGVPdXRzaWRlIiwiZXh0cmFwb2xhdGlvblZhbHVlIiwia2VlcEFzcGVjdFJhdGlvUG9saWN5IiwibW9kZSIsIm5lYXJlc3RNb2RlIiwic3RhcnRzIiwiZW5kcyIsImVwc2lsb24iLCJlcXVhdGlvbiIsIndfaXNfY29uc3QiLCJhY3RpdmF0aW9uX3BhcmFtcyIsIktlIiwibWVzc2FnZSIsIkF0IiwiRXQiLCJNYSIsIlV0IiwiSmUiLCJUZXh0RGVjb2RlciIsInF0IiwiZGVjb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwienQiLCJjaGFyQ29kZUF0IiwiS3QiLCJsdCIsInhyIiwiZHQiLCJXdCIsIkd0IiwieXQiLCJOdCIsIlZ0IiwiWXQiLCJVU0VSIiwiTE9HTkFNRSIsIlBBVEgiLCJQV0QiLCJIT01FIiwiTEFORyIsIm5hdmlnYXRvciIsImxhbmd1YWdlcyIsIlNyIiwiVmUiLCJYdCIsIm5lIiwidG9TdHJpbmciLCJ1ciIsInB0IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXREYXkiLCJEYXRlIiwiQmEiLCJDYSIsImdldFRpbWUiLCJzZXREYXRlIiwic2V0TW9udGgiLCJzZXRGdWxsWWVhciIsIldhIiwiVmEiLCJFYSIsIklhIiwiRmEiLCJ3YSIsIiRhIiwiVWEiLCJSZWdFeHAiLCJzcGxpdCIsInN1YnN0cmluZyIsIk1hdGgiLCJmbG9vciIsImFicyIsImluY2x1ZGVzIiwiSnQiLCJjdCIsInR0IiwiSXIiLCJfdCIsIlF0IiwiWnQiLCJBciIsIkVyIiwiUHIiLCJGdCIsIkJyb3dzZXIiLCJHYSIsIk5hIiwicmVzdW1lIiwiT3IiLCJwYXVzZSIsIm9yIiwiVHQiLCJlciIsImZvckVhY2giLCJvbkV4aXQiLCJUciIsIlJyIiwieiIsIkEiLCJ4IiwiTmFOIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENIb3VycyIsImdldFVUQ0RhdGUiLCJnZXRVVENNb250aCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDRGF5IiwiVVRDIiwiZ2V0U2Vjb25kcyIsImdldE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0VGltZSIsImdldFllYXIiLCJ0ciIsImNlaWwiLCJ0b1RpbWVTdHJpbmciLCJtYXRjaCIsImFwcGx5IiwiaCIsIm5vdyIsImMiLCJwZXJmb3JtYW5jZSIsImNvcHlXaXRoaW4iLCJncm93IiwiayIsIkYiLCJhcmd1bWVudHMiLCJwb3AiLCJpciIsIkZpYmVycyIsImFiIiwiQ3IiLCJfX2Vycm5vX2xvY2F0aW9uIiwibWFsbG9jIiwic3RhY2tTYXZlIiwic3RhY2tBbGxvYyIsImJ0IiwiTiIsIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiLCJjbGVhckludGVydmFsIiwiaW5zdGFudGlhdGVXYXNtIiwiaW5zdGFudGlhdGVTdHJlYW1pbmciLCJ6ZSIsImluc3RhbmNlIiwiX09ydEluaXQiLCJPIiwiX09ydEdldExhc3RFcnJvciIsIl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyIsIlEiLCJfT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIiLCJfT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlIiwiX09ydEFkZFNlc3Npb25Db25maWdFbnRyeSIsIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMiLCJfT3J0Q3JlYXRlU2Vzc2lvbiIsIl9PcnRSZWxlYXNlU2Vzc2lvbiIsIl9PcnRHZXRJbnB1dE91dHB1dENvdW50IiwiWCIsIl9PcnRHZXRJbnB1dE5hbWUiLCJfT3J0R2V0T3V0cHV0TmFtZSIsIl9PcnRGcmVlIiwiX09ydENyZWF0ZVRlbnNvciIsIl9PcnRHZXRUZW5zb3JEYXRhIiwiYWEiLCJfT3J0UmVsZWFzZVRlbnNvciIsImJhIiwiX09ydENyZWF0ZVJ1bk9wdGlvbnMiLCJjYSIsIl9PcnRBZGRSdW5Db25maWdFbnRyeSIsImRhIiwiX09ydFJlbGVhc2VSdW5PcHRpb25zIiwiZWEiLCJfT3J0Q3JlYXRlQmluZGluZyIsImZhIiwiZ2EiLCJfT3J0QmluZE91dHB1dCIsImhhIiwiX09ydENsZWFyQm91bmRPdXRwdXRzIiwiaWEiLCJfT3J0UmVsZWFzZUJpbmRpbmciLCJrYSIsImxhIiwiX09ydEVuZFByb2ZpbGluZyIsIm1hIiwiX0pzZXBPdXRwdXQiLCJuYSIsIl9Kc2VwR2V0Tm9kZU5hbWUiLCJvYSIsIlJ0IiwiX21hbGxvYyIsInBhIiwiX2ZyZWUiLCJzYSIsInJyIiwidGEiLCJuciIsInVhIiwiYXIiLCJ2YSIsInhhIiwieWEiLCJ6YSIsIkFhIiwic3IiLCJjYWxsZWRSdW4iLCJvblJ1bnRpbWVJbml0aWFsaXplZCIsInBvc3RSdW4iLCJzZXRTdGF0dXMiLCJzZXRUaW1lb3V0IiwiX19fc3RhcnRfZW1fanMiLCJfX19zdG9wX2VtX2pzIiwic3RhY2tSZXN0b3JlIiwiVVRGOFRvU3RyaW5nIiwic3RyaW5nVG9VVEY4IiwibGVuZ3RoQnl0ZXNVVEY4IiwicHJlSW5pdCIsInhvIiwiU28iLCJDbyIsImNwdXMiLCJWbCIsIlJvIiwiR2wiLCJXbiIsIk5uIiwianIiLCJUbyIsIkZsIiwiTGwiLCJIbCIsIlBvIiwiUGUiLCJNZSIsImRyIiwiQWUiLCJrbyIsImpsIiwicWwiLCJLbCIsIllsIiwiTW8iLCJWbiIsImNyIiwicHIiLCJLciIsImZyIiwiWXIiLCJVbiIsIlhsIiwiSmwiLCJ6byIsIldvIiwiTm8iLCJRbCIsIl9lIiwiVm8iLCJYciIsIlpsIiwiRm8iLCJGbiIsIkduIiwiTG8iLCJMbiIsImllIiwiSG4iLCJudCIsIk10IiwiSnIiLCJRciIsIlpyIiwiam8iLCJCZSIsInFuIiwibXQiLCJRZSIsIkR0IiwiU3QiLCJxbyIsImpuIiwiS28iLCJLbiIsIllvIiwidGQiLCJYbyIsInJkIiwibmQiLCJDdCIsIkpvIiwiUW8iLCJhZCIsIm9kIiwiaWQiLCJzZCIsInVkIiwibGQiLCJkZCIsImNkIiwicGQiLCJmZCIsImF0IiwiWm8iLCJlaSIsInRpIiwicmkiLCJuaSIsImFpIiwib2kiLCJpaSIsInNpIiwidWkiLCJvdCIsIm1kIiwidG4iLCJZbiIsIml0IiwiaGQiLCJnZCIsInlkIiwiYmQiLCJ3ZCIsInZkIiwiJGQiLCJ4ZCIsIlNkIiwiQ2QiLCJzdCIsImRpIiwiY2kiLCJwaSIsImZpIiwibWkiLCJoaSIsImdpIiwieWkiLCJiaSIsIndpIiwiWmUiLCJ2aSIsIiRpIiwieGkiLCJTaSIsIlhuIiwiSWQiLCJBZCIsIklpIiwiRWQiLCIkZSIsIkVpIiwiX2kiLCJPaSIsIlRpIiwiUmkiLCJQaSIsImtpIiwiQmkiLCJNaSIsIkpuIiwiX2QiLCJEaSIsInppIiwiV2kiLCJOaSIsInJuIiwiVmkiLCJubiIsIlVpIiwiR2kiLCJGaSIsIkxpIiwiSGkiLCJqaSIsInFpIiwiS2kiLCJZaSIsIlhpIiwiSmkiLCJRaSIsIlppIiwiZXMiLCJ0cyIsInJzIiwibnMiLCJUZCIsIlJkIiwiYXMiLCJQZCIsImtkIiwidXQiLCJpcyIsInNzIiwidXMiLCJscyIsImRzIiwiY3MiLCJwcyIsImZzIiwibXMiLCJocyIsIk1kIiwiRGQiLCJ6ZCIsIldkIiwieXMiLCJicyIsIldlIiwiYW4iLCJvbiIsInVuIiwibG4iLCJkbiIsIk5kIiwiVmQiLCJnciIsInZzIiwiVWQiLCJ5ciIsIkdkIiwiY24iLCJGZCIsIiRzIiwiQ3MiLCJMZCIsIklzIiwiSGQiLCJqZCIsInFkIiwiQXMiLCJLZCIsIllkIiwiWGQiLCJKZCIsIk9zIiwiVHMiLCJRZCIsIlpkIiwiZWMiLCJ0YyIsIlJzIiwicG4iLCJrcyIsIm5jIiwiYWMiLCJCcyIsIk1zIiwib2MiLCJ6cyIsImljIiwic2MiLCJXcyIsInVjIiwibGMiLCJWcyIsIlVzIiwiZGMiLCJjYyIsIkZzIiwiTHMiLCJwYyIsImZjIiwibWMiLCJqcyIsInFzIiwiaGMiLCJnYyIsInljIiwiYmMiLCJZcyIsIlhzIiwid2MiLCJ2YyIsIlFzIiwiWnMiLCIkYyIsInR1IiwieGMiLCJTYyIsIkNjIiwiSWMiLCJBYyIsIkVjIiwiX2MiLCJPYyIsIlRjIiwibnUiLCJhdSIsImZuIiwiaXUiLCJzdSIsInV1IiwibHUiLCJkdSIsImN1IiwicHUiLCJmdSIsIm11IiwiaHUiLCJndSIsInl1IiwiYnUiLCJ3dSIsIlBjIiwia2MiLCIkdSIsIkJjIiwiTWMiLCJEYyIsInpjIiwiV2MiLCJOYyIsIlZjIiwiVWMiLCJHYyIsIkZjIiwiTGMiLCJIYyIsImpjIiwicWMiLCJLYyIsIlN1IiwiQ3UiLCJZYyIsIlhjIiwiQXUiLCJFdSIsIkpjIiwibW4iLCJRYyIsIk91IiwiWmMiLCJlcCIsIlR1IiwiUnUiLCJ0cCIsInJwIiwia3UiLCJCdSIsIm5wIiwiYXAiLCJvcCIsImlwIiwic3AiLCJEdSIsInp1IiwiTnUiLCJ1cCIsImxwIiwiZHAiLCJWdSIsImNwIiwicHAiLCJHdSIsIkx1IiwiaG4iLCJmcCIsIm1wIiwiZ24iLCJJbyIsIl9vIiwiRW8iLCJ6biIsIkFvIiwiYWUiLCJRYiIsIndiIiwieWIiLCJqYiIsInhiIiwiemIiLCJBYiIsImVlIiwicmUiLCJoZSIsImJlIiwicnQiLCJzZSIsInhuIiwiYmIiLCJGYiIsIkVOVklST05NRU5UX0lTX1BUSFJFQUQiLCJXb3JrZXIiLCJ3cml0ZVN5bmMiLCJJTklUSUFMX01FTU9SWSIsIndhc21NZW1vcnkiLCJNZW1vcnkiLCJpbml0aWFsIiwibWF4aW11bSIsInNoYXJlZCIsImp0IiwiJHIiLCJ5ZSIsInRlcm1pbmF0ZSIsIm9ubWVzc2FnZSIsIkViIiwidGIiLCJjbWQiLCJzdGFydF9yb3V0aW5lIiwiR2IiLCJhcmciLCJyYiIsInB0aHJlYWRfcHRyIiwidW5yZWYiLCJwb3N0TWVzc2FnZSIsIk1iIiwiSGIiLCJtYiIsImdiIiwidmIiLCJ1YiIsIkJiIiwicmVjZWl2ZU9iamVjdFRyYW5zZmVyIiwiRGIiLCJ0aHJlYWRJbml0VExTIiwibGIiLCJzZXRFeGl0U3RhdHVzIiwia2IiLCJTYiIsIkNuIiwiQ2IiLCJ0YXJnZXRUaHJlYWQiLCJNciIsIlJiIiwidHJhbnNmZXJMaXN0IiwidGhyZWFkIiwibG9hZGVkIiwiYWxlcnQiLCJ0aHJlYWRJZCIsInRleHQiLCJ0YXJnZXQiLCJhcmdzIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJoYW5kbGVycyIsInVybE9yQmxvYiIsIm1haW5TY3JpcHRVcmxPckJsb2IiLCJ3YXNtTW9kdWxlIiwicWIiLCJQVGhyZWFkIiwiZmIiLCJwYiIsIm9iIiwibmIiLCJPYiIsImVzdGFibGlzaFN0YWNrU3BhY2UiLCJEciIsImludm9rZUVudHJ5UG9pbnQiLCJJbiIsIl9yIiwiQXRvbWljcyIsIk5iIiwic3RvcmUiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQiLCJjaGVja01haWxib3giLCJTbiIsIkFuIiwiRW4iLCJQdCIsIktiIiwiSmIiLCJjYiIsImliIiwiZWIiLCJUYiIsIkliIiwiTGIiLCJ2bCIsIiRsIiwia3IiLCJ3dCIsIl9hIiwiQnIiLCJTbCIsIkNsIiwiVGwiLCJSbCIsImhiIiwic2IiLCJFbCIsIkFsIiwiX2wiLCJPbCIsInJlZiIsInRpbWVPcmlnaW4iLCJoYXJkd2FyZUNvbmN1cnJlbmN5IiwiUGIiLCJVYiIsInhsIiwicHRocmVhZF9zZWxmIiwiUGwiLCJfcHRocmVhZF9zZWxmIiwiX19lbXNjcmlwdGVuX3Rsc19pbml0IiwiX19lbXNjcmlwdGVuX3RocmVhZF9pbml0IiwiX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkIiwienIiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQiLCJfX2Vtc2NyaXB0ZW5fY2hlY2tfbWFpbGJveCIsImR5bkNhbGxfaWkiLCJzdGFydFdvcmtlciIsImtlZXBSdW50aW1lQWxpdmUiLCJFeGl0U3RhdHVzIiwiT28iLCJnZiIsIlVsIiwiSHQiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwidmFsaWRhdGUiLCJpbml0VGltZW91dCIsIm51bVRocmVhZHMiLCJzaW1kIiwid2FzbVBhdGhzIiwiZW5kc1dpdGgiLCJCbG9iIiwiY3JlYXRlT2JqZWN0VVJMIiwicmFjZSIsInFyIiwiaGFzIiwiYWRkIiwiZW50cmllcyIsIkJvIiwibG9nU2V2ZXJpdHlMZXZlbCIsImlzSW50ZWdlciIsImxvZ1ZlcmJvc2l0eUxldmVsIiwidGFnIiwiZXh0cmEiLCJXZWFrU2V0IiwiRG8iLCJzZXNzaW9uIiwidXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSIsInNvbWUiLCJlbmFibGVNZW1QYXR0ZXJuIiwiZGV2aWNlVHlwZSIsInBvd2VyUHJlZmVyZW5jZSIsInByZWZlcnJlZExheW91dCIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwibG9nSWQiLCJvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJlbmFibGVQcm9maWxpbmciLCJmcmVlRGltZW5zaW9uT3ZlcnJpZGVzIiwiRGUiLCJ4dCIsInRvSVNPU3RyaW5nIiwiVW8iLCJHbyIsIkhvIiwiZGV2aWNlIiwiY3JlYXRlQnVmZmVyIiwidXNhZ2UiLCJHUFVCdWZmZXJVc2FnZSIsIkNPUFlfRFNUIiwiTUFQX1JFQUQiLCJnZXRDb21tYW5kRW5jb2RlciIsImVuZENvbXB1dGVQYXNzIiwiY29weUJ1ZmZlclRvQnVmZmVyIiwibWFwQXN5bmMiLCJHUFVNYXBNb2RlIiwiUkVBRCIsImdldE1hcHBlZFJhbmdlIiwiZGVzdHJveSIsInN0b3JhZ2VDYWNoZSIsImZyZWVCdWZmZXJzIiwiZnJlZVVuaWZvcm1CdWZmZXJzIiwiYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmciLCJidWZmZXJzUGVuZGluZyIsImV4dGVybmFsQnVmZmVycyIsInVwbG9hZCIsImJ5dGVPZmZzZXQiLCJvcmlnaW5hbFNpemUiLCJtYXBwZWRBdENyZWF0aW9uIiwiTUFQX1dSSVRFIiwiQ09QWV9TUkMiLCJ1bm1hcCIsImdwdURhdGEiLCJtZW1jcHkiLCJyZWdpc3RlckV4dGVybmFsQnVmZmVyIiwiZGVsZXRlIiwidW5yZWdpc3RlckV4dGVybmFsQnVmZmVyIiwiU1RPUkFHRSIsIlVOSUZPUk0iLCJyZWZyZXNoUGVuZGluZ0J1ZmZlcnMiLCJrZSIsImNhY2hlS2V5IiwiX2NhY2hlS2V5Iiwic29ydCIsImdlIiwiY2FsY01hdE11bFNoYXBlIiwiY2FsY1NoYXBlIiwiaXNWYWxpZEJyb2FkY2FzdCIsImdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UiLCJzaXplRnJvbURpbWVuc2lvbiIsInNpemVUb0RpbWVuc2lvbiIsImNvbXB1dGVTdHJpZGVzIiwibm9ybWFsaXplQXhpcyIsIm5vcm1hbGl6ZUF4ZXMiLCJzb3J0QmFzZWRPblBlcm0iLCJyZXZlcnNlIiwicGFkU2hhcGUiLCJhcmVFcXVhbCIsImV2ZXJ5IiwiYWRqdXN0UG9vbEF0dHJpYnV0ZXMiLCJhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQiLCJhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSIsImNvbXB1dGVQb29sT3V0cHV0U2hhcGUiLCJjb21wdXRlU2hhcGVIZWxwZXIiLCJjb21wdXRlQ29udk91dHB1dFNoYXBlIiwiZ2V0U2hhcGVPZkdlbW1SZXN1bHQiLCJ2ZSIsImtleXMiLCJpbmRpY2VzIiwic3RvcmFnZSIsInRlbnNvciIsIm9mZnNldFRvSW5kaWNlcyIsImluZGljZXNUb09mZnNldCIsImJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0Iiwic2V0QnlJbmRpY2VzIiwiZ2V0QnlJbmRpY2VzIiwiaW1wbCIsInZhbHVlcyIsImluZGljZXNHZXQiLCJyYW5rIiwiaW5kaWNlc1NldCIsInNldEJ5T2Zmc2V0IiwiZ2V0QnlPZmZzZXQiLCJzaGFwZSIsIm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwIiwiaW5kaWNlc0hlbHBlcnMiLCJ1bmlmb3JtcyIsInZhcmlhYmxlSW5kZXgiLCJndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzIiwibWFpblN0YXJ0IiwiZGVjbGFyZVZhcmlhYmxlIiwiZGVjbGFyZVZhcmlhYmxlcyIsInJlZ2lzdGVyVW5pZm9ybSIsInVuaWZvcm1EZWNsYXJhdGlvbiIsImFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMiLCJtciIsInNoYWRlckNhY2hlIiwiaGludCIsImlucHV0RGVwZW5kZW5jaWVzIiwiZ2V0UnVuRGF0YSIsIm91dHB1dHMiLCJkaXNwYXRjaEdyb3VwIiwicHJvZ3JhbVVuaWZvcm1zIiwiZ2V0U2hhZGVyU291cmNlIiwiaW5wdXRzIiwiY29tcHV0ZSIsImxpIiwiZW4iLCJzdW0iLCJwcm9kIiwic3VtU3F1YXJlIiwibG9nU3VtRXhwIiwibDEiLCJsMiIsImxvZ1N1bSIsImdldEJpZ0ludDY0QXJyYXkiLCJDaSIsIkFpIiwiUW4iLCJnZXRGbG9hdDMyQXJyYXkiLCJvcyIsImdzIiwic2NhbGFyIiwidmVjdG9yIiwid3MiLCJzbiIsIlpuIiwiaHIiLCJhY3RpdmF0aW9uRnVuY3Rpb24iLCJhcHBseUFjdGl2YXRpb24iLCJjbGlwTWluIiwiY2xpcE1heCIsImFjdGl2YXRpb25DYWNoZUtleSIsImJyIiwieHMiLCJ0b0xvd2VyQ2FzZSIsIlNzIiwia2VybmVsQ3VzdG9tRGF0YSIsIndUIiwiY29uY2F0IiwiRXMiLCJfcyIsIlBzIiwicmVkdWNlIiwiZmlsbCIsIkRzIiwic3ltYm9sVG9JbmRpY2VzIiwiaW5wdXRJbmRleCIsImFkZFN5bWJvbCIsImhhc0VsbGlwc2lzIiwic3ltYm9sVG9JbmZvIiwibGhzIiwib3V0cHV0RGltcyIsInByb2Nlc3NUZXJtIiwiY291bnQiLCJlbGxpcHNpc0RpbXMiLCJkaW1WYWx1ZSIsInJocyIsImlucHV0SW5kaWNlcyIsIk5zIiwiR3MiLCJIcyIsIktzIiwiSnMiLCJKU09OIiwic3RyaW5naWZ5IiwiY29tcG9uZW50cyIsImV1Iiwib3V0cHV0Q291bnQiLCJydSIsIm91IiwidnUiLCJjZWlsTW9kZSIsImNvdW50SW5jbHVkZVBhZCIsInN0b3JhZ2VPcmRlciIsInh1IiwiZ2V0SW50MzJBcnJheSIsInZhbGlkYXRlSW5wdXRDb250ZW50IiwiSXUiLCJyb3VuZCIsIk1BWF9WQUxVRSIsIk1JTl9WQUxVRSIsImN1c3RvbURhdGFCdWZmZXIiLCJfdSIsIlB1Iiwic2lnbiIsIk11IiwiV3UiLCJVdSIsIkZ1IiwiSHUiLCJqdSIsInJlcG8iLCJhdHRyaWJ1dGVzQm91bmQiLCJnZXRBcnRpZmFjdCIsInNldEFydGlmYWN0IiwiZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyIiwic2V0UGlwZWxpbmUiLCJjb21wdXRlUGlwZWxpbmUiLCJiaW5kaW5nIiwicmVzb3VyY2UiLCJjcmVhdGVCaW5kR3JvdXAiLCJsYXlvdXQiLCJnZXRCaW5kR3JvdXBMYXlvdXQiLCJsYWJlbCIsInByb2dyYW1JbmZvIiwic2V0QmluZEdyb3VwIiwiZGlzcGF0Y2hXb3JrZ3JvdXBzIiwicGVuZGluZ0Rpc3BhdGNoTnVtYmVyIiwiaXNRdWVyeUVuYWJsZWQiLCJxdWVyeURhdGEiLCJncHVEYXRhTWFuYWdlciIsInF1ZXJ5U2V0Q291bnQiLCJRVUVSWV9SRVNPTFZFIiwicmVzb2x2ZVF1ZXJ5U2V0IiwicXVlcnlTZXQiLCJjdXJyZW50S2VybmVsSWQiLCJrZXJuZWxzIiwicXVlcnlUaW1lQmFzZSIsImJ1aWxkIiwiZmVhdHVyZXMiLCJjcmVhdGVTaGFkZXJNb2R1bGUiLCJjb2RlIiwiY3JlYXRlQ29tcHV0ZVBpcGVsaW5lIiwiZW50cnlQb2ludCIsIm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplIiwibGltaXRzIiwibWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24iLCJzcXJ0IiwiY2JydCIsInF1IiwiY29tbWFuZEVuY29kZXIiLCJjb21wdXRlUGFzc0VuY29kZXIiLCJzZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZyIsImN1cnJlbnRLZXJuZWxDdXN0b21EYXRhIiwiaW5pdGlhbGl6ZSIsImdwdSIsInJlcXVlc3RBZGFwdGVyIiwicmVxdWlyZWRMaW1pdHMiLCJtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUiLCJtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUiLCJtYXhCdWZmZXJTaXplIiwibWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVYIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVZIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVaIiwicmVxdWlyZWRGZWF0dXJlcyIsInJlcXVlc3REZXZpY2UiLCJwcm9ncmFtTWFuYWdlciIsImtlcm5lbFBlcnNpc3RlbnREYXRhIiwiZGVidWciLCJvbnVuY2FwdHVyZWRlcnJvciIsIkdQVVZhbGlkYXRpb25FcnJvciIsImNyZWF0ZUNvbW1hbmRFbmNvZGVyIiwiY3JlYXRlUXVlcnlTZXQiLCJ0aW1lc3RhbXBXcml0ZXMiLCJiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4IiwiZW5kT2ZQYXNzV3JpdGVJbmRleCIsImJlZ2luQ29tcHV0ZVBhc3MiLCJlbmQiLCJxdWV1ZSIsInN1Ym1pdCIsImZpbmlzaCIsInByb2ZpbGluZ01vZGUiLCJ0ZW1wb3JhcnlEYXRhIiwid3JpdGVCdWZmZXIiLCJvZmZzZXQiLCJhbGxvYyIsImZyZWUiLCJjcmVhdGVLZXJuZWwiLCJyZWxlYXNlS2VybmVsIiwiY29tcHV0ZUtlcm5lbCIsInB1c2hFcnJvclNjb3BlIiwicG9wRXJyb3JTY29wZSIsIkt1IiwiaHAiLCJ3ciIsIkp1IiwiZ3AiLCJ5cCIsIlF1IiwidnIiLCJadSIsImVsIiwidGwiLCJYdSIsInJsIiwibmwiLCJhbCIsImh0IiwiamUiLCJibiIsIkl0IiwidnAiLCJ5biIsInNsIiwidWwiLCJsbCIsImRsIiwiY2wiLCJwbCIsImZsIiwibWwiLCJ3biIsImhsIiwiJHAiLCJ2biIsInhwIiwiJG4iLCJZdSIsImN1c3RvbURhdGFPZmZzZXQiLCJjdXN0b21EYXRhU2l6ZSIsIm9wS2VybmVsQ29udGV4dCIsIm91dHB1dCIsIm9sIiwicHJlZmVycmVkT3V0cHV0TG9jYXRpb24iLCJoYW5kbGUiLCJvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMiLCJvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIiwiaWwiLCJVeSIsIndwIiwicHJveHkiLCJvdXQiLCJyZXZva2VPYmplY3RVUkwiLCJpbiIsIm1vZGVsIiwibW9kZWxkYXRhIiwib3B0aW9ucyIsInNlc3Npb25JZCIsIm91dHB1dEluZGljZXMiLCJnbCIsImNyZWF0ZVNlc3Npb25BbGxvY2F0ZSIsImxvYWRNb2RlbCIsInlsIiwiYmwiLCJ3YXNtQmFja2VuZCIsIlNwIiwid2wiLCJJcCIsImRlZmF1bHQiLCJDcCIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsInVuZGVmaW5lZCIsIl9fd2VicGFja19tb2R1bGVzX18iLCJnbG9iYWxUaGlzIiwiRnVuY3Rpb24iLCJvcnQiLCJNT0RFTF9XSURUSCIsIk1PREVMX0hFSUdIVCIsIk1PREVMX01BUCIsInNhbV9iIiwiY29uZmlnIiwicHJvdmlkZXIiLCJ0aHJlYWRzIiwidmFycyIsInNlYXJjaCIsInBhaXIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJzZUludCIsImdldENvbmZpZyIsImNhbnZhcyIsImZpbGVpbiIsImltYWdlX2VtYmVkZGluZ3MiLCJpbWFnZUltYWdlRGF0YSIsInNlc3MiLCJnZXRFbGVtZW50QnlJZCIsImlubmVyVGV4dCIsInRvRml4ZWQiLCJpbWFnZVByZXByb2Nlc3NpbmciLCJpbWdBcnIiLCJvcmlnaW5hbFRlbnNvciIsIm9yaWdpbmFsRGF0YSIsInJlc2hhcGVkVGVuc29yIiwicmVzaXplVGVuc29yIiwiaXNXaGl0ZSIsInRocmVzaG9sZCIsInBlcmNlbnQiLCJpZldoaXRlQmFja2dyb3VuZCIsImludmVydEltYWdlIiwiaW52ZXJ0V2hpdGVCYWNrZ3JvdW5kIiwiYWRkRXZlbnRMaXN0ZW5lciIsImltZyIsImlkeCIsIm9wdCIsInVybCIsImNhY2hlIiwiY2FjaGVzIiwiY2xlYXJfY2FjaGUiLCJjYWNoZWRSZXNwb25zZSIsImZldGNoQW5kQ2FjaGUiLCJsb2FkX21vZGVsIiwib25jaGFuZ2UiLCJldnQiLCJmaWxlcyIsImV2ZW50IiwiRmlsZVJlYWRlciIsImZpbGVSZWFkZXIiLCJwcmVkaWN0aW9uX2VsZW1lbnQiLCJkaXNhYmxlZCIsInN0eWxlIiwiY3Vyc29yIiwiY3R4IiwiaW1nVGVuc29yIiwiZmVlZCIsImVtYl9wcm9wZXJ0eSIsIm9yaWdpbmFsT2JqZWN0Iiwia2V5IiwiZ2V0S2V5c0FuZFZhbHVlcyIsInByb2JzIiwibWF4X3Byb2IiLCJtYXhJbmQiLCJoYW5kbGVJbWFnZSIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJtYWluIl0sInNvdXJjZVJvb3QiOiIifQ==