/*! For license information please see bundle.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}(self,(()=>(()=>{var e={122:(e,t,n)=>{"use strict";var r,a,i,o,s,u,l,d,c,p,f,h,m,g,y,w,$,v,b,x,S,_,C,E,I,A,O,T,R="/index.js",k=Object.defineProperty,B=Object.getOwnPropertyDescriptor,M=Object.getOwnPropertyNames,D=Object.prototype.hasOwnProperty,P=(e,t)=>()=>(e&&(t=e(e=0)),t),z=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),W=(e,t)=>{for(var n in t)k(e,n,{get:t[n],enumerable:!0})},N=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let n of M(t))!D.call(e,n)&&undefined!==n&&k(e,n,{get:()=>t[n],enumerable:!(r=B(t,n))||r.enumerable});return e})(k({},"__esModule",{value:!0}),e),G=P((()=>{a=new Map,i=[],o=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=a.get(e);if(void 0===r)a.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=i.indexOf(e);-1!==t&&i.splice(t,1);for(let t=0;t<i.length;t++)if(a.get(i[t]).priority<=n)return void i.splice(t,0,e);i.push(e)}}},s=async e=>{let t=0===e.length?i:e,n=[];for(let e of t){let t=a.get(e);if(t){if(t.initialized)return t.backend;if(t.aborted)continue;let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(a){r||n.push({name:e,err:a}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)}})),U=P((()=>{G()})),V=P((()=>{u="1.17.0-dev.20231103-1439da36fe"})),j=P((()=>{V(),l="warning",d={wasm:{},webgl:{},webgpu:{},versions:{common:u},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);l=e}},get logLevel(){return l}},Object.defineProperty(d,"logLevel",{enumerable:!0})})),F=P((()=>{j(),c=d})),H=P((()=>{p=(e,t)=>{let n=document.createElement("canvas");n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[3]):(a=e.dims[3],i=e.dims[2]);let o,s,u=void 0!==t?.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?o=[255,255,255,255]:"number"==typeof l.mean?o=[l.mean,l.mean,l.mean,l.mean]:(o=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(o[3]=l.mean[3])),void 0===l||void 0===l.bias?s=[0,0,0,0]:"number"==typeof l.bias?s=[l.bias,l.bias,l.bias,l.bias]:(s=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(s[3]=l.bias[3]));let d=i*a,c=0,p=d,f=2*d,h=-1;"RGBA"===u?(c=0,p=d,f=2*d,h=3*d):"RGB"===u?(c=0,p=d,f=2*d):"RBG"===u&&(c=0,f=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<a;n++){let a=(e.data[c++]-s[0])*o[0],i=(e.data[p++]-s[1])*o[1],u=(e.data[f++]-s[2])*o[2],l=-1===h?255:(e.data[h++]-s[3])*o[3];r.fillStyle="rgba("+a+","+i+","+u+","+l+")",r.fillRect(n,t,1,1)}return n.toDataURL()}throw new Error("Can not access image data")},f=(e,t)=>{let n,r=document.createElement("canvas").getContext("2d");if(null==r)throw new Error("Can not access image data");{let a,i,o;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[1],o=e.dims[3]):(a=e.dims[3],i=e.dims[2],o=e.dims[1]);let s,u,l=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?s=[255,255,255,255]:"number"==typeof d.mean?s=[d.mean,d.mean,d.mean,d.mean]:(s=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(s[3]=d.mean[3])),void 0===d||void 0===d.bias?u=[0,0,0,0]:"number"==typeof d.bias?u=[d.bias,d.bias,d.bias,d.bias]:(u=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(u[3]=d.bias[3]));let c=i*a;if(void 0!==t&&(void 0!==t.format&&4===o&&"RGBA"!==t.format||3===o&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let p=4,f=0,h=1,m=2,g=3,y=0,w=c,$=2*c,v=-1;"RGBA"===l?(y=0,w=c,$=2*c,v=3*c):"RGB"===l?(y=0,w=c,$=2*c):"RBG"===l&&(y=0,$=c,w=2*c),n=r.createImageData(a,i);for(let t=0;t<i*a;f+=p,h+=p,m+=p,g+=p,t++)n.data[f]=(e.data[y++]-u[0])*s[0],n.data[h]=(e.data[w++]-u[1])*s[1],n.data[m]=(e.data[$++]-u[2])*s[2],n.data[g]=-1===v?255:(e.data[v++]-u[3])*s[3]}return n}})),L=P((()=>{K(),h=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:a,width:i}=t,o=t.norm??{mean:255,bias:0};n="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],r="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=a*i,d="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l),c=4,p=0,f=1,h=2,m=3,g=0,y=l,w=2*l,$=-1;"RGB"===s&&(c=3,p=0,f=1,h=2,m=-1),"RGBA"===u?$=3*l:"RBG"===u?(g=0,w=l,y=2*l):"BGR"===u&&(w=0,y=l,g=2*l);for(let t=0;t<l;t++,p+=c,h+=c,f+=c,m+=c)d[g++]=(e[p]+r[0])/n[0],d[y++]=(e[f]+r[1])/n[1],d[w++]=(e[h]+r[2])/n[2],-1!==$&&-1!==m&&(d[$++]=(e[m]+r[3])/n[3]);return new C("float32",d,"RGBA"===u?[1,4,a,i]:[1,3,a,i])},m=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,o="string"==typeof e,s=t??{};if(r){let r=document.createElement("canvas");r.width=e.width,r.height=e.height;let a=r.getContext("2d");if(null==a)throw new Error("Can not access image data");{let r=e.height,i=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=r,s.width=i}else s.tensorFormat="RGBA",s.height=r,s.width=i;a.drawImage(e,0,0),n=a.getImageData(0,0,i,r).data}}else{if(!a){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=document.createElement("canvas");r.width=e.width,r.height=e.height;let a=r.getContext("2d");if(null!=a){let t=e.height,r=e.width;return a.drawImage(e,0,0,r,t),n=a.getImageData(0,0,r,t).data,s.height=t,s.width=r,h(n,s)}throw new Error("Can not access image data")}if(o)return new Promise(((t,n)=>{let r=document.createElement("canvas"),a=r.getContext("2d");if(!e||!a)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,a.drawImage(i,0,0,r.width,r.height);let e=a.getImageData(0,0,r.width,r.height);s.height=r.height,s.width=r.width,t(h(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,a;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,a=t.resizedWidth):(r=e.height,a=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=r,s.width=a,void 0!==t){let t=document.createElement("canvas");t.width=a,t.height=r;let i=t.getContext("2d");if(null==i)throw new Error("Can not access image data");i.putImageData(e,0,0),n=i.getImageData(0,0,a,r).data}else n=e.data}}if(void 0!==n)return h(n,s);throw new Error("Input data provided is not supported - aborted tensor creation")},g=(e,t)=>{let{width:n,height:r,download:a,dispose:i}=t;return new C({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:a,dispose:i})},y=(e,t)=>{let{dataType:n,dims:r,download:a,dispose:i}=t;return new C({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:a,dispose:i})},w=(e,t,n)=>new C({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),q=P((()=>{$=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),v=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),b=!1,x=()=>{if(!b){b=!0;let e=typeof BigInt64Array<"u"&&"function"==typeof BigInt64Array.from,t=typeof BigUint64Array<"u"&&"function"==typeof BigUint64Array.from;e&&($.set("int64",BigInt64Array),v.set(BigInt64Array,"int64")),t&&($.set("uint64",BigUint64Array),v.set(BigUint64Array,"uint64"))}}})),Y=P((()=>{K(),S=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},_=(e,t)=>{switch(e.location){case"cpu":return new C(e.type,e.data,t);case"cpu-pinned":return new C({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new C({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new C({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),K=P((()=>{H(),L(),q(),Y(),C=class{constructor(e,t,n){let r,a;if(x(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,a=e.dims,e.location){case"cpu-pinned":{let t=$.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"bool"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,o;if("string"==typeof e)if(r=e,o=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");i=t}else{let n=$.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);i=t}}else if(o=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else{let t=v.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===o)o=[i.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");a=o,this.cpuData=i,this.dataLocation="cpu"}let i=S(a);if(this.cpuData&&i!==this.cpuData.length)throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=i}static async fromImage(e,t){return m(e,t)}static fromTexture(e,t){return g(e,t)}static fromGpuBuffer(e,t){return y(e,t)}static fromPinnedBuffer(e,t,n){return w(e,t,n)}toDataURL(e){return p(this,e)}toImageData(e){return f(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return _(this,e)}}})),X=P((()=>{K(),E=C})),J=P((()=>{G(),X(),I=class e{constructor(e){this.handler=e}async run(e,t,n){let r={},a={};if("object"!=typeof e||null===e||e instanceof E||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,o=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==o.indexOf(n)){let a=t[n];(null===a||a instanceof E)&&(e=!0,i=!1,r[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(let e of this.outputNames)r[e]=null;let o=await this.handler.run(e,r,a),s={};for(let e in o)if(Object.hasOwnProperty.call(o,e)){let t=o[e];s[e]=t instanceof E?t:new E(t.type,t.data,t.dims)}return s}async release(){return this.handler.dispose()}static async create(t,n,r,a){let i,o={};if("string"==typeof t){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,s=0,u=t.byteLength;if("object"==typeof n&&null!==n)o=n;else if("number"==typeof n){if(s=n,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(u=t.byteLength-s,"number"==typeof r){if(u=r,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||s+u>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-s}].`);if("object"==typeof a&&null!==a)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(e,s,u)}}let u=(o.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await(await s(u)).createInferenceSessionHandler(i,o);return new e(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),Q=P((()=>{J(),A=I})),Z=P((()=>{})),ee=P((()=>{G(),X(),O=class e{constructor(e){this.handler=e}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,n){let r=t.evalModel||"",a=t.optimizerModel||"",i=n||{},o=(i.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),u=await s(o);if(u.createTrainingSessionHandler){let n=await u.createTrainingSessionHandler(t.checkpointState,t.trainModel,r,a,i);return new e(n)}throw new Error("Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.")}typeNarrowingForRunStep(e,t,n){let r={},a={};if("object"!=typeof e||null===e||e instanceof E||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,o=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==o.indexOf(n)){let a=t[n];(null===a||a instanceof E)&&(e=!0,i=!1,r[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(let e of this.outputNames)r[e]=null;return[r,a]}convertHandlerReturnTypeToMapOfTensors(e){let t={};for(let n in e)if(Object.hasOwnProperty.call(e,n)){let r=e[n];t[n]=r instanceof E?r:new E(r.type,r.data,r.dims)}return t}async runTrainStep(e,t,n){let[r,a]=this.typeNarrowingForRunStep(e,t,n),i=await this.handler.runTrainStep(e,r,a);return this.convertHandlerReturnTypeToMapOfTensors(i)}async loadParametersBuffer(e,t){throw new Error("Method not implemented.")}async getContiguousParameters(e){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}})),te=P((()=>{ee(),T=O})),ne={};W(ne,{InferenceSession:()=>A,Tensor:()=>E,TrainingSession:()=>T,env:()=>c,registerBackend:()=>o});var re=P((()=>{U(),F(),Q(),X(),Z(),te()})),ae={};W(ae,{readFile:()=>ie});var ie,oe=P((()=>{ie=void 0})),se={};W(se,{join:()=>ue});var ue,le=P((()=>{ue=void 0})),de=z(((n,a)=>{var i,o=(i=(i=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||R,function(e={}){var t,n,r=e;r.ready=new Promise(((e,r)=>{t=e,n=r})),r.jsepInit=(e,t,n,a,i,o,s,u)=>{r.Za=e,r.Oa=t,r.Qa=n,r.Ja=a,r.Pa=i,r.ra=o,r.Ra=s,r.Sa=u,t=(e,t,n)=>(...r)=>{let a=be,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),be!=a?new Promise(((e,t)=>{Ie={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(r.Da)throw Error("Session already started");let a=r.Da={Ta:n[0],errors:[]},i=await t(...n);if(r.Da!==a)throw Error("Session mismatch");e.flush();let o=a.errors;if(0<o.length){let e=await Promise.all(o);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return i}finally{r.Da=null}},r._OrtRun=n(t(r._OrtRun,(()=>r._OrtRun),(e=>r._OrtRun=e))),r._OrtRunWithBinding=n(t(r._OrtRunWithBinding,(()=>r._OrtRunWithBinding),(e=>r._OrtRunWithBinding=e))),r._OrtBindInput=t(r._OrtBindInput,(()=>r._OrtBindInput),(e=>r._OrtBindInput=e)),r.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),r.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},r.jsepGetBuffer=t=>e.getBuffer(t),r.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r)};var a,o,s,u=Object.assign({},r),l="./this.program",d=(e,t)=>{throw t},c="object"==typeof window,p="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var m=(oe(),N(ae)),g=(le(),N(se));h=p?g.dirname(h)+"/":"//",a=(e,t)=>(e=e.startsWith("file://")?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),s=e=>((e=a(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):g.normalize(e),m.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!r.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),d=(e,t)=>{throw process.exitCode=e,t},r.inspect=()=>"[Emscripten Module object]"}else(c||p)&&(p?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),i&&(h=i),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},p&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,w=r.print||console.log.bind(console),$=r.printErr||console.error.bind(console);Object.assign(r,u),u=null,r.thisProgram&&(l=r.thisProgram),r.quit&&(d=r.quit),r.wasmBinary&&(y=r.wasmBinary);var v=r.noExitRuntime||!0;"object"!=typeof WebAssembly&&U("no native wasm support detected");var b,x,S,_,C,E,I,A,O,T=!1;function R(){var e=b.buffer;r.HEAP8=_=new Int8Array(e),r.HEAP16=new Int16Array(e),r.HEAP32=E=new Int32Array(e),r.HEAPU8=C=new Uint8Array(e),r.HEAPU16=new Uint16Array(e),r.HEAPU32=I=new Uint32Array(e),r.HEAPF32=A=new Float32Array(e),r.HEAPF64=O=new Float64Array(e)}var k=[],B=[],M=[];function D(){var e=r.preRun.shift();k.unshift(e)}var P,z=0,W=null,G=null;function U(e){throw r.onAbort&&r.onAbort(e),$(e="Aborted("+e+")"),T=!0,S=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function V(e){return e.startsWith("data:application/octet-stream;base64,")}if(!V(P="ort-wasm-simd.wasm")){var j=P;P=r.locateFile?r.locateFile(j,h):h+j}function F(e){if(e==P&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function H(e,t,n){return function(e){if(!y&&(c||p)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>F(e)));if(o)return new Promise(((t,n)=>{o(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>F(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{$("failed to asynchronously prepare wasm: "+e),U(e)}))}var L,q={913792:e=>{r.ra("Abs",e,void 0)},913843:e=>{r.ra("Neg",e,void 0)},913894:e=>{r.ra("Floor",e,void 0)},913947:e=>{r.ra("Ceil",e,void 0)},913999:e=>{r.ra("Reciprocal",e,void 0)},914057:e=>{r.ra("Sqrt",e,void 0)},914109:e=>{r.ra("Exp",e,void 0)},914160:e=>{r.ra("Erf",e,void 0)},914211:e=>{r.ra("Sigmoid",e,void 0)},914266:e=>{r.ra("Log",e,void 0)},914317:e=>{r.ra("Sin",e,void 0)},914368:e=>{r.ra("Cos",e,void 0)},914419:e=>{r.ra("Tan",e,void 0)},914470:e=>{r.ra("Asin",e,void 0)},914522:e=>{r.ra("Acos",e,void 0)},914574:e=>{r.ra("Atan",e,void 0)},914626:e=>{r.ra("Sinh",e,void 0)},914678:e=>{r.ra("Cosh",e,void 0)},914730:e=>{r.ra("Asinh",e,void 0)},914783:e=>{r.ra("Acosh",e,void 0)},914836:e=>{r.ra("Atanh",e,void 0)},914889:e=>{r.ra("Tanh",e,void 0)},914941:e=>{r.ra("Not",e,void 0)},914992:(e,t,n)=>{r.ra("ClipV10",e,{min:t,max:n})},915064:e=>{r.ra("Clip",e,void 0)},915116:(e,t)=>{r.ra("Elu",e,{alpha:t})},915174:e=>{r.ra("Relu",e,void 0)},915226:(e,t)=>{r.ra("LeakyRelu",e,{alpha:t})},915290:(e,t)=>{r.ra("ThresholdedRelu",e,{alpha:t})},915360:(e,t)=>{r.ra("Cast",e,{to:t})},915418:e=>{r.ra("Add",e,void 0)},915469:e=>{r.ra("Sub",e,void 0)},915520:e=>{r.ra("Mul",e,void 0)},915571:e=>{r.ra("Div",e,void 0)},915622:e=>{r.ra("Pow",e,void 0)},915673:e=>{r.ra("Equal",e,void 0)},915726:e=>{r.ra("Greater",e,void 0)},915781:e=>{r.ra("GreaterOrEqual",e,void 0)},915843:e=>{r.ra("Less",e,void 0)},915895:e=>{r.ra("LessOrEqual",e,void 0)},915954:(e,t,n,a,i)=>{r.ra("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916118:(e,t,n,a,i)=>{r.ra("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916281:(e,t,n,a,i)=>{r.ra("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916444:(e,t,n,a,i)=>{r.ra("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916608:(e,t,n,a,i)=>{r.ra("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916771:(e,t,n,a,i)=>{r.ra("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916933:(e,t,n,a,i)=>{r.ra("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917095:(e,t,n,a,i)=>{r.ra("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917261:(e,t,n,a,i)=>{r.ra("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917430:(e,t,n,a,i)=>{r.ra("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917599:e=>{r.ra("Where",e,void 0)},917652:(e,t,n)=>{r.ra("Transpose",e,{perm:t?Array.from(E.subarray(n>>>0,n+t>>>0)):[]})},917765:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m)=>{r.ra("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[d>>>0],outputPadding:c?Array.from(E.subarray(p>>>0,p+c>>>0)):[],outputShape:f?Array.from(E.subarray(h>>>0,h+f>>>0)):[],activation:ee(m)})},918179:(e,t,n,a,i,o,s,u,l,d,c,p,f,h)=>{r.ra("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(E.subarray(n>>>0,n+2>>>0)),group:a,kernelShape:Array.from(E.subarray(i>>>0,i+2>>>0)),pads:Array.from(E.subarray(o>>>0,o+4>>>0)),strides:Array.from(E.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<d?Array.from(E.subarray(c>>>0,c+d>>>0)):[],outputShape:0<p?Array.from(E.subarray(f>>>0,f+p>>>0)):[],activation:ee(h)})},918736:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m)=>{r.ra("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[d>>>0],outputPadding:c?Array.from(E.subarray(p>>>0,p+c>>>0)):[],outputShape:f?Array.from(E.subarray(h>>>0,h+f>>>0)):[],activation:ee(m)})},919150:(e,t,n,a,i,o,s,u,l,d,c,p,f,h)=>{r.ra("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(E.subarray(n>>>0,n+2>>>0)),group:a,kernelShape:Array.from(E.subarray(i>>>0,i+2>>>0)),pads:Array.from(E.subarray(o>>>0,o+4>>>0)),strides:Array.from(E.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<d?Array.from(E.subarray(c>>>0,c+d>>>0)):[],outputShape:0<p?Array.from(E.subarray(f>>>0,f+p>>>0)):[],activation:ee(h)})},919707:(e,t)=>{r.ra("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},919798:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920082:(e,t)=>{r.ra("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},920173:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920457:(e,t)=>{r.ra("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},920544:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920824:(e,t)=>{r.ra("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},920911:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},921191:(e,t,n,a,i)=>{r.ra("Gemm",e,{alpha:t,beta:n,transA:a,transB:i})},921295:e=>{r.ra("MatMul",e,void 0)},921349:(e,t,n,a)=>{r.ra("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},921457:(e,t,n,a)=>{r.ra("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},921565:(e,t)=>{r.ra("Softmax",e,{axis:t})},921628:(e,t)=>{r.ra("Concat",e,{axis:t})},921688:(e,t,n,a,i)=>{r.ra("Split",e,{axis:t,numOutputs:n,splitSizes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},921833:e=>{r.ra("Expand",e,void 0)},921887:(e,t)=>{r.ra("Gather",e,{axis:Number(t)})},921958:(e,t)=>{r.ra("GatherElements",e,{axis:Number(t)})},922037:(e,t,n,a,i,o,s,u,l,d,c)=>{r.ra("Resize",e,{antialias:t,axes:n?Array.from(E.subarray(a>>>0,a+n>>>0)):[],coordinateTransformMode:ee(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:ee(l),mode:ee(d),nearestMode:ee(c)})},922388:(e,t,n,a,i,o,s)=>{r.ra("Slice",e,{starts:t?Array.from(E.subarray(n>>>0,n+t>>>0)):[],ends:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[],axes:o?Array.from(E.subarray(s>>>0,s+o>>>0)):[]})},922619:e=>{r.ra("Tile",e,void 0)},922671:(e,t,n)=>{r.ra("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},922778:(e,t,n)=>{r.ra("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},922892:(e,t,n)=>{r.ra("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},923006:e=>{r.ra("Range",e,void 0)},923059:(e,t)=>{r.ra("Einsum",e,{equation:ee(t)})},923140:(e,t,n,a,i)=>{r.ra("Pad",e,{mode:t,value:n,pads:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},923272:e=>{r.ra("Gelu",e,void 0)},923324:e=>{r.ra("BiasAdd",e,void 0)},923379:e=>{r.ra("BiasSplitGelu",e,void 0)},923440:(e,t)=>{r.ra("SkipLayerNormalization",e,{epsilon:t})},923521:(e,t,n,a,i,o,s,u,l,d,c,p,f)=>{r.ra("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:a,kernel_shape:[i],pads:o?Array.from(E.subarray(s>>>0,s+o>>>0)):[],strides:[u],w_is_const:()=>!!_[d>>>0],activation:ee(c),activation_params:p?Array.from(A.subarray(f>>>0,f+p>>>0)):[]})},923902:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:t,dilations:[n,a],group:i,kernel_shape:[o,s],pads:u?Array.from(E.subarray(l>>>0,l+u>>>0)):[],strides:[d,c],w_is_const:()=>!!_[f>>>0],activation:ee(h),activation_params:m?Array.from(A.subarray(g>>>0,g+m>>>0)):[]})},924304:e=>{r.Ra(e)},924338:(e,t)=>r.Sa(e,t,r.Da.Ta,r.Da.errors),924450:e=>r.Oa(e),924483:e=>r.Qa(e),924515:(e,t,n)=>{r.Ja(e,t,n,!0)},924554:(e,t,n)=>{r.Ja(e,t,n)}};function Y(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var K=e=>{for(;0<e.length;)e.shift()(r)};function X(e){this.Ha=e-24,this.Ma=function(e){I[this.Ha+4>>2>>>0]=e},this.La=function(e){I[this.Ha+8>>2>>>0]=e},this.Ya=function(e,t){this.Ka(),this.Ma(e),this.La(t)},this.Ka=function(){I[this.Ha+16>>2>>>0]=0}}var J,Q=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Z=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Q)return Q.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},ee=(e,t)=>(e>>>=0)?Z(C,e,t):"",te=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},ne=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},re=e=>e%4==0&&(e%100!=0||e%400==0),ie=[0,31,60,91,121,152,182,213,244,274,305,335],ue=[0,31,59,90,120,151,181,212,243,273,304,334],de=e=>{var t=te(e)+1,n=Re(t);return n&&ne(e,C,n,t),n},ce=[],pe=(e,t)=>{var n;for(ce.length=0,t>>=2;n=C[e++>>>0];)t+=105!=n&t,ce.push(105==n?E[t>>>0]:O[t++>>>1]),++t;return ce},fe={},he=()=>{if(!J){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"};for(e in fe)void 0===fe[e]?delete t[e]:t[e]=fe[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);J=n}return J},me=[null,[],[]],ge=[31,29,31,30,31,30,31,31,30,31,30,31],ye=[31,28,31,30,31,30,31,31,30,31,30,31];function we(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return a(e,t,"0")}function o(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.Ba;for(e=new Date(new Date(e.Ca+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(re(e.getFullYear())?ge:ye)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=o(t,e)?0>=o(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0;var l=E[40+(r>>>=0)>>2>>>0];for(var d in r={Wa:E[r>>2>>>0],Va:E[r+4>>2>>>0],Ea:E[r+8>>2>>>0],Ia:E[r+12>>2>>>0],Fa:E[r+16>>2>>>0],Ca:E[r+20>>2>>>0],wa:E[r+24>>2>>>0],Ba:E[r+28>>2>>>0],$a:E[r+32>>2>>>0],Ua:E[r+36>>2>>>0],Xa:l?ee(l):""},n=ee(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(d,"g"),l[d]);var c="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(d in l={"%a":e=>c[e.wa].substring(0,3),"%A":e=>c[e.wa],"%b":e=>p[e.Fa].substring(0,3),"%B":e=>p[e.Fa],"%C":e=>i((e.Ca+1900)/100|0,2),"%d":e=>i(e.Ia,2),"%e":e=>a(e.Ia,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>i(e.Ea,2),"%I":e=>(0==(e=e.Ea)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Fa-1;t+=(re(e.Ca+1900)?ge:ye)[n++]);return i(e.Ia+t,3)},"%m":e=>i(e.Fa+1,2),"%M":e=>i(e.Va,2),"%n":()=>"\n","%p":e=>0<=e.Ea&&12>e.Ea?"AM":"PM","%S":e=>i(e.Wa,2),"%t":()=>"\t","%u":e=>e.wa||7,"%U":e=>i(Math.floor((e.Ba+7-e.wa)/7),2),"%V":e=>{var t=Math.floor((e.Ba+7-(e.wa+6)%7)/7);if(2>=(e.wa+371-e.Ba-2)%7&&t++,t)53==t&&(4==(n=(e.wa+371-e.Ba)%7)||3==n&&re(e.Ca)||(t=1));else{t=52;var n=(e.wa+7-e.Ba-1)%7;(4==n||5==n&&re(e.Ca%400-1))&&t++}return i(t,2)},"%w":e=>e.wa,"%W":e=>i(Math.floor((e.Ba+7-(e.wa+6)%7)/7),2),"%y":e=>(e.Ca+1900).toString().substring(2),"%Y":e=>e.Ca+1900,"%z":e=>(0<=(e=e.Ua)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.Xa,"%%":()=>"%"},n=n.replace(/%%/g,"\0\0"),l)n.includes(d)&&(n=n.replace(new RegExp(d,"g"),l[d](r)));return d=function(e){var t=Array(te(e)+1);return ne(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),d.length>t?0:(_.set(d,e>>>0),d.length-1)}function $e(e){try{e()}catch(e){U(e)}}var ve=0,be=null,xe=0,Se=[],_e={},Ce={},Ee=0,Ie=null,Ae=[];var Oe={n:function(e,t,n){return function(e){return function(e){if(!T){if(0===ve){var t=!1,n=!1;e(((e=0)=>{if(!T&&(xe=e,t=!0,n)){ve=2,$e((()=>Ne(be))),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),e=!1;try{var r=(0,x[Ce[E[be+8>>2>>>0]]])()}catch(t){r=t,e=!0}var a=!1;if(!be){var i=Ie;i&&(Ie=null,(e?i.reject:i.resolve)(r),a=!0)}if(e&&!a)throw r}})),n=!0,t||(ve=1,be=function(){var e=Re(65548),t=e+12;I[e>>2>>>0]=t,I[e+4>>2>>>0]=t+65536,t=Se[0];var n=_e[t];return void 0===n&&(n=Ee++,_e[t]=n,Ce[n]=t),E[e+8>>2>>>0]=n,e}(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),$e((()=>ze(be))))}else 2===ve?(ve=0,$e(Ge),ke(be),be=null,Ae.forEach((e=>{if(!T)try{if(e(),!v)try{S=S=e=S,v||(r.onExit&&r.onExit(e),T=!0),d(e,new Y(e))}catch(e){e instanceof Y||"unwind"==e||d(1,e)}}catch(e){e instanceof Y||"unwind"==e||d(1,e)}}))):U(`invalid state: ${ve}`);return xe}}((t=>{e().then(t)}))}((async()=>{await r.Pa(e,t,n)}))},a:function(e,t,n){throw new X(e>>>=0).Ya(t>>>0,n>>>0),e},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),E[n>>2>>>0]=e.getUTCSeconds(),E[n+4>>2>>>0]=e.getUTCMinutes(),E[n+8>>2>>>0]=e.getUTCHours(),E[n+12>>2>>>0]=e.getUTCDate(),E[n+16>>2>>>0]=e.getUTCMonth(),E[n+20>>2>>>0]=e.getUTCFullYear()-1900,E[n+24>>2>>>0]=e.getUTCDay(),E[n+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),E[n>>2>>>0]=e.getSeconds(),E[n+4>>2>>>0]=e.getMinutes(),E[n+8>>2>>>0]=e.getHours(),E[n+12>>2>>>0]=e.getDate(),E[n+16>>2>>>0]=e.getMonth(),E[n+20>>2>>>0]=e.getFullYear()-1900,E[n+24>>2>>>0]=e.getDay(),E[n+28>>2>>>0]=(re(e.getFullYear())?ie:ue)[e.getMonth()]+e.getDate()-1|0,E[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();E[n+32>>2>>>0]=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t))},s:function(e){e>>>=0;var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,a);return 0>n?E[e+32>>2>>>0]=+(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(re(t.getFullYear())?ie:ue)[t.getMonth()]+t.getDate()-1|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Be((L=e,1<=+Math.abs(L)?0<L?+Math.floor(L/4294967296)>>>0:~~+Math.ceil((L-+(~~L>>>0))/4294967296)>>>0:0)),e>>>0},o:function(){return-52},p:function(){},v:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}n>>>=0;var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var s=o.getTimezoneOffset();I[e>>>0>>2>>>0]=60*Math.max(a,s),E[t>>>0>>2>>>0]=+(a!=s),e=r(i),t=r(o),e=de(e),t=de(t),s<a?(I[n>>2>>>0]=e,I[n+4>>2>>>0]=t):(I[n>>2>>>0]=t,I[n+4>>2>>>0]=e)},e:()=>{U("")},b:function(e,t,n){return e>>>=0,t=pe(t>>>0,n>>>0),q[e].apply(null,t)},i:function(e,t,n){return e>>>=0,t=pe(t>>>0,n>>>0),q[e].apply(null,t)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(e,t,n){return t>>>=0,C.copyWithin(e>>>0>>>0,t>>>0,t+(n>>>0)>>>0)},u:function(e){e>>>=0;var t=C.length;if(4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r);e:{a=a.min.call(a,4294901760,r+(65536-r%65536)%65536)-b.buffer.byteLength+65535>>>16;try{b.grow(a),R();var i=1;break e}catch{}i=void 0}if(i)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var n=0;return he().forEach((function(r,a){var i=t+n;for(a=I[e+4*a>>2>>>0]=i,i=0;i<r.length;++i)_[a++>>0>>>0]=r.charCodeAt(i);_[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var n=he();I[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),I[t>>2>>>0]=r,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(e,t,n,r){t>>>=0,n>>>=0,r>>>=0;for(var a=0,i=0;i<n;i++){var o=I[t>>2>>>0],s=I[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=C[o+u>>>0],d=me[e];0===l||10===l?((1===e?w:$)(Z(d,0)),d.length=0):d.push(l)}a+=s}return I[r>>2>>>0]=a,0},F:we,d:function(e,t,n,r){return we(e>>>0,t>>>0,n>>>0,r>>>0)}};(function(){function e(e){if(e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){Se.push(t);try{return r.apply(null,arguments)}finally{T||(Se.pop()===t||U(),be&&1===ve&&0===Se.length&&(ve=0,$e(We),typeof Fibers<"u"&&Fibers.ab()))}}:r}(t);return n}(e=e.exports),x=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),b=x.M,R(),B.unshift(x.N),z--,r.monitorRunDependencies&&r.monitorRunDependencies(z),0==z&&(null!==W&&(clearInterval(W),W=null),G)){var t=G;G=null,t()}return e}var t={a:Oe};if(z++,r.monitorRunDependencies&&r.monitorRunDependencies(z),r.instantiateWasm)try{return r.instantiateWasm(t,e)}catch(e){$("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var n=P;return y||"function"!=typeof WebAssembly.instantiateStreaming||V(n)||n.startsWith("file://")||f||"function"!=typeof fetch?H(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return $("wasm streaming compile failed: "+r),$("falling back to ArrayBuffer instantiation"),H(n,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)})(),r._OrtInit=(e,t)=>(r._OrtInit=x.O)(e,t),r._OrtGetLastError=(e,t)=>(r._OrtGetLastError=x.P)(e,t),r._OrtCreateSessionOptions=(e,t,n,a,i,o,s,u,l,d)=>(r._OrtCreateSessionOptions=x.Q)(e,t,n,a,i,o,s,u,l,d),r._OrtAppendExecutionProvider=(e,t)=>(r._OrtAppendExecutionProvider=x.R)(e,t),r._OrtAddFreeDimensionOverride=(e,t,n)=>(r._OrtAddFreeDimensionOverride=x.S)(e,t,n),r._OrtAddSessionConfigEntry=(e,t,n)=>(r._OrtAddSessionConfigEntry=x.T)(e,t,n),r._OrtReleaseSessionOptions=e=>(r._OrtReleaseSessionOptions=x.U)(e),r._OrtCreateSession=(e,t,n)=>(r._OrtCreateSession=x.V)(e,t,n),r._OrtReleaseSession=e=>(r._OrtReleaseSession=x.W)(e),r._OrtGetInputOutputCount=(e,t,n)=>(r._OrtGetInputOutputCount=x.X)(e,t,n),r._OrtGetInputName=(e,t)=>(r._OrtGetInputName=x.Y)(e,t),r._OrtGetOutputName=(e,t)=>(r._OrtGetOutputName=x.Z)(e,t),r._OrtFree=e=>(r._OrtFree=x._)(e),r._OrtCreateTensor=(e,t,n,a,i,o)=>(r._OrtCreateTensor=x.$)(e,t,n,a,i,o),r._OrtGetTensorData=(e,t,n,a,i)=>(r._OrtGetTensorData=x.aa)(e,t,n,a,i),r._OrtReleaseTensor=e=>(r._OrtReleaseTensor=x.ba)(e),r._OrtCreateRunOptions=(e,t,n,a)=>(r._OrtCreateRunOptions=x.ca)(e,t,n,a),r._OrtAddRunConfigEntry=(e,t,n)=>(r._OrtAddRunConfigEntry=x.da)(e,t,n),r._OrtReleaseRunOptions=e=>(r._OrtReleaseRunOptions=x.ea)(e),r._OrtCreateBinding=e=>(r._OrtCreateBinding=x.fa)(e),r._OrtBindInput=(e,t,n)=>(r._OrtBindInput=x.ga)(e,t,n),r._OrtBindOutput=(e,t,n,a)=>(r._OrtBindOutput=x.ha)(e,t,n,a),r._OrtClearBoundOutputs=e=>(r._OrtClearBoundOutputs=x.ia)(e),r._OrtReleaseBinding=e=>(r._OrtReleaseBinding=x.ja)(e),r._OrtRunWithBinding=(e,t,n,a,i)=>(r._OrtRunWithBinding=x.ka)(e,t,n,a,i),r._OrtRun=(e,t,n,a,i,o,s,u)=>(r._OrtRun=x.la)(e,t,n,a,i,o,s,u),r._OrtEndProfiling=e=>(r._OrtEndProfiling=x.ma)(e),r._JsepOutput=(e,t,n)=>(r._JsepOutput=x.na)(e,t,n),r._JsepGetNodeName=e=>(r._JsepGetNodeName=x.oa)(e);var Te,Re=r._malloc=e=>(Re=r._malloc=x.pa)(e),ke=r._free=e=>(ke=r._free=x.qa)(e),Be=e=>(Be=x.sa)(e),Me=()=>(Me=x.ta)(),De=e=>(De=x.ua)(e),Pe=e=>(Pe=x.va)(e),ze=e=>(ze=x.xa)(e),We=()=>(We=x.ya)(),Ne=e=>(Ne=x.za)(e),Ge=()=>(Ge=x.Aa)();function Ue(){function e(){if(!Te&&(Te=!0,r.calledRun=!0,!T)){if(K(B),t(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for("function"==typeof r.postRun&&(r.postRun=[r.postRun]);r.postRun.length;){var e=r.postRun.shift();M.unshift(e)}K(M)}}if(!(0<z)){if(r.preRun)for("function"==typeof r.preRun&&(r.preRun=[r.preRun]);r.preRun.length;)D();K(k),0<z||(r.setStatus?(r.setStatus("Running..."),setTimeout((function(){setTimeout((function(){r.setStatus("")}),1),e()}),1)):e())}}if(r.___start_em_js=924587,r.___stop_em_js=924748,r.stackAlloc=Pe,r.stackSave=Me,r.stackRestore=De,r.UTF8ToString=ee,r.stringToUTF8=(e,t,n)=>ne(e,C,t,n),r.lengthBytesUTF8=te,G=function e(){Te||Ue(),Te||(G=e)},r.preInit)for("function"==typeof r.preInit&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Ue(),e.ready});"object"==typeof n&&"object"==typeof a?a.exports=o:void 0===(r=(()=>o).apply(t,[]))||(e.exports=r)})),ce=z((()=>{})),pe=z((()=>{})),fe={};W(fe,{cpus:()=>he});var he,me,ge,ye,we,$e,ve,be,xe,Se,_e,Ce,Ee,Ie,Ae,Oe,Te,Re,ke,Be,Me,De,Pe,ze,We,Ne,Ge,Ue,Ve,je,Fe,He,Le,qe,Ye,Ke,Xe,Je,Qe,Ze,et,tt,nt,rt,at,it,ot,st,ut,lt,dt,ct,pt,ft,ht,mt,gt,yt,wt,$t,vt,bt,xt,St,_t,Ct,Et,It,At,Ot,Tt,Rt,kt,Bt,Mt,Dt,Pt,zt,Wt,Nt,Gt,Ut,Vt,jt,Ft,Ht,Lt,qt,Yt,Kt,Xt,Jt,Qt,Zt,en,tn,nn,rn,an,on,sn,un,ln,dn,cn,pn,fn,hn,mn,gn,yn,wn,$n,vn,bn,xn,Sn,_n,Cn,En,In,An,On,Tn,Rn,kn,Bn,Mn,Dn,Pn,zn,Wn,Nn,Gn,Un,Vn,jn,Fn,Hn,Ln,qn,Yn,Kn,Xn,Jn,Qn,Zn,er,tr,nr,rr,ar,ir,or,sr,ur,lr,dr,cr,pr,fr,hr,mr,gr,yr,wr,$r,vr,br,xr,Sr,_r,Cr,Er,Ir,Ar,Or,Tr,Rr,kr,Br,Mr,Dr,Pr,zr,Wr,Nr,Gr,Ur,Vr,jr,Fr,Hr,Lr,qr,Yr,Kr,Xr,Jr,Qr,Zr,ea,ta,na,ra,aa,ia,oa,sa,ua,la,da,ca,pa,fa,ha,ma,ga,ya,wa,$a,va,ba,xa,Sa,_a,Ca,Ea,Ia,Aa,Oa,Ta,Ra,ka,Ba,Ma,Da,Pa,za,Wa,Na,Ga,Ua,Va,ja,Fa,Ha,La,qa,Ya,Ka,Xa,Ja,Qa,Za,ei,ti,ni,ri,ai,ii,oi,si,ui,li,di,ci,pi,fi,hi,mi,gi,yi,wi,$i,vi,bi,xi,Si,_i,Ci,Ei,Ii,Ai,Oi,Ti,Ri,ki,Bi,Mi,Di,Pi,zi,Wi,Ni,Gi,Ui,Vi,ji,Fi,Hi,Li,qi,Yi,Ki,Xi,Ji,Qi,Zi,eo,to,no,ro,ao,io,oo,so,uo,lo,co,po,fo,ho,mo,go,yo,wo,$o,vo,bo,xo,So,_o,Co,Eo,Io,Ao,Oo,To,Ro,ko,Bo,Mo,Do,Po,zo,Wo,No=P((()=>{he=void 0})),Go=z(((a,i)=>{var o,s=(o=(o=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||R,function(e={}){function t(){return k.buffer!=P.buffer&&F(),P}function r(){return k.buffer!=P.buffer&&F(),z}function a(){return k.buffer!=P.buffer&&F(),W}function i(){return k.buffer!=P.buffer&&F(),G}function s(){return k.buffer!=P.buffer&&F(),U}function u(){return k.buffer!=P.buffer&&F(),V}var l,d,c=e;c.ready=new Promise(((e,t)=>{l=e,d=t})),c.jsepInit=(e,t,n,r,a,i,o,s)=>{c.Qb=e,c.wb=t,c.yb=n,c.jb=r,c.xb=a,c.Ea=i,c.zb=o,c.Ab=s,t=(e,t,n)=>(...r)=>{let a=xt,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),xt!=a?new Promise(((e,t)=>{At={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(c.bb)throw Error("Session already started");let r=c.bb={Fb:n[0],errors:[]},a=await t(...n);if(c.bb!==r)throw Error("Session mismatch");e.flush();let i=r.errors;if(0<i.length){let e=await Promise.all(i);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return a}finally{c.bb=null}},c._OrtRun=n(t(c._OrtRun,(()=>c._OrtRun),(e=>c._OrtRun=e))),c._OrtRunWithBinding=n(t(c._OrtRunWithBinding,(()=>c._OrtRunWithBinding),(e=>c._OrtRunWithBinding=e))),c._OrtBindInput=t(c._OrtBindInput,(()=>c._OrtBindInput),(e=>c._OrtBindInput=e)),c.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),c.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},c.jsepGetBuffer=t=>e.getBuffer(t),c.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r)};var p,f,h,m=Object.assign({},c),g="./this.program",y=(e,t)=>{throw t},w="object"==typeof window,$="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,x="";function S(e){return c.locateFile?c.locateFile(e,x):x+e}if(v){var _=(oe(),N(ae)),C=(le(),N(se));let e;x=$?C.dirname(x)+"/":"//",p=(e,t)=>(e=e.startsWith("file://")?new URL(e):C.normalize(e),_.readFileSync(e,t?void 0:"utf8")),h=e=>((e=p(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):C.normalize(e),_.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),y=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{e=ce()}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=e.Worker}else(w||$)&&($?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),typeof o<"u"&&o&&(x=o),x=0!==x.indexOf("blob:")?x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},$&&(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));v&&typeof performance>"u"&&(n.g.performance=pe().performance);var E=console.log.bind(console),I=console.error.bind(console);v&&(E=(...e)=>_.writeSync(1,e.join(" ")+"\n"),I=(...e)=>_.writeSync(2,e.join(" ")+"\n"));var A,O=c.print||E,T=c.printErr||I;Object.assign(c,m),m=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(y=c.quit),c.wasmBinary&&(A=c.wasmBinary);var R=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&re("no native wasm support detected");var k,B,M,D,P,z,W,G,U,V,j=!1;function F(){var e=k.buffer;c.HEAP8=P=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=W=new Int32Array(e),c.HEAPU8=z=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=G=new Uint32Array(e),c.HEAPF32=U=new Float32Array(e),c.HEAPF64=V=new Float64Array(e)}var H=c.INITIAL_MEMORY||16777216;if(5242880<=H||re("INITIAL_MEMORY should be larger than STACK_SIZE, was "+H+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:H/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw T("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&T("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");F(),H=k.buffer.byteLength;var L=[],q=[],Y=[],K=0;function X(){return R||0<K}var J,Q=0,Z=null,ee=null;function te(){Q++,c.monitorRunDependencies&&c.monitorRunDependencies(Q)}function ne(){if(Q--,c.monitorRunDependencies&&c.monitorRunDependencies(Q),0==Q&&(null!==Z&&(clearInterval(Z),Z=null),ee)){var e=ee;ee=null,e()}}function re(e){throw c.onAbort&&c.onAbort(e),T(e="Aborted("+e+")"),j=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),d(e),e}function ie(e){return e.startsWith("data:application/octet-stream;base64,")}function ue(e){if(e==J&&A)return new Uint8Array(A);if(h)return h(e);throw"both async and sync fetching of the wasm failed"}function de(e,t,n){return function(e){if(!A&&(w||$)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>ue(e)));if(f)return new Promise(((t,n)=>{f(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>ue(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{T("failed to asynchronously prepare wasm: "+e),re(e)}))}ie(J="ort-wasm-simd-threaded.wasm")||(J=S(J));var he,me={914988:e=>{c.Ea("Abs",e,void 0)},915039:e=>{c.Ea("Neg",e,void 0)},915090:e=>{c.Ea("Floor",e,void 0)},915143:e=>{c.Ea("Ceil",e,void 0)},915195:e=>{c.Ea("Reciprocal",e,void 0)},915253:e=>{c.Ea("Sqrt",e,void 0)},915305:e=>{c.Ea("Exp",e,void 0)},915356:e=>{c.Ea("Erf",e,void 0)},915407:e=>{c.Ea("Sigmoid",e,void 0)},915462:e=>{c.Ea("Log",e,void 0)},915513:e=>{c.Ea("Sin",e,void 0)},915564:e=>{c.Ea("Cos",e,void 0)},915615:e=>{c.Ea("Tan",e,void 0)},915666:e=>{c.Ea("Asin",e,void 0)},915718:e=>{c.Ea("Acos",e,void 0)},915770:e=>{c.Ea("Atan",e,void 0)},915822:e=>{c.Ea("Sinh",e,void 0)},915874:e=>{c.Ea("Cosh",e,void 0)},915926:e=>{c.Ea("Asinh",e,void 0)},915979:e=>{c.Ea("Acosh",e,void 0)},916032:e=>{c.Ea("Atanh",e,void 0)},916085:e=>{c.Ea("Tanh",e,void 0)},916137:e=>{c.Ea("Not",e,void 0)},916188:(e,t,n)=>{c.Ea("ClipV10",e,{min:t,max:n})},916260:e=>{c.Ea("Clip",e,void 0)},916312:(e,t)=>{c.Ea("Elu",e,{alpha:t})},916370:e=>{c.Ea("Relu",e,void 0)},916422:(e,t)=>{c.Ea("LeakyRelu",e,{alpha:t})},916486:(e,t)=>{c.Ea("ThresholdedRelu",e,{alpha:t})},916556:(e,t)=>{c.Ea("Cast",e,{to:t})},916614:e=>{c.Ea("Add",e,void 0)},916665:e=>{c.Ea("Sub",e,void 0)},916716:e=>{c.Ea("Mul",e,void 0)},916767:e=>{c.Ea("Div",e,void 0)},916818:e=>{c.Ea("Pow",e,void 0)},916869:e=>{c.Ea("Equal",e,void 0)},916922:e=>{c.Ea("Greater",e,void 0)},916977:e=>{c.Ea("GreaterOrEqual",e,void 0)},917039:e=>{c.Ea("Less",e,void 0)},917091:e=>{c.Ea("LessOrEqual",e,void 0)},917150:(e,t,n,r,i)=>{c.Ea("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917314:(e,t,n,r,i)=>{c.Ea("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917477:(e,t,n,r,i)=>{c.Ea("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917640:(e,t,n,r,i)=>{c.Ea("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917804:(e,t,n,r,i)=>{c.Ea("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917967:(e,t,n,r,i)=>{c.Ea("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918129:(e,t,n,r,i)=>{c.Ea("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918291:(e,t,n,r,i)=>{c.Ea("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918457:(e,t,n,r,i)=>{c.Ea("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918626:(e,t,n,r,i)=>{c.Ea("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918795:e=>{c.Ea("Where",e,void 0)},918848:(e,t,n)=>{c.Ea("Transpose",e,{perm:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[]})},918961:(e,n,r,i,o,s,u,l,d,p,f,h,m,g,y)=>{c.Ea("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:m?Array.from(a().subarray(g>>>0,g+m>>>0)):[],activation:xe(y)})},919375:(e,n,r,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(m>>>0,m+h>>>0)):[],activation:xe(g)})},919932:(e,n,r,i,o,s,u,l,d,p,f,h,m,g,y)=>{c.Ea("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:m?Array.from(a().subarray(g>>>0,g+m>>>0)):[],activation:xe(y)})},920346:(e,n,r,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(m>>>0,m+h>>>0)):[],activation:xe(g)})},920903:(e,t)=>{c.Ea("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},920994:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},921278:(e,t)=>{c.Ea("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},921369:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},921653:(e,t)=>{c.Ea("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},921740:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},922020:(e,t)=>{c.Ea("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},922107:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},922387:(e,t,n,r,a)=>{c.Ea("Gemm",e,{alpha:t,beta:n,transA:r,transB:a})},922491:e=>{c.Ea("MatMul",e,void 0)},922545:(e,t,n,r)=>{c.Ea("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},922653:(e,t,n,r)=>{c.Ea("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},922761:(e,t)=>{c.Ea("Softmax",e,{axis:t})},922824:(e,t)=>{c.Ea("Concat",e,{axis:t})},922884:(e,t,n,r,i)=>{c.Ea("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},923029:e=>{c.Ea("Expand",e,void 0)},923083:(e,t)=>{c.Ea("Gather",e,{axis:Number(t)})},923154:(e,t)=>{c.Ea("GatherElements",e,{axis:Number(t)})},923233:(e,t,n,r,i,o,s,u,l,d,p)=>{c.Ea("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(r>>>0,r+n>>>0)):[],coordinateTransformMode:xe(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:xe(l),mode:xe(d),nearestMode:xe(p)})},923584:(e,t,n,r,i,o,s)=>{c.Ea("Slice",e,{starts:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[],ends:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[],axes:o?Array.from(a().subarray(s>>>0,s+o>>>0)):[]})},923815:e=>{c.Ea("Tile",e,void 0)},923867:(e,t,n)=>{c.Ea("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},923974:(e,t,n)=>{c.Ea("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},924088:(e,t,n)=>{c.Ea("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},924202:e=>{c.Ea("Range",e,void 0)},924255:(e,t)=>{c.Ea("Einsum",e,{equation:xe(t)})},924336:(e,t,n,r,i)=>{c.Ea("Pad",e,{mode:t,value:n,pads:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},924468:e=>{c.Ea("Gelu",e,void 0)},924520:e=>{c.Ea("BiasAdd",e,void 0)},924575:e=>{c.Ea("BiasSplitGelu",e,void 0)},924636:(e,t)=>{c.Ea("SkipLayerNormalization",e,{epsilon:t})},924717:(e,n,r,i,o,u,l,d,p,f,h,m,g)=>{c.Ea("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:i,kernel_shape:[o],pads:u?Array.from(a().subarray(l>>>0,l+u>>>0)):[],strides:[d],w_is_const:()=>!!t()[f>>>0],activation:xe(h),activation_params:m?Array.from(s().subarray(g>>>0,g+m>>>0)):[]})},925098:(e,n,r,i,o,u,l,d,p,f,h,m,g,y,w,$)=>{c.Ea("Conv",e,{format:m?"NHWC":"NCHW",auto_pad:n,dilations:[r,i],group:o,kernel_shape:[u,l],pads:d?Array.from(a().subarray(p>>>0,p+d>>>0)):[],strides:[f,h],w_is_const:()=>!!t()[g>>>0],activation:xe(y),activation_params:w?Array.from(s().subarray($>>>0,$+w>>>0)):[]})},925500:e=>{c.zb(e)},925534:(e,t)=>c.Ab(e,t,c.bb.Fb,c.bb.errors),925646:e=>c.wb(e),925679:e=>c.yb(e),925711:(e,t,n)=>{c.jb(e,t,n,!0)},925750:(e,t,n)=>{c.jb(e,t,n)}};function ge(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ye(e){e.terminate(),e.onmessage=()=>{}}function we(e){(e=Ce.Qa[e])||re(),Ce.Eb(e)}function $e(e){var t=Ce.tb();if(!t)return 6;Ce.Ya.push(t),Ce.Qa[e.Xa]=t,t.Xa=e.Xa;var n={cmd:"run",start_routine:e.Gb,arg:e.rb,pthread_ptr:e.Xa};return v&&t.unref(),t.postMessage(n,e.Mb),0}var ve=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,be=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&ve)return ve.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},xe=(e,t)=>(e>>>=0)?be(r(),e,t):"";function Se(e){if(b)return it(1,1,e);D=e,X()||(Ce.Hb(),c.onExit&&c.onExit(e),j=!0),y(e,new ge(e))}var _e=e=>{if(D=e,b)throw Ie(e),"unwind";Se(e)},Ce={ab:[],Ya:[],mb:[],Qa:{},gb:function(){b?Ce.vb():Ce.ub()},ub:function(){L.unshift((()=>{te(),Ce.Bb((()=>ne()))}))},vb:function(){Ce.receiveObjectTransfer=Ce.Db,Ce.threadInitTLS=Ce.lb,Ce.setExitStatus=Ce.kb,R=!1},kb:function(e){D=e},Sb:["$terminateWorker"],Hb:function(){for(var e of Ce.Ya)ye(e);for(e of Ce.ab)ye(e);Ce.ab=[],Ce.Ya=[],Ce.Qa=[]},Eb:function(e){var t=e.Xa;delete Ce.Qa[t],Ce.ab.push(e),Ce.Ya.splice(Ce.Ya.indexOf(e),1),e.Xa=0,Wt(t)},Db:function(){},lb:function(){Ce.mb.forEach((e=>e()))},Cb:e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=kt()){var a=Ce.Qa[n.Rb];a?a.postMessage(n,n.transferList):T('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"checkMailbox"===r?Ke():"spawnThread"===r?$e(n):"cleanupThread"===r?we(n.thread):"killThread"===r?(n=n.thread,r=Ce.Qa[n],delete Ce.Qa[n],ye(r),Wt(n),Ce.Ya.splice(Ce.Ya.indexOf(r),1),r.Xa=0):"cancelThread"===r?Ce.Qa[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?c[n.handler](...n.args):r&&T("worker sent an unknown command "+r)},e.onerror=e=>{throw T("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var n,r=[];for(n of["onExit","onAbort","print","printErr"])c.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,urlOrBlob:c.mainScriptUrlOrBlob||o,wasmMemory:k,wasmModule:M})})),Bb:function(e){e()},qb:function(){var e=S("ort-wasm-simd-threaded.worker.js");e=new Worker(e),Ce.ab.push(e)},tb:function(){return 0==Ce.ab.length&&(Ce.qb(),Ce.Cb(Ce.ab[0])),Ce.ab.pop()}};c.PThread=Ce;var Ee=e=>{for(;0<e.length;)e.shift()(c)};function Ie(e){if(b)return it(2,0,e);_e(e)}function Ae(e){this.fb=e-24,this.pb=function(e){i()[this.fb+4>>2>>>0]=e},this.ob=function(e){i()[this.fb+8>>2>>>0]=e},this.gb=function(e,t){this.nb(),this.pb(e),this.ob(t)},this.nb=function(){i()[this.fb+16>>2>>>0]=0}}function Oe(e,t,n,r){return b?it(3,1,e,t,n,r):Te(e,t,n,r)}function Te(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,typeof SharedArrayBuffer>"u")return T("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?Oe(e,t,n,r):(e={Gb:n,Xa:e,rb:r,Mb:a},b?(e.Ob="spawnThread",postMessage(e,a),0):$e(e))}function Re(e,t,n){return b?it(4,1,e,t,n):0}function ke(e,t){if(b)return it(5,1,e,t)}c.establishStackSpace=function(){var e=kt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],Vt(t,t-e),Ft(t)},c.invokeEntryPoint=function(e,t){e=Lt.apply(null,[e,t]),X()?Ce.kb(e):Nt(e)};var Be=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Me=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},De=(e,t,n)=>Me(e,r(),t,n);function Pe(e,t){if(b)return it(6,1,e,t)}function ze(e,t,n){if(b)return it(7,1,e,t,n)}function We(e,t,n){return b?it(8,1,e,t,n):0}function Ne(e,t){if(b)return it(9,1,e,t)}function Ge(e,t,n){if(b)return it(10,1,e,t,n)}function Ue(e,t,n,r){if(b)return it(11,1,e,t,n,r)}function Ve(e,t,n,r){if(b)return it(12,1,e,t,n,r)}function je(e,t,n,r){if(b)return it(13,1,e,t,n,r)}function Fe(e){if(b)return it(14,1,e)}function He(e,t){if(b)return it(15,1,e,t)}function Le(e,t,n){if(b)return it(16,1,e,t,n)}var qe=e=>{if(!j)try{if(e(),!X())try{b?Nt(D):_e(D)}catch(e){e instanceof ge||"unwind"==e||y(1,e)}}catch(e){e instanceof ge||"unwind"==e||y(1,e)}};function Ye(e){e>>>=0,"function"==typeof Atomics.Nb&&(Atomics.Nb(a(),e>>2,e).value.then(Ke),e+=128,Atomics.store(a(),e>>2,1))}function Ke(){var e=kt();e&&(Ye(e),qe((()=>Gt())))}c.__emscripten_thread_mailbox_await=Ye,c.checkMailbox=Ke;var Xe=e=>e%4==0&&(e%100!=0||e%400==0),Je=[0,31,60,91,121,152,182,213,244,274,305,335],Qe=[0,31,59,90,120,151,181,212,243,273,304,334];function Ze(e,t,n,r,a,i,o,s){return b?it(17,1,e,t,n,r,a,i,o,s):-52}function et(e,t,n,r,a,i,o){if(b)return it(18,1,e,t,n,r,a,i,o)}var tt=e=>{var t=Be(e)+1,n=Bt(t);return n&&De(e,n,t),n},nt=[],rt=(e,t)=>{var n;for(nt.length=0,t>>=2;n=r()[e++>>>0];)t+=105!=n&t,nt.push(105==n?a()[t>>>0]:u()[t++>>>1]),++t;return nt},at=e=>{var t=jt();return e=e(),Ft(t),e};function it(e,t){var n=arguments.length-2,r=arguments;return at((()=>{for(var a=Ht(8*n),i=a>>3,o=0;o<n;o++){var s=r[2+o];u()[i+o>>>0]=s}return zt(e,n,a,t)}))}var ot,st=[],ut={},lt=()=>{if(!ot){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in ut)void 0===ut[e]?delete t[e]:t[e]=ut[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);ot=n}return ot};function dt(e,n){if(b)return it(19,1,e,n);e>>>=0,n>>>=0;var r=0;return lt().forEach((function(a,o){var s=n+r;for(o=i()[e+4*o>>2>>>0]=s,s=0;s<a.length;++s)t()[o++>>0>>>0]=a.charCodeAt(s);t()[o>>0>>>0]=0,r+=a.length+1})),0}function ct(e,t){if(b)return it(20,1,e,t);e>>>=0,t>>>=0;var n=lt();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function pt(e){return b?it(21,1,e):52}function ft(e,t,n,r){return b?it(22,1,e,t,n,r):52}function ht(e,t,n,r,a){return b?it(23,1,e,t,n,r,a):70}var mt=[null,[],[]];function gt(e,t,n,a){if(b)return it(24,1,e,t,n,a);t>>>=0,n>>>=0,a>>>=0;for(var o=0,s=0;s<n;s++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var d=0;d<l;d++){var c=r()[u+d>>>0],p=mt[e];0===c||10===c?((1===e?O:T)(be(p,0)),p.length=0):p.push(c)}o+=l}return i()[a>>2>>>0]=o,0}var yt=[31,29,31,30,31,30,31,31,30,31,30,31],wt=[31,28,31,30,31,30,31,31,30,31,30,31];function $t(e,n,r,i){function o(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return o(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function l(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function d(e){var t=e.Za;for(e=new Date(new Date(e.$a+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?yt:wt)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=l(new Date(e.getFullYear(),0,4)),n=l(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,n>>>=0,r>>>=0,i>>>=0;var c=a()[i+40>>2>>>0];for(var p in i={Kb:a()[i>>2>>>0],Jb:a()[i+4>>2>>>0],cb:a()[i+8>>2>>>0],ib:a()[i+12>>2>>>0],eb:a()[i+16>>2>>>0],$a:a()[i+20>>2>>>0],Wa:a()[i+24>>2>>>0],Za:a()[i+28>>2>>>0],Tb:a()[i+32>>2>>>0],Ib:a()[i+36>>2>>>0],Lb:c?xe(c):""},r=xe(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),c[p]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(p in c={"%a":e=>f[e.Wa].substring(0,3),"%A":e=>f[e.Wa],"%b":e=>h[e.eb].substring(0,3),"%B":e=>h[e.eb],"%C":e=>s((e.$a+1900)/100|0,2),"%d":e=>s(e.ib,2),"%e":e=>o(e.ib,2," "),"%g":e=>d(e).toString().substring(2),"%G":e=>d(e),"%H":e=>s(e.cb,2),"%I":e=>(0==(e=e.cb)?e=12:12<e&&(e-=12),s(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.eb-1;t+=(Xe(e.$a+1900)?yt:wt)[n++]);return s(e.ib+t,3)},"%m":e=>s(e.eb+1,2),"%M":e=>s(e.Jb,2),"%n":()=>"\n","%p":e=>0<=e.cb&&12>e.cb?"AM":"PM","%S":e=>s(e.Kb,2),"%t":()=>"\t","%u":e=>e.Wa||7,"%U":e=>s(Math.floor((e.Za+7-e.Wa)/7),2),"%V":e=>{var t=Math.floor((e.Za+7-(e.Wa+6)%7)/7);if(2>=(e.Wa+371-e.Za-2)%7&&t++,t)53==t&&(4==(n=(e.Wa+371-e.Za)%7)||3==n&&Xe(e.$a)||(t=1));else{t=52;var n=(e.Wa+7-e.Za-1)%7;(4==n||5==n&&Xe(e.$a%400-1))&&t++}return s(t,2)},"%w":e=>e.Wa,"%W":e=>s(Math.floor((e.Za+7-(e.Wa+6)%7)/7),2),"%y":e=>(e.$a+1900).toString().substring(2),"%Y":e=>e.$a+1900,"%z":e=>(0<=(e=e.Ib)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.Lb,"%%":()=>"%"},r=r.replace(/%%/g,"\0\0"),c)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),c[p](i)));return p=function(e){var t=Array(Be(e)+1);return Me(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),p.length>n?0:(((e,n)=>{t().set(e,n>>>0)})(p,e),p.length-1)}function vt(e){try{e()}catch(e){re(e)}}var bt=0,xt=null,St=0,_t=[],Ct={},Et={},It=0,At=null,Ot=[];Ce.gb();var Tt=[null,Se,Ie,Oe,Re,ke,Pe,ze,We,Ne,Ge,Ue,Ve,je,Fe,He,Le,Ze,et,dt,ct,pt,ft,ht,gt],Rt={r:function(e,t,n){return function(e){return function(e){if(!j){if(0===bt){var t=!1,n=!1;e(((e=0)=>{if(!j&&(St=e,t=!0,n)){bt=2,vt((()=>Kt(xt))),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),e=!1;try{var r=function(){var e=a()[xt+8>>2>>>0];return e=B[Et[e]],--K,e()}()}catch(t){r=t,e=!0}var i=!1;if(!xt){var o=At;o&&(At=null,(e?o.reject:o.resolve)(r),i=!0)}if(e&&!i)throw r}})),n=!0,t||(bt=1,xt=function(){var e=Bt(65548),t=e+12;i()[e>>2>>>0]=t,i()[e+4>>2>>>0]=t+65536,t=_t[0];var n=Ct[t];return void 0===n&&(n=It++,Ct[t]=n,Et[n]=t),t=n,a()[e+8>>2>>>0]=t,e}(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),vt((()=>qt(xt))))}else 2===bt?(bt=0,vt(Xt),Mt(xt),xt=null,Ot.forEach((e=>qe(e)))):re(`invalid state: ${bt}`);return St}}((t=>{e().then(t)}))}((async()=>{await c.xb(e,t,n)}))},b:function(e,t,n){throw new Ae(e>>>=0).gb(t>>>0,n>>>0),e},O:function(e){Dt(e>>>0,!$,1,!w,131072,!1),Ce.lb()},l:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):we(e)},I:Te,i:Re,U:ke,E:Pe,G:ze,V:We,S:Ne,K:Ge,R:Ue,p:Ve,F:je,C:Fe,T:He,D:Le,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>Ke())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=Ce.Qa[e])&&e.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Ye,X:function(e){v&&Ce.Qa[e>>>0].ref()},u:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getUTCSeconds(),a()[n+4>>2>>>0]=e.getUTCMinutes(),a()[n+8>>2>>>0]=e.getUTCHours(),a()[n+12>>2>>>0]=e.getUTCDate(),a()[n+16>>2>>>0]=e.getUTCMonth(),a()[n+20>>2>>>0]=e.getUTCFullYear()-1900,a()[n+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[n+28>>2>>>0]=e},v:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getSeconds(),a()[n+4>>2>>>0]=e.getMinutes(),a()[n+8>>2>>>0]=e.getHours(),a()[n+12>>2>>>0]=e.getDate(),a()[n+16>>2>>>0]=e.getMonth(),a()[n+20>>2>>>0]=e.getFullYear()-1900,a()[n+24>>2>>>0]=e.getDay(),t=(Xe(e.getFullYear())?Je:Qe)[e.getMonth()]+e.getDate()-1|0,a()[n+28>>2>>>0]=t,a()[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t)),a()[n+32>>2>>>0]=e},w:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(o,i);return 0>n?a()[e+32>>2>>>0]=+(i!=o&&s==r):0<n!=(s==r)&&(i=Math.max(o,i),t.setTime(t.getTime()+6e4*((0<n?s:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(Xe(t.getFullYear())?Je:Qe)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Ut((he=e,1<=+Math.abs(he)?0<he?+Math.floor(he/4294967296)>>>0:~~+Math.ceil((he-+(~~he>>>0))/4294967296)>>>0:0)),e>>>0},s:Ze,t:et,z:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var o=(new Date).getFullYear(),s=new Date(o,0,1),u=new Date(o,6,1);o=s.getTimezoneOffset();var l=u.getTimezoneOffset(),d=Math.max(o,l);i()[e>>2>>>0]=60*d,a()[t>>2>>>0]=+(o!=l),e=r(s),t=r(u),e=tt(e),t=tt(t),l<o?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)},d:()=>{re("")},c:function(e,t,n){return e>>>=0,t=rt(t>>>0,n>>>0),me[e].apply(null,t)},k:function(e,t,n){return e>>>=0,t=rt(t>>>0,n>>>0),me[e].apply(null,t)},m:function(){},j:function(){return Date.now()},W:()=>{throw K+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return v?(No(),N(fe)).cpus().length:navigator.hardwareConcurrency},L:function(e,t,n,r){for(Ce.Pb=t>>>0,st.length=n,t=r>>>0>>3,r=0;r<n;r++)st[r]=u()[t+r>>>0];return(0>e?me[-e-1]:Tt[e]).apply(null,st)},y:function(e){e>>>=0;var t=r().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var i=Math;a=Math.max(e,a);e:{i=i.min.call(i,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(i),F();var o=1;break e}catch{}o=void 0}if(o)return!0}return!1},P:dt,Q:ct,H:_e,h:pt,o:ft,x:ht,n:gt,a:k||c.wasmMemory,J:$t,e:function(e,t,n,r){return $t(e>>>0,t>>>0,n>>>0,r>>>0)}};(function(){function e(e,t){return e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){_t.push(t);try{return r.apply(null,arguments)}finally{j||(_t.pop()===t||re(),xt&&1===bt&&0===_t.length&&(bt=0,K+=1,vt(Yt),typeof Fibers<"u"&&Fibers.Ub()))}}:r}(t);return n}(e=e.exports),B=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),Ce.mb.push(B.Da),q.unshift(B.Y),M=t,ne(),e}var t={a:Rt};if(te(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){T("Module.instantiateWasm callback failed with error: "+e),d(e)}(function(e,t){var n=J;return A||"function"!=typeof WebAssembly.instantiateStreaming||ie(n)||n.startsWith("file://")||v||"function"!=typeof fetch?de(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return T("wasm streaming compile failed: "+r),T("falling back to ArrayBuffer instantiation"),de(n,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(d)})(),c._OrtInit=(e,t)=>(c._OrtInit=B.Z)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=B._)(e,t),c._OrtCreateSessionOptions=(e,t,n,r,a,i,o,s,u,l)=>(c._OrtCreateSessionOptions=B.$)(e,t,n,r,a,i,o,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=B.aa)(e,t),c._OrtAddFreeDimensionOverride=(e,t,n)=>(c._OrtAddFreeDimensionOverride=B.ba)(e,t,n),c._OrtAddSessionConfigEntry=(e,t,n)=>(c._OrtAddSessionConfigEntry=B.ca)(e,t,n),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=B.da)(e),c._OrtCreateSession=(e,t,n)=>(c._OrtCreateSession=B.ea)(e,t,n),c._OrtReleaseSession=e=>(c._OrtReleaseSession=B.fa)(e),c._OrtGetInputOutputCount=(e,t,n)=>(c._OrtGetInputOutputCount=B.ga)(e,t,n),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=B.ha)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=B.ia)(e,t),c._OrtFree=e=>(c._OrtFree=B.ja)(e),c._OrtCreateTensor=(e,t,n,r,a,i)=>(c._OrtCreateTensor=B.ka)(e,t,n,r,a,i),c._OrtGetTensorData=(e,t,n,r,a)=>(c._OrtGetTensorData=B.la)(e,t,n,r,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=B.ma)(e),c._OrtCreateRunOptions=(e,t,n,r)=>(c._OrtCreateRunOptions=B.na)(e,t,n,r),c._OrtAddRunConfigEntry=(e,t,n)=>(c._OrtAddRunConfigEntry=B.oa)(e,t,n),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=B.pa)(e),c._OrtCreateBinding=e=>(c._OrtCreateBinding=B.qa)(e),c._OrtBindInput=(e,t,n)=>(c._OrtBindInput=B.ra)(e,t,n),c._OrtBindOutput=(e,t,n,r)=>(c._OrtBindOutput=B.sa)(e,t,n,r),c._OrtClearBoundOutputs=e=>(c._OrtClearBoundOutputs=B.ta)(e),c._OrtReleaseBinding=e=>(c._OrtReleaseBinding=B.ua)(e),c._OrtRunWithBinding=(e,t,n,r,a)=>(c._OrtRunWithBinding=B.va)(e,t,n,r,a),c._OrtRun=(e,t,n,r,a,i,o,s)=>(c._OrtRun=B.wa)(e,t,n,r,a,i,o,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=B.xa)(e),c._JsepOutput=(e,t,n)=>(c._JsepOutput=B.ya)(e,t,n),c._JsepGetNodeName=e=>(c._JsepGetNodeName=B.za)(e);var kt=c._pthread_self=()=>(kt=c._pthread_self=B.Aa)(),Bt=c._malloc=e=>(Bt=c._malloc=B.Ba)(e),Mt=c._free=e=>(Mt=c._free=B.Ca)(e);c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=B.Da)();var Dt=c.__emscripten_thread_init=(e,t,n,r,a,i)=>(Dt=c.__emscripten_thread_init=B.Fa)(e,t,n,r,a,i);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=B.Ga)();var Pt,zt=(e,t,n,r)=>(zt=B.Ha)(e,t,n,r),Wt=e=>(Wt=B.Ia)(e),Nt=c.__emscripten_thread_exit=e=>(Nt=c.__emscripten_thread_exit=B.Ja)(e),Gt=c.__emscripten_check_mailbox=()=>(Gt=c.__emscripten_check_mailbox=B.Ka)(),Ut=e=>(Ut=B.La)(e),Vt=(e,t)=>(Vt=B.Ma)(e,t),jt=()=>(jt=B.Na)(),Ft=e=>(Ft=B.Oa)(e),Ht=e=>(Ht=B.Pa)(e),Lt=c.dynCall_ii=(e,t)=>(Lt=c.dynCall_ii=B.Ra)(e,t),qt=e=>(qt=B.Sa)(e),Yt=()=>(Yt=B.Ta)(),Kt=e=>(Kt=B.Ua)(e),Xt=()=>(Xt=B.Va)();function Jt(){function e(){if(!Pt&&(Pt=!0,c.calledRun=!0,!j)&&(b||Ee(q),l(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();Y.unshift(e)}Ee(Y)}}if(!(0<Q))if(b)l(c),b||Ee(q),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)L.unshift(c.preRun.shift());Ee(L),0<Q||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.___start_em_js=925783,c.___stop_em_js=925944,c.keepRuntimeAlive=X,c.wasmMemory=k,c.stackAlloc=Ht,c.stackSave=jt,c.stackRestore=Ft,c.UTF8ToString=xe,c.stringToUTF8=De,c.lengthBytesUTF8=Be,c.ExitStatus=ge,c.PThread=Ce,ee=function e(){Pt||Jt(),Pt||(ee=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return Jt(),e.ready});"object"==typeof a&&"object"==typeof i?i.exports=s:void 0===(r=(()=>s).apply(t,[]))||(e.exports=r)})),Uo=z(((e,t)=>{t.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'})),Vo=P((()=>{me=de(),ge=Go(),we=!1,$e=!1,ve=!1,be=()=>{try{return!(typeof SharedArrayBuffer>"u")&&(typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},xe=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Se=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",_e=async e=>{if(we)return Promise.resolve();if($e)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ve)throw new Error("previous call to 'initializeWebAssembly()' failed.");$e=!0;let t=e.initTimeout,n=e.numThreads,r=e.simd,a=n>1&&be(),i=r&&xe(),o=e.wasmPaths,s="string"==typeof o?o:void 0,u=Se(i,a),l="object"==typeof o?o[u]:void 0,d=!1,c=[];if(t>0&&c.push(new Promise((e=>{setTimeout((()=>{d=!0,e()}),t)}))),c.push(new Promise(((e,t)=>{let n=a?ge:me,r={locateFile:(e,t)=>{if(a&&e.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Uo()],{type:"text/javascript"}));if(e.endsWith(".wasm")){if(l)return l;let e=s??t;return"ort-wasm-simd.wasm"===u?e+"ort-wasm-simd.jsep.wasm":"ort-wasm-simd-threaded.wasm"===u?e+"ort-wasm-simd-threaded.jsep.wasm":e+u}return t+e}};if(a)if(typeof Blob>"u")r.mainScriptUrlOrBlob=(void 0)("/","ort-wasm-threaded.js");else{let e=`var ortWasmThreaded=${n.toString()};`;r.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(r).then((t=>{$e=!1,we=!0,ye=t,e()}),(e=>{$e=!1,ve=!0,t(e)}))}))),await Promise.race(c),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ce=()=>{if(we&&ye)return ye;throw new Error("WebAssembly is not initialized yet.")}})),jo=P((()=>{Vo(),Ee=(e,t)=>{let n=Ce(),r=n.lengthBytesUTF8(e)+1,a=n._malloc(r);return n.stringToUTF8(e,a,r),t.push(a),a},Ie=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,a])=>{let i=t?t+e:e;if("object"==typeof a)Ie(a,i+".",n,r);else if("string"==typeof a||"number"==typeof a)r(i,a.toString());else{if("boolean"!=typeof a)throw new Error("Can't handle extra config type: "+typeof a);r(i,a?"1":"0")}}))},Ae=e=>{let t=Ce(),n=t.stackSave();try{let n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);let r=t.HEAP32[n/4],a=t.HEAPU32[n/4+1],i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}})),Fo=P((()=>{Vo(),jo(),Oe=e=>{let t=Ce(),n=0,r=[],a=e||{};try{if(void 0===e?.logSeverityLevel)a.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)a.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(a.terminate=!1);let i=0;return void 0!==e?.tag&&(i=Ee(e.tag,r)),n=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,i),0===n&&Ae("Can't create run options."),void 0!==e?.extra&&Ie(e.extra,"",new WeakSet,((e,a)=>{let i=Ee(e,r),o=Ee(a,r);0!==t._OrtAddRunConfigEntry(n,i,o)&&Ae(`Can't set a run config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),Ho=P((()=>{Vo(),jo(),Te=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Re=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},ke=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},Be=(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof r){let t=r;if(t?.deviceType){let r=Ee("deviceType",n),a=Ee(t.deviceType,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'deviceType' - ${t.deviceType}.`)}if(t?.powerPreference){let r=Ee("powerPreference",n),a=Ee(t.powerPreference,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'powerPreference' - ${t.powerPreference}.`)}}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);let r=Ee("preferredLayout",n),a=Ee(t.preferredLayout,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'preferredLayout' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=Ee(t,n);0!==Ce()._OrtAppendExecutionProvider(e,a)&&Ae(`Can't append execution provider: ${t}.`)}},Me=e=>{let t=Ce(),n=0,r=[],a=e||{};ke(a);try{let e=Te(a.graphOptimizationLevel??"all"),i=Re(a.executionMode??"sequential"),o="string"==typeof a.logId?Ee(a.logId,r):0,s=a.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw new Error(`log serverity level is not valid: ${s}`);let u=a.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let l="string"==typeof a.optimizedModelFilePath?Ee(a.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!a.enableCpuMemArena,!!a.enableMemPattern,i,!!a.enableProfiling,0,o,s,u,l),0===n&&Ae("Can't create session options."),a.executionProviders&&Be(n,a.executionProviders,r),a.freeDimensionOverrides)for(let[e,i]of Object.entries(a.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof i||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let a=Ee(e,r);0!==t._OrtAddFreeDimensionOverride(n,a,i)&&Ae(`Can't set a free dimension override: ${e} - ${i}.`)}return void 0!==a.extra&&Ie(a.extra,"",new WeakSet,((e,a)=>{let i=Ee(e,r),o=Ee(a,r);0!==t._OrtAddSessionConfigEntry(n,i,o)&&Ae(`Can't set a session config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseSessionOptions(n),r.forEach((e=>t._free(e))),e}}})),Lo=P((()=>{De=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Pe=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ze=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],We=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ne=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ge=e=>"float32"===e||"int32"===e||"int64"===e||"bool"===e||"float16"===e||"uint32"===e,Ue=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}})),qo=P((()=>{Lo(),Ve=["V","I","W","E","F"],je=(e,t)=>{console.log(`[${Ve[e]},${(new Date).toISOString()}]${t}`)},Le=(e,t)=>{Fe=e,He=t},qe=(e,t)=>{let n=Ne(e);n>=Ne(Fe)&&je(n,"function"==typeof t?t():t)},Ye=(...e)=>{He&&qe(...e)}})),Yo=P((()=>{Lo(),Ke=(e,t)=>new(We(t))(e)})),Ko=P((()=>{})),Xo=P((()=>{qo(),Ko(),Xe=e=>16*Math.ceil(e/16),Je=1,Qe=()=>Je++,Ze=async(e,t,n,r)=>{let a=Xe(n),i=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=e.getCommandEncoder();e.endComputePass(),o.copyBufferToBuffer(t,0,i,0,a),e.flush(),await i.mapAsync(GPUMapMode.READ);let s=i.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(s,0,n)),e}return new Uint8Array(s.slice(0,n))}finally{i.destroy()}},et=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,t){let n=t.buffer,r=t.byteOffset,a=t.byteLength,i=Xe(a),o=this.storageCache.get(e);if(!o)throw new Error("gpu data for uploading does not exist");if(o.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${a}`);let s=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=s.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,r,a)),s.unmap();let l=this.backend.getCommandEncoder();this.backend.endComputePass(),l.copyBufferToBuffer(s,0,o.gpuData.buffer,0,i),Ye("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(s)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=Xe(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}registerExternalBuffer(e,t,n){let r;if(n){if(r=this.externalBuffers.get(n),void 0===r)throw new Error("previous buffer is not registered");if(e===n)return Ye("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;this.externalBuffers.delete(n)}else r=Qe();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),this.externalBuffers.set(e,r),Ye("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){let t=this.externalBuffers.get(e);void 0!==t&&(this.storageCache.delete(t),this.externalBuffers.delete(e),Ye("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=Xe(e),a=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||i){let e=a?this.freeBuffers:this.freeUniformBuffers,i=e.get(r);i||(i=[],e.set(r,i)),n=i.length>0?i.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let o={id:Qe(),type:0,buffer:n};return this.storageCache.set(o.id,{gpuData:o,originalSize:e}),Ye("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${o.id}`)),o}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return Ye("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");await Ze(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},tt=(...e)=>new et(...e)})),Jo=P((()=>{nt=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}},rt=e=>new nt(e)})),Qo=P((()=>{at=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},it=class{static calcShape(e,t,n=!1){let r=e.length,a=t.length;if(0===r)return t;if(0===a)return e;let i=Math.max(e.length,t.length),o=new Array(i);if(n){if(r<2||a<2)return;let n=at.calcMatMulShape([e[r-2],e[r-1]],[t[a-2],t[a-1]]);if(void 0===n)return;[o[i-2],o[i-1]]=n}for(let s=n?3:1;s<=i;s++){let n=r-s<0?1:e[r-s],u=a-s<0?1:t[a-s];if(n!==u&&n>1&&u>1)return;o[i-s]=Math.max(n,u)}return o}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(1!==e[n-a]&&e[n-a]!==t[r-a])return!1;return!0}},ot=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let a=t;a<n;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=e[a]}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},st=class e{static adjustPoolAttributes(e,t,n,r,a,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,a,i,o,s){if(s){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<t.length-2;u++)e.adjustPadAndReturnShape(t[u+(o?1:2)],n[u],r[u],a[u],i,u,u+t.length-2,s)}}static computePoolOutputShape(t,n,r,a,i,o,s){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return e.computeShapeHelper(t,n,u,r,a,i,o,s),u}static computeConvOutputShape(t,n,r,a,i,o,s){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[t[0],n[0]];return e.computeShapeHelper(!1,t,u,r,a,i,o,s),u}static computeShapeHelper(t,n,r,a,i,o,s,u){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],a[t],i[t],o[t],s,t,t+n.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,a,i,o,s){let u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[i]+a[o]-u)/t+1);switch(s){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return a[i]=Math.floor("SAME_LOWER"===s?(n+1)/2:n/2),a[o]=n-a[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},ut=class{static getShapeOfGemmResult(e,t,n,r,a){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,o,s;t?(i=e[1],o=e[0]):(i=e[0],o=e[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==o)throw new Error("dimension mismatch");if(i<=0||s<=0||o<=0)throw new Error("invalid shape specified");if(a&&!it.isValidBroadcast(a,[i,s]))throw new Error("gemm: invalid bias shape for broadcast");return[i,s,o]}},lt=-34028234663852886e22,dt=34028234663852886e22})),Zo=P((()=>{Lo(),Qo(),ct=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},pt=(e,t=1)=>{let n=ct(e,t);return"string"==typeof n?n:n[0]},ft=e=>[{type:"uint32",data:e},{type:"uint32",data:ot.computeStrides(e)}],ht=e=>e%4==0?4:e%2==0?2:1,mt=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,gt=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}f(${n})`,yt=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,wt=(e,t,n,r,a)=>{let i="number"==typeof n,o=i?n:n.length,s=[...new Array(o).keys()],u=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,l=ct(t,a),d="string"==typeof l?l:l[1],c="string"==typeof l?l:l[0],p={indices:u,value:d,storage:c,tensor:t},f=e=>"string"==typeof e?e:`${e}u`,h={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=i?"uniforms.":"",g=`${m}${e}_shape`,y=`${m}${e}_strides`,w="";for(let e=0;e<o-1;e++)w+=`\n    let dim${e} = current / ${y}[${e}];\n    let rest${e} = current % ${y}[${e}];\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;w+=`indices[${o-1}] = current;`;let $=o<2?"":`\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\n    var indices: ${p.indices};\n    var current = offset;\n    ${w}\n    return indices;\n  }`,v=[];if(o>=2)for(let e=o-1;e>=0;e--)v.push(`${y}[${e}] * (indices[${e}])`);let b=o<2?"":`\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\n    return ${v.join("+")};\n  }`,x=(...e)=>0===o?"0u":`${p.indices}(${e.map(f).join(",")})`,S=(e,t)=>o<2?`${e}`:`${e}[${t}]`,_={},C=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),E=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),I=o<2?"":`\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${d} {\n    return ${E(`i2o_${e}(indices)`)};\n  }`,A=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn get_${e}(${t}) -> ${d} {\n    return get_${e}ByIndices(${x(n)});\n  }`})(),O=o<2?"":`\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${d}) {\n    ${C(`i2o_${e}(indices)`,"value")}\n  }`,T=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn set_${e}(${t}, value: ${d}) {\n    set_${e}ByIndices(${x(n)}, value);\n  }`})();return{impl:()=>{let e=[];return i||(e.push(`const ${g} = ${p.indices}(${n.join(",")});`),e.push(`const ${y} = ${p.indices}(${ot.computeStrides(n).join(",")});`)),h.offsetToIndices&&e.push($),h.indicesToOffset&&e.push(b),h.broadcastedIndicesToOffset&&Object.values(_).forEach((t=>e.push(t))),h.set&&e.push(T),h.setByIndices&&e.push(O),h.get&&e.push(A),h.getByIndices&&e.push(I),e.join("\n")},type:p,offsetToIndices:t=>(h.offsetToIndices=!0,o<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(h.indicesToOffset=!0,o<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{h.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in _)return`${r}(${t})`;let a=[];for(let e=o-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-o);a.push(`${S(y,e)} * (${t} % ${S(g,e)})`)}return _[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${a.length>0?a.join("+"):"0u"};\n           }`,`${r}(${t})`},indices:x,indicesGet:S,indicesSet:(e,t,n)=>o<2?`${e}=${n};`:`${e}[${t}]=${n};`,set:(...t)=>{if(t.length!==o+1)throw new Error(`indices length must be ${o}`);let n=t[o];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,o).map(f).join(",");return 0===o?C("0u",n):1===o?C(r[0],n):(h.set=!0,h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:C,setByIndices:(t,n)=>o<2?C(t,n):(h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==o)throw new Error(`indices length must be ${o}`);let n=t.map(f).join(",");return 0===o?E("0u"):1===o?E(n[0]):(h.get=!0,h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:E,getByIndices:t=>o<2?E(t):(h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r?"input":"output",name:e,strides:y,shape:g,rank:o}},$t=(e,t,n,r=1)=>wt(e,t,n,!0,r),vt=(e,t,n,r=1)=>wt(e,t,n,!1,r),bt=class{constructor(e){this.normalizedDispatchGroup=e,this.indicesHelpers=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=64){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2],a=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\n  fn main(${a?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\n    ${a?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${t*n*r}u + local_index;`}\n  `}declareVariable(e,t){this.indicesHelpers.push(e),e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:e.type.indices}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:e.type.indices});let n="input"===e.usage?"read":"read_write",r=e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\n")}registerUniform(e,t){return this.uniforms.push({name:e,type:t}),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n}of this.uniforms)e.push(`${t}:${n}`);return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map((e=>e.impl())).join("\n")}},xt=e=>new bt(e),St=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;a++){let i=n-1-a,o=e[i]||1;(t[t.length-1-a]||1)>1&&1===o&&r.unshift(i)}return r},_t=e=>e<=4})),es=P((()=>{Qo(),Jo(),Zo(),Ct=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.")},Et=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,It=(e,t)=>ot.sortBasedOnPerm(e,Et(e.length,t)),At=(e,t,n,r)=>{let a=[];a.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)a.push(n.indicesSet("a",e[r],`i[${r}]`));return a.push("return a;}"),a.join("\n")},Ot=(e,t)=>{let n=e.dataType,r=e.dims.length,a=Et(r,t),i=_t(r),o=It(e.dims,a),s=i?o.length:o,u=i?r:e.dims,l=vt("output",n,s),d=$t("a",n,u);return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:i?["rank"]:["dims"]},getRunData:e=>{let t=ot.size(o);return{outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:i?[{type:"uint32",data:t},...ft(e[0].dims),...ft(o)]:[{type:"uint32",data:t}]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(d,l)}\n\n  ${At(a,r,d,l)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${l.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${l.setByOffset("global_idx",d.getByIndices("aIndices"))}\n  }`}},Tt=(e,t)=>{Ct(e.inputs),e.compute(Ot(e.inputs[0],t.perm))},Rt=e=>rt({perm:e.perm})})),ts=P((()=>{Qo(),Zo(),ns(),es(),kt={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Bt={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Mt={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Dt={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Pt=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},zt=(e,t)=>{let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]},Wt=(e,t)=>{let n=e.length+t.length,r=[],a=0;for(let i=0;i<n;i++)-1===t.indexOf(i)?r.push(e[a++]):r.push(1);return r},Nt=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Gt=(e,t)=>{let n=[];if(!Nt(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},Ut=(e,t,n,r,a,i,o)=>{let s=n[0].dims,u=ot.size(i),l=ot.size(o),d=$t("_A",n[0].dataType,s),c=vt("output",a,i),p=`\n          var<workgroup> aBestValues : array<${c.type.storage}, 32>;\n       `;return{name:e,shaderCache:t,getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,c)}\n        ${p}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(32)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / 32;\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${c.type.storage}(${Mt[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + 32) {\n           let candidate = ${c.type.storage}(${d.getByOffset("offset + k")});\n           bestValue = ${kt[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, 32u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${Bt[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${c.setByOffset("outputIndex","mean"===r?`bestValue / ${c.type.storage}(uniforms.reduceSize)`:`${Dt[r]}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:u},programUniforms:[{type:"uint32",data:l}]})}},Vt=(e,t,n,r)=>{let a=1===e.inputs.length?n:nn(e.inputs,n),i=a.axes;0===i.length&&!a.noopWithEmptyAxes&&(i=e.inputs[0].dims.map(((e,t)=>t)));let o=ot.normalizeAxes(i,e.inputs[0].dims.length),s=o,u=e.inputs[0],l=Gt(s,e.inputs[0].dims.length);l.length>0&&(u=e.compute(Ot(e.inputs[0],l),{inputs:[0],outputs:[-1]})[0],s=Pt(s.length,u.dims.length));let[d,c]=zt(u.dims,s),p=d;a.keepDims&&(p=Wt(d,o)),e.compute(Ut(t,{hint:a.cacheKey,inputDependencies:["type"]},[u],r,e.inputs[0].dataType,p,c),{inputs:[u]})},jt=(e,t)=>{Vt(e,"ReduceMeanShared",t,"mean")},Ft=(e,t)=>{Vt(e,"ReduceL1Shared",t,"l1")},Ht=(e,t)=>{Vt(e,"ReduceL2Shared",t,"l2")},Lt=(e,t)=>{Vt(e,"ReduceLogSumExpShared",t,"logSumExp")},qt=(e,t)=>{Vt(e,"ReduceMaxShared",t,"max")},Yt=(e,t)=>{Vt(e,"ReduceMinShared",t,"min")},Kt=(e,t)=>{Vt(e,"ReduceProdShared",t,"prod")},Xt=(e,t)=>{Vt(e,"ReduceSumShared",t,"sum")},Jt=(e,t)=>{Vt(e,"ReduceSumSquareShared",t,"sumSquare")},Qt=(e,t)=>{Vt(e,"ReduceLogSumShared",t,"logSum")}})),ns=P((()=>{Qo(),Jo(),Zo(),ts(),Zt=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},en=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],tn=(e,t,n,r,a,i,o=!1,s=!1)=>{let u=[],l=n[0].dims,d=ot.normalizeAxes(a,n[0].dims.length),c=!s&&0===d.length;l.forEach(((e,t)=>{c||d.indexOf(t)>=0?o&&u.push(1):u.push(e)}));let p=[],f=$t("_A",n[0].dataType,l),h=vt("output",i,u),m=r(f,h,d),g=`inputOffset = ${f.indicesToOffset("inputIndices")};`,y=`let ${g};`,w=`var ${g};`,$=""===m[1]?"":w,v=(""===m[1]?y:g)+"\n"+m[2];for(let e=0,t=0;e<n[0].dims.length;e++)c||d.indexOf(e)>=0?(o&&t++,v=`for(var j${e}: u32 = 0; j${e} < ${n[0].dims[e]}; j${e}++) {\n                ${m[2].includes("lastIndex")?`let lastIndex = j${e};`:""}\n                ${f.indicesSet("inputIndices",e,`j${e}`)}\n                ${v}\n              }`):(p.push(`${f.indicesSet("inputIndices",e,h.indicesGet("outputIndices",t))};`),t++);let b=ot.size(u);return{name:e,shaderCache:t,getShaderSource:e=>`\n        ${e.declareVariables(f,h)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n          var inputIndices: ${f.type.indices};\n          let outputIndices = ${h.offsetToIndices("global_idx")};\n\n          ${p.join("\n")}\n          ${m[0]}       // init ops for reduce max/min\n          ${$}\n          ${m[1]}\n          ${v}\n          ${m[3]}\n          ${4===m.length?h.setByOffset("global_idx","value"):m.slice(4).join("\n")}\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(b/64)}})}},nn=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),rt({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rn=(e,t,n,r)=>{let a=e.inputs,i=1===a.length?n:nn(a,n);e.compute(tn(t,{hint:i.cacheKey},[a[0]],i.noopWithEmptyAxes&&0===i.axes.length?en:r,i.axes,a[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},an=(e,t)=>{Zt(e.inputs),rn(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,"value = log(value);"]))},on=(e,t)=>{Zt(e.inputs),rn(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByOffset("inputOffset")});`,""]))},sn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"]))},un=(e,t)=>{Zt(e.inputs),rn(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByOffset("inputOffset")});`,"value = log(value);"]))},ln=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("inputIndices",t,0));return[`${r.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = max(value, ${e.getByOffset("inputOffset")});`,""]}))},dn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMean",t,((t,n,r)=>{let a=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(a*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${a});`]}))},cn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`inputIndices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = min(value, ${e.getByOffset("inputOffset")});`,""]}))},pn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByOffset("inputOffset")};`,""]))},fn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,""]))},hn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += t * t;`,""]))},mn=(e,t,n)=>{if(0===t.length)return!!n;let r=1,a=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:a*=e[n];return a<32&&r>1024},gn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dn(e,t):jt(e,t)},yn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?on(e,t):Ft(e,t)},wn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?sn(e,t):Ht(e,t)},$n=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?un(e,t):Lt(e,t)},vn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ln(e,t):qt(e,t)},bn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cn(e,t):Yt(e,t)},xn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pn(e,t):Kt(e,t)},Sn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fn(e,t):Xt(e,t)},_n=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hn(e,t):Jt(e,t)},Cn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?an(e,t):Qt(e,t)},En=e=>rt(e)})),rs=P((()=>{Lo(),Jo(),ns(),In=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},An=(e,t)=>rt({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),On=(e,t)=>{In(e.inputs);let n=1===e.inputs.length?t:An(e.inputs,t);e.compute(tn("ArgMin",{hint:n.cacheKey},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]}),[n.axis],7,n.keepDims),{inputs:[0]})},Tn=(e,t)=>{In(e.inputs);let n=1===e.inputs.length?t:An(e.inputs,t);e.compute(tn("argMax",{hint:n.cacheKey},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]}),[n.axis],7,n.keepDims),{inputs:[0]})},Rn=e=>rt(e)})),as=P((()=>{Qo(),Zo(),kn=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Bn=e=>{let t=e[0].dims,n=e[0].dims[2],r=ot.size(t)/4,a=e[0].dataType,i=$t("input",a,t,4),o=$t("bias",a,[n],4),s=$t("residual",a,t,4),u=vt("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(i,o,s,u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${i.getByOffset("global_idx")}\n      + ${o.getByOffset("global_idx % channels")} + ${s.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx","value")}\n  }`}},Mn=e=>{kn(e.inputs),e.compute(Bn(e.inputs))}})),is=P((()=>{Lo(),Qo(),Jo(),Zo(),Dn=(e,t,n,r,a,i)=>{let o=Math.ceil(t/4),s="";s="string"==typeof a?`${a}(a)`:a("a");let u=$t("inputData",n,[o],4),l=vt("outputData",r,[o],4);return`\n  ${e.declareVariables(u,l)}\n\n  ${i??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    let a = ${u.getByOffset("global_idx")};\n    ${l.setByOffset("global_idx",s)}\n  }`},Pn=(e,t,n,r,a,i=e.dataType)=>({name:t,shaderCache:{hint:a},getShaderSource:t=>Dn(t,ot.size(e.dims),e.dataType,i,n,r),getRunData:t=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(ot.size(t[0].dims)/64/4)}})}),zn=e=>{e.compute(Pn(e.inputs[0],"Abs","abs"))},Wn=e=>{e.compute(Pn(e.inputs[0],"Acos","acos"))},Nn=e=>{e.compute(Pn(e.inputs[0],"Acosh","acosh"))},Gn=e=>{e.compute(Pn(e.inputs[0],"Asin","asin"))},Un=e=>{e.compute(Pn(e.inputs[0],"Asinh","asinh"))},Vn=e=>{e.compute(Pn(e.inputs[0],"Atan","atan"))},jn=e=>{e.compute(Pn(e.inputs[0],"Atanh","atanh"))},Fn=e=>rt(e),Hn=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Pn(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},Ln=(e,t)=>{let n=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<${n}> = vec4(${n}(${t.min}));\n    const clip_max_: vec4<${n}> = vec4(${n}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},qn=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:lt,n=e.length>=3?e[2].getFloat32Array()[0]:dt;return rt({min:t,max:n})},Yn=e=>{let t=qn(e.inputs);Ln(e,t)},Kn=e=>{e.compute(Pn(e.inputs[0],"Ceil","ceil"))},Xn=e=>{e.compute(Pn(e.inputs[0],"Cos","cos"))},Jn=e=>{e.compute(Pn(e.inputs[0],"Cosh","cosh"))},Qn=e=>rt(e),Zn=(e,t)=>{e.compute(Pn(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},er=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,tr=e=>{let t=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),er(`vec4<${t}>`,t)))},nr=e=>{e.compute(Pn(e.inputs[0],"Exp","exp"))},rr=e=>{e.compute(Pn(e.inputs[0],"Floor","floor"))},ar=e=>{let t=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),er(`vec4<${t}>`,t)))},ir=(e,t)=>{e.compute(Pn(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},or=e=>{e.compute(Pn(e.inputs[0],"Not",(e=>`!${e}`)))},sr=e=>{e.compute(Pn(e.inputs[0],"Neg",(e=>`-${e}`)))},ur=e=>{e.compute(Pn(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},lr=e=>{e.compute(Pn(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},dr=e=>{e.compute(Pn(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},cr=e=>{e.compute(Pn(e.inputs[0],"Sin","sin"))},pr=e=>{e.compute(Pn(e.inputs[0],"Sinh","sinh"))},fr=e=>{e.compute(Pn(e.inputs[0],"Sqrt","sqrt"))},hr=e=>{e.compute(Pn(e.inputs[0],"Tan","tan"))},mr=e=>{e.compute(Pn(e.inputs[0],"Tanh","tanh"))},gr=(e,t)=>(e.compute(Pn(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),yr=e=>{e.compute(Pn(e.inputs[0],"Log","log"))}})),os=P((()=>{Qo(),Zo(),is(),wr=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},$r=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=$t("input",e[0].dataType,e[0].dims,4),r=$t("bias",e[0].dataType,[e[0].dims[2]],4),a=vt("output",e[0].dataType,t,4),i=ot.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,r,a)}\n\n  ${er("vec4f")}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},vr=e=>{wr(e.inputs),e.compute($r(e.inputs))}})),ss=P((()=>{Lo(),Qo(),Zo(),br=(e,t,n,r,a,i,o,s,u,l,d)=>{let c,p,f=ot.size(r),h=Math.ceil(f/4);"string"==typeof o?c=p=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?c=p=o:(c=o.scalar,p=o.vector);let m,g="",y=vt("outputData",l,r,4),w=$t("aData",s,t,4),$=$t("bData",u,n,4);if(i){let e=e=>{let t=ot.computeStrides(e),n=[];for(let a=e.length-1;a>=0;a--){let i=y.indicesGet("outputIndices",a+r.length-e.length);n.push(`${t[a]}u * (${i} % ${e[a]}u)`)}return n.length>0?n.join("+"):"0u"};g=`\n          fn calcOffsetA(outputIndices: ${y.type.indices}) -> u32 {\n            return ${e(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${y.type.indices}) -> u32 {\n            return ${e(n)};\n          }\n        `}if(a)if(i){let e=1===ot.size(t),r=1===ot.size(n);m=e||r?y.setByOffset("global_idx",p(e?`${w.type.value}(${w.getByOffset("0")}.x)`:w.getByOffset("global_idx"),r?`${$.type.value}(${$.getByOffset("0")}.x)`:$.getByOffset("global_idx"))):`\n            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${y.setByOffset("global_idx",p(w.getByOffset("offsetA / 4u"),$.getByOffset("offsetB / 4u")))}\n          `}else m=y.setByOffset("global_idx",p(w.getByOffset("global_idx"),$.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${y.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = calcOffsetA(outputIndices${t});\n            let offsetB${t} = calcOffsetB(outputIndices${t});\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${c(r,a)});\n          `};m=9===l?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(w,$,y)}\n\n        ${d??""}\n        ${g}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n        ${m}\n      }`},xr=(e,t,n,r,a,i,o=n.dataType)=>{let s=!ot.areEqual(n.dims,r.dims),u=n.dims,l=ot.size(n.dims),d=!1;if(s){let e=it.calcShape(n.dims,r.dims,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");u=e,l=ot.size(u);let t=1===ot.size(n.dims),a=1===ot.size(r.dims),i=1;for(let e=1;e<u.length;e++){let t=n.dims[n.dims.length-e]??1;if(t!==(r.dims[r.dims.length-e]??1))break;i*=t}(i%4==0||t||a)&&(d=!0)}else d=!0;return{name:e,shaderCache:{hint:t},getShaderSource:e=>br(e,n.dims,r.dims,u,d,s,a,n.dataType,r.dataType,o,i),getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},Sr=(e,t,n,r,a,i)=>{e.compute(xr(t,a??"",e.inputs[0],e.inputs[1],n,r,i))},_r=e=>{Sr(e,"Add",((e,t)=>`${e}+${t}`))},Cr=e=>{Sr(e,"Div",((e,t)=>`${e}/${t}`))},Er=e=>{Sr(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},Ir=e=>{Sr(e,"Mul",((e,t)=>`${e}*${t}`))},Ar=e=>{let t=$t("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Sr(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Or=e=>{Sr(e,"Sub",((e,t)=>`${e}-${t}`))},Tr=e=>{Sr(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Rr=e=>{Sr(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},kr=e=>{Sr(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Br=e=>{Sr(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),us=P((()=>{Qo(),Jo(),Zo(),Mr=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,n=e[0].dims.length;for(let r of e){if(r.dataType!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}},Dr=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Pr=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;++a){let i=t.setByOffset("global_idx",e[a].getByIndices("indices"));1===n?r.push(i):0===a?r.push(`if (inputIndex == ${a}u) { ${i} }`):a===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${a}) { ${i} }`)}return r.join("\n")},zr=(e,t)=>{let n=e[0].dims.slice();if(t>=n.length||t<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");let r=t<0?n.length+t:t,a=n.slice(0);for(let t=1;t<e.length;t++){let i=e[t].dims.slice();for(let e=0;e<n.length;e++)if(e===r)a[r]+=i[e];else if(n[e]!==i[e])throw new Error("non concat dimensions must match")}let i=ot.size(a),o=new Array(e.length),s=new Array(e.length),u=e[0].dataType,l=0;for(let t=0;t<e.length;++t)l+=e[t].dims[r],o[t]=l,s[t]=$t(`input${t}`,u,e[t].dims);let d=vt("output",u,a),c=d.indicesGet("indices",r);return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n  ${e.declareVariables(...s,d)}\n\n  const sizeInConcatAxis = array<u32, ${o.length}>(${o.map((e=>`${e}u`)).join(",")});\n  ${Dr(o.length)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n    var indices = ${d.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${c});\n    if (inputIndex != 0u) {\n      ${c} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Pr(s,d)}\n  }`}},Wr=(e,t)=>{Mr(e.inputs),e.compute(zr(e.inputs,t.axis))},Nr=e=>rt({axis:e.axis})})),ls=P((()=>{Gr=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Ur=(e,t=!1,n=!1,r=3)=>"",Vr=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `})),ds=P((()=>{jr="\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n"})),cs=P((()=>{Qo(),Fr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Hr=e=>{let t=e?.activation||"";if("Clip"===t){let[n,r]=e?.activation_params||[lt,dt];return{activation:t,clipMax:r,clipMin:n,activationCacheKey:`${t}:${n},${r}`}}return{activation:t,activationCacheKey:t}}})),ps=P((()=>{Qo(),Zo(),cs(),ls(),Lr=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,qr=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Yr=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32)=>{let u=t[1]*e[1],l=t[0]*e[0],d=a?u:i,c=a?i:u,p=d/t[0],f=i/t[1];if((!a||4!==p||4!==e[1])&&(a||3!==p&&4!==p)||d%t[0]!=0||i%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${a} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${p} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${p}<${n}>, ${d/p}>, ${c}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${p};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${o?"0":"i32(globalId.z)"};\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let numTiles = ${o?`${Math.ceil(s/i)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${f};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Lr(a,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${qr(a,p)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Kr=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Xr=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Jr=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32,u=!1)=>{let l=e[1]*t[1],d=e[0]*t[0],c=a?l:i,p=a?i:l;if(p%t[1]!=0||c%t[0]!=0||i%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let f=p/t[1],h=c/t[0],m=i/t[1],g=u?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${l};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${Kr(a,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${l};\n\nlet tileRowA = i32(localId.y) * ${f};\nlet tileColA = i32(localId.x) * ${h};\nlet tileRowB = i32(localId.y) * ${m};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${h}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Kr(a,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Xr(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${o?"0":"i32(globalId.z)"};\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${o?`${Math.ceil(s/i)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${g}\n  }\n`},Qr=(e,t,n,r,a,i=!1)=>{let o=a[0],s=a[1],u=a[2],l=r[0],d=r[1],c=r[2],p=r[3],f=St(o,u),h=St(s,u),m=pt(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${Gr(e,m)} {\n      var value = ${Gr(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${(()=>{let e=d.rank,t=l.rank,n=`var aIndices: ${d.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\naIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return f.forEach((e=>{n+=`\naIndices[${e}] = 0;`})),n+=`\naIndices[${e-2}] = u32(row);\n                   aIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${Gr(e,m)} {\n      var value = ${Gr(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${(()=>{let e=c.rank,t=l.rank,n=`var bIndices: ${c.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\nbIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return h.forEach((e=>{n+=`\nbIndices[${e}] = 0;`})),n+=`\nbIndices[${e-2}] = u32(row);\n                   bIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${c.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Gr(e,m)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${i?"bias[colIn]":`${Gr(e,m)}(bias[row])`};`:""}\n        ${n}\n        ${p.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Zr=(e,t,n,r,a=!1)=>{let i=e[0].dims,o=e[1].dims,s=i.slice(0,-2),u=o.slice(0,-2),l=r?r.slice(0,-2):n.slice(0,-2),d=$t("batchDims",e[0].dataType,l),c=[d],p=[s,u,l],f=ot.size(l),h=i[i.length-2],m=i[i.length-1],g=o[o.length-1],y=m%4==0&&g%4==0,{activationFunction:w,applyActivation:$}=Fr(t,y),v=h<=8?[4,1,1]:[4,4,1],b=[8,8,1],x=[Math.ceil(g/b[0]/v[0]),Math.ceil(h/b[1]/v[1]),Math.ceil(f/b[2]/v[2])],S=pt(e[0].dataType),_=y?4:1,C=$t("a",e[0].dataType,[...s,h,m/_],_),E=$t("b",e[1].dataType,[...u,m,g/_],_),I=vt("result",e[0].dataType,[f,h,g/_],_);c.push(C),c.push(E),c.push(I);let A=[C,E],O=e.length>2,T=Qr(_,O,$,c,p,a);if(O){let t=a?_:1;A.push($t("bias",e[2].dataType,e[2].dims,t))}return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]}}),getShaderSource:e=>`\n  const dimAOuter: i32 = ${h};\n  const dimBOuter: i32 = ${g};\n  const dimInner: i32 = ${m};\n  ${e.declareVariables(...A,I)}\n  ${w}\n  ${T}\n  ${y?Yr(v,b,S,d):Jr(v,b,S,d)}\n                   ${d.impl()}`}}})),fs=P((()=>{qo(),Qo(),Zo(),ls(),ds(),ps(),ea=(e,t,n,r,a=!1,i,o=!1,s=4,u=4,l=4,d="f32")=>{let c=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",p=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",m=e?"row":"col",g=e?"col":"row",y=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${m} / outWidth;\n    let outCol = ${m} % outWidth;\n\n    let WRow = ${g} / (filterDims[1] * inChannels);\n    let WCol = ${g} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${g} % inChannels;\n    var resData = ${Gr(s,d)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\n      ${c}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(s)}\n    }\n    return resData;`,w=e?t&&r?`\n    let col = colIn * ${s};\n    ${y}`:`\n    let col = colIn * ${s};\n    if (row < dimAOuter && col < dimInner) {\n      ${y}\n    }\n    return ${Gr(s,d)}(0.0);`:r&&n?`\n    let col = colIn * ${s};\n    ${y}`:`\n    let col = colIn * ${s};\n    if (row < dimInner && col < dimBOuter) {\n      ${y}\n    }\n    return ${Gr(s,d)}(0.0);`,$=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,v=Gr(l,d),b=Gr(e?s:u,d),x=Gr(e?u:s,d);return`\n    ${Ur(i,o,4===l,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\n      ${e?w:$}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\n      ${e?$:w}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${v}) {\n      let col = colIn * ${l};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${p}\n      ${Vr(a,i)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ta=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],c=u?n[2]:n[3],p=u?n[1]:n[2],f=u?n[3]:n[1],h=u&&(l%4==0||l%3==0)&&f%4==0,m=u?f:c*p,g=u?c*p:f,y=[8,8,1],w=r<=8?[4,1,1]:[4,4,1],$=[Math.ceil(m/y[0]/w[0]),Math.ceil(g/y[1]/w[1]),Math.ceil(d/y[2]/w[2])];Ye("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${$}`));let v=h?u&&l%4!=0?3:4:w[0],b=y[1]*w[1],x=y[0]*w[0],S=Math.max(y[0]*v,y[1]),_=r%b==0,C=a%x==0,E=i%S==0,I=h?[v,4,4]:[1,1,1],A=pt(e[0].dataType),O=[`@group(0) @binding(0) var<storage, read> x: array<${h&&4===v?`vec4<${A}>`:A}>;`,`@group(0) @binding(1) var<storage, read> w: array<${h?`vec4<${A}>`:A}>;`],T=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${h?`vec4<${A}>`:A}) {\n        result[flatIndex] = ${h?`vec4<${A}>`:A}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${h?`vec4<${A}>`:A}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${h?"/ 4":""}, value);\n      }`;return o&&(O.push(`@group(0) @binding(2) var<storage, read> bias: array<${h?`vec4<${A}>`:A}>;`),T+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?`vec4<${A}>`:A} {\n          return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]}}),getShaderSource:()=>`\n        ${jr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${O.join("")}\n        @group(0) @binding(${O.length}) var<storage, read_write> result: array<${h?`vec4<${A}>`:A}>;\n        //@group(0) @binding(${O.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${ot.computeStrides(n).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${r};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${i};\n        ${T}\n        ${ea(u,_,C,E,o,t.activation.toLowerCase(),!1,I[0],I[1],I[2],A)}\n            ${h?Yr(w,y,A,void 0,!u,S):Jr(w,y,A,void 0,!u,S,!1,void 0,s)}`}}})),hs=P((()=>{Qo(),Zo(),ms(),cs(),na=(e,t,n)=>{let r=e.length>2,a=r?"value += b[output_channel];":"",i=e[0].dims,o=e[1].dims,s=o[0]/t.group,{activationFunction:u,applyActivation:l}=Fr(t),d="NHWC"===t.format,c=ra(i,o,t.dilations,t.pads,t.strides,d),p=ot.size(c),f=vt("output",e[0].dataType,c),h=$t("x",e[0].dataType,i),m=$t("w",e[1].dataType,o),g=[h,m];return r&&g.push($t("b",e[2].dataType,e[2].dims)),{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n?n(c):c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:e=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${e.declareVariables(...g,f)}\n\n  ${u}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n    let outputIndices = ${f.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${d?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${d?1:2}], outputIndices[${d?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${s}u;\n\n    var value: ${f.type.value} = ${f.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${o[1]}u; wInChannel++) {\n      let input_channel = group_id * ${o[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${o[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${i[d?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${o[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${i[d?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${d?h.get("batch","xHeight","xWidth","input_channel"):h.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${m.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${a}\n    ${l}\n    ${f.setByOffset("global_idx","value")}\n  }`}}})),ms=P((()=>{Qo(),Jo(),fs(),ps(),hs(),cs(),es(),ra=(e,t,n,r,a,i)=>{let o=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-d[t]+a[t])/a[t])));return c.splice(0,0,o),c.splice(i?3:1,0,l),c},aa=[2,3,1,0],ia=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},oa=(e,t)=>{let n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();st.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),a},sa=e=>{let t=Hr(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,i=e.group,o=e.kernel_shape,s=e.pads,u=e.strides,l=e.w_is_const();return rt({autoPad:r,format:n,dilations:a,group:i,kernelShape:o,pads:s,strides:u,wIsConst:l,...t})},ua=(e,t,n)=>{let r=oa(n,t);if(1!==n.group)return void e.compute(na(t,r));let a="NHWC"===n.format,i=3===t.length,o=t[0].dims[a?1:2],s=t[0].dims[a?2:3],u=t[0].dims[a?3:1],l=t[1].dims[2],d=t[1].dims[3],c=ra(t[0].dims,t[1].dims,n.dilations,r.pads,n.strides,a),p=c[a?1:2],f=c[a?2:3],h=c[a?3:1],m=a&&l===o&&d===s&&0===n.pads[0]&&0===n.pads[1];if(m||1===l&&1===d&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let l,d,g,y=c[0],w=[];if(a){let r=e.kernelCustomData.wT??e.compute(Ot(t[1],aa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*s*u;l=t[0].reshape([1,y,e]),d=r.reshape([1,e,h]),g=[1,y,h]}else l=t[0].reshape([y,o*s,u]),d=r.reshape([1,u,h]),g=[y,p*f,h];w.push(l),w.push(d)}else l=t[0].reshape([y,u,o*s]),d=t[1].reshape([1,h,u]),g=[y,h,p*f],w.push(d),w.push(l);return i&&w.push(t[2]),void e.compute(Zr(w,r,c,g,a),{inputs:w})}let g=e.kernelCustomData.wT??e.compute(Ot(t[1],aa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let y=[t[0],g];i&&y.push(t[2]);let w=a?p*f:h,$=a?h:p*f,v=l*d*u;e.compute(ta(y,r,c,w,$,v,i,!0),{inputs:y})},la=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),o=[1].concat(t.dilations),s=[1].concat(t.kernelShape),u=oa({...t,pads:a,strides:i,dilations:o,kernelShape:s},r);e.compute(na(r,u,(e=>n?[e[0],e[2],e[3]]:[])))},da=(e,t)=>{ia(e.inputs,t),3===e.inputs[0].dims.length?la(e,t):ua(e,e.inputs,t)}})),gs=P((()=>{qo(),Qo(),ls(),ds(),ps(),ca=(e,t=!1,n,r=!1,a=4)=>{let i=Gr(a,"f32"),o=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",s=e?"row":"col",u=e?"col":"row",l=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${s} / outWidth;\n      let outCol = ${s} % outWidth;\n\n      let WRow = ${u} / (filterDims[1] * inChannels);\n      let WCol = ${u} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${e?"outBackprop[1]":"outBackprop[2]"}) || fract(xR) > 0.0) {\n        return ${i}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${e?"outBackprop[2]":"outBackprop[3]"}) || fract(xC) > 0.0) {\n        return ${i}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${u} % inChannels;\n      ${e?"\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      "}\n      return x[getIndexFromCoords4D(coord, xShape)/${a}];`,d=e?`\n      let col = colIn * ${a};\n      if (row < dimAOuter && col < dimInner) {\n        ${l}\n      }\n      return ${i}(0.0);`:`\n      let col = colIn * ${a};\n      if (row < dimInner && col < dimBOuter) {\n        ${l}\n      }\n      return ${i}(0.0);`,c=`\n      let col = colIn * ${a};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\n      }\n      return ${i}(0.0);\n      `;return`\n  ${Ur(n,r,4===a,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?d:c}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?c:d}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${i}) {\n    let col = colIn * ${a};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${o}\n      ${Vr(t,n)}\n      result[getIndexFromCoords4D(coords, outShape)/${a}] = value;\n    }\n  }`},pa=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],c=u?n[2]:n[3],p=u?n[1]:n[2],f=u?n[3]:n[1],h=u?l%4==0&&f%4==0:c%4==0&&f%4==0,m=u?f:c*p,g=u?c*p:f,y=h?[8,8,1]:[m<=4||g<=4?4:16,m>4&&g<=4?4:16,1],w=h?[4,4,1]:[m<=4?1:4,m>4&&g<=4?1:4,1],$=[Math.ceil(m/y[0]/w[0]),Math.ceil(g/y[1]/w[1]),Math.ceil(d/y[2]/w[2])];Ye("verbose",(()=>`[conv_backprop_mm_webgpu] dispatch = ${$}`));let v=h?4:1,b=Math.max(y[0]*v,y[1]),x=[`@group(0) @binding(0) var<storage, read> x: array<${h?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],S="";return o&&(x.push(`@group(0) @binding(2) var<storage, read> bias: array<${h?"vec4<f32>":"f32"}>;`),S+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?"vec4<f32>":"f32"} {\n          return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]}}),getShaderSource:()=>`\n        ${jr}\n        ${x.join("\n")}\n        @group(0) @binding(${x.length}) var<storage, read_write> result: array<${h?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${ot.computeStrides(n).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[u?1:2]}, ${t.kernelShape[u?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[u?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[u?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${r};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${i};\n        ${S}\n        ${ca(u,o,t.activation.toLowerCase(),!1,v)}\n        ${h?Yr(w,y,"f32",void 0,!u,b):Jr(w,y,"f32",void 0,!u,b,!1,void 0,s)}`}}})),ys=P((()=>{qo(),Qo(),Zo(),fa=(e,t,n,r,a,i,o=!1,s)=>{let u="NHWC"===n.format,l=u?1:2,d=u?2:3,c=u?3:1,p=ot.size(r),f=o?2:1,h=n.group,m=t[1].dims,g=m[0]/h,y=m[1],w=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${o?`vec4<${s}>`:s}) {\n    result[flatIndex] = ${o?`vec4<${s}>`:s}(value);\n  }`;a&&(w+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${o?`vec4<${s}>`:s} {\n      return bias[coords.${u?"w":"y"}${o?"/ 4":""}];\n    }`);let $=o?4:1,v=$t("W",t[1].dataType,t[1].dims,$),b=$t("Dy",t[0].dataType,t[0].dims,$),x=[b,v];a&&x.push($t("bias",t[2].dataType,[r[c]],$));let S=vt("result",t[0].dataType,r,$),_=`{\n        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${i?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${i?"global_id.y":"workgroup_id.y"} * ${f};\n        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${s}>, ${f}>;\n        for (var i = 0; i < ${f}; i++) {\n          dotProd[i] = vec4<${s}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${s}(dyCorner.x) + ${s}(wR)) / ${s}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${s}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${s}(dyCorner.y) + ${s}(wC)) / ${s}(strides.y);\n            let dyC2 = (${s}(dyCorner.y) + 1.0 + ${s}(wC)) / ${s}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${s}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${s}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${b.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${s}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${c}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${f}; i = i + 1) {\n          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};\n          ${S.set("batch","r","c + i","d1","value")};\n        }\n      }`,C=`\n          let outputIndices = ${S.offsetToIndices("global_idx")};\n          let batch = ${S.indicesGet("outputIndices",0)};\n          let d1 = ${S.indicesGet("outputIndices",c)};\n          let r = ${S.indicesGet("outputIndices",l)};\n          let c = ${S.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${y};\n          let wOutChannel = d1 - groupId * ${y};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${s}(dyRCorner) + ${s}(wR)) / ${s}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${s}(outBackprop[${l}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${s}(dyCCorner) + ${s}(wC)) / ${s}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${s}(outBackprop[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${g};\n              for (var d2: u32 = 0; d2 < ${g}; d2 = d2 + 1) {\n                let xValue = ${u?b.get("batch","idyR","idyC","inputChannel"):b.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${v.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${a?"bias[d1]":"0.0"};\n          ${S.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...x,S)}\n  ${w}\n  const outShape : vec4<u32> = vec4<u32>(${r.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[u?1:2]}, ${n.kernelShape[u?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${n.dilations[0]<=1?0:(n.kernelShape[u?1:2]-1)*(n.dilations[0]-1)},\n          ${n.dilations[1]<=1?0:(n.kernelShape[u?2:3]-1)*(n.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)};\n  ${o?_:C}}`},ha=(e,t,n)=>{let r=e.length>2,a=t.outputShape,i=ot.size(a),o=[Math.ceil(i/64),1,1];Ye("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${o}`));let s=pt(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:o[0],y:o[1],z:o[2]},outputs:[{dims:n?n(a):a,dataType:e[0].dataType}]}),getShaderSource:n=>fa(n,e,t,a,r,1===o[1]&&1===o[2],!1,s)}}})),ws=P((()=>{Jo(),gs(),ys(),cs(),es(),ma=(e,t,n,r,a,i)=>(e-1)*t+n+(r-1)*a+1-i,ga=(e,t,n,r,a)=>{let i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[a]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[a]=i)},ya=(e,t,n,r,a,i,o,s,u,l)=>{let d=e.length-2,c=0===l.length;if(0===u.length)for(let e=0;e<d;++e)u.push(0);let p=e[0],f=t[s?3:1]*a;for(let a=0,p=e.length-d-(s?1:0);a<d;++a,++p){let s=e[p],f=c?s*o[a]:l[a],h=ma(s,o[a],i[a],t[p],n[a],f);ga(h,r,i,a,a+d),c&&l.push(o[a]*(s-1)+u[a]+(t[p]-1)*n[a]+1-i[a]-i[a+d])}l.splice(0,0,p),l.splice(s?3:1,0,f)},wa=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let a=e.pads.slice(),i=e.outputShape.slice(),o=e.outputPadding.slice(),s=t[0].dims,u=e.dilations.slice();if(0===u.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}let l=e.strides.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}ya(s,n,u,e.autoPad,e.group,a,l,r,o,i);let d=Object.assign({},e),c=e.cacheKey+[n.join("n,"),a.join(","),l.join(","),o.join(","),i.join(","),u.join(",")].join("_");return Object.assign(d,{kernelShape:n,pads:a,outputPadding:o,outputShape:i,dilations:u,strides:l,cacheKey:c}),d},$a=e=>{let t=Hr(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,i=e.group,o=e.kernelShape,s=e.pads,u=e.strides,l=e.wIsConst(),d=e.outputPadding,c=e.outputShape;return rt({autoPad:r,format:n,dilations:a,group:i,kernelShape:o,outputPadding:d,outputShape:c,pads:s,strides:u,wIsConst:l,...t})},va=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},ba=[2,3,1,0],xa=(e,t,n)=>{let r=wa(n,t),a="NHWC"===n.format,i=3===t.length;if(1!==r.group)return void e.compute(ha(t,r));let o=r.outputShape,s=o[a?1:2],u=o[a?2:3],l=o[a?3:1],d=a?s*u:l,c=a?l:s*u,p=t[1].dims[2]*t[1].dims[3]*t[0].dims[a?3:1],f=e.kernelCustomData.wT??e.compute(Ot(t[1],ba),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=f);let h=[t[0],f];i&&(a||1!==t[2].dims.length?h.push(t[2]):h.push(t[2].reshape([t[2].dims[0],1,1]))),e.compute(pa(h,r,o,d,c,p,i,!0),{inputs:h})},Sa=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===r.length&&r.push(e.inputs[2]);let a=t.kernelShape;(0===a.length||0===a[0])&&(a=[e.inputs[1].dims[2]]);let i=t.dilations;(0===i.length||0===i[0])&&(i=[1]);let o=t.strides;(0===o.length||0===o[0])&&(o=[1]);let s=t.pads;0===s.length&&(s=[0,0]),s=[0,s[0],0,s[1]],o=[1].concat(o),i=[1].concat(i),a=[1].concat(a);let u=wa({...t,pads:s,strides:o,dilations:i,kernelShape:a},r);e.compute(ha(r,u,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])))},_a=(e,t)=>{va(e.inputs,t),3===e.inputs[0].dims.length?Sa(e,t):xa(e,e.inputs,t)}})),$s=P((()=>{Qo(),Jo(),Zo(),Ia="^"+(Ea="("+(Ca="[a-zA-Z]|\\.\\.\\.")+")+")+"$",Aa="^("+Ea+",)*"+Ea+"$",Oa=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Ta=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(Aa)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(Ia)))throw new Error("Invalid LHS term");let a=this.processTerm(t,!0,r,n);this.lhs.push(a)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(Ea)))throw new Error("Invalid RHS");r.match(RegExp(Ca,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!0,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let a=n.length,i=!1,o=[],s=0;if(!e.match(RegExp(Ia))&&!t&&""!==e)throw new Error("Invalid LHS term");let u=e.match(RegExp(Ca,"g")),l=new Oa(r);return u?.forEach(((e,d)=>{if("..."===e){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let e=a-u.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(o=n.slice(s,s+e),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=o}for(let e=0;e<o.length;e++){let t=String.fromCharCode("0".charCodeAt(0)+d);l.addSymbol(t,d+e),this.addSymbol(t,n[s++],r)}}else l.addSymbol(e,d),this.addSymbol(e,n[s++],r)})),l}},Ra=(e,t)=>{let n=e[0].dataType,r=new Array(e.length);for(let t=0;t<e.length;++t)r[t]=$t(`input${t}`,n,e[t].dims);let a=t.outputDims,i=ot.size(a),o=vt("output",n,a),s=[],u=Array.from(t.rhs.symbolToIndices.keys()),l=[],d=[],c=[],p=[],f=t.symbolToInfo.size===u.length;t.symbolToInfo.forEach(((e,n)=>{if(u.includes(n)){let a=u.indexOf(n);t.lhs.forEach(((t,i)=>{if(e.inputIndices.includes(i)){let e=t.symbolToIndices.get(n);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{s.push(`${r[i].indicesSet(`input${i}Indices`,e,o.indicesGet("outputIndices",a))}`)}))}}))}else t.lhs.forEach(((e,a)=>{let i=t.symbolToInfo.get(n);if(void 0===i)throw new Error("Invalid symbol error");if(i.inputIndices.includes(a)){let t=e.symbolToIndices.get(n);if(void 0===t)throw new Error("Invalid symbol error");t.forEach((e=>{l.push(`${r[a].indicesSet(`input${a}Indices`,e,`${n}`)}`)})),p.push(`prod *= ${r[a].getByIndices(`input${a}Indices`)};`)}})),d.push(`for(var ${n}: u32 = 0; ${n} < ${t.symbolToInfo.get(n)?.dimValue}; ${n}++) {`),c.push("}")}));let h=f?[...s,`let sum = ${r.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...s,"var sum = 0.0;",...d,...l,"var prod = 1.0;",...p,"sum += prod;",...c];return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n      ${e.declareVariables(...r,o)}\n\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n        var outputIndices = ${o.offsetToIndices("global_idx")};\n        ${r.map(((e,t)=>`var input${t}Indices: ${r[t].type.indices};`)).join("\n")}\n        ${h.join("\n")};\n        ${o.setByOffset("global_idx","sum")};\n      }`}},ka=(e,t)=>{let n=new Ta(e.inputs,t.equation);e.compute(Ra(e.inputs,n))},Ba=e=>{let t=e.equation.replace(/\s+/g,"");return rt({equation:t})}})),vs=P((()=>{Qo(),Zo(),Ma=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,a=t.length<n.length?0:t.length-n.length;for(;r<n.length&&a<t.length;++r,++a)if(n[r]!==t[a]&&1!==n[r]&&1!==t[a])throw new Error("Expand requires shape to be broadcastable to input")},Da=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let a=0;a<t.length;++a)r.push(1===t[a]?e[a+n]:t[a]);return r},Pa=(e,t)=>e.length>t.length?Da(e,t):Da(t,e),za=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=Pa(t,n),a=ot.size(r),i=e[0].dataType,o=$t("input",i,t),s=vt("output",i,r);return{name:"Expand",shaderCache:{hint:`${r}`},getShaderSource:e=>`\n  const inputShape = ${o.indices(...t)};\n  ${e.declareVariables(o,s)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let outputIndices = ${s.offsetToIndices("global_idx")};\n    var inputIndices: ${o.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${o.indicesGet("inputShape","i")} == 1) {\n        ${o.indicesSet("inputIndices","i",0)}\n      } else {\n        ${o.indicesSet("inputIndices","i",s.indicesGet("outputIndices","i + "+(r.length-t.length)))}\n      }\n    }\n    ${s.setByOffset("global_idx",o.getByIndices("inputIndices"))}\n  }`,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}})}},Wa=e=>{Ma(e.inputs),e.compute(za(e.inputs),{inputs:[0]})}})),bs=P((()=>{Qo(),Jo(),Zo(),Na=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},Ga=(e,t)=>{let n=e[0].dims,r=e[1].dims,a=n.length,i=ot.normalizeAxis(t.axis,a),o=n.slice(0);o.splice(i,1,...r);let s=n[i],u=ot.size(o),l=$t("data",e[0].dataType,e[0].dims),d=$t("inputIndices",e[1].dataType,e[1].dims),c=vt("output",e[0].dataType,o);return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:e=>`\n      ${e.declareVariables(l,d,c)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        let outputIndices = ${c.offsetToIndices("global_idx")};\n        ${(()=>{let e=r.length,t=`var indicesIndices  = ${d.type.indices}(0);`;for(let n=0;n<e;n++)t+=`${e>1?`indicesIndices[${n}]`:"indicesIndices"} = ${o.length>1?`outputIndices[${i+n}]`:"outputIndices"};`;t+=`\n        var idx = ${d.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${s};\n        }\n        var dataIndices = ${l.type.indices}(0);\n      `;for(let n=0,r=0;n<a;n++)n===i?(t+=(a>1?`dataIndices[${n}]`:"dataIndices")+" = u32(idx);",r+=e):(t+=`${a>1?`dataIndices[${n}]`:"dataIndices"} = ${o.length>1?`outputIndices[${r}]`:"outputIndices"};`,r++);return t})()};\n        let value = ${l.getByIndices("dataIndices")};\n        ${c.setByOffset("global_idx","value")};\n      }`}},Ua=e=>rt({axis:e.axis}),Va=(e,t)=>{let n=e.inputs;Na(n),e.compute(Ga(e.inputs,t))}})),xs=P((()=>{Qo(),Jo(),Zo(),ja=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},Fa=(e,t)=>{let n=e[0].dims,r=e[0].dataType,a=n.length,i=ot.computeStrides(n),o=ot.size(n),s=e[1].dims,u=e[1].dataType,l=ot.size(s),d=ot.normalizeAxis(t.axis,a),c=n[d],p=s.slice(0),f=ot.size(p),h=$t("input",r,n),m=$t("indices",u,[l]),g=vt("output",r,p);return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:e=>`\n      const inputStrides = array<u32, ${i.length}>(${i.map((e=>`${e}u`)).join(",")});\n      ${e.declareVariables(h,m,g)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n\n      let outputIndices = ${g.offsetToIndices("global_idx")};\n\n      var idx = ${m.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${c};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${n.length}; i++) {\n        if (i == ${d}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${g.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${o}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`}},Ha=e=>rt({axis:e.axis}),La=(e,t)=>{let n=e.inputs;ja(n),e.compute(Fa(e.inputs,t))}})),Ss=P((()=>{Qo(),Jo(),Zo(),qa=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Ya=(e,t,n)=>{if(0===n.length)return"0u";let r=1===n.length&&1!==e||2===n.length&&n[0]!==e,a=n[n.length-1]!==t,i="0u";return r||(i+=`+ m * ${n[n.length-1]}u`),a||(i+="+n"),i},Ka=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[a,i,o]=ut.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),s=[a,i];if(!s)throw new Error("Can't use gemm on the given tensors");let u=ot.size(s),l="";t.transA&&t.transB?l="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?l="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?l="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(l="value += a[m * K + k] * b[k * N + n];");let d=pt(e[0].dataType),c=1===t.alpha?"":"value *= alpha;",p=3===e.length?`value += beta * c[${Ya(a,i,e[2].dims)}];`:"",f=[`@group(0) @binding(0) var<storage, read> a : array<${d}>;`,`@group(0) @binding(1) var<storage, read> b : array<${d}>;`];return 3===e.length&&f.push(`@group(0) @binding(2) var<storage, read> c : array<${d}>;`),{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:n=>`\n  const M: u32 = ${a}u;\n  const N: u32 = ${i}u;\n  const K: u32 = ${o}u;\n  const alpha = ${d}(${t.alpha});\n  const beta = ${d}(${t.beta});\n\n  ${f.join("\n")}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${d}>;\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${d}(0);\n    for (var k: u32 = 0u; k<${o}u; k++) {\n      ${l}\n    }\n\n    ${c}\n    ${p}\n    output[global_id.x] = value;\n\n  }`}},Xa=(e,t)=>{qa(e.inputs),e.compute(Ka(e.inputs,t))},Ja=e=>rt(e)})),_s=P((()=>{Lo(),Qo(),Jo(),Zo(),Qa={name:"InstanceNormalization"},Za=(e,t)=>{let n=e[0].dims,r=n,a=ot.sizeToDimension(n,2),i=ot.sizeFromDimension(n,2),o=n[1],s=$t("x",e[0].dataType,[n[0],n[1],i]),u=$t("scale",e[1].dataType,e[1].dims),l=$t("bias",e[2].dataType,e[2].dims),d=vt("output",e[0].dataType,[n[0],n[1],i]),c=[s,u,l,d],p=s.type.value;return{...Qa,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:a}}),getShaderSource:e=>`\n\n  const C: u32 = ${o};\n  const normSize: u32 = ${i};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${p};\n  var<workgroup> squaredNormShared : ${p};\n  var<workgroup> workgroupShared : array<${p}, 64>;\n  const workgroupSize = 64u;\n  ${e.declareVariables(...c)}\n  ${e.mainStart(64)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${p} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${s.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${p}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${s.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${p}(normSize) + epsilon);\n    let channelScale = invStdDev * ${u.getByOffset("channel")};\n    let channelShift = ${l.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${s.get("batch","channel","h")} * channelScale + channelShift;\n      ${d.set("batch","channel","h","value")};\n    }\n  }`}},ei=(e,t,n,r,a,i,o,s)=>{let u=ht(o),l=$t("input",t.dataType,t.dims,u),d=$t("scale",n.dataType,n.dims,u),c=$t("bias",r.dataType,r.dims,u),p=1===u?"vec2f":`mat2x${u}f`,f=1===u?"f32":`vec${u}f`,h=(e,t)=>`${p}(${e}, ${t})`,m=a*o/u,g=Math.ceil(i/64),y=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:u,n:a,h:i,c:o})},getRunData:()=>({outputs:[{dims:[a,o,64,2],dataType:1}],dispatchGroup:{x:a*o/u}}),getShaderSource:e=>`\n  const H: u32 = ${i};\n  const C: u32 = ${o/u};\n  const imageSize: u32 = ${i*o/u};\n\n  ${e.declareVariables(l)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${p}>;\n\n  ${e.mainStart(64)}\n    let currentImageNumber = global_idx / 64 / C;\n    let currentChannelNumber = (global_idx / 64) % C;\n    let wgId = global_idx % 64;\n    let wgOffset = wgId * ${g};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${g}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${mt("f32",u)};\n    var squaredSum = ${mt("f32",u)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${f}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${h("sum","squaredSum")};\n  }`},{inputs:[t],outputs:[-1]})[0];return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:u,n:a,h:i,c:o,epsilon:s})},getRunData:()=>({outputs:[{dims:[a,o,2],dataType:1}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:e=>`\n  const H: u32 = ${i};\n  const C: u32 = ${o/u};\n  const imageSize: u32 = ${64*o/u};\n  const epsilon: f32 = ${s};\n\n  @group(0) @binding(0) var<storage, read> input : array<${p}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${d.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${c.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${p}>;\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${mt("f32",u)};\n    var squaredSum = ${mt("f32",u)};\n    for (var i: u32 = 0; i < 64; i++) {\n        let value = input[offset + i + currentChannelNumber * 64];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${f}(scale[currentChannelNumber]);\n    let channelShift = ${f}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${h("channelScale","channelShift")};\n  }`},{inputs:[y,n,r],outputs:[-1]})[0]},ti=(e,t,n)=>{let r=t[0].dims,a=r,i=r[0],o=r[r.length-1],s=ot.sizeFromDimension(r,1)/o,u=ht(o),l=ot.size(a)/u,d=$t("input",t[0].dataType,t[0].dims,u),c=vt("output",t[0].dataType,a,u),p=pt(t[0].dataType),f=1===u?"vec2f":`mat2x${u}f`,h=1===u?p:`vec${u}<${p}>`,m=ei(e,t[0],t[1],t[2],i,s,o,n.epsilon);e.compute({name:"InstanceNormalization",shaderCache:{hint:`${n.cacheKey}`},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:e=>`\n  const H: u32 = ${s};\n  const C: u32 = ${o/u};\n\n  @group(0) @binding(0) var<storage, read> input : array<${d.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${f}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${c.type.storage}>;\n\n  ${e.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${h}(scale[0]), ${h}(scale[1]));\n  }`},{inputs:[t[0],m]})},ni=e=>rt({epsilon:e.epsilon,format:e.format}),ri=(e,t)=>{"NHWC"===t.format?ti(e,e.inputs,t):e.compute(Za(e.inputs,t))}})),Cs=P((()=>{Lo(),Qo(),Jo(),Zo(),ai=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ii=(e,t,n)=>{let r=e[0].dims,a=e[1],i=e[2],o=r,s=ot.normalizeAxis(t.axis,r.length),u=ot.sizeToDimension(r,s),l=ot.sizeFromDimension(r,s),d=ot.size(a.dims),c=i?ot.size(i.dims):0;if(d!==l||i&&c!==l)throw new Error(`Size of X.shape()[axis:] == ${l}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${d} and bias size of ${c}`);let p=[];for(let e=0;e<r.length;++e)e<s?p.push(r[e]):p.push(1);let f=ht(l),h=pt(e[0].dataType),m=[$t("x",e[0].dataType,e[0].dims,f),$t("scale",a.dataType,a.dims,f)];i&&m.push($t("bias",i.dataType,i.dims,f)),m.push(vt("output",e[0].dataType,o,f));let g=n>1,y=n>2;g&&m.push(vt("meanDataOutput",1,p)),y&&m.push(vt("invStdOutput",1,p));let w=[{dims:o,dataType:e[0].dataType}];return g&&w.push({dims:p,dataType:1}),y&&w.push({dims:p,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${n}|${e.length}`},getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:e=>`\n  const normSize: f32 = ${l};\n  const normSizeVectorized: u32 = ${l/f};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${e.declareVariables(...m)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${mt("f32",f)};\n    var meanSquareVector = ${mt("f32",f)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${gt(h,f,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${yt("meanVector",f)} / normSize;\n    let meanSquare = sqrt(${yt("meanSquareVector",f)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${gt(h,f,"x[j + offset]")};\n      let f32scale = ${gt(h,f,"scale[j]")};\n      output[j + offset] = ${m[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${i?`+ ${gt(h,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${g?"meanDataOutput[global_idx] = mean":""};\n    ${y?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`}},oi=e=>rt({axis:e.axis,epsilon:e.epsilon}),si=(e,t)=>{ai(e.inputs),e.compute(ii(e.inputs,t,e.outputCount))}})),Es=P((()=>{Qo(),ps(),ui=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},li=e=>{ui(e.inputs);let t=it.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(Zr(e.inputs,{activation:"",activationCacheKey:""},t))}})),Is=P((()=>{Lo(),Qo(),Jo(),Zo(),di=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType)throw new Error("Input type must be float.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},ci=(e,t,n,r,a,i,o)=>{let s="";for(let t=n.length-1;t>=0;--t)s+=`\n            k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${n[t]}) {\n              break;\n            }\n            offset += k * ${r[t]};\n        `;return`\n          value = ${i}(${o});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${s}\n            value = x[offset];\n          }\n      `},pi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(n[t]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${n[t]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},fi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${n[t]}) {\n                  k = ${n[t]-1};\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},hi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0)  {\n                  k += ${n[t]};\n                }\n                if (k >= ${n[t]}) {\n                  k -= ${n[t]};\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},mi=(e,t,n,r,a,i)=>{switch(a.mode){case 0:return ci(e,0,n,r,a.pads,i,a.value);case 1:return pi(e,0,n,r,a.pads);case 2:return fi(e,0,n,r,a.pads);case 3:return hi(e,0,n,r,a.pads);default:throw new Error("Invalid mode")}},gi=(e,t,n,r)=>{let a=t[0].dims,i=ot.padShape(a.slice(),n.pads),o=ot.size(i),s=ot.computeStrides(a),u=vt("output",t[0].dataType,i),l=$t("x",t[0].dataType,a),d=mi(u,0,a,s,n,r);return`\n              ${e.declareVariables(l,u)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n              let indices = ${u.offsetToIndices("global_idx")};\n\n              var value = ${r}(0);\n              ${d}\n              output[global_idx] = value;\n          }`},yi=(e,t)=>{let n=ot.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ot.size(n)/64)}}),getShaderSource:n=>gi(n,e,t,"f32")}},wi=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,i=new Int32Array(2*a).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)i[Number(t[e])]=Number(n[e]),i[Number(t[e])+a]=Number(n[e+t.length])}else n.forEach(((e,t)=>i[Number(t)]=Number(e)));let o=[];return i.forEach((e=>o.push(e))),rt({mode:t.mode,value:r,pads:o})}return t},$i=(e,t)=>{di(e.inputs);let n=wi(e.inputs,t);e.compute(yi(e.inputs,n),{inputs:[0]})},vi=e=>{let t=e.mode,n=e.value,r=e.pads;return rt({mode:t,value:n,pads:r})}})),As=P((()=>{Qo(),Jo(),Zo(),bi=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},xi=(e,t,n)=>{let r="NHWC"===t.format,a=e.dims.slice();r&&a.splice(1,0,a.pop());let i=Object.hasOwnProperty.call(t,"dilations"),o=t.kernelShape.slice(),s=t.strides.slice(),u=i?t.dilations.slice():[],l=t.pads.slice();st.adjustPoolAttributes(n,a,o,s,u,l);let d=st.computePoolOutputShape(n,a,s,u,o,l,t.autoPad),c=Object.assign({},t);i?Object.assign(c,{kernelShape:o,strides:s,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:o,strides:s,pads:l,cacheKey:t.cacheKey});let p=d.slice();return p.push(p.splice(1,1)[0]),[c,r?p:d]},Si=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===a.format,l=n,d=t.type.value,c=l.length,p=ot.size(r),f=vt("output",t.type.tensor,r);if(a.kernelShape.length<=2){let n=a.kernelShape[a.kernelShape.length-1],r=a.strides[a.strides.length-1],h=a.pads[a.pads.length/2-1],m=c-(u?2:1),g="",y="",w="";if(g=h+a.pads[a.pads.length-1]!==0?`\n                for (var i: u32 = 0u; i < ${n}u; i++) {\n                  xIndices[${m}] = indices[${m}] * ${r} - ${h} + i;\n                  if (xIndices[${m}] < 0 || xIndices[${m}] >= ${l[m]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`:`\n                for (var i: u32 = 0u; i < ${n}u; i++) {\n                  xIndices[${m}] = indices[${m}] * ${r} - ${h} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`,2===a.kernelShape.length){let e=a.kernelShape[a.kernelShape.length-2],t=a.strides[a.strides.length-2],r=a.pads[a.pads.length/2-2],i=a.pads[a.pads.length-2],o=c-(u?3:2),s=l[o];y=r+i!==0?`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\n                  if (xIndices[${o}] < 0 || xIndices[${o}] >= ${s}) {\n                    pad+= ${n};\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\n                `,w="\n              }\n            "}return`\n            ${e.declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var value: ${d} = ${d}(${s});\n              var pad = 0;\n              ${y}\n              ${g}\n              ${w}\n              ${o}\n\n              output[global_idx] = value;\n            }`}{if(u)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let n=ot.size(a.kernelShape),r=ot.computeStrides(a.kernelShape),d=r.length,h=a.pads.length,m="";return m=a.pads.reduce(((e,t)=>e+t))?`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${i}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${i}\n            `,`\n            ${e.declareVariables(t,f)}\n\n            const pads = array<u32, ${h}>(${a.pads.map((e=>`${e}u`)).join(",")});\n            const inputDims = array<u32, ${c}>(${l.map((e=>`${e}u`)).join(",")});\n            const kernelStrides = array<u32, ${d}>(${r.map((e=>`${e}u`)).join(",")});\n            const strides = array<u32, ${d}>(${a.strides.map((e=>`${e}u`)).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              let xIndices = ${f.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${d}>;\n\n              var value = ${f.type.value}(${s});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${d-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${d-1}] = offset;\n\n                isPad = false;\n                for (var j = ${c-d}u; j < ${c}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${c-d}u]\n                    + offsets[j - ${c-d}u] - pads[j - 2u];\n                  ${m}\n              }\n              ${o}\n\n              output[global_idx] = value;\n            }`}},_i=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ci=(e,t,n,r)=>{let[a,i]=xi(t,r,n),o=ot.size(a.kernelShape),s=$t("x",t.dataType,t.dims),u=s.type.value,l="";return a.countIncludePad?l+=`value /= ${u}(${o});`:l+=`value /= ${u}(${o} - pad);`,{name:e,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ot.size(i)/64)}}),getShaderSource:e=>Si(e,s,t.dims,i,a,"value += x_val;",l,"0.0")}},Ei=e=>{let t=0!==e.count_include_pad,n=_i(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return rt({countIncludePad:t,...n})},Ii=(e,t)=>{bi(e.inputs),e.compute(Ci("AveragePool",e.inputs[0],!1,t))},Ai={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Oi=e=>{let t=e.format;return{format:t,...Ai,cacheKey:t}},Ti=(e,t)=>{bi(e.inputs),e.compute(Ci("GlobalAveragePool",e.inputs[0],!0,t))},Ri=(e,t,n,r)=>{let[a,i]=xi(t,r,n),o=$t("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ot.size(i)/64)}}),getShaderSource:e=>Si(e,o,t.dims,i,a,"\n      value = max(x_val, value);\n    ","","-1e5")}},ki=(e,t)=>{bi(e.inputs),e.compute(Ri("MaxPool",e.inputs[0],!1,t))},Bi=e=>{let t=e.storage_order,n=e.dilations,r=_i(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return rt({storageOrder:t,dilations:n,...r})},Mi=e=>{let t=e.format;return{format:t,...Ai,cacheKey:t}},Di=(e,t)=>{bi(e.inputs),e.compute(Ri("GlobalMaxPool",e.inputs[0],!0,t))}})),Os=P((()=>{re(),Lo(),Zo(),Pi=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},zi=(e,t,n,r)=>{let a=Math.abs(Math.ceil((t-e)/n)),i=[a],o=a,s=vt("output",r,i),u=s.type.storage;return{name:"Range",shaderCache:{hint:[e,t,n].map((e=>e.toString())).join("_")},getShaderSource:t=>`\n        ${t.declareVariables(s)}\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n        output[global_idx] = ${u}(${e}) + ${u}(global_idx) * ${u}(${n});\n      }`,getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)}})}},Wi=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),c.webgpu.validateInputContent&&Pi(t,n,r),e.compute(zi(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),Ts=P((()=>{Qo(),Jo(),Zo(),Ni=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},Gi=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},Ui=(e,t,n,r,a,i)=>{let[o,s,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(s>0&&e.length>s&&e[s].dims.length>0){if(e[s].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ni(r,t),t.axes.length>0&&Gi(r,t.axes,l).forEach(((e,t)=>r[t]=e))}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach((e=>a.push(Number(e)))),a.length!==l||n>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof a<"u"&&r.length>0&&a.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},Vi=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join("\n");case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",ji=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Fi=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),a=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=a[i],r[i+n]=a[t.length+i]})),r):a},Hi=(e,t,n,r)=>{let a=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>a.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>a[e]=n[t]))}else n.forEach((e=>a.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");a=e.map(((e,n)=>Math.round(e*t[n])))}return a},Li=(e,t,n,r)=>{let a=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map((e=>n[e])),Number.MAX_VALUE):Math.min(...n,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map((e=>n[e])),Number.MIN_VALUE):Math.max(...n,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();n.fill(1,0,n.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach((e=>n[e]=a)),r.axes.forEach((t=>i[t]=Math.round(e[t]*n[t])))):(n.fill(a,0,n.length),i.forEach(((e,t)=>i[t]=Math.round(e*n[t])))),i},qi=(e,t,n,r,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${n.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\n      const outputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n      const scales = array<f32, ${r.length}>(${r.map((e=>`${e}f`)).join(",")});\n      const roi = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\n      var originalIndices: array<f32, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var outputIndex = ${1===n.length?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Yi=(e,t,n,r,a,i,o)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n        const outputShape = array<u32, ${r.length}>(${r.map((e=>`${e}u`)).join(",")});\n        const scales = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\n        const roi = array<f32, ${i.length}>(${i.map((e=>`${e}f`)).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${r.length}; i++) {\n          var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${n.length}]);\n            if (!${o} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,Ki=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${1===t.length?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Xi=(e,t,n,r,a,i,o)=>{let[s,u,l,d]=2===n.length?[-1,0,1,-1]:1===a[1]?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${u}] = max(0, min(row, ${n[u]} - 1));\n      inputIndices[${l}] = max(0, min(col, ${n[l]} - 1));\n      if (${n.length} > 2) {\n        inputIndices[${d}] = channel;\n        inputIndices[${s}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${u}];\n      var col:f32 = originalIndices[${l}];\n      if (${i} && (row < 0 || row > (${n[u]} - 1) || col < 0 || col > ${n[l]} - 1)) {\n        return ${o};\n      }\n      row = max(0, min(row, ${n[u]} - 1));\n      col = max(0, min(col, ${n[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${n.length>2}) {\n        channel = u32(originalIndices[${d}]);\n        batch = u32(originalIndices[${s}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Ji=(e,t,n,r,a,i,o,s,u,l)=>{let[d,c]=2===n.length?[0,1]:1===a[1]?[2,3]:[1,2],p=o=>{let c=o===d?"row":"col";return`\n      fn ${c}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${1===r.length?"outputIndices":`outputIndices[${o}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[o]},\n        f32(${r[o]}), f32(${n[o]}), ${i[o]}, ${i[o]} + ${n.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${s} && (originalIdx < 0 || originalIdx > (${n[o]} - 1))) {\n          return ${u};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${c}: f32 = originalIdx + f32(i);\n          if (${c} < 0 || ${c} >= ${n[o]}) {\n            if (${l}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${s}) {\n              return ${u};\n            } else {\n              ${c} = max(0, min(${c}, ${n[o]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${o}] = u32(${c});\n          data[i + 1] = ${o===d?`input[${e.indicesToOffset("inputIndicesCopy")}];`:"\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);"}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${p(d)};\n    ${p(c)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};\n    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Qi=(e,t,n,r,a,i)=>{let o=e.dims,s=Fi(i,t.axes,o.length),u=Hi(o,r,a,t.axes),l=r.slice();0===r.length&&(l=o.map(((e,t)=>0===e?1:u[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(u=Li(o,0,l,t)));let d=vt("output",e.dataType,u),c=$t("input",e.dataType,o),p=ot.size(u),f=o.length===u.length&&o.every(((e,t)=>e===u[t])),h="tf_crop_and_resize"===t.coordinateTransformMode;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${l.length>0?l:""}|${a.length>0?a:""}`},getShaderSource:e=>`\n      ${Vi(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Ki(c,o)};\n              ${ji(t.nearestMode,n)};\n              ${Yi(c,d,o,u,l,s,h)};\n              `;case"linear":return`\n              ${qi(d,o,u,l,s)};\n              ${Xi(c,d,o,0,l,h,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Ji(c,d,o,u,l,s,t.cubicCoeffA,h,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${e.declareVariables(c,d)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n        if (${f}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${d.offsetToIndices("global_idx")};\n          var inputIndices: ${c.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${c.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)}})}},Zi=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},eo=(e,t)=>{let n=[],r=[],a=[],i=Zi(e);Ui(e.inputs,t,i,n,r,a),e.compute(Qi(e.inputs[0],t,i,n,r,a),{inputs:[0]})},to=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,a=e.cubicCoeffA,i=0!==e.excludeOutside,o=e.extrapolationValue,s=e.keepAspectRatioPolicy,u=e.mode,l=""===e.nearestMode?"simple":e.nearestMode;return rt({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:a,excludeOutside:i,extrapolationValue:o,keepAspectRatioPolicy:s,mode:u,nearestMode:l})}})),Rs=P((()=>{Lo(),Qo(),Jo(),Zo(),no=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},ro=(e,t,n,r)=>{let a=e[0].dims,i=a,o=ot.size(a),s=a.slice(-1)[0],u=r?a.slice(0,-1).concat(1):[],l=e.length>3,d=e.length>4,c=r&&n>1,p=r&&n>2,f=n>3,h=ht(s),m=[$t("x",e[0].dataType,e[0].dims,h),$t("skip",e[1].dataType,e[1].dims,h),$t("gamma",e[2].dataType,e[2].dims,h)];l&&m.push($t("beta",e[3].dataType,e[3].dims,h)),d&&m.push($t("bias",e[4].dataType,e[4].dims,h)),m.push(vt("output",e[0].dataType,i,h)),c&&m.push(vt("meanOutput",1,u)),p&&m.push(vt("invStdOutput",1,u)),f&&m.push(vt("inputSkipBiasSum",e[0].dataType,i,h));let g=pt(e[0].dataType),y=[{dims:i,dataType:e[0].dataType}];return n>1&&y.push({dims:u,dataType:1}),n>2&&y.push({dims:u,dataType:1}),n>3&&y.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:e=>`\n      const hiddenSize: f32 = ${s};\n      const hiddenSizeVectorized: u32 = ${s/h};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${e.declareVariables(...m)}\n\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(o/s)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${mt("f32",h)};\n        var squareSum = ${mt("f32",h)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${d?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${f?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${gt(g,h,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${yt("sum",h)} / hiddenSize;\n        let variance = sqrt(${yt("squareSum",h)} / hiddenSize - mean * mean + epsilon);\n        ${c?"meanOutput[global_idx] = mean;":""}\n        ${p?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${g}(mean)) / ${g}(variance) * gamma[i]\n           + ${l?"beta[i]":"0.0"};\n        }\n      }`,getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(o/s/64)}})}},ao=(e,t)=>{no(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(ro(e.inputs,t,e.outputCount,!1),{outputs:n})},io=e=>{let t=e.epsilon;return rt({epsilon:t})}})),ks=P((()=>{Lo(),Qo(),Jo(),Zo(),oo=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},so=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},uo=(e,t)=>{if(e.length>1){let t=so(e,1),n=so(e,2),r=so(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),rt({starts:t,ends:n,axes:r})}return t},lo=(e,t,n,r,a)=>{let i=e;return e<0&&(i+=n[r[t]]),a[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},co=(e,t,n,r)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${1===n.length?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,po=(e,t)=>{let n=e[0].dims,r=ot.size(n),a=t.axes.length>0?ot.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=so(e,4);i.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===i.length&&(i=Array(a.length).fill(1));let o=t.starts.map(((e,t)=>lo(e,t,n,a,i))),s=t.ends.map(((e,t)=>lo(e,t,n,a,i)));if(a.length!==n.length)for(let e=0;e<n.length;++e)a.includes(e)||(o.splice(e,0,0),s.splice(e,0,n[e]),i.splice(e,0,1));let u=i.map((e=>Math.sign(e)));i.forEach(((e,t,n)=>{if(e<0){let r=(s[t]-o[t])/e,a=o[t],u=a+r*i[t];o[t]=u,s[t]=a,n[t]=-e}}));let l=n.slice(0);a.forEach(((e,t)=>{l[e]=Math.ceil((s[e]-o[e])/i[e])}));let d={dims:l,dataType:e[0].dataType},c=vt("output",e[0].dataType,l),p=$t("input",e[0].dataType,n),f=ot.size(l);return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:e=>`\n      ${e.declareVariables(p,c)}\n        const signs = array<i32, ${u.length}>(${u.map((e=>`${e}i`)).join(",")});\n        const starts = array<u32, ${o.length}>(${o.map((e=>`${e}u`)).join(",")});\n        const ends = array<u32, ${s.length}>(${s.map((e=>`${e}u`)).join(",")});\n        const steps = array<u32, ${i.length}>(${i.map((e=>`${e}u`)).join(",")});\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n\n        ${co(p,c,n,l)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n          let outputIndices = ${c.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${c.setByOffset("global_idx",p.getByIndices("inputIndices"))}\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)}})}},fo=(e,t)=>{oo(e.inputs,t);let n=uo(e.inputs,t);e.compute(po(e.inputs,n),{inputs:[0]})},ho=e=>{let t=e.starts,n=e.ends,r=e.axes;return rt({starts:t,ends:n,axes:r})}})),Bs=P((()=>{Qo(),Jo(),Zo(),mo=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},go=(e,t)=>{let n=pt(e.dataType),r=e.dims,a=ot.size(r),i=t.axis;if(i<0&&(i=r.length+i),i<r.length-1)throw new Error("softmax only supports last axis for now.");let o=r[i],s=a/o,u=ht(o),l=o/u,d=1===u?n:`vec${u}<${n}>`,c="f32"===n?`var threadMax = ${d}(-3.402823e+38f);`:`var threadMax = ${d}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:s}}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${d};\n      var<workgroup> rowSumShared : ${d};\n      var<workgroup> threadShared : array<${d}, 64>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${d}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${d}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${d} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${d}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(64, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = 64;\n        let row = gindex / wg;\n        let cols = ${l};\n        let row_stride : i32 = ${l};\n\n        // find the rows max\n        ${c}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${d}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",u)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${d}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${d}(${yt("threadShared[0]",u)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},yo=(e,t)=>{mo(e.inputs),e.compute(go(e.inputs[0],t))},wo=e=>rt({axis:e.axis})})),Ms=P((()=>{Qo(),Jo(),Zo(),$o=e=>{if(!e||e.length<1)throw new Error("too few inputs")},vo=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),rt({numOutputs:r,axis:t.axis,splitSizes:n})},bo=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,xo=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let a=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(a):0===r?n.push(`if (outputNumber == ${r}u) { ${a} }`):r===t-1?n.push(`else { ${a} }`):n.push(`else if (outputNumber == ${r}) { ${a} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},So=(e,t)=>{let n=e[0].dims,r=ot.size(n),a=e[0].dataType,i=n.length,o=t.axis,s=o<0?n.length+o:o,u=new Array(t.numOutputs),l=$t("input",a,n),d=new Array(t.numOutputs),c=[],p=[],f=0;for(let r=0;r<t.numOutputs;r++){f+=t.splitSizes[r],d[r]=f;let i=n.slice();i[t.axis]=t.splitSizes[r],p.push(i),u[r]=vt(`output${r}`,a,p[r]),c.push({dims:p[r],dataType:e[0].dataType})}let h=i<2?"indices":`indices[${s}]`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:e=>`\n  ${e.declareVariables(l,...u)}\n  const sizeInConcatAxis = array<u32, ${d.length}>(${d.map((e=>`${e}u`)).join(",")});\n  ${bo(d.length)}\n  ${xo(u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n\n    var indices = ${l.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${h});\n    if (outputNumber != 0) {\n        ${h} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`,getRunData:()=>({outputs:c,dispatchGroup:{x:Math.ceil(r/64)}})}},_o=(e,t)=>{$o(e.inputs);let n=1===e.inputs.length?t:vo(e.inputs,t);e.compute(So(e.inputs,n),{inputs:[0]})},Co=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return rt({axis:t,numOutputs:r,splitSizes:n})}})),Ds=P((()=>{Lo(),Qo(),Zo(),Eo=e=>Array.from(e.getBigInt64Array(),Number),Io=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Eo(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Ao=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Oo=e=>{let t=e[0].dims,n=Eo(e[1]),r=Ao(t,n),a=ot.size(r),i=e[0].dataType,o=$t("input",i,t),s=vt("output",i,r);return{name:"Tile",shaderCache:{hint:`${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:e=>`\n      const inputShape = ${o.indices(...t)};\n      ${e.declareVariables(o,s)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n      let outputIndices = ${s.offsetToIndices("global_idx")};\n      var inputIndices: ${o.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${s.indicesGet("outputIndices","i")}  % ${o.indicesGet("inputShape","i")};\n\n        ${o.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${s.setByOffset("global_idx",o.getByIndices("inputIndices"))}\n    }`}},To=e=>{Io(e.inputs),e.compute(Oo(e.inputs),{inputs:[0]})}})),Ps=P((()=>{Lo(),Qo(),Zo(),Ro=(e,t,n,r,a)=>{let i,o=ot.size(n),s=Math.ceil(o/4),u=vt("outputData",a,n,4),l=$t("aData",t[1].dataType,t[1].dims,4),d=$t("bData",t[2].dataType,t[2].dims,4),c=$t("cData",t[0].dataType,t[0].dims,4),p=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`,i=`bool(cData[indexC${t}] & ${4278190080>>>8*(3-t)}u)`;return`\n            let outputIndices${t} = ${u.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${l.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let offsetB${t} = ${d.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let offsetC${t} = ${c.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let indexC${t} = offsetC${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${p(r,a,i)});\n          `};i=9===a?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}else i=u.setByOffset("global_idx",p(l.getByOffset("global_idx"),d.getByOffset("global_idx"),c.getByOffset("global_idx")));return`\n        ${e.declareVariables(c,l,d,u)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        ${i}\n      }`},ko=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,a=e[1].dataType,i=!(ot.areEqual(t,n)&&ot.areEqual(n,r)),o=t,s=ot.size(t);if(i){let e=it.calcShape(it.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can't perform where op on the given tensors");o=e,s=ot.size(o)}return{name:"Where",getShaderSource:t=>Ro(t,e,o,i,a),getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:Math.ceil(s/64/4)}})}},Bo=e=>{e.compute(ko(e.inputs))}})),zs=P((()=>{rs(),as(),os(),ss(),us(),ms(),ws(),$s(),vs(),bs(),xs(),Ss(),_s(),Cs(),Es(),Is(),As(),Os(),ns(),Ts(),Rs(),ks(),Bs(),Ms(),Ds(),es(),is(),Ps(),Mo=new Map([["Abs",[zn]],["Acos",[Wn]],["Acosh",[Nn]],["Add",[_r]],["ArgMax",[Tn,Rn]],["ArgMin",[On,Rn]],["Asin",[Gn]],["Asinh",[Un]],["Atan",[Vn]],["Atanh",[jn]],["AveragePool",[Ii,Ei]],["BiasAdd",[Mn]],["BiasSplitGelu",[vr]],["Cast",[Hn,Fn]],["Ceil",[Kn]],["ClipV10",[Ln]],["Clip",[Yn]],["Concat",[Wr,Nr]],["Conv",[da,sa]],["ConvTranspose",[_a,$a]],["Cos",[Xn]],["Cosh",[Jn]],["Div",[Cr]],["Einsum",[ka,Ba]],["Elu",[Zn,Qn]],["Equal",[Er]],["Erf",[tr]],["Exp",[nr]],["Expand",[Wa]],["Floor",[rr]],["FusedConv",[da,sa]],["Gather",[Va,Ua]],["GatherElements",[La,Ha]],["Gelu",[ar]],["Gemm",[Xa,Ja]],["GlobalAveragePool",[Ti,Oi]],["GlobalMaxPool",[Di,Mi]],["Greater",[Tr]],["GreaterOrEqual",[kr]],["InstanceNormalization",[ri,ni]],["LayerNormalization",[si,oi]],["LeakyRelu",[ir,Qn]],["Less",[Rr]],["LessOrEqual",[Br]],["Log",[yr]],["MatMul",[li]],["MaxPool",[ki,Bi]],["Mul",[Ir]],["Neg",[sr]],["Not",[or]],["Pad",[$i,vi]],["Pow",[Ar]],["Range",[Wi]],["Reciprocal",[ur]],["ReduceMin",[bn,En]],["ReduceMean",[gn,En]],["ReduceMax",[vn,En]],["ReduceSum",[Sn,En]],["ReduceProd",[xn,En]],["ReduceL1",[yn,En]],["ReduceL2",[wn,En]],["ReduceLogSum",[Cn,En]],["ReduceLogSumExp",[$n,En]],["ReduceSumSquare",[_n,En]],["Relu",[lr]],["Resize",[eo,to]],["Sigmoid",[dr]],["Sin",[cr]],["Sinh",[pr]],["Slice",[fo,ho]],["SkipLayerNormalization",[ao,io]],["Split",[_o,Co]],["Sqrt",[fr]],["Softmax",[yo,wo]],["Sub",[Or]],["Tan",[hr]],["Tanh",[mr]],["ThresholdedRelu",[gr,Qn]],["Tile",[To]],["Transpose",[Tt,Rt]],["Where",[Bo]]])})),Ws=P((()=>{Lo(),qo(),Zo(),Do=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,a,i,o){let s=this.backend.device,u=this.backend.getComputePassEncoder();u.setPipeline(e.computePipeline);let l=[];for(let e of r)l.push({binding:l.length,resource:{buffer:e.buffer}});for(let e of a)l.push({binding:l.length,resource:{buffer:e.buffer}});o&&l.push({binding:l.length,resource:o});let d=s.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:l,label:e.programInfo.name});if(u.setBindGroup(0,d),u.dispatchWorkgroups(...i),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(8*this.backend.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let e=this.backend.gpuDataManager.create(8*this.backend.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,e.buffer,0,8*this.backend.querySetCount),this.backend.flush();let r=this.backend.currentKernelId,a=this.backend.kernels.get(r),i=`[${a[0]}] ${a[1]}`;e.buffer.mapAsync(GPUMapMode.READ).then((()=>{let a=new BigUint64Array(e.buffer.getMappedRange()),o=a[0],s=a[1];e.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=o);let u=Number(o-this.backend.queryTimeBase),l=Number(s-this.backend.queryTimeBase);if(!Number.isSafeInteger(u)||!Number.isSafeInteger(l))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id);let d="";t.forEach(((e,t)=>{d+=`input[${t}]: [${e.dims}] | ${Pe(e.dataType)}, `}));let c="";n.forEach(((e,t)=>{c+=`output[${t}]: [${e.dims}] | ${Pe(e.dataType)}, `})),console.log(`[profiling] kernel "${r}|${i}" ${d}${c}execution time: ${l-u} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){let n=this.backend.device,r=[];n.features.has("shader-f16")&&r.push("enable f16;");let a=xt(t),i=e.getShaderSource(a),o=`${r.join("\n")}\n${a.additionalImplementations}\n${i}`,s=n.createShaderModule({code:o,label:e.name});return Ye("verbose",(()=>`[WebGPU] shader code: ${o}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:s,entryPoint:"main"},layout:"auto",label:e.name})}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&n<=a&&r<=a)return[t,n,r];let i=t*n*r,o=Math.ceil(Math.sqrt(i));if(o>a){if(o=Math.ceil(Math.cbrt(i)),o>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}return[o,o,1]}}})),Ns=P((()=>{qo(),Yo(),Xo(),zs(),Ws(),Po=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let a=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${a}`);break;case"rank":{let t=e[r].dims.length;n.push(`${a};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${a};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},zo=(e,t)=>{let n=e.name;return e.shaderCache?.hint&&(n+="["+e.shaderCache.hint+"]"),n+=`:${Po(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,n},Wo=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.querySetCount=2,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n};t.features.has("timestamp-query")&&n.push("timestamp-query"),t.features.has("shader-f16")&&n.push("shader-f16"),this.device=await t.requestDevice(r),this.gpuDataManager=tt(this),this.programManager=new Do(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Le(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!(!this.device.features.has("timestamp-query")||"default"!==this.env.webgpu.profilingMode)}run(e,t,n,r,a){let i=[];for(let e=0;e<t.length;++e){let n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);i[e]=n}let o=zo(e,t),s=this.programManager.getArtifact(o),{outputs:u,dispatchGroup:l,programUniforms:d}=e.getRunData(t),c=0===n.length?u.map(((e,t)=>t)):n;if(c.length!==u.length)throw new Error(`Output size ${c.length} must be equal to ${u.length}.`);let p,f=[],h=[];for(let e=0;e<u.length;++e){if(!Number.isInteger(c[e])||c[e]<-3||c[e]>=u.length)throw new Error(`Invalid output index: ${c[e]}`);if(-3===c[e])continue;let t=-1===c[e],n=-2===c[e],i=t||n?a(u[e].dataType,u[e].dims):r(c[e],u[e].dataType,u[e].dims),o=this.gpuDataManager.get(i.data);if(!o)throw new Error(`no GPU data for output: ${i.data}`);if(t&&this.temporaryData.push(o),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(o)}f.push(i),h.push(o)}if(d){let e=0,t=0,n=[],r=1;d.forEach((a=>{let i,o="number"==typeof a.data?[a.data]:a.data;switch(o.length){case 1:i=4;break;case 2:i=8;break;case 3:case 4:case 5:case 6:i=16;break;default:throw new Error(`unsupported data length: ${o.length}`)}(5===t||6===t)&&(i=16),i>r&&(r=i),e=Math.ceil(e/i)*i,t=o.length,n.push(e),e+=4*o.length})),e=Math.ceil(e/r)*r;let a=new ArrayBuffer(e);d.forEach(((e,t)=>{let r=n[t],i="number"==typeof e.data?[e.data]:e.data;"int32"===e.type?new Int32Array(a,r,i.length).set(i):"uint32"===e.type?new Uint32Array(a,r,i.length).set(i):new Float32Array(a,r,i.length).set(i)}));let i=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(i.buffer,0,a,0,e),this.gpuDataManager.release(i.id),p={offset:0,size:e,buffer:i.buffer}}let m=this.programManager.normalizeDispatchGroupSize(l);return s||(s=this.programManager.build(e,m),this.programManager.setArtifact(o,s)),Ye("info",(()=>`[ProgramManager] run "${e.name}" (key=${o}) with ${m[0]}x${m[1]}x${m[2]}`)),this.programManager.run(s,t,f,i,h,m,p),f}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let a=Mo.get(e);if(!a)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r,a[0],[a[1],n]])}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let[a,i,o,s]=r;if(null!==this.currentKernelId)throw new Error(`kernel "[${a}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,s[0]&&(s[1]=s[0](s[1]),s[0]=void 0),Ye("info",(()=>`[WebGPU] Start to run kernel "[${a}] ${i}"...`));let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),o(t,s[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${i}" failed. ${e}`)),1}finally{u&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${a}] ${i}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let a=this.sessionExternalDataMapping.get(e);a||(a=new Map,this.sessionExternalDataMapping.set(e,a));let i=a.get(t),o=this.gpuDataManager.registerExternalBuffer(n,r,i?.[1]);return a.set(t,[o,n]),o}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[1]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await Ze(this,e,t);return Ke(r.buffer,n)}}}})),Gs={};W(Gs,{init:()=>js});var Us,Vs,js,Fs,Hs,Ls,qs,Ys,Ks,Xs,Js,Qs,Zs,eu,tu,nu,ru,au,iu,ou,su,uu,lu,du,cu,pu,fu,hu,mu,gu,yu,wu,$u,vu,bu,xu,Su,_u,Cu,Eu,Iu,Au,Ou,Tu,Ru,ku,Bu,Mu,Du,Pu=P((()=>{Lo(),Ns(),qo(),Qo(),Us=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(ot.size(t)!==ot.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Vs=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0;let r=e.HEAPU32,a=n>>2;this.opKernelContext=r[a++];let i=r[a++];this.outputCount=r[a++],this.customDataOffset=r[a++],this.customDataSize=r[a++];let o=[];for(let t=0;t<i;t++){let t=r[a++],n=r[a++],i=r[a++],s=[];for(let e=0;e<i;e++)s.push(r[a++]);o.push(new Us(e,t,n,s))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new Us(this.module,t,this.output(e,n),n)),((e,t)=>{let n=ze(e);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n*ot.size(t);return new Us(this.module,e,this.backend.gpuDataManager.create(r).id,t)}))}output(e,t){let n=this.module.stackSave();try{let n=this.module.stackAlloc(4*(1+t.length)),r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},js=async(e,t)=>{let n=e.jsepInit;if(n&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let r=new Wo;await r.initialize(t),n(r,(e=>r.alloc(e)),(e=>r.free(e)),((t,n,a,i=!1)=>{if(i)Ye("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${a}`)),r.memcpy(t,n);else{Ye("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${a}`));let i=e.HEAPU8.subarray(t,t+a);r.upload(n,i)}}),(async(t,n,a)=>{Ye("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${a}`)),await r.download(t,(()=>e.HEAPU8.subarray(n,n+a)))}),((n,a,i)=>r.createKernel(n,a,i,t.debug||"default"===t.webgpu.profilingMode?e.UTF8ToString(e._JsepGetNodeName(a)):`${a}`)),(e=>r.releaseKernel(e)),((t,n,a,i)=>{Ye("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${a}, kernel=${t}, contextDataOffset=${n}`));let o=new Vs(e,r,n);return r.computeKernel(t,o,i)}))}}})),zu=P((()=>{Fo(),Ho(),Lo(),Vo(),jo(),Fs=!1,Hs=e=>{let t=Ce(),n=t.stackSave();try{let n=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,n,n+4)&&Ae("Can't get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(n)}},Ls=(e,t)=>{0!==Ce()._OrtInit(e,t)&&Ae("Can't initialize onnxruntime.")},qs=async e=>{Ls(e.wasm.numThreads,Ne(e.logLevel));{let t=(Pu(),N(Gs)).init;await t(Ce(),e)}Fs=!0},Ys=new Map,Ks=()=>Fs,Xs=e=>{let t=Ce(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Js=(e,t)=>{let n=Ce(),r=0,a=0,i=0,o=[],s=[],u=[];try{[a,o]=Me(t),r=n._OrtCreateSession(e[0],e[1],a),0===r&&Ae("Can't create a session.");let[l,d]=Hs(r),c=[],p=[],f=[];for(let e=0;e<l;e++){let t=n._OrtGetInputName(r,e);0===t&&Ae("Can't get an input name."),s.push(t),c.push(n.UTF8ToString(t))}for(let e=0;e<d;e++){let a=n._OrtGetOutputName(r,e);0===a&&Ae("Can't get an output name."),u.push(a);let i=n.UTF8ToString(a);p.push(i);{let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[i]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}.`);f.push(e)}}let h=null;return f.some((e=>"gpu-buffer"===e))&&(i=n._OrtCreateBinding(r),0===i&&Ae("Can't create IO binding."),h={handle:i,outputPreferredLocations:f,outputPreferredLocationsEncoded:f.map((e=>Ue(e)))}),Ys.set(r,[r,s,u,h]),[r,c,p]}catch(e){throw s.forEach((e=>n._OrtFree(e))),u.forEach((e=>n._OrtFree(e))),0!==i&&n._OrtReleaseBinding(i),0!==r&&n._OrtReleaseSession(r),e}finally{n._free(e[0]),0!==a&&n._OrtReleaseSessionOptions(a),o.forEach((e=>n._free(e)))}},Qs=(e,t)=>{let n=Xs(e);return Js(n,t)},Zs=e=>{let t=Ce(),n=Ys.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,a,i,o]=n;o&&t._OrtReleaseBinding(o.handle),t.jsepUnregisterBuffers?.(e),a.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(r),Ys.delete(e)},eu=(e,t,n,r,a)=>{if(!e)return void t.push(0);let i,o,s=Ce(),u=e[0],l=e[1],d=e[3];if("string"===u&&"gpu-buffer"===d)throw new Error("String tensor is not supported on GPU.");if("gpu-buffer"===d){let t=e[2].gpuBuffer,n=ze(De(u));o=l.reduce(((e,t)=>e*t),1)*n,i=s.jsepRegisterBuffer(r,a,t,o)}else{let t=e[2];if(Array.isArray(t)){o=4*t.length,i=s._malloc(o),n.push(i);let e=i/4;for(let r=0;r<t.length;r++){if("string"!=typeof t[r])throw new TypeError(`tensor data at index ${r} is not a string`);s.HEAPU32[e++]=Ee(t[r],n)}}else o=t.byteLength,i=s._malloc(o),n.push(i),s.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),i)}let c=s.stackSave(),p=s.stackAlloc(4*l.length);try{let e=p/4;l.forEach((t=>s.HEAP32[e++]=t));let n=s._OrtCreateTensor(De(u),i,o,p,l.length,Ue(d));0===n&&Ae(`Can't create tensor for input/output. session=${r}, index=${a}.`),t.push(n)}finally{s.stackRestore(c)}},tu=async(e,t,n,r,a,i)=>{let o=Ce(),s=Ys.get(e);if(!s)throw new Error(`cannot run inference. invalid session id: ${e}`);let[u,l,d,c]=s,p=t.length,f=r.length,h=0,m=[],g=[],y=[],w=[],$=o.stackSave(),v=o.stackAlloc(4*p),b=o.stackAlloc(4*p),x=o.stackAlloc(4*f),S=o.stackAlloc(4*f);try{[h,m]=Oe(i);for(let r=0;r<p;r++)eu(n[r],g,w,e,t[r]);for(let t=0;t<f;t++)eu(a[t],y,w,e,p+r[t]);let s,$=v/4,_=b/4,C=x/4,E=S/4;for(let e=0;e<p;e++)o.HEAPU32[$++]=g[e],o.HEAPU32[_++]=l[t[e]];for(let e=0;e<f;e++)o.HEAPU32[C++]=y[e],o.HEAPU32[E++]=d[r[e]];if(c){let{handle:n,outputPreferredLocations:i,outputPreferredLocationsEncoded:s}=c;if(l.length!==p)throw new Error(`input count from feeds (${p}) is expected to be always equal to model's input count (${l.length}).`);for(let r=0;r<p;r++){let a=t[r];0!==await o._OrtBindInput(n,l[a],g[r])&&Ae(`Can't bind input[${r}] for session=${e}.`)}for(let t=0;t<f;t++){let u=r[t];a[t]?.[3]?0!==o._OrtBindOutput(n,d[u],y[t],0)&&Ae(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==o._OrtBindOutput(n,d[u],0,s[u])&&Ae(`Can't bind output[${t}] to ${i[t]} for session=${e}.`)}}s=c?await o._OrtRunWithBinding(u,c.handle,f,x,h):await o._OrtRun(u,b,v,p,S,f,x,h),0!==s&&Ae("failed to call OrtRun().");let I=[];for(let e=0;e<f;e++){let t=o.HEAPU32[x/4+e];if(t===y[e]){I.push(a[e]);continue}let n,i=o.stackSave(),s=o.stackAlloc(16),u=!1,l=0;try{0!==o._OrtGetTensorData(t,s,s+4,s+8,s+12)&&Ae(`Can't access output tensor data on index ${e}.`);let a=s/4,i=o.HEAPU32[a++];l=o.HEAPU32[a++];let d=o.HEAPU32[a++],p=o.HEAPU32[a++],f=[];for(let e=0;e<p;e++)f.push(o.HEAPU32[d/4+e]);o._OrtFree(d);let h=f.reduce(((e,t)=>e*t),1);n=Pe(i);let m=c?.outputPreferredLocations[r[e]];if("string"===n){if("gpu-buffer"===m)throw new Error("String tensor is not supported on GPU.");let e=[],t=l/4;for(let n=0;n<h;n++){let r=o.HEAPU32[t++],a=n===h-1?void 0:o.HEAPU32[t]-r;e.push(o.UTF8ToString(r,a))}I.push([n,f,e,"cpu"])}else if("gpu-buffer"===m&&h>0){let e=o.jsepGetBuffer(l),r=ze(i);if(void 0===r||!Ge(n))throw new Error(`Unsupported data type: ${n}`);u=!0,I.push([n,f,{gpuBuffer:e,download:o.jsepCreateDownloader(e,h*r,n),dispose:()=>{o._OrtReleaseTensor(t)}},"gpu-buffer"])}else{let e=new(We(n))(h);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(o.HEAPU8.subarray(l,l+e.byteLength)),I.push([n,f,e,"cpu"])}}finally{o.stackRestore(i),"string"===n&&l&&o._free(l),u||o._OrtReleaseTensor(t)}}return c&&o._OrtClearBoundOutputs(c.handle),I}finally{o.stackRestore($),g.forEach((e=>o._OrtReleaseTensor(e))),y.forEach((e=>o._OrtReleaseTensor(e))),w.forEach((e=>o._free(e))),0!==h&&o._OrtReleaseRunOptions(h),m.forEach((e=>o._free(e)))}},nu=e=>{let t=Ce(),n=Ys.get(e);if(!n)throw new Error("invalid session id");let r=n[0],a=t._OrtEndProfiling(r);0===a&&Ae("Can't get an profile file name."),t._OrtFree(a)},ru=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),Wu=z(((e,t)=>{t.exports='/*!\n * ONNX Runtime Web v1.17.0-dev.20231103-1439da36fe\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var on=Object.defineProperty;var Su=Object.getOwnPropertyDescriptor;var Cu=Object.getOwnPropertyNames;var Au=Object.prototype.hasOwnProperty;var H=(e,t)=>()=>(e&&(t=e(e=0)),t);var Jt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ir=(e,t)=>{for(var r in t)on(e,r,{get:t[r],enumerable:!0})},Iu=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Cu(t))!Au.call(e,n)&&n!==r&&on(e,n,{get:()=>t[n],enumerable:!(o=Su(t,n))||o.enumerable});return e};var Mt=e=>Iu(on({},"__esModule",{value:!0}),e);var an={};Ir(an,{readFile:()=>Eu});var Eu,sn=H(()=>{Eu=void 0});var un={};Ir(un,{join:()=>Tu});var Tu,ln=H(()=>{Tu=void 0});var uo=Jt((so,dn)=>{"use strict";var io=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((l,p)=>{o=l,n=p}),r.jsepInit=(l,p,h,C,T,U,G,ue)=>{r.Za=l,r.Oa=p,r.Qa=h,r.Ja=C,r.Pa=T,r.ra=U,r.Ra=G,r.Sa=ue,p=(Y,Q,J)=>(...ce)=>{let me=He,E=Q?.();ce=Y(...ce);let te=Q?.();return E!==te&&(Y=te,J(E),Q=J=null),He!=me?gr():ce},h=Y=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let J=r.Da={Ta:Q[0],errors:[]},ce=await Y(...Q);if(r.Da!==J)throw Error("Session mismatch");l.flush();let me=J.errors;if(0<me.length){let E=await Promise.all(me);if(E=E.filter(te=>te),0<E.length)throw Error(E.join(`\n`))}return ce}finally{r.Da=null}},r._OrtRun=h(p(r._OrtRun,()=>r._OrtRun,Y=>r._OrtRun=Y)),r._OrtRunWithBinding=h(p(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Y=>r._OrtRunWithBinding=Y)),r._OrtBindInput=p(r._OrtBindInput,()=>r._OrtBindInput,Y=>r._OrtBindInput=Y),r.jsepRegisterBuffer=(Y,Q,J,ce)=>l.registerBuffer(Y,Q,J,ce),r.jsepUnregisterBuffers=Y=>{l.unregisterBuffers(Y)},r.jsepGetBuffer=Y=>l.getBuffer(Y),r.jsepCreateDownloader=(Y,Q,J)=>l.createDownloader(Y,Q,J)};var s=Object.assign({},r),u="./this.program",d=(l,p)=>{throw p},a=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x="",b,w,v;if(g){var y=(sn(),Mt(an)),S=(ln(),Mt(un));x=m?S.dirname(x)+"/":__dirname+"/",b=(l,p)=>(l=l.startsWith("file://")?new URL(l):S.normalize(l),y.readFileSync(l,p?void 0:"utf8")),v=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),w=(l,p,h,C=!0)=>{l=l.startsWith("file://")?new URL(l):S.normalize(l),y.readFile(l,C?void 0:"utf8",(T,U)=>{T?h(T):p(C?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,p)=>{throw process.exitCode=l,p},r.inspect=()=>"[Emscripten Module object]"}else(a||m)&&(m?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),e&&(x=e),x.indexOf("blob:")!==0?x=x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):x="",b=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.send(null),p.responseText},m&&(v=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),w=(l,p,h)=>{var C=new XMLHttpRequest;C.open("GET",l,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?p(C.response):h()},C.onerror=h,C.send(null)});var A=r.print||console.log.bind(console),R=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(d=r.quit);var W;r.wasmBinary&&(W=r.wasmBinary);var M=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Le("no native wasm support detected");var D,_,z=!1,F,q,le,B,K,xe,ae;function we(){var l=D.buffer;r.HEAP8=q=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=B=new Int32Array(l),r.HEAPU8=le=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=K=new Uint32Array(l),r.HEAPF32=xe=new Float32Array(l),r.HEAPF64=ae=new Float64Array(l)}var j=[],Se=[],Oe=[];function Ie(){var l=r.preRun.shift();j.unshift(l)}var Ce=0,dt=null,Ne=null;function Le(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",R(l),z=!0,F=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function N(l){return l.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!N(de)){var pe=de;de=r.locateFile?r.locateFile(pe,x):x+pe}function ze(l){if(l==de&&W)return new Uint8Array(W);if(v)return v(l);throw"both async and sync fetching of the wasm failed"}function Ue(l){if(!W&&(a||m)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at \'"+l+"\'";return p.arrayBuffer()}).catch(()=>ze(l));if(w)return new Promise((p,h)=>{w(l,C=>p(new Uint8Array(C)),h)})}return Promise.resolve().then(()=>ze(l))}function Te(l,p,h){return Ue(l).then(C=>WebAssembly.instantiate(C,p)).then(C=>C).then(h,C=>{R("failed to asynchronously prepare wasm: "+C),Le(C)})}function ke(l,p){var h=de;return W||typeof WebAssembly.instantiateStreaming!="function"||N(h)||h.startsWith("file://")||g||typeof fetch!="function"?Te(h,l,p):fetch(h,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,l).then(p,function(T){return R("wasm streaming compile failed: "+T),R("falling back to ArrayBuffer instantiation"),Te(h,l,p)}))}var Ge,Xe={913792:l=>{r.ra("Abs",l,void 0)},913843:l=>{r.ra("Neg",l,void 0)},913894:l=>{r.ra("Floor",l,void 0)},913947:l=>{r.ra("Ceil",l,void 0)},913999:l=>{r.ra("Reciprocal",l,void 0)},914057:l=>{r.ra("Sqrt",l,void 0)},914109:l=>{r.ra("Exp",l,void 0)},914160:l=>{r.ra("Erf",l,void 0)},914211:l=>{r.ra("Sigmoid",l,void 0)},914266:l=>{r.ra("Log",l,void 0)},914317:l=>{r.ra("Sin",l,void 0)},914368:l=>{r.ra("Cos",l,void 0)},914419:l=>{r.ra("Tan",l,void 0)},914470:l=>{r.ra("Asin",l,void 0)},914522:l=>{r.ra("Acos",l,void 0)},914574:l=>{r.ra("Atan",l,void 0)},914626:l=>{r.ra("Sinh",l,void 0)},914678:l=>{r.ra("Cosh",l,void 0)},914730:l=>{r.ra("Asinh",l,void 0)},914783:l=>{r.ra("Acosh",l,void 0)},914836:l=>{r.ra("Atanh",l,void 0)},914889:l=>{r.ra("Tanh",l,void 0)},914941:l=>{r.ra("Not",l,void 0)},914992:(l,p,h)=>{r.ra("ClipV10",l,{min:p,max:h})},915064:l=>{r.ra("Clip",l,void 0)},915116:(l,p)=>{r.ra("Elu",l,{alpha:p})},915174:l=>{r.ra("Relu",l,void 0)},915226:(l,p)=>{r.ra("LeakyRelu",l,{alpha:p})},915290:(l,p)=>{r.ra("ThresholdedRelu",l,{alpha:p})},915360:(l,p)=>{r.ra("Cast",l,{to:p})},915418:l=>{r.ra("Add",l,void 0)},915469:l=>{r.ra("Sub",l,void 0)},915520:l=>{r.ra("Mul",l,void 0)},915571:l=>{r.ra("Div",l,void 0)},915622:l=>{r.ra("Pow",l,void 0)},915673:l=>{r.ra("Equal",l,void 0)},915726:l=>{r.ra("Greater",l,void 0)},915781:l=>{r.ra("GreaterOrEqual",l,void 0)},915843:l=>{r.ra("Less",l,void 0)},915895:l=>{r.ra("LessOrEqual",l,void 0)},915954:(l,p,h,C,T)=>{r.ra("ReduceMean",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916118:(l,p,h,C,T)=>{r.ra("ReduceMax",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916281:(l,p,h,C,T)=>{r.ra("ReduceMin",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916444:(l,p,h,C,T)=>{r.ra("ReduceProd",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916608:(l,p,h,C,T)=>{r.ra("ReduceSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916771:(l,p,h,C,T)=>{r.ra("ReduceL1",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916933:(l,p,h,C,T)=>{r.ra("ReduceL2",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917095:(l,p,h,C,T)=>{r.ra("ReduceLogSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917261:(l,p,h,C,T)=>{r.ra("ReduceSumSquare",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917430:(l,p,h,C,T)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917599:l=>{r.ra("Where",l,void 0)},917652:(l,p,h)=>{r.ra("Transpose",l,{perm:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[]})},917765:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[T],pads:[U,G],strides:[ue],wIsConst:()=>!!q[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},918179:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:ue?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(T>>>0,T+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!q[Y>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},918736:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[T],pads:[U,G],strides:[ue],wIsConst:()=>!!q[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},919150:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:ue?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(T>>>0,T+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!q[Y>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},919707:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},919798:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920082:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},920173:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920457:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},920544:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920824:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},920911:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},921191:(l,p,h,C,T)=>{r.ra("Gemm",l,{alpha:p,beta:h,transA:C,transB:T})},921295:l=>{r.ra("MatMul",l,void 0)},921349:(l,p,h,C)=>{r.ra("ArgMax",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},921457:(l,p,h,C)=>{r.ra("ArgMin",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},921565:(l,p)=>{r.ra("Softmax",l,{axis:p})},921628:(l,p)=>{r.ra("Concat",l,{axis:p})},921688:(l,p,h,C,T)=>{r.ra("Split",l,{axis:p,numOutputs:h,splitSizes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},921833:l=>{r.ra("Expand",l,void 0)},921887:(l,p)=>{r.ra("Gather",l,{axis:Number(p)})},921958:(l,p)=>{r.ra("GatherElements",l,{axis:Number(p)})},922037:(l,p,h,C,T,U,G,ue,Y,Q,J)=>{r.ra("Resize",l,{antialias:p,axes:h?Array.from(B.subarray(C>>>0,C+h>>>0)):[],coordinateTransformMode:_e(T),cubicCoeffA:U,excludeOutside:G,extrapolationValue:ue,keepAspectRatioPolicy:_e(Y),mode:_e(Q),nearestMode:_e(J)})},922388:(l,p,h,C,T,U,G)=>{r.ra("Slice",l,{starts:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[],ends:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[],axes:U?Array.from(B.subarray(G>>>0,G+U>>>0)):[]})},922619:l=>{r.ra("Tile",l,void 0)},922671:(l,p,h)=>{r.ra("LayerNormalization",l,{axis:Number(p),epsilon:Number(h)})},922778:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},922892:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},923006:l=>{r.ra("Range",l,void 0)},923059:(l,p)=>{r.ra("Einsum",l,{equation:_e(p)})},923140:(l,p,h,C,T)=>{r.ra("Pad",l,{mode:p,value:h,pads:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},923272:l=>{r.ra("Gelu",l,void 0)},923324:l=>{r.ra("BiasAdd",l,void 0)},923379:l=>{r.ra("BiasSplitGelu",l,void 0)},923440:(l,p)=>{r.ra("SkipLayerNormalization",l,{epsilon:p})},923521:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me)=>{r.ra("Conv",l,{format:Y?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:C,kernel_shape:[T],pads:U?Array.from(B.subarray(G>>>0,G+U>>>0)):[],strides:[ue],w_is_const:()=>!!q[Q>>>0],activation:_e(J),activation_params:ce?Array.from(xe.subarray(me>>>0,me+ce>>>0)):[]})},923902:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("Conv",l,{format:ce?"NHWC":"NCHW",auto_pad:p,dilations:[h,C],group:T,kernel_shape:[U,G],pads:ue?Array.from(B.subarray(Y>>>0,Y+ue>>>0)):[],strides:[Q,J],w_is_const:()=>!!q[me>>>0],activation:_e(E),activation_params:te?Array.from(xe.subarray(fe>>>0,fe+te>>>0)):[]})},924304:l=>{r.Ra(l)},924338:(l,p)=>r.Sa(l,p,r.Da.Ta,r.Da.errors),924450:l=>r.Oa(l),924483:l=>r.Qa(l),924515:(l,p,h)=>{r.Ja(l,p,h,!0)},924554:(l,p,h)=>{r.Ja(l,p,h)}};function Fe(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var yt=l=>{for(;0<l.length;)l.shift()(r)};function bt(l){this.Ha=l-24,this.Ma=function(p){K[this.Ha+4>>2>>>0]=p},this.La=function(p){K[this.Ha+8>>2>>>0]=p},this.Ya=function(p,h){this.Ka(),this.Ma(p),this.La(h)},this.Ka=function(){K[this.Ha+16>>2>>>0]=0}}var Bt=0,lr=0,Ke=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,kt=(l,p,h)=>{p>>>=0;var C=p+h;for(h=p;l[h]&&!(h>=C);)++h;if(16<h-p&&l.buffer&&Ke)return Ke.decode(l.subarray(p,h));for(C="";p<h;){var T=l[p++];if(T&128){var U=l[p++]&63;if((T&224)==192)C+=String.fromCharCode((T&31)<<6|U);else{var G=l[p++]&63;T=(T&240)==224?(T&15)<<12|U<<6|G:(T&7)<<18|U<<12|G<<6|l[p++]&63,65536>T?C+=String.fromCharCode(T):(T-=65536,C+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else C+=String.fromCharCode(T)}return C},_e=(l,p)=>(l>>>=0)?kt(le,l,p):"",It=l=>{for(var p=0,h=0;h<l.length;++h){var C=l.charCodeAt(h);127>=C?p++:2047>=C?p+=2:55296<=C&&57343>=C?(p+=4,++h):p+=3}return p},Dt=(l,p,h,C)=>{if(h>>>=0,!(0<C))return 0;var T=h;C=h+C-1;for(var U=0;U<l.length;++U){var G=l.charCodeAt(U);if(55296<=G&&57343>=G){var ue=l.charCodeAt(++U);G=65536+((G&1023)<<10)|ue&1023}if(127>=G){if(h>=C)break;p[h++>>>0]=G}else{if(2047>=G){if(h+1>=C)break;p[h++>>>0]=192|G>>6}else{if(65535>=G){if(h+2>=C)break;p[h++>>>0]=224|G>>12}else{if(h+3>=C)break;p[h++>>>0]=240|G>>18,p[h++>>>0]=128|G>>12&63}p[h++>>>0]=128|G>>6&63}p[h++>>>0]=128|G&63}}return p[h>>>0]=0,h-T},at=l=>l%4===0&&(l%100!==0||l%400===0),dr=[0,31,60,91,121,152,182,213,244,274,305,335],it=[0,31,59,90,120,151,181,212,243,273,304,334],Et=l=>{var p=It(l)+1,h=Rt(p);return h&&Dt(l,le,h,p),h},ct=[],Tt=(l,p)=>{ct.length=0;var h;for(p>>=2;h=le[l++>>>0];)p+=h!=105&p,ct.push(h==105?B[p>>>0]:ae[p++>>>1]),++p;return ct},Ot={},Wt=()=>{if(!_t){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},p;for(p in Ot)Ot[p]===void 0?delete l[p]:l[p]=Ot[p];var h=[];for(p in l)h.push(`${p}=${l[p]}`);_t=h}return _t},_t,cr=[null,[],[]],Ve=[31,29,31,30,31,30,31,31,30,31,30,31],zt=[31,28,31,30,31,30,31,31,30,31,30,31];function Vt(l){var p=Array(It(l)+1);return Dt(l,p,0,p.length),p}function ne(l,p,h,C){function T(E,te,fe){for(E=typeof E=="number"?E.toString():E||"";E.length<te;)E=fe[0]+E;return E}function U(E,te){return T(E,te,"0")}function G(E,te){function fe(Xt){return 0>Xt?-1:0<Xt?1:0}var ut;return(ut=fe(E.getFullYear()-te.getFullYear()))===0&&(ut=fe(E.getMonth()-te.getMonth()))===0&&(ut=fe(E.getDate()-te.getDate())),ut}function ue(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function Y(E){var te=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<te;){var fe=E.getMonth(),ut=(at(E.getFullYear())?Ve:zt)[fe];if(te>ut-E.getDate())te-=ut-E.getDate()+1,E.setDate(1),11>fe?E.setMonth(fe+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+te);break}}return fe=new Date(E.getFullYear()+1,0,4),te=ue(new Date(E.getFullYear(),0,4)),fe=ue(fe),0>=G(te,E)?0>=G(fe,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}l>>>=0,p>>>=0,h>>>=0,C>>>=0;var Q=B[C+40>>2>>>0];C={Wa:B[C>>2>>>0],Va:B[C+4>>2>>>0],Ea:B[C+8>>2>>>0],Ia:B[C+12>>2>>>0],Fa:B[C+16>>2>>>0],Ca:B[C+20>>2>>>0],wa:B[C+24>>2>>>0],Ba:B[C+28>>2>>>0],$a:B[C+32>>2>>>0],Ua:B[C+36>>2>>>0],Xa:Q?_e(Q):""},h=_e(h),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var J in Q)h=h.replace(new RegExp(J,"g"),Q[J]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),me="January February March April May June July August September October November December".split(" ");Q={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>me[E.Fa].substring(0,3),"%B":E=>me[E.Fa],"%C":E=>U((E.Ca+1900)/100|0,2),"%d":E=>U(E.Ia,2),"%e":E=>T(E.Ia,2," "),"%g":E=>Y(E).toString().substring(2),"%G":E=>Y(E),"%H":E=>U(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),U(E,2)),"%j":E=>{for(var te=0,fe=0;fe<=E.Fa-1;te+=(at(E.Ca+1900)?Ve:zt)[fe++]);return U(E.Ia+te,3)},"%m":E=>U(E.Fa+1,2),"%M":E=>U(E.Va,2),"%n":()=>`\n`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>U(E.Wa,2),"%t":()=>"\t","%u":E=>E.wa||7,"%U":E=>U(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var te=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&te++,te)te==53&&(fe=(E.wa+371-E.Ba)%7,fe==4||fe==3&&at(E.Ca)||(te=1));else{te=52;var fe=(E.wa+7-E.Ba-1)%7;(fe==4||fe==5&&at(E.Ca%400-1))&&te++}return U(te,2)},"%w":E=>E.wa,"%W":E=>U(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var te=0<=E;return E=Math.abs(E)/60,(te?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},h=h.replace(/%%/g,"\\0\\0");for(J in Q)h.includes(J)&&(h=h.replace(new RegExp(J,"g"),Q[J](C)));return h=h.replace(/\\0\\0/g,"%"),J=Vt(h),J.length>p?0:(q.set(J,l>>>0),J.length-1)}function st(l){try{l()}catch(p){Le(p)}}function pr(l){var p={},h;for(h in l)(function(C){var T=l[C];p[C]=typeof T=="function"?function(){wt.push(C);try{return T.apply(null,arguments)}finally{z||(wt.pop()===C||Le(),He&&Je===1&&wt.length===0&&(Je=0,st(qt),typeof Fibers<"u"&&Fibers.ab()))}}:T})(h);return p}var Je=0,He=null,fr=0,wt=[],Gt={},Nt={},mr=0,vt=null,hr=[];function gr(){return new Promise((l,p)=>{vt={resolve:l,reject:p}})}function yr(){var l=Rt(65548),p=l+12;K[l>>2>>>0]=p,K[l+4>>2>>>0]=p+65536,p=wt[0];var h=Gt[p];return h===void 0&&(h=mr++,Gt[p]=h,Nt[h]=p),B[l+8>>2>>>0]=h,l}function br(l){if(!z){if(Je===0){var p=!1,h=!1;l((C=0)=>{if(!z&&(fr=C,p=!0,h)){Je=2,st(()=>Pt(He)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var T=(0,_[Nt[B[He+8>>2>>>0]]])()}catch(ue){T=ue,C=!0}var U=!1;if(!He){var G=vt;G&&(vt=null,(C?G.reject:G.resolve)(T),U=!0)}if(C&&!U)throw T}}),h=!0,p||(Je=1,He=yr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),st(()=>Kt(He)))}else Je===2?(Je=0,st($t),Ut(He),He=null,hr.forEach(C=>{if(!z)try{if(C(),!M)try{F=F=C=F,M||(r.onExit&&r.onExit(C),z=!0),d(C,new Fe(C))}catch(T){T instanceof Fe||T=="unwind"||d(1,T)}}catch(T){T instanceof Fe||T=="unwind"||d(1,T)}})):Le(`invalid state: ${Je}`);return fr}}function wr(l){return br(p=>{l().then(p)})}var vr={n:function(l,p,h){return wr(async()=>{await r.Pa(l,p,h)})},a:function(l,p,h){throw l>>>=0,new bt(l).Ya(p>>>0,h>>>0),Bt=l,lr++,Bt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getUTCSeconds(),B[h+4>>2>>>0]=l.getUTCMinutes(),B[h+8>>2>>>0]=l.getUTCHours(),B[h+12>>2>>>0]=l.getUTCDate(),B[h+16>>2>>>0]=l.getUTCMonth(),B[h+20>>2>>>0]=l.getUTCFullYear()-1900,B[h+24>>2>>>0]=l.getUTCDay(),B[h+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getSeconds(),B[h+4>>2>>>0]=l.getMinutes(),B[h+8>>2>>>0]=l.getHours(),B[h+12>>2>>>0]=l.getDate(),B[h+16>>2>>>0]=l.getMonth(),B[h+20>>2>>>0]=l.getFullYear()-1900,B[h+24>>2>>>0]=l.getDay(),B[h+28>>2>>>0]=(at(l.getFullYear())?dr:it)[l.getMonth()]+l.getDate()-1|0,B[h+36>>2>>>0]=-(60*l.getTimezoneOffset()),p=new Date(l.getFullYear(),6,1).getTimezoneOffset();var C=new Date(l.getFullYear(),0,1).getTimezoneOffset();B[h+32>>2>>>0]=(p!=C&&l.getTimezoneOffset()==Math.min(C,p))|0},s:function(l){l>>>=0;var p=new Date(B[l+20>>2>>>0]+1900,B[l+16>>2>>>0],B[l+12>>2>>>0],B[l+8>>2>>>0],B[l+4>>2>>>0],B[l>>2>>>0],0),h=B[l+32>>2>>>0],C=p.getTimezoneOffset(),T=new Date(p.getFullYear(),6,1).getTimezoneOffset(),U=new Date(p.getFullYear(),0,1).getTimezoneOffset(),G=Math.min(U,T);return 0>h?B[l+32>>2>>>0]=+(T!=U&&G==C):0<h!=(G==C)&&(T=Math.max(U,T),p.setTime(p.getTime()+6e4*((0<h?G:T)-C))),B[l+24>>2>>>0]=p.getDay(),B[l+28>>2>>>0]=(at(p.getFullYear())?dr:it)[p.getMonth()]+p.getDate()-1|0,B[l>>2>>>0]=p.getSeconds(),B[l+4>>2>>>0]=p.getMinutes(),B[l+8>>2>>>0]=p.getHours(),B[l+12>>2>>>0]=p.getDate(),B[l+16>>2>>>0]=p.getMonth(),B[l+20>>2>>>0]=p.getYear(),l=p.getTime()/1e3,Lt((Ge=l,1<=+Math.abs(Ge)?0<Ge?+Math.floor(Ge/4294967296)>>>0:~~+Math.ceil((Ge-+(~~Ge>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,p,h){function C(Y){return(Y=Y.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Y[1]:"GMT"}h>>>=0;var T=new Date().getFullYear(),U=new Date(T,0,1),G=new Date(T,6,1);T=U.getTimezoneOffset();var ue=G.getTimezoneOffset();K[l>>>0>>2>>>0]=60*Math.max(T,ue),B[p>>>0>>2>>>0]=+(T!=ue),l=C(U),p=C(G),l=Et(l),p=Et(p),ue<T?(K[h>>2>>>0]=l,K[h+4>>2>>>0]=p):(K[h>>2>>>0]=p,K[h+4>>2>>>0]=l)},e:()=>{Le("")},b:function(l,p,h){return l>>>=0,p=Tt(p>>>0,h>>>0),Xe[l].apply(null,p)},i:function(l,p,h){return l>>>=0,p=Tt(p>>>0,h>>>0),Xe[l].apply(null,p)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,p,h){return p>>>=0,le.copyWithin(l>>>0>>>0,p>>>0,p+(h>>>0)>>>0)},u:function(l){l>>>=0;var p=le.length;if(4294901760<l)return!1;for(var h=1;4>=h;h*=2){var C=p*(1+.2/h);C=Math.min(C,l+100663296);var T=Math;C=Math.max(l,C);e:{T=T.min.call(T,4294901760,C+(65536-C%65536)%65536)-D.buffer.byteLength+65535>>>16;try{D.grow(T),we();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(l,p){l>>>=0,p>>>=0;var h=0;return Wt().forEach(function(C,T){var U=p+h;for(T=K[l+4*T>>2>>>0]=U,U=0;U<C.length;++U)q[T++>>0>>>0]=C.charCodeAt(U);q[T>>0>>>0]=0,h+=C.length+1}),0},E:function(l,p){l>>>=0,p>>>=0;var h=Wt();K[l>>2>>>0]=h.length;var C=0;return h.forEach(function(T){C+=T.length+1}),K[p>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,p,h,C){p>>>=0,h>>>=0,C>>>=0;for(var T=0,U=0;U<h;U++){var G=K[p>>2>>>0],ue=K[p+4>>2>>>0];p+=8;for(var Y=0;Y<ue;Y++){var Q=le[G+Y>>>0],J=cr[l];Q===0||Q===10?((l===1?A:R)(kt(J,0)),J.length=0):J.push(Q)}T+=ue}return K[C>>2>>>0]=T,0},F:ne,d:function(l,p,h,C){return ne(l>>>0,p>>>0,h>>>0,C>>>0)}};(function(){function l(h){if(h=h.exports,h=pr(h),_=h=pt(h),D=_.M,we(),Se.unshift(_.N),Ce--,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),Ce==0&&(dt!==null&&(clearInterval(dt),dt=null),Ne)){var C=Ne;Ne=null,C()}return h}var p={a:vr};if(Ce++,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),r.instantiateWasm)try{return r.instantiateWasm(p,l)}catch(h){R("Module.instantiateWasm callback failed with error: "+h),n(h)}return ke(p,function(h){l(h.instance)}).catch(n),{}})(),r._OrtInit=(l,p)=>(r._OrtInit=_.O)(l,p),r._OrtGetLastError=(l,p)=>(r._OrtGetLastError=_.P)(l,p),r._OrtCreateSessionOptions=(l,p,h,C,T,U,G,ue,Y,Q)=>(r._OrtCreateSessionOptions=_.Q)(l,p,h,C,T,U,G,ue,Y,Q),r._OrtAppendExecutionProvider=(l,p)=>(r._OrtAppendExecutionProvider=_.R)(l,p),r._OrtAddFreeDimensionOverride=(l,p,h)=>(r._OrtAddFreeDimensionOverride=_.S)(l,p,h),r._OrtAddSessionConfigEntry=(l,p,h)=>(r._OrtAddSessionConfigEntry=_.T)(l,p,h),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=_.U)(l),r._OrtCreateSession=(l,p,h)=>(r._OrtCreateSession=_.V)(l,p,h),r._OrtReleaseSession=l=>(r._OrtReleaseSession=_.W)(l),r._OrtGetInputOutputCount=(l,p,h)=>(r._OrtGetInputOutputCount=_.X)(l,p,h),r._OrtGetInputName=(l,p)=>(r._OrtGetInputName=_.Y)(l,p),r._OrtGetOutputName=(l,p)=>(r._OrtGetOutputName=_.Z)(l,p),r._OrtFree=l=>(r._OrtFree=_._)(l),r._OrtCreateTensor=(l,p,h,C,T,U)=>(r._OrtCreateTensor=_.$)(l,p,h,C,T,U),r._OrtGetTensorData=(l,p,h,C,T)=>(r._OrtGetTensorData=_.aa)(l,p,h,C,T),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=_.ba)(l),r._OrtCreateRunOptions=(l,p,h,C)=>(r._OrtCreateRunOptions=_.ca)(l,p,h,C),r._OrtAddRunConfigEntry=(l,p,h)=>(r._OrtAddRunConfigEntry=_.da)(l,p,h),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=_.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=_.fa)(l),r._OrtBindInput=(l,p,h)=>(r._OrtBindInput=_.ga)(l,p,h),r._OrtBindOutput=(l,p,h,C)=>(r._OrtBindOutput=_.ha)(l,p,h,C),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=_.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=_.ja)(l),r._OrtRunWithBinding=(l,p,h,C,T)=>(r._OrtRunWithBinding=_.ka)(l,p,h,C,T),r._OrtRun=(l,p,h,C,T,U,G,ue)=>(r._OrtRun=_.la)(l,p,h,C,T,U,G,ue),r._OrtEndProfiling=l=>(r._OrtEndProfiling=_.ma)(l),r._JsepOutput=(l,p,h)=>(r._JsepOutput=_.na)(l,p,h),r._JsepGetNodeName=l=>(r._JsepGetNodeName=_.oa)(l);var Rt=r._malloc=l=>(Rt=r._malloc=_.pa)(l),Ut=r._free=l=>(Ut=r._free=_.qa)(l),Lt=l=>(Lt=_.sa)(l),Ft=()=>(Ft=_.ta)(),Ht=l=>(Ht=_.ua)(l),jt=l=>(jt=_.va)(l),Kt=l=>(Kt=_.xa)(l),qt=()=>(qt=_.ya)(),Pt=l=>(Pt=_.za)(l),$t=()=>($t=_.Aa)();r.___start_em_js=924587,r.___stop_em_js=924748;function pt(l){l=Object.assign({},l);var p=C=>()=>C()>>>0,h=C=>T=>C(T)>>>0;return l.__errno_location=p(l.__errno_location),l.malloc=h(l.malloc),l.stackSave=p(l.stackSave),l.stackAlloc=h(l.stackAlloc),l}r.stackAlloc=jt,r.stackSave=Ft,r.stackRestore=Ht,r.UTF8ToString=_e,r.stringToUTF8=(l,p,h)=>Dt(l,le,p,h),r.lengthBytesUTF8=It;var xt;Ne=function l(){xt||Yt(),xt||(Ne=l)};function Yt(){function l(){if(!xt&&(xt=!0,r.calledRun=!0,!z)){if(yt(Se),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var p=r.postRun.shift();Oe.unshift(p)}yt(Oe)}}if(!(0<Ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ie();yt(j),0<Ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Yt(),t.ready}})();typeof so=="object"&&typeof dn=="object"?dn.exports=io:typeof define=="function"&&define.amd&&define([],()=>io)});var lo=Jt(()=>{});var co=Jt(()=>{});var po={};Ir(po,{cpus:()=>Ou});var Ou,fo=H(()=>{Ou=void 0});var go=Jt((ho,cn)=>{"use strict";var mo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=Ce.buffer&&pe(),Ce}function o(){return we.buffer!=Ce.buffer&&pe(),dt}function n(){return we.buffer!=Ce.buffer&&pe(),Ne}function s(){return we.buffer!=Ce.buffer&&pe(),Le}function u(){return we.buffer!=Ce.buffer&&pe(),N}function d(){return we.buffer!=Ce.buffer&&pe(),de}var a=t,m,g;a.ready=new Promise((i,c)=>{m=i,g=c}),a.jsepInit=(i,c,f,$,I,P,V,oe)=>{a.Qb=i,a.wb=c,a.yb=f,a.jb=$,a.xb=I,a.Ea=P,a.zb=V,a.Ab=oe,c=(ee,Z,re)=>(...he)=>{let be=Ze,O=Z?.();he=ee(...he);let se=Z?.();return O!==se&&(ee=se,re(O),Z=re=null),Ze!=be?hu():he},f=ee=>async(...Z)=>{try{if(a.bb)throw Error("Session already started");let re=a.bb={Fb:Z[0],errors:[]},he=await ee(...Z);if(a.bb!==re)throw Error("Session mismatch");i.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(se=>se),0<O.length)throw Error(O.join(`\n`))}return he}finally{a.bb=null}},a._OrtRun=f(c(a._OrtRun,()=>a._OrtRun,ee=>a._OrtRun=ee)),a._OrtRunWithBinding=f(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,ee=>a._OrtRunWithBinding=ee)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,ee=>a._OrtBindInput=ee),a.jsepRegisterBuffer=(ee,Z,re,he)=>i.registerBuffer(ee,Z,re,he),a.jsepUnregisterBuffers=ee=>{i.unregisterBuffers(ee)},a.jsepGetBuffer=ee=>i.getBuffer(ee),a.jsepCreateDownloader=(ee,Z,re)=>i.createDownloader(ee,Z,re)};var x=Object.assign({},a),b="./this.program",w=(i,c)=>{throw c},v=typeof window=="object",y=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=a.ENVIRONMENT_IS_PTHREAD||!1,R="";function W(i){return a.locateFile?a.locateFile(i,R):R+i}var M,D,_;if(S){var z=(sn(),Mt(an)),F=(ln(),Mt(un));R=y?F.dirname(R)+"/":__dirname+"/",M=(c,f)=>(c=c.startsWith("file://")?new URL(c):F.normalize(c),z.readFileSync(c,f?void 0:"utf8")),_=c=>(c=M(c,!0),c.buffer||(c=new Uint8Array(c)),c),D=(c,f,$,I=!0)=>{c=c.startsWith("file://")?new URL(c):F.normalize(c),z.readFile(c,I?void 0:"utf8",(P,V)=>{P?$(P):f(I?V.buffer:V)})},!a.thisProgram&&1<process.argv.length&&(b=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),w=(c,f)=>{throw process.exitCode=c,f},a.inspect=()=>"[Emscripten Module object]";let i;try{i=lo()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else(v||y)&&(y?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.indexOf("blob:")!==0?R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1):R="",S||(M=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},y&&(_=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),D=(i,c,f)=>{var $=new XMLHttpRequest;$.open("GET",i,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?c($.response):f()},$.onerror=f,$.send(null)}));S&&typeof performance>"u"&&(global.performance=co().performance);var q=console.log.bind(console),le=console.error.bind(console);S&&(q=(...i)=>z.writeSync(1,i.join(" ")+`\n`),le=(...i)=>z.writeSync(2,i.join(" ")+`\n`));var B=a.print||q,K=a.printErr||le;Object.assign(a,x),x=null,a.thisProgram&&(b=a.thisProgram),a.quit&&(w=a.quit);var xe;a.wasmBinary&&(xe=a.wasmBinary);var ae=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Ke("no native wasm support detected");var we,j,Se,Oe=!1,Ie,Ce,dt,Ne,Le,N,de;function pe(){var i=we.buffer;a.HEAP8=Ce=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAP32=Ne=new Int32Array(i),a.HEAPU8=dt=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAPU32=Le=new Uint32Array(i),a.HEAPF32=N=new Float32Array(i),a.HEAPF64=de=new Float64Array(i)}var ze=a.INITIAL_MEMORY||16777216;if(5242880<=ze||Ke("INITIAL_MEMORY should be larger than STACK_SIZE, was "+ze+"! (STACK_SIZE=5242880)"),A)we=a.wasmMemory;else if(a.wasmMemory)we=a.wasmMemory;else if(we=new WebAssembly.Memory({initial:ze/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),ze=we.buffer.byteLength;var Ue=[],Te=[],ke=[],Ge=0;function Xe(){return ae||0<Ge}var Fe=0,yt=null,bt=null;function Bt(){Fe++,a.monitorRunDependencies&&a.monitorRunDependencies(Fe)}function lr(){if(Fe--,a.monitorRunDependencies&&a.monitorRunDependencies(Fe),Fe==0&&(yt!==null&&(clearInterval(yt),yt=null),bt)){var i=bt;bt=null,i()}}function Ke(i){throw a.onAbort&&a.onAbort(i),i="Aborted("+i+")",K(i),Oe=!0,Ie=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),g(i),i}function kt(i){return i.startsWith("data:application/octet-stream;base64,")}var _e;_e="ort-wasm-simd-threaded.wasm",kt(_e)||(_e=W(_e));function It(i){if(i==_e&&xe)return new Uint8Array(xe);if(_)return _(i);throw"both async and sync fetching of the wasm failed"}function Dt(i){if(!xe&&(v||y)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>It(i));if(D)return new Promise((c,f)=>{D(i,$=>c(new Uint8Array($)),f)})}return Promise.resolve().then(()=>It(i))}function at(i,c,f){return Dt(i).then($=>WebAssembly.instantiate($,c)).then($=>$).then(f,$=>{K("failed to asynchronously prepare wasm: "+$),Ke($)})}function dr(i,c){var f=_e;return xe||typeof WebAssembly.instantiateStreaming!="function"||kt(f)||f.startsWith("file://")||S||typeof fetch!="function"?at(f,i,c):fetch(f,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,i).then(c,function(I){return K("wasm streaming compile failed: "+I),K("falling back to ArrayBuffer instantiation"),at(f,i,c)}))}var it,Et={914988:i=>{a.Ea("Abs",i,void 0)},915039:i=>{a.Ea("Neg",i,void 0)},915090:i=>{a.Ea("Floor",i,void 0)},915143:i=>{a.Ea("Ceil",i,void 0)},915195:i=>{a.Ea("Reciprocal",i,void 0)},915253:i=>{a.Ea("Sqrt",i,void 0)},915305:i=>{a.Ea("Exp",i,void 0)},915356:i=>{a.Ea("Erf",i,void 0)},915407:i=>{a.Ea("Sigmoid",i,void 0)},915462:i=>{a.Ea("Log",i,void 0)},915513:i=>{a.Ea("Sin",i,void 0)},915564:i=>{a.Ea("Cos",i,void 0)},915615:i=>{a.Ea("Tan",i,void 0)},915666:i=>{a.Ea("Asin",i,void 0)},915718:i=>{a.Ea("Acos",i,void 0)},915770:i=>{a.Ea("Atan",i,void 0)},915822:i=>{a.Ea("Sinh",i,void 0)},915874:i=>{a.Ea("Cosh",i,void 0)},915926:i=>{a.Ea("Asinh",i,void 0)},915979:i=>{a.Ea("Acosh",i,void 0)},916032:i=>{a.Ea("Atanh",i,void 0)},916085:i=>{a.Ea("Tanh",i,void 0)},916137:i=>{a.Ea("Not",i,void 0)},916188:(i,c,f)=>{a.Ea("ClipV10",i,{min:c,max:f})},916260:i=>{a.Ea("Clip",i,void 0)},916312:(i,c)=>{a.Ea("Elu",i,{alpha:c})},916370:i=>{a.Ea("Relu",i,void 0)},916422:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},916486:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},916556:(i,c)=>{a.Ea("Cast",i,{to:c})},916614:i=>{a.Ea("Add",i,void 0)},916665:i=>{a.Ea("Sub",i,void 0)},916716:i=>{a.Ea("Mul",i,void 0)},916767:i=>{a.Ea("Div",i,void 0)},916818:i=>{a.Ea("Pow",i,void 0)},916869:i=>{a.Ea("Equal",i,void 0)},916922:i=>{a.Ea("Greater",i,void 0)},916977:i=>{a.Ea("GreaterOrEqual",i,void 0)},917039:i=>{a.Ea("Less",i,void 0)},917091:i=>{a.Ea("LessOrEqual",i,void 0)},917150:(i,c,f,$,I)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917314:(i,c,f,$,I)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917477:(i,c,f,$,I)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917640:(i,c,f,$,I)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917804:(i,c,f,$,I)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917967:(i,c,f,$,I)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918129:(i,c,f,$,I)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918291:(i,c,f,$,I)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918457:(i,c,f,$,I)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918626:(i,c,f,$,I)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918795:i=>{a.Ea("Where",i,void 0)},918848:(i,c,f)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[]})},918961:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se)=>{a.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[I],pads:[P,V],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ve(se)})},919375:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O)=>{a.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(P>>>0,P+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ve(O)})},919932:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se)=>{a.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[I],pads:[P,V],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ve(se)})},920346:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O)=>{a.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(P>>>0,P+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ve(O)})},920903:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},920994:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},921278:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},921369:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},921653:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},921740:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},922020:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},922107:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},922387:(i,c,f,$,I)=>{a.Ea("Gemm",i,{alpha:c,beta:f,transA:$,transB:I})},922491:i=>{a.Ea("MatMul",i,void 0)},922545:(i,c,f,$)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},922653:(i,c,f,$)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},922761:(i,c)=>{a.Ea("Softmax",i,{axis:c})},922824:(i,c)=>{a.Ea("Concat",i,{axis:c})},922884:(i,c,f,$,I)=>{a.Ea("Split",i,{axis:c,numOutputs:f,splitSizes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},923029:i=>{a.Ea("Expand",i,void 0)},923083:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},923154:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},923233:(i,c,f,$,I,P,V,oe,ee,Z,re)=>{a.Ea("Resize",i,{antialias:c,axes:f?Array.from(n().subarray($>>>0,$+f>>>0)):[],coordinateTransformMode:Ve(I),cubicCoeffA:P,excludeOutside:V,extrapolationValue:oe,keepAspectRatioPolicy:Ve(ee),mode:Ve(Z),nearestMode:Ve(re)})},923584:(i,c,f,$,I,P,V)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[],ends:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[],axes:P?Array.from(n().subarray(V>>>0,V+P>>>0)):[]})},923815:i=>{a.Ea("Tile",i,void 0)},923867:(i,c,f)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(f)})},923974:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},924088:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},924202:i=>{a.Ea("Range",i,void 0)},924255:(i,c)=>{a.Ea("Einsum",i,{equation:Ve(c)})},924336:(i,c,f,$,I)=>{a.Ea("Pad",i,{mode:c,value:f,pads:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},924468:i=>{a.Ea("Gelu",i,void 0)},924520:i=>{a.Ea("BiasAdd",i,void 0)},924575:i=>{a.Ea("BiasSplitGelu",i,void 0)},924636:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},924717:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be)=>{a.Ea("Conv",i,{format:ee?"NHWC":"NCHW",auto_pad:c,dilations:[f],group:$,kernel_shape:[I],pads:P?Array.from(n().subarray(V>>>0,V+P>>>0)):[],strides:[oe],w_is_const:()=>!!r()[Z>>>0],activation:Ve(re),activation_params:he?Array.from(u().subarray(be>>>0,be+he>>>0)):[]})},925098:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("Conv",i,{format:he?"NHWC":"NCHW",auto_pad:c,dilations:[f,$],group:I,kernel_shape:[P,V],pads:oe?Array.from(n().subarray(ee>>>0,ee+oe>>>0)):[],strides:[Z,re],w_is_const:()=>!!r()[be>>>0],activation:Ve(O),activation_params:se?Array.from(u().subarray(ye>>>0,ye+se>>>0)):[]})},925500:i=>{a.zb(i)},925534:(i,c)=>a.Ab(i,c,a.bb.Fb,a.bb.errors),925646:i=>a.wb(i),925679:i=>a.yb(i),925711:(i,c,f)=>{a.jb(i,c,f,!0)},925750:(i,c,f)=>{a.jb(i,c,f)}};function ct(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Tt(i){i.terminate(),i.onmessage=()=>{}}function Ot(i){(i=ne.Qa[i])||Ke(),ne.Eb(i)}function Wt(i){var c=ne.tb();if(!c)return 6;ne.Ya.push(c),ne.Qa[i.Xa]=c,c.Xa=i.Xa;var f={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return S&&c.unref(),c.postMessage(f,i.Mb),0}var _t=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,cr=(i,c,f)=>{c>>>=0;var $=c+f;for(f=c;i[f]&&!(f>=$);)++f;if(16<f-c&&i.buffer&&_t)return _t.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,f):i.subarray(c,f));for($="";c<f;){var I=i[c++];if(I&128){var P=i[c++]&63;if((I&224)==192)$+=String.fromCharCode((I&31)<<6|P);else{var V=i[c++]&63;I=(I&240)==224?(I&15)<<12|P<<6|V:(I&7)<<18|P<<12|V<<6|i[c++]&63,65536>I?$+=String.fromCharCode(I):(I-=65536,$+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else $+=String.fromCharCode(I)}return $},Ve=(i,c)=>(i>>>=0)?cr(o(),i,c):"";function zt(i){if(A)return G(1,1,i);Ie=i,Xe()||(ne.Hb(),a.onExit&&a.onExit(i),Oe=!0),w(i,new ct(i))}var Vt=i=>{if(Ie=i,A)throw pr(i),"unwind";zt(i)},ne={ab:[],Ya:[],mb:[],Qa:{},gb:function(){A?ne.vb():ne.ub()},ub:function(){Ue.unshift(()=>{Bt(),ne.Bb(()=>lr())})},vb:function(){ne.receiveObjectTransfer=ne.Db,ne.threadInitTLS=ne.lb,ne.setExitStatus=ne.kb,ae=!1},kb:function(i){Ie=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ne.Ya)Tt(i);for(i of ne.ab)Tt(i);ne.ab=[],ne.Ya=[],ne.Qa=[]},Eb:function(i){var c=i.Xa;delete ne.Qa[c],ne.ab.push(i),ne.Ya.splice(ne.Ya.indexOf(i),1),i.Xa=0,en(c)},Db:function(){},lb:function(){ne.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=P=>{P=P.data;var V=P.cmd;if(P.targetThread&&P.targetThread!=Sr()){var oe=ne.Qa[P.Rb];oe?oe.postMessage(P,P.transferList):K(\'Internal error! Worker sent a message "\'+V+\'" to target pthread \'+P.targetThread+", but that thread no longer exists!")}else V==="checkMailbox"?$t():V==="spawnThread"?Wt(P):V==="cleanupThread"?Ot(P.thread):V==="killThread"?(P=P.thread,V=ne.Qa[P],delete ne.Qa[P],Tt(V),en(P),ne.Ya.splice(ne.Ya.indexOf(V),1),V.Xa=0):V==="cancelThread"?ne.Qa[P.thread].postMessage({cmd:"cancel"}):V==="loaded"?(i.loaded=!0,c(i)):V==="alert"?alert("Thread "+P.threadId+": "+P.text):P.target==="setimmediate"?i.postMessage(P):V==="callHandler"?a[P.handler](...P.args):V&&K("worker sent an unknown command "+V)},i.onerror=P=>{throw K("worker sent an error! "+P.filename+":"+P.lineno+": "+P.message),P},S&&(i.on("message",function(P){i.onmessage({data:P})}),i.on("error",function(P){i.onerror(P)}));var f=[],$=["onExit","onAbort","print","printErr"],I;for(I of $)a.hasOwnProperty(I)&&f.push(I);i.postMessage({cmd:"load",handlers:f,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Se})}),Bb:function(i){i()},qb:function(){var i=W("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ne.ab.push(i)},tb:function(){return ne.ab.length==0&&(ne.qb(),ne.Cb(ne.ab[0])),ne.ab.pop()}};a.PThread=ne;var st=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=function(){var i=Sr(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],Zn(c,c-i),Cr(c)};function pr(i){if(A)return G(2,0,i);Vt(i)}a.invokeEntryPoint=function(i,c){i=Qn.apply(null,[i,c]),Xe()?ne.kb(i):tn(i)};function Je(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,f){this.nb(),this.pb(c),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var He=0,fr=0;function wt(i,c,f,$){return A?G(3,1,i,c,f,$):Gt(i,c,f,$)}function Gt(i,c,f,$){if(i>>>=0,c>>>=0,f>>>=0,$>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var I=[];return A&&I.length===0?wt(i,c,f,$):(i={Gb:f,Xa:i,rb:$,Mb:I},A?(i.Ob="spawnThread",postMessage(i,I),0):Wt(i))}function Nt(i,c,f){return A?G(4,1,i,c,f):0}function mr(i,c){if(A)return G(5,1,i,c)}var vt=i=>{for(var c=0,f=0;f<i.length;++f){var $=i.charCodeAt(f);127>=$?c++:2047>=$?c+=2:55296<=$&&57343>=$?(c+=4,++f):c+=3}return c},hr=(i,c,f,$)=>{if(f>>>=0,!(0<$))return 0;var I=f;$=f+$-1;for(var P=0;P<i.length;++P){var V=i.charCodeAt(P);if(55296<=V&&57343>=V){var oe=i.charCodeAt(++P);V=65536+((V&1023)<<10)|oe&1023}if(127>=V){if(f>=$)break;c[f++>>>0]=V}else{if(2047>=V){if(f+1>=$)break;c[f++>>>0]=192|V>>6}else{if(65535>=V){if(f+2>=$)break;c[f++>>>0]=224|V>>12}else{if(f+3>=$)break;c[f++>>>0]=240|V>>18,c[f++>>>0]=128|V>>12&63}c[f++>>>0]=128|V>>6&63}c[f++>>>0]=128|V&63}}return c[f>>>0]=0,f-I},gr=(i,c,f)=>hr(i,o(),c,f);function yr(i,c){if(A)return G(6,1,i,c)}function br(i,c,f){if(A)return G(7,1,i,c,f)}function wr(i,c,f){return A?G(8,1,i,c,f):0}function vr(i,c){if(A)return G(9,1,i,c)}function Rt(i,c,f){if(A)return G(10,1,i,c,f)}function Ut(i,c,f,$){if(A)return G(11,1,i,c,f,$)}function Lt(i,c,f,$){if(A)return G(12,1,i,c,f,$)}function Ft(i,c,f,$){if(A)return G(13,1,i,c,f,$)}function Ht(i){if(A)return G(14,1,i)}function jt(i,c){if(A)return G(15,1,i,c)}function Kt(i,c,f){if(A)return G(16,1,i,c,f)}var qt=i=>{if(!Oe)try{if(i(),!Xe())try{A?tn(Ie):Vt(Ie)}catch(c){c instanceof ct||c=="unwind"||w(1,c)}}catch(c){c instanceof ct||c=="unwind"||w(1,c)}};function Pt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then($t),i+=128,Atomics.store(n(),i>>2,1))}a.__emscripten_thread_mailbox_await=Pt;function $t(){var i=Sr();i&&(Pt(i),qt(()=>Xn()))}a.checkMailbox=$t;var pt=i=>i%4===0&&(i%100!==0||i%400===0),xt=[0,31,60,91,121,152,182,213,244,274,305,335],Yt=[0,31,59,90,120,151,181,212,243,273,304,334];function l(i,c,f,$,I,P,V,oe){return A?G(17,1,i,c,f,$,I,P,V,oe):-52}function p(i,c,f,$,I,P,V){if(A)return G(18,1,i,c,f,$,I,P,V)}var h=i=>{var c=vt(i)+1,f=Qr(c);return f&&gr(i,f,c),f},C=[],T=(i,c)=>{C.length=0;var f;for(c>>=2;f=o()[i++>>>0];)c+=f!=105&c,C.push(f==105?n()[c>>>0]:d()[c++>>>1]),++c;return C},U=i=>{var c=rn();return i=i(),Cr(c),i};function G(i,c){var f=arguments.length-2,$=arguments;return U(()=>{for(var I=nn(8*f),P=I>>3,V=0;V<f;V++){var oe=$[2+V];d()[P+V>>>0]=oe}return Yn(i,f,I,c)})}var ue=[],Y={},Q=()=>{if(!J){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"},c;for(c in Y)Y[c]===void 0?delete i[c]:i[c]=Y[c];var f=[];for(c in i)f.push(`${c}=${i[c]}`);J=f}return J},J;function ce(i,c){if(A)return G(19,1,i,c);i>>>=0,c>>>=0;var f=0;return Q().forEach(function($,I){var P=c+f;for(I=s()[i+4*I>>2>>>0]=P,P=0;P<$.length;++P)r()[I++>>0>>>0]=$.charCodeAt(P);r()[I>>0>>>0]=0,f+=$.length+1}),0}function me(i,c){if(A)return G(20,1,i,c);i>>>=0,c>>>=0;var f=Q();s()[i>>2>>>0]=f.length;var $=0;return f.forEach(function(I){$+=I.length+1}),s()[c>>2>>>0]=$,0}function E(i){return A?G(21,1,i):52}function te(i,c,f,$){return A?G(22,1,i,c,f,$):52}function fe(i,c,f,$,I){return A?G(23,1,i,c,f,$,I):70}var ut=[null,[],[]];function Xt(i,c,f,$){if(A)return G(24,1,i,c,f,$);c>>>=0,f>>>=0,$>>>=0;for(var I=0,P=0;P<f;P++){var V=s()[c>>2>>>0],oe=s()[c+4>>2>>>0];c+=8;for(var ee=0;ee<oe;ee++){var Z=o()[V+ee>>>0],re=ut[i];Z===0||Z===10?((i===1?B:K)(cr(re,0)),re.length=0):re.push(Z)}I+=oe}return s()[$>>2>>>0]=I,0}var Nn=[31,29,31,30,31,30,31,31,30,31,30,31],Un=[31,28,31,30,31,30,31,31,30,31,30,31];function du(i){var c=Array(vt(i)+1);return hr(i,c,0,c.length),c}var cu=(i,c)=>{r().set(i,c>>>0)};function Ln(i,c,f,$){function I(O,se,ye){for(O=typeof O=="number"?O.toString():O||"";O.length<se;)O=ye[0]+O;return O}function P(O,se){return I(O,se,"0")}function V(O,se){function ye(ao){return 0>ao?-1:0<ao?1:0}var St;return(St=ye(O.getFullYear()-se.getFullYear()))===0&&(St=ye(O.getMonth()-se.getMonth()))===0&&(St=ye(O.getDate()-se.getDate())),St}function oe(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ee(O){var se=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<se;){var ye=O.getMonth(),St=(pt(O.getFullYear())?Nn:Un)[ye];if(se>St-O.getDate())se-=St-O.getDate()+1,O.setDate(1),11>ye?O.setMonth(ye+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+se);break}}return ye=new Date(O.getFullYear()+1,0,4),se=oe(new Date(O.getFullYear(),0,4)),ye=oe(ye),0>=V(se,O)?0>=V(ye,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}i>>>=0,c>>>=0,f>>>=0,$>>>=0;var Z=n()[$+40>>2>>>0];$={Kb:n()[$>>2>>>0],Jb:n()[$+4>>2>>>0],cb:n()[$+8>>2>>>0],ib:n()[$+12>>2>>>0],eb:n()[$+16>>2>>>0],$a:n()[$+20>>2>>>0],Wa:n()[$+24>>2>>>0],Za:n()[$+28>>2>>>0],Tb:n()[$+32>>2>>>0],Ib:n()[$+36>>2>>>0],Lb:Z?Ve(Z):""},f=Ve(f),Z={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in Z)f=f.replace(new RegExp(re,"g"),Z[re]);var he="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");Z={"%a":O=>he[O.Wa].substring(0,3),"%A":O=>he[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>P((O.$a+1900)/100|0,2),"%d":O=>P(O.ib,2),"%e":O=>I(O.ib,2," "),"%g":O=>ee(O).toString().substring(2),"%G":O=>ee(O),"%H":O=>P(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),P(O,2)),"%j":O=>{for(var se=0,ye=0;ye<=O.eb-1;se+=(pt(O.$a+1900)?Nn:Un)[ye++]);return P(O.ib+se,3)},"%m":O=>P(O.eb+1,2),"%M":O=>P(O.Jb,2),"%n":()=>`\n`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>P(O.Kb,2),"%t":()=>"\t","%u":O=>O.Wa||7,"%U":O=>P(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var se=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&se++,se)se==53&&(ye=(O.Wa+371-O.Za)%7,ye==4||ye==3&&pt(O.$a)||(se=1));else{se=52;var ye=(O.Wa+7-O.Za-1)%7;(ye==4||ye==5&&pt(O.$a%400-1))&&se++}return P(se,2)},"%w":O=>O.Wa,"%W":O=>P(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var se=0<=O;return O=Math.abs(O)/60,(se?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(re in Z)f.includes(re)&&(f=f.replace(new RegExp(re,"g"),Z[re]($)));return f=f.replace(/\\0\\0/g,"%"),re=du(f),re.length>c?0:(cu(re,i),re.length-1)}function $r(i){try{i()}catch(c){Ke(c)}}function pu(i){var c={},f;for(f in i)(function($){var I=i[$];c[$]=typeof I=="function"?function(){xr.push($);try{return I.apply(null,arguments)}finally{Oe||(xr.pop()===$||Ke(),Ze&&ft===1&&xr.length===0&&(ft=0,Ge+=1,$r(to),typeof Fibers<"u"&&Fibers.Ub()))}}:I})(f);return c}var ft=0,Ze=null,Fn=0,xr=[],Hn={},jn={},fu=0,Zr=null,mu=[];function hu(){return new Promise((i,c)=>{Zr={resolve:i,reject:c}})}function gu(){var i=Qr(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=xr[0];var f=Hn[c];return f===void 0&&(f=fu++,Hn[c]=f,jn[f]=c),c=f,n()[i+8>>2>>>0]=c,i}function yu(){var i=n()[Ze+8>>2>>>0];return i=j[jn[i]],--Ge,i()}function bu(i){if(!Oe){if(ft===0){var c=!1,f=!1;i(($=0)=>{if(!Oe&&(Fn=$,c=!0,f)){ft=2,$r(()=>ro(Ze)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),$=!1;try{var I=yu()}catch(oe){I=oe,$=!0}var P=!1;if(!Ze){var V=Zr;V&&(Zr=null,($?V.reject:V.resolve)(I),P=!0)}if($&&!P)throw I}}),f=!0,c||(ft=1,Ze=gu(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),$r(()=>eo(Ze)))}else ft===2?(ft=0,$r(no),Kn(Ze),Ze=null,mu.forEach($=>qt($))):Ke(`invalid state: ${ft}`);return Fn}}function wu(i){return bu(c=>{i().then(c)})}ne.gb();var vu=[null,zt,pr,wt,Nt,mr,yr,br,wr,vr,Rt,Ut,Lt,Ft,Ht,jt,Kt,l,p,ce,me,E,te,fe,Xt],$u={r:function(i,c,f){return wu(async()=>{await a.xb(i,c,f)})},b:function(i,c,f){throw i>>>=0,new Je(i).gb(c>>>0,f>>>0),He=i,fr++,He},O:function(i){qn(i>>>0,!y,1,!v,131072,!1),ne.lb()},l:function(i){i>>>=0,A?postMessage({cmd:"cleanupThread",thread:i}):Ot(i)},I:Gt,i:Nt,U:mr,E:yr,G:br,V:wr,S:vr,K:Rt,R:Ut,p:Lt,F:Ft,C:Ht,T:jt,D:Kt,q:()=>!0,A:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>$t()):A?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ne.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Pt,X:function(i){S&&ne.Qa[i>>>0].ref()},u:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getUTCSeconds(),n()[f+4>>2>>>0]=i.getUTCMinutes(),n()[f+8>>2>>>0]=i.getUTCHours(),n()[f+12>>2>>>0]=i.getUTCDate(),n()[f+16>>2>>>0]=i.getUTCMonth(),n()[f+20>>2>>>0]=i.getUTCFullYear()-1900,n()[f+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>2>>>0]=i},v:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getSeconds(),n()[f+4>>2>>>0]=i.getMinutes(),n()[f+8>>2>>>0]=i.getHours(),n()[f+12>>2>>>0]=i.getDate(),n()[f+16>>2>>>0]=i.getMonth(),n()[f+20>>2>>>0]=i.getFullYear()-1900,n()[f+24>>2>>>0]=i.getDay(),c=(pt(i.getFullYear())?xt:Yt)[i.getMonth()]+i.getDate()-1|0,n()[f+28>>2>>>0]=c,n()[f+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var $=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=$&&i.getTimezoneOffset()==Math.min($,c))|0,n()[f+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),f=n()[i+32>>2>>>0],$=c.getTimezoneOffset(),I=new Date(c.getFullYear(),6,1).getTimezoneOffset(),P=new Date(c.getFullYear(),0,1).getTimezoneOffset(),V=Math.min(P,I);return 0>f?n()[i+32>>2>>>0]=+(I!=P&&V==$):0<f!=(V==$)&&(I=Math.max(P,I),c.setTime(c.getTime()+6e4*((0<f?V:I)-$))),n()[i+24>>2>>>0]=c.getDay(),f=(pt(c.getFullYear())?xt:Yt)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=f,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,Jn((it=i,1<=+Math.abs(it)?0<it?+Math.floor(it/4294967296)>>>0:~~+Math.ceil((it-+(~~it>>>0))/4294967296)>>>0:0)),i>>>0},s:l,t:p,z:function(i,c,f){function $(Z){return(Z=Z.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Z[1]:"GMT"}i>>>=0,c>>>=0,f>>>=0;var I=new Date().getFullYear(),P=new Date(I,0,1),V=new Date(I,6,1);I=P.getTimezoneOffset();var oe=V.getTimezoneOffset(),ee=Math.max(I,oe);s()[i>>2>>>0]=60*ee,n()[c>>2>>>0]=+(I!=oe),i=$(P),c=$(V),i=h(i),c=h(c),oe<I?(s()[f>>2>>>0]=i,s()[f+4>>2>>>0]=c):(s()[f>>2>>>0]=c,s()[f+4>>2>>>0]=i)},d:()=>{Ke("")},c:function(i,c,f){return i>>>=0,c=T(c>>>0,f>>>0),Et[i].apply(null,c)},k:function(i,c,f){return i>>>=0,c=T(c>>>0,f>>>0),Et[i].apply(null,c)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ge+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return S?(fo(),Mt(po)).cpus().length:navigator.hardwareConcurrency},L:function(i,c,f,$){for(ne.Pb=c>>>0,ue.length=f,c=$>>>0>>3,$=0;$<f;$++)ue[$]=d()[c+$>>>0];return(0>i?Et[-i-1]:vu[i]).apply(null,ue)},y:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var f=1;4>=f;f*=2){var $=c*(1+.2/f);$=Math.min($,i+100663296);var I=Math;$=Math.max(i,$);e:{I=I.min.call(I,4294901760,$+(65536-$%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(I),pe();var P=1;break e}catch{}P=void 0}if(P)return!0}return!1},P:ce,Q:me,H:Vt,h:E,o:te,x:fe,n:Xt,a:we||a.wasmMemory,J:Ln,e:function(i,c,f,$){return Ln(i>>>0,c>>>0,f>>>0,$>>>0)}};(function(){function i(f,$){return f=f.exports,f=pu(f),j=f=xu(f),ne.mb.push(j.Da),Te.unshift(j.Y),Se=$,lr(),f}var c={a:$u};if(Bt(),a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(f){K("Module.instantiateWasm callback failed with error: "+f),g(f)}return dr(c,function(f){i(f.instance,f.module)}).catch(g),{}})(),a._OrtInit=(i,c)=>(a._OrtInit=j.Z)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=j._)(i,c),a._OrtCreateSessionOptions=(i,c,f,$,I,P,V,oe,ee,Z)=>(a._OrtCreateSessionOptions=j.$)(i,c,f,$,I,P,V,oe,ee,Z),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=j.aa)(i,c),a._OrtAddFreeDimensionOverride=(i,c,f)=>(a._OrtAddFreeDimensionOverride=j.ba)(i,c,f),a._OrtAddSessionConfigEntry=(i,c,f)=>(a._OrtAddSessionConfigEntry=j.ca)(i,c,f),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=j.da)(i),a._OrtCreateSession=(i,c,f)=>(a._OrtCreateSession=j.ea)(i,c,f),a._OrtReleaseSession=i=>(a._OrtReleaseSession=j.fa)(i),a._OrtGetInputOutputCount=(i,c,f)=>(a._OrtGetInputOutputCount=j.ga)(i,c,f),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=j.ha)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=j.ia)(i,c),a._OrtFree=i=>(a._OrtFree=j.ja)(i),a._OrtCreateTensor=(i,c,f,$,I,P)=>(a._OrtCreateTensor=j.ka)(i,c,f,$,I,P),a._OrtGetTensorData=(i,c,f,$,I)=>(a._OrtGetTensorData=j.la)(i,c,f,$,I),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=j.ma)(i),a._OrtCreateRunOptions=(i,c,f,$)=>(a._OrtCreateRunOptions=j.na)(i,c,f,$),a._OrtAddRunConfigEntry=(i,c,f)=>(a._OrtAddRunConfigEntry=j.oa)(i,c,f),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=j.pa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=j.qa)(i),a._OrtBindInput=(i,c,f)=>(a._OrtBindInput=j.ra)(i,c,f),a._OrtBindOutput=(i,c,f,$)=>(a._OrtBindOutput=j.sa)(i,c,f,$),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=j.ta)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=j.ua)(i),a._OrtRunWithBinding=(i,c,f,$,I)=>(a._OrtRunWithBinding=j.va)(i,c,f,$,I),a._OrtRun=(i,c,f,$,I,P,V,oe)=>(a._OrtRun=j.wa)(i,c,f,$,I,P,V,oe),a._OrtEndProfiling=i=>(a._OrtEndProfiling=j.xa)(i),a._JsepOutput=(i,c,f)=>(a._JsepOutput=j.ya)(i,c,f),a._JsepGetNodeName=i=>(a._JsepGetNodeName=j.za)(i);var Sr=a._pthread_self=()=>(Sr=a._pthread_self=j.Aa)(),Qr=a._malloc=i=>(Qr=a._malloc=j.Ba)(i),Kn=a._free=i=>(Kn=a._free=j.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=j.Da)();var qn=a.__emscripten_thread_init=(i,c,f,$,I,P)=>(qn=a.__emscripten_thread_init=j.Fa)(i,c,f,$,I,P);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=j.Ga)();var Yn=(i,c,f,$)=>(Yn=j.Ha)(i,c,f,$),en=i=>(en=j.Ia)(i),tn=a.__emscripten_thread_exit=i=>(tn=a.__emscripten_thread_exit=j.Ja)(i),Xn=a.__emscripten_check_mailbox=()=>(Xn=a.__emscripten_check_mailbox=j.Ka)(),Jn=i=>(Jn=j.La)(i),Zn=(i,c)=>(Zn=j.Ma)(i,c),rn=()=>(rn=j.Na)(),Cr=i=>(Cr=j.Oa)(i),nn=i=>(nn=j.Pa)(i),Qn=a.dynCall_ii=(i,c)=>(Qn=a.dynCall_ii=j.Ra)(i,c),eo=i=>(eo=j.Sa)(i),to=()=>(to=j.Ta)(),ro=i=>(ro=j.Ua)(i),no=()=>(no=j.Va)();a.___start_em_js=925783,a.___stop_em_js=925944;function xu(i){i=Object.assign({},i);var c=$=>()=>$()>>>0,f=$=>I=>$(I)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=f(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=f(i.stackAlloc),i}a.keepRuntimeAlive=Xe,a.wasmMemory=we,a.stackAlloc=nn,a.stackSave=rn,a.stackRestore=Cr,a.UTF8ToString=Ve,a.stringToUTF8=gr,a.lengthBytesUTF8=vt,a.ExitStatus=ct,a.PThread=ne;var Ar;bt=function i(){Ar||oo(),Ar||(bt=i)};function oo(){function i(){if(!Ar&&(Ar=!0,a.calledRun=!0,!Oe)&&(A||st(Te),m(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!A)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();ke.unshift(c)}st(ke)}}if(!(0<Fe))if(A)m(a),A||st(Te),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Ue.unshift(a.preRun.shift());st(Ue),0<Fe||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),i()},1)):i())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return oo(),t.ready}})();typeof ho=="object"&&typeof cn=="object"?cn.exports=mo:typeof define=="function"&&define.amd&&define([],()=>mo)});var yo=Jt((mc,_u)=>{_u.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var mn,Qt,er,Tr,tr,So,hn,De=H(()=>{"use strict";mn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Qt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},er=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Tr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},tr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},So=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",hn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Vu,Gu,Co,Ao,Io,Nu,Ee,mt=H(()=>{"use strict";De();Vu=["V","I","W","E","F"],Gu=(e,t)=>{console.log(`[${Vu[e]},${new Date().toISOString()}]${t}`)},Io=(e,t)=>{Co=e,Ao=t},Nu=(e,t)=>{let r=tr(e),o=tr(Co);r>=o&&Gu(r,typeof t=="function"?t():t)},Ee=(...e)=>{Ao&&Nu(...e)}});var Eo,To=H(()=>{"use strict";De();Eo=(e,t)=>new(Tr(t))(e)});var Oo=H(()=>{"use strict"});var Or,Uu,_o,yn,gn,Ro,Po=H(()=>{"use strict";mt();Oo();Or=e=>Math.ceil(e/16)*16,Uu=1,_o=()=>Uu++,yn=async(e,t,r,o)=>{let n=Or(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let d=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(d,0,r)),a}else return new Uint8Array(d.slice(0,r))}finally{s.destroy()}},gn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Or(s),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=a.getMappedRange();new Uint8Array(m).set(new Uint8Array(o,n,s)),a.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(a,0,d.gpuData.buffer,0,u),Ee("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Or(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=_o();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ee("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Or(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,m=a.get(o);m||(m=[],a.set(o,m)),m.length>0?n=m.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let d={id:_o(),type:0,buffer:n};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Ee("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ee("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await yn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Ro=(...e)=>new gn(...e)});var bn,ie,Pe=H(()=>{"use strict";bn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ie=e=>new bn(e)});var wn,Qe,k,Ct,_r,Rr,Pr,ge=H(()=>{"use strict";wn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},Qe=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),d=new Array(u);if(o){if(n<2||s<2)return;let a=wn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[d[u-2],d[u-1]]=a}for(let a=o?3:1;a<=u;a++){let m=n-a<0?1:t[n-a],g=s-a<0?1:r[s-a];if(m!==g&&m>1&&g>1)return;d[u-a]=Math.max(m,g)}return d}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},k=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},Ct=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<n.length){if(n[d]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let d=0;d<o.length;d++)if(d<s.length){if(s[d]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let d=0;d<o.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=o[d]||u[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,d){if(d){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,d)}}static computePoolOutputShape(t,r,o,n,s,u,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,d),a}static computeConvOutputShape(t,r,o,n,s,u,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,d),a}static computeShapeHelper(t,r,o,n,s,u,d,a){if(t)for(let m=0;m<r.length-2;m++)o.push(1);else for(let m=0;m<r.length-2;m++)o.push(e.adjustPadAndReturnShape(r[m+2],n[m],s[m],u[m],d,m,m+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,d,a){let m=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[d]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let x=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(x+1)/2:x/2),s[d]=x-s[u],Math.floor((t+x-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[d]-m)/r+1)}},_r=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,d,a;r?(u=t[1],d=t[0]):(u=t[0],d=t[1]);let m=-1;if(n?(a=o[0],m=1):(a=o[1],m=0),o[m]!==d)throw new Error("dimension mismatch");if(u<=0||a<=0||d<=0)throw new Error("invalid shape specified");if(s&&!Qe.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,d]}},Rr=-34028234663852886e22,Pr=34028234663852886e22});var Lu,Mo,Me,$n,lt,qe,At,ht,Bo,L,X,vn,ko,xn,Do,ve=H(()=>{"use strict";De();ge();Lu=64,Mo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Me=(e,t=1)=>{let r=Mo(e,t);return typeof r=="string"?r:r[0]},$n=e=>[{type:"uint32",data:e},{type:"uint32",data:k.computeStrides(e)}],lt=e=>e%4===0?4:e%2===0?2:1,qe=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,At=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,ht=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Bo=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,d=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,m=Mo(t,n),g=typeof m=="string"?m:m[1],x=typeof m=="string"?m:m[0],b={indices:a,value:g,storage:x,tensor:t},w=N=>typeof N=="string"?N:`${N}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=s?"uniforms.":"",S=`${y}${e}_shape`,A=`${y}${e}_strides`,R="";for(let N=0;N<u-1;N++)R+=`\n    let dim${N} = current / ${A}[${N}];\n    let rest${N} = current % ${A}[${N}];\n    indices[${N}] = dim${N};\n    current = rest${N};\n    `;R+=`indices[${u-1}] = current;`;let W=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${R}\n    return indices;\n  }`,M=N=>(v.offsetToIndices=!0,u<2?N:`o2i_${e}(${N})`),D=[];if(u>=2)for(let N=u-1;N>=0;N--)D.push(`${A}[${N}] * (indices[${N}])`);let _=u<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${D.join("+")};\n  }`,z=N=>(v.indicesToOffset=!0,u<2?N:`i2o_${e}(${N})`),F=(...N)=>u===0?"0u":`${b.indices}(${N.map(w).join(",")})`,q=(N,de)=>u<2?`${N}`:`${N}[${de}]`,le=(N,de,pe)=>u<2?`${N}=${pe};`:`${N}[${de}]=${pe};`,B={},K=(N,de)=>{v.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in B)return`${pe}(${N})`;let ze=[];for(let Ue=u-1;Ue>=0;Ue--){let Te=de.indicesGet("outputIndices",Ue+de.rank-u);ze.push(`${q(A,Ue)} * (${Te} % ${q(S,Ue)})`)}return B[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {\n             return ${ze.length>0?ze.join("+"):"0u"};\n           }`,`${pe}(${N})`},xe=(N,de)=>(()=>{if(b.storage===b.value)return`${e}[${N}]=${de};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${N}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${N}]=vec2<u32>(u32(${de}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${N}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ae=N=>(()=>{if(b.storage===b.value)return`${e}[${N}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${N}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${N}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${N}] & 0xFFu), bool(${e}[${N}] & 0xFF00u), bool(${e}[${N}] & 0xFF0000u), bool(${e}[${N}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),we=u<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${g} {\n    return ${ae(`i2o_${e}(indices)`)};\n  }`,j=u<2?"":(()=>{let N=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn get_${e}(${N}) -> ${g} {\n    return get_${e}ByIndices(${F(de)});\n  }`})(),Se=(...N)=>{if(N.length!==u)throw new Error(`indices length must be ${u}`);let de=N.map(w).join(",");return u===0?ae("0u"):u===1?ae(de[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${de})`)},Oe=N=>u<2?ae(N):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${N})`),Ie=u<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${g}) {\n    ${xe(`i2o_${e}(indices)`,"value")}\n  }`,Ce=u<2?"":(()=>{let N=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn set_${e}(${N}, value: ${g}) {\n    set_${e}ByIndices(${F(de)}, value);\n  }`})();return{impl:()=>{let N=[];return s||(N.push(`const ${S} = ${b.indices}(${r.join(",")});`),N.push(`const ${A} = ${b.indices}(${k.computeStrides(r).join(",")});`)),v.offsetToIndices&&N.push(W),v.indicesToOffset&&N.push(_),v.broadcastedIndicesToOffset&&Object.values(B).forEach(de=>N.push(de)),v.set&&N.push(Ce),v.setByIndices&&N.push(Ie),v.get&&N.push(j),v.getByIndices&&N.push(we),N.join(`\n`)},type:b,offsetToIndices:M,indicesToOffset:z,broadcastedIndicesToOffset:K,indices:F,indicesGet:q,indicesSet:le,set:(...N)=>{if(N.length!==u+1)throw new Error(`indices length must be ${u}`);let de=N[u];if(typeof de!="string")throw new Error("value must be string");let pe=N.slice(0,u).map(w).join(",");return u===0?xe("0u",de):u===1?xe(pe[0],de):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:xe,setByIndices:(N,de)=>u<2?xe(N,de):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${N}, ${de});`),get:Se,getByOffset:ae,getByIndices:Oe,usage:o?"input":"output",name:e,strides:A,shape:S,rank:u}},L=(e,t,r,o=1)=>Bo(e,t,r,!0,o),X=(e,t,r,o=1)=>Bo(e,t,r,!1,o),vn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Lu){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,d=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*o*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${d}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},ko=e=>new vn(e),xn=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},Do=e=>e<=4});var Fu,Wo,Hu,ju,gt,zo,Vo,rr=H(()=>{"use strict";ge();Pe();ve();Fu=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Wo=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Hu=(e,t)=>k.sortBasedOnPerm(e,Wo(e.length,t)),ju=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},gt=(e,t)=>{let r=e.dataType,o=e.dims.length,n=Wo(o,t),s=Do(o),u=Hu(e.dims,n),d=s?u.length:u,a=s?o:e.dims,m=X("output",r,d),g=L("a",r,a),x=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(g,m)}\n\n  ${ju(n,o,g,m)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",g.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:b=>{let w=k.size(u);return{outputs:[{dims:u,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:s?[{type:"uint32",data:w},...$n(b[0].dims),...$n(u)]:[{type:"uint32",data:w}]}},getShaderSource:x}},zo=(e,t)=>{Fu(e.inputs),e.compute(gt(e.inputs[0],t.perm))},Vo=e=>ie({perm:e.perm})});var Ku,qu,Yu,Xu,Ju,Zu,Qu,el,tl,rl,et,Go,No,Uo,Lo,Fo,Ho,jo,Ko,qo,Yo,Xo=H(()=>{"use strict";ge();ve();Mr();rr();Ku={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},qu={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Yu={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Xu={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Ju=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Zu=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},Qu=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},el=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},tl=(e,t)=>{let r=[];if(!el(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},rl=(e,t,r,o,n,s,u)=>{let d=r[0].dims,a=k.size(s),m=k.size(u),g=L("_A",r[0].dataType,d),x=X("output",n,s),b=32,w=`\n          var<workgroup> aBestValues : array<${x.type.storage}, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:y=>`\n        ${y.registerUniform("reduceSize","u32").declareVariables(g,x)}\n        ${w}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${y.mainStart(b)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${x.type.storage}(${Yu[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = ${x.type.storage}(${g.getByOffset("offset + k")});\n           bestValue = ${Ku[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${qu[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${x.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${x.type.storage}(uniforms.reduceSize)`:`${Xu[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:m}]})}},et=(e,t,r,o)=>{let n=e.inputs.length===1?r:Sn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((w,v)=>v));let u=k.normalizeAxes(s,e.inputs[0].dims.length),d=u,a=e.inputs[0],m=tl(d,e.inputs[0].dims.length);m.length>0&&(a=e.compute(gt(e.inputs[0],m),{inputs:[0],outputs:[-1]})[0],d=Ju(d.length,a.dims.length));let[g,x]=Zu(a.dims,d),b=g;n.keepDims&&(b=Qu(g,u)),e.compute(rl(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,b,x),{inputs:[a]})},Go=(e,t)=>{et(e,"ReduceMeanShared",t,"mean")},No=(e,t)=>{et(e,"ReduceL1Shared",t,"l1")},Uo=(e,t)=>{et(e,"ReduceL2Shared",t,"l2")},Lo=(e,t)=>{et(e,"ReduceLogSumExpShared",t,"logSumExp")},Fo=(e,t)=>{et(e,"ReduceMaxShared",t,"max")},Ho=(e,t)=>{et(e,"ReduceMinShared",t,"min")},jo=(e,t)=>{et(e,"ReduceProdShared",t,"prod")},Ko=(e,t)=>{et(e,"ReduceSumShared",t,"sum")},qo=(e,t)=>{et(e,"ReduceSumSquareShared",t,"sumSquare")},Yo=(e,t)=>{et(e,"ReduceLogSumShared",t,"logSum")}});var tt,nl,Br,Sn,rt,ol,al,il,sl,ul,ll,dl,cl,pl,fl,nt,Jo,Zo,Qo,ea,ta,ra,na,oa,aa,ia,Ye,Mr=H(()=>{"use strict";ge();Pe();ve();Xo();tt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},nl=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Br=(e,t,r,o,n,s,u=!1,d=!1)=>{let a=[],m=r[0].dims,g=k.normalizeAxes(n,r[0].dims.length),x=!d&&g.length===0;m.forEach((z,F)=>{x||g.indexOf(F)>=0?u&&a.push(1):a.push(z)});let b=[],w=L("_A",r[0].dataType,m),v=X("output",s,a),y=o(w,v,g),S=`inputOffset = ${w.indicesToOffset("inputIndices")};`,A=`let ${S};`,R=`var ${S};`,W=y[1]===""?"":R,M=(y[1]===""?A:S)+`\n`+y[2];for(let z=0,F=0;z<r[0].dims.length;z++)x||g.indexOf(z)>=0?(u&&F++,M=`for(var j${z}: u32 = 0; j${z} < ${r[0].dims[z]}; j${z}++) {\n                ${y[2].includes("lastIndex")?`let lastIndex = j${z};`:""}\n                ${w.indicesSet("inputIndices",z,`j${z}`)}\n                ${M}\n              }`):(b.push(`${w.indicesSet("inputIndices",z,v.indicesGet("outputIndices",F))};`),F++);let D=k.size(a);return{name:e,shaderCache:t,getShaderSource:z=>`\n        ${z.declareVariables(w,v)}\n\n        ${z.mainStart()}\n          ${z.guardAgainstOutOfBoundsWorkgroupSizes(D)}\n          var inputIndices: ${w.type.indices};\n          let outputIndices = ${v.offsetToIndices("global_idx")};\n\n          ${b.join(`\n`)}\n          ${y[0]}       // init ops for reduce max/min\n          ${W}\n          ${y[1]}\n          ${M}\n          ${y[3]}\n          ${y.length===4?v.setByOffset("global_idx","value"):y.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(D/64)}})}},Sn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ie({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rt=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:Sn(n,r);e.compute(Br(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?nl:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},ol=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},al=(e,t)=>{tt(e.inputs),rt(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},il=(e,t)=>{tt(e.inputs),rt(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},sl=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},ul=(e,t)=>{tt(e.inputs),rt(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(o.indicesSet("inputIndices",d,0));return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},ll=(e,t)=>{tt(e.inputs),rt(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&(u*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},dl=(e,t)=>{tt(e.inputs),rt(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`inputIndices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},cl=(e,t)=>{tt(e.inputs),rt(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},pl=(e,t)=>{tt(e.inputs),rt(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},fl=(e,t)=>{tt(e.inputs),rt(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},nt=(e,t,r)=>{if(t.length===0)return!!r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},Jo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ll(e,t):Go(e,t)},Zo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?al(e,t):No(e,t)},Qo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?il(e,t):Uo(e,t)},ea=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?sl(e,t):Lo(e,t)},ta=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ul(e,t):Fo(e,t)},ra=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dl(e,t):Ho(e,t)},na=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cl(e,t):jo(e,t)},oa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pl(e,t):Ko(e,t)},aa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fl(e,t):qo(e,t)},ia=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ol(e,t):Yo(e,t)},Ye=e=>ie(e)});var sa,ua,la,da,Cn,ca=H(()=>{"use strict";De();Pe();Mr();sa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},ua=(e,t)=>ie({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),la=(e,t)=>{sa(e.inputs);let r=(n,s,u)=>{let d=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&d.push(`inputIndices[${a}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ua(e.inputs,t);e.compute(Br("ArgMin",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},da=(e,t)=>{sa(e.inputs);let r=(n,s,u)=>{let d=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&d.push(`inputIndices[${a}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ua(e.inputs,t);e.compute(Br("argMax",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Cn=e=>ie(e)});var ml,hl,pa,fa=H(()=>{"use strict";ge();ve();ml=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hl=e=>{let t=e[0].dims,r=e[0].dims[2],o=k.size(t)/4,n=e[0].dataType,s=L("input",n,t,4),u=L("bias",n,[r],4),d=L("residual",n,t,4),a=X("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:g=>`\n  const channels = ${r}u / 4;\n  ${g.declareVariables(s,u,d,a)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},pa=e=>{ml(e.inputs),e.compute(hl(e.inputs))}});var gl,$e,ma,ha,ga,ya,ba,wa,va,$a,xa,An,yl,Sa,Ca,Aa,Ia,kr,Ea,Dr,Ta,Oa,_a,Ra,Pa,Ma,Ba,ka,Da,Wa,za,Va,Ga,Na,Ua,La,Fa,In=H(()=>{"use strict";De();ge();Pe();ve();gl=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),d="";typeof n=="string"?d=`${n}(a)`:d=n("a");let a=L("inputData",r,[u],4),m=X("outputData",o,[u],4);return`\n  ${e.declareVariables(a,m)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx",d)}\n  }`},$e=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n},getShaderSource:u=>gl(u,k.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(k.size(u[0].dims)/64/4)}})}),ma=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},ha=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},ga=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},ya=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},ba=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},wa=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},va=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},$a=e=>ie(e),xa=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},An=(e,t)=>{let r=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},yl=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Rr,r=e.length>=3?e[2].getFloat32Array()[0]:Pr;return ie({min:t,max:r})},Sa=e=>{let t=yl(e.inputs);An(e,t)},Ca=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},Aa=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},Ia=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},kr=e=>ie(e),Ea=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Dr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Ta=e=>{let t=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Dr(`vec4<${t}>`,t)))},Oa=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},_a=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},Ra=e=>{let t=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Dr(`vec4<${t}>`,t)))},Pa=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},Ma=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},Ba=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},ka=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Da=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},Wa=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},za=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},Va=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},Ga=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},Na=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},Ua=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},La=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),Fa=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var wl,vl,Ha,ja=H(()=>{"use strict";ge();ve();In();wl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},vl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=L("input",e[0].dataType,e[0].dims,4),o=L("bias",e[0].dataType,[e[0].dims[2]],4),n=X("output",e[0].dataType,t,4),s=k.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:d=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${d.declareVariables(r,o,n)}\n\n  ${Dr("vec4f")}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ha=e=>{wl(e.inputs),e.compute(vl(e.inputs))}});var $l,xl,ot,Ka,qa,Ya,Xa,Ja,Za,Qa,ei,ti,ri,ni=H(()=>{"use strict";De();ge();ve();$l=(e,t,r,o,n,s,u,d,a,m,g)=>{let x=k.size(o),b=Math.ceil(x/4),w,v;typeof u=="string"?w=v=(M,D)=>`${u}((${M}),(${D}))`:typeof u=="function"?w=v=u:(w=u.scalar,v=u.vector);let y="",S=X("outputData",m,o,4),A=L("aData",d,t,4),R=L("bData",a,r,4);if(s){let M=D=>{let _=k.computeStrides(D),z=[];for(let F=D.length-1;F>=0;F--){let q=S.indicesGet("outputIndices",F+o.length-D.length);z.push(`${_[F]}u * (${q} % ${D[F]}u)`)}return z.length>0?z.join("+"):"0u"};y=`\n          fn calcOffsetA(outputIndices: ${S.type.indices}) -> u32 {\n            return ${M(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${S.type.indices}) -> u32 {\n            return ${M(r)};\n          }\n        `}let W;if(n)if(s){let M=k.size(t)===1,D=k.size(r)===1;M||D?W=S.setByOffset("global_idx",v(M?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"),D?`${R.type.value}(${R.getByOffset("0")}.x)`:R.getByOffset("global_idx"))):W=`\n            let outputIndices = ${S.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${S.setByOffset("global_idx",v(A.getByOffset("offsetA / 4u"),R.getByOffset("offsetB / 4u")))}\n          `}else W=S.setByOffset("global_idx",v(A.getByOffset("global_idx"),R.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let M=(D,_,z="")=>{let F=`aData[indexA${_}][componentA${_}]`,q=`bData[indexB${_}][componentB${_}]`;return`\n            let outputIndices${_} = ${S.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offsetA${_} = calcOffsetA(outputIndices${_});\n            let offsetB${_} = calcOffsetB(outputIndices${_});\n            let indexA${_} = offsetA${_} / 4u;\n            let indexB${_} = offsetB${_} / 4u;\n            let componentA${_} = offsetA${_} % 4u;\n            let componentB${_} = offsetB${_} % 4u;\n            ${D}[${_}] = ${z}(${w(F,q)});\n          `};m===9?W=`\n            var data = vec4<u32>(0);\n            ${M("data",0,"u32")}\n            ${M("data",1,"u32")}\n            ${M("data",2,"u32")}\n            ${M("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:W=`\n            ${M("outputData[global_idx]",0)}\n            ${M("outputData[global_idx]",1)}\n            ${M("outputData[global_idx]",2)}\n            ${M("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(A,R,S)}\n\n        ${g??""}\n        ${y}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        ${W}\n      }`},xl=(e,t,r,o,n,s,u=r.dataType)=>{let d=!k.areEqual(r.dims,o.dims),a=r.dims,m=k.size(r.dims),g=!1;if(d){let x=Qe.calcShape(r.dims,o.dims,!1);if(!x)throw new Error("Can\'t perform binary op on the given tensors");a=x,m=k.size(a);let b=k.size(r.dims)===1,w=k.size(o.dims)===1,v=1;for(let y=1;y<a.length;y++){let S=r.dims[r.dims.length-y]??1,A=o.dims[o.dims.length-y]??1;if(S===A)v*=S;else break}(v%4===0||b||w)&&(g=!0)}else g=!0;return{name:e,shaderCache:{hint:t},getShaderSource:x=>$l(x,r.dims,o.dims,a,g,d,n,r.dataType,o.dataType,u,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(m/64/4)}})}},ot=(e,t,r,o,n,s)=>{e.compute(xl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},Ka=e=>{ot(e,"Add",(t,r)=>`${t}+${r}`)},qa=e=>{ot(e,"Div",(t,r)=>`${t}/${r}`)},Ya=e=>{ot(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Xa=e=>{ot(e,"Mul",(t,r)=>`${t}*${r}`)},Ja=e=>{let t=L("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ot(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Za=e=>{ot(e,"Sub",(t,r)=>`${t}-${r}`)},Qa=e=>{ot(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},ei=e=>{ot(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},ti=e=>{ot(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},ri=e=>{ot(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Cl,Al,Il,El,oi,ai,ii=H(()=>{"use strict";ge();Pe();ve();Cl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},Al=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Il=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},El=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let w=1;w<e.length;w++){let v=e[w].dims.slice();for(let y=0;y<r.length;y++)if(y===o)n[o]+=v[y];else if(r[y]!==v[y])throw new Error("non concat dimensions must match")}let s=k.size(n),u=new Array(e.length),d=new Array(e.length),a=e[0].dataType,m=0;for(let w=0;w<e.length;++w)m+=e[w].dims[o],u[w]=m,d[w]=L(`input${w}`,a,e[w].dims);let g=X("output",a,n),x=g.indicesGet("indices",o),b=w=>`\n  ${w.declareVariables(...d,g)}\n\n  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map(v=>`${v}u`).join(",")});\n  ${Al(u.length)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n\n    var indices = ${g.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${x});\n    if (inputIndex != 0u) {\n      ${x} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Il(d,g)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:b}},oi=(e,t)=>{Cl(e.inputs),e.compute(El(e.inputs,t.axis))},ai=e=>ie({axis:e.axis})});var We,Wr,zr,Vr=H(()=>{"use strict";We=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Wr=(e,t=!1,r=!1,o=3)=>"",zr=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `});var Gr,En=H(()=>{"use strict";Gr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Nr,Ur,nr=H(()=>{"use strict";ge();Nr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Ur=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Rr,Pr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var Tl,Ol,or,si,_l,ar,Rl,Lr,ir=H(()=>{"use strict";ge();ve();nr();Vr();Tl=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Ol=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,or=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32)=>{let a=t[1]*e[1],m=t[0]*e[0],g=n?a:s,x=n?s:a,b=g/t[0],w=s/t[1];if(!((n&&b===4&&e[1]===4||!n&&(b===3||b===4))&&g%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${g/b}>, ${x}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${w};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Tl(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Ol(n,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},si=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,_l=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",ar=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32,a=!1)=>{let m=e[1]*t[1],g=e[0]*t[0],x=n?m:s,b=n?s:m;if(!(b%t[1]===0&&x%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${x} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=b/t[1],v=x/t[0],y=s/t[1],S=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${m};\n    let globalColStart = i32(workgroupId.x) * ${g};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${x}; inputCol = inputCol + ${t[0]}) {\n          ${si(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${m};\n\nlet tileRowA = i32(localId.y) * ${w};\nlet tileColA = i32(localId.x) * ${v};\nlet tileRowB = i32(localId.y) * ${y};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${si(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${_l(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${x}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${S}\n  }\n`},Rl=(e,t,r,o,n,s=!1)=>{let u=n[0],d=n[1],a=n[2],m=o[0],g=o[1],x=o[2],b=o[3],w=xn(u,a),v=xn(d,a),y=Me(o[0].type.tensor),S=()=>{let W=g.rank,M=m.rank,D=`var aIndices: ${g.type.indices};`;for(let _=W-2-1,z=M-1;_>=0;_--,z--)D+=`\naIndices[${_}] = ${M>1?`batchIndices[${z}]`:"batchIndices"};`;return w.forEach(_=>{D+=`\naIndices[${_}] = 0;`}),D+=`\naIndices[${W-2}] = u32(row);\n                   aIndices[${W-1}] = u32(colIn);`,D},A=()=>{let W=x.rank,M=m.rank,D=`var bIndices: ${x.type.indices};`;for(let _=W-2-1,z=M-1;_>=0;_--,z--)D+=`\nbIndices[${_}] = ${M>1?`batchIndices[${z}]`:"batchIndices"};`;return v.forEach(_=>{D+=`\nbIndices[${_}] = 0;`}),D+=`\nbIndices[${W-2}] = u32(row);\n                   bIndices[${W-1}] = u32(colIn);`,D};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,y)} {\n      var value = ${We(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${S()}\n        value = ${g.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,y)} {\n      var value = ${We(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${A()}\n        value = ${x.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${We(e,y)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${We(e,y)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Lr=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s.slice(0,-2),a=u.slice(0,-2),m=o?o.slice(0,-2):r.slice(0,-2),g=L("batchDims",e[0].dataType,m),x=[g],b=[d,a,m],w=k.size(m),v=s[s.length-2],y=s[s.length-1],S=u[u.length-1],A=y%4===0&&S%4===0,{activationFunction:R,applyActivation:W}=Nr(t,A),M=v<=8?[4,1,1]:[4,4,1],D=[8,8,1],_=[Math.ceil(S/D[0]/M[0]),Math.ceil(v/D[1]/M[1]),Math.ceil(w/D[2]/M[2])],z=Me(e[0].dataType),F=A?4:1,q=L("a",e[0].dataType,[...d,v,y/F],F),le=L("b",e[1].dataType,[...a,y,S/F],F),B=X("result",e[0].dataType,[w,v,S/F],F);x.push(q),x.push(le),x.push(B);let K=[q,le],xe=e.length>2,ae=Rl(F,xe,W,x,b,n);if(xe){let j=n?F:1;K.push(L("bias",e[2].dataType,e[2].dims,j))}let we=j=>`\n  const dimAOuter: i32 = ${v};\n  const dimBOuter: i32 = ${S};\n  const dimInner: i32 = ${y};\n  ${j.declareVariables(...K,B)}\n  ${R}\n  ${ae}\n  ${A?or(M,D,z,g):ar(M,D,z,g)}\n                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]}}),getShaderSource:we}}});var Pl,ui,li=H(()=>{"use strict";mt();ge();ve();Vr();En();ir();Pl=(e,t,r,o,n=!1,s,u=!1,d=4,a=4,m=4,g="f32")=>{let x=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},b=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,v=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"xShape[1]":"xShape[2]",S=e?"xShape[2]":"xShape[3]",A=e?"row":"col",R=e?"col":"row",W=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${R} / (filterDims[1] * inChannels);\n    let WCol = ${R} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${R} % inChannels;\n    var resData = ${We(d,g)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${S}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${x(d)}\n    }\n    return resData;`,M=e?t&&o?`\n    let col = colIn * ${d};\n    ${W}`:`\n    let col = colIn * ${d};\n    if (row < dimAOuter && col < dimInner) {\n      ${W}\n    }\n    return ${We(d,g)}(0.0);`:o&&r?`\n    let col = colIn * ${d};\n    ${W}`:`\n    let col = colIn * ${d};\n    if (row < dimInner && col < dimBOuter) {\n      ${W}\n    }\n    return ${We(d,g)}(0.0);`,D=`${b(a)}`,_=We(m,g),z=e?We(d,g):We(a,g),F=e?We(a,g):We(d,g);return`\n    ${Wr(s,u,m===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${z} {\n      ${e?M:D}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${F} {\n      ${e?D:M}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${m};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${v}\n      ${zr(n,s)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ui=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",m=a?e[0].dims[3]:e[0].dims[1],g=r[0],x=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],v=a&&(m%4===0||m%3===0)&&w%4===0,y=a?w:x*b,S=a?x*b:w,A=[8,8,1],R=o<=8?[4,1,1]:[4,4,1],W=[Math.ceil(y/A[0]/R[0]),Math.ceil(S/A[1]/R[1]),Math.ceil(g/A[2]/R[2])];Ee("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${W}`);let M=v?a&&m%4!==0?3:4:R[0],D=A[1]*R[1],_=A[0]*R[0],z=Math.max(A[0]*M,A[1]),F=o%D===0,q=n%_===0,le=s%z===0,B=v?[M,4,4]:[1,1,1],K=Me(e[0].dataType),xe=[`@group(0) @binding(0) var<storage, read> x: array<${v&&M===4?`vec4<${K}>`:K}>;`,`@group(0) @binding(1) var<storage, read> w: array<${v?`vec4<${K}>`:K}>;`],ae=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${K}>`:K}) {\n        result[flatIndex] = ${v?`vec4<${K}>`:K}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${K}>`:K}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`;return u&&(xe.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?`vec4<${K}>`:K}>;`),ae+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${K}>`:K} {\n          return bias[coords.${a?"w":"y"}${v?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${Gr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${xe.join("")}\n        @group(0) @binding(${xe.length}) var<storage, read_write> result: array<${v?`vec4<${K}>`:K}>;\n        //@group(0) @binding(${xe.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${ae}\n        ${Pl(a,F,q,le,u,t.activation.toLowerCase(),!1,B[0],B[1],B[2],K)}\n            ${v?or(R,A,K,void 0,!a,z):ar(R,A,K,void 0,!a,z,!1,void 0,d)}`}}});var Tn,di=H(()=>{"use strict";ge();ve();_n();nr();Tn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,d=u[0]/t.group,{activationFunction:a,applyActivation:m}=Nr(t),g=t.format==="NHWC",x=On(s,u,t.dilations,t.pads,t.strides,g),b=k.size(x),w=X("output",e[0].dataType,x),v=L("x",e[0].dataType,s),y=L("w",e[1].dataType,u),S=[v,y];o&&S.push(L("b",e[2].dataType,e[2].dims));let A=R=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${R.declareVariables(...S,w)}\n\n  ${a}\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n    let outputIndices = ${w.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${g?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${w.type.value} = ${w.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[g?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[g?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${g?v.get("batch","xHeight","xWidth","input_channel"):v.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${y.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${m}\n    ${w.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(x):x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:A}}});var On,ci,Ml,pi,Rn,Bl,kl,Pn,_n=H(()=>{"use strict";ge();Pe();li();ir();di();nr();rr();On=(e,t,r,o,n,s)=>{let u=e[0],d=e.slice(s?1:2,s?3:4),a=d.length,m=t[0],x=t.slice(2).map((v,y)=>v+(v-1)*(r[y]-1)),w=d.map((v,y)=>v+o[y]+o[y+a]).map((v,y)=>Math.floor((v-x[y]+n[y])/n[y]));return w.splice(0,0,u),w.splice(s?3:1,0,m),w},ci=[2,3,1,0],Ml=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},pi=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();Ct.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},Rn=e=>{let t=Ur(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,d=e.pads,a=e.strides,m=e.w_is_const();return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:d,strides:a,wIsConst:m,...t})},Bl=(e,t,r)=>{let o=pi(r,t);if(r.group!==1){e.compute(Tn(t,o));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],d=t[0].dims[n?2:3],a=t[0].dims[n?3:1],m=t[1].dims[2],g=t[1].dims[3],x=On(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),b=x[n?1:2],w=x[n?2:3],v=x[n?3:1],y=n&&m===u&&g===d&&r.pads[0]===0&&r.pads[1]===0;if(y||m===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let _=x[0],z,F,q,le=[];if(n){let B=e.kernelCustomData.wT??e.compute(gt(t[1],ci),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=B),y){let K=u*d*a;z=t[0].reshape([1,_,K]),F=B.reshape([1,K,v]),q=[1,_,v]}else z=t[0].reshape([_,u*d,a]),F=B.reshape([1,a,v]),q=[_,b*w,v];le.push(z),le.push(F)}else z=t[0].reshape([_,a,u*d]),F=t[1].reshape([1,v,a]),q=[_,v,b*w],le.push(F),le.push(z);s&&le.push(t[2]),e.compute(Lr(le,o,x,q,n),{inputs:le});return}let S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],ci),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let R=[t[0],A];s&&R.push(t[2]);let W=n?b*w:v,M=n?v:b*w,D=m*g*a;e.compute(ui(R,o,x,W,M,D,s,S),{inputs:R})},kl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),d=[1].concat(t.kernelShape),a=pi({...t,pads:n,strides:s,dilations:u,kernelShape:d},o);e.compute(Tn(o,a,m=>r?[m[0],m[2],m[3]]:[]))},Pn=(e,t)=>{Ml(e.inputs,t),e.inputs[0].dims.length===3?kl(e,t):Bl(e,e.inputs,t)}});var Dl,fi,mi=H(()=>{"use strict";mt();ge();Vr();En();ir();Dl=(e,t=!1,r,o=!1,n=4)=>{let s=We(n,"f32"),u=A=>{switch(A){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${A} is not supported.`)}},d=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,a=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"outBackprop[1]":"outBackprop[2]",g=e?"outBackprop[2]":"outBackprop[3]",x=e?"row":"col",b=e?"col":"row",w=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${x} / outWidth;\n      let outCol = ${x} % outWidth;\n\n      let WRow = ${b} / (filterDims[1] * inChannels);\n      let WCol = ${b} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${b} % inChannels;\n      ${d}\n      return x[getIndexFromCoords4D(coord, xShape)/${n}];`,v=e?`\n      let col = colIn * ${n};\n      if (row < dimAOuter && col < dimInner) {\n        ${w}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${n};\n      if (row < dimInner && col < dimBOuter) {\n        ${w}\n      }\n      return ${s}(0.0);`,y=`\n      let col = colIn * ${n};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(n)}\n      }\n      return ${s}(0.0);\n      `;return`\n  ${Wr(r,o,n===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?v:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?y:v}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${n};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${a}\n      ${zr(t,r)}\n      result[getIndexFromCoords4D(coords, outShape)/${n}] = value;\n    }\n  }`},fi=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",m=a?e[0].dims[3]:e[0].dims[1],g=r[0],x=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],v=a?m%4===0&&w%4===0:x%4===0&&w%4===0,y=a?w:x*b,S=a?x*b:w,A=v?[8,8,1]:[y<=4||S<=4?4:16,y>4&&S<=4?4:16,1],R=v?[4,4,1]:[y<=4?1:4,y>4&&S<=4?1:4,1],W=[Math.ceil(y/A[0]/R[0]),Math.ceil(S/A[1]/R[1]),Math.ceil(g/A[2]/R[2])];Ee("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${W}`);let M=v?4:1,D=Math.max(A[0]*M,A[1]),_=[`@group(0) @binding(0) var<storage, read> x: array<${v?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],z="";return u&&(_.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?"vec4<f32>":"f32"}>;`),z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?"vec4<f32>":"f32"} {\n          return bias[coords.${a?"w":"y"}${v?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${Gr}\n        ${_.join(`\n`)}\n        @group(0) @binding(${_.length}) var<storage, read_write> result: array<${v?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${z}\n        ${Dl(a,u,t.activation.toLowerCase(),!1,M)}\n        ${v?or(R,A,"f32",void 0,!a,D):ar(R,A,"f32",void 0,!a,D,!1,void 0,d)}`}}});var Wl,Mn,hi=H(()=>{"use strict";mt();ge();ve();Wl=(e,t,r,o,n,s,u=!1,d)=>{let a=r.format==="NHWC",m=a?1:2,g=a?2:3,x=a?3:1,b=k.size(o),w=u?2:1,v=r.group,y=t[1].dims,S=y[0]/v,A=y[1],R=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${u?`vec4<${d}>`:d}(value);\n  }`;n&&(R+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${d}>`:d} {\n      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];\n    }`);let W=u?4:1,M=L("W",t[1].dataType,t[1].dims,W),D=L("Dy",t[0].dataType,t[0].dims,W),_=[D,M];n&&_.push(L("bias",t[2].dataType,[o[x]],W));let z=X("result",t[0].dataType,o,W),F=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${D.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${x}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${z.set("batch","r","c + i","d1","value")};\n        }\n      }`,q=`\n          let outputIndices = ${z.offsetToIndices("global_idx")};\n          let batch = ${z.indicesGet("outputIndices",0)};\n          let d1 = ${z.indicesGet("outputIndices",x)};\n          let r = ${z.indicesGet("outputIndices",m)};\n          let c = ${z.indicesGet("outputIndices",g)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${A};\n          let wOutChannel = d1 - groupId * ${A};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${m}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${g}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${S};\n              for (var d2: u32 = 0; d2 < ${S}; d2 = d2 + 1) {\n                let xValue = ${a?D.get("batch","idyR","idyC","inputChannel"):D.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${M.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${z.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(..._,z)}\n  ${R}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${u?F:q}}`},Mn=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=k.size(n),u=[Math.ceil(s/64),1,1];Ee("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let d=Me(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>Wl(a,e,t,n,o,u[1]===1&&u[2]===1,!1,d)}}});var zl,Vl,Gl,gi,yi,Nl,Ul,Ll,Fl,bi,wi=H(()=>{"use strict";Pe();mi();hi();nr();rr();zl=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,Vl=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},Gl=(e,t,r,o,n,s,u,d,a,m)=>{let g=e.length-2,x=m.length===0;if(a.length===0)for(let v=0;v<g;++v)a.push(0);let b=e[0],w=t[d?3:1]*n;for(let v=0,y=e.length-g-(d?1:0);v<g;++v,++y){let S=e[y],A=x?S*u[v]:m[v],R=zl(S,u[v],s[v],t[y],r[v],A);Vl(R,o,s,v,v+g),x&&m.push(u[v]*(S-1)+a[v]+(t[y]-1)*r[v]+1-s[v]-s[v+g])}m.splice(0,0,b),m.splice(d?3:1,0,w)},gi=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,w)=>b*w,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),d=t[0].dims,a=e.dilations.slice();if(a.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;a=new Array(b).fill(1)}let m=e.strides.slice();if(m.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;m=new Array(b).fill(1)}Gl(d,r,a,e.autoPad,e.group,n,m,o,u,s);let g=Object.assign({},e),x=e.cacheKey+[r.join("n,"),n.join(","),m.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:m,cacheKey:x}),g},yi=e=>{let t=Ur(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,d=e.pads,a=e.strides,m=e.wIsConst(),g=e.outputPadding,x=e.outputShape;return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:g,outputShape:x,pads:d,strides:a,wIsConst:m,...t})},Nl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((g,x)=>g+x,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((g,x)=>g+x,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((g,x)=>g+x,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((g,x)=>g+x,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ul=[2,3,1,0],Ll=(e,t,r)=>{let o=gi(r,t),n=r.format==="NHWC",s=t.length===3;if(o.group!==1){e.compute(Mn(t,o));return}let u=o.outputShape,d=u[n?1:2],a=u[n?2:3],m=u[n?3:1],g=t[1].dims[2],x=t[1].dims[3],b=t[0].dims[n?3:1],w=n?d*a:m,v=n?m:d*a,y=g*x*b,S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],Ul),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let R=[t[0],A];s&&(!n&&t[2].dims.length===1?R.push(t[2].reshape([t[2].dims[0],1,1])):R.push(t[2])),e.compute(fi(R,o,u,w,v,y,s,S),{inputs:R})},Fl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=gi({...t,pads:d,strides:u,dilations:s,kernelShape:n},o);e.compute(Mn(o,a,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},bi=(e,t)=>{Nl(e.inputs,t),e.inputs[0].dims.length===3?Fl(e,t):Ll(e,e.inputs,t)}});var Bn,Fr,vi,Hl,jl,kn,Dn,Kl,$i,xi,Si=H(()=>{"use strict";ge();Pe();ve();Bn="[a-zA-Z]|\\\\.\\\\.\\\\.",Fr="("+Bn+")+",vi="^"+Fr+"$",Hl="("+Fr+",)*"+Fr,jl="^"+Hl+"$",kn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Dn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(jl)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,a)=>{let m=t[a].dims.slice();if(!d.match(RegExp(vi)))throw new Error("Invalid LHS term");let g=this.processTerm(d,!0,m,a);this.lhs.push(g)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([d,a])=>a.count===1||d==="...").map(([d])=>d).join("");else if(!n.match(RegExp(Fr)))throw new Error("Invalid RHS");n.match(RegExp(Bn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(d);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,d=[],a=0;if(!t.match(RegExp(vi))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(Bn,"g")),g=new kn(n);return m?.forEach((x,b)=>{if(x==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-m.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(a,a+w),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<d.length;v++){let y=String.fromCharCode("0".charCodeAt(0)+b);g.addSymbol(y,b+v),this.addSymbol(y,o[a++],n)}}else g.addSymbol(x,b),this.addSymbol(x,o[a++],n)}),g}},Kl=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let W=0;W<e.length;++W)o[W]=L(`input${W}`,r,e[W].dims);let n=t.outputDims,s=k.size(n),u=X("output",r,n),d=[],a=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",g="var sum = 0.0;",x="sum += prod;",b=[],w=[],v=[],y=[],S=t.symbolToInfo.size===a.length;t.symbolToInfo.forEach((W,M)=>{if(a.includes(M)){let D=a.indexOf(M);t.lhs.forEach((_,z)=>{if(W.inputIndices.includes(z)){let F=_.symbolToIndices.get(M);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(q=>{d.push(`${o[z].indicesSet(`input${z}Indices`,q,u.indicesGet("outputIndices",D))}`)})}})}else t.lhs.forEach((D,_)=>{let z=t.symbolToInfo.get(M);if(z===void 0)throw new Error("Invalid symbol error");if(z.inputIndices.includes(_)){let F=D.symbolToIndices.get(M);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(q=>{b.push(`${o[_].indicesSet(`input${_}Indices`,q,`${M}`)}`)}),y.push(`prod *= ${o[_].getByIndices(`input${_}Indices`)};`)}}),w.push(`for(var ${M}: u32 = 0; ${M} < ${t.symbolToInfo.get(M)?.dimValue}; ${M}++) {`),v.push("}")});let A=S?[...d,`let sum = ${o.map((W,M)=>W.getByIndices(`input${M}Indices`)).join(" * ")};`]:[...d,g,...w,...b,m,...y,x,...v],R=W=>`\n      ${W.declareVariables(...o,u)}\n\n      ${W.mainStart()}\n        ${W.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${u.offsetToIndices("global_idx")};\n        ${o.map((M,D)=>`var input${D}Indices: ${o[D].type.indices};`).join(`\n`)}\n        ${A.join(`\n`)};\n        ${u.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:R}},$i=(e,t)=>{let r=new Dn(e.inputs,t.equation);e.compute(Kl(e.inputs,r))},xi=e=>{let t=e.equation.replace(/\\s+/g,"");return ie({equation:t})}});var ql,Ci,Yl,Xl,Ai,Ii=H(()=>{"use strict";ge();ve();ql=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Ci=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},Yl=(e,t)=>e.length>t.length?Ci(e,t):Ci(t,e),Xl=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Yl(t,r),n=k.size(o),s=e[0].dataType,u=L("input",s,t),d=X("output",s,o),a=m=>`\n  const inputShape = ${u.indices(...t)};\n  ${m.declareVariables(u,d)}\n  ${m.mainStart()}\n  ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    var inputIndices: ${u.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${u.indicesGet("inputShape","i")} == 1) {\n        ${u.indicesSet("inputIndices","i",0)}\n      } else {\n        ${u.indicesSet("inputIndices","i",d.indicesGet("outputIndices",`i + ${o.length-t.length}`))}\n      }\n    }\n    ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:a,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Ai=e=>{ql(e.inputs),e.compute(Xl(e.inputs),{inputs:[0]})}});var Jl,Zl,Ei,Ti,Oi=H(()=>{"use strict";ge();Pe();ve();Jl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Zl=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=k.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let d=r[s],a=k.size(u),m=L("data",e[0].dataType,e[0].dims),g=L("inputIndices",e[1].dataType,e[1].dims),x=X("output",e[0].dataType,u),b=()=>{let v=o.length,y=`var indicesIndices  = ${g.type.indices}(0);`;for(let S=0;S<v;S++)y+=`${v>1?`indicesIndices[${S}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+S}]`:"outputIndices"};`;y+=`\n        var idx = ${g.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${d};\n        }\n        var dataIndices = ${m.type.indices}(0);\n      `;for(let S=0,A=0;S<n;S++)S===s?(y+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = u32(idx);`,A+=v):(y+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = ${u.length>1?`outputIndices[${A}]`:"outputIndices"};`,A++);return y},w=v=>`\n      ${v.declareVariables(m,g,x)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n        let outputIndices = ${x.offsetToIndices("global_idx")};\n        ${b()};\n        let value = ${m.getByIndices("dataIndices")};\n        ${x.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:w}},Ei=e=>ie({axis:e.axis}),Ti=(e,t)=>{let r=e.inputs;Jl(r),e.compute(Zl(e.inputs,t))}});var Ql,ed,_i,Ri,Pi=H(()=>{"use strict";ge();Pe();ve();Ql=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},ed=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=k.computeStrides(r),u=k.size(r),d=e[1].dims,a=e[1].dataType,m=k.size(d),g=k.normalizeAxis(t.axis,n),x=r[g],b=d.slice(0),w=k.size(b),v=L("input",o,r),y=L("indices",a,[m]),S=X("output",o,b),A=R=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(W=>`${W}u`).join(",")});\n      ${R.declareVariables(v,y,S)}\n      ${R.mainStart()}\n      ${R.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n\n      let outputIndices = ${S.offsetToIndices("global_idx")};\n\n      var idx = ${y.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${x};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${g}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${S.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${u}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:A}},_i=e=>ie({axis:e.axis}),Ri=(e,t)=>{let r=e.inputs;Ql(r),e.compute(ed(e.inputs,t))}});var td,rd,nd,Mi,Bi,ki=H(()=>{"use strict";ge();Pe();ve();td=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},rd=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},nd=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=_r.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[n,s];if(!d)throw new Error("Can\'t use gemm on the given tensors");let a=k.size(d),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let g=Me(e[0].dataType),x=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${rd(n,s,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let v=y=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${g}(${t.alpha});\n  const beta = ${g}(${t.beta});\n\n  ${w.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${g}>;\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${g}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${m}\n    }\n\n    ${x}\n    ${b}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:v}},Mi=(e,t)=>{td(e.inputs),e.compute(nd(e.inputs,t))},Bi=e=>ie(e)});var od,ad,id,sd,Di,Wi,zi=H(()=>{"use strict";De();ge();Pe();ve();od={name:"InstanceNormalization"},ad=(e,t)=>{let r=e[0].dims,o=r,n=2,s=k.sizeToDimension(r,n),u=k.sizeFromDimension(r,n),d=r[1],a=L("x",e[0].dataType,[r[0],r[1],u]),m=L("scale",e[1].dataType,e[1].dims),g=L("bias",e[2].dataType,e[2].dims),x=X("output",e[0].dataType,[r[0],r[1],u]),b=[a,m,g,x],w=a.type.value,v=64,y=S=>`\n\n  const C: u32 = ${d};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${w};\n  var<workgroup> squaredNormShared : ${w};\n  var<workgroup> workgroupShared : array<${w}, ${v}>;\n  const workgroupSize = ${v}u;\n  ${S.declareVariables(...b)}\n  ${S.mainStart(v)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${w} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${a.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${w}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${a.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${w}(normSize) + epsilon);\n    let channelScale = invStdDev * ${m.getByOffset("channel")};\n    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${a.get("batch","channel","h")} * channelScale + channelShift;\n      ${x.set("batch","channel","h","value")};\n    }\n  }`;return{...od,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:y}},id=(e,t,r,o,n,s,u,d)=>{let a=lt(u),m=L("input",t.dataType,t.dims,a),g=L("scale",r.dataType,r.dims,a),x=L("bias",o.dataType,o.dims,a),b=64,w=a===1?"vec2f":`mat2x${a}f`,v=a===1?"f32":`vec${a}f`,y=(D,_)=>`${w}(${D}, ${_})`,S=n*u/a,A=Math.ceil(s/b),R=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${s*u/a};\n\n  ${D.declareVariables(m)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart(b)}\n    let currentImageNumber = global_idx / ${b} / C;\n    let currentChannelNumber = (global_idx / ${b}) % C;\n    let wgId = global_idx % ${b};\n    let wgOffset = wgId * ${A};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${A}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${qe("f32",a)};\n    var squaredSum = ${qe("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${v}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${y("sum","squaredSum")};\n  }`,W=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,b,2],dataType:1}],dispatchGroup:{x:n*u/a}}),getShaderSource:R},{inputs:[t],outputs:[-1]})[0],M=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${b*u/a};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${w}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${g.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${x.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart()}\n    ${D.guardAgainstOutOfBoundsWorkgroupSizes(S)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${qe("f32",a)};\n    var squaredSum = ${qe("f32",a)};\n    for (var i: u32 = 0; i < ${b}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${b}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${v}(scale[currentChannelNumber]);\n    let channelShift = ${v}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${y("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u,epsilon:d})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:M},{inputs:[W,r,o],outputs:[-1]})[0]},sd=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],d=k.sizeFromDimension(o,1)/u,a=lt(u),m=k.size(n)/a,g=L("input",t[0].dataType,t[0].dims,a),x=X("output",t[0].dataType,n,a),b=Me(t[0].dataType),w=a===1?"vec2f":`mat2x${a}f`,v=a===1?b:`vec${a}<${b}>`,y=id(e,t[0],t[1],t[2],s,d,u,r.epsilon),S=A=>`\n  const H: u32 = ${d};\n  const C: u32 = ${u/a};\n\n  @group(0) @binding(0) var<storage, read> input : array<${g.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${x.type.storage}>;\n\n  ${A.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${v}(scale[0]), ${v}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:S},{inputs:[t[0],y]})},Di=e=>ie({epsilon:e.epsilon,format:e.format}),Wi=(e,t)=>{t.format==="NHWC"?sd(e,e.inputs,t):e.compute(ad(e.inputs,t))}});var ud,ld,Vi,Gi,Ni=H(()=>{"use strict";De();ge();Pe();ve();ud=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ld=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,d=k.normalizeAxis(t.axis,o.length),a=k.sizeToDimension(o,d),m=k.sizeFromDimension(o,d),g=k.size(n.dims),x=s?k.size(s.dims):0;if(g!==m||s&&x!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${g} and bias size of ${x}`);let b=[];for(let M=0;M<o.length;++M)M<d?b.push(o[M]):b.push(1);let w=lt(m),v=Me(e[0].dataType),y=[L("x",e[0].dataType,e[0].dims,w),L("scale",n.dataType,n.dims,w)];s&&y.push(L("bias",s.dataType,s.dims,w)),y.push(X("output",e[0].dataType,u,w));let S=r>1,A=r>2;S&&y.push(X("meanDataOutput",1,b)),A&&y.push(X("invStdOutput",1,b));let R=M=>`\n  const normSize: f32 = ${m};\n  const normSizeVectorized: u32 = ${m/w};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${M.declareVariables(...y)}\n  ${M.mainStart()}\n    ${M.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${qe("f32",w)};\n    var meanSquareVector = ${qe("f32",w)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${At(v,w,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${ht("meanVector",w)} / normSize;\n    let meanSquare = sqrt(${ht("meanSquareVector",w)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${At(v,w,"x[j + offset]")};\n      let f32scale = ${At(v,w,"scale[j]")};\n      output[j + offset] = ${y[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${At(v,w,"bias[j]")}`:""}\n      );\n    }\n\n    ${S?"meanDataOutput[global_idx] = mean":""};\n    ${A?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,W=[{dims:u,dataType:e[0].dataType}];return S&&W.push({dims:b,dataType:1}),A&&W.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:R}},Vi=e=>ie({axis:e.axis,epsilon:e.epsilon}),Gi=(e,t)=>{ud(e.inputs),e.compute(ld(e.inputs,t,e.outputCount))}});var dd,Ui,Li=H(()=>{"use strict";ge();ir();dd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Ui=e=>{dd(e.inputs);let t=Qe.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(Lr(e.inputs,{activation:"",activationCacheKey:""},t))}});var cd,pd,fd,md,hd,gd,yd,bd,wd,Fi,Hi,ji=H(()=>{"use strict";De();ge();Pe();ve();cd=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},pd=(e,t,r,o,n,s,u)=>{let d=r.length,a="";for(let m=d-1;m>=0;--m)a+=`\n            k = i32(${e.indicesGet("indices",m)}) - ${n[m]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[m]}) {\n              break;\n            }\n            offset += k * ${o[m]};\n        `;return`\n          value = ${s}(${u});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${a}\n            value = x[offset];\n          }\n      `},fd=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[d]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[d]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},md=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[d]}) {\n                  k = ${r[d]-1};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},hd=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0)  {\n                  k += ${r[d]};\n                }\n                if (k >= ${r[d]}) {\n                  k -= ${r[d]};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},gd=(e,t,r,o,n,s)=>{switch(n.mode){case 0:return pd(e,t,r,o,n.pads,s,n.value);case 1:return fd(e,t,r,o,n.pads);case 2:return md(e,t,r,o,n.pads);case 3:return hd(e,t,r,o,n.pads);default:throw new Error("Invalid mode")}},yd=(e,t,r,o)=>{let n=t[0].dims,s=k.padShape(n.slice(),r.pads),u=k.size(s),d=k.computeStrides(n),a=X("output",t[0].dataType,s),m=L("x",t[0].dataType,n),g=gd(a,s,n,d,r,o);return`\n              ${e.declareVariables(m,a)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${a.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${g}\n              output[global_idx] = value;\n          }`},bd=(e,t)=>{let r=k.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(r)/64)}}),getShaderSource:o=>yd(o,e,t,"f32")}},wd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let a=0;a<d.length;a++)s[Number(d[a])]=Number(r[a]),s[Number(d[a])+n]=Number(r[a+d.length])}else r.forEach((d,a)=>s[Number(a)]=Number(d));let u=[];return s.forEach(d=>u.push(d)),ie({mode:t.mode,value:o,pads:u})}else return t},Fi=(e,t)=>{cd(e.inputs);let r=wd(e.inputs,t);e.compute(bd(e.inputs,r),{inputs:[0]})},Hi=e=>{let t=e.mode,r=e.value,o=e.pads;return ie({mode:t,value:r,pads:o})}});var Hr,Ki,qi,Yi,Xi,Ji,Zi,Qi,es,ts,rs,ns,os,as,is,ss=H(()=>{"use strict";ge();Pe();ve();Hr=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Ki=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),d=t.strides.slice(),a=s?t.dilations.slice():[],m=t.pads.slice();Ct.adjustPoolAttributes(r,n,u,d,a,m);let g=Ct.computePoolOutputShape(r,n,d,a,u,m,t.autoPad),x=Object.assign({},t);s?Object.assign(x,{kernelShape:u,strides:d,pads:m,dilations:a,cacheKey:t.cacheKey}):Object.assign(x,{kernelShape:u,strides:d,pads:m,cacheKey:t.cacheKey});let b=g.slice();return b.push(b.splice(1,1)[0]),[x,o?b:g]},qi=(e,t,r,o,n,s,u,d)=>{let a=n.format==="NHWC",m=r,g=t.type.value,x=m.length,b=k.size(o),w=X("output",t.type.tensor,o);if(n.kernelShape.length<=2){let v=n.kernelShape[n.kernelShape.length-1],y=n.strides[n.strides.length-1],S=n.pads[n.pads.length/2-1],A=n.pads[n.pads.length-1],R=x-(a?2:1),W="",M="",D="";if(S+A!==0?W=`\n                for (var i: u32 = 0u; i < ${v}u; i++) {\n                  xIndices[${R}] = indices[${R}] * ${y} - ${S} + i;\n                  if (xIndices[${R}] < 0 || xIndices[${R}] >= ${m[R]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:W=`\n                for (var i: u32 = 0u; i < ${v}u; i++) {\n                  xIndices[${R}] = indices[${R}] * ${y} - ${S} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let z=n.kernelShape[n.kernelShape.length-2],F=n.strides[n.strides.length-2],q=n.pads[n.pads.length/2-2],le=n.pads[n.pads.length-2],B=x-(a?3:2),K=m[B];q+le!==0?M=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${F} - ${q} + j;\n                  if (xIndices[${B}] < 0 || xIndices[${B}] >= ${K}) {\n                    pad+= ${v};\n                    continue;\n                  }\n              `:M=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${F} - ${q} + j;\n                `,D=`\n              }\n            `}return`\n            ${e.declareVariables(t,w)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              var xIndices = ${w.offsetToIndices("global_idx")};\n\n              var value: ${g} = ${g}(${d});\n              var pad = 0;\n              ${M}\n              ${W}\n              ${D}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(a)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let v=k.size(n.kernelShape),y=k.computeStrides(n.kernelShape),S=y.length,A=n.pads.length,R=n.pads.reduce((D,_)=>D+_),W="";return R?W=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:W=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,w)}\n\n            const pads = array<u32, ${A}>(${n.pads.map(D=>`${D}u`).join(",")});\n            const inputDims = array<u32, ${x}>(${m.map(D=>`${D}u`).join(",")});\n            const kernelStrides = array<u32, ${S}>(${y.map(D=>`${D}u`).join(",")});\n            const strides = array<u32, ${S}>(${n.strides.map(D=>`${D}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              let xIndices = ${w.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${w.type.value}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${v}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${x-S}u; j < ${x}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${x-S}u]\n                    + offsets[j - ${x-S}u] - pads[j - 2u];\n                  ${W}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},Yi=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xi=(e,t,r,o)=>{let[n,s]=Ki(t,o,r),u=k.size(n.kernelShape),d=L("x",t.dataType,t.dims),a=d.type.value,m="value += x_val;",g="";return n.countIncludePad?g+=`value /= ${a}(${u});`:g+=`value /= ${a}(${u} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:x=>qi(x,d,t.dims,s,n,m,g,"0.0")}},Ji=e=>{let t=e.count_include_pad!==0,r=Yi(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ie({countIncludePad:t,...r})},Zi=(e,t)=>{Hr(e.inputs),e.compute(Xi("AveragePool",e.inputs[0],!1,t))},Qi={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},es=e=>{let t=e.format;return{format:t,...Qi,cacheKey:t}},ts=(e,t)=>{Hr(e.inputs),e.compute(Xi("GlobalAveragePool",e.inputs[0],!0,t))},rs=(e,t,r,o)=>{let[n,s]=Ki(t,o,r),u=`\n      value = max(x_val, value);\n    `,d="",a=L("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:m=>qi(m,a,t.dims,s,n,u,d,"-1e5")}},ns=(e,t)=>{Hr(e.inputs),e.compute(rs("MaxPool",e.inputs[0],!1,t))},os=e=>{let t=e.storage_order,r=e.dilations,o=Yi(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ie({storageOrder:t,dilations:r,...o})},as=e=>{let t=e.format;return{format:t,...Qi,cacheKey:t}},is=(e,t)=>{Hr(e.inputs),e.compute(rs("GlobalMaxPool",e.inputs[0],!0,t))}});var jr=H(()=>{"use strict"});var us=H(()=>{"use strict";jr()});var ls,ds=H(()=>{"use strict";ls="1.17.0-dev.20231103-1439da36fe"});var cs,Wn,ps=H(()=>{"use strict";ds();cs="warning",Wn={wasm:{},webgl:{},webgpu:{},versions:{common:ls},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);cs=e}},get logLevel(){return cs}};Object.defineProperty(Wn,"logLevel",{enumerable:!0})});var fs,ms=H(()=>{"use strict";ps();fs=Wn});var hs=H(()=>{"use strict"});var gs=H(()=>{"use strict";Kr()});var bs=H(()=>{"use strict"});var ws=H(()=>{"use strict";Kr()});var Kr=H(()=>{"use strict";hs();gs();bs();ws()});var qr=H(()=>{"use strict";Kr()});var vs=H(()=>{"use strict";jr();qr()});var $s=H(()=>{"use strict";vs()});var xs=H(()=>{"use strict"});var Ss=H(()=>{"use strict";jr();qr()});var Cs=H(()=>{"use strict";Ss()});var As=H(()=>{"use strict";us();ms();$s();qr();xs();Cs()});var Sd,Cd,Is,Es=H(()=>{"use strict";As();De();ve();Sd=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},Cd=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,d=X("output",o,s),a=d.type.storage,m=g=>`\n        ${g.declareVariables(d)}\n        ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${a}(${e}) + ${a}(global_idx) * ${a}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(g=>g.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},Is=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),fs.webgpu.validateInputContent&&Sd(t,r,o),e.compute(Cd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var Ad,Id,Ed,Td,Od,_d,Rd,Pd,Md,Bd,kd,Dd,Wd,zd,Vd,Ts,Os,_s=H(()=>{"use strict";ge();Pe();ve();Ad=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Id=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},Ed=(e,t,r,o,n,s)=>{let[u,d,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(g=>s.push(g));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(g=>o.push(g)),o.length!==0&&o.length!==m&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ad(o,t),t.axes.length>0&&Id(o,t.axes,m).forEach((g,x)=>o[x]=g)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(g=>n.push(Number(g))),n.length!==m||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},Td=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Od=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",_d=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},Rd=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},Pd=(e,t,r,o)=>{let n=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return o.axes.length>0?(o.axes.forEach(u=>r[u]=n),o.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(n,0,r.length),s.forEach((u,d)=>s[d]=Math.round(u*r[d]))),s},Md=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Bd=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(d=>`${d}u`).join(",")});\n        const outputShape = array<u32, ${o.length}>(${o.map(d=>`${d}u`).join(",")});\n        const scales = array<f32, ${n.length}>(${n.map(d=>`${d}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(d=>`${d}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${o.length}; i++) {\n          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,kd=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Dd=(e,t,r,o,n,s,u)=>{let[d,a,m,g]=r.length===2?[-1,0,1,-1]:n[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${a}] = max(0, min(row, ${r[a]} - 1));\n      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${g}] = channel;\n        inputIndices[${d}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${a}];\n      var col:f32 = originalIndices[${m}];\n      if (${s} && (row < 0 || row > (${r[a]} - 1) || col < 0 || col > ${r[m]} - 1)) {\n        return ${u};\n      }\n      row = max(0, min(row, ${r[a]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${g}]);\n        batch = u32(originalIndices[${d}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Wd=(e,t,r,o,n,s,u,d,a,m)=>{let[g,x]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],b=w=>{let v=w===g?"row":"col";return`\n      fn ${v}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${w}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[w]},\n        f32(${o[w]}), f32(${r[w]}), ${s[w]}, ${s[w]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[w]} - 1))) {\n          return ${a};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${v}: f32 = originalIdx + f32(i);\n          if (${v} < 0 || ${v} >= ${r[w]}) {\n            if (${m}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${a};\n            } else {\n              ${v} = max(0, min(${v}, ${r[w]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${w}] = u32(${v});\n          data[i + 1] = ${w===g?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${b(g)};\n    ${b(x)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},zd=(e,t,r,o,n,s)=>{let u=e.dims,d=_d(s,t.axes,u.length),a=Rd(u,o,n,t.axes),m=o.slice();o.length===0&&(m=u.map((S,A)=>S===0?1:a[A]/S),t.keepAspectRatioPolicy!=="stretch"&&(a=Pd(u,a,m,t)));let g=X("output",e.dataType,a),x=L("input",e.dataType,u),b=k.size(a),w=u.length===a.length&&u.every((S,A)=>S===a[A]),v=t.coordinateTransformMode==="tf_crop_and_resize",y=S=>`\n      ${Td(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${kd(x,u)};\n              ${Od(t.nearestMode,r)};\n              ${Bd(x,g,u,a,m,d,v)};\n              `;case"linear":return`\n              ${Md(g,u,a,m,d)};\n              ${Dd(x,g,u,a,m,v,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Wd(x,g,u,a,m,d,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${S.declareVariables(x,g)}\n      ${S.mainStart()}\n        ${S.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        if (${w}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${g.offsetToIndices("global_idx")};\n          var inputIndices: ${x.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${x.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${n.length>0?n:""}`},getShaderSource:y,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},Vd=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Ts=(e,t)=>{let r=[],o=[],n=[],s=Vd(e);Ed(e.inputs,t,s,r,o,n),e.compute(zd(e.inputs[0],t,s,r,o,n),{inputs:[0]})},Os=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,a=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return ie({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:d,mode:a,nearestMode:m})}});var Gd,Nd,Rs,Ps,Ms=H(()=>{"use strict";De();ge();Pe();ve();Gd=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},Nd=(e,t,r,o)=>{let n=e[0].dims,s=k.size(n),u=n,d=s,a=n.slice(-1)[0],m=o?n.slice(0,-1).concat(1):[],g=e.length>3,x=e.length>4,b=o&&r>1,w=o&&r>2,v=r>3,y=lt(a),S=[L("x",e[0].dataType,e[0].dims,y),L("skip",e[1].dataType,e[1].dims,y),L("gamma",e[2].dataType,e[2].dims,y)];g&&S.push(L("beta",e[3].dataType,e[3].dims,y)),x&&S.push(L("bias",e[4].dataType,e[4].dims,y)),S.push(X("output",e[0].dataType,u,y)),b&&S.push(X("meanOutput",1,m)),w&&S.push(X("invStdOutput",1,m)),v&&S.push(X("inputSkipBiasSum",e[0].dataType,u,y));let A=Me(e[0].dataType),R=M=>`\n      const hiddenSize: f32 = ${a};\n      const hiddenSizeVectorized: u32 = ${a/y};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${M.declareVariables(...S)}\n\n      ${M.mainStart()}\n        ${M.guardAgainstOutOfBoundsWorkgroupSizes(d/a)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${qe("f32",y)};\n        var squareSum = ${qe("f32",y)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${x?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${v?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${At(A,y,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${ht("sum",y)} / hiddenSize;\n        let variance = sqrt(${ht("squareSum",y)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${A}(mean)) / ${A}(variance) * gamma[i]\n           + ${g?"beta[i]":"0.0"};\n        }\n      }`,W=[{dims:u,dataType:e[0].dataType}];return r>1&&W.push({dims:m,dataType:1}),r>2&&W.push({dims:m,dataType:1}),r>3&&W.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:R,getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(d/a/64)}})}},Rs=(e,t)=>{Gd(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Nd(e.inputs,t,e.outputCount,!1),{outputs:o})},Ps=e=>{let t=e.epsilon;return ie({epsilon:t})}});var Ud,Yr,Ld,Bs,Fd,Hd,ks,Ds,Ws=H(()=>{"use strict";De();ge();Pe();ve();Ud=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Yr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Ld=(e,t)=>{if(e.length>1){let r=Yr(e,1),o=Yr(e,2),n=Yr(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ie({starts:r,ends:o,axes:n})}else return t},Bs=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},Fd=(e,t,r,o)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Hd=(e,t)=>{let r=e[0].dims,o=k.size(r),n=t.axes.length>0?k.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=Yr(e,4);s.forEach(y=>y!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((y,S)=>Bs(y,S,r,n,s)),d=t.ends.map((y,S)=>Bs(y,S,r,n,s));if(n.length!==r.length)for(let y=0;y<r.length;++y)n.includes(y)||(u.splice(y,0,0),d.splice(y,0,r[y]),s.splice(y,0,1));let a=s.map(y=>Math.sign(y));s.forEach((y,S,A)=>{if(y<0){let R=(d[S]-u[S])/y,W=u[S],M=W+R*s[S];u[S]=M,d[S]=W,A[S]=-y}});let m=r.slice(0);n.forEach((y,S)=>{m[y]=Math.ceil((d[y]-u[y])/s[y])});let g={dims:m,dataType:e[0].dataType},x=X("output",e[0].dataType,m),b=L("input",e[0].dataType,r),w=k.size(m),v=y=>`\n      ${y.declareVariables(b,x)}\n        const signs = array<i32, ${a.length}>(${a.map(S=>`${S}i`).join(",")});\n        const starts = array<u32, ${u.length}>(${u.map(S=>`${S}u`).join(",")});\n        const ends = array<u32, ${d.length}>(${d.map(S=>`${S}u`).join(",")});\n        const steps = array<u32, ${s.length}>(${s.map(S=>`${S}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(S=>`${S}u`).join(",")});\n\n        ${Fd(b,x,r,m)}\n        ${y.mainStart()}\n          ${y.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${x.setByOffset("global_idx",b.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:v,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(o/64)}})}},ks=(e,t)=>{Ud(e.inputs,t);let r=Ld(e.inputs,t);e.compute(Hd(e.inputs,r),{inputs:[0]})},Ds=e=>{let t=e.starts,r=e.ends,o=e.axes;return ie({starts:t,ends:r,axes:o})}});var jd,Kd,zs,Vs,Gs=H(()=>{"use strict";ge();Pe();ve();jd=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Kd=(e,t)=>{let r=Me(e.dataType),o=e.dims,n=k.size(o),s=64,u=t.axis;if(u<0&&(u=o.length+u),u<o.length-1)throw new Error("softmax only supports last axis for now.");let d=o[u],a=n/d,m=lt(d),g=d/m,x=m===1?r:`vec${m}<${r}>`,b=(y,S)=>S===4?`max(max(${y}.x, ${y}.y), max(${y}.z, ${y}.w))`:S===2?`max(${y}.x, ${y}.y)`:S===3?`max(max(${y}.x, ${y}.y), ${y}.z)`:y,w=r==="f32"?`var threadMax = ${x}(-3.402823e+38f);`:`var threadMax = ${x}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:a}}),getShaderSource:y=>`\n      var<workgroup> rowMaxShared : ${x};\n      var<workgroup> rowSumShared : ${x};\n      var<workgroup> threadShared : array<${x}, ${s}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${x}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${x}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${x} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${x}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${s}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${s};\n        let row = gindex / wg;\n        let cols = ${g};\n        let row_stride : i32 = ${g};\n\n        // find the rows max\n        ${w}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${x}(${b("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${x}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${x}(${ht("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},zs=(e,t)=>{jd(e.inputs),e.compute(Kd(e.inputs[0],t))},Vs=e=>ie({axis:e.axis})});var qd,Yd,Xd,Jd,Zd,Ns,Us,Ls=H(()=>{"use strict";ge();Pe();ve();qd=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Yd=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),ie({numOutputs:o,axis:t.axis,splitSizes:r})},Xd=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Jd=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (outputNumber == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${o}) { ${n} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Zd=(e,t)=>{let r=e[0].dims,o=k.size(r),n=e[0].dataType,s=r.length,u=t.axis,d=u<0?r.length+u:u,a=new Array(t.numOutputs),m=L("input",n,r),g=new Array(t.numOutputs),x=[],b=[],w=0;for(let S=0;S<t.numOutputs;S++){w+=t.splitSizes[S],g[S]=w;let A=r.slice();A[t.axis]=t.splitSizes[S],b.push(A),a[S]=X(`output${S}`,n,b[S]),x.push({dims:b[S],dataType:e[0].dataType})}let v=s<2?"indices":`indices[${d}]`,y=S=>`\n  ${S.declareVariables(m,...a)}\n  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(A=>`${A}u`).join(",")});\n  ${Xd(g.length)}\n  ${Jd(a)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    var indices = ${m.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${v});\n    if (outputNumber != 0) {\n        ${v} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:y,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(o/64)}})}},Ns=(e,t)=>{qd(e.inputs);let r=e.inputs.length===1?t:Yd(e.inputs,t);e.compute(Zd(e.inputs,r),{inputs:[0]})},Us=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ie({axis:t,numOutputs:o,splitSizes:r})}});var Fs,Qd,ec,tc,Hs,js=H(()=>{"use strict";De();ge();ve();Fs=e=>Array.from(e.getBigInt64Array(),Number),Qd=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Fs(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ec=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},tc=e=>{let t=e[0].dims,r=Fs(e[1]),o=ec(t,r),n=k.size(o),s=e[0].dataType,u=L("input",s,t),d=X("output",s,o),a=m=>`\n      const inputShape = ${u.indices(...t)};\n      ${m.declareVariables(u,d)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      var inputIndices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${d.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};\n\n        ${u.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:a}},Hs=e=>{Qd(e.inputs),e.compute(tc(e.inputs),{inputs:[0]})}});var rc,nc,Ks,qs=H(()=>{"use strict";De();ge();ve();rc=(e,t,r,o,n)=>{let s=k.size(r),u=Math.ceil(s/4),d=X("outputData",n,r,4),a=L("aData",t[1].dataType,t[1].dims,4),m=L("bData",t[2].dataType,t[2].dims,4),g=L("cData",t[0].dataType,t[0].dims,4),x,b=(w,v,y)=>`select(${v}, ${w}, ${y})`;if(!o)x=d.setByOffset("global_idx",b(a.getByOffset("global_idx"),m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let w=(v,y,S="")=>{let A=`aData[indexA${y}][componentA${y}]`,R=`bData[indexB${y}][componentB${y}]`,W=`bool(cData[indexC${y}] & ${4278190080>>>(3-y)*8}u)`;return`\n            let outputIndices${y} = ${d.offsetToIndices(`global_idx * 4u + ${y}u`)};\n            let offsetA${y} = ${a.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let offsetB${y} = ${m.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let offsetC${y} = ${g.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let indexA${y} = offsetA${y} / 4u;\n            let indexB${y} = offsetB${y} / 4u;\n            let indexC${y} = offsetC${y} / 4u;\n            let componentA${y} = offsetA${y} % 4u;\n            let componentB${y} = offsetB${y} % 4u;\n            ${v}[${y}] = ${S}(${b(A,R,W)});\n          `};n===9?x=`\n            var data = vec4<u32>(0);\n            ${w("data",0,"u32")}\n            ${w("data",1,"u32")}\n            ${w("data",2,"u32")}\n            ${w("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:x=`\n            ${w("outputData[global_idx]",0)}\n            ${w("outputData[global_idx]",1)}\n            ${w("outputData[global_idx]",2)}\n            ${w("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(g,a,m,d)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        ${x}\n      }`},nc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(k.areEqual(t,r)&&k.areEqual(r,o)),u=t,d=k.size(t);if(s){let a=Qe.calcShape(Qe.calcShape(t,r,!1),o,!1);if(!a)throw new Error("Can\'t perform where op on the given tensors");u=a,d=k.size(u)}return{name:"Where",getShaderSource:a=>rc(a,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(d/64/4)}})}},Ks=e=>{e.compute(nc(e.inputs))}});var Ys,Xs=H(()=>{"use strict";ca();fa();ja();ni();ii();_n();wi();Si();Ii();Oi();Pi();ki();zi();Ni();Li();ji();ss();Es();Mr();_s();Ms();Ws();Gs();Ls();js();rr();In();qs();Ys=new Map([["Abs",[ma]],["Acos",[ha]],["Acosh",[ga]],["Add",[Ka]],["ArgMax",[da,Cn]],["ArgMin",[la,Cn]],["Asin",[ya]],["Asinh",[ba]],["Atan",[wa]],["Atanh",[va]],["AveragePool",[Zi,Ji]],["BiasAdd",[pa]],["BiasSplitGelu",[Ha]],["Cast",[xa,$a]],["Ceil",[Ca]],["ClipV10",[An]],["Clip",[Sa]],["Concat",[oi,ai]],["Conv",[Pn,Rn]],["ConvTranspose",[bi,yi]],["Cos",[Aa]],["Cosh",[Ia]],["Div",[qa]],["Einsum",[$i,xi]],["Elu",[Ea,kr]],["Equal",[Ya]],["Erf",[Ta]],["Exp",[Oa]],["Expand",[Ai]],["Floor",[_a]],["FusedConv",[Pn,Rn]],["Gather",[Ti,Ei]],["GatherElements",[Ri,_i]],["Gelu",[Ra]],["Gemm",[Mi,Bi]],["GlobalAveragePool",[ts,es]],["GlobalMaxPool",[is,as]],["Greater",[Qa]],["GreaterOrEqual",[ti]],["InstanceNormalization",[Wi,Di]],["LayerNormalization",[Gi,Vi]],["LeakyRelu",[Pa,kr]],["Less",[ei]],["LessOrEqual",[ri]],["Log",[Fa]],["MatMul",[Ui]],["MaxPool",[ns,os]],["Mul",[Xa]],["Neg",[Ba]],["Not",[Ma]],["Pad",[Fi,Hi]],["Pow",[Ja]],["Range",[Is]],["Reciprocal",[ka]],["ReduceMin",[ra,Ye]],["ReduceMean",[Jo,Ye]],["ReduceMax",[ta,Ye]],["ReduceSum",[oa,Ye]],["ReduceProd",[na,Ye]],["ReduceL1",[Zo,Ye]],["ReduceL2",[Qo,Ye]],["ReduceLogSum",[ia,Ye]],["ReduceLogSumExp",[ea,Ye]],["ReduceSumSquare",[aa,Ye]],["Relu",[Da]],["Resize",[Ts,Os]],["Sigmoid",[Wa]],["Sin",[za]],["Sinh",[Va]],["Slice",[ks,Ds]],["SkipLayerNormalization",[Rs,Ps]],["Split",[Ns,Us]],["Sqrt",[Ga]],["Softmax",[zs,Vs]],["Sub",[Za]],["Tan",[Na]],["Tanh",[Ua]],["ThresholdedRelu",[La,kr]],["Tile",[Hs]],["Transpose",[zo,Vo]],["Where",[Ks]]])});var Xr,Js=H(()=>{"use strict";De();mt();ve();Xr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s,u,d){let a=this.backend.device,m=this.backend.getComputePassEncoder();m.setPipeline(t.computePipeline);let g=[];for(let b of n)g.push({binding:g.length,resource:{buffer:b.buffer}});for(let b of s)g.push({binding:g.length,resource:{buffer:b.buffer}});d&&g.push({binding:g.length,resource:d});let x=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:g,label:t.programInfo.name});if(m.setBindGroup(0,x),m.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let b=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,b.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,v=this.backend.kernels.get(w),y=`[${v[0]}] ${v[1]}`;b.buffer.mapAsync(GPUMapMode.READ).then(()=>{let S=new BigUint64Array(b.buffer.getMappedRange()),A=S[0],R=S[1];b.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=A);let W=Number(A-this.backend.queryTimeBase),M=Number(R-this.backend.queryTimeBase);if(!Number.isSafeInteger(W)||!Number.isSafeInteger(M))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(b.id);let D="";r.forEach((z,F)=>{D+=`input[${F}]: [${z.dims}] | ${Qt(z.dataType)}, `});let _="";o.forEach((z,F)=>{_+=`output[${F}]: [${z.dims}] | ${Qt(z.dataType)}, `}),console.log(`[profiling] kernel "${w}|${y}" ${D}${_}execution time: ${M-W} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=ko(r),u=t.getShaderSource(s),d=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:d,label:t.name});Ee("verbose",()=>`[WebGPU] shader code: ${d}`);let m=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,d=Math.ceil(Math.sqrt(u));if(d>s){if(d=Math.ceil(Math.cbrt(u)),d>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var oc,ac,Jr,Zs=H(()=>{"use strict";mt();To();Po();Xs();Js();oc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},ac=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${oc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Jr=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Ro(this),this.programManager=new Xr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Io(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,o,n,s){let u=[];for(let A=0;A<r.length;++A){let R=this.gpuDataManager.get(r[A].data);if(!R)throw new Error(`no GPU data for input: ${r[A].data}`);u[A]=R}let d=ac(t,r),a=this.programManager.getArtifact(d),{outputs:m,dispatchGroup:g,programUniforms:x}=t.getRunData(r),b=o.length===0?m.map((A,R)=>R):o;if(b.length!==m.length)throw new Error(`Output size ${b.length} must be equal to ${m.length}.`);let w=[],v=[];for(let A=0;A<m.length;++A){if(!Number.isInteger(b[A])||b[A]<-3||b[A]>=m.length)throw new Error(`Invalid output index: ${b[A]}`);if(b[A]===-3)continue;let R=b[A]===-1,W=b[A]===-2,M=R||W?s(m[A].dataType,m[A].dims):n(b[A],m[A].dataType,m[A].dims),D=this.gpuDataManager.get(M.data);if(!D)throw new Error(`no GPU data for output: ${M.data}`);if(R&&this.temporaryData.push(D),W){let _=this.kernelPersistentData.get(this.currentKernelId);_||(_=[],this.kernelPersistentData.set(this.currentKernelId,_)),_.push(D)}w.push(M),v.push(D)}let y;if(x){let A=0,R=0,W=[],M=1;x.forEach(z=>{let F=typeof z.data=="number"?[z.data]:z.data,q;switch(F.length){case 1:q=4;break;case 2:q=8;break;case 3:q=16;break;case 4:q=16;break;case 5:q=16;break;case 6:q=16;break;default:throw new Error(`unsupported data length: ${F.length}`)}(R===5||R===6)&&(q=16),q>M&&(M=q),A=Math.ceil(A/q)*q,R=F.length,W.push(A),A+=F.length*4}),A=Math.ceil(A/M)*M;let D=new ArrayBuffer(A);x.forEach((z,F)=>{let q=W[F],le=typeof z.data=="number"?[z.data]:z.data;z.type==="int32"?new Int32Array(D,q,le.length).set(le):z.type==="uint32"?new Uint32Array(D,q,le.length).set(le):new Float32Array(D,q,le.length).set(le)});let _=this.gpuDataManager.create(A,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(_.buffer,0,D,0,A),this.gpuDataManager.release(_.id),y={offset:0,size:A,buffer:_.buffer}}let S=this.programManager.normalizeDispatchGroupSize(g);return a||(a=this.programManager.build(t,S),this.programManager.setArtifact(d,a)),Ee("info",()=>`[ProgramManager] run "${t.name}" (key=${d}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(a,r,w,u,v,S,y),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=Ys.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,d,a]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Ee("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),d(r,a[1]),0}catch(g){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${g}`)),1}finally{m&&o.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${s}] ${u}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),d=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await yn(this,t,r);return Eo(n.buffer,o)}}}});var Qs={};Ir(Qs,{init:()=>ic});var sr,zn,ic,eu=H(()=>{"use strict";De();Zs();mt();ge();sr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(k.size(t)!==k.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},zn=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let d=[];for(let a=0;a<u;a++){let m=n[s++],g=n[s++],x=n[s++],b=[];for(let w=0;w<x;w++)b.push(n[s++]);d.push(new sr(t,m,g,b))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,n=r?.outputs??[],s=(d,a,m)=>new sr(this.module,a,this.output(d,m),m),u=(d,a)=>{let m=er(d);if(!m)throw new Error(`Unsupported data type: ${d}`);let g=m*k.size(a);return new sr(this.module,d,this.backend.gpuDataManager.create(g).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},ic=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new Jr;await o.initialize(t),r(o,n=>o.alloc(n),n=>o.free(n),(n,s,u,d=!1)=>{if(d)Ee("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),o.memcpy(n,s);else{Ee("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let a=e.HEAPU8.subarray(n,n+u);o.upload(s,a)}},async(n,s,u)=>{Ee("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await o.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>o.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>o.releaseKernel(n),(n,s,u,d)=>{Ee("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let a=new zn(e,o,s);return o.computeKernel(n,a,d)})}}});var wo;wo=uo();var Ru=go(),pn,fn=!1,Er=!1,bo=!1,Pu=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Mu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Bu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",vo=async e=>{if(fn)return Promise.resolve();if(Er)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(bo)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Er=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=r>1&&Pu(),s=o&&Mu(),u=e.wasmPaths,d=typeof u=="string"?u:void 0,a=Bu(s,n),m=typeof u=="object"?u[a]:void 0,g=!1,x=[];if(t>0&&x.push(new Promise(b=>{setTimeout(()=>{g=!0,b()},t)})),x.push(new Promise((b,w)=>{let v=n?Ru:wo,y={locateFile:(S,A)=>{if(n&&S.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([yo()],{type:"text/javascript"}));if(S.endsWith(".wasm")){if(m)return m;let R=d??A;return a==="ort-wasm-simd.wasm"?R+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?R+"ort-wasm-simd-threaded.jsep.wasm":R+a}return A+S}};if(n)if(typeof Blob>"u")y.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let S=`var ortWasmThreaded=${v.toString()};`;y.mainScriptUrlOrBlob=new Blob([S],{type:"text/javascript"})}v(y).then(S=>{Er=!1,fn=!0,pn=S,b()},S=>{Er=!1,bo=!0,w(S)})})),await Promise.race(x),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(fn&&pn)return pn;throw new Error("WebAssembly is not initialized yet.")};var Be=(e,t)=>{let r=Re(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},Zt=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")Zt(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ae=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var $o=e=>{let t=Re(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Be(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&Zt(e.extra,"",new WeakSet,(u,d)=>{let a=Be(u,o),m=Be(d,o);t._OrtAddRunConfigEntry(r,a,m)!==0&&Ae(`Can\'t set a run config entry: ${u} - ${d}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var ku=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Du=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Wu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},zu=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let d=Be("deviceType",r),a=Be(u.deviceType,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.powerPreference){let d=Be("powerPreference",r),a=Be(u.powerPreference,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let d=Be("preferredLayout",r),a=Be(u.preferredLayout,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Be(n,r);Re()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can\'t append execution provider: ${n}.`)}},xo=e=>{let t=Re(),r=0,o=[],n=e||{};Wu(n);try{let s=ku(n.graphOptimizationLevel??"all"),u=Du(n.executionMode??"sequential"),d=typeof n.logId=="string"?Be(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let m=n.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let g=typeof n.optimizedModelFilePath=="string"?Be(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,d,a,m,g),r===0&&Ae("Can\'t create session options."),n.executionProviders&&zu(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[x,b]of Object.entries(n.freeDimensionOverrides)){if(typeof x!="string")throw new Error(`free dimension override name must be a string: ${x}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let w=Be(x,o);t._OrtAddFreeDimensionOverride(r,w,b)!==0&&Ae(`Can\'t set a free dimension override: ${x} - ${b}.`)}return n.extra!==void 0&&Zt(n.extra,"",new WeakSet,(x,b)=>{let w=Be(x,o),v=Be(b,o);t._OrtAddSessionConfigEntry(r,w,v)!==0&&Ae(`Can\'t set a session config entry: ${x} - ${b}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};De();var ru=!1,sc=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},uc=(e,t)=>{Re()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},nu=async e=>{uc(e.wasm.numThreads,tr(e.logLevel));{let t=(eu(),Mt(Qs)).init;await t(Re(),e)}ru=!0},ur=new Map,ou=()=>ru,Vn=e=>{let t=Re(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Gn=(e,t)=>{let r=Re(),o=0,n=0,s=0,u=[],d=[],a=[];try{[n,u]=xo(t),o=r._OrtCreateSession(e[0],e[1],n),o===0&&Ae("Can\'t create a session.");let[m,g]=sc(o),x=[],b=[],w=[];for(let y=0;y<m;y++){let S=r._OrtGetInputName(o,y);S===0&&Ae("Can\'t get an input name."),d.push(S),x.push(r.UTF8ToString(S))}for(let y=0;y<g;y++){let S=r._OrtGetOutputName(o,y);S===0&&Ae("Can\'t get an output name."),a.push(S);let A=r.UTF8ToString(S);b.push(A);{let R=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[A]??"cpu";if(R!=="cpu"&&R!=="cpu-pinned"&&R!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${R}.`);w.push(R)}}let v=null;return w.some(y=>y==="gpu-buffer")&&(s=r._OrtCreateBinding(o),s===0&&Ae("Can\'t create IO binding."),v={handle:s,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(y=>hn(y))}),ur.set(o,[o,d,a,v]),[o,x,b]}catch(m){throw d.forEach(g=>r._OrtFree(g)),a.forEach(g=>r._OrtFree(g)),s!==0&&r._OrtReleaseBinding(s),o!==0&&r._OrtReleaseSession(o),m}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(m=>r._free(m))}},au=(e,t)=>{let r=Vn(e);return Gn(r,t)},iu=e=>{let t=Re(),r=ur.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),ur.delete(e)},tu=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=Re(),u=e[0],d=e[1],a=e[3],m,g;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let w=e[2].gpuBuffer,v=er(mn(u));g=d.reduce((y,S)=>y*S,1)*v,m=s.jsepRegisterBuffer(o,n,w,g)}else{let w=e[2];if(Array.isArray(w)){g=4*w.length,m=s._malloc(g),r.push(m);let v=m/4;for(let y=0;y<w.length;y++){if(typeof w[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);s.HEAPU32[v++]=Be(w[y],r)}}else g=w.byteLength,m=s._malloc(g),r.push(m),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,g),m)}let x=s.stackSave(),b=s.stackAlloc(4*d.length);try{let w=b/4;d.forEach(y=>s.HEAP32[w++]=y);let v=s._OrtCreateTensor(mn(u),m,g,b,d.length,hn(a));v===0&&Ae(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push(v)}finally{s.stackRestore(x)}},su=async(e,t,r,o,n,s)=>{let u=Re(),d=ur.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,m,g,x]=d,b=t.length,w=o.length,v=0,y=[],S=[],A=[],R=[],W=u.stackSave(),M=u.stackAlloc(b*4),D=u.stackAlloc(b*4),_=u.stackAlloc(w*4),z=u.stackAlloc(w*4);try{[v,y]=$o(s);for(let ae=0;ae<b;ae++)tu(r[ae],S,R,e,t[ae]);for(let ae=0;ae<w;ae++)tu(n[ae],A,R,e,b+o[ae]);let F=M/4,q=D/4,le=_/4,B=z/4;for(let ae=0;ae<b;ae++)u.HEAPU32[F++]=S[ae],u.HEAPU32[q++]=m[t[ae]];for(let ae=0;ae<w;ae++)u.HEAPU32[le++]=A[ae],u.HEAPU32[B++]=g[o[ae]];if(x){let{handle:ae,outputPreferredLocations:we,outputPreferredLocationsEncoded:j}=x;if(m.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${m.length}).`);for(let Se=0;Se<b;Se++){let Oe=t[Se];await u._OrtBindInput(ae,m[Oe],S[Se])!==0&&Ae(`Can\'t bind input[${Se}] for session=${e}.`)}for(let Se=0;Se<w;Se++){let Oe=o[Se];n[Se]?.[3]?u._OrtBindOutput(ae,g[Oe],A[Se],0)!==0&&Ae(`Can\'t bind pre-allocated output[${Se}] for session=${e}.`):u._OrtBindOutput(ae,g[Oe],0,j[Oe])!==0&&Ae(`Can\'t bind output[${Se}] to ${we[Se]} for session=${e}.`)}}let K;x?K=await u._OrtRunWithBinding(a,x.handle,w,_,v):K=await u._OrtRun(a,D,M,b,z,w,_,v),K!==0&&Ae("failed to call OrtRun().");let xe=[];for(let ae=0;ae<w;ae++){let we=u.HEAPU32[_/4+ae];if(we===A[ae]){xe.push(n[ae]);continue}let j=u.stackSave(),Se=u.stackAlloc(4*4),Oe=!1,Ie,Ce=0;try{u._OrtGetTensorData(we,Se,Se+4,Se+8,Se+12)!==0&&Ae(`Can\'t access output tensor data on index ${ae}.`);let Ne=Se/4,Le=u.HEAPU32[Ne++];Ce=u.HEAPU32[Ne++];let N=u.HEAPU32[Ne++],de=u.HEAPU32[Ne++],pe=[];for(let Te=0;Te<de;Te++)pe.push(u.HEAPU32[N/4+Te]);u._OrtFree(N);let ze=pe.reduce((Te,ke)=>Te*ke,1);Ie=Qt(Le);let Ue=x?.outputPreferredLocations[o[ae]];if(Ie==="string"){if(Ue==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Te=[],ke=Ce/4;for(let Ge=0;Ge<ze;Ge++){let Xe=u.HEAPU32[ke++],Fe=Ge===ze-1?void 0:u.HEAPU32[ke]-Xe;Te.push(u.UTF8ToString(Xe,Fe))}xe.push([Ie,pe,Te,"cpu"])}else if(Ue==="gpu-buffer"&&ze>0){let Te=u.jsepGetBuffer(Ce),ke=er(Le);if(ke===void 0||!So(Ie))throw new Error(`Unsupported data type: ${Ie}`);Oe=!0,xe.push([Ie,pe,{gpuBuffer:Te,download:u.jsepCreateDownloader(Te,ze*ke,Ie),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Te=Tr(Ie),ke=new Te(ze);new Uint8Array(ke.buffer,ke.byteOffset,ke.byteLength).set(u.HEAPU8.subarray(Ce,Ce+ke.byteLength)),xe.push([Ie,pe,ke,"cpu"])}}finally{u.stackRestore(j),Ie==="string"&&Ce&&u._free(Ce),Oe||u._OrtReleaseTensor(we)}}return x&&u._OrtClearBoundOutputs(x.handle),xe}finally{u.stackRestore(W),S.forEach(F=>u._OrtReleaseTensor(F)),A.forEach(F=>u._OrtReleaseTensor(F)),R.forEach(F=>u._free(F)),v!==0&&u._OrtReleaseRunOptions(v),y.forEach(F=>u._free(F))}},uu=e=>{let t=Re(),r=ur.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Ae("Can\'t get an profile file name."),t._OrtFree(n)},lu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{vo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{nu(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=Vn(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,o=Gn(t,r);postMessage({type:"create_finalize",out:o})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,o=au(t,r);postMessage({type:"create",out:o})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;iu(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:o,outputIndices:n,options:s}=e.data.in;su(t,r,o,n,s).then(u=>{postMessage({type:"run",out:u},lu(u))},u=>{postMessage({type:"run",err:u})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;uu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=ou();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'})),Nu=P((()=>{re(),zu(),Vo(),au=()=>!!c.wasm.proxy&&typeof document<"u",ou=!1,su=!1,uu=!1,cu=[],pu=[],fu=[],hu=[],mu=[],gu=[],yu=[],wu=()=>{if(ou||!su||uu||!iu)throw new Error("worker not ready")},$u=e=>{switch(e.data.type){case"init-wasm":ou=!1,e.data.err?(uu=!0,lu[1](e.data.err)):(su=!0,lu[0]());break;case"init-ort":e.data.err?du[1](e.data.err):du[0]();break;case"create_allocate":e.data.err?cu.shift()[1](e.data.err):cu.shift()[0](e.data.out);break;case"create_finalize":e.data.err?pu.shift()[1](e.data.err):pu.shift()[0](e.data.out);break;case"create":e.data.err?fu.shift()[1](e.data.err):fu.shift()[0](e.data.out);break;case"release":e.data.err?hu.shift()[1](e.data.err):hu.shift()[0]();break;case"run":e.data.err?mu.shift()[1](e.data.err):mu.shift()[0](e.data.out);break;case"end-profiling":e.data.err?gu.shift()[1](e.data.err):gu.shift()[0]();break;case"is-ort-env-initialized":e.data.err?yu.shift()[1](e.data.err):yu.shift()[0](e.data.out)}},vu=typeof document<"u"?document?.currentScript?.src:void 0,bu=async()=>{if(au()){if(su)return;if(ou)throw new Error("multiple calls to 'initWasm()' detected.");if(uu)throw new Error("previous call to 'initWasm()' failed.");return ou=!0,void 0===c.wasm.wasmPaths&&vu&&0!==vu.indexOf("blob:")&&(c.wasm.wasmPaths=vu.substr(0,+vu.lastIndexOf("/")+1)),new Promise(((e,t)=>{iu?.terminate();let n=URL.createObjectURL(new Blob([Wu()],{type:"text/javascript"}));(iu=new Worker(n,{name:"ort-wasm-proxy-worker"})).onerror=e=>t(e),iu.onmessage=$u,URL.revokeObjectURL(n),lu=[e,t];let r={type:"init-wasm",in:c.wasm};iu.postMessage(r)}))}return _e(c.wasm)},xu=async e=>{if(au())return wu(),new Promise(((t,n)=>{du=[t,n];let r={type:"init-ort",in:e};iu.postMessage(r)}));await qs(e)},Su=async e=>au()?(wu(),new Promise(((t,n)=>{cu.push([t,n]);let r={type:"create_allocate",in:{model:e}};iu.postMessage(r,[e.buffer])}))):Xs(e),_u=async(e,t)=>au()?(wu(),new Promise(((n,r)=>{pu.push([n,r]);let a={type:"create_finalize",in:{modeldata:e,options:t}};iu.postMessage(a)}))):Js(e,t),Cu=async(e,t)=>{if(au()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return wu(),new Promise(((n,r)=>{fu.push([n,r]);let a={type:"create",in:{model:e,options:t}};iu.postMessage(a,[e.buffer])}))}return Qs(e,t)},Eu=async e=>{if(au())return wu(),new Promise(((t,n)=>{hu.push([t,n]);let r={type:"release",in:e};iu.postMessage(r)}));Zs(e)},Iu=async(e,t,n,r,a,i)=>{if(au()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return wu(),new Promise(((a,o)=>{mu.push([a,o]);let s=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:s,outputIndices:r,options:i}};iu.postMessage(u,ru(s))}))}return tu(e,t,n,r,a,i)},Au=async e=>{if(au())return wu(),new Promise(((t,n)=>{gu.push([t,n]);let r={type:"end-profiling",in:e};iu.postMessage(r)}));nu(e)},Ou=async()=>au()?(wu(),new Promise(((e,t)=>{yu.push([e,t]),iu.postMessage({type:"is-ort-env-initialized"})}))):Ks()})),Gu=P((()=>{re(),Nu(),Lo(),Ru=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},ku=e=>{switch(e[3]){case"cpu":return new E(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Ge(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:a}=e[2];return E.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},Bu=class{async createSessionAllocate(e){let t=await fetch(e);if(200!==t.status)throw new Error(`failed to load model: ${e}`);let n=await t.arrayBuffer();return Su(new Uint8Array(n))}async loadModel(e,t){if(await Ou()||(Tu||(Tu=xu(c)),await Tu,Tu=void 0),"string"==typeof e)if(typeof process<"u"&&process.versions&&process.versions.node){let n=await(void 0)(e);[this.sessionId,this.inputNames,this.outputNames]=await Cu(n,t)}else{let n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await _u(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await Cu(e,t)}async dispose(){return Eu(this.sessionId)}async run(e,t,n){let r=[],a=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],i=this.inputNames.indexOf(t);if(-1===i)throw new Error(`invalid input '${t}'`);r.push(n),a.push(i)}));let i=[],o=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output '${t}'`);i.push(n),o.push(r)}));let s=r.map(((e,t)=>Ru(e,(()=>`input "${this.inputNames[a[t]]}"`)))),u=i.map(((e,t)=>e?Ru(e,(()=>`output "${this.outputNames[o[t]]}"`)):null)),l=await Iu(this.sessionId,a,s,o,u,n),d={};for(let e=0;e<l.length;e++)d[this.outputNames[o[e]]]=i[e]??ku(l[e]);return d}startProfiling(){}endProfiling(){Au(this.sessionId)}}})),Uu=P((()=>{re(),Nu(),Gu(),Mu=()=>{if(("number"!=typeof c.wasm.initTimeout||c.wasm.initTimeout<0)&&(c.wasm.initTimeout=0),"boolean"!=typeof c.wasm.simd&&(c.wasm.simd=!0),"boolean"!=typeof c.wasm.proxy&&(c.wasm.proxy=!1),"number"!=typeof c.wasm.numThreads||!Number.isInteger(c.wasm.numThreads)||c.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;c.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Du=class{async init(){Mu(),await bu()}async createInferenceSessionHandler(e,t){let n=new Bu;return await n.loadModel(e,t),Promise.resolve(n)}}})),Vu={};W(Vu,{wasmBackend:()=>ju});var ju,Fu=P((()=>{Uu(),ju=new Du})),Hu={};W(Hu,{InferenceSession:()=>A,Tensor:()=>E,TrainingSession:()=>T,default:()=>Lu,env:()=>c,registerBackend:()=>o}),e.exports=N(Hu),re(),re(),re();var Lu=ne;{let e=(Fu(),N(Vu)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&o("webgpu",e,5),o("cpu",e,10),o("wasm",e,10),o("xnnpack",e,9),o("webnn",e,9)}Object.defineProperty(c.versions,"web",{value:"1.17.0-dev.20231103-1439da36fe",enumerable:!0})}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}return n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{const e=n(122),t=28,r=28,a={sam_b:["models/mnist_cnn.onnx"]},i=function(){var e={model:"sam_b",provider:"webgpu",device:"gpu",threads:"1"};let t=window.location.search.substring(1).split("&");for(var n=0;n<t.length;n++){let r=t[n].split("=");if(r[0]in e)e[r[0]]=decodeURIComponent(r[1]);else if(r[0].length>0)throw new Error("unknown argument: "+r[0])}return e.threads=parseInt(e.threads),e}();let o,s;var u;e.env.wasm.numThreads=i.threads,e.env.wasm.proxy=!0;var l,d=[];function c(e){document.getElementById("status").innerHTML+=`<br>[${performance.now().toFixed(3)}] `+e,console.log(e)}async function p(n){return n=await e.Tensor.fromImage(n,options={resizedWidth:t,resizedHeight:r}),n=await async function(t){const n=t.data,r=new e.Tensor(n.slice(0,784),[1,1,28,28]);return c(`reshapedTensor is ${r.dims}`),r}(n),await async function(e){return isWhite=await async function(e,t=.3){var n=0;const r=e.data;for(let e=0;e<r.length;e++)1==r[e]&&(n+=1);var a=n/784;return c(`percent whitenesss is ${a}; count is ${n}; ${e.dims}`),a>=t}(e),1==isWhite?(c("yaay! image is white background; gotta invert!"),e=await async function(e){const t=e.data;for(let e=0;e<t.length;e++)t[e]=1-t[e];return e}(e)):(c("noo! img is NOT white background"),e)}(n)}document.addEventListener("DOMContentLoaded",(()=>{!async function(){const t=a[i.model];o=document.getElementById("img_canvas"),s=document.getElementById("file-in");let n=document.getElementById("original-image");console.log("[debug] BEFORE model loading..."),async function(t,n,r){let a=i.provider;switch(a){case"webnn":if(!("ml"in navigator))throw new Error("webnn is NOT supported");a={name:"webnn",deviceType:i.device,powerPreference:"default"};break;case"webgpu":if(!navigator.gpu)throw new Error("webgpu is NOT supported")}const o={executionProviders:[a]};c(`[load_model] idx is what? ${n}`),async function(e){try{const t=await caches.open("onnx");i.clear_cache&&t.delete(e);let n=await t.match(e);return null==n?(await t.add(e),n=await t.match(e),c(`${e} (from network)`)):c(`${e} (from cache)`),await n.arrayBuffer()}catch(t){return c(`${e} (from network)`),await fetch(e).then((e=>e.arrayBuffer()))}}(t[n]).then((a=>{d[n]=e.InferenceSession.create(a,o),d[n].then((()=>{c(`${t[n]} loaded. yoy`),0==n&&c("[load_model] idx is 0; so going for next recursion of model")}),(e=>{throw c(`${t[n]} failed with ${e}.`),e})),c(void 0!==r?"img is undefined!":"img is not undefined!")}))}(t,0,n).then((()=>{}),(e=>{c(e)})),console.log("[debug] model loaded; sess:",d),s.onchange=function(e){let t=(e.target||window.event.src).files;if(FileReader&&t&&t.length){let e=new FileReader;e.onload=()=>{n.onload=()=>async function(e){const t=document.getElementById("prediction-element");s.disabled=!0;const n=document.createElement("canvas");n.style.cursor="wait",u=void 0;var r=e.width,a=e.height;r>a?r>28&&(a*=28/r,r=28):a>28&&(r*=28/a,a=28),r=Math.round(r),a=Math.round(a),n.width=r,n.height=a;var i=n.getContext("2d");console.log(`[modelForward] img.height: ${e.height}### img.width: ${e.width}`),i.drawImage(e,0,0,r,a),l=i.getImageData(0,0,r,a);const o=await p(l);c(`###imgTensor.dims is this: ${o.dims}###`),c(`###imgTensor sample is this: ${o.data.slice(110,119)}###`);const f={"input.1":o},h=await d[0];performance.now(),console.log("[debug] s:",h),u=await h.run(f);const m=await async function(e){for(key in e)c(`object[${key}]: ${e[key]}`);return e[key]}(u);probs=m.cpuData,max_prob=Math.max(...probs),maxInd=probs.indexOf(max_prob),probsArray=Array.from(probs),expProbNums=probsArray.map((function(e){return Number(Math.exp(e))})),totalProbNums=expProbNums.reduce(((e,t)=>e+t),0),expProbProbs=expProbNums.map((function(e){return Number((e/totalProbNums*100).toFixed(2))})),t.innerHTML=`<div class="tooltip_custom">Class: ${maxInd}<span class="tooltiptext_custom">Probabilities: ${expProbProbs.join("%, ")}%</span></div>`,s.disabled=!1}(n),n.src=e.result},e.readAsDataURL(t[0])}}}()}))})(),{}})()));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxhQUFhWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxXQUFXWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVD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QU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsYUFBYXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxVQUFVcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxNQUFNcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsT0FBT3BjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE9BQU9wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsT0FBT3BjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLFFBQVFwYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsUUFBUXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxRQUFRcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE9BQU9wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFH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QUFtQi9CLFVBQVksc0NBQXNDNEMseURBQXlETSxhQUFheDhDLEtBQUssdUJBRWhKaTVDLEVBQU9xQyxVQUFXLENBQ3RCLENBcUhtQ21CLENBQWFwQyxHQUNoQ0EsRUFBSTUyQyxJQUFNMjNDLEVBQVdzQixNQUFNLEVBRS9CdEIsRUFBV3VCLGNBQWMxQixFQUFNLEdBQ25DLENBQ0osQ0FFSixDQUVzRDJCLEVBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcnQtc2FtL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9vcnQtc2FtLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9kaXN0L2Nqcy9vcnQud2ViZ3B1Lm1pbi5qcyIsIndlYnBhY2s6Ly9vcnQtc2FtL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL29ydC1zYW0vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9vcnQtc2FtLy4vbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuICIsIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4xNy4wLWRldi4yMDIzMTEwMy0xNDM5ZGEzNmZlXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7dmFyIF9uPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIga2w9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgQmw9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIE1sPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIEw9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgTHQ9KGUsdCk9PigpPT4odHx8ZSgodD17ZXhwb3J0czp7fX0pLmV4cG9ydHMsdCksdC5leHBvcnRzKSxrdD0oZSx0KT0+e2Zvcih2YXIgciBpbiB0KV9uKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxEbD0oZSx0LHIsYSk9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG4gb2YgQmwodCkpIU1sLmNhbGwoZSxuKSYmbiE9PXImJl9uKGUsbix7Z2V0OigpPT50W25dLGVudW1lcmFibGU6IShhPWtsKHQsbikpfHxhLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIHZ0PWU9PkRsKF9uKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciBXcixCdCxmdCxOcixWcj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V3I9bmV3IE1hcCxCdD1bXSxmdD0oZSx0LHIpPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgYT1Xci5nZXQoZSk7aWYoYT09PXZvaWQgMClXci5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5OnJ9KTtlbHNle2lmKGEucHJpb3JpdHk+cilyZXR1cm47aWYoYS5wcmlvcml0eT09PXImJmEuYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke3J9YCl9aWYocj49MCl7bGV0IG49QnQuaW5kZXhPZihlKTtuIT09LTEmJkJ0LnNwbGljZShuLDEpO2ZvcihsZXQgcz0wO3M8QnQubGVuZ3RoO3MrKylpZihXci5nZXQoQnRbc10pLnByaW9yaXR5PD1yKXtCdC5zcGxpY2UocywwLGUpO3JldHVybn1CdC5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0sTnI9YXN5bmMgZT0+e2xldCB0PWUubGVuZ3RoPT09MD9CdDplLHI9W107Zm9yKGxldCBhIG9mIHQpe2xldCBuPVdyLmdldChhKTtpZihuKXtpZihuLmluaXRpYWxpemVkKXJldHVybiBuLmJhY2tlbmQ7aWYobi5hYm9ydGVkKWNvbnRpbnVlO2xldCBzPSEhbi5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIHN8fChuLmluaXRQcm9taXNlPW4uYmFja2VuZC5pbml0KCkpLGF3YWl0IG4uaW5pdFByb21pc2Usbi5pbml0aWFsaXplZD0hMCxuLmJhY2tlbmR9Y2F0Y2godSl7c3x8ci5wdXNoKHtuYW1lOmEsZXJyOnV9KSxuLmFib3J0ZWQ9ITB9ZmluYWxseXtkZWxldGUgbi5pbml0UHJvbWlzZX19fXRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtyLm1hcChhPT5gWyR7YS5uYW1lfV0gJHthLmVycn1gKS5qb2luKFwiLCBcIil9YCl9fSk7dmFyIExhPUwoKCk9PntcInVzZSBzdHJpY3RcIjtWcigpfSk7dmFyIEhhLGphPUwoKCk9PntcInVzZSBzdHJpY3RcIjtIYT1cIjEuMTcuMC1kZXYuMjAyMzExMDMtMTQzOWRhMzZmZVwifSk7dmFyIHFhLE9uLEthPUwoKCk9PntcInVzZSBzdHJpY3RcIjtqYSgpO3FhPVwid2FybmluZ1wiLE9uPXt3YXNtOnt9LHdlYmdsOnt9LHdlYmdwdTp7fSx2ZXJzaW9uczp7Y29tbW9uOkhhfSxzZXQgbG9nTGV2ZWwoZSl7aWYoZSE9PXZvaWQgMCl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCJ8fFtcInZlcmJvc2VcIixcImluZm9cIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJmYXRhbFwiXS5pbmRleE9mKGUpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCk7cWE9ZX19LGdldCBsb2dMZXZlbCgpe3JldHVybiBxYX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShPbixcImxvZ0xldmVsXCIse2VudW1lcmFibGU6ITB9KX0pO3ZhciBJZSxZYT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7S2EoKTtJZT1Pbn0pO3ZhciBYYSxKYSxRYT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WGE9KGUsdCk9PntsZXQgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Iud2lkdGg9ZS5kaW1zWzNdLHIuaGVpZ2h0PWUuZGltc1syXTtsZXQgYT1yLmdldENvbnRleHQoXCIyZFwiKTtpZihhIT1udWxsKXtsZXQgbixzO3Q/LnRlbnNvckxheW91dCE9PXZvaWQgMCYmdC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIj8obj1lLmRpbXNbMl0scz1lLmRpbXNbM10pOihuPWUuZGltc1szXSxzPWUuZGltc1syXSk7bGV0IHU9dD8uZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsbD10Py5ub3JtLG8scDtsPT09dm9pZCAwfHxsLm1lYW49PT12b2lkIDA/bz1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgbC5tZWFuPT1cIm51bWJlclwiP289W2wubWVhbixsLm1lYW4sbC5tZWFuLGwubWVhbl06KG89W2wubWVhblswXSxsLm1lYW5bMV0sbC5tZWFuWzJdLDBdLGwubWVhblszXSE9PXZvaWQgMCYmKG9bM109bC5tZWFuWzNdKSksbD09PXZvaWQgMHx8bC5iaWFzPT09dm9pZCAwP3A9WzAsMCwwLDBdOnR5cGVvZiBsLmJpYXM9PVwibnVtYmVyXCI/cD1bbC5iaWFzLGwuYmlhcyxsLmJpYXMsbC5iaWFzXToocD1bbC5iaWFzWzBdLGwuYmlhc1sxXSxsLmJpYXNbMl0sMF0sbC5iaWFzWzNdIT09dm9pZCAwJiYocFszXT1sLmJpYXNbM10pKTtsZXQgbT1zKm4seT0wLGc9bSx2PW0qMiwkPS0xO3U9PT1cIlJHQkFcIj8oeT0wLGc9bSx2PW0qMiwkPW0qMyk6dT09PVwiUkdCXCI/KHk9MCxnPW0sdj1tKjIpOnU9PT1cIlJCR1wiJiYoeT0wLHY9bSxnPW0qMik7Zm9yKGxldCBiPTA7YjxzO2IrKylmb3IobGV0IFM9MDtTPG47UysrKXtsZXQgST0oZS5kYXRhW3krK10tcFswXSkqb1swXSxUPShlLmRhdGFbZysrXS1wWzFdKSpvWzFdLEI9KGUuZGF0YVt2KytdLXBbMl0pKm9bMl0sUD0kPT09LTE/MjU1OihlLmRhdGFbJCsrXS1wWzNdKSpvWzNdO2EuZmlsbFN0eWxlPVwicmdiYShcIitJK1wiLFwiK1QrXCIsXCIrQitcIixcIitQK1wiKVwiLGEuZmlsbFJlY3QoUyxiLDEsMSl9cmV0dXJuIHIudG9EYXRhVVJMKCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfSxKYT0oZSx0KT0+e2xldCByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpLGE7aWYociE9bnVsbCl7bGV0IG4scyx1O3Q/LnRlbnNvckxheW91dCE9PXZvaWQgMCYmdC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIj8obj1lLmRpbXNbMl0scz1lLmRpbXNbMV0sdT1lLmRpbXNbM10pOihuPWUuZGltc1szXSxzPWUuZGltc1syXSx1PWUuZGltc1sxXSk7bGV0IGw9dCE9PXZvaWQgMCYmdC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIixvPXQ/Lm5vcm0scCxtO289PT12b2lkIDB8fG8ubWVhbj09PXZvaWQgMD9wPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiBvLm1lYW49PVwibnVtYmVyXCI/cD1bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXToocD1bby5tZWFuWzBdLG8ubWVhblsxXSxvLm1lYW5bMl0sMjU1XSxvLm1lYW5bM10hPT12b2lkIDAmJihwWzNdPW8ubWVhblszXSkpLG89PT12b2lkIDB8fG8uYmlhcz09PXZvaWQgMD9tPVswLDAsMCwwXTp0eXBlb2Ygby5iaWFzPT1cIm51bWJlclwiP209W28uYmlhcyxvLmJpYXMsby5iaWFzLG8uYmlhc106KG09W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLDBdLG8uYmlhc1szXSE9PXZvaWQgMCYmKG1bM109by5iaWFzWzNdKSk7bGV0IHk9cypuO2lmKHQhPT12b2lkIDAmJih0LmZvcm1hdCE9PXZvaWQgMCYmdT09PTQmJnQuZm9ybWF0IT09XCJSR0JBXCJ8fHU9PT0zJiZ0LmZvcm1hdCE9PVwiUkdCXCImJnQuZm9ybWF0IT09XCJCR1JcIikpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpO2xldCBnPTQsdj0wLCQ9MSxiPTIsUz0zLEk9MCxUPXksQj15KjIsUD0tMTtsPT09XCJSR0JBXCI/KEk9MCxUPXksQj15KjIsUD15KjMpOmw9PT1cIlJHQlwiPyhJPTAsVD15LEI9eSoyKTpsPT09XCJSQkdcIiYmKEk9MCxCPXksVD15KjIpLGE9ci5jcmVhdGVJbWFnZURhdGEobixzKTtmb3IobGV0IEQ9MDtEPHMqbjt2Kz1nLCQrPWcsYis9ZyxTKz1nLEQrKylhLmRhdGFbdl09KGUuZGF0YVtJKytdLW1bMF0pKnBbMF0sYS5kYXRhWyRdPShlLmRhdGFbVCsrXS1tWzFdKSpwWzFdLGEuZGF0YVtiXT0oZS5kYXRhW0IrK10tbVsyXSkqcFsyXSxhLmRhdGFbU109UD09PS0xPzI1NTooZS5kYXRhW1ArK10tbVszXSkqcFszXX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIik7cmV0dXJuIGF9fSk7dmFyIFRuLFphLGVvLHRvLHJvLG5vPUwoKCk9PntcInVzZSBzdHJpY3RcIjtVcigpO1RuPShlLHQpPT57aWYoZT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkXCIpO2lmKHQuaGVpZ2h0PT09dm9pZCAwfHx0LndpZHRoPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkXCIpO2lmKHQudGVuc29yTGF5b3V0PT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKFwiTkhXQyBUZW5zb3IgbGF5b3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO2xldHtoZWlnaHQ6cix3aWR0aDphfT10LG49dC5ub3JtPz97bWVhbjoyNTUsYmlhczowfSxzLHU7dHlwZW9mIG4ubWVhbj09XCJudW1iZXJcIj9zPVtuLm1lYW4sbi5tZWFuLG4ubWVhbixuLm1lYW5dOnM9W24ubWVhblswXSxuLm1lYW5bMV0sbi5tZWFuWzJdLG4ubWVhblszXT8/MjU1XSx0eXBlb2Ygbi5iaWFzPT1cIm51bWJlclwiP3U9W24uYmlhcyxuLmJpYXMsbi5iaWFzLG4uYmlhc106dT1bbi5iaWFzWzBdLG4uYmlhc1sxXSxuLmJpYXNbMl0sbi5iaWFzWzNdPz8wXTtsZXQgbD10LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQkFcIixvPXQudGVuc29yRm9ybWF0IT09dm9pZCAwJiZ0LnRlbnNvckZvcm1hdCE9PXZvaWQgMD90LnRlbnNvckZvcm1hdDpcIlJHQlwiLHA9ciphLG09bz09PVwiUkdCQVwiP25ldyBGbG9hdDMyQXJyYXkocCo0KTpuZXcgRmxvYXQzMkFycmF5KHAqMykseT00LGc9MCx2PTEsJD0yLGI9MyxTPTAsST1wLFQ9cCoyLEI9LTE7bD09PVwiUkdCXCImJih5PTMsZz0wLHY9MSwkPTIsYj0tMSksbz09PVwiUkdCQVwiP0I9cCozOm89PT1cIlJCR1wiPyhTPTAsVD1wLEk9cCoyKTpvPT09XCJCR1JcIiYmKFQ9MCxJPXAsUz1wKjIpO2ZvcihsZXQgRD0wO0Q8cDtEKyssZys9eSwkKz15LHYrPXksYis9eSltW1MrK109KGVbZ10rdVswXSkvc1swXSxtW0krK109KGVbdl0rdVsxXSkvc1sxXSxtW1QrK109KGVbJF0rdVsyXSkvc1syXSxCIT09LTEmJmIhPT0tMSYmKG1bQisrXT0oZVtiXSt1WzNdKS9zWzNdKTtyZXR1cm4gbz09PVwiUkdCQVwiP25ldyBGZShcImZsb2F0MzJcIixtLFsxLDQscixhXSk6bmV3IEZlKFwiZmxvYXQzMlwiLG0sWzEsMyxyLGFdKX0sWmE9YXN5bmMoZSx0KT0+e2xldCByPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PFwidVwiJiZlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCxhPXR5cGVvZiBJbWFnZURhdGE8XCJ1XCImJmUgaW5zdGFuY2VvZiBJbWFnZURhdGEsbj10eXBlb2YgSW1hZ2VCaXRtYXA8XCJ1XCImJmUgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCxzPXR5cGVvZiBlPT1cInN0cmluZ1wiLHUsbD10Pz97fTtpZihyKXtsZXQgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO28ud2lkdGg9ZS53aWR0aCxvLmhlaWdodD1lLmhlaWdodDtsZXQgcD1vLmdldENvbnRleHQoXCIyZFwiKTtpZihwIT1udWxsKXtsZXQgbT1lLmhlaWdodCx5PWUud2lkdGg7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkSGVpZ2h0IT09dm9pZCAwJiZ0LnJlc2l6ZWRXaWR0aCE9PXZvaWQgMCYmKG09dC5yZXNpemVkSGVpZ2h0LHk9dC5yZXNpemVkV2lkdGgpLHQhPT12b2lkIDApe2lmKGw9dCx0LnRlbnNvckZvcm1hdCE9PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudFwiKTtsLnRlbnNvckZvcm1hdD1cIlJHQkFcIixsLmhlaWdodD1tLGwud2lkdGg9eX1lbHNlIGwudGVuc29yRm9ybWF0PVwiUkdCQVwiLGwuaGVpZ2h0PW0sbC53aWR0aD15O3AuZHJhd0ltYWdlKGUsMCwwKSx1PXAuZ2V0SW1hZ2VEYXRhKDAsMCx5LG0pLmRhdGF9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2UgaWYoYSl7bGV0IG8scDtpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRXaWR0aCE9PXZvaWQgMCYmdC5yZXNpemVkSGVpZ2h0IT09dm9pZCAwPyhvPXQucmVzaXplZEhlaWdodCxwPXQucmVzaXplZFdpZHRoKToobz1lLmhlaWdodCxwPWUud2lkdGgpLHQhPT12b2lkIDAmJihsPXQpLGwuZm9ybWF0PVwiUkdCQVwiLGwuaGVpZ2h0PW8sbC53aWR0aD1wLHQhPT12b2lkIDApe2xldCBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7bS53aWR0aD1wLG0uaGVpZ2h0PW87bGV0IHk9bS5nZXRDb250ZXh0KFwiMmRcIik7aWYoeSE9bnVsbCl5LnB1dEltYWdlRGF0YShlLDAsMCksdT15LmdldEltYWdlRGF0YSgwLDAscCxvKS5kYXRhO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIHU9ZS5kYXRhfWVsc2UgaWYobil7aWYodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2xldCBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7by53aWR0aD1lLndpZHRoLG8uaGVpZ2h0PWUuaGVpZ2h0O2xldCBwPW8uZ2V0Q29udGV4dChcIjJkXCIpO2lmKHAhPW51bGwpe2xldCBtPWUuaGVpZ2h0LHk9ZS53aWR0aDtyZXR1cm4gcC5kcmF3SW1hZ2UoZSwwLDAseSxtKSx1PXAuZ2V0SW1hZ2VEYXRhKDAsMCx5LG0pLmRhdGEsbC5oZWlnaHQ9bSxsLndpZHRoPXksVG4odSxsKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihzKXJldHVybiBuZXcgUHJvbWlzZSgobyxwKT0+e2xldCBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikseT1tLmdldENvbnRleHQoXCIyZFwiKTtpZighZXx8IXkpcmV0dXJuIHAoKTtsZXQgZz1uZXcgSW1hZ2U7Zy5jcm9zc09yaWdpbj1cIkFub255bW91c1wiLGcuc3JjPWUsZy5vbmxvYWQ9KCk9PnttLndpZHRoPWcud2lkdGgsbS5oZWlnaHQ9Zy5oZWlnaHQseS5kcmF3SW1hZ2UoZywwLDAsbS53aWR0aCxtLmhlaWdodCk7bGV0IHY9eS5nZXRJbWFnZURhdGEoMCwwLG0ud2lkdGgsbS5oZWlnaHQpO2wuaGVpZ2h0PW0uaGVpZ2h0LGwud2lkdGg9bS53aWR0aCxvKFRuKHYuZGF0YSxsKSl9fSk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9aWYodSE9PXZvaWQgMClyZXR1cm4gVG4odSxsKTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX0sZW89KGUsdCk9PntsZXR7d2lkdGg6cixoZWlnaHQ6YSxkb3dubG9hZDpuLGRpc3Bvc2U6c309dCx1PVsxLGEsciw0XTtyZXR1cm4gbmV3IEZlKHtsb2NhdGlvbjpcInRleHR1cmVcIix0eXBlOlwiZmxvYXQzMlwiLHRleHR1cmU6ZSxkaW1zOnUsZG93bmxvYWQ6bixkaXNwb3NlOnN9KX0sdG89KGUsdCk9PntsZXR7ZGF0YVR5cGU6cixkaW1zOmEsZG93bmxvYWQ6bixkaXNwb3NlOnN9PXQ7cmV0dXJuIG5ldyBGZSh7bG9jYXRpb246XCJncHUtYnVmZmVyXCIsdHlwZTpyPz9cImZsb2F0MzJcIixncHVCdWZmZXI6ZSxkaW1zOmEsZG93bmxvYWQ6bixkaXNwb3NlOnN9KX0scm89KGUsdCxyKT0+bmV3IEZlKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIix0eXBlOmUsZGF0YTp0LGRpbXM6cj8/W3QubGVuZ3RoXX0pfSk7dmFyIGxyLEdyLGFvLG9vLGlvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtscj1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsRmxvYXQzMkFycmF5XSxbXCJ1aW50OFwiLFVpbnQ4QXJyYXldLFtcImludDhcIixJbnQ4QXJyYXldLFtcInVpbnQxNlwiLFVpbnQxNkFycmF5XSxbXCJmbG9hdDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldXSksR3I9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLGFvPSExLG9vPSgpPT57aWYoIWFvKXthbz0hMDtsZXQgZT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmdHlwZW9mIEJpZ0ludDY0QXJyYXkuZnJvbT09XCJmdW5jdGlvblwiLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZ0eXBlb2YgQmlnVWludDY0QXJyYXkuZnJvbT09XCJmdW5jdGlvblwiO2UmJihsci5zZXQoXCJpbnQ2NFwiLEJpZ0ludDY0QXJyYXkpLEdyLnNldChCaWdJbnQ2NEFycmF5LFwiaW50NjRcIikpLHQmJihsci5zZXQoXCJ1aW50NjRcIixCaWdVaW50NjRBcnJheSksR3Iuc2V0KEJpZ1VpbnQ2NEFycmF5LFwidWludDY0XCIpKX19fSk7dmFyIHNvLHVvLGxvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtVcigpO3NvPWU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtsZXQgYT1lW3JdO2lmKHR5cGVvZiBhIT1cIm51bWJlclwifHwhTnVtYmVyLmlzU2FmZUludGVnZXIoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske3J9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHthfWApO2lmKGE8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske3J9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHthfWApO3QqPWF9cmV0dXJuIHR9LHVvPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgRmUoZS50eXBlLGUuZGF0YSx0KTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIG5ldyBGZSh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsZGF0YTplLmRhdGEsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwidGV4dHVyZVwiOnJldHVybiBuZXcgRmUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHRleHR1cmU6ZS50ZXh0dXJlLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gbmV3IEZlKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIixncHVCdWZmZXI6ZS5ncHVCdWZmZXIsdHlwZTplLnR5cGUsZGltczp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke2UubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKX19fSk7dmFyIEZlLFVyPUwoKCk9PntcInVzZSBzdHJpY3RcIjtRYSgpO25vKCk7aW8oKTtsbygpO0ZlPWNsYXNze2NvbnN0cnVjdG9yKHQscixhKXtvbygpO2xldCBuLHM7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCImJlwibG9jYXRpb25cImluIHQpc3dpdGNoKHRoaXMuZGF0YUxvY2F0aW9uPXQubG9jYXRpb24sbj10LnR5cGUscz10LmRpbXMsdC5sb2NhdGlvbil7Y2FzZVwiY3B1LXBpbm5lZFwiOntsZXQgbD1sci5nZXQobik7aWYoIWwpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7bn1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO2lmKCEodC5kYXRhIGluc3RhbmNlb2YgbCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7bC5uYW1lfWApO3RoaXMuY3B1RGF0YT10LmRhdGE7YnJlYWt9Y2FzZVwidGV4dHVyZVwiOntpZihuIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7bn1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO3RoaXMuZ3B1VGV4dHVyZURhdGE9dC50ZXh0dXJlLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcImdwdS1idWZmZXJcIjp7aWYobiE9PVwiZmxvYXQzMlwiJiZuIT09XCJmbG9hdDE2XCImJm4hPT1cImludDMyXCImJm4hPT1cImludDY0XCImJm4hPT1cInVpbnQzMlwiJiZuIT09XCJib29sXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7bn1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO3RoaXMuZ3B1QnVmZmVyRGF0YT10LmdwdUJ1ZmZlcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCl9ZWxzZXtsZXQgbCxvO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKG49dCxvPWEsdD09PVwic3RyaW5nXCIpe2lmKCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO2w9cn1lbHNle2xldCBwPWxyLmdldCh0KTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke3R9LmApO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHQ9PT1cImZsb2F0MTZcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ3JlYXRpbmcgYSBmbG9hdDE2IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIFVpbnQxNkFycmF5IGFzIGRhdGEuXCIpO3Q9PT1cInVpbnQ2NFwifHx0PT09XCJpbnQ2NFwiP2w9cC5mcm9tKHIsQmlnSW50KTpsPXAuZnJvbShyKX1lbHNlIGlmKHIgaW5zdGFuY2VvZiBwKWw9cjtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHtufSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3B9YCl9ZWxzZSBpZihvPXIsQXJyYXkuaXNBcnJheSh0KSl7aWYodC5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS5cIik7bGV0IHA9dHlwZW9mIHRbMF07aWYocD09PVwic3RyaW5nXCIpbj1cInN0cmluZ1wiLGw9dDtlbHNlIGlmKHA9PT1cImJvb2xlYW5cIiluPVwiYm9vbFwiLGw9VWludDhBcnJheS5mcm9tKHQpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtwfS5gKX1lbHNle2xldCBwPUdyLmdldCh0LmNvbnN0cnVjdG9yKTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke3QuY29uc3RydWN0b3J9LmApO249cCxsPXR9aWYobz09PXZvaWQgMClvPVtsLmxlbmd0aF07ZWxzZSBpZighQXJyYXkuaXNBcnJheShvKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZW5zb3IncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXlcIik7cz1vLHRoaXMuY3B1RGF0YT1sLHRoaXMuZGF0YUxvY2F0aW9uPVwiY3B1XCJ9bGV0IHU9c28ocyk7aWYodGhpcy5jcHVEYXRhJiZ1IT09dGhpcy5jcHVEYXRhLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHt1fSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7dGhpcy50eXBlPW4sdGhpcy5kaW1zPXMsdGhpcy5zaXplPXV9c3RhdGljIGFzeW5jIGZyb21JbWFnZSh0LHIpe3JldHVybiBaYSh0LHIpfXN0YXRpYyBmcm9tVGV4dHVyZSh0LHIpe3JldHVybiBlbyh0LHIpfXN0YXRpYyBmcm9tR3B1QnVmZmVyKHQscil7cmV0dXJuIHRvKHQscil9c3RhdGljIGZyb21QaW5uZWRCdWZmZXIodCxyLGEpe3JldHVybiBybyh0LHIsYSl9dG9EYXRhVVJMKHQpe3JldHVybiBYYSh0aGlzLHQpfXRvSW1hZ2VEYXRhKHQpe3JldHVybiBKYSh0aGlzLHQpfWdldCBkYXRhKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmNwdURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IG9uIENQVS4gVXNlIGBnZXREYXRhKClgIHRvIGRvd25sb2FkIEdQVSBkYXRhIHRvIENQVSwgb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LlwiKTtyZXR1cm4gdGhpcy5jcHVEYXRhfWdldCBsb2NhdGlvbigpe3JldHVybiB0aGlzLmRhdGFMb2NhdGlvbn1nZXQgdGV4dHVyZSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVUZXh0dXJlRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS5cIik7cmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGF9Z2V0IGdwdUJ1ZmZlcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVCdWZmZXJEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHUFUgYnVmZmVyLlwiKTtyZXR1cm4gdGhpcy5ncHVCdWZmZXJEYXRhfWFzeW5jIGdldERhdGEodCl7c3dpdGNoKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRhdGFMb2NhdGlvbil7Y2FzZVwiY3B1XCI6Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiB0aGlzLmRhdGE7Y2FzZVwidGV4dHVyZVwiOmNhc2VcImdwdS1idWZmZXJcIjp7aWYoIXRoaXMuZG93bmxvYWRlcil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuXCIpO2lmKHRoaXMuaXNEb3dubG9hZGluZyl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC5cIik7dHJ5e3RoaXMuaXNEb3dubG9hZGluZz0hMDtsZXQgcj1hd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtyZXR1cm4gdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwiLHRoaXMuY3B1RGF0YT1yLHQmJnRoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHJ9ZmluYWxseXt0aGlzLmlzRG93bmxvYWRpbmc9ITF9fWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZ2V0IGRhdGEgZnJvbSBsb2NhdGlvbjogJHt0aGlzLmRhdGFMb2NhdGlvbn1gKX19ZGlzcG9zZSgpe2lmKHRoaXMuaXNEb3dubG9hZGluZyl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC5cIik7dGhpcy5kaXNwb3NlciYmKHRoaXMuZGlzcG9zZXIoKSx0aGlzLmRpc3Bvc2VyPXZvaWQgMCksdGhpcy5jcHVEYXRhPXZvaWQgMCx0aGlzLmdwdVRleHR1cmVEYXRhPXZvaWQgMCx0aGlzLmdwdUJ1ZmZlckRhdGE9dm9pZCAwLHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5pc0Rvd25sb2FkaW5nPXZvaWQgMCx0aGlzLmRhdGFMb2NhdGlvbj1cIm5vbmVcIn1lbnN1cmVWYWxpZCgpe2lmKHRoaXMuZGF0YUxvY2F0aW9uPT09XCJub25lXCIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cIil9cmVzaGFwZSh0KXtpZih0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kb3dubG9hZGVyfHx0aGlzLmRpc3Bvc2VyKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuXCIpO3JldHVybiB1byh0aGlzLHQpfX19KTt2YXIgVWUsRnI9TCgoKT0+e1widXNlIHN0cmljdFwiO1VyKCk7VWU9RmV9KTt2YXIgTHIsY289TCgoKT0+e1widXNlIHN0cmljdFwiO1ZyKCk7RnIoKTtMcj1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWFzeW5jIHJ1bih0LHIsYSl7bGV0IG49e30scz17fTtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGx8fHQgaW5zdGFuY2VvZiBVZXx8QXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCB1PSEwO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiKXtpZihyPT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKHIgaW5zdGFuY2VvZiBVZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZihyLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO3U9ITE7Zm9yKGxldCBwIG9mIHIpe2lmKHR5cGVvZiBwIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihwKT09PS0xKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtwfS5gKTtuW3BdPW51bGx9aWYodHlwZW9mIGE9PVwib2JqZWN0XCImJmEhPT1udWxsKXM9YTtlbHNlIGlmKHR5cGVvZiBhPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IHA9ITEsbT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKTtmb3IobGV0IHkgb2YgdGhpcy5vdXRwdXROYW1lcylpZihtLmluZGV4T2YoeSkhPT0tMSl7bGV0IGc9clt5XTsoZz09PW51bGx8fGcgaW5zdGFuY2VvZiBVZSkmJihwPSEwLHU9ITEsblt5XT1nKX1pZihwKXtpZih0eXBlb2YgYT09XCJvYmplY3RcIiYmYSE9PW51bGwpcz1hO2Vsc2UgaWYodHlwZW9mIGE8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBzPXJ9fWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGxldCBwIG9mIHRoaXMuaW5wdXROYW1lcylpZih0eXBlb2YgdFtwXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke3B9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYodSlmb3IobGV0IHAgb2YgdGhpcy5vdXRwdXROYW1lcyluW3BdPW51bGw7bGV0IGw9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1bih0LG4scyksbz17fTtmb3IobGV0IHAgaW4gbClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChsLHApKXtsZXQgbT1sW3BdO20gaW5zdGFuY2VvZiBVZT9vW3BdPW06b1twXT1uZXcgVWUobS50eXBlLG0uZGF0YSxtLmRpbXMpfXJldHVybiBvfWFzeW5jIHJlbGVhc2UoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKX1zdGF0aWMgYXN5bmMgY3JlYXRlKHQscixhLG4pe2xldCBzLHU9e307aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKHM9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpdT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYocz10LHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbCl1PXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiZ0IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpe2xldCB5PXQsZz0wLHY9dC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbCl1PXI7ZWxzZSBpZih0eXBlb2Ygcj09XCJudW1iZXJcIil7aWYoZz1yLCFOdW1iZXIuaXNTYWZlSW50ZWdlcihnKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKGc8MHx8Zz49eS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke3kuYnl0ZUxlbmd0aH0pLmApO2lmKHY9dC5ieXRlTGVuZ3RoLWcsdHlwZW9mIGE9PVwibnVtYmVyXCIpe2lmKHY9YSwhTnVtYmVyLmlzU2FmZUludGVnZXIodikpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZih2PD0wfHxnK3Y+eS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke3kuYnl0ZUxlbmd0aC1nfV0uYCk7aWYodHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKXU9bjtlbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodHlwZW9mIGE8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO3M9bmV3IFVpbnQ4QXJyYXkoeSxnLHYpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTtsZXQgbz0odS5leGVjdXRpb25Qcm92aWRlcnN8fFtdKS5tYXAoeT0+dHlwZW9mIHk9PVwic3RyaW5nXCI/eTp5Lm5hbWUpLG09YXdhaXQoYXdhaXQgTnIobykpLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHMsdSk7cmV0dXJuIG5ldyBlKG0pfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpfWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXN9fX0pO3ZhciBwbyxmbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Y28oKTtwbz1Mcn0pO3ZhciBtbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgemwsSHIsaG89TCgoKT0+e1widXNlIHN0cmljdFwiO1ZyKCk7RnIoKTt6bD1cIlRyYWluaW5nIGJhY2tlbmQgY291bGQgbm90IGJlIHJlc29sdmVkLiBNYWtlIHN1cmUgeW91J3JlIHVzaW5nIHRoZSBjb3JyZWN0IGNvbmZpZ3VyYXRpb24gJiBXZWJBc3NlbWJseSBmaWxlcy5cIixIcj1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXN9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LHIpe2xldCBhPXQuZXZhbE1vZGVsfHxcIlwiLG49dC5vcHRpbWl6ZXJNb2RlbHx8XCJcIixzPXJ8fHt9LGw9KHMuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSkubWFwKHA9PnR5cGVvZiBwPT1cInN0cmluZ1wiP3A6cC5uYW1lKSxvPWF3YWl0IE5yKGwpO2lmKG8uY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcil7bGV0IHA9YXdhaXQgby5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKHQuY2hlY2twb2ludFN0YXRlLHQudHJhaW5Nb2RlbCxhLG4scyk7cmV0dXJuIG5ldyBlKHApfWVsc2UgdGhyb3cgbmV3IEVycm9yKHpsKX10eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0LHIsYSl7bGV0IG49e30scz17fTtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGx8fHQgaW5zdGFuY2VvZiBVZXx8QXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCB1PSEwO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiKXtpZihyPT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKHIgaW5zdGFuY2VvZiBVZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZihyLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO3U9ITE7Zm9yKGxldCBsIG9mIHIpe2lmKHR5cGVvZiBsIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihsKT09PS0xKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtsfS5gKTtuW2xdPW51bGx9aWYodHlwZW9mIGE9PVwib2JqZWN0XCImJmEhPT1udWxsKXM9YTtlbHNlIGlmKHR5cGVvZiBhPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IGw9ITEsbz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKTtmb3IobGV0IHAgb2YgdGhpcy5vdXRwdXROYW1lcylpZihvLmluZGV4T2YocCkhPT0tMSl7bGV0IG09cltwXTsobT09PW51bGx8fG0gaW5zdGFuY2VvZiBVZSkmJihsPSEwLHU9ITEsbltwXT1tKX1pZihsKXtpZih0eXBlb2YgYT09XCJvYmplY3RcIiYmYSE9PW51bGwpcz1hO2Vsc2UgaWYodHlwZW9mIGE8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBzPXJ9fWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGxldCBsIG9mIHRoaXMuaW5wdXROYW1lcylpZih0eXBlb2YgdFtsXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke2x9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYodSlmb3IobGV0IGwgb2YgdGhpcy5vdXRwdXROYW1lcyluW2xdPW51bGw7cmV0dXJuW24sc119Y29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnModCl7bGV0IHI9e307Zm9yKGxldCBhIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxhKSl7bGV0IG49dFthXTtuIGluc3RhbmNlb2YgVWU/clthXT1uOnJbYV09bmV3IFVlKG4udHlwZSxuLmRhdGEsbi5kaW1zKX1yZXR1cm4gcn1hc3luYyBydW5UcmFpblN0ZXAodCxyLGEpe2xldFtuLHNdPXRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAodCxyLGEpLHU9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1blRyYWluU3RlcCh0LG4scyk7cmV0dXJuIHRoaXMuY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnModSl9YXN5bmMgbG9hZFBhcmFtZXRlcnNCdWZmZXIodCxyKXt0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKX1hc3luYyBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0KXt0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKX1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9fX0pO3ZhciBnbyx5bz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aG8oKTtnbz1Icn0pO3ZhciBSbj17fTtrdChSbix7SW5mZXJlbmNlU2Vzc2lvbjooKT0+cG8sVGVuc29yOigpPT5VZSxUcmFpbmluZ1Nlc3Npb246KCk9PmdvLGVudjooKT0+SWUscmVnaXN0ZXJCYWNrZW5kOigpPT5mdH0pO3ZhciAkdD1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TGEoKTtZYSgpO2ZvKCk7RnIoKTttbygpO3lvKCl9KTt2YXIgUG49e307a3QoUG4se3JlYWRGaWxlOigpPT5XbH0pO3ZhciBXbCxrbj1MKCgpPT57V2w9dm9pZCAwfSk7dmFyIEJuPXt9O2t0KEJuLHtqb2luOigpPT5ObH0pO3ZhciBObCxNbj1MKCgpPT57Tmw9dm9pZCAwfSk7dmFyICRvPUx0KCh2byxEbik9PntcInVzZSBzdHJpY3RcIjt2YXIgd289KCgpPT57dmFyIGU9dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMDtyZXR1cm4gdHlwZW9mIF9fZmlsZW5hbWU8XCJ1XCImJihlPWV8fF9fZmlsZW5hbWUpLGZ1bmN0aW9uKHQ9e30pe3ZhciByPXQsYSxuO3IucmVhZHk9bmV3IFByb21pc2UoKGQsZik9PnthPWQsbj1mfSksci5qc2VwSW5pdD0oZCxmLHcsQyxfLEcsVix1ZSk9PntyLlphPWQsci5PYT1mLHIuUWE9dyxyLkphPUMsci5QYT1fLHIucmE9RyxyLlJhPVYsci5TYT11ZSxmPShZLFosSik9PiguLi5jZSk9PntsZXQgbWU9WWUsRT1aPy4oKTtjZT1ZKC4uLmNlKTtsZXQgdGU9Wj8uKCk7cmV0dXJuIEUhPT10ZSYmKFk9dGUsSihFKSxaPUo9bnVsbCksWWUhPW1lP19yKCk6Y2V9LHc9WT0+YXN5bmMoLi4uWik9Pnt0cnl7aWYoci5EYSl0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCBKPXIuRGE9e1RhOlpbMF0sZXJyb3JzOltdfSxjZT1hd2FpdCBZKC4uLlopO2lmKHIuRGEhPT1KKXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTtkLmZsdXNoKCk7bGV0IG1lPUouZXJyb3JzO2lmKDA8bWUubGVuZ3RoKXtsZXQgRT1hd2FpdCBQcm9taXNlLmFsbChtZSk7aWYoRT1FLmZpbHRlcih0ZT0+dGUpLDA8RS5sZW5ndGgpdGhyb3cgRXJyb3IoRS5qb2luKGBcbmApKX1yZXR1cm4gY2V9ZmluYWxseXtyLkRhPW51bGx9fSxyLl9PcnRSdW49dyhmKHIuX09ydFJ1biwoKT0+ci5fT3J0UnVuLFk9PnIuX09ydFJ1bj1ZKSksci5fT3J0UnVuV2l0aEJpbmRpbmc9dyhmKHIuX09ydFJ1bldpdGhCaW5kaW5nLCgpPT5yLl9PcnRSdW5XaXRoQmluZGluZyxZPT5yLl9PcnRSdW5XaXRoQmluZGluZz1ZKSksci5fT3J0QmluZElucHV0PWYoci5fT3J0QmluZElucHV0LCgpPT5yLl9PcnRCaW5kSW5wdXQsWT0+ci5fT3J0QmluZElucHV0PVkpLHIuanNlcFJlZ2lzdGVyQnVmZmVyPShZLFosSixjZSk9PmQucmVnaXN0ZXJCdWZmZXIoWSxaLEosY2UpLHIuanNlcFVucmVnaXN0ZXJCdWZmZXJzPVk9PntkLnVucmVnaXN0ZXJCdWZmZXJzKFkpfSxyLmpzZXBHZXRCdWZmZXI9WT0+ZC5nZXRCdWZmZXIoWSksci5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oWSxaLEopPT5kLmNyZWF0ZURvd25sb2FkZXIoWSxaLEopfTt2YXIgcz1PYmplY3QuYXNzaWduKHt9LHIpLHU9XCIuL3RoaXMucHJvZ3JhbVwiLGw9KGQsZik9Pnt0aHJvdyBmfSxvPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIscD10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLG09dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLHk9XCJcIixnLHYsJDtpZihtKXt2YXIgYj0oa24oKSx2dChQbikpLFM9KE1uKCksdnQoQm4pKTt5PXA/Uy5kaXJuYW1lKHkpK1wiL1wiOl9fZGlybmFtZStcIi9cIixnPShkLGYpPT4oZD1kLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwoZCk6Uy5ub3JtYWxpemUoZCksYi5yZWFkRmlsZVN5bmMoZCxmP3ZvaWQgMDpcInV0ZjhcIikpLCQ9ZD0+KGQ9ZyhkLCEwKSxkLmJ1ZmZlcnx8KGQ9bmV3IFVpbnQ4QXJyYXkoZCkpLGQpLHY9KGQsZix3LEM9ITApPT57ZD1kLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwoZCk6Uy5ub3JtYWxpemUoZCksYi5yZWFkRmlsZShkLEM/dm9pZCAwOlwidXRmOFwiLChfLEcpPT57Xz93KF8pOmYoQz9HLmJ1ZmZlcjpHKX0pfSwhci50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYodT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLGw9KGQsZik9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWQsZn0sci5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9ZWxzZShvfHxwKSYmKHA/eT1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoeT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksZSYmKHk9ZSkseS5pbmRleE9mKFwiYmxvYjpcIikhPT0wP3k9eS5zdWJzdHIoMCx5LnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOnk9XCJcIixnPWQ9Pnt2YXIgZj1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGYub3BlbihcIkdFVFwiLGQsITEpLGYuc2VuZChudWxsKSxmLnJlc3BvbnNlVGV4dH0scCYmKCQ9ZD0+e3ZhciBmPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZi5vcGVuKFwiR0VUXCIsZCwhMSksZi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGYuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShmLnJlc3BvbnNlKX0pLHY9KGQsZix3KT0+e3ZhciBDPW5ldyBYTUxIdHRwUmVxdWVzdDtDLm9wZW4oXCJHRVRcIixkLCEwKSxDLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsQy5vbmxvYWQ9KCk9PntDLnN0YXR1cz09MjAwfHxDLnN0YXR1cz09MCYmQy5yZXNwb25zZT9mKEMucmVzcG9uc2UpOncoKX0sQy5vbmVycm9yPXcsQy5zZW5kKG51bGwpfSk7dmFyIEk9ci5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxUPXIucHJpbnRFcnJ8fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKHIscykscz1udWxsLHIudGhpc1Byb2dyYW0mJih1PXIudGhpc1Byb2dyYW0pLHIucXVpdCYmKGw9ci5xdWl0KTt2YXIgQjtyLndhc21CaW5hcnkmJihCPXIud2FzbUJpbmFyeSk7dmFyIFA9ci5ub0V4aXRSdW50aW1lfHwhMDt0eXBlb2YgV2ViQXNzZW1ibHkhPVwib2JqZWN0XCImJnFlKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgRCxSLFc9ITEsSCxLLGxlLE0scSx4ZSxvZTtmdW5jdGlvbiB3ZSgpe3ZhciBkPUQuYnVmZmVyO3IuSEVBUDg9Sz1uZXcgSW50OEFycmF5KGQpLHIuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGQpLHIuSEVBUDMyPU09bmV3IEludDMyQXJyYXkoZCksci5IRUFQVTg9bGU9bmV3IFVpbnQ4QXJyYXkoZCksci5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShkKSxyLkhFQVBVMzI9cT1uZXcgVWludDMyQXJyYXkoZCksci5IRUFQRjMyPXhlPW5ldyBGbG9hdDMyQXJyYXkoZCksci5IRUFQRjY0PW9lPW5ldyBGbG9hdDY0QXJyYXkoZCl9dmFyIGo9W10sU2U9W10sVGU9W107ZnVuY3Rpb24gRWUoKXt2YXIgZD1yLnByZVJ1bi5zaGlmdCgpO2oudW5zaGlmdChkKX12YXIgQ2U9MCxndD1udWxsLExlPW51bGw7ZnVuY3Rpb24gcWUoZCl7dGhyb3cgci5vbkFib3J0JiZyLm9uQWJvcnQoZCksZD1cIkFib3J0ZWQoXCIrZCtcIilcIixUKGQpLFc9ITAsSD0xLGQ9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihkK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxuKGQpLGR9ZnVuY3Rpb24gVShkKXtyZXR1cm4gZC5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX12YXIgZGU7aWYoZGU9XCJvcnQtd2FzbS1zaW1kLndhc21cIiwhVShkZSkpe3ZhciBwZT1kZTtkZT1yLmxvY2F0ZUZpbGU/ci5sb2NhdGVGaWxlKHBlLHkpOnkrcGV9ZnVuY3Rpb24gTmUoZCl7aWYoZD09ZGUmJkIpcmV0dXJuIG5ldyBVaW50OEFycmF5KEIpO2lmKCQpcmV0dXJuICQoZCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gSGUoZCl7aWYoIUImJihvfHxwKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFkLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChkLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGY9PntpZighZi5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrZCtcIidcIjtyZXR1cm4gZi5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9Pk5lKGQpKTtpZih2KXJldHVybiBuZXcgUHJvbWlzZSgoZix3KT0+e3YoZCxDPT5mKG5ldyBVaW50OEFycmF5KEMpKSx3KX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5OZShkKSl9ZnVuY3Rpb24gT2UoZCxmLHcpe3JldHVybiBIZShkKS50aGVuKEM9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEMsZikpLnRoZW4oQz0+QykudGhlbih3LEM9PntUKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrQykscWUoQyl9KX1mdW5jdGlvbiB6ZShkLGYpe3ZhciB3PWRlO3JldHVybiBCfHx0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8VSh3KXx8dy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8bXx8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/T2UodyxkLGYpOmZldGNoKHcse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oQz0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoQyxkKS50aGVuKGYsZnVuY3Rpb24oXyl7cmV0dXJuIFQoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrXyksVChcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLE9lKHcsZCxmKX0pKX12YXIgR2UsZXQ9ezkxMzc5MjpkPT57ci5yYShcIkFic1wiLGQsdm9pZCAwKX0sOTEzODQzOmQ9PntyLnJhKFwiTmVnXCIsZCx2b2lkIDApfSw5MTM4OTQ6ZD0+e3IucmEoXCJGbG9vclwiLGQsdm9pZCAwKX0sOTEzOTQ3OmQ9PntyLnJhKFwiQ2VpbFwiLGQsdm9pZCAwKX0sOTEzOTk5OmQ9PntyLnJhKFwiUmVjaXByb2NhbFwiLGQsdm9pZCAwKX0sOTE0MDU3OmQ9PntyLnJhKFwiU3FydFwiLGQsdm9pZCAwKX0sOTE0MTA5OmQ9PntyLnJhKFwiRXhwXCIsZCx2b2lkIDApfSw5MTQxNjA6ZD0+e3IucmEoXCJFcmZcIixkLHZvaWQgMCl9LDkxNDIxMTpkPT57ci5yYShcIlNpZ21vaWRcIixkLHZvaWQgMCl9LDkxNDI2NjpkPT57ci5yYShcIkxvZ1wiLGQsdm9pZCAwKX0sOTE0MzE3OmQ9PntyLnJhKFwiU2luXCIsZCx2b2lkIDApfSw5MTQzNjg6ZD0+e3IucmEoXCJDb3NcIixkLHZvaWQgMCl9LDkxNDQxOTpkPT57ci5yYShcIlRhblwiLGQsdm9pZCAwKX0sOTE0NDcwOmQ9PntyLnJhKFwiQXNpblwiLGQsdm9pZCAwKX0sOTE0NTIyOmQ9PntyLnJhKFwiQWNvc1wiLGQsdm9pZCAwKX0sOTE0NTc0OmQ9PntyLnJhKFwiQXRhblwiLGQsdm9pZCAwKX0sOTE0NjI2OmQ9PntyLnJhKFwiU2luaFwiLGQsdm9pZCAwKX0sOTE0Njc4OmQ9PntyLnJhKFwiQ29zaFwiLGQsdm9pZCAwKX0sOTE0NzMwOmQ9PntyLnJhKFwiQXNpbmhcIixkLHZvaWQgMCl9LDkxNDc4MzpkPT57ci5yYShcIkFjb3NoXCIsZCx2b2lkIDApfSw5MTQ4MzY6ZD0+e3IucmEoXCJBdGFuaFwiLGQsdm9pZCAwKX0sOTE0ODg5OmQ9PntyLnJhKFwiVGFuaFwiLGQsdm9pZCAwKX0sOTE0OTQxOmQ9PntyLnJhKFwiTm90XCIsZCx2b2lkIDApfSw5MTQ5OTI6KGQsZix3KT0+e3IucmEoXCJDbGlwVjEwXCIsZCx7bWluOmYsbWF4Ond9KX0sOTE1MDY0OmQ9PntyLnJhKFwiQ2xpcFwiLGQsdm9pZCAwKX0sOTE1MTE2OihkLGYpPT57ci5yYShcIkVsdVwiLGQse2FscGhhOmZ9KX0sOTE1MTc0OmQ9PntyLnJhKFwiUmVsdVwiLGQsdm9pZCAwKX0sOTE1MjI2OihkLGYpPT57ci5yYShcIkxlYWt5UmVsdVwiLGQse2FscGhhOmZ9KX0sOTE1MjkwOihkLGYpPT57ci5yYShcIlRocmVzaG9sZGVkUmVsdVwiLGQse2FscGhhOmZ9KX0sOTE1MzYwOihkLGYpPT57ci5yYShcIkNhc3RcIixkLHt0bzpmfSl9LDkxNTQxODpkPT57ci5yYShcIkFkZFwiLGQsdm9pZCAwKX0sOTE1NDY5OmQ9PntyLnJhKFwiU3ViXCIsZCx2b2lkIDApfSw5MTU1MjA6ZD0+e3IucmEoXCJNdWxcIixkLHZvaWQgMCl9LDkxNTU3MTpkPT57ci5yYShcIkRpdlwiLGQsdm9pZCAwKX0sOTE1NjIyOmQ9PntyLnJhKFwiUG93XCIsZCx2b2lkIDApfSw5MTU2NzM6ZD0+e3IucmEoXCJFcXVhbFwiLGQsdm9pZCAwKX0sOTE1NzI2OmQ9PntyLnJhKFwiR3JlYXRlclwiLGQsdm9pZCAwKX0sOTE1NzgxOmQ9PntyLnJhKFwiR3JlYXRlck9yRXF1YWxcIixkLHZvaWQgMCl9LDkxNTg0MzpkPT57ci5yYShcIkxlc3NcIixkLHZvaWQgMCl9LDkxNTg5NTpkPT57ci5yYShcIkxlc3NPckVxdWFsXCIsZCx2b2lkIDApfSw5MTU5NTQ6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlTWVhblwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE2MTE4OihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZU1heFwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE2MjgxOihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZU1pblwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE2NDQ0OihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZVByb2RcIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNjYwODooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VTdW1cIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNjc3MTooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VMMVwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE2OTMzOihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZUwyXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTcwOTU6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlTG9nU3VtXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTcyNjE6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlU3VtU3F1YXJlXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTc0MzA6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlTG9nU3VtRXhwXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTc1OTk6ZD0+e3IucmEoXCJXaGVyZVwiLGQsdm9pZCAwKX0sOTE3NjUyOihkLGYsdyk9PntyLnJhKFwiVHJhbnNwb3NlXCIsZCx7cGVybTpmP0FycmF5LmZyb20oTS5zdWJhcnJheSh3Pj4+MCx3K2Y+Pj4wKSk6W119KX0sOTE3NzY1OihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUsdGUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixkLHtmb3JtYXQ6WT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmYsZGlsYXRpb25zOlt3XSxncm91cDpDLGtlcm5lbF9zaGFwZTpbX10scGFkczpbRyxWXSxzdHJpZGVzOlt1ZV0sd0lzQ29uc3Q6KCk9PiEhS1taPj4+MF0sb3V0cHV0UGFkZGluZzpKP0FycmF5LmZyb20oTS5zdWJhcnJheShjZT4+PjAsY2UrSj4+PjApKTpbXSxvdXRwdXRTaGFwZTptZT9BcnJheS5mcm9tKE0uc3ViYXJyYXkoRT4+PjAsRSttZT4+PjApKTpbXSxhY3RpdmF0aW9uOlJlKHRlKX0pfSw5MTgxNzk6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGQse2Zvcm1hdDp1ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmYsZGlsYXRpb25zOkFycmF5LmZyb20oTS5zdWJhcnJheSh3Pj4+MCx3KzI+Pj4wKSksZ3JvdXA6QyxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXysyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShNLnN1YmFycmF5KEc+Pj4wLEcrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oTS5zdWJhcnJheShWPj4+MCxWKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhS1tZPj4+MF0sb3V0cHV0UGFkZGluZzowPFo/QXJyYXkuZnJvbShNLnN1YmFycmF5KEo+Pj4wLEorWj4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGNlP0FycmF5LmZyb20oTS5zdWJhcnJheShtZT4+PjAsbWUrY2U+Pj4wKSk6W10sYWN0aXZhdGlvbjpSZShFKX0pfSw5MTg3MzY6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSx0ZSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGQse2Zvcm1hdDpZP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6ZixkaWxhdGlvbnM6W3ddLGdyb3VwOkMsa2VybmVsX3NoYXBlOltfXSxwYWRzOltHLFZdLHN0cmlkZXM6W3VlXSx3SXNDb25zdDooKT0+ISFLW1o+Pj4wXSxvdXRwdXRQYWRkaW5nOko/QXJyYXkuZnJvbShNLnN1YmFycmF5KGNlPj4+MCxjZStKPj4+MCkpOltdLG91dHB1dFNoYXBlOm1lP0FycmF5LmZyb20oTS5zdWJhcnJheShFPj4+MCxFK21lPj4+MCkpOltdLGFjdGl2YXRpb246UmUodGUpfSl9LDkxOTE1MDooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsZCx7Zm9ybWF0OnVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6ZixkaWxhdGlvbnM6QXJyYXkuZnJvbShNLnN1YmFycmF5KHc+Pj4wLHcrMj4+PjApKSxncm91cDpDLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKE0uc3ViYXJyYXkoRz4+PjAsRys0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShNLnN1YmFycmF5KFY+Pj4wLFYrMj4+PjApKSx3SXNDb25zdDooKT0+ISFLW1k+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8Wj9BcnJheS5mcm9tKE0uc3ViYXJyYXkoSj4+PjAsSitaPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8Y2U/QXJyYXkuZnJvbShNLnN1YmFycmF5KG1lPj4+MCxtZStjZT4+PjApKTpbXSxhY3RpdmF0aW9uOlJlKEUpfSl9LDkxOTcwNzooZCxmKT0+e3IucmEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGQse2Zvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkxOTc5ODooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJBdmVyYWdlUG9vbFwiLGQse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGNlaWxfbW9kZTp3LGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpfLGRpbGF0aW9uczpbRyxWXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1osSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIwMDgyOihkLGYpPT57ci5yYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsZCx7Zm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwMTczOihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIkF2ZXJhZ2VQb29sXCIsZCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsY2VpbF9tb2RlOncsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOl8sZGlsYXRpb25zOltHLFZdLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbWixKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjA0NTc6KGQsZik9PntyLnJhKFwiR2xvYmFsTWF4UG9vbFwiLGQse2Zvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDU0NDooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJNYXhQb29sXCIsZCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsY2VpbF9tb2RlOncsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOl8sZGlsYXRpb25zOltHLFZdLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbWixKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjA4MjQ6KGQsZik9PntyLnJhKFwiR2xvYmFsTWF4UG9vbFwiLGQse2Zvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDkxMTooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJNYXhQb29sXCIsZCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsY2VpbF9tb2RlOncsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOl8sZGlsYXRpb25zOltHLFZdLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbWixKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjExOTE6KGQsZix3LEMsXyk9PntyLnJhKFwiR2VtbVwiLGQse2FscGhhOmYsYmV0YTp3LHRyYW5zQTpDLHRyYW5zQjpffSl9LDkyMTI5NTpkPT57ci5yYShcIk1hdE11bFwiLGQsdm9pZCAwKX0sOTIxMzQ5OihkLGYsdyxDKT0+e3IucmEoXCJBcmdNYXhcIixkLHtrZWVwRGltczohIWYsc2VsZWN0TGFzdEluZGV4OiEhdyxheGlzOkN9KX0sOTIxNDU3OihkLGYsdyxDKT0+e3IucmEoXCJBcmdNaW5cIixkLHtrZWVwRGltczohIWYsc2VsZWN0TGFzdEluZGV4OiEhdyxheGlzOkN9KX0sOTIxNTY1OihkLGYpPT57ci5yYShcIlNvZnRtYXhcIixkLHtheGlzOmZ9KX0sOTIxNjI4OihkLGYpPT57ci5yYShcIkNvbmNhdFwiLGQse2F4aXM6Zn0pfSw5MjE2ODg6KGQsZix3LEMsXyk9PntyLnJhKFwiU3BsaXRcIixkLHtheGlzOmYsbnVtT3V0cHV0czp3LHNwbGl0U2l6ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkyMTgzMzpkPT57ci5yYShcIkV4cGFuZFwiLGQsdm9pZCAwKX0sOTIxODg3OihkLGYpPT57ci5yYShcIkdhdGhlclwiLGQse2F4aXM6TnVtYmVyKGYpfSl9LDkyMTk1ODooZCxmKT0+e3IucmEoXCJHYXRoZXJFbGVtZW50c1wiLGQse2F4aXM6TnVtYmVyKGYpfSl9LDkyMjAzNzooZCxmLHcsQyxfLEcsVix1ZSxZLFosSik9PntyLnJhKFwiUmVzaXplXCIsZCx7YW50aWFsaWFzOmYsYXhlczp3P0FycmF5LmZyb20oTS5zdWJhcnJheShDPj4+MCxDK3c+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6UmUoXyksY3ViaWNDb2VmZkE6RyxleGNsdWRlT3V0c2lkZTpWLGV4dHJhcG9sYXRpb25WYWx1ZTp1ZSxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6UmUoWSksbW9kZTpSZShaKSxuZWFyZXN0TW9kZTpSZShKKX0pfSw5MjIzODg6KGQsZix3LEMsXyxHLFYpPT57ci5yYShcIlNsaWNlXCIsZCx7c3RhcnRzOmY/QXJyYXkuZnJvbShNLnN1YmFycmF5KHc+Pj4wLHcrZj4+PjApKTpbXSxlbmRzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXSxheGVzOkc/QXJyYXkuZnJvbShNLnN1YmFycmF5KFY+Pj4wLFYrRz4+PjApKTpbXX0pfSw5MjI2MTk6ZD0+e3IucmEoXCJUaWxlXCIsZCx2b2lkIDApfSw5MjI2NzE6KGQsZix3KT0+e3IucmEoXCJMYXllck5vcm1hbGl6YXRpb25cIixkLHtheGlzOk51bWJlcihmKSxlcHNpbG9uOk51bWJlcih3KX0pfSw5MjI3Nzg6KGQsZix3KT0+e3IucmEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixkLHtlcHNpbG9uOmYsZm9ybWF0Onc/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyODkyOihkLGYsdyk9PntyLnJhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsZCx7ZXBzaWxvbjpmLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMzAwNjpkPT57ci5yYShcIlJhbmdlXCIsZCx2b2lkIDApfSw5MjMwNTk6KGQsZik9PntyLnJhKFwiRWluc3VtXCIsZCx7ZXF1YXRpb246UmUoZil9KX0sOTIzMTQwOihkLGYsdyxDLF8pPT57ci5yYShcIlBhZFwiLGQse21vZGU6Zix2YWx1ZTp3LHBhZHM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkyMzI3MjpkPT57ci5yYShcIkdlbHVcIixkLHZvaWQgMCl9LDkyMzMyNDpkPT57ci5yYShcIkJpYXNBZGRcIixkLHZvaWQgMCl9LDkyMzM3OTpkPT57ci5yYShcIkJpYXNTcGxpdEdlbHVcIixkLHZvaWQgMCl9LDkyMzQ0MDooZCxmKT0+e3IucmEoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsZCx7ZXBzaWxvbjpmfSl9LDkyMzUyMTooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSk9PntyLnJhKFwiQ29udlwiLGQse2Zvcm1hdDpZP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsZGlsYXRpb25zOlt3XSxncm91cDpDLGtlcm5lbF9zaGFwZTpbX10scGFkczpHP0FycmF5LmZyb20oTS5zdWJhcnJheShWPj4+MCxWK0c+Pj4wKSk6W10sc3RyaWRlczpbdWVdLHdfaXNfY29uc3Q6KCk9PiEhS1taPj4+MF0sYWN0aXZhdGlvbjpSZShKKSxhY3RpdmF0aW9uX3BhcmFtczpjZT9BcnJheS5mcm9tKHhlLnN1YmFycmF5KG1lPj4+MCxtZStjZT4+PjApKTpbXX0pfSw5MjM5MDI6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiQ29udlwiLGQse2Zvcm1hdDpjZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGRpbGF0aW9uczpbdyxDXSxncm91cDpfLGtlcm5lbF9zaGFwZTpbRyxWXSxwYWRzOnVlP0FycmF5LmZyb20oTS5zdWJhcnJheShZPj4+MCxZK3VlPj4+MCkpOltdLHN0cmlkZXM6W1osSl0sd19pc19jb25zdDooKT0+ISFLW21lPj4+MF0sYWN0aXZhdGlvbjpSZShFKSxhY3RpdmF0aW9uX3BhcmFtczp0ZT9BcnJheS5mcm9tKHhlLnN1YmFycmF5KGZlPj4+MCxmZSt0ZT4+PjApKTpbXX0pfSw5MjQzMDQ6ZD0+e3IuUmEoZCl9LDkyNDMzODooZCxmKT0+ci5TYShkLGYsci5EYS5UYSxyLkRhLmVycm9ycyksOTI0NDUwOmQ9PnIuT2EoZCksOTI0NDgzOmQ9PnIuUWEoZCksOTI0NTE1OihkLGYsdyk9PntyLkphKGQsZix3LCEwKX0sOTI0NTU0OihkLGYsdyk9PntyLkphKGQsZix3KX19O2Z1bmN0aW9uIEtlKGQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtkfSlgLHRoaXMuc3RhdHVzPWR9dmFyIEF0PWQ9Pntmb3IoOzA8ZC5sZW5ndGg7KWQuc2hpZnQoKShyKX07ZnVuY3Rpb24gRXQoZCl7dGhpcy5IYT1kLTI0LHRoaXMuTWE9ZnVuY3Rpb24oZil7cVt0aGlzLkhhKzQ+PjI+Pj4wXT1mfSx0aGlzLkxhPWZ1bmN0aW9uKGYpe3FbdGhpcy5IYSs4Pj4yPj4+MF09Zn0sdGhpcy5ZYT1mdW5jdGlvbihmLHcpe3RoaXMuS2EoKSx0aGlzLk1hKGYpLHRoaXMuTGEodyl9LHRoaXMuS2E9ZnVuY3Rpb24oKXtxW3RoaXMuSGErMTY+PjI+Pj4wXT0wfX12YXIganQ9MCwkcj0wLEplPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxxdD0oZCxmLHcpPT57Zj4+Pj0wO3ZhciBDPWYrdztmb3Iodz1mO2Rbd10mJiEodz49Qyk7KSsrdztpZigxNjx3LWYmJmQuYnVmZmVyJiZKZSlyZXR1cm4gSmUuZGVjb2RlKGQuc3ViYXJyYXkoZix3KSk7Zm9yKEM9XCJcIjtmPHc7KXt2YXIgXz1kW2YrK107aWYoXyYxMjgpe3ZhciBHPWRbZisrXSY2MztpZigoXyYyMjQpPT0xOTIpQys9U3RyaW5nLmZyb21DaGFyQ29kZSgoXyYzMSk8PDZ8Ryk7ZWxzZXt2YXIgVj1kW2YrK10mNjM7Xz0oXyYyNDApPT0yMjQ/KF8mMTUpPDwxMnxHPDw2fFY6KF8mNyk8PDE4fEc8PDEyfFY8PDZ8ZFtmKytdJjYzLDY1NTM2Pl8/Qys9U3RyaW5nLmZyb21DaGFyQ29kZShfKTooXy09NjU1MzYsQys9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxfPj4xMCw1NjMyMHxfJjEwMjMpKX19ZWxzZSBDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKF8pfXJldHVybiBDfSxSZT0oZCxmKT0+KGQ+Pj49MCk/cXQobGUsZCxmKTpcIlwiLHp0PWQ9Pntmb3IodmFyIGY9MCx3PTA7dzxkLmxlbmd0aDsrK3cpe3ZhciBDPWQuY2hhckNvZGVBdCh3KTsxMjc+PUM/ZisrOjIwNDc+PUM/Zis9Mjo1NTI5Njw9QyYmNTczNDM+PUM/KGYrPTQsKyt3KTpmKz0zfXJldHVybiBmfSxLdD0oZCxmLHcsQyk9PntpZih3Pj4+PTAsISgwPEMpKXJldHVybiAwO3ZhciBfPXc7Qz13K0MtMTtmb3IodmFyIEc9MDtHPGQubGVuZ3RoOysrRyl7dmFyIFY9ZC5jaGFyQ29kZUF0KEcpO2lmKDU1Mjk2PD1WJiY1NzM0Mz49Vil7dmFyIHVlPWQuY2hhckNvZGVBdCgrK0cpO1Y9NjU1MzYrKChWJjEwMjMpPDwxMCl8dWUmMTAyM31pZigxMjc+PVYpe2lmKHc+PUMpYnJlYWs7Zlt3Kys+Pj4wXT1WfWVsc2V7aWYoMjA0Nz49Vil7aWYodysxPj1DKWJyZWFrO2ZbdysrPj4+MF09MTkyfFY+PjZ9ZWxzZXtpZig2NTUzNT49Vil7aWYodysyPj1DKWJyZWFrO2ZbdysrPj4+MF09MjI0fFY+PjEyfWVsc2V7aWYodyszPj1DKWJyZWFrO2ZbdysrPj4+MF09MjQwfFY+PjE4LGZbdysrPj4+MF09MTI4fFY+PjEyJjYzfWZbdysrPj4+MF09MTI4fFY+PjYmNjN9Zlt3Kys+Pj4wXT0xMjh8ViY2M319cmV0dXJuIGZbdz4+PjBdPTAsdy1ffSxsdD1kPT5kJTQ9PT0wJiYoZCUxMDAhPT0wfHxkJTQwMD09PTApLHhyPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLGR0PVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdLFd0PWQ9Pnt2YXIgZj16dChkKSsxLHc9R3QoZik7cmV0dXJuIHcmJkt0KGQsbGUsdyxmKSx3fSx5dD1bXSxOdD0oZCxmKT0+e3l0Lmxlbmd0aD0wO3ZhciB3O2ZvcihmPj49Mjt3PWxlW2QrKz4+PjBdOylmKz13IT0xMDUmZix5dC5wdXNoKHc9PTEwNT9NW2Y+Pj4wXTpvZVtmKys+Pj4xXSksKytmO3JldHVybiB5dH0sVnQ9e30sWXQ9KCk9PntpZighVXQpe3ZhciBkPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOnV8fFwiLi90aGlzLnByb2dyYW1cIn0sZjtmb3IoZiBpbiBWdClWdFtmXT09PXZvaWQgMD9kZWxldGUgZFtmXTpkW2ZdPVZ0W2ZdO3ZhciB3PVtdO2ZvcihmIGluIGQpdy5wdXNoKGAke2Z9PSR7ZFtmXX1gKTtVdD13fXJldHVybiBVdH0sVXQsU3I9W251bGwsW10sW11dLFZlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sWHQ9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBKdChkKXt2YXIgZj1BcnJheSh6dChkKSsxKTtyZXR1cm4gS3QoZCxmLDAsZi5sZW5ndGgpLGZ9ZnVuY3Rpb24gbmUoZCxmLHcsQyl7ZnVuY3Rpb24gXyhFLHRlLGZlKXtmb3IoRT10eXBlb2YgRT09XCJudW1iZXJcIj9FLnRvU3RyaW5nKCk6RXx8XCJcIjtFLmxlbmd0aDx0ZTspRT1mZVswXStFO3JldHVybiBFfWZ1bmN0aW9uIEcoRSx0ZSl7cmV0dXJuIF8oRSx0ZSxcIjBcIil9ZnVuY3Rpb24gVihFLHRlKXtmdW5jdGlvbiBmZSh1cil7cmV0dXJuIDA+dXI/LTE6MDx1cj8xOjB9dmFyIHB0O3JldHVybihwdD1mZShFLmdldEZ1bGxZZWFyKCktdGUuZ2V0RnVsbFllYXIoKSkpPT09MCYmKHB0PWZlKEUuZ2V0TW9udGgoKS10ZS5nZXRNb250aCgpKSk9PT0wJiYocHQ9ZmUoRS5nZXREYXRlKCktdGUuZ2V0RGF0ZSgpKSkscHR9ZnVuY3Rpb24gdWUoRSl7c3dpdGNoKEUuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gRTtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gWShFKXt2YXIgdGU9RS5CYTtmb3IoRT1uZXcgRGF0ZShuZXcgRGF0ZShFLkNhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8dGU7KXt2YXIgZmU9RS5nZXRNb250aCgpLHB0PShsdChFLmdldEZ1bGxZZWFyKCkpP1ZlOlh0KVtmZV07aWYodGU+cHQtRS5nZXREYXRlKCkpdGUtPXB0LUUuZ2V0RGF0ZSgpKzEsRS5zZXREYXRlKDEpLDExPmZlP0Uuc2V0TW9udGgoZmUrMSk6KEUuc2V0TW9udGgoMCksRS5zZXRGdWxsWWVhcihFLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7RS5zZXREYXRlKEUuZ2V0RGF0ZSgpK3RlKTticmVha319cmV0dXJuIGZlPW5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSsxLDAsNCksdGU9dWUobmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsNCkpLGZlPXVlKGZlKSwwPj1WKHRlLEUpPzA+PVYoZmUsRSk/RS5nZXRGdWxsWWVhcigpKzE6RS5nZXRGdWxsWWVhcigpOkUuZ2V0RnVsbFllYXIoKS0xfWQ+Pj49MCxmPj4+PTAsdz4+Pj0wLEM+Pj49MDt2YXIgWj1NW0MrNDA+PjI+Pj4wXTtDPXtXYTpNW0M+PjI+Pj4wXSxWYTpNW0MrND4+Mj4+PjBdLEVhOk1bQys4Pj4yPj4+MF0sSWE6TVtDKzEyPj4yPj4+MF0sRmE6TVtDKzE2Pj4yPj4+MF0sQ2E6TVtDKzIwPj4yPj4+MF0sd2E6TVtDKzI0Pj4yPj4+MF0sQmE6TVtDKzI4Pj4yPj4+MF0sJGE6TVtDKzMyPj4yPj4+MF0sVWE6TVtDKzM2Pj4yPj4+MF0sWGE6Wj9SZShaKTpcIlwifSx3PVJlKHcpLFo9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIEogaW4gWil3PXcucmVwbGFjZShuZXcgUmVnRXhwKEosXCJnXCIpLFpbSl0pO3ZhciBjZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLG1lPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtaPXtcIiVhXCI6RT0+Y2VbRS53YV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOkU9PmNlW0Uud2FdLFwiJWJcIjpFPT5tZVtFLkZhXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6RT0+bWVbRS5GYV0sXCIlQ1wiOkU9PkcoKEUuQ2ErMTkwMCkvMTAwfDAsMiksXCIlZFwiOkU9PkcoRS5JYSwyKSxcIiVlXCI6RT0+XyhFLklhLDIsXCIgXCIpLFwiJWdcIjpFPT5ZKEUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpFPT5ZKEUpLFwiJUhcIjpFPT5HKEUuRWEsMiksXCIlSVwiOkU9PihFPUUuRWEsRT09MD9FPTEyOjEyPEUmJihFLT0xMiksRyhFLDIpKSxcIiVqXCI6RT0+e2Zvcih2YXIgdGU9MCxmZT0wO2ZlPD1FLkZhLTE7dGUrPShsdChFLkNhKzE5MDApP1ZlOlh0KVtmZSsrXSk7cmV0dXJuIEcoRS5JYSt0ZSwzKX0sXCIlbVwiOkU9PkcoRS5GYSsxLDIpLFwiJU1cIjpFPT5HKEUuVmEsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjpFPT4wPD1FLkVhJiYxMj5FLkVhP1wiQU1cIjpcIlBNXCIsXCIlU1wiOkU9PkcoRS5XYSwyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6RT0+RS53YXx8NyxcIiVVXCI6RT0+RyhNYXRoLmZsb29yKChFLkJhKzctRS53YSkvNyksMiksXCIlVlwiOkU9Pnt2YXIgdGU9TWF0aC5mbG9vcigoRS5CYSs3LShFLndhKzYpJTcpLzcpO2lmKDI+PShFLndhKzM3MS1FLkJhLTIpJTcmJnRlKyssdGUpdGU9PTUzJiYoZmU9KEUud2ErMzcxLUUuQmEpJTcsZmU9PTR8fGZlPT0zJiZsdChFLkNhKXx8KHRlPTEpKTtlbHNle3RlPTUyO3ZhciBmZT0oRS53YSs3LUUuQmEtMSklNzsoZmU9PTR8fGZlPT01JiZsdChFLkNhJTQwMC0xKSkmJnRlKyt9cmV0dXJuIEcodGUsMil9LFwiJXdcIjpFPT5FLndhLFwiJVdcIjpFPT5HKE1hdGguZmxvb3IoKEUuQmErNy0oRS53YSs2KSU3KS83KSwyKSxcIiV5XCI6RT0+KEUuQ2ErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOkU9PkUuQ2ErMTkwMCxcIiV6XCI6RT0+e0U9RS5VYTt2YXIgdGU9MDw9RTtyZXR1cm4gRT1NYXRoLmFicyhFKS82MCwodGU/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoRS82MCoxMDArRSU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOkU9PkUuWGEsXCIlJVwiOigpPT5cIiVcIn0sdz13LnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIik7Zm9yKEogaW4gWil3LmluY2x1ZGVzKEopJiYodz13LnJlcGxhY2UobmV3IFJlZ0V4cChKLFwiZ1wiKSxaW0pdKEMpKSk7cmV0dXJuIHc9dy5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIiksSj1KdCh3KSxKLmxlbmd0aD5mPzA6KEsuc2V0KEosZD4+PjApLEoubGVuZ3RoLTEpfWZ1bmN0aW9uIGN0KGQpe3RyeXtkKCl9Y2F0Y2goZil7cWUoZil9fWZ1bmN0aW9uIENyKGQpe3ZhciBmPXt9LHc7Zm9yKHcgaW4gZCkoZnVuY3Rpb24oQyl7dmFyIF89ZFtDXTtmW0NdPXR5cGVvZiBfPT1cImZ1bmN0aW9uXCI/ZnVuY3Rpb24oKXtfdC5wdXNoKEMpO3RyeXtyZXR1cm4gXy5hcHBseShudWxsLGFyZ3VtZW50cyl9ZmluYWxseXtXfHwoX3QucG9wKCk9PT1DfHxxZSgpLFllJiZ0dD09PTEmJl90Lmxlbmd0aD09PTAmJih0dD0wLGN0KGlyKSx0eXBlb2YgRmliZXJzPFwidVwiJiZGaWJlcnMuYWIoKSkpfX06X30pKHcpO3JldHVybiBmfXZhciB0dD0wLFllPW51bGwsSXI9MCxfdD1bXSxRdD17fSxadD17fSxBcj0wLE90PW51bGwsRXI9W107ZnVuY3Rpb24gX3IoKXtyZXR1cm4gbmV3IFByb21pc2UoKGQsZik9PntPdD17cmVzb2x2ZTpkLHJlamVjdDpmfX0pfWZ1bmN0aW9uIE9yKCl7dmFyIGQ9R3QoNjU1NDgpLGY9ZCsxMjtxW2Q+PjI+Pj4wXT1mLHFbZCs0Pj4yPj4+MF09Zis2NTUzNixmPV90WzBdO3ZhciB3PVF0W2ZdO3JldHVybiB3PT09dm9pZCAwJiYodz1BcisrLFF0W2ZdPXcsWnRbd109ZiksTVtkKzg+PjI+Pj4wXT13LGR9ZnVuY3Rpb24gVHIoZCl7aWYoIVcpe2lmKHR0PT09MCl7dmFyIGY9ITEsdz0hMTtkKChDPTApPT57aWYoIVcmJihJcj1DLGY9ITAsdykpe3R0PTIsY3QoKCk9PkZ0KFllKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuR2EuTmEmJkJyb3dzZXIuR2EucmVzdW1lKCksQz0hMTt0cnl7dmFyIF89KDAsUltadFtNW1llKzg+PjI+Pj4wXV1dKSgpfWNhdGNoKHVlKXtfPXVlLEM9ITB9dmFyIEc9ITE7aWYoIVllKXt2YXIgVj1PdDtWJiYoT3Q9bnVsbCwoQz9WLnJlamVjdDpWLnJlc29sdmUpKF8pLEc9ITApfWlmKEMmJiFHKXRocm93IF99fSksdz0hMCxmfHwodHQ9MSxZZT1PcigpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkdhLk5hJiZCcm93c2VyLkdhLnBhdXNlKCksY3QoKCk9Pm9yKFllKSkpfWVsc2UgdHQ9PT0yPyh0dD0wLGN0KFR0KSxlcihZZSksWWU9bnVsbCxFci5mb3JFYWNoKEM9PntpZighVyl0cnl7aWYoQygpLCFQKXRyeXtIPUg9Qz1ILFB8fChyLm9uRXhpdCYmci5vbkV4aXQoQyksVz0hMCksbChDLG5ldyBLZShDKSl9Y2F0Y2goXyl7XyBpbnN0YW5jZW9mIEtlfHxfPT1cInVud2luZFwifHxsKDEsXyl9fWNhdGNoKF8pe18gaW5zdGFuY2VvZiBLZXx8Xz09XCJ1bndpbmRcInx8bCgxLF8pfX0pKTpxZShgaW52YWxpZCBzdGF0ZTogJHt0dH1gKTtyZXR1cm4gSXJ9fWZ1bmN0aW9uIFJyKGQpe3JldHVybiBUcihmPT57ZCgpLnRoZW4oZil9KX12YXIgUHI9e246ZnVuY3Rpb24oZCxmLHcpe3JldHVybiBScihhc3luYygpPT57YXdhaXQgci5QYShkLGYsdyl9KX0sYTpmdW5jdGlvbihkLGYsdyl7dGhyb3cgZD4+Pj0wLG5ldyBFdChkKS5ZYShmPj4+MCx3Pj4+MCksanQ9ZCwkcisrLGp0fSxnOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEo6ZnVuY3Rpb24oKXt9LHo6ZnVuY3Rpb24oKXt9LEI6ZnVuY3Rpb24oKXt9LEw6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sSDpmdW5jdGlvbigpe30sQzpmdW5jdGlvbigpe30sRzpmdW5jdGlvbigpe30sbDpmdW5jdGlvbigpe30sQTpmdW5jdGlvbigpe30seDpmdW5jdGlvbigpe30sSTpmdW5jdGlvbigpe30seTpmdW5jdGlvbigpe30sbTooKT0+ITAscTpmdW5jdGlvbihkLGYsdyl7ZD1mKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFkPyhkPj4+MCkrNDI5NDk2NzI5NipmOk5hTix3Pj4+PTAsZD1uZXcgRGF0ZSgxZTMqZCksTVt3Pj4yPj4+MF09ZC5nZXRVVENTZWNvbmRzKCksTVt3KzQ+PjI+Pj4wXT1kLmdldFVUQ01pbnV0ZXMoKSxNW3crOD4+Mj4+PjBdPWQuZ2V0VVRDSG91cnMoKSxNW3crMTI+PjI+Pj4wXT1kLmdldFVUQ0RhdGUoKSxNW3crMTY+PjI+Pj4wXT1kLmdldFVUQ01vbnRoKCksTVt3KzIwPj4yPj4+MF09ZC5nZXRVVENGdWxsWWVhcigpLTE5MDAsTVt3KzI0Pj4yPj4+MF09ZC5nZXRVVENEYXkoKSxNW3crMjg+PjI+Pj4wXT0oZC5nZXRUaW1lKCktRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MH0scjpmdW5jdGlvbihkLGYsdyl7ZD1mKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFkPyhkPj4+MCkrNDI5NDk2NzI5NipmOk5hTix3Pj4+PTAsZD1uZXcgRGF0ZSgxZTMqZCksTVt3Pj4yPj4+MF09ZC5nZXRTZWNvbmRzKCksTVt3KzQ+PjI+Pj4wXT1kLmdldE1pbnV0ZXMoKSxNW3crOD4+Mj4+PjBdPWQuZ2V0SG91cnMoKSxNW3crMTI+PjI+Pj4wXT1kLmdldERhdGUoKSxNW3crMTY+PjI+Pj4wXT1kLmdldE1vbnRoKCksTVt3KzIwPj4yPj4+MF09ZC5nZXRGdWxsWWVhcigpLTE5MDAsTVt3KzI0Pj4yPj4+MF09ZC5nZXREYXkoKSxNW3crMjg+PjI+Pj4wXT0obHQoZC5nZXRGdWxsWWVhcigpKT94cjpkdClbZC5nZXRNb250aCgpXStkLmdldERhdGUoKS0xfDAsTVt3KzM2Pj4yPj4+MF09LSg2MCpkLmdldFRpbWV6b25lT2Zmc2V0KCkpLGY9bmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgQz1uZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO01bdyszMj4+Mj4+PjBdPShmIT1DJiZkLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKEMsZikpfDB9LHM6ZnVuY3Rpb24oZCl7ZD4+Pj0wO3ZhciBmPW5ldyBEYXRlKE1bZCsyMD4+Mj4+PjBdKzE5MDAsTVtkKzE2Pj4yPj4+MF0sTVtkKzEyPj4yPj4+MF0sTVtkKzg+PjI+Pj4wXSxNW2QrND4+Mj4+PjBdLE1bZD4+Mj4+PjBdLDApLHc9TVtkKzMyPj4yPj4+MF0sQz1mLmdldFRpbWV6b25lT2Zmc2V0KCksXz1uZXcgRGF0ZShmLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEc9bmV3IERhdGUoZi5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxWPU1hdGgubWluKEcsXyk7cmV0dXJuIDA+dz9NW2QrMzI+PjI+Pj4wXT0rKF8hPUcmJlY9PUMpOjA8dyE9KFY9PUMpJiYoXz1NYXRoLm1heChHLF8pLGYuc2V0VGltZShmLmdldFRpbWUoKSs2ZTQqKCgwPHc/VjpfKS1DKSkpLE1bZCsyND4+Mj4+PjBdPWYuZ2V0RGF5KCksTVtkKzI4Pj4yPj4+MF09KGx0KGYuZ2V0RnVsbFllYXIoKSk/eHI6ZHQpW2YuZ2V0TW9udGgoKV0rZi5nZXREYXRlKCktMXwwLE1bZD4+Mj4+PjBdPWYuZ2V0U2Vjb25kcygpLE1bZCs0Pj4yPj4+MF09Zi5nZXRNaW51dGVzKCksTVtkKzg+PjI+Pj4wXT1mLmdldEhvdXJzKCksTVtkKzEyPj4yPj4+MF09Zi5nZXREYXRlKCksTVtkKzE2Pj4yPj4+MF09Zi5nZXRNb250aCgpLE1bZCsyMD4+Mj4+PjBdPWYuZ2V0WWVhcigpLGQ9Zi5nZXRUaW1lKCkvMWUzLHRyKChHZT1kLDE8PStNYXRoLmFicyhHZSk/MDxHZT8rTWF0aC5mbG9vcihHZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChHZS0rKH5+R2U+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxkPj4+MH0sbzpmdW5jdGlvbigpe3JldHVybi01Mn0scDpmdW5jdGlvbigpe30sdjpmdW5jdGlvbihkLGYsdyl7ZnVuY3Rpb24gQyhZKXtyZXR1cm4oWT1ZLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP1lbMV06XCJHTVRcIn13Pj4+PTA7dmFyIF89bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLEc9bmV3IERhdGUoXywwLDEpLFY9bmV3IERhdGUoXyw2LDEpO189Ry5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB1ZT1WLmdldFRpbWV6b25lT2Zmc2V0KCk7cVtkPj4+MD4+Mj4+PjBdPTYwKk1hdGgubWF4KF8sdWUpLE1bZj4+PjA+PjI+Pj4wXT0rKF8hPXVlKSxkPUMoRyksZj1DKFYpLGQ9V3QoZCksZj1XdChmKSx1ZTxfPyhxW3c+PjI+Pj4wXT1kLHFbdys0Pj4yPj4+MF09Zik6KHFbdz4+Mj4+PjBdPWYscVt3KzQ+PjI+Pj4wXT1kKX0sZTooKT0+e3FlKFwiXCIpfSxiOmZ1bmN0aW9uKGQsZix3KXtyZXR1cm4gZD4+Pj0wLGY9TnQoZj4+PjAsdz4+PjApLGV0W2RdLmFwcGx5KG51bGwsZil9LGk6ZnVuY3Rpb24oZCxmLHcpe3JldHVybiBkPj4+PTAsZj1OdChmPj4+MCx3Pj4+MCksZXRbZF0uYXBwbHkobnVsbCxmKX0saDpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx3OmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGM6KCk9PnBlcmZvcm1hbmNlLm5vdygpLEs6ZnVuY3Rpb24oZCxmLHcpe3JldHVybiBmPj4+PTAsbGUuY29weVdpdGhpbihkPj4+MD4+PjAsZj4+PjAsZisodz4+PjApPj4+MCl9LHU6ZnVuY3Rpb24oZCl7ZD4+Pj0wO3ZhciBmPWxlLmxlbmd0aDtpZig0Mjk0OTAxNzYwPGQpcmV0dXJuITE7Zm9yKHZhciB3PTE7ND49dzt3Kj0yKXt2YXIgQz1mKigxKy4yL3cpO0M9TWF0aC5taW4oQyxkKzEwMDY2MzI5Nik7dmFyIF89TWF0aDtDPU1hdGgubWF4KGQsQyk7ZTp7Xz1fLm1pbi5jYWxsKF8sNDI5NDkwMTc2MCxDKyg2NTUzNi1DJTY1NTM2KSU2NTUzNiktRC5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2O3RyeXtELmdyb3coXyksd2UoKTt2YXIgRz0xO2JyZWFrIGV9Y2F0Y2h7fUc9dm9pZCAwfWlmKEcpcmV0dXJuITB9cmV0dXJuITF9LEQ6ZnVuY3Rpb24oZCxmKXtkPj4+PTAsZj4+Pj0wO3ZhciB3PTA7cmV0dXJuIFl0KCkuZm9yRWFjaChmdW5jdGlvbihDLF8pe3ZhciBHPWYrdztmb3IoXz1xW2QrNCpfPj4yPj4+MF09RyxHPTA7RzxDLmxlbmd0aDsrK0cpS1tfKys+PjA+Pj4wXT1DLmNoYXJDb2RlQXQoRyk7S1tfPj4wPj4+MF09MCx3Kz1DLmxlbmd0aCsxfSksMH0sRTpmdW5jdGlvbihkLGYpe2Q+Pj49MCxmPj4+PTA7dmFyIHc9WXQoKTtxW2Q+PjI+Pj4wXT13Lmxlbmd0aDt2YXIgQz0wO3JldHVybiB3LmZvckVhY2goZnVuY3Rpb24oXyl7Qys9Xy5sZW5ndGgrMX0pLHFbZj4+Mj4+PjBdPUMsMH0sZjooKT0+NTIsazpmdW5jdGlvbigpe3JldHVybiA1Mn0sdDpmdW5jdGlvbigpe3JldHVybiA3MH0sajpmdW5jdGlvbihkLGYsdyxDKXtmPj4+PTAsdz4+Pj0wLEM+Pj49MDtmb3IodmFyIF89MCxHPTA7Rzx3O0crKyl7dmFyIFY9cVtmPj4yPj4+MF0sdWU9cVtmKzQ+PjI+Pj4wXTtmKz04O2Zvcih2YXIgWT0wO1k8dWU7WSsrKXt2YXIgWj1sZVtWK1k+Pj4wXSxKPVNyW2RdO1o9PT0wfHxaPT09MTA/KChkPT09MT9JOlQpKHF0KEosMCkpLEoubGVuZ3RoPTApOkoucHVzaChaKX1fKz11ZX1yZXR1cm4gcVtDPj4yPj4+MF09XywwfSxGOm5lLGQ6ZnVuY3Rpb24oZCxmLHcsQyl7cmV0dXJuIG5lKGQ+Pj4wLGY+Pj4wLHc+Pj4wLEM+Pj4wKX19OyhmdW5jdGlvbigpe2Z1bmN0aW9uIGQodyl7aWYodz13LmV4cG9ydHMsdz1Dcih3KSxSPXc9YnQodyksRD1SLk0sd2UoKSxTZS51bnNoaWZ0KFIuTiksQ2UtLSxyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhDZSksQ2U9PTAmJihndCE9PW51bGwmJihjbGVhckludGVydmFsKGd0KSxndD1udWxsKSxMZSkpe3ZhciBDPUxlO0xlPW51bGwsQygpfXJldHVybiB3fXZhciBmPXthOlByfTtpZihDZSsrLHIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKENlKSxyLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHIuaW5zdGFudGlhdGVXYXNtKGYsZCl9Y2F0Y2godyl7VChcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK3cpLG4odyl9cmV0dXJuIHplKGYsZnVuY3Rpb24odyl7ZCh3Lmluc3RhbmNlKX0pLmNhdGNoKG4pLHt9fSkoKSxyLl9PcnRJbml0PShkLGYpPT4oci5fT3J0SW5pdD1SLk8pKGQsZiksci5fT3J0R2V0TGFzdEVycm9yPShkLGYpPT4oci5fT3J0R2V0TGFzdEVycm9yPVIuUCkoZCxmKSxyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oZCxmLHcsQyxfLEcsVix1ZSxZLFopPT4oci5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9Ui5RKShkLGYsdyxDLF8sRyxWLHVlLFksWiksci5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGQsZik9PihyLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1SLlIpKGQsZiksci5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShkLGYsdyk9PihyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9Ui5TKShkLGYsdyksci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShkLGYsdyk9PihyLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9Ui5UKShkLGYsdyksci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWQ9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9Ui5VKShkKSxyLl9PcnRDcmVhdGVTZXNzaW9uPShkLGYsdyk9PihyLl9PcnRDcmVhdGVTZXNzaW9uPVIuVikoZCxmLHcpLHIuX09ydFJlbGVhc2VTZXNzaW9uPWQ9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbj1SLlcpKGQpLHIuX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGQsZix3KT0+KHIuX09ydEdldElucHV0T3V0cHV0Q291bnQ9Ui5YKShkLGYsdyksci5fT3J0R2V0SW5wdXROYW1lPShkLGYpPT4oci5fT3J0R2V0SW5wdXROYW1lPVIuWSkoZCxmKSxyLl9PcnRHZXRPdXRwdXROYW1lPShkLGYpPT4oci5fT3J0R2V0T3V0cHV0TmFtZT1SLlopKGQsZiksci5fT3J0RnJlZT1kPT4oci5fT3J0RnJlZT1SLl8pKGQpLHIuX09ydENyZWF0ZVRlbnNvcj0oZCxmLHcsQyxfLEcpPT4oci5fT3J0Q3JlYXRlVGVuc29yPVIuJCkoZCxmLHcsQyxfLEcpLHIuX09ydEdldFRlbnNvckRhdGE9KGQsZix3LEMsXyk9PihyLl9PcnRHZXRUZW5zb3JEYXRhPVIuYWEpKGQsZix3LEMsXyksci5fT3J0UmVsZWFzZVRlbnNvcj1kPT4oci5fT3J0UmVsZWFzZVRlbnNvcj1SLmJhKShkKSxyLl9PcnRDcmVhdGVSdW5PcHRpb25zPShkLGYsdyxDKT0+KHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9Ui5jYSkoZCxmLHcsQyksci5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGQsZix3KT0+KHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PVIuZGEpKGQsZix3KSxyLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1kPT4oci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9Ui5lYSkoZCksci5fT3J0Q3JlYXRlQmluZGluZz1kPT4oci5fT3J0Q3JlYXRlQmluZGluZz1SLmZhKShkKSxyLl9PcnRCaW5kSW5wdXQ9KGQsZix3KT0+KHIuX09ydEJpbmRJbnB1dD1SLmdhKShkLGYsdyksci5fT3J0QmluZE91dHB1dD0oZCxmLHcsQyk9PihyLl9PcnRCaW5kT3V0cHV0PVIuaGEpKGQsZix3LEMpLHIuX09ydENsZWFyQm91bmRPdXRwdXRzPWQ9PihyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1SLmlhKShkKSxyLl9PcnRSZWxlYXNlQmluZGluZz1kPT4oci5fT3J0UmVsZWFzZUJpbmRpbmc9Ui5qYSkoZCksci5fT3J0UnVuV2l0aEJpbmRpbmc9KGQsZix3LEMsXyk9PihyLl9PcnRSdW5XaXRoQmluZGluZz1SLmthKShkLGYsdyxDLF8pLHIuX09ydFJ1bj0oZCxmLHcsQyxfLEcsVix1ZSk9PihyLl9PcnRSdW49Ui5sYSkoZCxmLHcsQyxfLEcsVix1ZSksci5fT3J0RW5kUHJvZmlsaW5nPWQ9PihyLl9PcnRFbmRQcm9maWxpbmc9Ui5tYSkoZCksci5fSnNlcE91dHB1dD0oZCxmLHcpPT4oci5fSnNlcE91dHB1dD1SLm5hKShkLGYsdyksci5fSnNlcEdldE5vZGVOYW1lPWQ9PihyLl9Kc2VwR2V0Tm9kZU5hbWU9Ui5vYSkoZCk7dmFyIEd0PXIuX21hbGxvYz1kPT4oR3Q9ci5fbWFsbG9jPVIucGEpKGQpLGVyPXIuX2ZyZWU9ZD0+KGVyPXIuX2ZyZWU9Ui5xYSkoZCksdHI9ZD0+KHRyPVIuc2EpKGQpLHJyPSgpPT4ocnI9Ui50YSkoKSxucj1kPT4obnI9Ui51YSkoZCksYXI9ZD0+KGFyPVIudmEpKGQpLG9yPWQ9Pihvcj1SLnhhKShkKSxpcj0oKT0+KGlyPVIueWEpKCksRnQ9ZD0+KEZ0PVIuemEpKGQpLFR0PSgpPT4oVHQ9Ui5BYSkoKTtyLl9fX3N0YXJ0X2VtX2pzPTkyNDU4NyxyLl9fX3N0b3BfZW1fanM9OTI0NzQ4O2Z1bmN0aW9uIGJ0KGQpe2Q9T2JqZWN0LmFzc2lnbih7fSxkKTt2YXIgZj1DPT4oKT0+QygpPj4+MCx3PUM9Pl89PkMoXyk+Pj4wO3JldHVybiBkLl9fZXJybm9fbG9jYXRpb249ZihkLl9fZXJybm9fbG9jYXRpb24pLGQubWFsbG9jPXcoZC5tYWxsb2MpLGQuc3RhY2tTYXZlPWYoZC5zdGFja1NhdmUpLGQuc3RhY2tBbGxvYz13KGQuc3RhY2tBbGxvYyksZH1yLnN0YWNrQWxsb2M9YXIsci5zdGFja1NhdmU9cnIsci5zdGFja1Jlc3RvcmU9bnIsci5VVEY4VG9TdHJpbmc9UmUsci5zdHJpbmdUb1VURjg9KGQsZix3KT0+S3QoZCxsZSxmLHcpLHIubGVuZ3RoQnl0ZXNVVEY4PXp0O3ZhciBSdDtMZT1mdW5jdGlvbiBkKCl7UnR8fHNyKCksUnR8fChMZT1kKX07ZnVuY3Rpb24gc3IoKXtmdW5jdGlvbiBkKCl7aWYoIVJ0JiYoUnQ9ITAsci5jYWxsZWRSdW49ITAsIVcpKXtpZihBdChTZSksYShyKSxyLm9uUnVudGltZUluaXRpYWxpemVkJiZyLm9uUnVudGltZUluaXRpYWxpemVkKCksci5wb3N0UnVuKWZvcih0eXBlb2Ygci5wb3N0UnVuPT1cImZ1bmN0aW9uXCImJihyLnBvc3RSdW49W3IucG9zdFJ1bl0pO3IucG9zdFJ1bi5sZW5ndGg7KXt2YXIgZj1yLnBvc3RSdW4uc2hpZnQoKTtUZS51bnNoaWZ0KGYpfUF0KFRlKX19aWYoISgwPENlKSl7aWYoci5wcmVSdW4pZm9yKHR5cGVvZiByLnByZVJ1bj09XCJmdW5jdGlvblwiJiYoci5wcmVSdW49W3IucHJlUnVuXSk7ci5wcmVSdW4ubGVuZ3RoOylFZSgpO0F0KGopLDA8Q2V8fChyLnNldFN0YXR1cz8oci5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ci5zZXRTdGF0dXMoXCJcIil9LDEpLGQoKX0sMSkpOmQoKSl9fWlmKHIucHJlSW5pdClmb3IodHlwZW9mIHIucHJlSW5pdD09XCJmdW5jdGlvblwiJiYoci5wcmVJbml0PVtyLnByZUluaXRdKTswPHIucHJlSW5pdC5sZW5ndGg7KXIucHJlSW5pdC5wb3AoKSgpO3JldHVybiBzcigpLHQucmVhZHl9fSkoKTt0eXBlb2Ygdm89PVwib2JqZWN0XCImJnR5cGVvZiBEbj09XCJvYmplY3RcIj9Ebi5leHBvcnRzPXdvOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCYmZGVmaW5lKFtdLCgpPT53byl9KTt2YXIgeG89THQoKCk9Pnt9KTt2YXIgU289THQoKCk9Pnt9KTt2YXIgQ289e307a3QoQ28se2NwdXM6KCk9PlZsfSk7dmFyIFZsLElvPUwoKCk9PntWbD12b2lkIDB9KTt2YXIgX289THQoKEVvLHpuKT0+e1widXNlIHN0cmljdFwiO3ZhciBBbz0oKCk9Pnt2YXIgZT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKGU9ZXx8X19maWxlbmFtZSksZnVuY3Rpb24odD17fSl7ZnVuY3Rpb24gcigpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxDZX1mdW5jdGlvbiBhKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLGd0fWZ1bmN0aW9uIG4oKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksTGV9ZnVuY3Rpb24gcygpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxxZX1mdW5jdGlvbiB1KCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLFV9ZnVuY3Rpb24gbCgpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxkZX12YXIgbz10LHAsbTtvLnJlYWR5PW5ldyBQcm9taXNlKChpLGMpPT57cD1pLG09Y30pLG8uanNlcEluaXQ9KGksYyxoLHgsQSxrLE4sYWUpPT57by5RYj1pLG8ud2I9YyxvLnliPWgsby5qYj14LG8ueGI9QSxvLkVhPWssby56Yj1OLG8uQWI9YWUsYz0oZWUsUSxyZSk9PiguLi5oZSk9PntsZXQgYmU9cnQsTz1RPy4oKTtoZT1lZSguLi5oZSk7bGV0IHNlPVE/LigpO3JldHVybiBPIT09c2UmJihlZT1zZSxyZShPKSxRPXJlPW51bGwpLHJ0IT1iZT9JbCgpOmhlfSxoPWVlPT5hc3luYyguLi5RKT0+e3RyeXtpZihvLmJiKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7bGV0IHJlPW8uYmI9e0ZiOlFbMF0sZXJyb3JzOltdfSxoZT1hd2FpdCBlZSguLi5RKTtpZihvLmJiIT09cmUpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO2kuZmx1c2goKTtsZXQgYmU9cmUuZXJyb3JzO2lmKDA8YmUubGVuZ3RoKXtsZXQgTz1hd2FpdCBQcm9taXNlLmFsbChiZSk7aWYoTz1PLmZpbHRlcihzZT0+c2UpLDA8Ty5sZW5ndGgpdGhyb3cgRXJyb3IoTy5qb2luKGBcbmApKX1yZXR1cm4gaGV9ZmluYWxseXtvLmJiPW51bGx9fSxvLl9PcnRSdW49aChjKG8uX09ydFJ1biwoKT0+by5fT3J0UnVuLGVlPT5vLl9PcnRSdW49ZWUpKSxvLl9PcnRSdW5XaXRoQmluZGluZz1oKGMoby5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9Pm8uX09ydFJ1bldpdGhCaW5kaW5nLGVlPT5vLl9PcnRSdW5XaXRoQmluZGluZz1lZSkpLG8uX09ydEJpbmRJbnB1dD1jKG8uX09ydEJpbmRJbnB1dCwoKT0+by5fT3J0QmluZElucHV0LGVlPT5vLl9PcnRCaW5kSW5wdXQ9ZWUpLG8uanNlcFJlZ2lzdGVyQnVmZmVyPShlZSxRLHJlLGhlKT0+aS5yZWdpc3RlckJ1ZmZlcihlZSxRLHJlLGhlKSxvLmpzZXBVbnJlZ2lzdGVyQnVmZmVycz1lZT0+e2kudW5yZWdpc3RlckJ1ZmZlcnMoZWUpfSxvLmpzZXBHZXRCdWZmZXI9ZWU9PmkuZ2V0QnVmZmVyKGVlKSxvLmpzZXBDcmVhdGVEb3dubG9hZGVyPShlZSxRLHJlKT0+aS5jcmVhdGVEb3dubG9hZGVyKGVlLFEscmUpfTt2YXIgeT1PYmplY3QuYXNzaWduKHt9LG8pLGc9XCIuL3RoaXMucHJvZ3JhbVwiLHY9KGksYyk9Pnt0aHJvdyBjfSwkPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIsYj10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLFM9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLEk9by5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxUPVwiXCI7ZnVuY3Rpb24gQihpKXtyZXR1cm4gby5sb2NhdGVGaWxlP28ubG9jYXRlRmlsZShpLFQpOlQraX12YXIgUCxELFI7aWYoUyl7dmFyIFc9KGtuKCksdnQoUG4pKSxIPShNbigpLHZ0KEJuKSk7VD1iP0guZGlybmFtZShUKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsUD0oYyxoKT0+KGM9Yy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGMpOkgubm9ybWFsaXplKGMpLFcucmVhZEZpbGVTeW5jKGMsaD92b2lkIDA6XCJ1dGY4XCIpKSxSPWM9PihjPVAoYywhMCksYy5idWZmZXJ8fChjPW5ldyBVaW50OEFycmF5KGMpKSxjKSxEPShjLGgseCxBPSEwKT0+e2M9Yy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGMpOkgubm9ybWFsaXplKGMpLFcucmVhZEZpbGUoYyxBP3ZvaWQgMDpcInV0ZjhcIiwoayxOKT0+e2s/eChrKTpoKEE/Ti5idWZmZXI6Til9KX0sIW8udGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKGc9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSx2PShjLGgpPT57dGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1jLGh9LG8uaW5zcGVjdD0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwiO2xldCBpO3RyeXtpPXhvKCl9Y2F0Y2goYyl7dGhyb3cgY29uc29sZS5lcnJvcignVGhlIFwid29ya2VyX3RocmVhZHNcIiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG5vZGUuanMgYnVpbGQgLSBwZXJoYXBzIGEgbmV3ZXIgdmVyc2lvbiBpcyBuZWVkZWQ/JyksY31nbG9iYWwuV29ya2VyPWkuV29ya2VyfWVsc2UoJHx8YikmJihiP1Q9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKFQ9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLHR5cGVvZiBlPFwidVwiJiZlJiYoVD1lKSxULmluZGV4T2YoXCJibG9iOlwiKSE9PTA/VD1ULnN1YnN0cigwLFQucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6VD1cIlwiLFN8fChQPWk9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLGksITEpLGMuc2VuZChudWxsKSxjLnJlc3BvbnNlVGV4dH0sYiYmKFI9aT0+e3ZhciBjPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYy5vcGVuKFwiR0VUXCIsaSwhMSksYy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGMuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShjLnJlc3BvbnNlKX0pLEQ9KGksYyxoKT0+e3ZhciB4PW5ldyBYTUxIdHRwUmVxdWVzdDt4Lm9wZW4oXCJHRVRcIixpLCEwKSx4LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIseC5vbmxvYWQ9KCk9Pnt4LnN0YXR1cz09MjAwfHx4LnN0YXR1cz09MCYmeC5yZXNwb25zZT9jKHgucmVzcG9uc2UpOmgoKX0seC5vbmVycm9yPWgseC5zZW5kKG51bGwpfSkpO1MmJnR5cGVvZiBwZXJmb3JtYW5jZT5cInVcIiYmKGdsb2JhbC5wZXJmb3JtYW5jZT1TbygpLnBlcmZvcm1hbmNlKTt2YXIgSz1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLGxlPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtTJiYoSz0oLi4uaSk9Plcud3JpdGVTeW5jKDEsaS5qb2luKFwiIFwiKStgXG5gKSxsZT0oLi4uaSk9Plcud3JpdGVTeW5jKDIsaS5qb2luKFwiIFwiKStgXG5gKSk7dmFyIE09by5wcmludHx8SyxxPW8ucHJpbnRFcnJ8fGxlO09iamVjdC5hc3NpZ24obyx5KSx5PW51bGwsby50aGlzUHJvZ3JhbSYmKGc9by50aGlzUHJvZ3JhbSksby5xdWl0JiYodj1vLnF1aXQpO3ZhciB4ZTtvLndhc21CaW5hcnkmJih4ZT1vLndhc21CaW5hcnkpO3ZhciBvZT1vLm5vRXhpdFJ1bnRpbWV8fCEwO3R5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIiYmSmUoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciB3ZSxqLFNlLFRlPSExLEVlLENlLGd0LExlLHFlLFUsZGU7ZnVuY3Rpb24gcGUoKXt2YXIgaT13ZS5idWZmZXI7by5IRUFQOD1DZT1uZXcgSW50OEFycmF5KGkpLG8uSEVBUDE2PW5ldyBJbnQxNkFycmF5KGkpLG8uSEVBUDMyPUxlPW5ldyBJbnQzMkFycmF5KGkpLG8uSEVBUFU4PWd0PW5ldyBVaW50OEFycmF5KGkpLG8uSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoaSksby5IRUFQVTMyPXFlPW5ldyBVaW50MzJBcnJheShpKSxvLkhFQVBGMzI9VT1uZXcgRmxvYXQzMkFycmF5KGkpLG8uSEVBUEY2ND1kZT1uZXcgRmxvYXQ2NEFycmF5KGkpfXZhciBOZT1vLklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZig1MjQyODgwPD1OZXx8SmUoXCJJTklUSUFMX01FTU9SWSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gU1RBQ0tfU0laRSwgd2FzIFwiK05lK1wiISAoU1RBQ0tfU0laRT01MjQyODgwKVwiKSxJKXdlPW8ud2FzbU1lbW9yeTtlbHNlIGlmKG8ud2FzbU1lbW9yeSl3ZT1vLndhc21NZW1vcnk7ZWxzZSBpZih3ZT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOk5lLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSksISh3ZS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgcShcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxTJiZxKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQvb3IgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTtwZSgpLE5lPXdlLmJ1ZmZlci5ieXRlTGVuZ3RoO3ZhciBIZT1bXSxPZT1bXSx6ZT1bXSxHZT0wO2Z1bmN0aW9uIGV0KCl7cmV0dXJuIG9lfHwwPEdlfXZhciBLZT0wLEF0PW51bGwsRXQ9bnVsbDtmdW5jdGlvbiBqdCgpe0tlKyssby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZvLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoS2UpfWZ1bmN0aW9uICRyKCl7aWYoS2UtLSxvLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJm8ubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhLZSksS2U9PTAmJihBdCE9PW51bGwmJihjbGVhckludGVydmFsKEF0KSxBdD1udWxsKSxFdCkpe3ZhciBpPUV0O0V0PW51bGwsaSgpfX1mdW5jdGlvbiBKZShpKXt0aHJvdyBvLm9uQWJvcnQmJm8ub25BYm9ydChpKSxpPVwiQWJvcnRlZChcIitpK1wiKVwiLHEoaSksVGU9ITAsRWU9MSxpPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoaStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbShpKSxpfWZ1bmN0aW9uIHF0KGkpe3JldHVybiBpLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfXZhciBSZTtSZT1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiLHF0KFJlKXx8KFJlPUIoUmUpKTtmdW5jdGlvbiB6dChpKXtpZihpPT1SZSYmeGUpcmV0dXJuIG5ldyBVaW50OEFycmF5KHhlKTtpZihSKXJldHVybiBSKGkpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIEt0KGkpe2lmKCF4ZSYmKCR8fGIpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIWkuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKGkse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oYz0+e2lmKCFjLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitpK1wiJ1wiO3JldHVybiBjLmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+enQoaSkpO2lmKEQpcmV0dXJuIG5ldyBQcm9taXNlKChjLGgpPT57RChpLHg9PmMobmV3IFVpbnQ4QXJyYXkoeCkpLGgpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pnp0KGkpKX1mdW5jdGlvbiBsdChpLGMsaCl7cmV0dXJuIEt0KGkpLnRoZW4oeD0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoeCxjKSkudGhlbih4PT54KS50aGVuKGgseD0+e3EoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit4KSxKZSh4KX0pfWZ1bmN0aW9uIHhyKGksYyl7dmFyIGg9UmU7cmV0dXJuIHhlfHx0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8cXQoaCl8fGguc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fFN8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP2x0KGgsaSxjKTpmZXRjaChoLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHg9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHgsaSkudGhlbihjLGZ1bmN0aW9uKEEpe3JldHVybiBxKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK0EpLHEoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxsdChoLGksYyl9KSl9dmFyIGR0LFd0PXs5MTQ5ODg6aT0+e28uRWEoXCJBYnNcIixpLHZvaWQgMCl9LDkxNTAzOTppPT57by5FYShcIk5lZ1wiLGksdm9pZCAwKX0sOTE1MDkwOmk9PntvLkVhKFwiRmxvb3JcIixpLHZvaWQgMCl9LDkxNTE0MzppPT57by5FYShcIkNlaWxcIixpLHZvaWQgMCl9LDkxNTE5NTppPT57by5FYShcIlJlY2lwcm9jYWxcIixpLHZvaWQgMCl9LDkxNTI1MzppPT57by5FYShcIlNxcnRcIixpLHZvaWQgMCl9LDkxNTMwNTppPT57by5FYShcIkV4cFwiLGksdm9pZCAwKX0sOTE1MzU2Omk9PntvLkVhKFwiRXJmXCIsaSx2b2lkIDApfSw5MTU0MDc6aT0+e28uRWEoXCJTaWdtb2lkXCIsaSx2b2lkIDApfSw5MTU0NjI6aT0+e28uRWEoXCJMb2dcIixpLHZvaWQgMCl9LDkxNTUxMzppPT57by5FYShcIlNpblwiLGksdm9pZCAwKX0sOTE1NTY0Omk9PntvLkVhKFwiQ29zXCIsaSx2b2lkIDApfSw5MTU2MTU6aT0+e28uRWEoXCJUYW5cIixpLHZvaWQgMCl9LDkxNTY2NjppPT57by5FYShcIkFzaW5cIixpLHZvaWQgMCl9LDkxNTcxODppPT57by5FYShcIkFjb3NcIixpLHZvaWQgMCl9LDkxNTc3MDppPT57by5FYShcIkF0YW5cIixpLHZvaWQgMCl9LDkxNTgyMjppPT57by5FYShcIlNpbmhcIixpLHZvaWQgMCl9LDkxNTg3NDppPT57by5FYShcIkNvc2hcIixpLHZvaWQgMCl9LDkxNTkyNjppPT57by5FYShcIkFzaW5oXCIsaSx2b2lkIDApfSw5MTU5Nzk6aT0+e28uRWEoXCJBY29zaFwiLGksdm9pZCAwKX0sOTE2MDMyOmk9PntvLkVhKFwiQXRhbmhcIixpLHZvaWQgMCl9LDkxNjA4NTppPT57by5FYShcIlRhbmhcIixpLHZvaWQgMCl9LDkxNjEzNzppPT57by5FYShcIk5vdFwiLGksdm9pZCAwKX0sOTE2MTg4OihpLGMsaCk9PntvLkVhKFwiQ2xpcFYxMFwiLGkse21pbjpjLG1heDpofSl9LDkxNjI2MDppPT57by5FYShcIkNsaXBcIixpLHZvaWQgMCl9LDkxNjMxMjooaSxjKT0+e28uRWEoXCJFbHVcIixpLHthbHBoYTpjfSl9LDkxNjM3MDppPT57by5FYShcIlJlbHVcIixpLHZvaWQgMCl9LDkxNjQyMjooaSxjKT0+e28uRWEoXCJMZWFreVJlbHVcIixpLHthbHBoYTpjfSl9LDkxNjQ4NjooaSxjKT0+e28uRWEoXCJUaHJlc2hvbGRlZFJlbHVcIixpLHthbHBoYTpjfSl9LDkxNjU1NjooaSxjKT0+e28uRWEoXCJDYXN0XCIsaSx7dG86Y30pfSw5MTY2MTQ6aT0+e28uRWEoXCJBZGRcIixpLHZvaWQgMCl9LDkxNjY2NTppPT57by5FYShcIlN1YlwiLGksdm9pZCAwKX0sOTE2NzE2Omk9PntvLkVhKFwiTXVsXCIsaSx2b2lkIDApfSw5MTY3Njc6aT0+e28uRWEoXCJEaXZcIixpLHZvaWQgMCl9LDkxNjgxODppPT57by5FYShcIlBvd1wiLGksdm9pZCAwKX0sOTE2ODY5Omk9PntvLkVhKFwiRXF1YWxcIixpLHZvaWQgMCl9LDkxNjkyMjppPT57by5FYShcIkdyZWF0ZXJcIixpLHZvaWQgMCl9LDkxNjk3NzppPT57by5FYShcIkdyZWF0ZXJPckVxdWFsXCIsaSx2b2lkIDApfSw5MTcwMzk6aT0+e28uRWEoXCJMZXNzXCIsaSx2b2lkIDApfSw5MTcwOTE6aT0+e28uRWEoXCJMZXNzT3JFcXVhbFwiLGksdm9pZCAwKX0sOTE3MTUwOihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZU1lYW5cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE3MzE0OihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZU1heFwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTc0Nzc6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlTWluXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxNzY0MDooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VQcm9kXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxNzgwNDooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VTdW1cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE3OTY3OihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZUwxXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxODEyOTooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VMMlwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTgyOTE6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlTG9nU3VtXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxODQ1NzooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VTdW1TcXVhcmVcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE4NjI2OihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZUxvZ1N1bUV4cFwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTg3OTU6aT0+e28uRWEoXCJXaGVyZVwiLGksdm9pZCAwKX0sOTE4ODQ4OihpLGMsaCk9PntvLkVhKFwiVHJhbnNwb3NlXCIsaSx7cGVybTpjP0FycmF5LmZyb20obigpLnN1YmFycmF5KGg+Pj4wLGgrYz4+PjApKTpbXX0pfSw5MTg5NjE6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPLHNlKT0+e28uRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OmVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6W2hdLGdyb3VwOngsa2VybmVsX3NoYXBlOltBXSxwYWRzOltrLE5dLHN0cmlkZXM6W2FlXSx3SXNDb25zdDooKT0+ISFyKClbUT4+PjBdLG91dHB1dFBhZGRpbmc6cmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaGU+Pj4wLGhlK3JlPj4+MCkpOltdLG91dHB1dFNoYXBlOmJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KE8+Pj4wLE8rYmU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShzZSl9KX0sOTE5Mzc1OihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyk9PntvLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDphZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20obigpLnN1YmFycmF5KGg+Pj4wLGgrMj4+PjApKSxncm91cDp4LGtlcm5lbFNoYXBlOkFycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEErMj4+PjApKSxwYWRzOkFycmF5LmZyb20obigpLnN1YmFycmF5KGs+Pj4wLGsrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20obigpLnN1YmFycmF5KE4+Pj4wLE4rMj4+PjApKSx3SXNDb25zdDooKT0+ISFyKClbZWU+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8UT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShyZT4+PjAscmUrUT4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGhlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGJlPj4+MCxiZStoZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKE8pfSl9LDkxOTkzMjooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8sc2UpPT57by5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6ZWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbaF0sZ3JvdXA6eCxrZXJuZWxfc2hhcGU6W0FdLHBhZHM6W2ssTl0sc3RyaWRlczpbYWVdLHdJc0NvbnN0OigpPT4hIXIoKVtRPj4+MF0sb3V0cHV0UGFkZGluZzpyZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShoZT4+PjAsaGUrcmU+Pj4wKSk6W10sb3V0cHV0U2hhcGU6YmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTz4+PjAsTytiZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKHNlKX0pfSw5MjAzNDY6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPKT0+e28uRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OmFlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaD4+PjAsaCsyPj4+MCkpLGdyb3VwOngsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaz4+PjAsays0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTj4+PjAsTisyPj4+MCkpLHdJc0NvbnN0OigpPT4hIXIoKVtlZT4+PjBdLG91dHB1dFBhZGRpbmc6MDxRP0FycmF5LmZyb20obigpLnN1YmFycmF5KHJlPj4+MCxyZStRPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8aGU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoYmU+Pj4wLGJlK2hlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoTyl9KX0sOTIwOTAzOihpLGMpPT57by5FYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwOTk0OihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyxzZSx5ZSk9PntvLkVhKFwiQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDp4LHN0b3JhZ2Vfb3JkZXI6QSxkaWxhdGlvbnM6W2ssTl0sa2VybmVsX3NoYXBlOlthZSxlZV0scGFkczpbUSxyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIxMjc4OihpLGMpPT57by5FYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIxMzY5OihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyxzZSx5ZSk9PntvLkVhKFwiQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDp4LHN0b3JhZ2Vfb3JkZXI6QSxkaWxhdGlvbnM6W2ssTl0sa2VybmVsX3NoYXBlOlthZSxlZV0scGFkczpbUSxyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIxNjUzOihpLGMpPT57by5FYShcIkdsb2JhbE1heFBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjE3NDA6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPLHNlLHllKT0+e28uRWEoXCJNYXhQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6eCxzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltrLE5dLGtlcm5lbF9zaGFwZTpbYWUsZWVdLHBhZHM6W1EscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMjAyMDooaSxjKT0+e28uRWEoXCJHbG9iYWxNYXhQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyMTA3OihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyxzZSx5ZSk9PntvLkVhKFwiTWF4UG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOngsc3RvcmFnZV9vcmRlcjpBLGRpbGF0aW9uczpbayxOXSxrZXJuZWxfc2hhcGU6W2FlLGVlXSxwYWRzOltRLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjIzODc6KGksYyxoLHgsQSk9PntvLkVhKFwiR2VtbVwiLGkse2FscGhhOmMsYmV0YTpoLHRyYW5zQTp4LHRyYW5zQjpBfSl9LDkyMjQ5MTppPT57by5FYShcIk1hdE11bFwiLGksdm9pZCAwKX0sOTIyNTQ1OihpLGMsaCx4KT0+e28uRWEoXCJBcmdNYXhcIixpLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhaCxheGlzOnh9KX0sOTIyNjUzOihpLGMsaCx4KT0+e28uRWEoXCJBcmdNaW5cIixpLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhaCxheGlzOnh9KX0sOTIyNzYxOihpLGMpPT57by5FYShcIlNvZnRtYXhcIixpLHtheGlzOmN9KX0sOTIyODI0OihpLGMpPT57by5FYShcIkNvbmNhdFwiLGkse2F4aXM6Y30pfSw5MjI4ODQ6KGksYyxoLHgsQSk9PntvLkVhKFwiU3BsaXRcIixpLHtheGlzOmMsbnVtT3V0cHV0czpoLHNwbGl0U2l6ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTIzMDI5Omk9PntvLkVhKFwiRXhwYW5kXCIsaSx2b2lkIDApfSw5MjMwODM6KGksYyk9PntvLkVhKFwiR2F0aGVyXCIsaSx7YXhpczpOdW1iZXIoYyl9KX0sOTIzMTU0OihpLGMpPT57by5FYShcIkdhdGhlckVsZW1lbnRzXCIsaSx7YXhpczpOdW1iZXIoYyl9KX0sOTIzMjMzOihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUpPT57by5FYShcIlJlc2l6ZVwiLGkse2FudGlhbGlhczpjLGF4ZXM6aD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheSh4Pj4+MCx4K2g+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6VmUoQSksY3ViaWNDb2VmZkE6ayxleGNsdWRlT3V0c2lkZTpOLGV4dHJhcG9sYXRpb25WYWx1ZTphZSxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6VmUoZWUpLG1vZGU6VmUoUSksbmVhcmVzdE1vZGU6VmUocmUpfSl9LDkyMzU4NDooaSxjLGgseCxBLGssTik9PntvLkVhKFwiU2xpY2VcIixpLHtzdGFydHM6Yz9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShoPj4+MCxoK2M+Pj4wKSk6W10sZW5kczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXSxheGVzOms/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTj4+PjAsTitrPj4+MCkpOltdfSl9LDkyMzgxNTppPT57by5FYShcIlRpbGVcIixpLHZvaWQgMCl9LDkyMzg2NzooaSxjLGgpPT57by5FYShcIkxheWVyTm9ybWFsaXphdGlvblwiLGkse2F4aXM6TnVtYmVyKGMpLGVwc2lsb246TnVtYmVyKGgpfSl9LDkyMzk3NDooaSxjLGgpPT57by5FYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246Yyxmb3JtYXQ6aD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjQwODg6KGksYyxoKT0+e28uRWEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOmMsZm9ybWF0Omg/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI0MjAyOmk9PntvLkVhKFwiUmFuZ2VcIixpLHZvaWQgMCl9LDkyNDI1NTooaSxjKT0+e28uRWEoXCJFaW5zdW1cIixpLHtlcXVhdGlvbjpWZShjKX0pfSw5MjQzMzY6KGksYyxoLHgsQSk9PntvLkVhKFwiUGFkXCIsaSx7bW9kZTpjLHZhbHVlOmgscGFkczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MjQ0Njg6aT0+e28uRWEoXCJHZWx1XCIsaSx2b2lkIDApfSw5MjQ1MjA6aT0+e28uRWEoXCJCaWFzQWRkXCIsaSx2b2lkIDApfSw5MjQ1NzU6aT0+e28uRWEoXCJCaWFzU3BsaXRHZWx1XCIsaSx2b2lkIDApfSw5MjQ2MzY6KGksYyk9PntvLkVhKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246Y30pfSw5MjQ3MTc6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSk9PntvLkVhKFwiQ29udlwiLGkse2Zvcm1hdDplZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGRpbGF0aW9uczpbaF0sZ3JvdXA6eCxrZXJuZWxfc2hhcGU6W0FdLHBhZHM6az9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShOPj4+MCxOK2s+Pj4wKSk6W10sc3RyaWRlczpbYWVdLHdfaXNfY29uc3Q6KCk9PiEhcigpW1E+Pj4wXSxhY3RpdmF0aW9uOlZlKHJlKSxhY3RpdmF0aW9uX3BhcmFtczpoZT9BcnJheS5mcm9tKHUoKS5zdWJhcnJheShiZT4+PjAsYmUraGU+Pj4wKSk6W119KX0sOTI1MDk4OihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyxzZSx5ZSk9PntvLkVhKFwiQ29udlwiLGkse2Zvcm1hdDpoZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGRpbGF0aW9uczpbaCx4XSxncm91cDpBLGtlcm5lbF9zaGFwZTpbayxOXSxwYWRzOmFlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGVlPj4+MCxlZSthZT4+PjApKTpbXSxzdHJpZGVzOltRLHJlXSx3X2lzX2NvbnN0OigpPT4hIXIoKVtiZT4+PjBdLGFjdGl2YXRpb246VmUoTyksYWN0aXZhdGlvbl9wYXJhbXM6c2U/QXJyYXkuZnJvbSh1KCkuc3ViYXJyYXkoeWU+Pj4wLHllK3NlPj4+MCkpOltdfSl9LDkyNTUwMDppPT57by56YihpKX0sOTI1NTM0OihpLGMpPT5vLkFiKGksYyxvLmJiLkZiLG8uYmIuZXJyb3JzKSw5MjU2NDY6aT0+by53YihpKSw5MjU2Nzk6aT0+by55YihpKSw5MjU3MTE6KGksYyxoKT0+e28uamIoaSxjLGgsITApfSw5MjU3NTA6KGksYyxoKT0+e28uamIoaSxjLGgpfX07ZnVuY3Rpb24geXQoaSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2l9KWAsdGhpcy5zdGF0dXM9aX1mdW5jdGlvbiBOdChpKXtpLnRlcm1pbmF0ZSgpLGkub25tZXNzYWdlPSgpPT57fX1mdW5jdGlvbiBWdChpKXsoaT1uZS5RYVtpXSl8fEplKCksbmUuRWIoaSl9ZnVuY3Rpb24gWXQoaSl7dmFyIGM9bmUudGIoKTtpZighYylyZXR1cm4gNjtuZS5ZYS5wdXNoKGMpLG5lLlFhW2kuWGFdPWMsYy5YYT1pLlhhO3ZhciBoPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOmkuR2IsYXJnOmkucmIscHRocmVhZF9wdHI6aS5YYX07cmV0dXJuIFMmJmMudW5yZWYoKSxjLnBvc3RNZXNzYWdlKGgsaS5NYiksMH12YXIgVXQ9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLFNyPShpLGMsaCk9PntjPj4+PTA7dmFyIHg9YytoO2ZvcihoPWM7aVtoXSYmIShoPj14KTspKytoO2lmKDE2PGgtYyYmaS5idWZmZXImJlV0KXJldHVybiBVdC5kZWNvZGUoaS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj9pLnNsaWNlKGMsaCk6aS5zdWJhcnJheShjLGgpKTtmb3IoeD1cIlwiO2M8aDspe3ZhciBBPWlbYysrXTtpZihBJjEyOCl7dmFyIGs9aVtjKytdJjYzO2lmKChBJjIyNCk9PTE5Mil4Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKChBJjMxKTw8NnxrKTtlbHNle3ZhciBOPWlbYysrXSY2MztBPShBJjI0MCk9PTIyND8oQSYxNSk8PDEyfGs8PDZ8TjooQSY3KTw8MTh8azw8MTJ8Tjw8NnxpW2MrK10mNjMsNjU1MzY+QT94Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKEEpOihBLT02NTUzNix4Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fEE+PjEwLDU2MzIwfEEmMTAyMykpfX1lbHNlIHgrPVN0cmluZy5mcm9tQ2hhckNvZGUoQSl9cmV0dXJuIHh9LFZlPShpLGMpPT4oaT4+Pj0wKT9TcihhKCksaSxjKTpcIlwiO2Z1bmN0aW9uIFh0KGkpe2lmKEkpcmV0dXJuIFYoMSwxLGkpO0VlPWksZXQoKXx8KG5lLkhiKCksby5vbkV4aXQmJm8ub25FeGl0KGkpLFRlPSEwKSx2KGksbmV3IHl0KGkpKX12YXIgSnQ9aT0+e2lmKEVlPWksSSl0aHJvdyBDcihpKSxcInVud2luZFwiO1h0KGkpfSxuZT17YWI6W10sWWE6W10sbWI6W10sUWE6e30sZ2I6ZnVuY3Rpb24oKXtJP25lLnZiKCk6bmUudWIoKX0sdWI6ZnVuY3Rpb24oKXtIZS51bnNoaWZ0KCgpPT57anQoKSxuZS5CYigoKT0+JHIoKSl9KX0sdmI6ZnVuY3Rpb24oKXtuZS5yZWNlaXZlT2JqZWN0VHJhbnNmZXI9bmUuRGIsbmUudGhyZWFkSW5pdFRMUz1uZS5sYixuZS5zZXRFeGl0U3RhdHVzPW5lLmtiLG9lPSExfSxrYjpmdW5jdGlvbihpKXtFZT1pfSxTYjpbXCIkdGVybWluYXRlV29ya2VyXCJdLEhiOmZ1bmN0aW9uKCl7Zm9yKHZhciBpIG9mIG5lLllhKU50KGkpO2ZvcihpIG9mIG5lLmFiKU50KGkpO25lLmFiPVtdLG5lLllhPVtdLG5lLlFhPVtdfSxFYjpmdW5jdGlvbihpKXt2YXIgYz1pLlhhO2RlbGV0ZSBuZS5RYVtjXSxuZS5hYi5wdXNoKGkpLG5lLllhLnNwbGljZShuZS5ZYS5pbmRleE9mKGkpLDEpLGkuWGE9MCxDbihjKX0sRGI6ZnVuY3Rpb24oKXt9LGxiOmZ1bmN0aW9uKCl7bmUubWIuZm9yRWFjaChpPT5pKCkpfSxDYjppPT5uZXcgUHJvbWlzZShjPT57aS5vbm1lc3NhZ2U9az0+e2s9ay5kYXRhO3ZhciBOPWsuY21kO2lmKGsudGFyZ2V0VGhyZWFkJiZrLnRhcmdldFRocmVhZCE9TXIoKSl7dmFyIGFlPW5lLlFhW2suUmJdO2FlP2FlLnBvc3RNZXNzYWdlKGssay50cmFuc2Zlckxpc3QpOnEoJ0ludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCInK04rJ1wiIHRvIHRhcmdldCBwdGhyZWFkICcray50YXJnZXRUaHJlYWQrXCIsIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIVwiKX1lbHNlIE49PT1cImNoZWNrTWFpbGJveFwiP1R0KCk6Tj09PVwic3Bhd25UaHJlYWRcIj9ZdChrKTpOPT09XCJjbGVhbnVwVGhyZWFkXCI/VnQoay50aHJlYWQpOk49PT1cImtpbGxUaHJlYWRcIj8oaz1rLnRocmVhZCxOPW5lLlFhW2tdLGRlbGV0ZSBuZS5RYVtrXSxOdChOKSxDbihrKSxuZS5ZYS5zcGxpY2UobmUuWWEuaW5kZXhPZihOKSwxKSxOLlhhPTApOk49PT1cImNhbmNlbFRocmVhZFwiP25lLlFhW2sudGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpOPT09XCJsb2FkZWRcIj8oaS5sb2FkZWQ9ITAsYyhpKSk6Tj09PVwiYWxlcnRcIj9hbGVydChcIlRocmVhZCBcIitrLnRocmVhZElkK1wiOiBcIitrLnRleHQpOmsudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIj9pLnBvc3RNZXNzYWdlKGspOk49PT1cImNhbGxIYW5kbGVyXCI/b1trLmhhbmRsZXJdKC4uLmsuYXJncyk6TiYmcShcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIitOKX0saS5vbmVycm9yPWs9Pnt0aHJvdyBxKFwid29ya2VyIHNlbnQgYW4gZXJyb3IhIFwiK2suZmlsZW5hbWUrXCI6XCIray5saW5lbm8rXCI6IFwiK2subWVzc2FnZSksa30sUyYmKGkub24oXCJtZXNzYWdlXCIsZnVuY3Rpb24oayl7aS5vbm1lc3NhZ2Uoe2RhdGE6a30pfSksaS5vbihcImVycm9yXCIsZnVuY3Rpb24oayl7aS5vbmVycm9yKGspfSkpO3ZhciBoPVtdLHg9W1wib25FeGl0XCIsXCJvbkFib3J0XCIsXCJwcmludFwiLFwicHJpbnRFcnJcIl0sQTtmb3IoQSBvZiB4KW8uaGFzT3duUHJvcGVydHkoQSkmJmgucHVzaChBKTtpLnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsaGFuZGxlcnM6aCx1cmxPckJsb2I6by5tYWluU2NyaXB0VXJsT3JCbG9ifHxlLHdhc21NZW1vcnk6d2Usd2FzbU1vZHVsZTpTZX0pfSksQmI6ZnVuY3Rpb24oaSl7aSgpfSxxYjpmdW5jdGlvbigpe3ZhciBpPUIoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndvcmtlci5qc1wiKTtpPW5ldyBXb3JrZXIoaSksbmUuYWIucHVzaChpKX0sdGI6ZnVuY3Rpb24oKXtyZXR1cm4gbmUuYWIubGVuZ3RoPT0wJiYobmUucWIoKSxuZS5DYihuZS5hYlswXSkpLG5lLmFiLnBvcCgpfX07by5QVGhyZWFkPW5lO3ZhciBjdD1pPT57Zm9yKDswPGkubGVuZ3RoOylpLnNoaWZ0KCkobyl9O28uZXN0YWJsaXNoU3RhY2tTcGFjZT1mdW5jdGlvbigpe3ZhciBpPU1yKCksYz1uKClbaSs1Mj4+Mj4+PjBdO2k9bigpW2krNTY+PjI+Pj4wXSxEYShjLGMtaSksRHIoYyl9O2Z1bmN0aW9uIENyKGkpe2lmKEkpcmV0dXJuIFYoMiwwLGkpO0p0KGkpfW8uaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbihpLGMpe2k9emEuYXBwbHkobnVsbCxbaSxjXSksZXQoKT9uZS5rYihpKTpJbihpKX07ZnVuY3Rpb24gdHQoaSl7dGhpcy5mYj1pLTI0LHRoaXMucGI9ZnVuY3Rpb24oYyl7cygpW3RoaXMuZmIrND4+Mj4+PjBdPWN9LHRoaXMub2I9ZnVuY3Rpb24oYyl7cygpW3RoaXMuZmIrOD4+Mj4+PjBdPWN9LHRoaXMuZ2I9ZnVuY3Rpb24oYyxoKXt0aGlzLm5iKCksdGhpcy5wYihjKSx0aGlzLm9iKGgpfSx0aGlzLm5iPWZ1bmN0aW9uKCl7cygpW3RoaXMuZmIrMTY+PjI+Pj4wXT0wfX12YXIgWWU9MCxJcj0wO2Z1bmN0aW9uIF90KGksYyxoLHgpe3JldHVybiBJP1YoMywxLGksYyxoLHgpOlF0KGksYyxoLHgpfWZ1bmN0aW9uIFF0KGksYyxoLHgpe2lmKGk+Pj49MCxjPj4+PTAsaD4+Pj0wLHg+Pj49MCx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuIHEoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBBPVtdO3JldHVybiBJJiZBLmxlbmd0aD09PTA/X3QoaSxjLGgseCk6KGk9e0diOmgsWGE6aSxyYjp4LE1iOkF9LEk/KGkuT2I9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKGksQSksMCk6WXQoaSkpfWZ1bmN0aW9uIFp0KGksYyxoKXtyZXR1cm4gST9WKDQsMSxpLGMsaCk6MH1mdW5jdGlvbiBBcihpLGMpe2lmKEkpcmV0dXJuIFYoNSwxLGksYyl9dmFyIE90PWk9Pntmb3IodmFyIGM9MCxoPTA7aDxpLmxlbmd0aDsrK2gpe3ZhciB4PWkuY2hhckNvZGVBdChoKTsxMjc+PXg/YysrOjIwNDc+PXg/Yys9Mjo1NTI5Njw9eCYmNTczNDM+PXg/KGMrPTQsKytoKTpjKz0zfXJldHVybiBjfSxFcj0oaSxjLGgseCk9PntpZihoPj4+PTAsISgwPHgpKXJldHVybiAwO3ZhciBBPWg7eD1oK3gtMTtmb3IodmFyIGs9MDtrPGkubGVuZ3RoOysrayl7dmFyIE49aS5jaGFyQ29kZUF0KGspO2lmKDU1Mjk2PD1OJiY1NzM0Mz49Til7dmFyIGFlPWkuY2hhckNvZGVBdCgrK2spO049NjU1MzYrKChOJjEwMjMpPDwxMCl8YWUmMTAyM31pZigxMjc+PU4pe2lmKGg+PXgpYnJlYWs7Y1toKys+Pj4wXT1OfWVsc2V7aWYoMjA0Nz49Til7aWYoaCsxPj14KWJyZWFrO2NbaCsrPj4+MF09MTkyfE4+PjZ9ZWxzZXtpZig2NTUzNT49Til7aWYoaCsyPj14KWJyZWFrO2NbaCsrPj4+MF09MjI0fE4+PjEyfWVsc2V7aWYoaCszPj14KWJyZWFrO2NbaCsrPj4+MF09MjQwfE4+PjE4LGNbaCsrPj4+MF09MTI4fE4+PjEyJjYzfWNbaCsrPj4+MF09MTI4fE4+PjYmNjN9Y1toKys+Pj4wXT0xMjh8TiY2M319cmV0dXJuIGNbaD4+PjBdPTAsaC1BfSxfcj0oaSxjLGgpPT5FcihpLGEoKSxjLGgpO2Z1bmN0aW9uIE9yKGksYyl7aWYoSSlyZXR1cm4gVig2LDEsaSxjKX1mdW5jdGlvbiBUcihpLGMsaCl7aWYoSSlyZXR1cm4gVig3LDEsaSxjLGgpfWZ1bmN0aW9uIFJyKGksYyxoKXtyZXR1cm4gST9WKDgsMSxpLGMsaCk6MH1mdW5jdGlvbiBQcihpLGMpe2lmKEkpcmV0dXJuIFYoOSwxLGksYyl9ZnVuY3Rpb24gR3QoaSxjLGgpe2lmKEkpcmV0dXJuIFYoMTAsMSxpLGMsaCl9ZnVuY3Rpb24gZXIoaSxjLGgseCl7aWYoSSlyZXR1cm4gVigxMSwxLGksYyxoLHgpfWZ1bmN0aW9uIHRyKGksYyxoLHgpe2lmKEkpcmV0dXJuIFYoMTIsMSxpLGMsaCx4KX1mdW5jdGlvbiBycihpLGMsaCx4KXtpZihJKXJldHVybiBWKDEzLDEsaSxjLGgseCl9ZnVuY3Rpb24gbnIoaSl7aWYoSSlyZXR1cm4gVigxNCwxLGkpfWZ1bmN0aW9uIGFyKGksYyl7aWYoSSlyZXR1cm4gVigxNSwxLGksYyl9ZnVuY3Rpb24gb3IoaSxjLGgpe2lmKEkpcmV0dXJuIFYoMTYsMSxpLGMsaCl9dmFyIGlyPWk9PntpZighVGUpdHJ5e2lmKGkoKSwhZXQoKSl0cnl7ST9JbihFZSk6SnQoRWUpfWNhdGNoKGMpe2MgaW5zdGFuY2VvZiB5dHx8Yz09XCJ1bndpbmRcInx8digxLGMpfX1jYXRjaChjKXtjIGluc3RhbmNlb2YgeXR8fGM9PVwidW53aW5kXCJ8fHYoMSxjKX19O2Z1bmN0aW9uIEZ0KGkpe2k+Pj49MCx0eXBlb2YgQXRvbWljcy5OYj09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5OYihuKCksaT4+MixpKS52YWx1ZS50aGVuKFR0KSxpKz0xMjgsQXRvbWljcy5zdG9yZShuKCksaT4+MiwxKSl9by5fX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQ9RnQ7ZnVuY3Rpb24gVHQoKXt2YXIgaT1NcigpO2kmJihGdChpKSxpcigoKT0+QmEoKSkpfW8uY2hlY2tNYWlsYm94PVR0O3ZhciBidD1pPT5pJTQ9PT0wJiYoaSUxMDAhPT0wfHxpJTQwMD09PTApLFJ0PVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLHNyPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO2Z1bmN0aW9uIGQoaSxjLGgseCxBLGssTixhZSl7cmV0dXJuIEk/VigxNywxLGksYyxoLHgsQSxrLE4sYWUpOi01Mn1mdW5jdGlvbiBmKGksYyxoLHgsQSxrLE4pe2lmKEkpcmV0dXJuIFYoMTgsMSxpLGMsaCx4LEEsayxOKX12YXIgdz1pPT57dmFyIGM9T3QoaSkrMSxoPVNuKGMpO3JldHVybiBoJiZfcihpLGgsYyksaH0sQz1bXSxfPShpLGMpPT57Qy5sZW5ndGg9MDt2YXIgaDtmb3IoYz4+PTI7aD1hKClbaSsrPj4+MF07KWMrPWghPTEwNSZjLEMucHVzaChoPT0xMDU/bigpW2M+Pj4wXTpsKClbYysrPj4+MV0pLCsrYztyZXR1cm4gQ30sRz1pPT57dmFyIGM9QW4oKTtyZXR1cm4gaT1pKCksRHIoYyksaX07ZnVuY3Rpb24gVihpLGMpe3ZhciBoPWFyZ3VtZW50cy5sZW5ndGgtMix4PWFyZ3VtZW50cztyZXR1cm4gRygoKT0+e2Zvcih2YXIgQT1Fbig4KmgpLGs9QT4+MyxOPTA7TjxoO04rKyl7dmFyIGFlPXhbMitOXTtsKClbaytOPj4+MF09YWV9cmV0dXJuIGthKGksaCxBLGMpfSl9dmFyIHVlPVtdLFk9e30sWj0oKT0+e2lmKCFKKXt2YXIgaT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpnfHxcIi4vdGhpcy5wcm9ncmFtXCJ9LGM7Zm9yKGMgaW4gWSlZW2NdPT09dm9pZCAwP2RlbGV0ZSBpW2NdOmlbY109WVtjXTt2YXIgaD1bXTtmb3IoYyBpbiBpKWgucHVzaChgJHtjfT0ke2lbY119YCk7Sj1ofXJldHVybiBKfSxKO2Z1bmN0aW9uIGNlKGksYyl7aWYoSSlyZXR1cm4gVigxOSwxLGksYyk7aT4+Pj0wLGM+Pj49MDt2YXIgaD0wO3JldHVybiBaKCkuZm9yRWFjaChmdW5jdGlvbih4LEEpe3ZhciBrPWMraDtmb3IoQT1zKClbaSs0KkE+PjI+Pj4wXT1rLGs9MDtrPHgubGVuZ3RoOysraylyKClbQSsrPj4wPj4+MF09eC5jaGFyQ29kZUF0KGspO3IoKVtBPj4wPj4+MF09MCxoKz14Lmxlbmd0aCsxfSksMH1mdW5jdGlvbiBtZShpLGMpe2lmKEkpcmV0dXJuIFYoMjAsMSxpLGMpO2k+Pj49MCxjPj4+PTA7dmFyIGg9WigpO3MoKVtpPj4yPj4+MF09aC5sZW5ndGg7dmFyIHg9MDtyZXR1cm4gaC5mb3JFYWNoKGZ1bmN0aW9uKEEpe3grPUEubGVuZ3RoKzF9KSxzKClbYz4+Mj4+PjBdPXgsMH1mdW5jdGlvbiBFKGkpe3JldHVybiBJP1YoMjEsMSxpKTo1Mn1mdW5jdGlvbiB0ZShpLGMsaCx4KXtyZXR1cm4gST9WKDIyLDEsaSxjLGgseCk6NTJ9ZnVuY3Rpb24gZmUoaSxjLGgseCxBKXtyZXR1cm4gST9WKDIzLDEsaSxjLGgseCxBKTo3MH12YXIgcHQ9W251bGwsW10sW11dO2Z1bmN0aW9uIHVyKGksYyxoLHgpe2lmKEkpcmV0dXJuIFYoMjQsMSxpLGMsaCx4KTtjPj4+PTAsaD4+Pj0wLHg+Pj49MDtmb3IodmFyIEE9MCxrPTA7azxoO2srKyl7dmFyIE49cygpW2M+PjI+Pj4wXSxhZT1zKClbYys0Pj4yPj4+MF07Yys9ODtmb3IodmFyIGVlPTA7ZWU8YWU7ZWUrKyl7dmFyIFE9YSgpW04rZWU+Pj4wXSxyZT1wdFtpXTtRPT09MHx8UT09PTEwPygoaT09PTE/TTpxKShTcihyZSwwKSkscmUubGVuZ3RoPTApOnJlLnB1c2goUSl9QSs9YWV9cmV0dXJuIHMoKVt4Pj4yPj4+MF09QSwwfXZhciBJYT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLEFhPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gdmwoaSl7dmFyIGM9QXJyYXkoT3QoaSkrMSk7cmV0dXJuIEVyKGksYywwLGMubGVuZ3RoKSxjfXZhciAkbD0oaSxjKT0+e3IoKS5zZXQoaSxjPj4+MCl9O2Z1bmN0aW9uIEVhKGksYyxoLHgpe2Z1bmN0aW9uIEEoTyxzZSx5ZSl7Zm9yKE89dHlwZW9mIE89PVwibnVtYmVyXCI/Ty50b1N0cmluZygpOk98fFwiXCI7Ty5sZW5ndGg8c2U7KU89eWVbMF0rTztyZXR1cm4gT31mdW5jdGlvbiBrKE8sc2Upe3JldHVybiBBKE8sc2UsXCIwXCIpfWZ1bmN0aW9uIE4oTyxzZSl7ZnVuY3Rpb24geWUoRmEpe3JldHVybiAwPkZhPy0xOjA8RmE/MTowfXZhciBQdDtyZXR1cm4oUHQ9eWUoTy5nZXRGdWxsWWVhcigpLXNlLmdldEZ1bGxZZWFyKCkpKT09PTAmJihQdD15ZShPLmdldE1vbnRoKCktc2UuZ2V0TW9udGgoKSkpPT09MCYmKFB0PXllKE8uZ2V0RGF0ZSgpLXNlLmdldERhdGUoKSkpLFB0fWZ1bmN0aW9uIGFlKE8pe3N3aXRjaChPLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIE87Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGVlKE8pe3ZhciBzZT1PLlphO2ZvcihPPW5ldyBEYXRlKG5ldyBEYXRlKE8uJGErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxzZTspe3ZhciB5ZT1PLmdldE1vbnRoKCksUHQ9KGJ0KE8uZ2V0RnVsbFllYXIoKSk/SWE6QWEpW3llXTtpZihzZT5QdC1PLmdldERhdGUoKSlzZS09UHQtTy5nZXREYXRlKCkrMSxPLnNldERhdGUoMSksMTE+eWU/Ty5zZXRNb250aCh5ZSsxKTooTy5zZXRNb250aCgwKSxPLnNldEZ1bGxZZWFyKE8uZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtPLnNldERhdGUoTy5nZXREYXRlKCkrc2UpO2JyZWFrfX1yZXR1cm4geWU9bmV3IERhdGUoTy5nZXRGdWxsWWVhcigpKzEsMCw0KSxzZT1hZShuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCw0KSkseWU9YWUoeWUpLDA+PU4oc2UsTyk/MD49Tih5ZSxPKT9PLmdldEZ1bGxZZWFyKCkrMTpPLmdldEZ1bGxZZWFyKCk6Ty5nZXRGdWxsWWVhcigpLTF9aT4+Pj0wLGM+Pj49MCxoPj4+PTAseD4+Pj0wO3ZhciBRPW4oKVt4KzQwPj4yPj4+MF07eD17S2I6bigpW3g+PjI+Pj4wXSxKYjpuKClbeCs0Pj4yPj4+MF0sY2I6bigpW3grOD4+Mj4+PjBdLGliOm4oKVt4KzEyPj4yPj4+MF0sZWI6bigpW3grMTY+PjI+Pj4wXSwkYTpuKClbeCsyMD4+Mj4+PjBdLFdhOm4oKVt4KzI0Pj4yPj4+MF0sWmE6bigpW3grMjg+PjI+Pj4wXSxUYjpuKClbeCszMj4+Mj4+PjBdLEliOm4oKVt4KzM2Pj4yPj4+MF0sTGI6UT9WZShRKTpcIlwifSxoPVZlKGgpLFE9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIHJlIGluIFEpaD1oLnJlcGxhY2UobmV3IFJlZ0V4cChyZSxcImdcIiksUVtyZV0pO3ZhciBoZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGJlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtRPXtcIiVhXCI6Tz0+aGVbTy5XYV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOk89PmhlW08uV2FdLFwiJWJcIjpPPT5iZVtPLmViXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6Tz0+YmVbTy5lYl0sXCIlQ1wiOk89PmsoKE8uJGErMTkwMCkvMTAwfDAsMiksXCIlZFwiOk89PmsoTy5pYiwyKSxcIiVlXCI6Tz0+QShPLmliLDIsXCIgXCIpLFwiJWdcIjpPPT5lZShPKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6Tz0+ZWUoTyksXCIlSFwiOk89PmsoTy5jYiwyKSxcIiVJXCI6Tz0+KE89Ty5jYixPPT0wP089MTI6MTI8TyYmKE8tPTEyKSxrKE8sMikpLFwiJWpcIjpPPT57Zm9yKHZhciBzZT0wLHllPTA7eWU8PU8uZWItMTtzZSs9KGJ0KE8uJGErMTkwMCk/SWE6QWEpW3llKytdKTtyZXR1cm4gayhPLmliK3NlLDMpfSxcIiVtXCI6Tz0+ayhPLmViKzEsMiksXCIlTVwiOk89PmsoTy5KYiwyKSxcIiVuXCI6KCk9PmBcbmAsXCIlcFwiOk89PjA8PU8uY2ImJjEyPk8uY2I/XCJBTVwiOlwiUE1cIixcIiVTXCI6Tz0+ayhPLktiLDIpLFwiJXRcIjooKT0+XCJcdFwiLFwiJXVcIjpPPT5PLldhfHw3LFwiJVVcIjpPPT5rKE1hdGguZmxvb3IoKE8uWmErNy1PLldhKS83KSwyKSxcIiVWXCI6Tz0+e3ZhciBzZT1NYXRoLmZsb29yKChPLlphKzctKE8uV2ErNiklNykvNyk7aWYoMj49KE8uV2ErMzcxLU8uWmEtMiklNyYmc2UrKyxzZSlzZT09NTMmJih5ZT0oTy5XYSszNzEtTy5aYSklNyx5ZT09NHx8eWU9PTMmJmJ0KE8uJGEpfHwoc2U9MSkpO2Vsc2V7c2U9NTI7dmFyIHllPShPLldhKzctTy5aYS0xKSU3Oyh5ZT09NHx8eWU9PTUmJmJ0KE8uJGElNDAwLTEpKSYmc2UrK31yZXR1cm4gayhzZSwyKX0sXCIld1wiOk89Pk8uV2EsXCIlV1wiOk89PmsoTWF0aC5mbG9vcigoTy5aYSs3LShPLldhKzYpJTcpLzcpLDIpLFwiJXlcIjpPPT4oTy4kYSsxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6Tz0+Ty4kYSsxOTAwLFwiJXpcIjpPPT57Tz1PLkliO3ZhciBzZT0wPD1PO3JldHVybiBPPU1hdGguYWJzKE8pLzYwLChzZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyhPLzYwKjEwMCtPJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6Tz0+Ty5MYixcIiUlXCI6KCk9PlwiJVwifSxoPWgucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKTtmb3IocmUgaW4gUSloLmluY2x1ZGVzKHJlKSYmKGg9aC5yZXBsYWNlKG5ldyBSZWdFeHAocmUsXCJnXCIpLFFbcmVdKHgpKSk7cmV0dXJuIGg9aC5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikscmU9dmwoaCkscmUubGVuZ3RoPmM/MDooJGwocmUsaSkscmUubGVuZ3RoLTEpfWZ1bmN0aW9uIGtyKGkpe3RyeXtpKCl9Y2F0Y2goYyl7SmUoYyl9fWZ1bmN0aW9uIHhsKGkpe3ZhciBjPXt9LGg7Zm9yKGggaW4gaSkoZnVuY3Rpb24oeCl7dmFyIEE9aVt4XTtjW3hdPXR5cGVvZiBBPT1cImZ1bmN0aW9uXCI/ZnVuY3Rpb24oKXtCci5wdXNoKHgpO3RyeXtyZXR1cm4gQS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZmluYWxseXtUZXx8KEJyLnBvcCgpPT09eHx8SmUoKSxydCYmd3Q9PT0xJiZCci5sZW5ndGg9PT0wJiYod3Q9MCxHZSs9MSxrcihOYSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLlViKCkpKX19OkF9KShoKTtyZXR1cm4gY312YXIgd3Q9MCxydD1udWxsLF9hPTAsQnI9W10sT2E9e30sVGE9e30sU2w9MCx4bj1udWxsLENsPVtdO2Z1bmN0aW9uIElsKCl7cmV0dXJuIG5ldyBQcm9taXNlKChpLGMpPT57eG49e3Jlc29sdmU6aSxyZWplY3Q6Y319KX1mdW5jdGlvbiBBbCgpe3ZhciBpPVNuKDY1NTQ4KSxjPWkrMTI7cygpW2k+PjI+Pj4wXT1jLHMoKVtpKzQ+PjI+Pj4wXT1jKzY1NTM2LGM9QnJbMF07dmFyIGg9T2FbY107cmV0dXJuIGg9PT12b2lkIDAmJihoPVNsKyssT2FbY109aCxUYVtoXT1jKSxjPWgsbigpW2krOD4+Mj4+PjBdPWMsaX1mdW5jdGlvbiBFbCgpe3ZhciBpPW4oKVtydCs4Pj4yPj4+MF07cmV0dXJuIGk9altUYVtpXV0sLS1HZSxpKCl9ZnVuY3Rpb24gX2woaSl7aWYoIVRlKXtpZih3dD09PTApe3ZhciBjPSExLGg9ITE7aSgoeD0wKT0+e2lmKCFUZSYmKF9hPXgsYz0hMCxoKSl7d3Q9MixrcigoKT0+VmEocnQpKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5oYi5zYiYmQnJvd3Nlci5oYi5yZXN1bWUoKSx4PSExO3RyeXt2YXIgQT1FbCgpfWNhdGNoKGFlKXtBPWFlLHg9ITB9dmFyIGs9ITE7aWYoIXJ0KXt2YXIgTj14bjtOJiYoeG49bnVsbCwoeD9OLnJlamVjdDpOLnJlc29sdmUpKEEpLGs9ITApfWlmKHgmJiFrKXRocm93IEF9fSksaD0hMCxjfHwod3Q9MSxydD1BbCgpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLmhiLnNiJiZCcm93c2VyLmhiLnBhdXNlKCksa3IoKCk9PldhKHJ0KSkpfWVsc2Ugd3Q9PT0yPyh3dD0wLGtyKFVhKSxSYShydCkscnQ9bnVsbCxDbC5mb3JFYWNoKHg9PmlyKHgpKSk6SmUoYGludmFsaWQgc3RhdGU6ICR7d3R9YCk7cmV0dXJuIF9hfX1mdW5jdGlvbiBPbChpKXtyZXR1cm4gX2woYz0+e2koKS50aGVuKGMpfSl9bmUuZ2IoKTt2YXIgVGw9W251bGwsWHQsQ3IsX3QsWnQsQXIsT3IsVHIsUnIsUHIsR3QsZXIsdHIscnIsbnIsYXIsb3IsZCxmLGNlLG1lLEUsdGUsZmUsdXJdLFJsPXtyOmZ1bmN0aW9uKGksYyxoKXtyZXR1cm4gT2woYXN5bmMoKT0+e2F3YWl0IG8ueGIoaSxjLGgpfSl9LGI6ZnVuY3Rpb24oaSxjLGgpe3Rocm93IGk+Pj49MCxuZXcgdHQoaSkuZ2IoYz4+PjAsaD4+PjApLFllPWksSXIrKyxZZX0sTzpmdW5jdGlvbihpKXtQYShpPj4+MCwhYiwxLCEkLDEzMTA3MiwhMSksbmUubGIoKX0sbDpmdW5jdGlvbihpKXtpPj4+PTAsST9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDppfSk6VnQoaSl9LEk6UXQsaTpadCxVOkFyLEU6T3IsRzpUcixWOlJyLFM6UHIsSzpHdCxSOmVyLHA6dHIsRjpycixDOm5yLFQ6YXIsRDpvcixxOigpPT4hMCxBOmZ1bmN0aW9uKGksYyl7aT4+Pj0wLGk9PWM+Pj4wP3NldFRpbWVvdXQoKCk9PlR0KCkpOkk/cG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDppLGNtZDpcImNoZWNrTWFpbGJveFwifSk6KGk9bmUuUWFbaV0pJiZpLnBvc3RNZXNzYWdlKHtjbWQ6XCJjaGVja01haWxib3hcIn0pfSxNOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LE46RnQsWDpmdW5jdGlvbihpKXtTJiZuZS5RYVtpPj4+MF0ucmVmKCl9LHU6ZnVuY3Rpb24oaSxjLGgpe2k9YysyMDk3MTUyPj4+MDw0MTk0MzA1LSEhaT8oaT4+PjApKzQyOTQ5NjcyOTYqYzpOYU4saD4+Pj0wLGk9bmV3IERhdGUoMWUzKmkpLG4oKVtoPj4yPj4+MF09aS5nZXRVVENTZWNvbmRzKCksbigpW2grND4+Mj4+PjBdPWkuZ2V0VVRDTWludXRlcygpLG4oKVtoKzg+PjI+Pj4wXT1pLmdldFVUQ0hvdXJzKCksbigpW2grMTI+PjI+Pj4wXT1pLmdldFVUQ0RhdGUoKSxuKClbaCsxNj4+Mj4+PjBdPWkuZ2V0VVRDTW9udGgoKSxuKClbaCsyMD4+Mj4+PjBdPWkuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLG4oKVtoKzI0Pj4yPj4+MF09aS5nZXRVVENEYXkoKSxpPShpLmdldFRpbWUoKS1EYXRlLlVUQyhpLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLG4oKVtoKzI4Pj4yPj4+MF09aX0sdjpmdW5jdGlvbihpLGMsaCl7aT1jKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFpPyhpPj4+MCkrNDI5NDk2NzI5NipjOk5hTixoPj4+PTAsaT1uZXcgRGF0ZSgxZTMqaSksbigpW2g+PjI+Pj4wXT1pLmdldFNlY29uZHMoKSxuKClbaCs0Pj4yPj4+MF09aS5nZXRNaW51dGVzKCksbigpW2grOD4+Mj4+PjBdPWkuZ2V0SG91cnMoKSxuKClbaCsxMj4+Mj4+PjBdPWkuZ2V0RGF0ZSgpLG4oKVtoKzE2Pj4yPj4+MF09aS5nZXRNb250aCgpLG4oKVtoKzIwPj4yPj4+MF09aS5nZXRGdWxsWWVhcigpLTE5MDAsbigpW2grMjQ+PjI+Pj4wXT1pLmdldERheSgpLGM9KGJ0KGkuZ2V0RnVsbFllYXIoKSk/UnQ6c3IpW2kuZ2V0TW9udGgoKV0raS5nZXREYXRlKCktMXwwLG4oKVtoKzI4Pj4yPj4+MF09YyxuKClbaCszNj4+Mj4+PjBdPS0oNjAqaS5nZXRUaW1lem9uZU9mZnNldCgpKSxjPW5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHg9bmV3IERhdGUoaS5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtpPShjIT14JiZpLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKHgsYykpfDAsbigpW2grMzI+PjI+Pj4wXT1pfSx3OmZ1bmN0aW9uKGkpe2k+Pj49MDt2YXIgYz1uZXcgRGF0ZShuKClbaSsyMD4+Mj4+PjBdKzE5MDAsbigpW2krMTY+PjI+Pj4wXSxuKClbaSsxMj4+Mj4+PjBdLG4oKVtpKzg+PjI+Pj4wXSxuKClbaSs0Pj4yPj4+MF0sbigpW2k+PjI+Pj4wXSwwKSxoPW4oKVtpKzMyPj4yPj4+MF0seD1jLmdldFRpbWV6b25lT2Zmc2V0KCksQT1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGs9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxOPU1hdGgubWluKGssQSk7cmV0dXJuIDA+aD9uKClbaSszMj4+Mj4+PjBdPSsoQSE9ayYmTj09eCk6MDxoIT0oTj09eCkmJihBPU1hdGgubWF4KGssQSksYy5zZXRUaW1lKGMuZ2V0VGltZSgpKzZlNCooKDA8aD9OOkEpLXgpKSksbigpW2krMjQ+PjI+Pj4wXT1jLmdldERheSgpLGg9KGJ0KGMuZ2V0RnVsbFllYXIoKSk/UnQ6c3IpW2MuZ2V0TW9udGgoKV0rYy5nZXREYXRlKCktMXwwLG4oKVtpKzI4Pj4yPj4+MF09aCxuKClbaT4+Mj4+PjBdPWMuZ2V0U2Vjb25kcygpLG4oKVtpKzQ+PjI+Pj4wXT1jLmdldE1pbnV0ZXMoKSxuKClbaSs4Pj4yPj4+MF09Yy5nZXRIb3VycygpLG4oKVtpKzEyPj4yPj4+MF09Yy5nZXREYXRlKCksbigpW2krMTY+PjI+Pj4wXT1jLmdldE1vbnRoKCksbigpW2krMjA+PjI+Pj4wXT1jLmdldFllYXIoKSxpPWMuZ2V0VGltZSgpLzFlMyxNYSgoZHQ9aSwxPD0rTWF0aC5hYnMoZHQpPzA8ZHQ/K01hdGguZmxvb3IoZHQvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgoZHQtKyh+fmR0Pj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKSksaT4+PjB9LHM6ZCx0OmYsejpmdW5jdGlvbihpLGMsaCl7ZnVuY3Rpb24geChRKXtyZXR1cm4oUT1RLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP1FbMV06XCJHTVRcIn1pPj4+PTAsYz4+Pj0wLGg+Pj49MDt2YXIgQT1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksaz1uZXcgRGF0ZShBLDAsMSksTj1uZXcgRGF0ZShBLDYsMSk7QT1rLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGFlPU4uZ2V0VGltZXpvbmVPZmZzZXQoKSxlZT1NYXRoLm1heChBLGFlKTtzKClbaT4+Mj4+PjBdPTYwKmVlLG4oKVtjPj4yPj4+MF09KyhBIT1hZSksaT14KGspLGM9eChOKSxpPXcoaSksYz13KGMpLGFlPEE/KHMoKVtoPj4yPj4+MF09aSxzKClbaCs0Pj4yPj4+MF09Yyk6KHMoKVtoPj4yPj4+MF09YyxzKClbaCs0Pj4yPj4+MF09aSl9LGQ6KCk9PntKZShcIlwiKX0sYzpmdW5jdGlvbihpLGMsaCl7cmV0dXJuIGk+Pj49MCxjPV8oYz4+PjAsaD4+PjApLFd0W2ldLmFwcGx5KG51bGwsYyl9LGs6ZnVuY3Rpb24oaSxjLGgpe3JldHVybiBpPj4+PTAsYz1fKGM+Pj4wLGg+Pj4wKSxXdFtpXS5hcHBseShudWxsLGMpfSxtOmZ1bmN0aW9uKCl7fSxqOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LFc6KCk9Pnt0aHJvdyBHZSs9MSxcInVud2luZFwifSxCOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGY6KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCksZzpmdW5jdGlvbigpe3JldHVybiBTPyhJbygpLHZ0KENvKSkuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeX0sTDpmdW5jdGlvbihpLGMsaCx4KXtmb3IobmUuUGI9Yz4+PjAsdWUubGVuZ3RoPWgsYz14Pj4+MD4+Myx4PTA7eDxoO3grKyl1ZVt4XT1sKClbYyt4Pj4+MF07cmV0dXJuKDA+aT9XdFstaS0xXTpUbFtpXSkuYXBwbHkobnVsbCx1ZSl9LHk6ZnVuY3Rpb24oaSl7aT4+Pj0wO3ZhciBjPWEoKS5sZW5ndGg7aWYoaTw9Y3x8NDI5NDkwMTc2MDxpKXJldHVybiExO2Zvcih2YXIgaD0xOzQ+PWg7aCo9Mil7dmFyIHg9YyooMSsuMi9oKTt4PU1hdGgubWluKHgsaSsxMDA2NjMyOTYpO3ZhciBBPU1hdGg7eD1NYXRoLm1heChpLHgpO2U6e0E9QS5taW4uY2FsbChBLDQyOTQ5MDE3NjAseCsoNjU1MzYteCU2NTUzNiklNjU1MzYpLXdlLmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTY7dHJ5e3dlLmdyb3coQSkscGUoKTt2YXIgaz0xO2JyZWFrIGV9Y2F0Y2h7fWs9dm9pZCAwfWlmKGspcmV0dXJuITB9cmV0dXJuITF9LFA6Y2UsUTptZSxIOkp0LGg6RSxvOnRlLHg6ZmUsbjp1cixhOndlfHxvLndhc21NZW1vcnksSjpFYSxlOmZ1bmN0aW9uKGksYyxoLHgpe3JldHVybiBFYShpPj4+MCxjPj4+MCxoPj4+MCx4Pj4+MCl9fTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBpKGgseCl7cmV0dXJuIGg9aC5leHBvcnRzLGg9eGwoaCksaj1oPVBsKGgpLG5lLm1iLnB1c2goai5EYSksT2UudW5zaGlmdChqLlkpLFNlPXgsJHIoKSxofXZhciBjPXthOlJsfTtpZihqdCgpLG8uaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gby5pbnN0YW50aWF0ZVdhc20oYyxpKX1jYXRjaChoKXtxKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIraCksbShoKX1yZXR1cm4geHIoYyxmdW5jdGlvbihoKXtpKGguaW5zdGFuY2UsaC5tb2R1bGUpfSkuY2F0Y2gobSkse319KSgpLG8uX09ydEluaXQ9KGksYyk9PihvLl9PcnRJbml0PWouWikoaSxjKSxvLl9PcnRHZXRMYXN0RXJyb3I9KGksYyk9PihvLl9PcnRHZXRMYXN0RXJyb3I9ai5fKShpLGMpLG8uX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShpLGMsaCx4LEEsayxOLGFlLGVlLFEpPT4oby5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ai4kKShpLGMsaCx4LEEsayxOLGFlLGVlLFEpLG8uX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShpLGMpPT4oby5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ai5hYSkoaSxjKSxvLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KGksYyxoKT0+KG8uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1qLmJhKShpLGMsaCksby5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShpLGMsaCk9PihvLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9ai5jYSkoaSxjLGgpLG8uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1pPT4oby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWouZGEpKGkpLG8uX09ydENyZWF0ZVNlc3Npb249KGksYyxoKT0+KG8uX09ydENyZWF0ZVNlc3Npb249ai5lYSkoaSxjLGgpLG8uX09ydFJlbGVhc2VTZXNzaW9uPWk9PihvLl9PcnRSZWxlYXNlU2Vzc2lvbj1qLmZhKShpKSxvLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShpLGMsaCk9PihvLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PWouZ2EpKGksYyxoKSxvLl9PcnRHZXRJbnB1dE5hbWU9KGksYyk9PihvLl9PcnRHZXRJbnB1dE5hbWU9ai5oYSkoaSxjKSxvLl9PcnRHZXRPdXRwdXROYW1lPShpLGMpPT4oby5fT3J0R2V0T3V0cHV0TmFtZT1qLmlhKShpLGMpLG8uX09ydEZyZWU9aT0+KG8uX09ydEZyZWU9ai5qYSkoaSksby5fT3J0Q3JlYXRlVGVuc29yPShpLGMsaCx4LEEsayk9PihvLl9PcnRDcmVhdGVUZW5zb3I9ai5rYSkoaSxjLGgseCxBLGspLG8uX09ydEdldFRlbnNvckRhdGE9KGksYyxoLHgsQSk9PihvLl9PcnRHZXRUZW5zb3JEYXRhPWoubGEpKGksYyxoLHgsQSksby5fT3J0UmVsZWFzZVRlbnNvcj1pPT4oby5fT3J0UmVsZWFzZVRlbnNvcj1qLm1hKShpKSxvLl9PcnRDcmVhdGVSdW5PcHRpb25zPShpLGMsaCx4KT0+KG8uX09ydENyZWF0ZVJ1bk9wdGlvbnM9ai5uYSkoaSxjLGgseCksby5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGksYyxoKT0+KG8uX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWoub2EpKGksYyxoKSxvLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1pPT4oby5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ai5wYSkoaSksby5fT3J0Q3JlYXRlQmluZGluZz1pPT4oby5fT3J0Q3JlYXRlQmluZGluZz1qLnFhKShpKSxvLl9PcnRCaW5kSW5wdXQ9KGksYyxoKT0+KG8uX09ydEJpbmRJbnB1dD1qLnJhKShpLGMsaCksby5fT3J0QmluZE91dHB1dD0oaSxjLGgseCk9PihvLl9PcnRCaW5kT3V0cHV0PWouc2EpKGksYyxoLHgpLG8uX09ydENsZWFyQm91bmRPdXRwdXRzPWk9PihvLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1qLnRhKShpKSxvLl9PcnRSZWxlYXNlQmluZGluZz1pPT4oby5fT3J0UmVsZWFzZUJpbmRpbmc9ai51YSkoaSksby5fT3J0UnVuV2l0aEJpbmRpbmc9KGksYyxoLHgsQSk9PihvLl9PcnRSdW5XaXRoQmluZGluZz1qLnZhKShpLGMsaCx4LEEpLG8uX09ydFJ1bj0oaSxjLGgseCxBLGssTixhZSk9PihvLl9PcnRSdW49ai53YSkoaSxjLGgseCxBLGssTixhZSksby5fT3J0RW5kUHJvZmlsaW5nPWk9PihvLl9PcnRFbmRQcm9maWxpbmc9ai54YSkoaSksby5fSnNlcE91dHB1dD0oaSxjLGgpPT4oby5fSnNlcE91dHB1dD1qLnlhKShpLGMsaCksby5fSnNlcEdldE5vZGVOYW1lPWk9PihvLl9Kc2VwR2V0Tm9kZU5hbWU9ai56YSkoaSk7dmFyIE1yPW8uX3B0aHJlYWRfc2VsZj0oKT0+KE1yPW8uX3B0aHJlYWRfc2VsZj1qLkFhKSgpLFNuPW8uX21hbGxvYz1pPT4oU249by5fbWFsbG9jPWouQmEpKGkpLFJhPW8uX2ZyZWU9aT0+KFJhPW8uX2ZyZWU9ai5DYSkoaSk7by5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9KCk9PihvLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1qLkRhKSgpO3ZhciBQYT1vLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD0oaSxjLGgseCxBLGspPT4oUGE9by5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9ai5GYSkoaSxjLGgseCxBLGspO28uX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPSgpPT4oby5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9ai5HYSkoKTt2YXIga2E9KGksYyxoLHgpPT4oa2E9ai5IYSkoaSxjLGgseCksQ249aT0+KENuPWouSWEpKGkpLEluPW8uX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWk9PihJbj1vLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1qLkphKShpKSxCYT1vLl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94PSgpPT4oQmE9by5fX2Vtc2NyaXB0ZW5fY2hlY2tfbWFpbGJveD1qLkthKSgpLE1hPWk9PihNYT1qLkxhKShpKSxEYT0oaSxjKT0+KERhPWouTWEpKGksYyksQW49KCk9PihBbj1qLk5hKSgpLERyPWk9PihEcj1qLk9hKShpKSxFbj1pPT4oRW49ai5QYSkoaSksemE9by5keW5DYWxsX2lpPShpLGMpPT4oemE9by5keW5DYWxsX2lpPWouUmEpKGksYyksV2E9aT0+KFdhPWouU2EpKGkpLE5hPSgpPT4oTmE9ai5UYSkoKSxWYT1pPT4oVmE9ai5VYSkoaSksVWE9KCk9PihVYT1qLlZhKSgpO28uX19fc3RhcnRfZW1fanM9OTI1NzgzLG8uX19fc3RvcF9lbV9qcz05MjU5NDQ7ZnVuY3Rpb24gUGwoaSl7aT1PYmplY3QuYXNzaWduKHt9LGkpO3ZhciBjPXg9PigpPT54KCk+Pj4wLGg9eD0+QT0+eChBKT4+PjA7cmV0dXJuIGkuX19lcnJub19sb2NhdGlvbj1jKGkuX19lcnJub19sb2NhdGlvbiksaS5wdGhyZWFkX3NlbGY9YyhpLnB0aHJlYWRfc2VsZiksaS5tYWxsb2M9aChpLm1hbGxvYyksaS5zdGFja1NhdmU9YyhpLnN0YWNrU2F2ZSksaS5zdGFja0FsbG9jPWgoaS5zdGFja0FsbG9jKSxpfW8ua2VlcFJ1bnRpbWVBbGl2ZT1ldCxvLndhc21NZW1vcnk9d2Usby5zdGFja0FsbG9jPUVuLG8uc3RhY2tTYXZlPUFuLG8uc3RhY2tSZXN0b3JlPURyLG8uVVRGOFRvU3RyaW5nPVZlLG8uc3RyaW5nVG9VVEY4PV9yLG8ubGVuZ3RoQnl0ZXNVVEY4PU90LG8uRXhpdFN0YXR1cz15dCxvLlBUaHJlYWQ9bmU7dmFyIHpyO0V0PWZ1bmN0aW9uIGkoKXt6cnx8R2EoKSx6cnx8KEV0PWkpfTtmdW5jdGlvbiBHYSgpe2Z1bmN0aW9uIGkoKXtpZighenImJih6cj0hMCxvLmNhbGxlZFJ1bj0hMCwhVGUpJiYoSXx8Y3QoT2UpLHAobyksby5vblJ1bnRpbWVJbml0aWFsaXplZCYmby5vblJ1bnRpbWVJbml0aWFsaXplZCgpLCFJKSl7aWYoby5wb3N0UnVuKWZvcih0eXBlb2Ygby5wb3N0UnVuPT1cImZ1bmN0aW9uXCImJihvLnBvc3RSdW49W28ucG9zdFJ1bl0pO28ucG9zdFJ1bi5sZW5ndGg7KXt2YXIgYz1vLnBvc3RSdW4uc2hpZnQoKTt6ZS51bnNoaWZ0KGMpfWN0KHplKX19aWYoISgwPEtlKSlpZihJKXAobyksSXx8Y3QoT2UpLHN0YXJ0V29ya2VyKG8pO2Vsc2V7aWYoby5wcmVSdW4pZm9yKHR5cGVvZiBvLnByZVJ1bj09XCJmdW5jdGlvblwiJiYoby5wcmVSdW49W28ucHJlUnVuXSk7by5wcmVSdW4ubGVuZ3RoOylIZS51bnNoaWZ0KG8ucHJlUnVuLnNoaWZ0KCkpO2N0KEhlKSwwPEtlfHwoby5zZXRTdGF0dXM/KG8uc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe28uc2V0U3RhdHVzKFwiXCIpfSwxKSxpKCl9LDEpKTppKCkpfX1pZihvLnByZUluaXQpZm9yKHR5cGVvZiBvLnByZUluaXQ9PVwiZnVuY3Rpb25cIiYmKG8ucHJlSW5pdD1bby5wcmVJbml0XSk7MDxvLnByZUluaXQubGVuZ3RoOylvLnByZUluaXQucG9wKCkoKTtyZXR1cm4gR2EoKSx0LnJlYWR5fX0pKCk7dHlwZW9mIEVvPT1cIm9iamVjdFwiJiZ0eXBlb2Ygem49PVwib2JqZWN0XCI/em4uZXhwb3J0cz1Bbzp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQmJmRlZmluZShbXSwoKT0+QW8pfSk7dmFyIE9vPUx0KChnZixVbCk9PntVbC5leHBvcnRzPSdcInVzZSBzdHJpY3RcIjt2YXIgTW9kdWxlPXt9LEVOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBub2RlV29ya2VyVGhyZWFkcz1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIikscGFyZW50UG9ydD1ub2RlV29ya2VyVGhyZWFkcy5wYXJlbnRQb3J0O3BhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsZT0+b25tZXNzYWdlKHtkYXRhOmV9KSk7dmFyIGZzPXJlcXVpcmUoXCJmc1wiKTtPYmplY3QuYXNzaWduKGdsb2JhbCx7c2VsZjpnbG9iYWwscmVxdWlyZSxNb2R1bGUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOm5vZGVXb3JrZXJUaHJlYWRzLldvcmtlcixpbXBvcnRTY3JpcHRzOmU9PigwLGV2YWwpKGZzLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKStcIi8vIyBzb3VyY2VVUkw9XCIrZSkscG9zdE1lc3NhZ2U6ZT0+cGFyZW50UG9ydC5wb3N0TWVzc2FnZShlKSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6RGF0ZS5ub3d9fSl9dmFyIGluaXRpYWxpemVkSlM9ITE7ZnVuY3Rpb24gdGhyZWFkUHJpbnRFcnIoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO2lmKEVOVklST05NRU5UX0lTX05PREUpe2ZzLndyaXRlU3luYygyLGUrYFxcbmApO3JldHVybn1jb25zb2xlLmVycm9yKGUpfWZ1bmN0aW9uIHRocmVhZEFsZXJ0KCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OmUsdGhyZWFkSWQ6TW9kdWxlLl9wdGhyZWFkX3NlbGYoKX0pfXZhciBlcnI9dGhyZWFkUHJpbnRFcnI7c2VsZi5hbGVydD10aHJlYWRBbGVydCxNb2R1bGUuaW5zdGFudGlhdGVXYXNtPShlLHQpPT57dmFyIGE9TW9kdWxlLndhc21Nb2R1bGU7TW9kdWxlLndhc21Nb2R1bGU9bnVsbDt2YXIgcj1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoYSxlKTtyZXR1cm4gdChyKX0sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9O2Z1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZSl7dHJ5e2lmKGUuZGF0YS5jbWQ9PT1cImxvYWRcIil7bGV0IGE9W107c2VsZi5vbm1lc3NhZ2U9cj0+YS5wdXNoKHIpLHNlbGYuc3RhcnRXb3JrZXI9cj0+e01vZHVsZT1yLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2ZvcihsZXQgcyBvZiBhKWhhbmRsZU1lc3NhZ2Uocyk7c2VsZi5vbm1lc3NhZ2U9aGFuZGxlTWVzc2FnZX0sTW9kdWxlLndhc21Nb2R1bGU9ZS5kYXRhLndhc21Nb2R1bGU7Zm9yKGNvbnN0IHIgb2YgZS5kYXRhLmhhbmRsZXJzKU1vZHVsZVtyXT0oLi4ucyk9Pntwb3N0TWVzc2FnZSh7Y21kOlwiY2FsbEhhbmRsZXJcIixoYW5kbGVyOnIsYXJnczpzfSl9O2lmKE1vZHVsZS53YXNtTWVtb3J5PWUuZGF0YS53YXNtTWVtb3J5LE1vZHVsZS5idWZmZXI9TW9kdWxlLndhc21NZW1vcnkuYnVmZmVyLE1vZHVsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLHR5cGVvZiBlLmRhdGEudXJsT3JCbG9iPT1cInN0cmluZ1wiKWltcG9ydFNjcmlwdHMoZS5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgdD1VUkwuY3JlYXRlT2JqZWN0VVJMKGUuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHModCksVVJMLnJldm9rZU9iamVjdFVSTCh0KX1vcnRXYXNtVGhyZWFkZWQoTW9kdWxlKX1lbHNlIGlmKGUuZGF0YS5jbWQ9PT1cInJ1blwiKXtNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0KGUuZGF0YS5wdGhyZWFkX3B0ciwwLDAsMSksTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdChlLmRhdGEucHRocmVhZF9wdHIpLE1vZHVsZS5lc3RhYmxpc2hTdGFja1NwYWNlKCksTW9kdWxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKGUuZGF0YSksTW9kdWxlLlBUaHJlYWQudGhyZWFkSW5pdFRMUygpLGluaXRpYWxpemVkSlN8fChpbml0aWFsaXplZEpTPSEwKTt0cnl7TW9kdWxlLmludm9rZUVudHJ5UG9pbnQoZS5kYXRhLnN0YXJ0X3JvdXRpbmUsZS5kYXRhLmFyZyl9Y2F0Y2goYSl7aWYoYSE9XCJ1bndpbmRcIil0aHJvdyBhfX1lbHNlIGUuZGF0YS5jbWQ9PT1cImNhbmNlbFwiP01vZHVsZS5fcHRocmVhZF9zZWxmKCkmJk1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOmUuZGF0YS50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwifHwoZS5kYXRhLmNtZD09PVwiY2hlY2tNYWlsYm94XCI/aW5pdGlhbGl6ZWRKUyYmTW9kdWxlLmNoZWNrTWFpbGJveCgpOmUuZGF0YS5jbWQmJihlcnIoXCJ3b3JrZXIuanMgcmVjZWl2ZWQgdW5rbm93biBjb21tYW5kIFwiK2UuZGF0YS5jbWQpLGVycihlLmRhdGEpKSl9Y2F0Y2goYSl7dGhyb3cgTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCgpLGF9fXNlbGYub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2U7XFxuJ30pO3ZhciBSbyxHbCxXbixObixqcixUbyxGbCxMbCxIbCxQbyxQZSxIdD1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Um89JG8oKTtHbD1fbygpLE5uPSExLGpyPSExLFRvPSExLEZsPSgpPT57dHJ5e3JldHVybiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCI/ITE6KHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaHtyZXR1cm4hMX19LExsPSgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LEhsPShlLHQpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXNpbWQud2FzbVwiOnQ/XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCIsUG89YXN5bmMgZT0+e2lmKE5uKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihqcil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihUbyl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtqcj0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LHI9ZS5udW1UaHJlYWRzLGE9ZS5zaW1kLG49cj4xJiZGbCgpLHM9YSYmTGwoKSx1PWUud2FzbVBhdGhzLGw9dHlwZW9mIHU9PVwic3RyaW5nXCI/dTp2b2lkIDAsbz1IbChzLG4pLHA9dHlwZW9mIHU9PVwib2JqZWN0XCI/dVtvXTp2b2lkIDAsbT0hMSx5PVtdO2lmKHQ+MCYmeS5wdXNoKG5ldyBQcm9taXNlKGc9PntzZXRUaW1lb3V0KCgpPT57bT0hMCxnKCl9LHQpfSkpLHkucHVzaChuZXcgUHJvbWlzZSgoZyx2KT0+e2xldCAkPW4/R2w6Um8sYj17bG9jYXRlRmlsZTooUyxJKT0+e2lmKG4mJlMuZW5kc1dpdGgoXCIud29ya2VyLmpzXCIpJiZ0eXBlb2YgQmxvYjxcInVcIilyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbT28oKV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTtpZihTLmVuZHNXaXRoKFwiLndhc21cIikpe2lmKHApcmV0dXJuIHA7bGV0IFQ9bD8/STtyZXR1cm4gbz09PVwib3J0LXdhc20tc2ltZC53YXNtXCI/VCtcIm9ydC13YXNtLXNpbWQuanNlcC53YXNtXCI6bz09PVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI/VCtcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6VCtvfXJldHVybiBJK1N9fTtpZihuKWlmKHR5cGVvZiBCbG9iPlwidVwiKWIubWFpblNjcmlwdFVybE9yQmxvYj0odm9pZCAwKShfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2xldCBTPWB2YXIgb3J0V2FzbVRocmVhZGVkPSR7JC50b1N0cmluZygpfTtgO2IubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbU10se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfSQoYikudGhlbihTPT57anI9ITEsTm49ITAsV249UyxnKCl9LFM9Pntqcj0hMSxUbz0hMCx2KFMpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKHkpLG0pdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxQZT0oKT0+e2lmKE5uJiZXbilyZXR1cm4gV247dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9fSk7dmFyIE1lLGRyLEFlLHFyPUwoKCk9PntcInVzZSBzdHJpY3RcIjtIdCgpO01lPShlLHQpPT57bGV0IHI9UGUoKSxhPXIubGVuZ3RoQnl0ZXNVVEY4KGUpKzEsbj1yLl9tYWxsb2MoYSk7cmV0dXJuIHIuc3RyaW5nVG9VVEY4KGUsbixhKSx0LnB1c2gobiksbn0sZHI9KGUsdCxyLGEpPT57aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXtpZihyLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtyLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbbixzXSk9PntsZXQgdT10P3QrbjpuO2lmKHR5cGVvZiBzPT1cIm9iamVjdFwiKWRyKHMsdStcIi5cIixyLGEpO2Vsc2UgaWYodHlwZW9mIHM9PVwic3RyaW5nXCJ8fHR5cGVvZiBzPT1cIm51bWJlclwiKWEodSxzLnRvU3RyaW5nKCkpO2Vsc2UgaWYodHlwZW9mIHM9PVwiYm9vbGVhblwiKWEodSxzP1wiMVwiOlwiMFwiKTtlbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiBzfWApfSl9LEFlPWU9PntsZXQgdD1QZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IGE9dC5zdGFja0FsbG9jKDgpO3QuX09ydEdldExhc3RFcnJvcihhLGErNCk7bGV0IG49dC5IRUFQMzJbYS80XSxzPXQuSEVBUFUzMlthLzQrMV0sdT1zP3QuVVRGOFRvU3RyaW5nKHMpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7bn0sIEVSUk9SX01FU1NBR0U6ICR7dX1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX19KTt2YXIga28sQm89TCgoKT0+e1widXNlIHN0cmljdFwiO0h0KCk7cXIoKTtrbz1lPT57bGV0IHQ9UGUoKSxyPTAsYT1bXSxuPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKW4ubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKW4ubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYobi50ZXJtaW5hdGU9ITEpO2xldCBzPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKHM9TWUoZS50YWcsYSkpLHI9dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhuLmxvZ1NldmVyaXR5TGV2ZWwsbi5sb2dWZXJib3NpdHlMZXZlbCwhIW4udGVybWluYXRlLHMpLHI9PT0wJiZBZShcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksZT8uZXh0cmEhPT12b2lkIDAmJmRyKGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwodSxsKT0+e2xldCBvPU1lKHUsYSkscD1NZShsLGEpO3QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHIsbyxwKSE9PTAmJkFlKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke3V9IC0gJHtsfS5gKX0pLFtyLGFdfWNhdGNoKHMpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhyKSxhLmZvckVhY2godT0+dC5fZnJlZSh1KSksc319fSk7dmFyIGpsLHFsLEtsLFlsLE1vLERvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtIdCgpO3FyKCk7amw9ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0scWw9ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LEtsPWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShyPT4odHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSxZbD0oZSx0LHIpPT57Zm9yKGxldCBhIG9mIHQpe2xldCBuPXR5cGVvZiBhPT1cInN0cmluZ1wiP2E6YS5uYW1lO3N3aXRjaChuKXtjYXNlXCJ4bm5wYWNrXCI6bj1cIlhOTlBBQ0tcIjticmVhaztjYXNlXCJ3ZWJublwiOmlmKG49XCJXRUJOTlwiLHR5cGVvZiBhIT1cInN0cmluZ1wiKXtsZXQgdT1hO2lmKHU/LmRldmljZVR5cGUpe2xldCBsPU1lKFwiZGV2aWNlVHlwZVwiLHIpLG89TWUodS5kZXZpY2VUeXBlLHIpO1BlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGwsbykhPT0wJiZBZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7dS5kZXZpY2VUeXBlfS5gKX1pZih1Py5wb3dlclByZWZlcmVuY2Upe2xldCBsPU1lKFwicG93ZXJQcmVmZXJlbmNlXCIsciksbz1NZSh1LnBvd2VyUHJlZmVyZW5jZSxyKTtQZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxsLG8pIT09MCYmQWUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncG93ZXJQcmVmZXJlbmNlJyAtICR7dS5wb3dlclByZWZlcmVuY2V9LmApfX1icmVhaztjYXNlXCJ3ZWJncHVcIjppZihuPVwiSlNcIix0eXBlb2YgYSE9XCJzdHJpbmdcIil7bGV0IHU9YTtpZih1Py5wcmVmZXJyZWRMYXlvdXQpe2lmKHUucHJlZmVycmVkTGF5b3V0IT09XCJOQ0hXXCImJnUucHJlZmVycmVkTGF5b3V0IT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHt1LnByZWZlcnJlZExheW91dH1gKTtsZXQgbD1NZShcInByZWZlcnJlZExheW91dFwiLHIpLG89TWUodS5wcmVmZXJyZWRMYXlvdXQscik7UGUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsbCxvKSE9PTAmJkFlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke3UucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtufWApfWxldCBzPU1lKG4scik7UGUoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxzKSE9PTAmJkFlKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke259LmApfX0sTW89ZT0+e2xldCB0PVBlKCkscj0wLGE9W10sbj1lfHx7fTtLbChuKTt0cnl7bGV0IHM9amwobi5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSx1PXFsKG4uZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGw9dHlwZW9mIG4ubG9nSWQ9PVwic3RyaW5nXCI/TWUobi5sb2dJZCxhKTowLG89bi5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG8pfHxvPDB8fG8+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke299YCk7bGV0IHA9bi5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwfHxwPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtwfWApO2xldCBtPXR5cGVvZiBuLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/TWUobi5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLGEpOjA7aWYocj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhzLCEhbi5lbmFibGVDcHVNZW1BcmVuYSwhIW4uZW5hYmxlTWVtUGF0dGVybix1LCEhbi5lbmFibGVQcm9maWxpbmcsMCxsLG8scCxtKSxyPT09MCYmQWUoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxuLmV4ZWN1dGlvblByb3ZpZGVycyYmWWwocixuLmV4ZWN1dGlvblByb3ZpZGVycyxhKSxuLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpZm9yKGxldFt5LGddb2YgT2JqZWN0LmVudHJpZXMobi5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSl7aWYodHlwZW9mIHkhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7eX1gKTtpZih0eXBlb2YgZyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZyl8fGc8MCl0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHtnfWApO2xldCB2PU1lKHksYSk7dC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKHIsdixnKSE9PTAmJkFlKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHt5fSAtICR7Z30uYCl9cmV0dXJuIG4uZXh0cmEhPT12b2lkIDAmJmRyKG4uZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoeSxnKT0+e2xldCB2PU1lKHksYSksJD1NZShnLGEpO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShyLHYsJCkhPT0wJiZBZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7eX0gLSAke2d9LmApfSksW3IsYV19Y2F0Y2gocyl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhyKSxhLmZvckVhY2godT0+dC5fZnJlZSh1KSksc319fSk7dmFyIFZuLGNyLHByLEtyLGZyLFlyLFVuLERlPUwoKCk9PntcInVzZSBzdHJpY3RcIjtWbj1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gMTA7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sY3I9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHByPWU9Plt2b2lkIDAsNCwxLDEsMiwyLDQsOCx2b2lkIDAsMSwyLDgsNCw4LHZvaWQgMCx2b2lkIDAsdm9pZCAwXVtlXSxLcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJ1aW50NjRcIjpyZXR1cm4gQmlnVWludDY0QXJyYXk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7ZX1gKX19LGZyPWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fSxZcj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJ1aW50MzJcIixVbj1lPT57c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm4gMDtjYXNlXCJjcHVcIjpyZXR1cm4gMTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIDI7Y2FzZVwidGV4dHVyZVwiOnJldHVybiAzO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtlfWApfX19KTt2YXIgWGwsSmwsem8sV28sTm8sUWwsX2UseHQ9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7WGw9W1wiVlwiLFwiSVwiLFwiV1wiLFwiRVwiLFwiRlwiXSxKbD0oZSx0KT0+e2NvbnNvbGUubG9nKGBbJHtYbFtlXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7dH1gKX0sTm89KGUsdCk9Pnt6bz1lLFdvPXR9LFFsPShlLHQpPT57bGV0IHI9ZnIoZSksYT1mcih6byk7cj49YSYmSmwocix0eXBlb2YgdD09XCJmdW5jdGlvblwiP3QoKTp0KX0sX2U9KC4uLmUpPT57V28mJlFsKC4uLmUpfX0pO3ZhciBWbyxVbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtWbz0oZSx0KT0+bmV3KEtyKHQpKShlKX0pO3ZhciBHbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgWHIsWmwsRm8sRm4sR24sTG8sSG89TCgoKT0+e1widXNlIHN0cmljdFwiO3h0KCk7R28oKTtYcj1lPT5NYXRoLmNlaWwoZS8xNikqMTYsWmw9MSxGbz0oKT0+WmwrKyxGbj1hc3luYyhlLHQscixhKT0+e2xldCBuPVhyKHIpLHM9ZS5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR9KTt0cnl7bGV0IHU9ZS5nZXRDb21tYW5kRW5jb2RlcigpO2UuZW5kQ29tcHV0ZVBhc3MoKSx1LmNvcHlCdWZmZXJUb0J1ZmZlcih0LDAscywwLG4pLGUuZmx1c2goKSxhd2FpdCBzLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7bGV0IGw9cy5nZXRNYXBwZWRSYW5nZSgpO2lmKGEpe2xldCBvPWEoKTtyZXR1cm4gby5zZXQobmV3IFVpbnQ4QXJyYXkobCwwLHIpKSxvfWVsc2UgcmV0dXJuIG5ldyBVaW50OEFycmF5KGwuc2xpY2UoMCxyKSl9ZmluYWxseXtzLmRlc3Ryb3koKX19LEduPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZz1bXSx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuZXh0ZXJuYWxCdWZmZXJzPW5ldyBNYXB9dXBsb2FkKHQscil7bGV0IGE9ci5idWZmZXIsbj1yLmJ5dGVPZmZzZXQscz1yLmJ5dGVMZW5ndGgsdT1YcihzKSxsPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighbCl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKGwub3JpZ2luYWxTaXplIT09cyl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtsLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke3N9YCk7bGV0IG89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTp1LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLHA9by5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KHApLnNldChuZXcgVWludDhBcnJheShhLG4scykpLG8udW5tYXAoKTtsZXQgbT10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxtLmNvcHlCdWZmZXJUb0J1ZmZlcihvLDAsbC5ncHVEYXRhLmJ1ZmZlciwwLHUpLF9lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7dH0pYCksdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZy5wdXNoKG8pfW1lbWNweSh0LHIpe2xldCBhPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtsZXQgbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQocik7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtpZihhLm9yaWdpbmFsU2l6ZSE9PW4ub3JpZ2luYWxTaXplKXRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemVcIik7bGV0IHM9WHIoYS5vcmlnaW5hbFNpemUpLHU9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksdS5jb3B5QnVmZmVyVG9CdWZmZXIoYS5ncHVEYXRhLmJ1ZmZlciwwLG4uZ3B1RGF0YS5idWZmZXIsMCxzKX1yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQscixhKXtsZXQgbjtpZihhKXtpZihuPXRoaXMuZXh0ZXJuYWxCdWZmZXJzLmdldChhKSxuPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGJ1ZmZlciBpcyBub3QgcmVnaXN0ZXJlZFwiKTtpZih0PT09YSlyZXR1cm4gX2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtufSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLG47dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKGEpfWVsc2Ugbj1GbygpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobix7Z3B1RGF0YTp7aWQ6bix0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpyfSksdGhpcy5leHRlcm5hbEJ1ZmZlcnMuc2V0KHQsbiksX2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtufSwgcmVnaXN0ZXJlZC5gKSxufXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXtsZXQgcj10aGlzLmV4dGVybmFsQnVmZmVycy5nZXQodCk7ciE9PXZvaWQgMCYmKHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShyKSx0aGlzLmV4dGVybmFsQnVmZmVycy5kZWxldGUodCksX2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke3J9YCkpfWNyZWF0ZSh0LHI9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7bGV0IGE9WHIodCksbixzPShyJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSx1PShyJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtpZihzfHx1KXtsZXQgbz1zP3RoaXMuZnJlZUJ1ZmZlcnM6dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMscD1vLmdldChhKTtwfHwocD1bXSxvLnNldChhLHApKSxwLmxlbmd0aD4wP249cC5wb3AoKTpuPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOmEsdXNhZ2U6cn0pfWVsc2Ugbj10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTphLHVzYWdlOnJ9KTtsZXQgbD17aWQ6Rm8oKSx0eXBlOjAsYnVmZmVyOm59O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobC5pZCx7Z3B1RGF0YTpsLG9yaWdpbmFsU2l6ZTp0fSksX2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3R9KSA9PiBpZD0ke2wuaWR9YCksbH1nZXQodCl7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KT8uZ3B1RGF0YX1yZWxlYXNlKHQpe2xldCByPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdFwiKTtyZXR1cm4gX2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7dH0pLCBncHVEYXRhSWQ9JHtyLmdwdURhdGEuaWR9YCksdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaChyLmdwdURhdGEuYnVmZmVyKSxyLm9yaWdpbmFsU2l6ZX1hc3luYyBkb3dubG9hZCh0LHIpe2xldCBhPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2F3YWl0IEZuKHRoaXMuYmFja2VuZCxhLmdwdURhdGEuYnVmZmVyLGEub3JpZ2luYWxTaXplLHIpfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nKXQuZGVzdHJveSgpO3RoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc9W107Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFP3RoaXMuZnJlZUJ1ZmZlcnMuZ2V0KHQuc2l6ZSkucHVzaCh0KToodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0/dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KHQuc2l6ZSkucHVzaCh0KTp0LmRlc3Ryb3koKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfWRpc3Bvc2UoKXt0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2godD0+e3QuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcH19LExvPSguLi5lKT0+bmV3IEduKC4uLmUpfSk7dmFyIExuLGllLGtlPUwoKCk9PntcInVzZSBzdHJpY3RcIjtMbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLl9jYWNoZUtleX19LGllPWU9Pm5ldyBMbihlKX0pO3ZhciBIbixudCx6LE10LEpyLFFyLFpyLGdlPUwoKCk9PntcInVzZSBzdHJpY3RcIjtIbj1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQscil7cmV0dXJuIHRbMV0hPT1yWzBdP3ZvaWQgMDpbdFswXSxyWzFdXX19LG50PWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxyLGE9ITEpe2xldCBuPXQubGVuZ3RoLHM9ci5sZW5ndGg7aWYobj09PTApcmV0dXJuIHI7aWYocz09PTApcmV0dXJuIHQ7bGV0IHU9TWF0aC5tYXgodC5sZW5ndGgsci5sZW5ndGgpLGw9bmV3IEFycmF5KHUpO2lmKGEpe2lmKG48Mnx8czwyKXJldHVybjtsZXQgbz1Ibi5jYWxjTWF0TXVsU2hhcGUoW3Rbbi0yXSx0W24tMV1dLFtyW3MtMl0scltzLTFdXSk7aWYobz09PXZvaWQgMClyZXR1cm47W2xbdS0yXSxsW3UtMV1dPW99Zm9yKGxldCBvPWE/MzoxO288PXU7bysrKXtsZXQgcD1uLW88MD8xOnRbbi1vXSxtPXMtbzwwPzE6cltzLW9dO2lmKHAhPT1tJiZwPjEmJm0+MSlyZXR1cm47bFt1LW9dPU1hdGgubWF4KHAsbSl9cmV0dXJuIGx9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxyKXtsZXQgYT10Lmxlbmd0aCxuPXIubGVuZ3RoO2lmKGE+bilyZXR1cm4hMTtmb3IobGV0IHM9MTtzPD1hO3MrKylpZih0W2Etc10hPT0xJiZ0W2Etc10hPT1yW24tc10pcmV0dXJuITE7cmV0dXJuITB9fSx6PWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscix0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAscil9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLGEpe2xldCBuPTE7Zm9yKGxldCBzPXI7czxhO3MrKyl7aWYodFtzXTwwKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7bio9dFtzXX1yZXR1cm4gbn1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IHI9dC5sZW5ndGg7aWYocj09PTApcmV0dXJuW107aWYocj09PTEpcmV0dXJuWzFdO2xldCBhPW5ldyBBcnJheShyKTthW3ItMV09MSxhW3ItMl09dFtyLTFdO2ZvcihsZXQgbj1yLTM7bj49MDstLW4pYVtuXT1hW24rMV0qdFtuKzFdO3JldHVybiBhfXN0YXRpYyBub3JtYWxpemVBeGlzKHQscil7aWYodDwtciYmdD49cil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K3I6dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LHIpe3JldHVybiB0Lm1hcChhPT50aGlzLm5vcm1hbGl6ZUF4aXMoYSxyPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxyKXtyZXR1cm4gcj9yLm1hcChhPT50W2FdKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LHIpe2xldCBhPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgobixzKT0+bityW3NdK3JbcythXSl9c3RhdGljIGFyZUVxdWFsKHQscil7cmV0dXJuIHQubGVuZ3RoIT09ci5sZW5ndGg/ITE6dC5ldmVyeSgoYSxuKT0+YT09PXJbbl0pfX0sTXQ9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxyLGEsbixzLHUpe2lmKCF0JiZhLmxlbmd0aCE9PXIubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgbD0wO2w8ci5sZW5ndGgtMjtsKyspbD49YS5sZW5ndGg/YS5wdXNoKHJbbCsyXSk6YVtsXT1yW2wrMl07Zm9yKGxldCBsPTA7bDxhLmxlbmd0aDtsKyspaWYobDxuLmxlbmd0aCl7aWYobltsXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugbi5wdXNoKDEpO2ZvcihsZXQgbD0wO2w8YS5sZW5ndGg7bCsrKWlmKGw8cy5sZW5ndGgpe2lmKHNbbF08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugcy5wdXNoKDEpO2ZvcihsZXQgbD0wO2w8YS5sZW5ndGgqMjtsKyspaWYobDx1Lmxlbmd0aCl7aWYodVtsXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSB1LnB1c2goMCk7Zm9yKGxldCBsPTA7bDxhLmxlbmd0aDtsKyspe2lmKGFbbF08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKHVbbF0+PWFbbF18fHVbbCthLmxlbmd0aF0+PWFbbF0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LHIsYSxuLHMsdSxsKXtpZihsKXtpZihzLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG4ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aC0yO28rKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbbysodT8xOjIpXSxyW29dLGFbb10sbltvXSxzLG8sbyt0Lmxlbmd0aC0yLGwpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LHIsYSxuLHMsdSxsKXtpZihyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IG89W3JbMF0sclsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQscixvLGEsbixzLHUsbCksb31zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LHIsYSxuLHMsdSxsKXtpZih0Lmxlbmd0aDw9MHx8ci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgbz1bdFswXSxyWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxvLGEsbixzLHUsbCksb31zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQscixhLG4scyx1LGwsbyl7aWYodClmb3IobGV0IHA9MDtwPHIubGVuZ3RoLTI7cCsrKWEucHVzaCgxKTtlbHNlIGZvcihsZXQgcD0wO3A8ci5sZW5ndGgtMjtwKyspYS5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUocltwKzJdLG5bcF0sc1twXSx1W3BdLGwscCxwK3IubGVuZ3RoLTIsbykpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LHIsYSxuLHMsdSxsLG8pe2xldCBwPWEqKG4tMSkrMTtpZihvJiZvIT09XCJOT1RTRVRcIilzd2l0Y2gobyl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gc1t1XT0wLHNbbF09MCxNYXRoLmZsb29yKCh0LXApL3IrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihhIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCB5PSgodCtyLTEpL3ItMSkqcituLXQ7cmV0dXJuIHNbdV09TWF0aC5mbG9vcihvPT09XCJTQU1FX0xPV0VSXCI/KHkrMSkvMjp5LzIpLHNbbF09eS1zW3VdLE1hdGguZmxvb3IoKHQreS1uKS9yKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQrc1t1XStzW2xdLXApL3IrMSl9fSxKcj1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxyLGEsbixzKXtpZih0Lmxlbmd0aCE9PTJ8fGEubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgdSxsLG87cj8odT10WzFdLGw9dFswXSk6KHU9dFswXSxsPXRbMV0pO2xldCBwPS0xO2lmKG4/KG89YVswXSxwPTEpOihvPWFbMV0scD0wKSxhW3BdIT09bCl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYodTw9MHx8bzw9MHx8bDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihzJiYhbnQuaXNWYWxpZEJyb2FkY2FzdChzLFt1LG9dKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bdSxvLGxdfX0sUXI9LTM0MDI4MjM0NjYzODUyODg2ZTIyLFpyPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIGVkLGpvLEJlLHFuLG10LFFlLER0LFN0LHFvLEYsWCxqbixLbyxLbixZbyx2ZT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO2VkPTY0LGpvPShlLHQpPT57aWYodD09PTMpdGhyb3cgbmV3IEVycm9yKFwidmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZFwiKTtzd2l0Y2goZSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHtlfWApfX0sQmU9KGUsdD0xKT0+e2xldCByPWpvKGUsdCk7cmV0dXJuIHR5cGVvZiByPT1cInN0cmluZ1wiP3I6clswXX0scW49ZT0+W3t0eXBlOlwidWludDMyXCIsZGF0YTplfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6ei5jb21wdXRlU3RyaWRlcyhlKX1dLG10PWU9PmUlND09PTA/NDplJTI9PT0wPzI6MSxRZT0oZT1cImYzMlwiLHQscj1cIjBcIik9PiF0fHx0PT09MT9gJHtlfSgke3J9KWA6YHZlYyR7dH08JHtlfT4oJHtyfSlgLER0PShlLHQscik9PmU9PT1cImYzMlwiP3I6dD09PTE/YGYzMigke3J9KWA6YHZlYyR7dH1mKCR7cn0pYCxTdD0oZSx0KT0+dD09PTQ/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnogKyAke2V9LncpYDp0PT09Mj9gKCR7ZX0ueCArICR7ZX0ueSlgOnQ9PT0zP2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56KWA6ZSxxbz0oZSx0LHIsYSxuKT0+e2xldCBzPXR5cGVvZiByPT1cIm51bWJlclwiLHU9cz9yOnIubGVuZ3RoLGw9Wy4uLm5ldyBBcnJheSh1KS5rZXlzKCldLG89dTwyP1widTMyXCI6dTw9ND9gdmVjJHt1fTx1MzI+YDpgYXJyYXk8dTMyLCAke3V9PmAscD1qbyh0LG4pLG09dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzFdLHk9dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzBdLGc9e2luZGljZXM6byx2YWx1ZTptLHN0b3JhZ2U6eSx0ZW5zb3I6dH0sdj1VPT50eXBlb2YgVT09XCJzdHJpbmdcIj9VOmAke1V9dWAsJD17b2Zmc2V0VG9JbmRpY2VzOiExLGluZGljZXNUb09mZnNldDohMSxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDohMSxzZXQ6ITEsc2V0QnlJbmRpY2VzOiExLGdldDohMSxnZXRCeUluZGljZXM6ITF9LGI9cz9cInVuaWZvcm1zLlwiOlwiXCIsUz1gJHtifSR7ZX1fc2hhcGVgLEk9YCR7Yn0ke2V9X3N0cmlkZXNgLFQ9XCJcIjtmb3IobGV0IFU9MDtVPHUtMTtVKyspVCs9YFxuICAgIGxldCBkaW0ke1V9ID0gY3VycmVudCAvICR7SX1bJHtVfV07XG4gICAgbGV0IHJlc3Qke1V9ID0gY3VycmVudCAlICR7SX1bJHtVfV07XG4gICAgaW5kaWNlc1ske1V9XSA9IGRpbSR7VX07XG4gICAgY3VycmVudCA9IHJlc3Qke1V9O1xuICAgIGA7VCs9YGluZGljZXNbJHt1LTF9XSA9IGN1cnJlbnQ7YDtsZXQgQj11PDI/XCJcIjpgXG4gIGZuIG8yaV8ke2V9KG9mZnNldDogdTMyKSAtPiAke2cuaW5kaWNlc30ge1xuICAgIHZhciBpbmRpY2VzOiAke2cuaW5kaWNlc307XG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XG4gICAgJHtUfVxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9YCxQPVU9PigkLm9mZnNldFRvSW5kaWNlcz0hMCx1PDI/VTpgbzJpXyR7ZX0oJHtVfSlgKSxEPVtdO2lmKHU+PTIpZm9yKGxldCBVPXUtMTtVPj0wO1UtLSlELnB1c2goYCR7SX1bJHtVfV0gKiAoaW5kaWNlc1ske1V9XSlgKTtsZXQgUj11PDI/XCJcIjpgXG4gIGZuIGkyb18ke2V9KGluZGljZXM6ICR7Zy5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtELmpvaW4oXCIrXCIpfTtcbiAgfWAsVz1VPT4oJC5pbmRpY2VzVG9PZmZzZXQ9ITAsdTwyP1U6YGkyb18ke2V9KCR7VX0pYCksSD0oLi4uVSk9PnU9PT0wP1wiMHVcIjpgJHtnLmluZGljZXN9KCR7VS5tYXAodikuam9pbihcIixcIil9KWAsSz0oVSxkZSk9PnU8Mj9gJHtVfWA6YCR7VX1bJHtkZX1dYCxsZT0oVSxkZSxwZSk9PnU8Mj9gJHtVfT0ke3BlfTtgOmAke1V9WyR7ZGV9XT0ke3BlfTtgLE09e30scT0oVSxkZSk9PnskLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0PSEwO2xldCBwZT1gJHtkZS5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtlfU9mZnNldGA7aWYocGUgaW4gTSlyZXR1cm5gJHtwZX0oJHtVfSlgO2xldCBOZT1bXTtmb3IobGV0IEhlPXUtMTtIZT49MDtIZS0tKXtsZXQgT2U9ZGUuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixIZStkZS5yYW5rLXUpO05lLnB1c2goYCR7SyhJLEhlKX0gKiAoJHtPZX0gJSAke0soUyxIZSl9KWApfXJldHVybiBNW3BlXT1gZm4gJHtwZX0ob3V0cHV0SW5kaWNlczogJHtkZS50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAke05lLmxlbmd0aD4wP05lLmpvaW4oXCIrXCIpOlwiMHVcIn07XG4gICAgICAgICAgIH1gLGAke3BlfSgke1V9KWB9LHhlPShVLGRlKT0+KCgpPT57aWYoZy5zdG9yYWdlPT09Zy52YWx1ZSlyZXR1cm5gJHtlfVske1V9XT0ke2RlfTtgO2lmKGcuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmcudmFsdWU9PT1cImkzMlwiKXJldHVybmAke2V9WyR7VX1dPXZlYzI8dTMyPih1MzIoJHtkZX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke2RlfSA8IDApKTtgO2lmKGcuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmcudmFsdWU9PT1cInUzMlwiKXJldHVybmAke2V9WyR7VX1dPXZlYzI8dTMyPih1MzIoJHtkZX0pLCAwdSk7YDtpZihnLnN0b3JhZ2U9PT1cInUzMlwiJiZnLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYCR7ZX1bJHtVfV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHtkZX0pKTtgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtnLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7Zy52YWx1ZX0geWV0YCl9KSgpLG9lPVU9PigoKT0+e2lmKGcuc3RvcmFnZT09PWcudmFsdWUpcmV0dXJuYCR7ZX1bJHtVfV1gO2lmKGcuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmcudmFsdWU9PT1cImkzMlwiKXJldHVybmBpMzIoJHtlfVske1V9XS54KWA7aWYoZy5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmZy52YWx1ZT09PVwidTMyXCIpcmV0dXJuYHUzMigke2V9WyR7VX1dLngpYDtpZihnLnN0b3JhZ2U9PT1cInUzMlwiJiZnLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYHZlYzQ8Ym9vbD4oYm9vbCgke2V9WyR7VX1dICYgMHhGRnUpLCBib29sKCR7ZX1bJHtVfV0gJiAweEZGMDB1KSwgYm9vbCgke2V9WyR7VX1dICYgMHhGRjAwMDB1KSwgYm9vbCgke2V9WyR7VX1dICYgMHhGRjAwMDAwMHUpKWA7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2cuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtnLnZhbHVlfSB5ZXRgKX0pKCksd2U9dTwyP1wiXCI6YFxuICBmbiBnZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2cuaW5kaWNlc30pIC0+ICR7bX0ge1xuICAgIHJldHVybiAke29lKGBpMm9fJHtlfShpbmRpY2VzKWApfTtcbiAgfWAsaj11PDI/XCJcIjooKCk9PntsZXQgVT1sLm1hcChwZT0+YGQke3BlfTogdTMyYCkuam9pbihcIiwgXCIpLGRlPWwubWFwKHBlPT5gZCR7cGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gZ2V0XyR7ZX0oJHtVfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuIGdldF8ke2V9QnlJbmRpY2VzKCR7SChkZSl9KTtcbiAgfWB9KSgpLFNlPSguLi5VKT0+e2lmKFUubGVuZ3RoIT09dSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHt1fWApO2xldCBkZT1VLm1hcCh2KS5qb2luKFwiLFwiKTtyZXR1cm4gdT09PTA/b2UoXCIwdVwiKTp1PT09MT9vZShkZVswXSk6KCQuZ2V0PSEwLCQuZ2V0QnlJbmRpY2VzPSEwLCQuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfSgke2RlfSlgKX0sVGU9VT0+dTwyP29lKFUpOigkLmdldEJ5SW5kaWNlcz0hMCwkLmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX1CeUluZGljZXMoJHtVfSlgKSxFZT11PDI/XCJcIjpgXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7Zy5pbmRpY2VzfSwgdmFsdWU6ICR7bX0pIHtcbiAgICAke3hlKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cbiAgfWAsQ2U9dTwyP1wiXCI6KCgpPT57bGV0IFU9bC5tYXAocGU9PmBkJHtwZX06IHUzMmApLmpvaW4oXCIsIFwiKSxkZT1sLm1hcChwZT0+YGQke3BlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIHNldF8ke2V9KCR7VX0sIHZhbHVlOiAke219KSB7XG4gICAgc2V0XyR7ZX1CeUluZGljZXMoJHtIKGRlKX0sIHZhbHVlKTtcbiAgfWB9KSgpO3JldHVybntpbXBsOigpPT57bGV0IFU9W107cmV0dXJuIHN8fChVLnB1c2goYGNvbnN0ICR7U30gPSAke2cuaW5kaWNlc30oJHtyLmpvaW4oXCIsXCIpfSk7YCksVS5wdXNoKGBjb25zdCAke0l9ID0gJHtnLmluZGljZXN9KCR7ei5jb21wdXRlU3RyaWRlcyhyKS5qb2luKFwiLFwiKX0pO2ApKSwkLm9mZnNldFRvSW5kaWNlcyYmVS5wdXNoKEIpLCQuaW5kaWNlc1RvT2Zmc2V0JiZVLnB1c2goUiksJC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCYmT2JqZWN0LnZhbHVlcyhNKS5mb3JFYWNoKGRlPT5VLnB1c2goZGUpKSwkLnNldCYmVS5wdXNoKENlKSwkLnNldEJ5SW5kaWNlcyYmVS5wdXNoKEVlKSwkLmdldCYmVS5wdXNoKGopLCQuZ2V0QnlJbmRpY2VzJiZVLnB1c2god2UpLFUuam9pbihgXG5gKX0sdHlwZTpnLG9mZnNldFRvSW5kaWNlczpQLGluZGljZXNUb09mZnNldDpXLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OnEsaW5kaWNlczpILGluZGljZXNHZXQ6SyxpbmRpY2VzU2V0OmxlLHNldDooLi4uVSk9PntpZihVLmxlbmd0aCE9PXUrMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHt1fWApO2xldCBkZT1VW3VdO2lmKHR5cGVvZiBkZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgcGU9VS5zbGljZSgwLHUpLm1hcCh2KS5qb2luKFwiLFwiKTtyZXR1cm4gdT09PTA/eGUoXCIwdVwiLGRlKTp1PT09MT94ZShwZVswXSxkZSk6KCQuc2V0PSEwLCQuc2V0QnlJbmRpY2VzPSEwLCQuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke3BlfSwgJHtkZX0pYCl9LHNldEJ5T2Zmc2V0OnhlLHNldEJ5SW5kaWNlczooVSxkZSk9PnU8Mj94ZShVLGRlKTooJC5zZXRCeUluZGljZXM9ITAsJC5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7VX0sICR7ZGV9KTtgKSxnZXQ6U2UsZ2V0QnlPZmZzZXQ6b2UsZ2V0QnlJbmRpY2VzOlRlLHVzYWdlOmE/XCJpbnB1dFwiOlwib3V0cHV0XCIsbmFtZTplLHN0cmlkZXM6SSxzaGFwZTpTLHJhbms6dX19LEY9KGUsdCxyLGE9MSk9PnFvKGUsdCxyLCEwLGEpLFg9KGUsdCxyLGE9MSk9PnFvKGUsdCxyLCExLGEpLGpuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXA9dDt0aGlzLmluZGljZXNIZWxwZXJzPVtdO3RoaXMudW5pZm9ybXM9W107dGhpcy52YXJpYWJsZUluZGV4PTB9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh0KXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHt0eXBlb2YgdD09XCJudW1iZXJcIj9gJHt0fXVgOnR9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KHQ9ZWQpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dFswXSxhPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsxXSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsyXSxzPXRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV09PT0xJiZ0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdPT09MSx1PXM/YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gOmBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pbmRleCA6IHUzMixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPmAsbD1zP1wibGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDtcIjpgbGV0IGdsb2JhbF9pZHggPSAod29ya2dyb3VwX2lkLnogKiAke3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF0qdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXX11ICtcbiAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqICR7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXX11ICsgd29ya2dyb3VwX2lkLngpICogJHtyKmEqbn11ICsgbG9jYWxfaW5kZXg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7cn0sICR7YX0sICR7bn0pXG4gIGZuIG1haW4oJHt1fSkge1xuICAgICR7bH1cbiAgYH1kZWNsYXJlVmFyaWFibGUodCxyKXt0aGlzLmluZGljZXNIZWxwZXJzLnB1c2godCksdC5zaGFwZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zaGFwZS5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTp0LnR5cGUuaW5kaWNlc30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOnQudHlwZS5pbmRpY2VzfSk7bGV0IGE9dC51c2FnZT09PVwiaW5wdXRcIj9cInJlYWRcIjpcInJlYWRfd3JpdGVcIixuPXQudHlwZS5zdG9yYWdlO3JldHVybmBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtyfSkgdmFyPHN0b3JhZ2UsICR7YX0+ICR7dC5uYW1lfTogYXJyYXk8JHtufT47YH1kZWNsYXJlVmFyaWFibGVzKC4uLnQpe3JldHVybiB0Lm1hcChyPT50aGlzLmRlY2xhcmVWYXJpYWJsZShyLHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbihgXG5gKX1yZWdpc3RlclVuaWZvcm0odCxyKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQsdHlwZTpyfSksdGhpc311bmlmb3JtRGVjbGFyYXRpb24oKXtpZih0aGlzLnVuaWZvcm1zLmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgdD1bXTtmb3IobGV0e25hbWU6cix0eXBlOmF9b2YgdGhpcy51bmlmb3Jtcyl0LnB1c2goYCR7cn06JHthfWApO3JldHVybmBcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dC5qb2luKFwiLCBcIil9IH07XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2B9Z2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKXtyZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSt0aGlzLmluZGljZXNIZWxwZXJzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKX19LEtvPWU9Pm5ldyBqbihlKSxLbj0oZSx0KT0+e2xldCByPWUubGVuZ3RoLGE9W107Zm9yKGxldCBuPTA7bjxyO24rKyl7bGV0IHM9ci0xLW4sdT1lW3NdfHwxOyh0W3QubGVuZ3RoLTEtbl18fDEpPjEmJnU9PT0xJiZhLnVuc2hpZnQocyl9cmV0dXJuIGF9LFlvPWU9PmU8PTR9KTt2YXIgdGQsWG8scmQsbmQsQ3QsSm8sUW8sbXI9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO3RkPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKX0sWG89KGUsdCk9PnQmJnQubGVuZ3RoIT09ZT9bLi4ubmV3IEFycmF5KGUpLmtleXMoKV0ucmV2ZXJzZSgpOnQscmQ9KGUsdCk9Pnouc29ydEJhc2VkT25QZXJtKGUsWG8oZS5sZW5ndGgsdCkpLG5kPShlLHQscixhKT0+e2xldCBuPVtdO24ucHVzaChgZm4gcGVybShpOiAke2EudHlwZS5pbmRpY2VzfSkgLT4gJHtyLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke3IudHlwZS5pbmRpY2VzfTtgKTtmb3IobGV0IHM9MDtzPHQ7KytzKW4ucHVzaChyLmluZGljZXNTZXQoXCJhXCIsZVtzXSxgaVske3N9XWApKTtyZXR1cm4gbi5wdXNoKFwicmV0dXJuIGE7fVwiKSxuLmpvaW4oYFxuYCl9LEN0PShlLHQpPT57bGV0IHI9ZS5kYXRhVHlwZSxhPWUuZGltcy5sZW5ndGgsbj1YbyhhLHQpLHM9WW8oYSksdT1yZChlLmRpbXMsbiksbD1zP3UubGVuZ3RoOnUsbz1zP2E6ZS5kaW1zLHA9WChcIm91dHB1dFwiLHIsbCksbT1GKFwiYVwiLHIsbykseT1nPT5gXG4gICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobSxwKX1cblxuICAke25kKG4sYSxtLHApfVxuXG4gICR7Zy5tYWluU3RhcnQoKX1cbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke3Aub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7cC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixtLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWA7cmV0dXJue25hbWU6XCJUcmFuc3Bvc2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6cz9bXCJyYW5rXCJdOltcImRpbXNcIl19LGdldFJ1bkRhdGE6Zz0+e2xldCB2PXouc2l6ZSh1KTtyZXR1cm57b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTpnWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwodi82NCl9LHByb2dyYW1Vbmlmb3JtczpzP1t7dHlwZTpcInVpbnQzMlwiLGRhdGE6dn0sLi4ucW4oZ1swXS5kaW1zKSwuLi5xbih1KV06W3t0eXBlOlwidWludDMyXCIsZGF0YTp2fV19fSxnZXRTaGFkZXJTb3VyY2U6eX19LEpvPShlLHQpPT57dGQoZS5pbnB1dHMpLGUuY29tcHV0ZShDdChlLmlucHV0c1swXSx0LnBlcm0pKX0sUW89ZT0+aWUoe3Blcm06ZS5wZXJtfSl9KTt2YXIgYWQsb2QsaWQsc2QsdWQsbGQsZGQsY2QscGQsZmQsYXQsWm8sZWksdGkscmksbmksYWksb2ksaWksc2ksdWksbGk9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtlbigpO21yKCk7YWQ9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSlcIixsMTpcImJlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0sb2Q9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDE6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxpZD17bWF4OlwiX0Fbb2Zmc2V0XVwiLG1pbjpcIl9BW29mZnNldF1cIixtZWFuOlwiMFwiLHN1bTpcIjBcIixwcm9kOlwiMVwiLHN1bVNxdWFyZTpcIjBcIixsb2dTdW1FeHA6XCIwXCIsbDE6XCIwXCIsbDI6XCIwXCIsbG9nU3VtOlwiMFwifSxzZD17bWF4OlwiYmVzdFZhbHVlXCIsbWluOlwiYmVzdFZhbHVlXCIsc3VtOlwiYmVzdFZhbHVlXCIscHJvZDpcImJlc3RWYWx1ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZVwiLGxvZ1N1bUV4cDpcImxvZyhiZXN0VmFsdWUpXCIsbDE6XCJiZXN0VmFsdWVcIixsMjpcInNxcnQoYmVzdFZhbHVlKVwiLGxvZ1N1bTpcImxvZyhiZXN0VmFsdWUpXCJ9LHVkPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBhPXQtZTthPHQ7KythKXIucHVzaChhKTtyZXR1cm4gcn0sbGQ9KGUsdCk9PntsZXQgcj1bXSxhPWUubGVuZ3RoO2ZvcihsZXQgcz0wO3M8YTtzKyspdC5pbmRleE9mKHMpPT09LTEmJnIucHVzaChlW3NdKTtsZXQgbj10Lm1hcChzPT5lW3NdKTtyZXR1cm5bcixuXX0sZGQ9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCt0Lmxlbmd0aCxhPVtdLG49MDtmb3IobGV0IHM9MDtzPHI7cysrKXQuaW5kZXhPZihzKT09PS0xP2EucHVzaChlW24rK10pOmEucHVzaCgxKTtyZXR1cm4gYX0sY2Q9KGUsdCk9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilpZihlW2UubGVuZ3RoLXItMV0hPT10LTEtcilyZXR1cm4hMTtyZXR1cm4hMH0scGQ9KGUsdCk9PntsZXQgcj1bXTtpZighY2QoZSx0KSl7Zm9yKGxldCBhPTA7YTx0OysrYSllLmluZGV4T2YoYSk9PT0tMSYmci5wdXNoKGEpO2UuZm9yRWFjaChhPT5yLnB1c2goYSkpfXJldHVybiByfSxmZD0oZSx0LHIsYSxuLHMsdSk9PntsZXQgbD1yWzBdLmRpbXMsbz16LnNpemUocykscD16LnNpemUodSksbT1GKFwiX0FcIixyWzBdLmRhdGFUeXBlLGwpLHk9WChcIm91dHB1dFwiLG4scyksZz0zMix2PWBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PCR7eS50eXBlLnN0b3JhZ2V9LCAke2d9PjtcbiAgICAgICBgO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6dCxnZXRTaGFkZXJTb3VyY2U6Yj0+YFxuICAgICAgICAke2IucmVnaXN0ZXJVbmlmb3JtKFwicmVkdWNlU2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobSx5KX1cbiAgICAgICAgJHt2fVxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xuICAgICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xuICAgICAgICAgfVxuICAgICAgICAgJHtiLm1haW5TdGFydChnKX1cbiAgICAgICAgICBsZXQgbG9jYWxfaWR4ID0gbG9jYWxfaWQueDtcblxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke2d9O1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBvdXRwdXRJbmRleCAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XG5cbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gJHt5LnR5cGUuc3RvcmFnZX0oJHtpZFthXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHtnfSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gJHt5LnR5cGUuc3RvcmFnZX0oJHttLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke2FkW2FdfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHtnfXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7b2RbYV19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7eS5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7YT09PVwibWVhblwiP2BiZXN0VmFsdWUgLyAke3kudHlwZS5zdG9yYWdlfSh1bmlmb3Jtcy5yZWR1Y2VTaXplKWA6YCR7c2RbYV19YH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTpufV0sZGlzcGF0Y2hHcm91cDp7eDpvfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOlwidWludDMyXCIsZGF0YTpwfV19KX19LGF0PShlLHQscixhKT0+e2xldCBuPWUuaW5wdXRzLmxlbmd0aD09PTE/cjpZbihlLmlucHV0cyxyKSxzPW4uYXhlcztzLmxlbmd0aD09PTAmJiFuLm5vb3BXaXRoRW1wdHlBeGVzJiYocz1lLmlucHV0c1swXS5kaW1zLm1hcCgodiwkKT0+JCkpO2xldCB1PXoubm9ybWFsaXplQXhlcyhzLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxsPXUsbz1lLmlucHV0c1swXSxwPXBkKGwsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO3AubGVuZ3RoPjAmJihvPWUuY29tcHV0ZShDdChlLmlucHV0c1swXSxwKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxsPXVkKGwubGVuZ3RoLG8uZGltcy5sZW5ndGgpKTtsZXRbbSx5XT1sZChvLmRpbXMsbCksZz1tO24ua2VlcERpbXMmJihnPWRkKG0sdSkpLGUuY29tcHV0ZShmZCh0LHtoaW50Om4uY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sW29dLGEsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZyx5KSx7aW5wdXRzOltvXX0pfSxabz0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LGVpPShlLHQpPT57YXQoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSx0aT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0scmk9KGUsdCk9PnthdChlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sbmk9KGUsdCk9PnthdChlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0sYWk9KGUsdCk9PnthdChlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0sb2k9KGUsdCk9PnthdChlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxpaT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxzaT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSx1aT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciBvdCxtZCx0bixZbixpdCxoZCxnZCx5ZCxiZCx3ZCx2ZCwkZCx4ZCxTZCxDZCxzdCxkaSxjaSxwaSxmaSxtaSxoaSxnaSx5aSxiaSx3aSxaZSxlbj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7bGkoKTtvdD1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZS5sZW5ndGg9PT0yJiZlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4ZXMgaW5wdXQgZGltcy5cIil9LG1kPWU9PltcIlwiLFwiXCIsYHZhciB2YWx1ZSA9ICR7ZS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwiXCJdLHRuPShlLHQscixhLG4scyx1PSExLGw9ITEpPT57bGV0IG89W10scD1yWzBdLmRpbXMsbT16Lm5vcm1hbGl6ZUF4ZXMobixyWzBdLmRpbXMubGVuZ3RoKSx5PSFsJiZtLmxlbmd0aD09PTA7cC5mb3JFYWNoKChXLEgpPT57eXx8bS5pbmRleE9mKEgpPj0wP3UmJm8ucHVzaCgxKTpvLnB1c2goVyl9KTtsZXQgZz1bXSx2PUYoXCJfQVwiLHJbMF0uZGF0YVR5cGUscCksJD1YKFwib3V0cHV0XCIscyxvKSxiPWEodiwkLG0pLFM9YGlucHV0T2Zmc2V0ID0gJHt2LmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc1wiKX07YCxJPWBsZXQgJHtTfTtgLFQ9YHZhciAke1N9O2AsQj1iWzFdPT09XCJcIj9cIlwiOlQsUD0oYlsxXT09PVwiXCI/STpTKStgXG5gK2JbMl07Zm9yKGxldCBXPTAsSD0wO1c8clswXS5kaW1zLmxlbmd0aDtXKyspeXx8bS5pbmRleE9mKFcpPj0wPyh1JiZIKyssUD1gZm9yKHZhciBqJHtXfTogdTMyID0gMDsgaiR7V30gPCAke3JbMF0uZGltc1tXXX07IGoke1d9KyspIHtcbiAgICAgICAgICAgICAgICAke2JbMl0uaW5jbHVkZXMoXCJsYXN0SW5kZXhcIik/YGxldCBsYXN0SW5kZXggPSBqJHtXfTtgOlwiXCJ9XG4gICAgICAgICAgICAgICAgJHt2LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixXLGBqJHtXfWApfVxuICAgICAgICAgICAgICAgICR7UH1cbiAgICAgICAgICAgICAgfWApOihnLnB1c2goYCR7di5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsVywkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsSCkpfTtgKSxIKyspO2xldCBEPXouc2l6ZShvKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOlc9PmBcbiAgICAgICAgJHtXLmRlY2xhcmVWYXJpYWJsZXModiwkKX1cblxuICAgICAgICAke1cubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtXLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoRCl9XG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHt2LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAke2cuam9pbihgXG5gKX1cbiAgICAgICAgICAke2JbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAgICR7Qn1cbiAgICAgICAgICAke2JbMV19XG4gICAgICAgICAgJHtQfVxuICAgICAgICAgICR7YlszXX1cbiAgICAgICAgICAke2IubGVuZ3RoPT09ND8kLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6Yi5zbGljZSg0KS5qb2luKGBcbmApfVxuICAgICAgICB9YCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEQvNjQpfX0pfX0sWW49KGUsdCk9PntsZXQgcj1bXTtyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJmVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goYT0+ci5wdXNoKE51bWJlcihhKSkpLGllKHtheGVzOnIsa2VlcERpbXM6dC5rZWVwRGltcyxub29wV2l0aEVtcHR5QXhlczp0Lm5vb3BXaXRoRW1wdHlBeGVzfSl9LGl0PShlLHQscixhKT0+e2xldCBuPWUuaW5wdXRzLHM9bi5sZW5ndGg9PT0xP3I6WW4obixyKTtlLmNvbXB1dGUodG4odCx7aGludDpzLmNhY2hlS2V5fSxbblswXV0scy5ub29wV2l0aEVtcHR5QXhlcyYmcy5heGVzLmxlbmd0aD09PTA/bWQ6YSxzLmF4ZXMsblswXS5kYXRhVHlwZSxzLmtlZXBEaW1zLHMubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LGhkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMb2dTdW1cIix0LChhLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sZ2Q9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUwxXCIsdCwoYSxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJcIl0pfSx5ZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTDJcIix0LChhLG4pPT5bYHZhciB0ID0gJHtuLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke24udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LGJkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChhLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSx3ZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTWF4XCIsdCwoYSxuLHMpPT57bGV0IHU9W107Zm9yKGxldCBsPTA7bDxhLnJhbms7bCsrKShzLmluZGV4T2YobCk+PTB8fHMubGVuZ3RoPT09MCkmJnUucHVzaChhLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixsLDApKTtyZXR1cm5bYCR7dS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwiXCJdfSl9LHZkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VNZWFuXCIsdCwoYSxuLHMpPT57bGV0IHU9MTtmb3IobGV0IGw9MDtsPGEucmFuaztsKyspKHMuaW5kZXhPZihsKT49MHx8cy5sZW5ndGg9PT0wKSYmKHUqPWUuaW5wdXRzWzBdLmRpbXNbbF0pO3JldHVybltcInZhciBzdW0gPSBmMzIoMCk7XCIsXCJcIixgc3VtICs9IGYzMigke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsYGxldCB2YWx1ZSA9ICR7bi50eXBlLnZhbHVlfShzdW0gLyAke3V9KTtgXX0pfSwkZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTWluXCIsdCwoYSxuLHMpPT57bGV0IHU9W107Zm9yKGxldCBsPTA7bDxhLnJhbms7bCsrKShzLmluZGV4T2YobCk+PTB8fHMubGVuZ3RoPT09MCkmJnUucHVzaChgaW5wdXRJbmRpY2VzWyR7bH1dID0gMDtgKTtyZXR1cm5bYCR7dS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwiXCJdfSl9LHhkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VQcm9kXCIsdCwoYSxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgxKTtgLFwiXCIsYHZhbHVlICo9ICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwiXCJdKX0sU2Q9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZVN1bVwiLHQsKGEsbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcIlwiXSl9LENkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VTdW1TcXVhcmVcIix0LChhLG4pPT5bYHZhciB0ID0gJHtuLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke24udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9OyB2YWx1ZSArPSB0ICogdDtgLFwiXCJdKX0sc3Q9KGUsdCxyKT0+e2lmKHQubGVuZ3RoPT09MClyZXR1cm4hIXI7bGV0IGE9MSxuPTE7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdC5pbmRleE9mKHMpPT09LTE/YSo9ZVtzXTpuKj1lW3NdO3JldHVybiBuPDMyJiZhPjEwMjR9LGRpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/dmQoZSx0KTpabyhlLHQpfSxjaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2dkKGUsdCk6ZWkoZSx0KX0scGk9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT95ZChlLHQpOnRpKGUsdCl9LGZpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/YmQoZSx0KTpyaShlLHQpfSxtaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3dkKGUsdCk6bmkoZSx0KX0saGk9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT8kZChlLHQpOmFpKGUsdCl9LGdpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/eGQoZSx0KTpvaShlLHQpfSx5aT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1NkKGUsdCk6aWkoZSx0KX0sYmk9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9DZChlLHQpOnNpKGUsdCl9LHdpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/aGQoZSx0KTp1aShlLHQpfSxaZT1lPT5pZShlKX0pO3ZhciB2aSwkaSx4aSxTaSxYbixDaT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtrZSgpO2VuKCk7dmk9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sJGk9KGUsdCk9PmllKHtheGlzOnQuYXhpcyxrZWVwRGltczp0LmtlZXBEaW1zLHNlbGVjdExhc3RJbmRleDp0LnNlbGVjdExhc3RJbmRleH0pLHhpPShlLHQpPT57dmkoZS5pbnB1dHMpO2xldCByPShuLHMsdSk9PntsZXQgbD1bXTtmb3IobGV0IG89MDtvPG4ucmFuaztvKyspKHUuaW5kZXhPZihvKT49MHx8dS5sZW5ndGg9PT0wKSYmbC5wdXNoKGBpbnB1dEluZGljZXNbJHtvfV0gPSAwO2ApO3JldHVybltgJHtsLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xudmFyIGJlc3RJbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI8PVwiOlwiPFwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XG4gICAgICAgICBiZXN0SW5kZXggPSBpMzIobGFzdEluZGV4KTtcbiAgICAgICB9YCxcIlwiLHMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0SW5kZXhcIildfSxhPWUuaW5wdXRzLmxlbmd0aD09PTE/dDokaShlLmlucHV0cyx0KTtlLmNvbXB1dGUodG4oXCJBcmdNaW5cIix7aGludDphLmNhY2hlS2V5fSxbZS5pbnB1dHNbMF1dLHIsW2EuYXhpc10sNyxhLmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxTaT0oZSx0KT0+e3ZpKGUuaW5wdXRzKTtsZXQgcj0obixzLHUpPT57bGV0IGw9W107Zm9yKGxldCBvPTA7bzxuLnJhbms7bysrKSh1LmluZGV4T2Yobyk+PTB8fHUubGVuZ3RoPT09MCkmJmwucHVzaChgaW5wdXRJbmRpY2VzWyR7b31dID0gMDtgKTtyZXR1cm5bYCR7bC5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcbnZhciBiZXN0SW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPj1cIjpcIj5cIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xuICAgICAgICAgYmVzdEluZGV4ID0gaTMyKGxhc3RJbmRleCk7XG4gICAgICAgfWAsXCJcIixzLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdEluZGV4XCIpXX0sYT1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6JGkoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHRuKFwiYXJnTWF4XCIse2hpbnQ6YS5jYWNoZUtleX0sW2UuaW5wdXRzWzBdXSxyLFthLmF4aXNdLDcsYS5rZWVwRGltcykse2lucHV0czpbMF19KX0sWG49ZT0+aWUoZSl9KTt2YXIgSWQsQWQsSWksQWk9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtJZD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMzIwLDY0MCwxMjgwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcIm51bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxBZD1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9ZVswXS5kaW1zWzJdLGE9ei5zaXplKHQpLzQsbj1lWzBdLmRhdGFUeXBlLHM9RihcImlucHV0XCIsbix0LDQpLHU9RihcImJpYXNcIixuLFtyXSw0KSxsPUYoXCJyZXNpZHVhbFwiLG4sdCw0KSxvPVgoXCJvdXRwdXRcIixuLHQsNCk7cmV0dXJue25hbWU6XCJCaWFzQWRkXCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bT0+YFxuICBjb25zdCBjaGFubmVscyA9ICR7cn11IC8gNDtcbiAgJHttLmRlY2xhcmVWYXJpYWJsZXMocyx1LGwsbyl9XG5cbiAgJHttLm1haW5TdGFydCgpfVxuICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGEpfVxuICAgIGxldCB2YWx1ZSA9ICR7cy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9XG4gICAgICArICR7dS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSBjaGFubmVsc1wiKX0gKyAke2wuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke28uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWB9fSxJaT1lPT57SWQoZS5pbnB1dHMpLGUuY29tcHV0ZShBZChlLmlucHV0cykpfX0pO3ZhciBFZCwkZSxFaSxfaSxPaSxUaSxSaSxQaSxraSxCaSxNaSxKbixfZCxEaSx6aSxXaSxOaSxybixWaSxubixVaSxHaSxGaSxMaSxIaSxqaSxxaSxLaSxZaSxYaSxKaSxRaSxaaSxlcyx0cyxycyxucyxRbj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO2tlKCk7dmUoKTtFZD0oZSx0LHIsYSxuLHMpPT57bGV0IHU9TWF0aC5jZWlsKHQvNCksbD1cIlwiO3R5cGVvZiBuPT1cInN0cmluZ1wiP2w9YCR7bn0oYSlgOmw9bihcImFcIik7bGV0IG89RihcImlucHV0RGF0YVwiLHIsW3VdLDQpLHA9WChcIm91dHB1dERhdGFcIixhLFt1XSw0KTtyZXR1cm5gXG4gICR7ZS5kZWNsYXJlVmFyaWFibGVzKG8scCl9XG5cbiAgJHtzPz9cIlwifVxuXG4gICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cblxuICAgIGxldCBhID0gJHtvLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGwpfVxuICB9YH0sJGU9KGUsdCxyLGEsbixzPWUuZGF0YVR5cGUpPT4oe25hbWU6dCxzaGFkZXJDYWNoZTp7aGludDpufSxnZXRTaGFkZXJTb3VyY2U6dT0+RWQodSx6LnNpemUoZS5kaW1zKSxlLmRhdGFUeXBlLHMscixhKSxnZXRSdW5EYXRhOnU9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh6LnNpemUodVswXS5kaW1zKS82NC80KX19KX0pLEVpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LF9pPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sT2k9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LFRpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sUmk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFzaW5oXCIsXCJhc2luaFwiKSl9LFBpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sa2k9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LEJpPWU9PmllKGUpLE1pPShlLHQpPT57bGV0IHI7c3dpdGNoKHQudG8pe2Nhc2UgMTA6cj1cInZlYzQ8ZjE2PlwiO2JyZWFrO2Nhc2UgMTpyPVwidmVjNDxmMzI+XCI7YnJlYWs7Y2FzZSAxMjpyPVwidmVjNDx1MzI+XCI7YnJlYWs7Y2FzZSA2OnI9XCJ2ZWM0PGkzMj5cIjticmVhaztjYXNlIDk6cj1cInZlYzQ8Ym9vbD5cIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgJ3RvJyBmcm9tICdDYXN0JyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDYXN0XCIscix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LEpuPShlLHQpPT57bGV0IHI9QmUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNsaXBcIixhPT5gY2xhbXAoJHthfSwgY2xpcF9taW5fLCBjbGlwX21heF8pYCxgXG4gICAgY29uc3QgY2xpcF9taW5fOiB2ZWM0PCR7cn0+ID0gdmVjNCgke3J9KCR7dC5taW59KSk7XG4gICAgY29uc3QgY2xpcF9tYXhfOiB2ZWM0PCR7cn0+ID0gdmVjNCgke3J9KCR7dC5tYXh9KSk7XG5gLHQuY2FjaGVLZXkpLHtpbnB1dHM6WzBdfSl9LF9kPWU9PntsZXQgdD1lLmxlbmd0aD49Mj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOlFyLHI9ZS5sZW5ndGg+PTM/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTpacjtyZXR1cm4gaWUoe21pbjp0LG1heDpyfSl9LERpPWU9PntsZXQgdD1fZChlLmlucHV0cyk7Sm4oZSx0KX0semk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNlaWxcIixcImNlaWxcIikpfSxXaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ29zXCIsXCJjb3NcIikpfSxOaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ29zaFwiLFwiY29zaFwiKSl9LHJuPWU9PmllKGUpLFZpPShlLHQpPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRWx1XCIscj0+YGVsdV92ZjMyKCR7cn0pYCxgXG4gIGNvbnN0IGVsdV9hbHBoYV86IGYzMiA9IGYzMigke3QuYWxwaGF9KTtcblxuICBmbiBlbHVfZjMyKGE6IGYzMikgLT4gZjMyIHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsdC5jYWNoZUtleSkpfSxubj0oZSx0PVwiZjMyXCIpPT5gXG5jb25zdCByMDogJHt0fSA9IDAuMzI3NTkxMTtcbmNvbnN0IHIxOiAke3R9ID0gMC4yNTQ4Mjk1OTI7XG5jb25zdCByMjogJHt0fSA9IC0wLjI4NDQ5NjczNjtcbmNvbnN0IHIzOiAke3R9ID0gMS40MjE0MTM3NDE7XG5jb25zdCByNDogJHt0fSA9IC0xLjQ1MzE1MjAyNztcbmNvbnN0IHI1OiAke3R9ID0gMS4wNjE0MDU0Mjk7XG5cbmZuIGVyZl92ZjMyKHY6ICR7ZX0pIC0+ICR7ZX0ge1xuICBsZXQgYWJzdiA9IGFicyh2KTtcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XG59YCxVaT1lPT57bGV0IHQ9QmUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkVyZlwiLHI9PmBlcmZfdmYzMigke3J9KWAsbm4oYHZlYzQ8JHt0fT5gLHQpKSl9LEdpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LEZpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxMaT1lPT57bGV0IHQ9QmUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkdlbHVcIixyPT5gMC41ICogJHtyfSAqICgxLjAgKyBlcmZfdmYzMigke3J9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLG5uKGB2ZWM0PCR7dH0+YCx0KSkpfSxIaT0oZSx0KT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLHI9PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke3J9LCAke3J9LCAke3J9ID49IHZlYzQ8ZjMyPigwLjApKWAsYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfOiBmMzIgPSBmMzIoJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LGppPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LHFpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LEtpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxZaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiUmVsdVwiLHQ9PmBzZWxlY3QodmVjNDxmMzI+KDAuMCksICR7dH0sICR7dH0gPiB2ZWM0PGYzMj4oMC4wKSlgKSl9LFhpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSxKaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxRaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LFppPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0sZXM9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0sdHM9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlRhbmhcIixcInRhbmhcIikpfSxycz0oZSx0KT0+KGUuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlRocmVzaG9sZGVkUmVsdVwiLHI9PmBzZWxlY3QodmVjNDxmMzI+KDAuMCksICR7cn0sICR7cn0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXzogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpLDApLG5zPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJMb2dcIixcImxvZ1wiKSl9fSk7dmFyIFRkLFJkLGFzLG9zPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7UW4oKTtUZD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxSZD1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IHI9RihcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCksYT1GKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbj1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLHM9ei5zaXplKHQpLzQ7cmV0dXJue25hbWU6XCJCaWFzU3BsaXRHZWx1XCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bD0+YFxuICBjb25zdCBNX1NRUlQyID0gc3FydCgyLjApO1xuICBjb25zdCBoYWxmQ2hhbm5lbHMgPSAke2VbMF0uZGltc1syXS80LzJ9dTtcblxuICAke2wuZGVjbGFyZVZhcmlhYmxlcyhyLGEsbil9XG5cbiAgJHtubihcInZlYzRmXCIpfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke24uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sYXM9ZT0+e1RkKGUuaW5wdXRzKSxlLmNvbXB1dGUoUmQoZS5pbnB1dHMpKX19KTt2YXIgUGQsa2QsdXQsaXMsc3MsdXMsbHMsZHMsY3MscHMsZnMsbXMsaHMsZ3M9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTt2ZSgpO1BkPShlLHQscixhLG4scyx1LGwsbyxwLG0pPT57bGV0IHk9ei5zaXplKGEpLGc9TWF0aC5jZWlsKHkvNCksdiwkO3R5cGVvZiB1PT1cInN0cmluZ1wiP3Y9JD0oUCxEKT0+YCR7dX0oKCR7UH0pLCgke0R9KSlgOnR5cGVvZiB1PT1cImZ1bmN0aW9uXCI/dj0kPXU6KHY9dS5zY2FsYXIsJD11LnZlY3Rvcik7bGV0IGI9XCJcIixTPVgoXCJvdXRwdXREYXRhXCIscCxhLDQpLEk9RihcImFEYXRhXCIsbCx0LDQpLFQ9RihcImJEYXRhXCIsbyxyLDQpO2lmKHMpe2xldCBQPUQ9PntsZXQgUj16LmNvbXB1dGVTdHJpZGVzKEQpLFc9W107Zm9yKGxldCBIPUQubGVuZ3RoLTE7SD49MDtILS0pe2xldCBLPVMuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixIK2EubGVuZ3RoLUQubGVuZ3RoKTtXLnB1c2goYCR7UltIXX11ICogKCR7S30gJSAke0RbSF19dSlgKX1yZXR1cm4gVy5sZW5ndGg+MD9XLmpvaW4oXCIrXCIpOlwiMHVcIn07Yj1gXG4gICAgICAgICAgZm4gY2FsY09mZnNldEEob3V0cHV0SW5kaWNlczogJHtTLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICByZXR1cm4gJHtQKHQpfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbiBjYWxjT2Zmc2V0QihvdXRwdXRJbmRpY2VzOiAke1MudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgIHJldHVybiAke1Aocil9O1xuICAgICAgICAgIH1cbiAgICAgICAgYH1sZXQgQjtpZihuKWlmKHMpe2xldCBQPXouc2l6ZSh0KT09PTEsRD16LnNpemUocik9PT0xO1B8fEQ/Qj1TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLCQoUD9gJHtJLnR5cGUudmFsdWV9KCR7SS5nZXRCeU9mZnNldChcIjBcIil9LngpYDpJLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxEP2Ake1QudHlwZS52YWx1ZX0oJHtULmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOlQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk6Qj1gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4ICogNHVcIil9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEgPSBjYWxjT2Zmc2V0QShvdXRwdXRJbmRpY2VzKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCID0gY2FsY09mZnNldEIob3V0cHV0SW5kaWNlcyk7XG4gICAgICAgICAgICAke1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsJChJLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QSAvIDR1XCIpLFQuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIikpKX1cbiAgICAgICAgICBgfWVsc2UgQj1TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLCQoSS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksVC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2lmKCFzKXRocm93IG5ldyBFcnJvcihcIm5vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLlwiKTtsZXQgUD0oRCxSLFc9XCJcIik9PntsZXQgSD1gYURhdGFbaW5kZXhBJHtSfV1bY29tcG9uZW50QSR7Un1dYCxLPWBiRGF0YVtpbmRleEIke1J9XVtjb21wb25lbnRCJHtSfV1gO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHtSfSA9ICR7Uy5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7Un11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke1J9ID0gY2FsY09mZnNldEEob3V0cHV0SW5kaWNlcyR7Un0pO1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke1J9ID0gY2FsY09mZnNldEIob3V0cHV0SW5kaWNlcyR7Un0pO1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7Un0gPSBvZmZzZXRBJHtSfSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7Un0gPSBvZmZzZXRCJHtSfSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke1J9ID0gb2Zmc2V0QSR7Un0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHtSfSA9IG9mZnNldEIke1J9ICUgNHU7XG4gICAgICAgICAgICAke0R9WyR7Un1dID0gJHtXfSgke3YoSCxLKX0pO1xuICAgICAgICAgIGB9O3A9PT05P0I9YFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke1AoXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgICAgICR7UChcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtQKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICAgICAke1AoXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpCPWBcbiAgICAgICAgICAgICR7UChcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7UChcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwxKX1cbiAgICAgICAgICAgICR7UChcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7UChcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXMoSSxULFMpfVxuXG4gICAgICAgICR7bT8/XCJcIn1cbiAgICAgICAgJHtifVxuXG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZyl9XG4gICAgICAgICR7Qn1cbiAgICAgIH1gfSxrZD0oZSx0LHIsYSxuLHMsdT1yLmRhdGFUeXBlKT0+e2xldCBsPSF6LmFyZUVxdWFsKHIuZGltcyxhLmRpbXMpLG89ci5kaW1zLHA9ei5zaXplKHIuZGltcyksbT0hMTtpZihsKXtsZXQgeT1udC5jYWxjU2hhcGUoci5kaW1zLGEuZGltcywhMSk7aWYoIXkpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bz15LHA9ei5zaXplKG8pO2xldCBnPXouc2l6ZShyLmRpbXMpPT09MSx2PXouc2l6ZShhLmRpbXMpPT09MSwkPTE7Zm9yKGxldCBiPTE7YjxvLmxlbmd0aDtiKyspe2xldCBTPXIuZGltc1tyLmRpbXMubGVuZ3RoLWJdPz8xLEk9YS5kaW1zW2EuZGltcy5sZW5ndGgtYl0/PzE7aWYoUz09PUkpJCo9UztlbHNlIGJyZWFrfSgkJTQ9PT0wfHxnfHx2KSYmKG09ITApfWVsc2UgbT0hMDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OnR9LGdldFNoYWRlclNvdXJjZTp5PT5QZCh5LHIuZGltcyxhLmRpbXMsbyxtLGwsbixyLmRhdGFUeXBlLGEuZGF0YVR5cGUsdSxzKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQvNCl9fSl9fSx1dD0oZSx0LHIsYSxuLHMpPT57ZS5jb21wdXRlKGtkKHQsbj8/XCJcIixlLmlucHV0c1swXSxlLmlucHV0c1sxXSxyLGEscykpfSxpcz1lPT57dXQoZSxcIkFkZFwiLCh0LHIpPT5gJHt0fSske3J9YCl9LHNzPWU9Pnt1dChlLFwiRGl2XCIsKHQscik9PmAke3R9LyR7cn1gKX0sdXM9ZT0+e3V0KGUsXCJFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fT09JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PT0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGxzPWU9Pnt1dChlLFwiTXVsXCIsKHQscik9PmAke3R9KiR7cn1gKX0sZHM9ZT0+e2xldCB0PUYoXCJpbnB1dFwiLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGUuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7dXQoZSxcIlBvd1wiLHtzY2FsYXI6KGEsbik9PmBwb3dfY3VzdG9tKCR7YX0sJHtufSlgLHZlY3RvcjooYSxuKT0+YHBvd192ZWN0b3JfY3VzdG9tKCR7YX0sJHtufSlgfSxgXG4gICAgZm4gcG93X2N1c3RvbShhIDogJHt0fSwgYiA6ICR7dH0pIC0+ICR7dH0ge1xuICAgICAgaWYgKGIgPT0gJHt0fSgwLjApKSB7XG4gICAgICAgIHJldHVybiAke3R9KDEuMCk7XG4gICAgICB9IGVsc2UgaWYgKGEgPCAke3R9KDAuMCkgJiYgZjMyKGIpICE9IGZsb29yKGYzMihiKSkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0ocG93KGYzMihhKSwgZjMyKGIpKSk7IC8vIE5hTlxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdChzaWduKGEpLCAke3R9KDEuMCksIHJvdW5kKGYzMihhYnMoYikgJSAke3R9KDIuMCkpKSAhPSAxLjApICogJHt0fSgke3Q9PT1cImkzMlwiP1wicm91bmRcIjpcIlwifShwb3coZjMyKGFicyhhKSksIGYzMihiKSkpKTtcbiAgICB9XG4gICAgZm4gcG93X3ZlY3Rvcl9jdXN0b20oYSA6IHZlYzQ8JHt0fT4sIGIgOiB2ZWM0PCR7dH0+KSAtPiB2ZWM0PCR7dH0+IHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCB2ZWN0b3JpemVkIHBvd1xuICAgICAgcmV0dXJuIHZlYzQ8JHt0fT4ocG93X2N1c3RvbShhLngsIGIueCksIHBvd19jdXN0b20oYS55LCBiLnkpLCBwb3dfY3VzdG9tKGEueiwgYi56KSwgcG93X2N1c3RvbShhLncsIGIudykpO1xuICAgIH1cbiAgICAgIGApfSxjcz1lPT57dXQoZSxcIlN1YlwiLCh0LHIpPT5gJHt0fS0ke3J9YCl9LHBzPWU9Pnt1dChlLFwiR3JlYXRlclwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fT4ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxmcz1lPT57dXQoZSxcIkxlc3NcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH08JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PCR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sbXM9ZT0+e3V0KGUsXCJHcmVhdGVyT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fT49JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9Pj0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGhzPWU9Pnt1dChlLFwiTGVzc09yRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH08PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fTw9JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfX0pO3ZhciBNZCxEZCx6ZCxXZCx5cyxicyx3cz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7TWQ9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2xldCB0PWVbMF0uZGF0YVR5cGUscj1lWzBdLmRpbXMubGVuZ3RoO2ZvcihsZXQgYSBvZiBlKXtpZihhLmRhdGFUeXBlIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihhLmRpbXMubGVuZ3RoIT09cil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX0sRGQ9ZT0+YFxuICBmbiBjYWxjdWxhdGVJbnB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbiAgfWAsemQ9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxhPVtdO2ZvcihsZXQgbj0wO248cjsrK24pe2xldCBzPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtuXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtyPT09MT9hLnB1c2gocyk6bj09PTA/YS5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke259dSkgeyAke3N9IH1gKTpuPT09ci0xP2EucHVzaChgZWxzZSB7ICR7c30gfWApOmEucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke259KSB7ICR7c30gfWApfXJldHVybiBhLmpvaW4oYFxuYCl9LFdkPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLnNsaWNlKCk7aWYodD49ci5sZW5ndGh8fHQ8LTEqci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO2xldCBhPXQ8MD9yLmxlbmd0aCt0OnQsbj1yLnNsaWNlKDApO2ZvcihsZXQgdj0xO3Y8ZS5sZW5ndGg7disrKXtsZXQgJD1lW3ZdLmRpbXMuc2xpY2UoKTtmb3IobGV0IGI9MDtiPHIubGVuZ3RoO2IrKylpZihiPT09YSluW2FdKz0kW2JdO2Vsc2UgaWYocltiXSE9PSRbYl0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9bGV0IHM9ei5zaXplKG4pLHU9bmV3IEFycmF5KGUubGVuZ3RoKSxsPW5ldyBBcnJheShlLmxlbmd0aCksbz1lWzBdLmRhdGFUeXBlLHA9MDtmb3IobGV0IHY9MDt2PGUubGVuZ3RoOysrdilwKz1lW3ZdLmRpbXNbYV0sdVt2XT1wLGxbdl09RihgaW5wdXQke3Z9YCxvLGVbdl0uZGltcyk7bGV0IG09WChcIm91dHB1dFwiLG8sbikseT1tLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsYSksZz12PT5gXG4gICR7di5kZWNsYXJlVmFyaWFibGVzKC4uLmwsbSl9XG5cbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHt1Lmxlbmd0aH0+KCR7dS5tYXAoJD0+YCR7JH11YCkuam9pbihcIixcIil9KTtcbiAgJHtEZCh1Lmxlbmd0aCl9XG5cbiAgJHt2Lm1haW5TdGFydCgpfVxuICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHMpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICBsZXQgaW5wdXRJbmRleCA9IGNhbGN1bGF0ZUlucHV0SW5kZXgoJHt5fSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgICR7eX0gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7emQobCxtKX1cbiAgfWA7cmV0dXJue25hbWU6XCJDb25jYXRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9fSksZ2V0U2hhZGVyU291cmNlOmd9fSx5cz0oZSx0KT0+e01kKGUuaW5wdXRzKSxlLmNvbXB1dGUoV2QoZS5pbnB1dHMsdC5heGlzKSl9LGJzPWU9PmllKHtheGlzOmUuYXhpc30pfSk7dmFyIFdlLGFuLG9uLHNuPUwoKCk9PntcInVzZSBzdHJpY3RcIjtXZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxhbj0oZSx0PSExLHI9ITEsYT0zKT0+XCJcIixvbj0oZSx0KT0+YFxuICAgICAgJHtlP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpO1wiOlwiXCJ9XG4gICAgICAvLyBUT0RPIHVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmUgd2hlbiBhY3RpdmF0aW9uIGlzIHN1cHBvcnRlZCBhYm92ZS5cbiAgICAgIC8vICR7dD9cInZhbHVlID0gYWN0aXZhdGlvbih2YWx1ZSwgY29vcmRzKTtcIjpcIlwifVxuICAgICAgYH0pO3ZhciB1bixabj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dW49YFxuZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzIDogdmVjNDxpMzI+LCBzaGFwZSA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICAgIHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudywgc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLncsIDEpKTtcbn1cbmZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgb3V0U2hhcGVTdHJpZGVzLngsIG91dFNoYXBlU3RyaWRlcy55LCBvdXRTaGFwZVN0cmlkZXMueiwgMSkpO1xufVxuYH0pO3ZhciBsbixkbixocj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtsbj0oZSx0PSExKT0+e3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwidmFsdWUgPSBtYXgodmFsdWUsIDAuMCk7XCJ9O2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwidmFsdWUgPSAoMS4wIC8gKDEuMCArIGV4cCgtdmFsdWUpKSk7XCJ9O2Nhc2VcIkNsaXBcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOmBjb25zdCBjbGlwX21pbl89ZjMyKCR7ZS5jbGlwTWlufSk7Y29uc3QgY2xpcF9tYXhfPWYzMigke2UuY2xpcE1heH0pO2AsYXBwbHlBY3RpdmF0aW9uOnQ/XCJ2YWx1ZSA9IGNsYW1wKHZhbHVlLCB2ZWM0KGNsaXBfbWluXyksIHZlYzQoY2xpcF9tYXhfKSk7XCI6XCJ2YWx1ZSA9IGNsYW1wKHZhbHVlLCBjbGlwX21pbl8sIGNsaXBfbWF4Xyk7XCJ9O2RlZmF1bHQ6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcIlwifX19LGRuPWU9PntsZXQgdD1lPy5hY3RpdmF0aW9ufHxcIlwiO2lmKHQ9PT1cIkNsaXBcIil7bGV0W3IsYV09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtRcixacl07cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4OmEsY2xpcE1pbjpyLGFjdGl2YXRpb25DYWNoZUtleTpgJHt0fToke3J9LCR7YX1gfX1yZXR1cm57YWN0aXZhdGlvbjp0LGFjdGl2YXRpb25DYWNoZUtleTp0fX19KTt2YXIgTmQsVmQsZ3IsdnMsVWQseXIsR2QsY24sYnI9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtocigpO3NuKCk7TmQ9KGUsdCk9PmU/YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgOmBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGAsVmQ9KGUsdCk9PmU/YFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7dD09PTM/XCJcIjpcImxldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107XCJ9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldO1wifVxuICAgICAgICB9YDpgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldO1wifVxuICAgICAgICB9YCxncj0oZSx0LHI9XCJmMzJcIixhLG49ITEscz0zMix1PSExLGw9MzIpPT57bGV0IG89dFsxXSplWzFdLHA9dFswXSplWzBdLG09bj9vOnMseT1uP3M6byxnPW0vdFswXSx2PXMvdFsxXTtpZighKChuJiZnPT09NCYmZVsxXT09PTR8fCFuJiYoZz09PTN8fGc9PT00KSkmJm0ldFswXT09PTAmJnMldFsxXT09PTAmJmVbMF09PT00KSl0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHtufSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7Z30gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHtlWzFdfSBtdXN0IGJlIDQuXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHtnfSBtdXN0IGJlIDMgb3IgNC5cbiAgdGlsZUFXaWR0aCAke219IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHtzfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke2d9PCR7cn0+LCAke20vZ30+LCAke3l9PjtcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHtyfT4sICR7cC9lWzBdfT4sICR7c30+O1xuXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke2d9O1xuY29uc3QgdGlsZUlubmVyID0gJHtzfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XG4gIGxldCBiYXRjaCA9ICR7dT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgJHthP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtvfTtcblxuICBsZXQgbnVtVGlsZXMgPSAke3U/YCR7TWF0aC5jZWlsKGwvcyl9YDpcIihkaW1Jbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgdmFyIGtTdGFydCA9ICR7dT9gaTMyKGdsb2JhbElkLnopICogJHtsfWA6XCIwXCJ9O1xuXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHtyfT4sIHJvd1BlclRocmVhZD47XG5cbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHt2fTtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICR7TmQobixhKX1cbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7dn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHthP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xuICAgICAgICAgICR7Zz09PTM/XCJcIjpcImxldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTtcIn1cblxuICAgICAgICAgICR7VmQobixnKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWB9LHZzPShlLHQpPT5lP2BcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYDpgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGAsVWQ9ZT0+ZT9cImxldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddO1wiOlwibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107XCIseXI9KGUsdCxyPVwiZjMyXCIsYSxuPSExLHM9MzIsdT0hMSxsPTMyLG89ITEpPT57bGV0IHA9ZVsxXSp0WzFdLG09ZVswXSp0WzBdLHk9bj9wOnMsZz1uP3M6cDtpZighKGcldFsxXT09PTAmJnkldFswXT09PTAmJnMldFsxXT09PTApKXRocm93IG5ldyBFcnJvcihgdGlsZUFIaWdodCAke2d9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19LCB0aWxlQVdpZHRoICR7eX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0sIHRpbGVJbm5lciAke3N9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19YCk7bGV0IHY9Zy90WzFdLCQ9eS90WzBdLGI9cy90WzFdLFM9bz9gXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke219O1xuXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7Z307IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt5fTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICAke3ZzKG4sYSl9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtzfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHttfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7YT9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt0WzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7bj9gbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV07YDpgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV1ba107YH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3RbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgOmBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHt2fTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHskfTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtifTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7dn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7JH07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICR7dnMobixhKX1cbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2J9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7YT9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke1VkKG4pfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7eX0+LCAke2d9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7bX0+LCAke3N9PjtcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbiAgY29uc3QgdGlsZUlubmVyID0gJHtzfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7dT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgICAke2E/YGxldCBiYXRjaEluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICAgIGxldCBudW1UaWxlcyA9ICR7dT9gJHtNYXRoLmNlaWwobC9zKX1gOlwiKGRpbUlubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICAgIHZhciBrU3RhcnQgPSAke3U/YGkzMihnbG9iYWxJZC56KSAqICR7bH1gOlwiMFwifTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuXG4gICAgLy8gV2l0aG91dCB0aGlzIGluaXRpYWxpemF0aW9uIHN0cmFuZ2UgdmFsdWVzIHNob3cgdXAgaW4gYWNjLlxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IDAuMDtcbiAgICAgIH1cbiAgICB9XG4gICAgJHtTfVxuICB9XG5gfSxHZD0oZSx0LHIsYSxuLHM9ITEpPT57bGV0IHU9blswXSxsPW5bMV0sbz1uWzJdLHA9YVswXSxtPWFbMV0seT1hWzJdLGc9YVszXSx2PUtuKHUsbyksJD1LbihsLG8pLGI9QmUoYVswXS50eXBlLnRlbnNvciksUz0oKT0+e2xldCBCPW0ucmFuayxQPXAucmFuayxEPWB2YXIgYUluZGljZXM6ICR7bS50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBSPUItMi0xLFc9UC0xO1I+PTA7Ui0tLFctLSlEKz1gXG5hSW5kaWNlc1ske1J9XSA9ICR7UD4xP2BiYXRjaEluZGljZXNbJHtXfV1gOlwiYmF0Y2hJbmRpY2VzXCJ9O2A7cmV0dXJuIHYuZm9yRWFjaChSPT57RCs9YFxuYUluZGljZXNbJHtSfV0gPSAwO2B9KSxEKz1gXG5hSW5kaWNlc1ske0ItMn1dID0gdTMyKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgYUluZGljZXNbJHtCLTF9XSA9IHUzMihjb2xJbik7YCxEfSxJPSgpPT57bGV0IEI9eS5yYW5rLFA9cC5yYW5rLEQ9YHZhciBiSW5kaWNlczogJHt5LnR5cGUuaW5kaWNlc307YDtmb3IobGV0IFI9Qi0yLTEsVz1QLTE7Uj49MDtSLS0sVy0tKUQrPWBcbmJJbmRpY2VzWyR7Un1dID0gJHtQPjE/YGJhdGNoSW5kaWNlc1ske1d9XWA6XCJiYXRjaEluZGljZXNcIn07YDtyZXR1cm4gJC5mb3JFYWNoKFI9PntEKz1gXG5iSW5kaWNlc1ske1J9XSA9IDA7YH0pLEQrPWBcbmJJbmRpY2VzWyR7Qi0yfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBiSW5kaWNlc1ske0ItMX1dID0gdTMyKGNvbEluKTtgLER9O3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke3AudHlwZS5pbmRpY2VzfSkgLT4gJHtXZShlLGIpfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke1dlKGUsYil9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUlubmVyKVxuICAgICAge1xuICAgICAgICAke1MoKX1cbiAgICAgICAgdmFsdWUgPSAke20uZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7cC50eXBlLmluZGljZXN9KSAtPiAke1dlKGUsYil9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7V2UoZSxiKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXIpXG4gICAgICB7XG4gICAgICAgICR7SSgpfVxuICAgICAgICB2YWx1ZSA9ICR7eS5nZXRCeUluZGljZXMoXCJiSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7V2UoZSxiKX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcbiAgICAgICAgJHt0P2B2YWx1ZSA9IHZhbHVlICsgJHtzP1wiYmlhc1tjb2xJbl1cIjpgJHtXZShlLGIpfShiaWFzW3Jvd10pYH07YDpcIlwifVxuICAgICAgICAke3J9XG4gICAgICAgICR7Zy5zZXRCeUluZGljZXMoXCJ2ZWMzPHUzMj4oY29vcmRzKVwiLFwidmFsdWVcIil9XG4gICAgICB9XG4gICAgfVxuICAgIGB9LGNuPShlLHQscixhLG49ITEpPT57bGV0IHM9ZVswXS5kaW1zLHU9ZVsxXS5kaW1zLGw9cy5zbGljZSgwLC0yKSxvPXUuc2xpY2UoMCwtMikscD1hP2Euc2xpY2UoMCwtMik6ci5zbGljZSgwLC0yKSxtPUYoXCJiYXRjaERpbXNcIixlWzBdLmRhdGFUeXBlLHApLHk9W21dLGc9W2wsbyxwXSx2PXouc2l6ZShwKSwkPXNbcy5sZW5ndGgtMl0sYj1zW3MubGVuZ3RoLTFdLFM9dVt1Lmxlbmd0aC0xXSxJPWIlND09PTAmJlMlND09PTAse2FjdGl2YXRpb25GdW5jdGlvbjpULGFwcGx5QWN0aXZhdGlvbjpCfT1sbih0LEkpLFA9JDw9OD9bNCwxLDFdOls0LDQsMV0sRD1bOCw4LDFdLFI9W01hdGguY2VpbChTL0RbMF0vUFswXSksTWF0aC5jZWlsKCQvRFsxXS9QWzFdKSxNYXRoLmNlaWwodi9EWzJdL1BbMl0pXSxXPUJlKGVbMF0uZGF0YVR5cGUpLEg9ST80OjEsSz1GKFwiYVwiLGVbMF0uZGF0YVR5cGUsWy4uLmwsJCxiL0hdLEgpLGxlPUYoXCJiXCIsZVsxXS5kYXRhVHlwZSxbLi4ubyxiLFMvSF0sSCksTT1YKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxbdiwkLFMvSF0sSCk7eS5wdXNoKEspLHkucHVzaChsZSkseS5wdXNoKE0pO2xldCBxPVtLLGxlXSx4ZT1lLmxlbmd0aD4yLG9lPUdkKEgseGUsQix5LGcsbik7aWYoeGUpe2xldCBqPW4/SDoxO3EucHVzaChGKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGopKX1sZXQgd2U9aj0+YFxuICBjb25zdCBkaW1BT3V0ZXI6IGkzMiA9ICR7JH07XG4gIGNvbnN0IGRpbUJPdXRlcjogaTMyID0gJHtTfTtcbiAgY29uc3QgZGltSW5uZXI6IGkzMiA9ICR7Yn07XG4gICR7ai5kZWNsYXJlVmFyaWFibGVzKC4uLnEsTSl9XG4gICR7VH1cbiAgJHtvZX1cbiAgJHtJP2dyKFAsRCxXLG0pOnlyKFAsRCxXLG0pfVxuICAgICAgICAgICAgICAgICAgICR7bS5pbXBsKCl9YDtyZXR1cm57bmFtZTpcIk1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OnQuYWN0aXZhdGlvbkNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6UlswXSx5OlJbMV0sejpSWzJdfX0pLGdldFNoYWRlclNvdXJjZTp3ZX19fSk7dmFyIEZkLCRzLHhzPUwoKCk9PntcInVzZSBzdHJpY3RcIjt4dCgpO2dlKCk7dmUoKTtzbigpO1puKCk7YnIoKTtGZD0oZSx0LHIsYSxuPSExLHMsdT0hMSxsPTQsbz00LHA9NCxtPVwiZjMyXCIpPT57bGV0IHk9bGU9Pntzd2l0Y2gobGUpe2Nhc2UgMTpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleF07XCI7Y2FzZSAzOnJldHVybmByZXNEYXRhID0gdmVjMzwke219Pih4W3hJbmRleF0sIHhbeEluZGV4ICsgMV0sIHhbeEluZGV4ICsgMl0pO2A7Y2FzZSA0OnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4IC8gNF07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtsZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGc9bGU9Pntzd2l0Y2gobGUpe2Nhc2UgMTpyZXR1cm5cInJldHVybiB3W3JvdyAqIHdTaGFwZVszXSArIGNvbEluXTtcIjtjYXNlIDQ6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiB3U2hhcGVbM10gLyA0ICsgY29sSW5dO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7bGV9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx2PWU/YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XG4gICAgYCwkPWU/YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGAsYj1lP1wieFNoYXBlWzFdXCI6XCJ4U2hhcGVbMl1cIixTPWU/XCJ4U2hhcGVbMl1cIjpcInhTaGFwZVszXVwiLEk9ZT9cInJvd1wiOlwiY29sXCIsVD1lP1wiY29sXCI6XCJyb3dcIixCPWBcbiAgICBsZXQgaW5DaGFubmVscyA9IHdTaGFwZVsyXTtcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XG4gICAgbGV0IG91dFJvdyA9ICR7SX0gLyBvdXRXaWR0aDtcbiAgICBsZXQgb3V0Q29sID0gJHtJfSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAke1R9IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7VH0gLyBpbkNoYW5uZWxzICUgZmlsdGVyRGltc1sxXTtcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHN0cmlkZVswXSArIGRpbGF0aW9uWzBdICogV1JvdyAtIHBhZFswXTtcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHN0cmlkZVsxXSArIGRpbGF0aW9uWzFdICogV0NvbCAtIHBhZFsxXTtcbiAgICBsZXQgeENoID0gJHtUfSAlIGluQ2hhbm5lbHM7XG4gICAgdmFyIHJlc0RhdGEgPSAke1dlKGwsbSl9KDAuMCk7XG4gICAgLy8gVGhlIGJvdW5kcyBjaGVja2luZyBpcyBhbHdheXMgbmVlZGVkIHNpbmNlIHdlIHVzZSBpdCB0byBwYWQgemVybyBmb3JcbiAgICAvLyB0aGUgJ3NhbWUnIHBhZGRpbmcgdHlwZS5cbiAgICBpZiAoeFJvdyA+PSAwICYmIHhSb3cgPCAke2J9ICYmIHhDb2wgPj0gMCAmJiB4Q29sIDwgJHtTfSkge1xuICAgICAgJHt2fVxuICAgICAgbGV0IHhJbmRleCA9IGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB4U2hhcGUpO1xuICAgICAgJHt5KGwpfVxuICAgIH1cbiAgICByZXR1cm4gcmVzRGF0YTtgLFA9ZT90JiZhP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2x9O1xuICAgICR7Qn1gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2x9O1xuICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltSW5uZXIpIHtcbiAgICAgICR7Qn1cbiAgICB9XG4gICAgcmV0dXJuICR7V2UobCxtKX0oMC4wKTtgOmEmJnI/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgJHtCfWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgaWYgKHJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xuICAgICAgJHtCfVxuICAgIH1cbiAgICByZXR1cm4gJHtXZShsLG0pfSgwLjApO2AsRD1gJHtnKG8pfWAsUj1XZShwLG0pLFc9ZT9XZShsLG0pOldlKG8sbSksSD1lP1dlKG8sbSk6V2UobCxtKTtyZXR1cm5gXG4gICAgJHthbihzLHUscD09PTQsNCl9XG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtXfSB7XG4gICAgICAke2U/UDpEfVxuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7SH0ge1xuICAgICAgJHtlP0Q6UH1cbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtSfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtwfTtcbiAgICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltQk91dGVyKVxuICAgICAge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcbiAgICAgICR7JH1cbiAgICAgICR7b24obixzKX1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gfSwkcz0oZSx0LHIsYSxuLHMsdSxsKT0+e2xldCBvPXQuZm9ybWF0PT09XCJOSFdDXCIscD1vP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sbT1yWzBdLHk9bz9yWzJdOnJbM10sZz1vP3JbMV06clsyXSx2PW8/clszXTpyWzFdLCQ9byYmKHAlND09PTB8fHAlMz09PTApJiZ2JTQ9PT0wLGI9bz92OnkqZyxTPW8/eSpnOnYsST1bOCw4LDFdLFQ9YTw9OD9bNCwxLDFdOls0LDQsMV0sQj1bTWF0aC5jZWlsKGIvSVswXS9UWzBdKSxNYXRoLmNlaWwoUy9JWzFdL1RbMV0pLE1hdGguY2VpbChtL0lbMl0vVFsyXSldO19lKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtCfWApO2xldCBQPSQ/byYmcCU0IT09MD8zOjQ6VFswXSxEPUlbMV0qVFsxXSxSPUlbMF0qVFswXSxXPU1hdGgubWF4KElbMF0qUCxJWzFdKSxIPWElRD09PTAsSz1uJVI9PT0wLGxlPXMlVz09PTAsTT0kP1tQLDQsNF06WzEsMSwxXSxxPUJlKGVbMF0uZGF0YVR5cGUpLHhlPVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4OiBhcnJheTwkeyQmJlA9PT00P2B2ZWM0PCR7cX0+YDpxfT47YCxgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiB3OiBhcnJheTwkeyQ/YHZlYzQ8JHtxfT5gOnF9PjtgXSxvZT1gXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAkeyQ/YHZlYzQ8JHtxfT5gOnF9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHskP2B2ZWM0PCR7cX0+YDpxfSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAkeyQ/YHZlYzQ8JHtxfT5gOnF9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7JD9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XG4gICAgICB9YDtyZXR1cm4gdSYmKHhlLnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhczogYXJyYXk8JHskP2B2ZWM0PCR7cX0+YDpxfT47YCksb2UrPWBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHskP2B2ZWM0PCR7cX0+YDpxfSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7bz9cIndcIjpcInlcIn0keyQ/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gKSx7bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpCWzBdLHk6QlsxXSx6OkJbMl19fSksZ2V0U2hhZGVyU291cmNlOigpPT5gXG4gICAgICAgICR7dW59XG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxuICAgICAgICAvLyAgb3V0U2hhcGVTdHJpZGVzOiB2ZWMzPGkzMj4sIGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4sIHBhZCA6IHZlYzI8aTMyPiwgc3RyaWRlIDogdmVjMjxpMzI+LFxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xuICAgICAgICAke3hlLmpvaW4oXCJcIil9XG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygke3hlLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PCR7JD9gdmVjNDwke3F9PmA6cX0+O1xuICAgICAgICAvL0Bncm91cCgwKSBAYmluZGluZygke3hlLmxlbmd0aCsxfSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAgICAgICBjb25zdCB4U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzBdLmRpbXMuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgd1NoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVsxXS5kaW1zLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IG91dFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ci5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBvdXRTaGFwZVN0cmlkZXMgOiB2ZWMzPGkzMj4gPSB2ZWMzPGkzMj4oJHt6LmNvbXB1dGVTdHJpZGVzKHIpLnNsaWNlKDAsMykuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3QgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Qua2VybmVsU2hhcGVbMF19LCAke3Qua2VybmVsU2hhcGVbMV19KTtcbiAgICAgICAgY29uc3QgcGFkIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5wYWRzWzBdfSwgJHt0LnBhZHNbMV19KTtcbiAgICAgICAgY29uc3Qgc3RyaWRlIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5zdHJpZGVzWzBdfSwgJHt0LnN0cmlkZXNbMV19KTtcbiAgICAgICAgY29uc3QgZGlsYXRpb24gOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LmRpbGF0aW9uc1swXX0sICR7dC5kaWxhdGlvbnNbMV19KTtcbiAgICAgICAgY29uc3QgZGltQU91dGVyIDogaTMyID0gJHthfTtcbiAgICAgICAgY29uc3QgZGltQk91dGVyIDogaTMyID0gJHtufTtcbiAgICAgICAgY29uc3QgZGltSW5uZXIgOiBpMzIgPSAke3N9O1xuICAgICAgICAke29lfVxuICAgICAgICAke0ZkKG8sSCxLLGxlLHUsdC5hY3RpdmF0aW9uLnRvTG93ZXJDYXNlKCksITEsTVswXSxNWzFdLE1bMl0scSl9XG4gICAgICAgICAgICAkeyQ/Z3IoVCxJLHEsdm9pZCAwLCFvLFcpOnlyKFQsSSxxLHZvaWQgMCwhbyxXLCExLHZvaWQgMCxsKX1gfX19KTt2YXIgZWEsU3M9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtyYSgpO2hyKCk7ZWE9KGUsdCxyKT0+e2xldCBhPWUubGVuZ3RoPjIsbj1hP1widmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07XCI6XCJcIixzPWVbMF0uZGltcyx1PWVbMV0uZGltcyxsPXVbMF0vdC5ncm91cCx7YWN0aXZhdGlvbkZ1bmN0aW9uOm8sYXBwbHlBY3RpdmF0aW9uOnB9PWxuKHQpLG09dC5mb3JtYXQ9PT1cIk5IV0NcIix5PXRhKHMsdSx0LmRpbGF0aW9ucyx0LnBhZHMsdC5zdHJpZGVzLG0pLGc9ei5zaXplKHkpLHY9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUseSksJD1GKFwieFwiLGVbMF0uZGF0YVR5cGUscyksYj1GKFwid1wiLGVbMV0uZGF0YVR5cGUsdSksUz1bJCxiXTthJiZTLnB1c2goRihcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcykpO2xldCBJPVQ9PmBcbiAgY29uc3Qgc3RyaWRlczogdmVjMjx1MzI+ID0gdmVjMigke3Quc3RyaWRlc1swXX11LCAke3Quc3RyaWRlc1sxXX11KTtcbiAgY29uc3QgcGFkczogdmVjMjx1MzI+ID0gdmVjMigke3QucGFkc1swXX11LCAke3QucGFkc1sxXX11KTtcblxuICAke1QuZGVjbGFyZVZhcmlhYmxlcyguLi5TLHYpfVxuXG4gICR7b31cblxuICAke1QubWFpblN0YXJ0KCl9XG4gICAgJHtULmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZyl9XG5cbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7di5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7bT8zOjF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske20/MToyfV0sIG91dHB1dEluZGljZXNbJHttPzI6M31dKSAqIHN0cmlkZXMgLSBwYWRzO1xuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgLyAke2x9dTtcblxuICAgIHZhciB2YWx1ZTogJHt2LnR5cGUudmFsdWV9ID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgJHt1WzFdfXU7IHdJbkNoYW5uZWwrKykge1xuICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7dVsxXX11ICsgd0luQ2hhbm5lbDtcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgJHt1WzJdfXU7IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqICR7dC5kaWxhdGlvbnNbMF19dTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gJHtzW20/MToyXX11KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCAke3VbM119dTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3QuZGlsYXRpb25zWzFdfXU7XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSAke3NbbT8yOjNdfXUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB4VmFsID0gJHttPyQuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKTokLmdldChcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIil9O1xuICAgICAgICAgIGxldCB3VmFsID0gJHtiLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAke259XG4gICAgJHtwfVxuICAgICR7di5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YDtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyP3IoeSk6eSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZy82NCl9fSksZ2V0U2hhZGVyU291cmNlOkl9fX0pO3ZhciB0YSxDcyxMZCxJcyxuYSxIZCxqZCxhYSxyYT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3hzKCk7YnIoKTtTcygpO2hyKCk7bXIoKTt0YT0oZSx0LHIsYSxuLHMpPT57bGV0IHU9ZVswXSxsPWUuc2xpY2Uocz8xOjIscz8zOjQpLG89bC5sZW5ndGgscD10WzBdLHk9dC5zbGljZSgyKS5tYXAoKCQsYik9PiQrKCQtMSkqKHJbYl0tMSkpLHY9bC5tYXAoKCQsYik9PiQrYVtiXSthW2Irb10pLm1hcCgoJCxiKT0+TWF0aC5mbG9vcigoJC15W2JdK25bYl0pL25bYl0pKTtyZXR1cm4gdi5zcGxpY2UoMCwwLHUpLHYuc3BsaWNlKHM/MzoxLDAscCksdn0sQ3M9WzIsMywxLDBdLExkPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCBjb252IDFEIGFuZCAyRFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sYT1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihyIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgbj1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtufURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5wYWRzLmxlbmd0aCE9PW4qMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7bioyfURgKTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpfSxJcz0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtmb3IobGV0IHM9MjtzPHRbMV0uZGltcy5sZW5ndGg7KytzKXJbcy0yXT09PTAmJihyW3MtMl09dFsxXS5kaW1zW3NdKTtsZXQgYT1lLnBhZHMuc2xpY2UoKTtNdC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxyLGEsZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBuPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obix7a2VybmVsU2hhcGU6cixwYWRzOmEsY2FjaGVLZXk6ZS5jYWNoZUtleX0pLG59LG5hPWU9PntsZXQgdD1kbihlKSxyPWUuZm9ybWF0LGE9W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxuPWUuZGlsYXRpb25zLHM9ZS5ncm91cCx1PWUua2VybmVsX3NoYXBlLGw9ZS5wYWRzLG89ZS5zdHJpZGVzLHA9ZS53X2lzX2NvbnN0KCk7cmV0dXJuIGllKHthdXRvUGFkOmEsZm9ybWF0OnIsZGlsYXRpb25zOm4sZ3JvdXA6cyxrZXJuZWxTaGFwZTp1LHBhZHM6bCxzdHJpZGVzOm8sd0lzQ29uc3Q6cCwuLi50fSl9LEhkPShlLHQscik9PntsZXQgYT1JcyhyLHQpO2lmKHIuZ3JvdXAhPT0xKXtlLmNvbXB1dGUoZWEodCxhKSk7cmV0dXJufWxldCBuPXIuZm9ybWF0PT09XCJOSFdDXCIscz10Lmxlbmd0aD09PTMsdT10WzBdLmRpbXNbbj8xOjJdLGw9dFswXS5kaW1zW24/MjozXSxvPXRbMF0uZGltc1tuPzM6MV0scD10WzFdLmRpbXNbMl0sbT10WzFdLmRpbXNbM10seT10YSh0WzBdLmRpbXMsdFsxXS5kaW1zLHIuZGlsYXRpb25zLGEucGFkcyxyLnN0cmlkZXMsbiksZz15W24/MToyXSx2PXlbbj8yOjNdLCQ9eVtuPzM6MV0sYj1uJiZwPT09dSYmbT09PWwmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTA7aWYoYnx8cD09PTEmJm09PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MSYmci5zdHJpZGVzWzBdPT09MSYmci5zdHJpZGVzWzFdPT09MSYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MCl7bGV0IFI9eVswXSxXLEgsSyxsZT1bXTtpZihuKXtsZXQgTT1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShDdCh0WzFdLENzKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO2lmKHIud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9TSksYil7bGV0IHE9dSpsKm87Vz10WzBdLnJlc2hhcGUoWzEsUixxXSksSD1NLnJlc2hhcGUoWzEscSwkXSksSz1bMSxSLCRdfWVsc2UgVz10WzBdLnJlc2hhcGUoW1IsdSpsLG9dKSxIPU0ucmVzaGFwZShbMSxvLCRdKSxLPVtSLGcqdiwkXTtsZS5wdXNoKFcpLGxlLnB1c2goSCl9ZWxzZSBXPXRbMF0ucmVzaGFwZShbUixvLHUqbF0pLEg9dFsxXS5yZXNoYXBlKFsxLCQsb10pLEs9W1IsJCxnKnZdLGxlLnB1c2goSCksbGUucHVzaChXKTtzJiZsZS5wdXNoKHRbMl0pLGUuY29tcHV0ZShjbihsZSxhLHksSyxuKSx7aW5wdXRzOmxlfSk7cmV0dXJufWxldCBTPSEwLEk9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoQ3QodFsxXSxDcykse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPUkpO2xldCBUPVt0WzBdLEldO3MmJlQucHVzaCh0WzJdKTtsZXQgQj1uP2cqdjokLFA9bj8kOmcqdixEPXAqbSpvO2UuY29tcHV0ZSgkcyhULGEseSxCLFAsRCxzLFMpLHtpbnB1dHM6VH0pfSxqZD0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsYT1bZS5pbnB1dHNbMF0ucmVzaGFwZShyP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmYS5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbj1bMCx0LnBhZHNbMF0sMCx0LnBhZHNbMV1dLHM9WzFdLmNvbmNhdCh0LnN0cmlkZXMpLHU9WzFdLmNvbmNhdCh0LmRpbGF0aW9ucyksbD1bMV0uY29uY2F0KHQua2VybmVsU2hhcGUpLG89SXMoey4uLnQscGFkczpuLHN0cmlkZXM6cyxkaWxhdGlvbnM6dSxrZXJuZWxTaGFwZTpsfSxhKTtlLmNvbXB1dGUoZWEoYSxvLHA9PnI/W3BbMF0scFsyXSxwWzNdXTpbXSkpfSxhYT0oZSx0KT0+e0xkKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Mz9qZChlLHQpOkhkKGUsZS5pbnB1dHMsdCl9fSk7dmFyIHFkLEFzLEVzPUwoKCk9PntcInVzZSBzdHJpY3RcIjt4dCgpO2dlKCk7c24oKTtabigpO2JyKCk7cWQ9KGUsdD0hMSxyLGE9ITEsbj00KT0+e2xldCBzPVdlKG4sXCJmMzJcIiksdT1JPT57c3dpdGNoKEkpe2Nhc2UgMTpyZXR1cm5cInJldHVybiBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB3U2hhcGUpXTtcIjtjYXNlIDQ6cmV0dXJuYFxuICAgICAgICAgICAgbGV0IGNvb3JkMSA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMSwgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IGNvb3JkMiA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMiwgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IGNvb3JkMyA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMywgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IHYwID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgd1NoYXBlKV07XG4gICAgICAgICAgICBsZXQgdjEgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMSwgd1NoYXBlKV07XG4gICAgICAgICAgICBsZXQgdjIgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMiwgd1NoYXBlKV07XG4gICAgICAgICAgICBsZXQgdjMgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMywgd1NoYXBlKV07XG4gICAgICAgICAgICByZXR1cm4gdmVjNDxmMzI+KHYwLCB2MSwgdjIsIHYzKTtcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtJfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sbD1lP2BcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgaVhSLCBpWEMsIHhDaCk7XG4gICAgICBgOmBcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCBpWFIsIGlYQyk7XG4gICAgICBgLG89ZT9gXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93LFxuICAgICAgY29sIC8gb3V0V2lkdGgsXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XG4gICAgYCxwPWU/XCJvdXRCYWNrcHJvcFsxXVwiOlwib3V0QmFja3Byb3BbMl1cIixtPWU/XCJvdXRCYWNrcHJvcFsyXVwiOlwib3V0QmFja3Byb3BbM11cIix5PWU/XCJyb3dcIjpcImNvbFwiLGc9ZT9cImNvbFwiOlwicm93XCIsdj1gXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7ZT9cIm91dEJhY2twcm9wWzNdXCI6XCJvdXRCYWNrcHJvcFsxXVwifTtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcbiAgICAgIGxldCBvdXRSb3cgPSAke3l9IC8gb3V0V2lkdGg7XG4gICAgICBsZXQgb3V0Q29sID0gJHt5fSAlIG91dFdpZHRoO1xuXG4gICAgICBsZXQgV1JvdyA9ICR7Z30gLyAoZmlsdGVyRGltc1sxXSAqIGluQ2hhbm5lbHMpO1xuICAgICAgbGV0IFdDb2wgPSAke2d9IC8gaW5DaGFubmVscyAlIGZpbHRlckRpbXNbMV07XG4gICAgICBsZXQgeFIgPSBmMzIob3V0Um93IC0gcGFkc1swXSArIGRpbGF0aW9uWzBdICogV1JvdykgLyBmMzIoc3RyaWRlc1swXSk7XG4gICAgICBsZXQgeEMgPSBmMzIob3V0Q29sIC0gcGFkc1sxXSArIGRpbGF0aW9uWzFdICogV0NvbCkgLyBmMzIoc3RyaWRlc1sxXSk7XG4gICAgICBpZiAoeFIgPCAwLjAgfHwgeFIgPj0gZjMyKCR7cH0pIHx8IGZyYWN0KHhSKSA+IDAuMCkge1xuICAgICAgICByZXR1cm4gJHtzfSgwLjApO1xuICAgICAgfVxuICAgICAgaWYgKHhDIDwgMC4wIHx8IHhDID49IGYzMigke219KSB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7c30oMC4wKTtcbiAgICAgIH1cbiAgICAgIGxldCBpWFIgPSBpMzIoeFIpO1xuICAgICAgbGV0IGlYQyA9IGkzMih4Qyk7XG4gICAgICBsZXQgeENoID0gJHtnfSAlIGluQ2hhbm5lbHM7XG4gICAgICAke2x9XG4gICAgICByZXR1cm4geFtnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgeFNoYXBlKS8ke259XTtgLCQ9ZT9gXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xuICAgICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1Jbm5lcikge1xuICAgICAgICAke3Z9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHtzfSgwLjApO2A6YFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcbiAgICAgIGlmIChyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcbiAgICAgICAgJHt2fVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7c30oMC4wKTtgLGI9YFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtlP1wib3V0QmFja3Byb3BbM11cIjpcIm91dEJhY2twcm9wWzFdXCJ9O1xuICAgICAgbGV0IGNvb3JkWCA9IGZpbHRlckRpbXMueCAtIDEgLSByb3cgLyAoZmlsdGVyRGltc1sxXSAqIGluQ2hhbm5lbHMpO1xuICAgICAgbGV0IGNvb3JkWSA9IGZpbHRlckRpbXMueSAtIDEgLSAocm93IC8gaW5DaGFubmVscykgJSBmaWx0ZXJEaW1zWzFdO1xuICAgICAgaWYgKCR7ZT9cInJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlclwiOlwicm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQU91dGVyXCJ9ICAmJiBjb29yZFggPj0gMCAmJiBjb29yZFkgPj0gMCkge1xuICAgICAgICBsZXQgcm93SW5uZXIgPSByb3cgJSBpbkNoYW5uZWxzO1xuICAgICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCwgcm93SW5uZXIpO1xuICAgICAgICAke3Uobil9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHtzfSgwLjApO1xuICAgICAgYDtyZXR1cm5gXG4gICR7YW4ocixhLG49PT00LDQpfVxuICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3N9IHtcbiAgICAke2U/JDpifVxuICB9XG5cbiAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtzfSB7XG4gICAgJHtlP2I6JH1cbiAgfVxuXG4gIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW5wdXQgOiAke3N9KSB7XG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcbiAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbnB1dDtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcbiAgICAgICR7b31cbiAgICAgICR7b24odCxyKX1cbiAgICAgIHJlc3VsdFtnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMsIG91dFNoYXBlKS8ke259XSA9IHZhbHVlO1xuICAgIH1cbiAgfWB9LEFzPShlLHQscixhLG4scyx1LGwpPT57bGV0IG89dC5mb3JtYXQ9PT1cIk5IV0NcIixwPW8/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxtPXJbMF0seT1vP3JbMl06clszXSxnPW8/clsxXTpyWzJdLHY9bz9yWzNdOnJbMV0sJD1vP3AlND09PTAmJnYlND09PTA6eSU0PT09MCYmdiU0PT09MCxiPW8/djp5KmcsUz1vP3kqZzp2LEk9JD9bOCw4LDFdOltiPD00fHxTPD00PzQ6MTYsYj40JiZTPD00PzQ6MTYsMV0sVD0kP1s0LDQsMV06W2I8PTQ/MTo0LGI+NCYmUzw9ND8xOjQsMV0sQj1bTWF0aC5jZWlsKGIvSVswXS9UWzBdKSxNYXRoLmNlaWwoUy9JWzFdL1RbMV0pLE1hdGguY2VpbChtL0lbMl0vVFsyXSldO19lKFwidmVyYm9zZVwiLCgpPT5gW2NvbnZfYmFja3Byb3BfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7Qn1gKTtsZXQgUD0kPzQ6MSxEPU1hdGgubWF4KElbMF0qUCxJWzFdKSxSPVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4OiBhcnJheTwkeyQ/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifT47YCxcIkBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gVzogYXJyYXk8ZjMyPjtcIl0sVz1cIlwiO3JldHVybiB1JiYoUi5wdXNoKGBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJpYXM6IGFycmF5PCR7JD9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtgKSxXKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7JD9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtvP1wid1wiOlwieVwifSR7JD9cIi8gNFwiOlwiXCJ9XTtcbiAgICAgICAgfWApLHtuYW1lOlwiQ29udjJEVHJhbnNwb3NlTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OkJbMF0seTpCWzFdLHo6QlsyXX19KSxnZXRTaGFkZXJTb3VyY2U6KCk9PmBcbiAgICAgICAgJHt1bn1cbiAgICAgICAgJHtSLmpvaW4oYFxuYCl9XG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygke1IubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdDogYXJyYXk8JHskP1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O1xuICAgICAgICBjb25zdCBvdXRCYWNrcHJvcCA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCB4U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzBdLmRpbXMuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgd1NoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVsxXS5kaW1zLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IG91dFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ci5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBvdXRTaGFwZVN0cmlkZXMgOiB2ZWMzPGkzMj4gPSB2ZWMzPGkzMj4oJHt6LmNvbXB1dGVTdHJpZGVzKHIpLnNsaWNlKDAsMykuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3QgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Qua2VybmVsU2hhcGVbbz8xOjJdfSwgJHt0Lmtlcm5lbFNoYXBlW28/MjozXX0pO1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gZmlsdGVyRGltcyArIHZlYzI8aTMyPihcbiAgICAgICAgICAgICAgJHt0LmRpbGF0aW9uc1swXTw9MT8wOih0Lmtlcm5lbFNoYXBlW28/MToyXS0xKSoodC5kaWxhdGlvbnNbMF0tMSl9LFxuICAgICAgICAgICAgICAke3QuZGlsYXRpb25zWzFdPD0xPzA6KHQua2VybmVsU2hhcGVbbz8yOjNdLTEpKih0LmRpbGF0aW9uc1sxXS0xKX0pO1xuICAgICAgICBjb25zdCBwYWRzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdKSAtIDEgLSAoJHt0LnBhZHNbMF0rdC5wYWRzWzJdfSkvMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0pIC0gMSAtICgke3QucGFkc1sxXSt0LnBhZHNbM119KS8yKTtcbiAgICAgICAgY29uc3Qgc3RyaWRlcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Quc3RyaWRlc1swXX0sICR7dC5zdHJpZGVzWzFdfSk7XG4gICAgICAgIGNvbnN0IGRpbGF0aW9uIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5kaWxhdGlvbnNbMF19LCAke3QuZGlsYXRpb25zWzFdfSk7XG4gICAgICAgIGNvbnN0IGRpbUFPdXRlciA6IGkzMiA9ICR7YX07XG4gICAgICAgIGNvbnN0IGRpbUJPdXRlciA6IGkzMiA9ICR7bn07XG4gICAgICAgIGNvbnN0IGRpbUlubmVyIDogaTMyID0gJHtzfTtcbiAgICAgICAgJHtXfVxuICAgICAgICAke3FkKG8sdSx0LmFjdGl2YXRpb24udG9Mb3dlckNhc2UoKSwhMSxQKX1cbiAgICAgICAgJHskP2dyKFQsSSxcImYzMlwiLHZvaWQgMCwhbyxEKTp5cihULEksXCJmMzJcIix2b2lkIDAsIW8sRCwhMSx2b2lkIDAsbCl9YH19fSk7dmFyIEtkLG9hLF9zPUwoKCk9PntcInVzZSBzdHJpY3RcIjt4dCgpO2dlKCk7dmUoKTtLZD0oZSx0LHIsYSxuLHMsdT0hMSxsKT0+e2xldCBvPXIuZm9ybWF0PT09XCJOSFdDXCIscD1vPzE6MixtPW8/MjozLHk9bz8zOjEsZz16LnNpemUoYSksdj11PzI6MSwkPXIuZ3JvdXAsYj10WzFdLmRpbXMsUz1iWzBdLyQsST1iWzFdLFQ9YFxuICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IHUzMiwgdmFsdWUgOiAke3U/YHZlYzQ8JHtsfT5gOmx9KSB7XG4gICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3U/YHZlYzQ8JHtsfT5gOmx9KHZhbHVlKTtcbiAgfWA7biYmKFQrPWBcbiAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDx1MzI+KSAtPiAke3U/YHZlYzQ8JHtsfT5gOmx9IHtcbiAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke28/XCJ3XCI6XCJ5XCJ9JHt1P1wiLyA0XCI6XCJcIn1dO1xuICAgIH1gKTtsZXQgQj11PzQ6MSxQPUYoXCJXXCIsdFsxXS5kYXRhVHlwZSx0WzFdLmRpbXMsQiksRD1GKFwiRHlcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyxCKSxSPVtELFBdO24mJlIucHVzaChGKFwiYmlhc1wiLHRbMl0uZGF0YVR5cGUsW2FbeV1dLEIpKTtsZXQgVz1YKFwicmVzdWx0XCIsdFswXS5kYXRhVHlwZSxhLEIpLEg9YHtcbiAgICAgICAgbGV0IGJhdGNoOiB1MzIgPSAke3M/XCJnbG9iYWxfaWQuelwiOlwid29ya2dyb3VwX2lkLnpcIn0gLyBvdXRTaGFwZVsxXTtcbiAgICAgICAgbGV0IHIgPSAke3M/XCJnbG9iYWxfaWQuelwiOlwid29ya2dyb3VwX2lkLnpcIn0gJSBvdXRTaGFwZVsxXTtcbiAgICAgICAgbGV0IGMgPSAke3M/XCJnbG9iYWxfaWQueVwiOlwid29ya2dyb3VwX2lkLnlcIn0gKiAke3Z9O1xuICAgICAgICBsZXQgZDE6IHUzMiA9ICR7cz9cImdsb2JhbF9pZC54XCI6XCJ3b3JrZ3JvdXBfaWQueFwifSAqIDQ7XG5cbiAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHZlYzI8aTMyPihwYWRzKTtcblxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgIHZhciBkb3RQcm9kOiBhcnJheTx2ZWM0PCR7bH0+LCAke3Z9PjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3Z9OyBpKyspIHtcbiAgICAgICAgICBkb3RQcm9kW2ldID0gdmVjNDwke2x9PigwLjApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IGZpbHRlckRpbXNbMF07IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgdmFyIGR5UiA9ICgke2x9KGR5Q29ybmVyLngpICsgJHtsfSh3UikpIC8gJHtsfShzdHJpZGVzLngpO1xuICAgICAgICAgIGxldCB3UlBlcm0gPSBmaWx0ZXJEaW1zWzBdIC0gMSAtIHdSO1xuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7bH0ob3V0QmFja3Byb3BbMV0pIHx8XG4gICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjAgfHwgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcblxuICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IGZpbHRlckRpbXNbMV07IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICBsZXQgZHlDID0gKCR7bH0oZHlDb3JuZXIueSkgKyAke2x9KHdDKSkgLyAke2x9KHN0cmlkZXMueSk7XG4gICAgICAgICAgICBsZXQgZHlDMiA9ICgke2x9KGR5Q29ybmVyLnkpICsgMS4wICsgJHtsfSh3QykpIC8gJHtsfShzdHJpZGVzLnkpO1xuICAgICAgICAgICAgbGV0IHdDUGVybSA9IGZpbHRlckRpbXNbMV0gLSAxIC0gd0M7XG4gICAgICAgICAgICBpZiAod0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiRHlDVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBiRHlDVmFsMiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2x9KG91dEJhY2twcm9wWzJdKSB8fFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcbiAgICAgICAgICAgICAgYkR5Q1ZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5QzIgPCAwLjAgfHwgZHlDMiA+PSAke2x9KG91dEJhY2twcm9wWzJdKSB8fFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QzIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGJEeUNWYWwyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgIGxldCBpZHlDMjogdTMyID0gdTMyKGR5QzIpO1xuICAgICAgICAgICAgaWYgKGJEeUNWYWwgJiYgYkR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbM107XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyIDp1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2x9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG5cbiAgICAgICAgICAgICAgICB4VmFsdWUgPSAgJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDMlwiLFwiZDJcIil9O1xuXG4gICAgICAgICAgICAgICAgZG90UHJvZFsxXSA9IGRvdFByb2RbMV0gKyB2ZWM0PCR7bH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsKSB7XG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IG91dEJhY2twcm9wWyR7eX1dO1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMlwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtsfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMF0gPSBkb3RQcm9kWzBdICsgdG1wdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJEeUNWYWwyKSB7XG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IG91dEJhY2twcm9wWzNdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMlwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDMlwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7bH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHRtcHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke3Z9OyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kW2ldICsgJHtuP1wiYmlhc1tjK2ldXCI6XCIwLjBcIn07XG4gICAgICAgICAgJHtXLnNldChcImJhdGNoXCIsXCJyXCIsXCJjICsgaVwiLFwiZDFcIixcInZhbHVlXCIpfTtcbiAgICAgICAgfVxuICAgICAgfWAsSz1gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgbGV0IGJhdGNoID0gJHtXLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsMCl9O1xuICAgICAgICAgIGxldCBkMSA9ICR7Vy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHkpfTtcbiAgICAgICAgICBsZXQgciA9ICR7Vy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHApfTtcbiAgICAgICAgICBsZXQgYyA9ICR7Vy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLG0pfTtcbiAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gcGFkcztcbiAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICBsZXQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gJHtJfTtcbiAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiAke0l9O1xuICAgICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICAgIHZhciBkb3RQcm9kID0gMC4wO1xuICAgICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IGVmZmVjdGl2ZUZpbHRlckRpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgIGlmICh3UiAlIGRpbGF0aW9ucy54ICE9IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZHlSID0gKCR7bH0oZHlSQ29ybmVyKSArICR7bH0od1IpKSAvICR7bH0oc3RyaWRlc1swXSk7XG4gICAgICAgICAgICBsZXQgd1JQZXJtID0gZmlsdGVyRGltcy54IC0gMSAtIHdSIC8gZGlsYXRpb25zLng7XG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2x9KG91dEJhY2twcm9wWyR7cH1dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XG4gICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgZWZmZWN0aXZlRmlsdGVyRGltcy55OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgICBpZiAod0MgJSBkaWxhdGlvbnMueSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGR5QyA9ICgke2x9KGR5Q0Nvcm5lcikgKyAke2x9KHdDKSkgLyAke2x9KHN0cmlkZXMueSk7XG4gICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSBmaWx0ZXJEaW1zLnkgLSAxIC0gd0MgLyBkaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtsfShvdXRCYWNrcHJvcFske219XSkgfHxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiAke1N9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCAke1N9OyBkMiA9IGQyICsgMSkge1xuICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke28/RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5Q1wiLFwiaW5wdXRDaGFubmVsXCIpOkQuZ2V0KFwiYmF0Y2hcIixcImlucHV0Q2hhbm5lbFwiLFwiaWR5UlwiLFwiaWR5Q1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7UC5nZXQoXCJpbnB1dENoYW5uZWxcIixcIndPdXRDaGFubmVsXCIsXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIil9O1xuICAgICAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbCA9IGlucHV0Q2hhbm5lbCArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCArICR7bj9cImJpYXNbZDFdXCI6XCIwLjBcIn07XG4gICAgICAgICAgJHtXLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgICBgO3JldHVybmBcbiAgJHtlLmRlY2xhcmVWYXJpYWJsZXMoLi4uUixXKX1cbiAgJHtUfVxuICBjb25zdCBvdXRTaGFwZSA6IHZlYzQ8dTMyPiA9IHZlYzQ8dTMyPigke2Euam9pbihcIixcIil9KTtcbiAgY29uc3Qgb3V0QmFja3Byb3AgOiB2ZWM0PHUzMj4gPSB2ZWM0PHUzMj4oJHt0WzBdLmRpbXMuam9pbihcIixcIil9KTtcbiAgY29uc3Qgc3RyaWRlcyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke3Iuc3RyaWRlc1swXX0sICR7ci5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4oJHtyLmtlcm5lbFNoYXBlW28/MToyXX0sICR7ci5rZXJuZWxTaGFwZVtvPzI6M119KTtcbiAgY29uc3QgZGlsYXRpb25zIDogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KCR7ci5kaWxhdGlvbnNbMF19LCAke3IuZGlsYXRpb25zWzFdfSk7XG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgOiB2ZWMyPHUzMj4gPSBmaWx0ZXJEaW1zICsgdmVjMjx1MzI+KFxuICAgICAgICAgICR7ci5kaWxhdGlvbnNbMF08PTE/MDooci5rZXJuZWxTaGFwZVtvPzE6Ml0tMSkqKHIuZGlsYXRpb25zWzBdLTEpfSxcbiAgICAgICAgICAke3IuZGlsYXRpb25zWzFdPD0xPzA6KHIua2VybmVsU2hhcGVbbz8yOjNdLTEpKihyLmRpbGF0aW9uc1sxXS0xKX0pO1xuICBjb25zdCBwYWRzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdKSAtIDEgLSAoJHtyLnBhZHNbMF0rci5wYWRzWzJdfSkvMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1sxXSkgLSAxIC0gKCR7ci5wYWRzWzFdK3IucGFkc1szXX0pLzIpO1xuICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhnKX07XG4gICR7dT9IOkt9fWB9LG9hPShlLHQscik9PntsZXQgYT1lLmxlbmd0aD4yLG49dC5vdXRwdXRTaGFwZSxzPXouc2l6ZShuKSx1PVtNYXRoLmNlaWwocy82NCksMSwxXTtfZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7dX1gKTtsZXQgbD1CZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7ZGlzcGF0Y2hHcm91cDp7eDp1WzBdLHk6dVsxXSx6OnVbMl19LG91dHB1dHM6W3tkaW1zOnI/cihuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XX0pLGdldFNoYWRlclNvdXJjZTpvPT5LZChvLGUsdCxuLGEsdVsxXT09PTEmJnVbMl09PT0xLCExLGwpfX19KTt2YXIgWWQsWGQsSmQsT3MsVHMsUWQsWmQsZWMsdGMsUnMsUHM9TCgoKT0+e1widXNlIHN0cmljdFwiO2tlKCk7RXMoKTtfcygpO2hyKCk7bXIoKTtZZD0oZSx0LHIsYSxuLHMpPT4oZS0xKSp0K3IrKGEtMSkqbisxLXMsWGQ9KGUsdCxyLGEsbik9PntsZXQgcz1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW2FdPXMscltuXT1lLXMpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbYV09ZS1zLHJbbl09cyl9LEpkPShlLHQscixhLG4scyx1LGwsbyxwKT0+e2xldCBtPWUubGVuZ3RoLTIseT1wLmxlbmd0aD09PTA7aWYoby5sZW5ndGg9PT0wKWZvcihsZXQgJD0wOyQ8bTsrKyQpby5wdXNoKDApO2xldCBnPWVbMF0sdj10W2w/MzoxXSpuO2ZvcihsZXQgJD0wLGI9ZS5sZW5ndGgtbS0obD8xOjApOyQ8bTsrKyQsKytiKXtsZXQgUz1lW2JdLEk9eT9TKnVbJF06cFskXSxUPVlkKFMsdVskXSxzWyRdLHRbYl0sclskXSxJKTtYZChULGEscywkLCQrbSkseSYmcC5wdXNoKHVbJF0qKFMtMSkrb1skXSsodFtiXS0xKSpyWyRdKzEtc1skXS1zWyQrbV0pfXAuc3BsaWNlKDAsMCxnKSxwLnNwbGljZShsPzM6MSwwLHYpfSxPcz0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKChnLHYpPT5nKnYsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgZz0yO2c8dFsxXS5kaW1zLmxlbmd0aDsrK2cpci5wdXNoKHRbMV0uZGltc1tnXSl9bGV0IGE9ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShhPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG49ZS5wYWRzLnNsaWNlKCkscz1lLm91dHB1dFNoYXBlLnNsaWNlKCksdT1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxsPXRbMF0uZGltcyxvPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYoby5yZWR1Y2UoKGcsdik9PmcrdiwwKT09PTApe2xldCBnPXRbMF0uZGltcy5sZW5ndGgtMjtvPW5ldyBBcnJheShnKS5maWxsKDEpfWxldCBwPWUuc3RyaWRlcy5zbGljZSgpO2lmKHAucmVkdWNlKChnLHYpPT5nK3YsMCk9PT0wKXtsZXQgZz10WzBdLmRpbXMubGVuZ3RoLTI7cD1uZXcgQXJyYXkoZykuZmlsbCgxKX1KZChsLHIsbyxlLmF1dG9QYWQsZS5ncm91cCxuLHAsYSx1LHMpO2xldCBtPU9iamVjdC5hc3NpZ24oe30sZSkseT1lLmNhY2hlS2V5K1tyLmpvaW4oXCJuLFwiKSxuLmpvaW4oXCIsXCIpLHAuam9pbihcIixcIiksdS5qb2luKFwiLFwiKSxzLmpvaW4oXCIsXCIpLG8uam9pbihcIixcIildLmpvaW4oXCJfXCIpO3JldHVybiBPYmplY3QuYXNzaWduKG0se2tlcm5lbFNoYXBlOnIscGFkczpuLG91dHB1dFBhZGRpbmc6dSxvdXRwdXRTaGFwZTpzLGRpbGF0aW9uczpvLHN0cmlkZXM6cCxjYWNoZUtleTp5fSksbX0sVHM9ZT0+e2xldCB0PWRuKGUpLHI9ZS5mb3JtYXQsYT1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG49ZS5kaWxhdGlvbnMscz1lLmdyb3VwLHU9ZS5rZXJuZWxTaGFwZSxsPWUucGFkcyxvPWUuc3RyaWRlcyxwPWUud0lzQ29uc3QoKSxtPWUub3V0cHV0UGFkZGluZyx5PWUub3V0cHV0U2hhcGU7cmV0dXJuIGllKHthdXRvUGFkOmEsZm9ybWF0OnIsZGlsYXRpb25zOm4sZ3JvdXA6cyxrZXJuZWxTaGFwZTp1LG91dHB1dFBhZGRpbmc6bSxvdXRwdXRTaGFwZTp5LHBhZHM6bCxzdHJpZGVzOm8sd0lzQ29uc3Q6cCwuLi50fSl9LFFkPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLGE9ZVsxXS5kaW1zWzBdO2lmKHIhPT1hKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7bGV0IG49ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMl0uZGltc1swXSE9PW4pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgcz1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMucmVkdWNlKChtLHkpPT5tK3ksMCk+MCYmdC5kaWxhdGlvbnMubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzfURgKTtpZih0LnN0cmlkZXMucmVkdWNlKChtLHkpPT5tK3ksMCk+MCYmdC5zdHJpZGVzLmxlbmd0aCE9PXMpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3N9RGApO2lmKHQucGFkcy5yZWR1Y2UoKG0seSk9Pm0reSwwKT4wJiZ0LnBhZHMubGVuZ3RoIT09cyoyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzKjJ9RGApO2lmKHQub3V0cHV0UGFkZGluZy5sZW5ndGghPT1zJiZ0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke3N9RGApO2lmKHQua2VybmVsU2hhcGUucmVkdWNlKChtLHkpPT5tK3ksMCk+MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZih0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PTAmJnQub3V0cHV0U2hhcGUubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3V0cHV0IHNoYXBlXCIpfSxaZD1bMiwzLDEsMF0sZWM9KGUsdCxyKT0+e2xldCBhPU9zKHIsdCksbj1yLmZvcm1hdD09PVwiTkhXQ1wiLHM9dC5sZW5ndGg9PT0zO2lmKGEuZ3JvdXAhPT0xKXtlLmNvbXB1dGUob2EodCxhKSk7cmV0dXJufWxldCB1PWEub3V0cHV0U2hhcGUsbD11W24/MToyXSxvPXVbbj8yOjNdLHA9dVtuPzM6MV0sbT10WzFdLmRpbXNbMl0seT10WzFdLmRpbXNbM10sZz10WzBdLmRpbXNbbj8zOjFdLHY9bj9sKm86cCwkPW4/cDpsKm8sYj1tKnkqZyxTPSEwLEk9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoQ3QodFsxXSxaZCkse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPUkpO2xldCBUPVt0WzBdLEldO3MmJighbiYmdFsyXS5kaW1zLmxlbmd0aD09PTE/VC5wdXNoKHRbMl0ucmVzaGFwZShbdFsyXS5kaW1zWzBdLDEsMV0pKTpULnB1c2godFsyXSkpLGUuY29tcHV0ZShBcyhULGEsdSx2LCQsYixzLFMpLHtpbnB1dHM6VH0pfSx0Yz0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsYT1bZS5pbnB1dHNbMF0ucmVzaGFwZShyP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07YS5sZW5ndGg9PT0zJiZhLnB1c2goZS5pbnB1dHNbMl0pO2xldCBuPXQua2VybmVsU2hhcGU7KG4ubGVuZ3RoPT09MHx8blswXT09PTApJiYobj1bZS5pbnB1dHNbMV0uZGltc1syXV0pO2xldCBzPXQuZGlsYXRpb25zOyhzLmxlbmd0aD09PTB8fHNbMF09PT0wKSYmKHM9WzFdKTtsZXQgdT10LnN0cmlkZXM7KHUubGVuZ3RoPT09MHx8dVswXT09PTApJiYodT1bMV0pO2xldCBsPXQucGFkcztsLmxlbmd0aD09PTAmJihsPVswLDBdKSxsPVswLGxbMF0sMCxsWzFdXSx1PVsxXS5jb25jYXQodSkscz1bMV0uY29uY2F0KHMpLG49WzFdLmNvbmNhdChuKTtsZXQgbz1Pcyh7Li4udCxwYWRzOmwsc3RyaWRlczp1LGRpbGF0aW9uczpzLGtlcm5lbFNoYXBlOm59LGEpO2UuY29tcHV0ZShvYShhLG8scD0+cj9bcFswXSxwWzJdLHBbM11dOltwWzBdLHBbMV0scFszXV0pKX0sUnM9KGUsdCk9PntRZChlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTM/dGMoZSx0KTplYyhlLGUuaW5wdXRzLHQpfX0pO3ZhciBpYSxwbixrcyxyYyxuYyxzYSx1YSxhYyxCcyxNcyxEcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7aWE9XCJbYS16QS1aXXxcXFxcLlxcXFwuXFxcXC5cIixwbj1cIihcIitpYStcIikrXCIsa3M9XCJeXCIrcG4rXCIkXCIscmM9XCIoXCIrcG4rXCIsKSpcIitwbixuYz1cIl5cIityYytcIiRcIixzYT1jbGFzc3tjb25zdHJ1Y3Rvcih0PS0xKXt0aGlzLnN5bWJvbFRvSW5kaWNlcz1uZXcgTWFwLHRoaXMuaW5wdXRJbmRleD10fWFkZFN5bWJvbCh0LHIpe2xldCBhPXRoaXMuc3ltYm9sVG9JbmRpY2VzLmdldCh0KTthPT09dm9pZCAwP2E9W3JdOmEucHVzaChyKSx0aGlzLnN5bWJvbFRvSW5kaWNlcy5zZXQodCxhKX19LHVhPWNsYXNze2NvbnN0cnVjdG9yKHQscil7dGhpcy5lcXVhdGlvbj1yO3RoaXMuaGFzRWxsaXBzaXM9ITEsdGhpcy5zeW1ib2xUb0luZm89bmV3IE1hcCx0aGlzLmxocz1uZXcgQXJyYXksdGhpcy5vdXRwdXREaW1zPVtdO2xldFthLG5dPXIuaW5jbHVkZXMoXCItPlwiKT9yLnNwbGl0KFwiLT5cIiwyKTpbcixcIlwiXTtpZighYS5tYXRjaChSZWdFeHAobmMpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2lmKGEuc3BsaXQoXCIsXCIpLmZvckVhY2goKGwsbyk9PntsZXQgcD10W29dLmRpbXMuc2xpY2UoKTtpZighbC5tYXRjaChSZWdFeHAoa3MpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBtPXRoaXMucHJvY2Vzc1Rlcm0obCwhMCxwLG8pO3RoaXMubGhzLnB1c2gobSl9KSxuPT09XCJcIiluKz1bLi4udGhpcy5zeW1ib2xUb0luZm8uZW50cmllcygpXS5maWx0ZXIoKFtsLG9dKT0+by5jb3VudD09PTF8fGw9PT1cIi4uLlwiKS5tYXAoKFtsXSk9PmwpLmpvaW4oXCJcIik7ZWxzZSBpZighbi5tYXRjaChSZWdFeHAocG4pKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIU1wiKTtuLm1hdGNoKFJlZ0V4cChpYSxcImdcIikpPy5mb3JFYWNoKGw9PntpZihsPT09XCIuLi5cIil0aGlzLm91dHB1dERpbXM9dGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7ZWxzZXtsZXQgbz10aGlzLnN5bWJvbFRvSW5mby5nZXQobCk7aWYobz09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIUyBzeW1ib2xcIik7dGhpcy5vdXRwdXREaW1zLnB1c2goby5kaW1WYWx1ZSl9fSksdGhpcy5yaHM9dGhpcy5wcm9jZXNzVGVybShuLCEwLHRoaXMub3V0cHV0RGltcyl9YWRkU3ltYm9sKHQscixhKXtsZXQgbj10aGlzLnN5bWJvbFRvSW5mby5nZXQodCk7aWYobiE9PXZvaWQgMCl7aWYobi5kaW1WYWx1ZSE9PXImJm4uY291bnQhPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbiBtaXNtYXRjaFwiKTtuLmNvdW50Kyssbi5pbnB1dEluZGljZXMucHVzaChhKX1lbHNlIG49e2NvdW50OjEsZGltVmFsdWU6cixpbnB1dEluZGljZXM6W2FdfTt0aGlzLnN5bWJvbFRvSW5mby5zZXQodCxuKX1wcm9jZXNzVGVybSh0LHIsYSxuPS0xKXtsZXQgcz1hLmxlbmd0aCx1PSExLGw9W10sbz0wO2lmKCF0Lm1hdGNoKFJlZ0V4cChrcykpJiYhciYmdCE9PVwiXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgcD10Lm1hdGNoKFJlZ0V4cChpYSxcImdcIikpLG09bmV3IHNhKG4pO3JldHVybiBwPy5mb3JFYWNoKCh5LGcpPT57aWYoeT09PVwiLi4uXCIpe2lmKHUpdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybVwiKTt1PSEwO2xldCB2PXMtcC5sZW5ndGgrMTtpZih2PDApdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihsPWEuc2xpY2UobyxvK3YpLHRoaXMuaGFzRWxsaXBzaXMpe2lmKHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCE9PWwubGVuZ3RofHx0aGlzLmVsbGlwc2lzRGltcy50b1N0cmluZygpIT09bC50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIGRpbWVuc2lvbnMgbWlzbWF0Y2hcIil9ZWxzZSBpZihyKXRoaXMuaGFzRWxsaXBzaXM9ITAsdGhpcy5lbGxpcHNpc0RpbXM9bDtlbHNlIHRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFNcIik7Zm9yKGxldCAkPTA7JDxsLmxlbmd0aDskKyspe2xldCBiPVN0cmluZy5mcm9tQ2hhckNvZGUoXCIwXCIuY2hhckNvZGVBdCgwKStnKTttLmFkZFN5bWJvbChiLGcrJCksdGhpcy5hZGRTeW1ib2woYixhW28rK10sbil9fWVsc2UgbS5hZGRTeW1ib2woeSxnKSx0aGlzLmFkZFN5bWJvbCh5LGFbbysrXSxuKX0pLG19fSxhYz0oZSx0KT0+e2xldCByPWVbMF0uZGF0YVR5cGUsYT1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgQj0wO0I8ZS5sZW5ndGg7KytCKWFbQl09RihgaW5wdXQke0J9YCxyLGVbQl0uZGltcyk7bGV0IG49dC5vdXRwdXREaW1zLHM9ei5zaXplKG4pLHU9WChcIm91dHB1dFwiLHIsbiksbD1bXSxvPUFycmF5LmZyb20odC5yaHMuc3ltYm9sVG9JbmRpY2VzLmtleXMoKSkscD1cInZhciBwcm9kID0gMS4wO1wiLG09XCJ2YXIgc3VtID0gMC4wO1wiLHk9XCJzdW0gKz0gcHJvZDtcIixnPVtdLHY9W10sJD1bXSxiPVtdLFM9dC5zeW1ib2xUb0luZm8uc2l6ZT09PW8ubGVuZ3RoO3Quc3ltYm9sVG9JbmZvLmZvckVhY2goKEIsUCk9PntpZihvLmluY2x1ZGVzKFApKXtsZXQgRD1vLmluZGV4T2YoUCk7dC5saHMuZm9yRWFjaCgoUixXKT0+e2lmKEIuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKFcpKXtsZXQgSD1SLnN5bWJvbFRvSW5kaWNlcy5nZXQoUCk7aWYoSD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtILmZvckVhY2goSz0+e2wucHVzaChgJHthW1ddLmluZGljZXNTZXQoYGlucHV0JHtXfUluZGljZXNgLEssdS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEQpKX1gKX0pfX0pfWVsc2UgdC5saHMuZm9yRWFjaCgoRCxSKT0+e2xldCBXPXQuc3ltYm9sVG9JbmZvLmdldChQKTtpZihXPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO2lmKFcuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKFIpKXtsZXQgSD1ELnN5bWJvbFRvSW5kaWNlcy5nZXQoUCk7aWYoSD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtILmZvckVhY2goSz0+e2cucHVzaChgJHthW1JdLmluZGljZXNTZXQoYGlucHV0JHtSfUluZGljZXNgLEssYCR7UH1gKX1gKX0pLGIucHVzaChgcHJvZCAqPSAke2FbUl0uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7Un1JbmRpY2VzYCl9O2ApfX0pLHYucHVzaChgZm9yKHZhciAke1B9OiB1MzIgPSAwOyAke1B9IDwgJHt0LnN5bWJvbFRvSW5mby5nZXQoUCk/LmRpbVZhbHVlfTsgJHtQfSsrKSB7YCksJC5wdXNoKFwifVwiKX0pO2xldCBJPVM/Wy4uLmwsYGxldCBzdW0gPSAke2EubWFwKChCLFApPT5CLmdldEJ5SW5kaWNlcyhgaW5wdXQke1B9SW5kaWNlc2ApKS5qb2luKFwiICogXCIpfTtgXTpbLi4ubCxtLC4uLnYsLi4uZyxwLC4uLmIseSwuLi4kXSxUPUI9PmBcbiAgICAgICR7Qi5kZWNsYXJlVmFyaWFibGVzKC4uLmEsdSl9XG5cbiAgICAgICR7Qi5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtCLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocyl9XG4gICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAke2EubWFwKChQLEQpPT5gdmFyIGlucHV0JHtEfUluZGljZXM6ICR7YVtEXS50eXBlLmluZGljZXN9O2ApLmpvaW4oYFxuYCl9XG4gICAgICAgICR7SS5qb2luKGBcbmApfTtcbiAgICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgIH1gO3JldHVybntuYW1lOlwiRWluc3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5lcXVhdGlvbn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6VH19LEJzPShlLHQpPT57bGV0IHI9bmV3IHVhKGUuaW5wdXRzLHQuZXF1YXRpb24pO2UuY29tcHV0ZShhYyhlLmlucHV0cyxyKSl9LE1zPWU9PntsZXQgdD1lLmVxdWF0aW9uLnJlcGxhY2UoL1xccysvZyxcIlwiKTtyZXR1cm4gaWUoe2VxdWF0aW9uOnR9KX19KTt2YXIgb2MsenMsaWMsc2MsV3MsTnM9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtvYz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgMiBpbnB1dC5cIik7bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLGE9ci5sZW5ndGg8dC5sZW5ndGg/MDpyLmxlbmd0aC10Lmxlbmd0aCxuPXQubGVuZ3RoPHIubGVuZ3RoPzA6dC5sZW5ndGgtci5sZW5ndGg7Zm9yKDthPHIubGVuZ3RoJiZuPHQubGVuZ3RoOysrYSwrK24paWYoclthXSE9PXRbbl0mJnJbYV0hPT0xJiZ0W25dIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dFwiKX0senM9KGUsdCk9PntsZXQgcj1lLmxlbmd0aC10Lmxlbmd0aCxhPVtdO2ZvcihsZXQgbj0wO248cjsrK24pYS5wdXNoKGVbbl0pO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWEucHVzaCh0W25dPT09MT9lW24rcl06dFtuXSk7cmV0dXJuIGF9LGljPShlLHQpPT5lLmxlbmd0aD50Lmxlbmd0aD96cyhlLHQpOnpzKHQsZSksc2M9ZT0+e2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxhPWljKHQsciksbj16LnNpemUoYSkscz1lWzBdLmRhdGFUeXBlLHU9RihcImlucHV0XCIscyx0KSxsPVgoXCJvdXRwdXRcIixzLGEpLG89cD0+YFxuICBjb25zdCBpbnB1dFNoYXBlID0gJHt1LmluZGljZXMoLi4udCl9O1xuICAke3AuZGVjbGFyZVZhcmlhYmxlcyh1LGwpfVxuICAke3AubWFpblN0YXJ0KCl9XG4gICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG4pfVxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtsLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIHZhciBpbnB1dEluZGljZXM6ICR7dS50eXBlLmluZGljZXN9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgaWYgKCR7dS5pbmRpY2VzR2V0KFwiaW5wdXRTaGFwZVwiLFwiaVwiKX0gPT0gMSkge1xuICAgICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLDApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHt1LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIixsLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsYGkgKyAke2EubGVuZ3RoLXQubGVuZ3RofWApKX1cbiAgICAgIH1cbiAgICB9XG4gICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHUuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpKX1cbiAgfWA7cmV0dXJue25hbWU6XCJFeHBhbmRcIixzaGFkZXJDYWNoZTp7aGludDpgJHthfWB9LGdldFNoYWRlclNvdXJjZTpvLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9fSl9fSxXcz1lPT57b2MoZS5pbnB1dHMpLGUuY29tcHV0ZShzYyhlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgdWMsbGMsVnMsVXMsR3M9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO3VjPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LGxjPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLG49ci5sZW5ndGgscz16Lm5vcm1hbGl6ZUF4aXModC5heGlzLG4pLHU9ci5zbGljZSgwKTt1LnNwbGljZShzLDEsLi4uYSk7bGV0IGw9cltzXSxvPXouc2l6ZSh1KSxwPUYoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLG09RihcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSx5PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHUpLGc9KCk9PntsZXQgJD1hLmxlbmd0aCxiPWB2YXIgaW5kaWNlc0luZGljZXMgID0gJHttLnR5cGUuaW5kaWNlc30oMCk7YDtmb3IobGV0IFM9MDtTPCQ7UysrKWIrPWAkeyQ+MT9gaW5kaWNlc0luZGljZXNbJHtTfV1gOlwiaW5kaWNlc0luZGljZXNcIn0gPSAke3UubGVuZ3RoPjE/YG91dHB1dEluZGljZXNbJHtzK1N9XWA6XCJvdXRwdXRJbmRpY2VzXCJ9O2A7Yis9YFxuICAgICAgICB2YXIgaWR4ID0gJHttLmdldEJ5SW5kaWNlcyhcImluZGljZXNJbmRpY2VzXCIpfTtcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICBpZHggPSBpZHggKyAke2x9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhSW5kaWNlcyA9ICR7cC50eXBlLmluZGljZXN9KDApO1xuICAgICAgYDtmb3IobGV0IFM9MCxJPTA7UzxuO1MrKylTPT09cz8oYis9YCR7bj4xP2BkYXRhSW5kaWNlc1ske1N9XWA6XCJkYXRhSW5kaWNlc1wifSA9IHUzMihpZHgpO2AsSSs9JCk6KGIrPWAke24+MT9gZGF0YUluZGljZXNbJHtTfV1gOlwiZGF0YUluZGljZXNcIn0gPSAke3UubGVuZ3RoPjE/YG91dHB1dEluZGljZXNbJHtJfV1gOlwib3V0cHV0SW5kaWNlc1wifTtgLEkrKyk7cmV0dXJuIGJ9LHY9JD0+YFxuICAgICAgJHskLmRlY2xhcmVWYXJpYWJsZXMocCxtLHkpfVxuICAgICAgJHskLm1haW5TdGFydCgpfVxuICAgICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvKX1cbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICR7ZygpfTtcbiAgICAgICAgbGV0IHZhbHVlID0gJHtwLmdldEJ5SW5kaWNlcyhcImRhdGFJbmRpY2VzXCIpfTtcbiAgICAgICAgJHt5LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgfWA7cmV0dXJue25hbWU6XCJHYXRoZXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfX0pLGdldFNoYWRlclNvdXJjZTp2fX0sVnM9ZT0+aWUoe2F4aXM6ZS5heGlzfSksVXM9KGUsdCk9PntsZXQgcj1lLmlucHV0czt1YyhyKSxlLmNvbXB1dGUobGMoZS5pbnB1dHMsdCkpfX0pO3ZhciBkYyxjYyxGcyxMcyxIcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7ZGM9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKX0sY2M9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsYT1lWzBdLmRhdGFUeXBlLG49ci5sZW5ndGgscz16LmNvbXB1dGVTdHJpZGVzKHIpLHU9ei5zaXplKHIpLGw9ZVsxXS5kaW1zLG89ZVsxXS5kYXRhVHlwZSxwPXouc2l6ZShsKSxtPXoubm9ybWFsaXplQXhpcyh0LmF4aXMsbikseT1yW21dLGc9bC5zbGljZSgwKSx2PXouc2l6ZShnKSwkPUYoXCJpbnB1dFwiLGEsciksYj1GKFwiaW5kaWNlc1wiLG8sW3BdKSxTPVgoXCJvdXRwdXRcIixhLGcpLEk9VD0+YFxuICAgICAgY29uc3QgaW5wdXRTdHJpZGVzID0gYXJyYXk8dTMyLCAke3MubGVuZ3RofT4oJHtzLm1hcChCPT5gJHtCfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgJHtULmRlY2xhcmVWYXJpYWJsZXMoJCxiLFMpfVxuICAgICAgJHtULm1haW5TdGFydCgpfVxuICAgICAgJHtULmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtiLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyAke3l9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc3JjT2Zmc2V0ID0gdTMyKDApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT0gJHttfSkge1xuICAgICAgICAgIHNyY09mZnNldCArPSAgdTMyKGlkeCkgKiBpbnB1dFN0cmlkZXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3JjT2Zmc2V0ICs9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiaVwiKX0gKiBpbnB1dFN0cmlkZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2hvdWxkIG5ldmVyIGhpdCB0aGlzIHdpdGggdmFsaWQgdmFsdWVzIGluIGluZGljZXNcbiAgICAgIC8vIFRoaXMgaXMgYSBndWFyZCBhZ2FpbnN0IG1hbGljaW91cyBkYXRhIGluIHRoZSBpbmRpY2VzIGlucHV0XG4gICAgICBpZiAoc3JjT2Zmc2V0IDwgMCB8fCBzcmNPZmZzZXQgPj0gJHt1fSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W3NyY09mZnNldF07XG4gIH1gO3JldHVybntuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmcsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHYvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpJfX0sRnM9ZT0+aWUoe2F4aXM6ZS5heGlzfSksTHM9KGUsdCk9PntsZXQgcj1lLmlucHV0cztkYyhyKSxlLmNvbXB1dGUoY2MoZS5pbnB1dHMsdCkpfX0pO3ZhciBwYyxmYyxtYyxqcyxxcyxLcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7cGM9ZT0+e2lmKCFlKXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMl0uZGltcy5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoZVswXS5kYXRhVHlwZSE9PWVbMV0uZGF0YVR5cGV8fGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9LGZjPShlLHQscik9PntpZihyLmxlbmd0aD09PTApcmV0dXJuXCIwdVwiO2xldCBhPXIubGVuZ3RoPT09MSYmZSE9PTF8fHIubGVuZ3RoPT09MiYmclswXSE9PWUsbj1yW3IubGVuZ3RoLTFdIT09dCxzPVwiMHVcIjtyZXR1cm4gYXx8KHMrPWArIG0gKiAke3Jbci5sZW5ndGgtMV19dWApLG58fChzKz1cIituXCIpLHN9LG1jPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLnNsaWNlKCksYT1lWzFdLmRpbXMuc2xpY2UoKSxbbixzLHVdPUpyLmdldFNoYXBlT2ZHZW1tUmVzdWx0KHIsdC50cmFuc0EsYSx0LnRyYW5zQixlLmxlbmd0aD09PTM/ZVsyXS5kaW1zOnZvaWQgMCksbD1bbixzXTtpZighbCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgbz16LnNpemUobCkscD1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj9wPVwidmFsdWUgKz0gYVtrICogTSArIG1dICogYltuICogSyArIGtdO1wiOnQudHJhbnNBJiYhdC50cmFuc0I/cD1cInZhbHVlICs9IGFbayAqIE0gKyBtXSAqIGJbayAqIE4gKyBuXTtcIjohdC50cmFuc0EmJnQudHJhbnNCP3A9XCJ2YWx1ZSArPSBhW20gKiBLICsga10gKiBiW24gKiBLICsga107XCI6IXQudHJhbnNBJiYhdC50cmFuc0ImJihwPVwidmFsdWUgKz0gYVttICogSyArIGtdICogYltrICogTiArIG5dO1wiKTtsZXQgbT1CZShlWzBdLmRhdGFUeXBlKSx5PXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSBhbHBoYTtcIixnPWUubGVuZ3RoPT09Mz9gdmFsdWUgKz0gYmV0YSAqIGNbJHtmYyhuLHMsZVsyXS5kaW1zKX1dO2A6XCJcIix2PVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBhIDogYXJyYXk8JHttfT47YCxgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBiIDogYXJyYXk8JHttfT47YF07ZS5sZW5ndGg9PT0zJiZ2LnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYyA6IGFycmF5PCR7bX0+O2ApO2xldCAkPWI9PmBcbiAgY29uc3QgTTogdTMyID0gJHtufXU7XG4gIGNvbnN0IE46IHUzMiA9ICR7c311O1xuICBjb25zdCBLOiB1MzIgPSAke3V9dTtcbiAgY29uc3QgYWxwaGEgPSAke219KCR7dC5hbHBoYX0pO1xuICBjb25zdCBiZXRhID0gJHttfSgke3QuYmV0YX0pO1xuXG4gICR7di5qb2luKGBcbmApfVxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtlLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke219PjtcblxuICAke2IubWFpblN0YXJ0KCl9XG4gICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobyl9XG5cbiAgICBsZXQgbSA9IGdsb2JhbF9pZC54IC8gTjtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54ICUgTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7bX0oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8JHt1fXU7IGsrKykge1xuICAgICAgJHtwfVxuICAgIH1cblxuICAgICR7eX1cbiAgICAke2d9XG4gICAgb3V0cHV0W2dsb2JhbF9pZC54XSA9IHZhbHVlO1xuXG4gIH1gO3JldHVybntuYW1lOlwiR2VtbVwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9fSksZ2V0U2hhZGVyU291cmNlOiR9fSxqcz0oZSx0KT0+e3BjKGUuaW5wdXRzKSxlLmNvbXB1dGUobWMoZS5pbnB1dHMsdCkpfSxxcz1lPT5pZShlKX0pO3ZhciBoYyxnYyx5YyxiYyxZcyxYcyxKcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO2tlKCk7dmUoKTtoYz17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwifSxnYz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxhPXIsbj0yLHM9ei5zaXplVG9EaW1lbnNpb24ocixuKSx1PXouc2l6ZUZyb21EaW1lbnNpb24ocixuKSxsPXJbMV0sbz1GKFwieFwiLGVbMF0uZGF0YVR5cGUsW3JbMF0sclsxXSx1XSkscD1GKFwic2NhbGVcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksbT1GKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zKSx5PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLFtyWzBdLHJbMV0sdV0pLGc9W28scCxtLHldLHY9by50eXBlLnZhbHVlLCQ9NjQsYj1TPT5gXG5cbiAgY29uc3QgQzogdTMyID0gJHtsfTtcbiAgY29uc3Qgbm9ybVNpemU6IHUzMiA9ICR7dX07XG4gIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7dC5lcHNpbG9ufTtcbiAgdmFyPHdvcmtncm91cD4gbWVhblNoYXJlZCA6ICR7dn07XG4gIHZhcjx3b3JrZ3JvdXA+IHNxdWFyZWROb3JtU2hhcmVkIDogJHt2fTtcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwU2hhcmVkIDogYXJyYXk8JHt2fSwgJHskfT47XG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSAkeyR9dTtcbiAgJHtTLmRlY2xhcmVWYXJpYWJsZXMoLi4uZyl9XG4gICR7Uy5tYWluU3RhcnQoJCl9XG4gICAgbGV0IG5vcm0gPSBnbG9iYWxfaWR4IC8gd29ya2dyb3VwU2l6ZTtcbiAgICBsZXQgYmF0Y2ggPSBub3JtIC8gQztcbiAgICBsZXQgY2hhbm5lbCA9IG5vcm0gJSBDO1xuICAgIGxldCBsb2NhbEluZGV4ID0gbG9jYWxfaWQueDtcblxuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxuICAgIHZhciBpbml0aWFsOiAke3Z9ID0gMDtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IG5vcm1TaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsICsgJHtvLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfTtcbiAgICB9XG4gICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gaW5pdGlhbDtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1lYW4gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xuICAgICAgbWVhblNoYXJlZCA9IHdvcmtncm91cFNoYXJlZFswXSAvICR7dn0obm9ybVNpemUpO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyByZWluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeS5cbiAgICBpbml0aWFsID0gMDtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IG5vcm1TaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcbiAgICAgIGxldCBkZXZpYXRpb24gPSAgJHtvLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSAtIG1lYW5TaGFyZWQ7XG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArIGRldmlhdGlvbiAqIGRldmlhdGlvbjtcbiAgICB9XG4gICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gaW5pdGlhbDtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHN1bSBvZiBzcXVhcmUgb2YgZGV2aWF0aW9uIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbEluZGV4ID09IDApIHtcbiAgICAgIHNxdWFyZWROb3JtU2hhcmVkID0gd29ya2dyb3VwU2hhcmVkWzBdO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgaW52U3RkRGV2ID0gMSAvIHNxcnQoc3F1YXJlZE5vcm1TaGFyZWQgLyAke3Z9KG5vcm1TaXplKSArIGVwc2lsb24pO1xuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiAke3AuZ2V0QnlPZmZzZXQoXCJjaGFubmVsXCIpfTtcbiAgICBsZXQgY2hhbm5lbFNoaWZ0ID0gJHttLmdldEJ5T2Zmc2V0KFwiY2hhbm5lbFwiKX0gLSBtZWFuU2hhcmVkICogY2hhbm5lbFNjYWxlO1xuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgbm9ybVNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xuICAgICAgbGV0IHZhbHVlID0gJHtvLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSAqIGNoYW5uZWxTY2FsZSArIGNoYW5uZWxTaGlmdDtcbiAgICAgICR7eS5zZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfWA7cmV0dXJuey4uLmhjLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpzfX0pLGdldFNoYWRlclNvdXJjZTpifX0seWM9KGUsdCxyLGEsbixzLHUsbCk9PntsZXQgbz1tdCh1KSxwPUYoXCJpbnB1dFwiLHQuZGF0YVR5cGUsdC5kaW1zLG8pLG09RihcInNjYWxlXCIsci5kYXRhVHlwZSxyLmRpbXMsbykseT1GKFwiYmlhc1wiLGEuZGF0YVR5cGUsYS5kaW1zLG8pLGc9NjQsdj1vPT09MT9cInZlYzJmXCI6YG1hdDJ4JHtvfWZgLCQ9bz09PTE/XCJmMzJcIjpgdmVjJHtvfWZgLGI9KEQsUik9PmAke3Z9KCR7RH0sICR7Un0pYCxTPW4qdS9vLEk9TWF0aC5jZWlsKHMvZyksVD1EPT5gXG4gIGNvbnN0IEg6IHUzMiA9ICR7c307XG4gIGNvbnN0IEM6IHUzMiA9ICR7dS9vfTtcbiAgY29uc3QgaW1hZ2VTaXplOiB1MzIgPSAke3MqdS9vfTtcblxuICAke0QuZGVjbGFyZVZhcmlhYmxlcyhwKX1cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3Z9PjtcblxuICAke0QubWFpblN0YXJ0KGcpfVxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gJHtnfSAvIEM7XG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gKGdsb2JhbF9pZHggLyAke2d9KSAlIEM7XG4gICAgbGV0IHdnSWQgPSBnbG9iYWxfaWR4ICUgJHtnfTtcbiAgICBsZXQgd2dPZmZzZXQgPSB3Z0lkICogJHtJfTtcbiAgICBpZiAod2dPZmZzZXQgPj0gSCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB3Z01heCA9IG1pbih3Z09mZnNldCArICR7SX0sIEgpO1xuXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIGltYWdlU2l6ZSArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xuICAgIHZhciBzdW0gPSAke1FlKFwiZjMyXCIsbyl9O1xuICAgIHZhciBzcXVhcmVkU3VtID0gJHtRZShcImYzMlwiLG8pfTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSB3Z09mZnNldDsgaSA8IHdnTWF4OyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJHskfShpbnB1dFtvZmZzZXQgKyBpICogQ10pO1xuICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgIHNxdWFyZWRTdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtiKFwic3VtXCIsXCJzcXVhcmVkU3VtXCIpfTtcbiAgfWAsQj1lLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlTWVhblwiLHNoYWRlckNhY2hlOntoaW50OkpTT04uc3RyaW5naWZ5KHtjb21wb25lbnRzOm8sbixoOnMsYzp1fSl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6W24sdSxnLDJdLGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4Om4qdS9vfX0pLGdldFNoYWRlclNvdXJjZTpUfSx7aW5wdXRzOlt0XSxvdXRwdXRzOlstMV19KVswXSxQPUQ9PmBcbiAgY29uc3QgSDogdTMyID0gJHtzfTtcbiAgY29uc3QgQzogdTMyID0gJHt1L299O1xuICBjb25zdCBpbWFnZVNpemU6IHUzMiA9ICR7Zyp1L299O1xuICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke2x9O1xuXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke3Z9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZSA6IGFycmF5PCR7bS50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzIDogYXJyYXk8JHt5LnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7dn0+O1xuXG4gICR7RC5tYWluU3RhcnQoKX1cbiAgICAke0QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhTKX1cbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvIEM7XG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gZ2xvYmFsX2lkeCAlIEM7XG5cbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogaW1hZ2VTaXplO1xuICAgIHZhciBzdW0gPSAke1FlKFwiZjMyXCIsbyl9O1xuICAgIHZhciBzcXVhcmVkU3VtID0gJHtRZShcImYzMlwiLG8pfTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtnfTsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGlucHV0W29mZnNldCArIGkgKyBjdXJyZW50Q2hhbm5lbE51bWJlciAqICR7Z31dO1xuICAgICAgICBzdW0gKz0gdmFsdWVbMF07XG4gICAgICAgIHNxdWFyZWRTdW0gKz0gdmFsdWVbMV07XG4gICAgfVxuICAgIHN1bSA9IHN1bSAvIGYzMihIKTtcbiAgICBzcXVhcmVkU3VtID0gc3F1YXJlZFN1bSAvIGYzMihIKTtcbiAgICBsZXQgaW52U3RkRGV2ID0gMSAvIHNxcnQoc3F1YXJlZFN1bSAtIHN1bSAqIHN1bSArIGVwc2lsb24pO1xuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiAkeyR9KHNjYWxlW2N1cnJlbnRDaGFubmVsTnVtYmVyXSk7XG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9ICR7JH0oYmlhc1tjdXJyZW50Q2hhbm5lbE51bWJlcl0pIC0gc3VtICogY2hhbm5lbFNjYWxlO1xuXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtiKFwiY2hhbm5lbFNjYWxlXCIsXCJjaGFubmVsU2hpZnRcIil9O1xuICB9YDtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6SlNPTi5zdHJpbmdpZnkoe2NvbXBvbmVudHM6byxuLGg6cyxjOnUsZXBzaWxvbjpsfSl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6W24sdSwyXSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoUy82NCl9fSksZ2V0U2hhZGVyU291cmNlOlB9LHtpbnB1dHM6W0IscixhXSxvdXRwdXRzOlstMV19KVswXX0sYmM9KGUsdCxyKT0+e2xldCBhPXRbMF0uZGltcyxuPWEscz1hWzBdLHU9YVthLmxlbmd0aC0xXSxsPXouc2l6ZUZyb21EaW1lbnNpb24oYSwxKS91LG89bXQodSkscD16LnNpemUobikvbyxtPUYoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLG8pLHk9WChcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsbixvKSxnPUJlKHRbMF0uZGF0YVR5cGUpLHY9bz09PTE/XCJ2ZWMyZlwiOmBtYXQyeCR7b31mYCwkPW89PT0xP2c6YHZlYyR7b308JHtnfT5gLGI9eWMoZSx0WzBdLHRbMV0sdFsyXSxzLGwsdSxyLmVwc2lsb24pLFM9ST0+YFxuICBjb25zdCBIOiB1MzIgPSAke2x9O1xuICBjb25zdCBDOiB1MzIgPSAke3Uvb307XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7bS50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZUlucHV0IDogYXJyYXk8JHt2fT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHt5LnR5cGUuc3RvcmFnZX0+O1xuXG4gICR7SS5tYWluU3RhcnQoKX1cbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvIChDICogSCk7XG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gZ2xvYmFsX2lkeCAlIEM7XG5cbiAgICBsZXQgc2NhbGVPZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiBDICsgY3VycmVudENoYW5uZWxOdW1iZXI7XG4gICAgbGV0IHNjYWxlID0gc2NhbGVJbnB1dFtzY2FsZU9mZnNldF07XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAkeyR9KHNjYWxlWzBdKSwgJHskfShzY2FsZVsxXSkpO1xuICB9YDtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHtyLmNhY2hlS2V5fWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9fSksZ2V0U2hhZGVyU291cmNlOlN9LHtpbnB1dHM6W3RbMF0sYl19KX0sWXM9ZT0+aWUoe2Vwc2lsb246ZS5lcHNpbG9uLGZvcm1hdDplLmZvcm1hdH0pLFhzPShlLHQpPT57dC5mb3JtYXQ9PT1cIk5IV0NcIj9iYyhlLGUuaW5wdXRzLHQpOmUuY29tcHV0ZShnYyhlLmlucHV0cyx0KSl9fSk7dmFyIHdjLHZjLFFzLFpzLGV1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7a2UoKTt2ZSgpO3djPWU9PntpZighZXx8ZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuXCIpfSx2Yz0oZSx0LHIpPT57bGV0IGE9ZVswXS5kaW1zLG49ZVsxXSxzPWVbMl0sdT1hLGw9ei5ub3JtYWxpemVBeGlzKHQuYXhpcyxhLmxlbmd0aCksbz16LnNpemVUb0RpbWVuc2lvbihhLGwpLHA9ei5zaXplRnJvbURpbWVuc2lvbihhLGwpLG09ei5zaXplKG4uZGltcykseT1zP3ouc2l6ZShzLmRpbXMpOjA7aWYobSE9PXB8fHMmJnkhPT1wKXRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7cH0uXG4gICAgICAgU2l6ZSBvZiBzY2FsZSBhbmQgYmlhcyAoaWYgcHJvdmlkZWQpIG11c3QgbWF0Y2ggdGhpcy5cbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke219IGFuZCBiaWFzIHNpemUgb2YgJHt5fWApO2xldCBnPVtdO2ZvcihsZXQgUD0wO1A8YS5sZW5ndGg7KytQKVA8bD9nLnB1c2goYVtQXSk6Zy5wdXNoKDEpO2xldCB2PW10KHApLCQ9QmUoZVswXS5kYXRhVHlwZSksYj1bRihcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyx2KSxGKFwic2NhbGVcIixuLmRhdGFUeXBlLG4uZGltcyx2KV07cyYmYi5wdXNoKEYoXCJiaWFzXCIscy5kYXRhVHlwZSxzLmRpbXMsdikpLGIucHVzaChYKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx1LHYpKTtsZXQgUz1yPjEsST1yPjI7UyYmYi5wdXNoKFgoXCJtZWFuRGF0YU91dHB1dFwiLDEsZykpLEkmJmIucHVzaChYKFwiaW52U3RkT3V0cHV0XCIsMSxnKSk7bGV0IFQ9UD0+YFxuICBjb25zdCBub3JtU2l6ZTogZjMyID0gJHtwfTtcbiAgY29uc3Qgbm9ybVNpemVWZWN0b3JpemVkOiB1MzIgPSAke3Avdn07XG4gIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7dC5lcHNpbG9ufTtcblxuICAke1AuZGVjbGFyZVZhcmlhYmxlcyguLi5iKX1cbiAgJHtQLm1haW5TdGFydCgpfVxuICAgICR7UC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG8pfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogbm9ybVNpemVWZWN0b3JpemVkO1xuICAgIHZhciBtZWFuVmVjdG9yID0gJHtRZShcImYzMlwiLHYpfTtcbiAgICB2YXIgbWVhblNxdWFyZVZlY3RvciA9ICR7UWUoXCJmMzJcIix2KX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IG5vcm1TaXplVmVjdG9yaXplZDsgaCsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke0R0KCQsdixcInhbaCArIG9mZnNldF1cIil9O1xuICAgICAgbWVhblZlY3RvciArPSB2YWx1ZTtcbiAgICAgIG1lYW5TcXVhcmVWZWN0b3IgKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IG1lYW4gPSAke1N0KFwibWVhblZlY3RvclwiLHYpfSAvIG5vcm1TaXplO1xuICAgIGxldCBtZWFuU3F1YXJlID0gc3FydCgke1N0KFwibWVhblNxdWFyZVZlY3RvclwiLHYpfSBcbiAgICAgIC8gbm9ybVNpemUgLSBtZWFuICogbWVhbiArIGVwc2lsb24pO1xuXG4gICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8IG5vcm1TaXplVmVjdG9yaXplZDsgaisrKSB7XG4gICAgICBsZXQgZjMyaW5wdXQgPSAke0R0KCQsdixcInhbaiArIG9mZnNldF1cIil9O1xuICAgICAgbGV0IGYzMnNjYWxlID0gJHtEdCgkLHYsXCJzY2FsZVtqXVwiKX07XG4gICAgICBvdXRwdXRbaiArIG9mZnNldF0gPSAke2JbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0IC0gbWVhbikgLyBtZWFuU3F1YXJlICogZjMyc2NhbGVcbiAgICAgICAgJHtzP2ArICR7RHQoJCx2LFwiYmlhc1tqXVwiKX1gOlwiXCJ9XG4gICAgICApO1xuICAgIH1cblxuICAgICR7Uz9cIm1lYW5EYXRhT3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xuICAgICR7ST9cImludlN0ZE91dHB1dFtnbG9iYWxfaWR4XSA9IDEgLyBtZWFuU3F1YXJlXCI6XCJcIn07XG4gIH1gLEI9W3tkaW1zOnUsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiBTJiZCLnB1c2goe2RpbXM6ZyxkYXRhVHlwZToxfSksSSYmQi5wdXNoKHtkaW1zOmcsZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke2UubGVuZ3RofWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpCLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfX0pLGdldFNoYWRlclNvdXJjZTpUfX0sUXM9ZT0+aWUoe2F4aXM6ZS5heGlzLGVwc2lsb246ZS5lcHNpbG9ufSksWnM9KGUsdCk9Pnt3YyhlLmlucHV0cyksZS5jb21wdXRlKHZjKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCkpfX0pO3ZhciAkYyx0dSxydT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTticigpOyRjPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sdHU9ZT0+eyRjKGUuaW5wdXRzKTtsZXQgdD1udC5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2UuY29tcHV0ZShjbihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwiLGFjdGl2YXRpb25DYWNoZUtleTpcIlwifSx0KSl9fSk7dmFyIHhjLFNjLENjLEljLEFjLEVjLF9jLE9jLFRjLG51LGF1LG91PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7a2UoKTt2ZSgpO3hjPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gZmV3IGlucHV0c1wiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQuXCIpO2lmKGUubGVuZ3RoPj0yKXtsZXQgdD1lWzBdLmRpbXMubGVuZ3RoKjI9PT1lWzFdLmRpbXNbMF07aWYoZS5sZW5ndGg9PT00JiYodD1lWzNdLmRpbXNbMF0qMj09PWVbMV0uZGltc1swXSksIXQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhZHMgc2hvdWxkIGJlIGEgMUQgdGVuc29yIG9mIHNoYXBlIFsyICogaW5wdXRfcmFua10gb3IgWzIgKiBudW1fYXhlc10uXCIpfX0sU2M9KGUsdCxyLGEsbixzLHUpPT57bGV0IGw9ci5sZW5ndGgsbz1cIlwiO2ZvcihsZXQgcD1sLTE7cD49MDstLXApbys9YFxuICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixwKX0pIC0gJHtuW3BdfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49ICR7cltwXX0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7YVtwXX07XG4gICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgIHZhbHVlID0gJHtzfSgke3V9KTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke299XG4gICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICBgfSxDYz0oZSx0LHIsYSxuKT0+e2xldCBzPXIubGVuZ3RoLHU9XCJcIjtmb3IobGV0IGw9cy0xO2w+PTA7LS1sKXUrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGwpfSkgLSAke25bbF19O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAkezIqKHJbbF0tMSl9O1xuICAgICAgICAgICAgICAgICAgayA9IGsgJSBfMm5fMTtcbiAgICAgICAgICAgICAgICAgIGlmKGsgPj0gJHtyW2xdfSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7YVtsXX07XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHt1fVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxJYz0oZSx0LHIsYSxuKT0+e2xldCBzPXIubGVuZ3RoLHU9XCJcIjtmb3IobGV0IGw9cy0xO2w+PTA7LS1sKXUrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGwpfSkgLSAke25bbF19O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49ICR7cltsXX0pIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAke3JbbF0tMX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogJHthW2xdfTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3V9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LEFjPShlLHQscixhLG4pPT57bGV0IHM9ci5sZW5ndGgsdT1cIlwiO2ZvcihsZXQgbD1zLTE7bD49MDstLWwpdSs9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbCl9KSAtICR7bltsXX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSAge1xuICAgICAgICAgICAgICAgICAgayArPSAke3JbbF19O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSAke3JbbF19KSB7XG4gICAgICAgICAgICAgICAgICBrIC09ICR7cltsXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogJHthW2xdfTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3V9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LEVjPShlLHQscixhLG4scyk9Pntzd2l0Y2gobi5tb2RlKXtjYXNlIDA6cmV0dXJuIFNjKGUsdCxyLGEsbi5wYWRzLHMsbi52YWx1ZSk7Y2FzZSAxOnJldHVybiBDYyhlLHQscixhLG4ucGFkcyk7Y2FzZSAyOnJldHVybiBJYyhlLHQscixhLG4ucGFkcyk7Y2FzZSAzOnJldHVybiBBYyhlLHQscixhLG4ucGFkcyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVcIil9fSxfYz0oZSx0LHIsYSk9PntsZXQgbj10WzBdLmRpbXMscz16LnBhZFNoYXBlKG4uc2xpY2UoKSxyLnBhZHMpLHU9ei5zaXplKHMpLGw9ei5jb21wdXRlU3RyaWRlcyhuKSxvPVgoXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLHMpLHA9RihcInhcIix0WzBdLmRhdGFUeXBlLG4pLG09RWMobyxzLG4sbCxyLGEpO3JldHVybmBcbiAgICAgICAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXMocCxvKX1cbiAgICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7by5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2F9KDApO1xuICAgICAgICAgICAgICAke219XG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgIH1gfSxPYz0oZSx0KT0+e2xldCByPXoucGFkU2hhcGUoZVswXS5kaW1zLnNsaWNlKCksdC5wYWRzKTtyZXR1cm57bmFtZTpcIlBhZFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoei5zaXplKHIpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6YT0+X2MoYSxlLHQsXCJmMzJcIil9fSxUYz0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLGE9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbj1lWzBdLmRpbXMubGVuZ3RoLHM9bmV3IEludDMyQXJyYXkoMipuKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgbD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IG89MDtvPGwubGVuZ3RoO28rKylzW051bWJlcihsW29dKV09TnVtYmVyKHJbb10pLHNbTnVtYmVyKGxbb10pK25dPU51bWJlcihyW28rbC5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgobCxvKT0+c1tOdW1iZXIobyldPU51bWJlcihsKSk7bGV0IHU9W107cmV0dXJuIHMuZm9yRWFjaChsPT51LnB1c2gobCkpLGllKHttb2RlOnQubW9kZSx2YWx1ZTphLHBhZHM6dX0pfWVsc2UgcmV0dXJuIHR9LG51PShlLHQpPT57eGMoZS5pbnB1dHMpO2xldCByPVRjKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShPYyhlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxhdT1lPT57bGV0IHQ9ZS5tb2RlLHI9ZS52YWx1ZSxhPWUucGFkcztyZXR1cm4gaWUoe21vZGU6dCx2YWx1ZTpyLHBhZHM6YX0pfX0pO3ZhciBmbixpdSxzdSx1dSxsdSxkdSxjdSxwdSxmdSxtdSxodSxndSx5dSxidSx3dSx2dT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7Zm49ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHN1cHBvcnRzIDEtRCBvciAyLUQgaW5wdXRzIG9ubHkgZm9yIG5vdy5cIil9LGl1PShlLHQscik9PntsZXQgYT10LmZvcm1hdD09PVwiTkhXQ1wiLG49ZS5kaW1zLnNsaWNlKCk7YSYmbi5zcGxpY2UoMSwwLG4ucG9wKCkpO2xldCBzPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIiksdT10Lmtlcm5lbFNoYXBlLnNsaWNlKCksbD10LnN0cmlkZXMuc2xpY2UoKSxvPXM/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxwPXQucGFkcy5zbGljZSgpO010LmFkanVzdFBvb2xBdHRyaWJ1dGVzKHIsbix1LGwsbyxwKTtsZXQgbT1NdC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKHIsbixsLG8sdSxwLHQuYXV0b1BhZCkseT1PYmplY3QuYXNzaWduKHt9LHQpO3M/T2JqZWN0LmFzc2lnbih5LHtrZXJuZWxTaGFwZTp1LHN0cmlkZXM6bCxwYWRzOnAsZGlsYXRpb25zOm8sY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24oeSx7a2VybmVsU2hhcGU6dSxzdHJpZGVzOmwscGFkczpwLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTtsZXQgZz1tLnNsaWNlKCk7cmV0dXJuIGcucHVzaChnLnNwbGljZSgxLDEpWzBdKSxbeSxhP2c6bV19LHN1PShlLHQscixhLG4scyx1LGwpPT57bGV0IG89bi5mb3JtYXQ9PT1cIk5IV0NcIixwPXIsbT10LnR5cGUudmFsdWUseT1wLmxlbmd0aCxnPXouc2l6ZShhKSx2PVgoXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLGEpO2lmKG4ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgJD1uLmtlcm5lbFNoYXBlW24ua2VybmVsU2hhcGUubGVuZ3RoLTFdLGI9bi5zdHJpZGVzW24uc3RyaWRlcy5sZW5ndGgtMV0sUz1uLnBhZHNbbi5wYWRzLmxlbmd0aC8yLTFdLEk9bi5wYWRzW24ucGFkcy5sZW5ndGgtMV0sVD15LShvPzI6MSksQj1cIlwiLFA9XCJcIixEPVwiXCI7aWYoUytJIT09MD9CPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7JH11OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7VH1dID0gaW5kaWNlc1ske1R9XSAqICR7Yn0gLSAke1N9ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske1R9XSA8IDAgfHwgeEluZGljZXNbJHtUfV0gPj0gJHtwW1RdfSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtzfVxuICAgICAgICAgICAgICAgIH1gOkI9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHskfXU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtUfV0gPSBpbmRpY2VzWyR7VH1dICogJHtifSAtICR7U30gKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7c31cbiAgICAgICAgICAgICAgICB9YCxuLmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCBXPW4ua2VybmVsU2hhcGVbbi5rZXJuZWxTaGFwZS5sZW5ndGgtMl0sSD1uLnN0cmlkZXNbbi5zdHJpZGVzLmxlbmd0aC0yXSxLPW4ucGFkc1tuLnBhZHMubGVuZ3RoLzItMl0sbGU9bi5wYWRzW24ucGFkcy5sZW5ndGgtMl0sTT15LShvPzM6MikscT1wW01dO0srbGUhPT0wP1A9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgJHtXfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtNfV0gPSBpbmRpY2VzWyR7TX1dICogJHtIfSAtICR7S30gKyBqO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7TX1dIDwgMCB8fCB4SW5kaWNlc1ske019XSA+PSAke3F9KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCs9ICR7JH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgOlA9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgJHtXfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtNfV0gPSBpbmRpY2VzWyR7TX1dICogJHtIfSAtICR7S30gKyBqO1xuICAgICAgICAgICAgICAgIGAsRD1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXModCx2KX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhnKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7di5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHt2Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZTogJHttfSA9ICR7bX0oJHtsfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICAke1B9XG4gICAgICAgICAgICAgICR7Qn1cbiAgICAgICAgICAgICAgJHtEfVxuICAgICAgICAgICAgICAke3V9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH1lbHNle2lmKG8pdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCAkPXouc2l6ZShuLmtlcm5lbFNoYXBlKSxiPXouY29tcHV0ZVN0cmlkZXMobi5rZXJuZWxTaGFwZSksUz1iLmxlbmd0aCxJPW4ucGFkcy5sZW5ndGgsVD1uLnBhZHMucmVkdWNlKChELFIpPT5EK1IpLEI9XCJcIjtyZXR1cm4gVD9CPWBcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gaW5wdXREaW1zW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAke3N9XG4gICAgICAgICAgICAgIH1gOkI9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICR7c31cbiAgICAgICAgICAgIGAsYFxuICAgICAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXModCx2KX1cblxuICAgICAgICAgICAgY29uc3QgcGFkcyA9IGFycmF5PHUzMiwgJHtJfT4oJHtuLnBhZHMubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dERpbXMgPSBhcnJheTx1MzIsICR7eX0+KCR7cC5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbFN0cmlkZXMgPSBhcnJheTx1MzIsICR7U30+KCR7Yi5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmlkZXMgPSBhcnJheTx1MzIsICR7U30+KCR7bi5zdHJpZGVzLm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGcpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHt2Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICBsZXQgeEluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgICAgdmFyIG9mZnNldHM6IGFycmF5PHUzMiwgJHtTfT47XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHt2LnR5cGUudmFsdWV9KCR7bH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAkeyR9dTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDB1OyBqIDwgJHtTLTF9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gb2Zmc2V0IC8ga2VybmVsU3RyaWRlc1tqXTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICoga2VybmVsU3RyaWRlc1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske1MtMX1dID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHt5LVN9dTsgaiA8ICR7eX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7eS1TfXVdXG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHt5LVN9dV0gLSBwYWRzW2ogLSAydV07XG4gICAgICAgICAgICAgICAgICAke0J9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHt1fVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9fSx1dT1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxsdT0oZSx0LHIsYSk9PntsZXRbbixzXT1pdSh0LGEsciksdT16LnNpemUobi5rZXJuZWxTaGFwZSksbD1GKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zKSxvPWwudHlwZS52YWx1ZSxwPVwidmFsdWUgKz0geF92YWw7XCIsbT1cIlwiO3JldHVybiBuLmNvdW50SW5jbHVkZVBhZD9tKz1gdmFsdWUgLz0gJHtvfSgke3V9KTtgOm0rPWB2YWx1ZSAvPSAke299KCR7dX0gLSBwYWQpO2Ase25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDphLmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHouc2l6ZShzKS82NCl9fSksZ2V0U2hhZGVyU291cmNlOnk9PnN1KHksbCx0LmRpbXMscyxuLHAsbSxcIjAuMFwiKX19LGR1PWU9PntsZXQgdD1lLmNvdW50X2luY2x1ZGVfcGFkIT09MCxyPXV1KGUpO2lmKHIuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7cmV0dXJuIGllKHtjb3VudEluY2x1ZGVQYWQ6dCwuLi5yfSl9LGN1PShlLHQpPT57Zm4oZS5pbnB1dHMpLGUuY29tcHV0ZShsdShcIkF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxwdT17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W10sY2FjaGVLZXk6XCJcIn0sZnU9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5wdSxjYWNoZUtleTp0fX0sbXU9KGUsdCk9PntmbihlLmlucHV0cyksZS5jb21wdXRlKGx1KFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LGh1PShlLHQscixhKT0+e2xldFtuLHNdPWl1KHQsYSxyKSx1PWBcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XG4gICAgYCxsPVwiXCIsbz1GKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmEuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoei5zaXplKHMpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6cD0+c3UocCxvLHQuZGltcyxzLG4sdSxsLFwiLTFlNVwiKX19LGd1PShlLHQpPT57Zm4oZS5pbnB1dHMpLGUuY29tcHV0ZShodShcIk1heFBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LHl1PWU9PntsZXQgdD1lLnN0b3JhZ2Vfb3JkZXIscj1lLmRpbGF0aW9ucyxhPXV1KGUpO2lmKHQhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKGEuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtyZXR1cm4gaWUoe3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpyLC4uLmF9KX0sYnU9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5wdSxjYWNoZUtleTp0fX0sd3U9KGUsdCk9PntmbihlLmlucHV0cyksZS5jb21wdXRlKGh1KFwiR2xvYmFsTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX19KTt2YXIgUGMsa2MsJHUseHU9TCgoKT0+e1widXNlIHN0cmljdFwiOyR0KCk7RGUoKTt2ZSgpO1BjPShlLHQscik9PntsZXQgYT1lPT09dCxuPWU8dCYmcjwwLHM9ZT50JiZyPjA7aWYoYXx8bnx8cyl0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSB0aGVzZSBpbnB1dHMnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLlwiKX0sa2M9KGUsdCxyLGEpPT57bGV0IG49TWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL3IpKSxzPVtuXSx1PW4sbD1YKFwib3V0cHV0XCIsYSxzKSxvPWwudHlwZS5zdG9yYWdlLHA9bT0+YFxuICAgICAgICAke20uZGVjbGFyZVZhcmlhYmxlcyhsKX1cbiAgICAgICAgJHttLm1haW5TdGFydCgpfVxuICAgICAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtvfSgke2V9KSArICR7b30oZ2xvYmFsX2lkeCkgKiAke299KCR7cn0pO1xuICAgICAgfWA7cmV0dXJue25hbWU6XCJSYW5nZVwiLHNoYWRlckNhY2hlOntoaW50OltlLHQscl0ubWFwKG09Pm0udG9TdHJpbmcoKSkuam9pbihcIl9cIil9LGdldFNoYWRlclNvdXJjZTpwLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwodS82NCl9fSl9fSwkdT1lPT57bGV0IHQ9MCxyPTAsYT0wO2UuaW5wdXRzWzBdLmRhdGFUeXBlPT09Nj8odD1lLmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRJbnQzMkFycmF5KClbMF0sYT1lLmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF0pOmUuaW5wdXRzWzBdLmRhdGFUeXBlPT09MSYmKHQ9ZS5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxhPWUuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdKSxJZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJlBjKHQscixhKSxlLmNvbXB1dGUoa2ModCxyLGEsZS5pbnB1dHNbMF0uZGF0YVR5cGUpLHtpbnB1dHM6W119KX19KTt2YXIgQmMsTWMsRGMsemMsV2MsTmMsVmMsVWMsR2MsRmMsTGMsSGMsamMscWMsS2MsU3UsQ3UsSXU9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO0JjPShlLHQpPT57aWYoZS5ldmVyeShyPT5yPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGxpbmVhciBtb2RlXCIpfWVsc2UgaWYodC5tb2RlPT09XCJjdWJpY1wiJiYhKGUubGVuZ3RoPT09Mnx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBjdWJpYyBtb2RlXCIpfX0sTWM9KGUsdCxyKT0+e3QuZXZlcnkobj0+bj49MCYmbjxyfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgYXhlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmUgYW5kIGxlc3MgdGhhbiByYW5rXCIpfSkpO2xldCBhPW5ldyBBcnJheShyKS5maWxsKDEpO3JldHVybiB0LmZvckVhY2goKG4scyk9PmFbbl09ZVtzXSksYX0sRGM9KGUsdCxyLGEsbixzKT0+e2xldFt1LGwsb109cj4xMD9bMSwyLDNdOlstMSxlLmxlbmd0aD4xPzE6LTEsLTFdLHA9ZVswXS5kaW1zLmxlbmd0aDtpZih1PjAmJmUubGVuZ3RoPnUmJmVbdV0uZGltcy5sZW5ndGg+MCllW3VdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2gobT0+cy5wdXNoKG0pKTtlbHNlIGlmKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBSb0kgaW5wdXQgdG8gYmUgc3BlY2lmaWVkIHdoZW4gY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgaXMgdGZDcm9wQW5kUmVzaXplXCIpO2lmKGw+MCYmZS5sZW5ndGg+bCYmZVtsXS5kaW1zLmxlbmd0aD4wKXtpZihlW2xdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2gobT0+YS5wdXNoKG0pKSxhLmxlbmd0aCE9PTAmJmEubGVuZ3RoIT09cCYmcj49MTgmJmEubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO0JjKGEsdCksdC5heGVzLmxlbmd0aD4wJiZNYyhhLHQuYXhlcyxwKS5mb3JFYWNoKChtLHkpPT5hW3ldPW0pfWlmKG8+MCYmZS5sZW5ndGg+byYmKGVbb10uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobT0+bi5wdXNoKE51bWJlcihtKSkpLG4ubGVuZ3RoIT09cHx8cj49MTgmJm4ubGVuZ3RoPT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYoYS5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2NhbGVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyk7aWYobi5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpfWlmKHR5cGVvZiBhPFwidVwiJiZ0eXBlb2YgbjxcInVcIiYmYS5sZW5ndGg+MCYmbi5sZW5ndGg+cCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkXCIpfSx6Yz1lPT5cImZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogZjMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogZjMyLCAgICBsZW5ndGhPcmlnaW5hbDogZjMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gZjMyIHsgXCIrKCgpPT57c3dpdGNoKGUpe2Nhc2VcImFzeW1tZXRyaWNcIjpyZXR1cm5cInJldHVybiB4UmVzaXplZCAvIHhTY2FsZTtcIjtjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpyZXR1cm5cImlmIChsZW5ndGhSZXNpemVkID4gMSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlIC0gMC41OyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJ0Zl9oYWxmX3BpeGVsX2Zvcl9ublwiOnJldHVyblwicmV0dXJuICh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGU7XCI7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnJldHVyblwiaWYgKGxlbmd0aFJlc2l6ZWQgPT0gMSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwidGZfY3JvcF9hbmRfcmVzaXplXCI6cmV0dXJuXCJpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9pU3RhcnQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSArICAgICAgICAgICAgICAgICAgICAgICAgICAgKHhSZXNpemVkICogKHJvaUVuZCAtIHJvaVN0YXJ0KSAqIChsZW5ndGhPcmlnaW5hbCAtIDEpKSAvIChsZW5ndGhSZXNpemVkIC0gMSk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChyb2lTdGFydCArIHJvaUVuZCkgKiBmMzIobGVuZ3RoT3JpZ2luYWwgLSAxKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuW1wiY29uc3Qgb3V0cHV0V2lkdGggPSB4U2NhbGUgKiBsZW5ndGhSZXNpemVkO1wiLFwiY29uc3QgYWRqdXN0bWVudCA9IGxlbmd0aFJlc2l6ZWQgLyBvdXRwdXRXaWR0aDtcIixcImNvbnN0IGNlbnRlciA9IGxlbmd0aE9yaWdpbmFsIC8gMjtcIixcImNvbnN0IG9mZnNldCA9IGNlbnRlciAqICgxIC0gYWRqdXN0bWVudCk7XCIsXCJyZXR1cm4gb2Zmc2V0ICsgKCh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGUpIC0gMC41O1wiXS5qb2luKGBcbmApO2Nhc2VcImhhbGZfcGl4ZWxcIjpyZXR1cm5cInJldHVybiAoKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZSkgLSAwLjU7XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixXYz0oZSx0KT0+XCJmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiBmMzIsIGlzRG93blNhbXBsZTogYm9vbCkgLT4gZjMyIHtcIisoKCk9Pntzd2l0Y2goZSl7Y2FzZVwicm91bmRfcHJlZmVyX2NlaWxcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICB9XCI7Y2FzZVwiZmxvb3JcIjpyZXR1cm5cInJldHVybiBmbG9vcih4T3JpZ2luYWwpO1wiO2Nhc2VcImNlaWxcIjpyZXR1cm5cInJldHVybiBjZWlsKHhPcmlnaW5hbCk7XCI7Y2FzZVwicm91bmRfcHJlZmVyX2Zsb29yXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInNpbXBsZVwiOmRlZmF1bHQ6aWYodDwxMSlyZXR1cm5cImlmIChpc0Rvd25TYW1wbGUpICAgICAgICAgICAgICAgICAgICAgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgICAgICAgICAgICAgICAgICAgICB9XCI7dGhyb3cgbmV3IEVycm9yKGBOZWFyZXN0IG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixOYz0oZSx0LHIpPT57bGV0IGE9bmV3IEFycmF5KHIpLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyKS5maWxsKDEpKSxuPWUubGVuZ3RoPT09MD9hOmUuc2xpY2UoKTtyZXR1cm4gdC5sZW5ndGg+MD8odC5mb3JFYWNoKChzLHUpPT57YVtzXT1uW3VdLGFbdStyXT1uW3QubGVuZ3RoK3VdfSksYSk6bn0sVmM9KGUsdCxyLGEpPT57bGV0IG49W107aWYoci5sZW5ndGg+MClpZihhLmxlbmd0aD4wKXtpZihlLmZvckVhY2gocz0+bi5wdXNoKHMpKSxNYXRoLm1heCguLi5hKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzIGlzIG91dCBvZiBib3VuZFwiKTthLmZvckVhY2goKHMsdSk9Pm5bc109clt1XSl9ZWxzZSByLmZvckVhY2gocz0+bi5wdXNoKHMpKTtlbHNle2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy5cIik7bj1lLm1hcCgocyx1KT0+TWF0aC5yb3VuZChzKnRbdV0pKX1yZXR1cm4gbn0sVWM9KGUsdCxyLGEpPT57bGV0IG49KCgpPT57c3dpdGNoKGEua2VlcEFzcGVjdFJhdGlvUG9saWN5KXtjYXNlXCJub3RfbGFyZ2VyXCI6cmV0dXJuIGEuYXhlcy5sZW5ndGg+MD9NYXRoLm1pbiguLi5hLmF4ZXMubWFwKHU9PnJbdV0pLE51bWJlci5NQVhfVkFMVUUpOk1hdGgubWluKC4uLnIsTnVtYmVyLk1BWF9WQUxVRSk7Y2FzZVwibm90X3NtYWxsZXJcIjpyZXR1cm4gYS5heGVzLmxlbmd0aD4wP01hdGgubWF4KC4uLmEuYXhlcy5tYXAodT0+clt1XSksTnVtYmVyLk1JTl9WQUxVRSk6TWF0aC5tYXgoLi4ucixOdW1iZXIuTUlOX1ZBTFVFKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgS2VlcCBhc3BlY3QgcmF0aW8gcG9saWN5ICR7YS5rZWVwQXNwZWN0UmF0aW9Qb2xpY3l9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpO3IuZmlsbCgxLDAsci5sZW5ndGgpO2xldCBzPWUuc2xpY2UoKTtyZXR1cm4gYS5heGVzLmxlbmd0aD4wPyhhLmF4ZXMuZm9yRWFjaCh1PT5yW3VdPW4pLGEuYXhlcy5mb3JFYWNoKHU9PnNbdV09TWF0aC5yb3VuZChlW3VdKnJbdV0pKSk6KHIuZmlsbChuLDAsci5sZW5ndGgpLHMuZm9yRWFjaCgodSxsKT0+c1tsXT1NYXRoLnJvdW5kKHUqcltsXSkpKSxzfSxHYz0oZSx0LHIsYSxuKT0+YFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTxmMzIsICR7ci5sZW5ndGh9PiB7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3QubGVuZ3RofT4oJHt0Lm1hcChzPT5gJHtzfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhcnJheTx1MzIsICR7ci5sZW5ndGh9Pigke3IubWFwKHM9PmAke3N9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICBjb25zdCBzY2FsZXMgPSBhcnJheTxmMzIsICR7YS5sZW5ndGh9Pigke2EubWFwKHM9PmAke3N9ZmApLmpvaW4oXCIsXCIpfSk7XG4gICAgICBjb25zdCByb2kgPSBhcnJheTxmMzIsICR7bi5sZW5ndGh9Pigke24ubWFwKHM9PmAke3N9ZmApLmpvaW4oXCIsXCIpfSk7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzOiBhcnJheTxmMzIsICR7ci5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHtyLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6XCJvdXRwdXRJbmRpY2VzW2ldXCJ9O1xuICAgICAgICBpZiAoc2NhbGVzW2ldID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsSW5kaWNlc1tpXSA9IGYzMihvdXRwdXRJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWxJbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGYzMihvdXRwdXRJbmRleCksIHNjYWxlc1tpXSxcbiAgICAgICAgICAgICAgICBmMzIob3V0cHV0U2hhcGVbaV0pLCBmMzIoaW5wdXRTaGFwZVtpXSksIHJvaVtpXSwgcm9pW2kgKyAke3QubGVuZ3RofV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxJbmRpY2VzO1xuICAgIH1gLEZjPShlLHQscixhLG4scyx1KT0+YFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7ci5sZW5ndGh9Pigke3IubWFwKGw9PmAke2x9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYXJyYXk8dTMyLCAke2EubGVuZ3RofT4oJHthLm1hcChsPT5gJHtsfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBzY2FsZXMgPSBhcnJheTxmMzIsICR7bi5sZW5ndGh9Pigke24ubWFwKGw9PmAke2x9ZmApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IHJvaSA9IGFycmF5PGYzMiwgJHtzLmxlbmd0aH0+KCR7cy5tYXAobD0+YCR7bH1mYCkuam9pbihcIixcIil9KTtcbiAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7YS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke2EubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpcIm91dHB1dEluZGljZXNbaV1cIn07XG4gICAgICAgICAgdmFyIGlucHV0SW5kZXg6IHUzMjtcbiAgICAgICAgICBpZiAoc2NhbGVzW2ldID09IDEuMCkge1xuICAgICAgICAgICAgaW5wdXRJbmRleCA9IG91dHB1dEluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGYzMihvdXRwdXRJbmRleCksIHNjYWxlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgZjMyKG91dHB1dFNoYXBlW2ldKSwgZjMyKGlucHV0U2hhcGVbaV0pLCByb2lbaV0sIHJvaVtpICsgJHtyLmxlbmd0aH1dKTtcbiAgICAgICAgICAgIGlmICghJHt1fSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgZjMyKGlucHV0U2hhcGVbaV0pKSkge1xuICAgICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIGlucHV0SW5kZXggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+IChmMzIoaW5wdXRTaGFwZVtpXSkgLSAxKSkge1xuICAgICAgICAgICAgICAgIGlucHV0SW5kZXggPSBpbnB1dFNoYXBlW2ldIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlc1tpXSA8IDEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRJbmRleFwiKX1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRJbmRpY2VzO1xuICAgIH1gLExjPShlLHQpPT5gXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3QubGVuZ3RofT4oJHt0Lm1hcChyPT5gJHtyfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRJbmRleCA9ICR7dC5sZW5ndGg9PT0xP1wiaW5wdXRJbmRpY2VzXCI6XCJpbnB1dEluZGljZXNbaV1cIn07XG4gICAgICAgIGlmIChpbnB1dEluZGV4IDwgMCB8fCBpbnB1dEluZGV4ID49IGlucHV0U2hhcGVbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gLEhjPShlLHQscixhLG4scyx1KT0+e2xldFtsLG8scCxtXT1yLmxlbmd0aD09PTI/Wy0xLDAsMSwtMV06blsxXT09PTE/WzAsMiwzLDFdOlswLDEsMiwzXTtyZXR1cm5gXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gZjMyIHtcbiAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgaW5wdXRJbmRpY2VzWyR7b31dID0gbWF4KDAsIG1pbihyb3csICR7cltvXX0gLSAxKSk7XG4gICAgICBpbnB1dEluZGljZXNbJHtwfV0gPSBtYXgoMCwgbWluKGNvbCwgJHtyW3BdfSAtIDEpKTtcbiAgICAgIGlmICgke3IubGVuZ3RofSA+IDIpIHtcbiAgICAgICAgaW5wdXRJbmRpY2VzWyR7bX1dID0gY2hhbm5lbDtcbiAgICAgICAgaW5wdXRJbmRpY2VzWyR7bH1dID0gYmF0Y2g7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGlucHV0WyR7ZS5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNcIil9XTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+IGYzMiB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlcyk7XG4gICAgICB2YXIgcm93OmYzMiA9IG9yaWdpbmFsSW5kaWNlc1ske299XTtcbiAgICAgIHZhciBjb2w6ZjMyID0gb3JpZ2luYWxJbmRpY2VzWyR7cH1dO1xuICAgICAgaWYgKCR7c30gJiYgKHJvdyA8IDAgfHwgcm93ID4gKCR7cltvXX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICR7cltwXX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHt1fTtcbiAgICAgIH1cbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke3Jbb119IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7cltwXX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAwO1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAwO1xuICAgICAgaWYgKCR7ci5sZW5ndGg+Mn0pIHtcbiAgICAgICAgY2hhbm5lbCA9IHUzMihvcmlnaW5hbEluZGljZXNbJHttfV0pO1xuICAgICAgICBiYXRjaCA9IHUzMihvcmlnaW5hbEluZGljZXNbJHtsfV0pO1xuICAgICAgfVxuICAgICAgdmFyIHgxMTogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcbiAgICAgIHZhciB4MjE6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xuICAgICAgdmFyIHgyMjogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiBmMzIgPSByb3cgLSBmMzIocm93MSk7XG4gICAgICB2YXIgZHgyOiBmMzIgPSBmMzIocm93MiApIC0gcm93O1xuICAgICAgdmFyIGR5MSA9IGNvbCAtIGYzMihjb2wxKTtcbiAgICAgIHZhciBkeTIgPSBmMzIoY29sMikgLSBjb2w7XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWB9LGpjPShlLHQscixhLG4scyx1LGwsbyxwKT0+e2xldFttLHldPXIubGVuZ3RoPT09Mj9bMCwxXTpuWzFdPT09MT9bMiwzXTpbMSwyXSxnPXY9PntsZXQgJD12PT09bT9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxuICAgICAgZm4gJHskfUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9LCBvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gZjMyIHtcbiAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHthLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6YG91dHB1dEluZGljZXNbJHt2fV1gfTtcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiBmMzIgPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoZjMyKG91dHB1dEluZGV4KSwgJHtuW3ZdfSxcbiAgICAgICAgZjMyKCR7YVt2XX0pLCBmMzIoJHtyW3ZdfSksICR7c1t2XX0sICR7c1t2XX0gKyAke3IubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiBmMzIgPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7bH0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke3Jbdl19IC0gMSkpKSB7XG4gICAgICAgICAgcmV0dXJuICR7b307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PGYzMiwgND4gPSBhcnJheTxmMzIsIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyICR7JH06IGYzMiA9IG9yaWdpbmFsSWR4ICsgZjMyKGkpO1xuICAgICAgICAgIGlmICgkeyR9IDwgMCB8fCAkeyR9ID49ICR7clt2XX0pIHtcbiAgICAgICAgICAgIGlmICgke3B9KSB7XG4gICAgICAgICAgICAgIGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR7bH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuICR7b307XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkeyR9ID0gbWF4KDAsIG1pbigkeyR9LCAke3Jbdl19IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzQ29weTogJHtlLnR5cGUuaW5kaWNlc30gPSBpbnB1dEluZGljZXM7XG4gICAgICAgICAgaW5wdXRJbmRpY2VzQ29weVske3Z9XSA9IHUzMigkeyR9KTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7dj09PW0/YGlucHV0WyR7ZS5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNDb3B5XCIpfV07YDpgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dEluZGljZXNDb3B5LCBvdXRwdXRJbmRpY2VzKTtgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XG4gICAgICB9YH07cmV0dXJuYFxuICAgICR7ZyhtKX07XG4gICAgJHtnKHkpfTtcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogZjMyKSAtPiBhcnJheTxmMzIsIDQ+IHtcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcbiAgICB2YXIgY29lZmZzOiBhcnJheTxmMzIsIDQ+ID0gYXJyYXk8ZjMyLCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6IGYzMiA9IDEuMCAtIGFic1M7XG4gICAgdmFyIHR3b01pbnVzQWJzUzogZjMyID0gMi4wIC0gYWJzUztcbiAgICB2YXIgb25lUGx1c0Fic1M6IGYzMiA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke3V9ICogb25lUGx1c0Fic1MgLSA1ICogJHt1fSkgKiBvbmVQbHVzQWJzUyArIDggKiAke3V9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7dX07XG4gICAgY29lZmZzWzFdID0gKCgke3V9ICsgMikgKiBhYnNTIC0gKCR7dX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke3V9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHt1fSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke3V9ICogdHdvTWludXNBYnNTIC0gNSAqICR7dX0pICogdHdvTWludXNBYnNTICsgOCAqICR7dX0pICogdHdvTWludXNBYnNTIC0gNCAqICR7dX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PGYzMiwgND4sIGNvZWZzOiBhcnJheTxmMzIsIDQ+KSAtPiBmMzIge1xuICAgIHZhciBjb2Vmc1N1bTogZjMyID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xuICB9XG5cbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+IGYzMiB7XG4gICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRJbmRpY2VzO1xuICAgIHJldHVybiBjb2xDdWJpY0ludGVycG9sYXRpb24oaW5wdXRJbmRpY2VzLCBvdXRwdXRJbmRpY2VzKTtcbiAgfVxuICAgIGB9LHFjPShlLHQscixhLG4scyk9PntsZXQgdT1lLmRpbXMsbD1OYyhzLHQuYXhlcyx1Lmxlbmd0aCksbz1WYyh1LGEsbix0LmF4ZXMpLHA9YS5zbGljZSgpO2EubGVuZ3RoPT09MCYmKHA9dS5tYXAoKFMsSSk9PlM9PT0wPzE6b1tJXS9TKSx0LmtlZXBBc3BlY3RSYXRpb1BvbGljeSE9PVwic3RyZXRjaFwiJiYobz1VYyh1LG8scCx0KSkpO2xldCBtPVgoXCJvdXRwdXRcIixlLmRhdGFUeXBlLG8pLHk9RihcImlucHV0XCIsZS5kYXRhVHlwZSx1KSxnPXouc2l6ZShvKSx2PXUubGVuZ3RoPT09by5sZW5ndGgmJnUuZXZlcnkoKFMsSSk9PlM9PT1vW0ldKSwkPXQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLGI9Uz0+YFxuICAgICAgJHt6Yyh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKX07XG4gICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gXG4gICAgICAgICAgICAgICR7TGMoeSx1KX07XG4gICAgICAgICAgICAgICR7V2ModC5uZWFyZXN0TW9kZSxyKX07XG4gICAgICAgICAgICAgICR7RmMoeSxtLHUsbyxwLGwsJCl9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtHYyhtLHUsbyxwLGwpfTtcbiAgICAgICAgICAgICAgJHtIYyh5LG0sdSxvLHAsJCx0LmV4dHJhcG9sYXRpb25WYWx1ZSl9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgICAgJHtqYyh5LG0sdSxvLHAsbCx0LmN1YmljQ29lZmZBLCQsdC5leHRyYXBvbGF0aW9uVmFsdWUsdC5leGNsdWRlT3V0c2lkZSl9O1xuICAgICAgICAgICAgYDtkZWZhdWx0OnRocm93IEVycm9yKFwiSW52YWxpZCByZXNpemUgbW9kZVwiKX19KSgpfTtcbiAgICAgICR7Uy5kZWNsYXJlVmFyaWFibGVzKHksbSl9XG4gICAgICAke1MubWFpblN0YXJ0KCl9XG4gICAgICAgICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGcpfVxuICAgICAgICBpZiAoJHt2fSkge1xuICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7eS50eXBlLmluZGljZXN9O1xuICAgICAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBpbnB1dEluZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dEluZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0WyR7eS5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwibGluZWFyXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlcyk7XCI7Y2FzZVwiY3ViaWNcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXMpO1wiO2RlZmF1bHQ6dGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2l6ZSBtb2RlOiAke3QubW9kZX1gKX19KSgpfTtcbiAgICAgICAgfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSZXNpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke3J9fCR7cC5sZW5ndGg+MD9wOlwiXCJ9fCR7bi5sZW5ndGg+MD9uOlwiXCJ9YH0sZ2V0U2hhZGVyU291cmNlOmIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChnLzY0KX19KX19LEtjPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sU3U9KGUsdCk9PntsZXQgcj1bXSxhPVtdLG49W10scz1LYyhlKTtEYyhlLmlucHV0cyx0LHMscixhLG4pLGUuY29tcHV0ZShxYyhlLmlucHV0c1swXSx0LHMscixhLG4pLHtpbnB1dHM6WzBdfSl9LEN1PWU9PntsZXQgdD1lLmFudGlhbGlhcyxyPWUuYXhlcyxhPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbj1lLmN1YmljQ29lZmZBLHM9ZS5leGNsdWRlT3V0c2lkZSE9PTAsdT1lLmV4dHJhcG9sYXRpb25WYWx1ZSxsPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LG89ZS5tb2RlLHA9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiBpZSh7YW50aWFsaWFzOnQsYXhlczpyLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOmEsY3ViaWNDb2VmZkE6bixleGNsdWRlT3V0c2lkZTpzLGV4dHJhcG9sYXRpb25WYWx1ZTp1LGtlZXBBc3BlY3RSYXRpb1BvbGljeTpsLG1vZGU6byxuZWFyZXN0TW9kZTpwfSl9fSk7dmFyIFljLFhjLEF1LEV1LF91PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7a2UoKTt2ZSgpO1ljPWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0scj1lWzFdLGE9ZVsyXTtpZih0LmRhdGFUeXBlIT09ci5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PWEuZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG49dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0scz10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMl0hPT1zKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihhLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKGEuZGltc1thLmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IHU9ZVszXTtpZih1LmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYodS5kaW1zW3UuZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCB1PWVbNF07aWYodS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKHUuZGltc1t1LmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LFhjPShlLHQscixhKT0+e2xldCBuPWVbMF0uZGltcyxzPXouc2l6ZShuKSx1PW4sbD1zLG89bi5zbGljZSgtMSlbMF0scD1hP24uc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLG09ZS5sZW5ndGg+Myx5PWUubGVuZ3RoPjQsZz1hJiZyPjEsdj1hJiZyPjIsJD1yPjMsYj1tdChvKSxTPVtGKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLGIpLEYoXCJza2lwXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsYiksRihcImdhbW1hXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsYildO20mJlMucHVzaChGKFwiYmV0YVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLGIpKSx5JiZTLnB1c2goRihcImJpYXNcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcyxiKSksUy5wdXNoKFgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHUsYikpLGcmJlMucHVzaChYKFwibWVhbk91dHB1dFwiLDEscCkpLHYmJlMucHVzaChYKFwiaW52U3RkT3V0cHV0XCIsMSxwKSksJCYmUy5wdXNoKFgoXCJpbnB1dFNraXBCaWFzU3VtXCIsZVswXS5kYXRhVHlwZSx1LGIpKTtsZXQgST1CZShlWzBdLmRhdGFUeXBlKSxUPVA9PmBcbiAgICAgIGNvbnN0IGhpZGRlblNpemU6IGYzMiA9ICR7b307XG4gICAgICBjb25zdCBoaWRkZW5TaXplVmVjdG9yaXplZDogdTMyID0gJHtvL2J9O1xuICAgICAgY29uc3QgZXBzaWxvbjogZjMyID0gJHt0LmVwc2lsb259O1xuXG4gICAgICAke1AuZGVjbGFyZVZhcmlhYmxlcyguLi5TKX1cblxuICAgICAgJHtQLm1haW5TdGFydCgpfVxuICAgICAgICAke1AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhsL28pfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIGhpZGRlblNpemVWZWN0b3JpemVkO1xuICAgICAgICB2YXIgc3VtID0gJHtRZShcImYzMlwiLGIpfTtcbiAgICAgICAgdmFyIHNxdWFyZVN1bSA9ICR7UWUoXCJmMzJcIixiKX07XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBoaWRkZW5TaXplVmVjdG9yaXplZDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNraXBWYWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNWYWx1ZSA9ICR7eT9cImJpYXNbaV1cIjpcIjAuMFwifTtcbiAgICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IHhbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRWYWx1ZSArIHNraXBWYWx1ZSArIGJpYXNWYWx1ZTtcbiAgICAgICAgICAkeyQ/XCJpbnB1dFNraXBCaWFzU3VtW29mZnNldCArIGldID0gdmFsdWU7XCI6XCJcIn1cbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcbiAgICAgICAgICBsZXQgZjMyVmFsdWUgPSAke0R0KEksYixcInZhbHVlXCIpfTtcbiAgICAgICAgICBzdW0gKz0gZjMyVmFsdWU7XG4gICAgICAgICAgc3F1YXJlU3VtICs9IGYzMlZhbHVlICogZjMyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lYW4gPSAke1N0KFwic3VtXCIsYil9IC8gaGlkZGVuU2l6ZTtcbiAgICAgICAgbGV0IHZhcmlhbmNlID0gc3FydCgke1N0KFwic3F1YXJlU3VtXCIsYil9IC8gaGlkZGVuU2l6ZSAtIG1lYW4gKiBtZWFuICsgZXBzaWxvbik7XG4gICAgICAgICR7Zz9cIm1lYW5PdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XG4gICAgICAgICR7dj9cImludlN0ZE91dHB1dFtnbG9iYWxfaWR4XSA9IDEuMCAvIHZhcmlhbmNlO1wiOlwiXCJ9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBoaWRkZW5TaXplVmVjdG9yaXplZDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAtICR7SX0obWVhbikpIC8gJHtJfSh2YXJpYW5jZSkgKiBnYW1tYVtpXVxuICAgICAgICAgICArICR7bT9cImJldGFbaV1cIjpcIjAuMFwifTtcbiAgICAgICAgfVxuICAgICAgfWAsQj1be2RpbXM6dSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIHI+MSYmQi5wdXNoKHtkaW1zOnAsZGF0YVR5cGU6MX0pLHI+MiYmQi5wdXNoKHtkaW1zOnAsZGF0YVR5cGU6MX0pLHI+MyYmQi5wdXNoKHtkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFNoYWRlclNvdXJjZTpULGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpCLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvby82NCl9fSl9fSxBdT0oZSx0KT0+e1ljKGUuaW5wdXRzKTtsZXQgYT1bMF07ZS5vdXRwdXRDb3VudD4xJiZhLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MiYmYS5wdXNoKC0zKSxlLm91dHB1dENvdW50PjMmJmEucHVzaCgzKSxlLmNvbXB1dGUoWGMoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50LCExKSx7b3V0cHV0czphfSl9LEV1PWU9PntsZXQgdD1lLmVwc2lsb247cmV0dXJuIGllKHtlcHNpbG9uOnR9KX19KTt2YXIgSmMsbW4sUWMsT3UsWmMsZXAsVHUsUnUsUHU9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtrZSgpO3ZlKCk7SmM9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtpZih0LmF4ZXMubGVuZ3RoIT09MCl7aWYodC5heGVzLmxlbmd0aCE9PXQuc3RhcnRzLmxlbmd0aHx8dC5heGVzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcywgc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIil9ZWxzZSBpZih0LnN0YXJ0cy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO2Uuc2xpY2UoMSkuZm9yRWFjaCgocixhKT0+e2lmKGVbYSsxXS5kYXRhVHlwZSE9PTYmJmVbYSsxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke2F9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKX0pfSxtbj0oZSx0KT0+e2xldCByPVtdO2lmKGUubGVuZ3RoPnQpaWYoZVt0XS5kYXRhVHlwZT09PTcpZVt0XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChhPT5yLnB1c2goTnVtYmVyKGEpKSk7ZWxzZSBpZihlW3RdLmRhdGFUeXBlPT09NillW3RdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKGE9PnIucHVzaChOdW1iZXIoYSkpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHt0fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7cmV0dXJuIHJ9LFFjPShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IHI9bW4oZSwxKSxhPW1uKGUsMiksbj1tbihlLDMpO3JldHVybiBuLmxlbmd0aD09PTAmJihuPVsuLi5BcnJheShlWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldKSxpZSh7c3RhcnRzOnIsZW5kczphLGF4ZXM6bn0pfWVsc2UgcmV0dXJuIHR9LE91PShlLHQscixhLG4pPT57bGV0IHM9ZTtyZXR1cm4gZTwwJiYocys9clthW3RdXSksblt0XTwwP01hdGgubWF4KDAsTWF0aC5taW4ocyxyW2FbdF1dLTEpKTpNYXRoLm1heCgwLE1hdGgubWluKHMsclthW3RdXSkpfSxaYz0oZSx0LHIsYSk9PmBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtyLmxlbmd0aH07IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke2EubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpcIm91dHB1dEluZGljZXNbaV1cIn07XG4gICAgICAgICAgICB2YXIgaW5wdXRJbmRleCA9IG91dHB1dEluZGV4ICogc3RlcHNbaV0gKyBzdGFydHNbaV0gKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRJbmRleCAvIGlucHV0U2hhcGVbaV07XG4gICAgICAgICAgICBpbnB1dEluZGV4ID0gaW5wdXRJbmRleCAlIGlucHV0U2hhcGVbaV07XG4gICAgICAgICAgICBpZiAoc2lnbnNbaV0gPCAwKSB7XG4gICAgICAgICAgICAgIGlucHV0SW5kZXggPSBpbnB1dFNoYXBlW2ldIC0gaW5wdXRJbmRleCAtIDF1ICsgc3RhcnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtyLmxlbmd0aD09PTE/XCJpbnB1dEluZGljZXNcIjpcImlucHV0SW5kaWNlc1tpXVwifSA9IGlucHV0SW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dEluZGljZXM7XG4gICAgICB9YCxlcD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxhPXouc2l6ZShyKSxuPXQuYXhlcy5sZW5ndGg+MD96Lm5vcm1hbGl6ZUF4ZXModC5heGVzLHIubGVuZ3RoKTpbLi4uQXJyYXkoci5sZW5ndGgpLmtleXMoKV0scz1tbihlLDQpO3MuZm9yRWFjaChiPT5iIT09MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwic3RlcCBjYW5ub3QgYmUgMFwiKX0pKSxzLmxlbmd0aD09PTAmJihzPUFycmF5KG4ubGVuZ3RoKS5maWxsKDEpKTtsZXQgdT10LnN0YXJ0cy5tYXAoKGIsUyk9Pk91KGIsUyxyLG4scykpLGw9dC5lbmRzLm1hcCgoYixTKT0+T3UoYixTLHIsbixzKSk7aWYobi5sZW5ndGghPT1yLmxlbmd0aClmb3IobGV0IGI9MDtiPHIubGVuZ3RoOysrYiluLmluY2x1ZGVzKGIpfHwodS5zcGxpY2UoYiwwLDApLGwuc3BsaWNlKGIsMCxyW2JdKSxzLnNwbGljZShiLDAsMSkpO2xldCBvPXMubWFwKGI9Pk1hdGguc2lnbihiKSk7cy5mb3JFYWNoKChiLFMsSSk9PntpZihiPDApe2xldCBUPShsW1NdLXVbU10pL2IsQj11W1NdLFA9QitUKnNbU107dVtTXT1QLGxbU109QixJW1NdPS1ifX0pO2xldCBwPXIuc2xpY2UoMCk7bi5mb3JFYWNoKChiLFMpPT57cFtiXT1NYXRoLmNlaWwoKGxbYl0tdVtiXSkvc1tiXSl9KTtsZXQgbT17ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9LHk9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUscCksZz1GKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLHIpLHY9ei5zaXplKHApLCQ9Yj0+YFxuICAgICAgJHtiLmRlY2xhcmVWYXJpYWJsZXMoZyx5KX1cbiAgICAgICAgY29uc3Qgc2lnbnMgPSBhcnJheTxpMzIsICR7by5sZW5ndGh9Pigke28ubWFwKFM9PmAke1N9aWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IGFycmF5PHUzMiwgJHt1Lmxlbmd0aH0+KCR7dS5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3QgZW5kcyA9IGFycmF5PHUzMiwgJHtsLmxlbmd0aH0+KCR7bC5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBhcnJheTx1MzIsICR7cy5sZW5ndGh9Pigke3MubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7ci5sZW5ndGh9Pigke3IubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XG5cbiAgICAgICAgJHtaYyhnLHkscixwKX1cbiAgICAgICAgJHtiLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHYpfVxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgIGxldCBpbnB1dEluZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0SW5kaWNlcyk7XG4gICAgICAgICAgJHt5LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGcuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpKX1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiU2xpY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke2VbNF0/LmRpbXM/P1wiXCJ9YH0sZ2V0U2hhZGVyU291cmNlOiQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlttXSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX19KX19LFR1PShlLHQpPT57SmMoZS5pbnB1dHMsdCk7bGV0IHI9UWMoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKGVwKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9LFJ1PWU9PntsZXQgdD1lLnN0YXJ0cyxyPWUuZW5kcyxhPWUuYXhlcztyZXR1cm4gaWUoe3N0YXJ0czp0LGVuZHM6cixheGVzOmF9KX19KTt2YXIgdHAscnAsa3UsQnUsTXU9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO3RwPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LHJwPShlLHQpPT57bGV0IHI9QmUoZS5kYXRhVHlwZSksYT1lLmRpbXMsbj16LnNpemUoYSkscz02NCx1PXQuYXhpcztpZih1PDAmJih1PWEubGVuZ3RoK3UpLHU8YS5sZW5ndGgtMSl0aHJvdyBuZXcgRXJyb3IoXCJzb2Z0bWF4IG9ubHkgc3VwcG9ydHMgbGFzdCBheGlzIGZvciBub3cuXCIpO2xldCBsPWFbdV0sbz1uL2wscD1tdChsKSxtPWwvcCx5PXA9PT0xP3I6YHZlYyR7cH08JHtyfT5gLGc9KGIsUyk9PlM9PT00P2BtYXgobWF4KCR7Yn0ueCwgJHtifS55KSwgbWF4KCR7Yn0ueiwgJHtifS53KSlgOlM9PT0yP2BtYXgoJHtifS54LCAke2J9LnkpYDpTPT09Mz9gbWF4KG1heCgke2J9LngsICR7Yn0ueSksICR7Yn0ueilgOmIsdj1yPT09XCJmMzJcIj9gdmFyIHRocmVhZE1heCA9ICR7eX0oLTMuNDAyODIzZSszOGYpO2A6YHZhciB0aHJlYWRNYXggPSAke3l9KC02NTUwNC4waCk7YDtyZXR1cm57bmFtZTpcIlNvZnRtYXhcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6b319KSxnZXRTaGFkZXJTb3VyY2U6Yj0+YFxuICAgICAgdmFyPHdvcmtncm91cD4gcm93TWF4U2hhcmVkIDogJHt5fTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7eX07XG4gICAgICB2YXI8d29ya2dyb3VwPiB0aHJlYWRTaGFyZWQgOiBhcnJheTwke3l9LCAke3N9PjtcblxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4IDogYXJyYXk8JHt5fT47XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdCA6IGFycmF5PCR7eX0+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt5fSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke3l9KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7c30sIDEsIDEpXG4gICAgICBmbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LCBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjM3UpIHtcbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWQueCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWQueCk7XG4gICAgICAgIGNvbnN0IHdnID0gJHtzfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9ICR7bX07XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gJHttfTtcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke3Z9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7eX0oJHtnKFwidGhyZWFkU2hhcmVkWzBdXCIscCl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7eX0oMC4wKTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcbiAgICAgICAgfVxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7eX0oJHtTdChcInRocmVhZFNoYXJlZFswXVwiLHApfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9YH19LGt1PShlLHQpPT57dHAoZS5pbnB1dHMpLGUuY29tcHV0ZShycChlLmlucHV0c1swXSx0KSl9LEJ1PWU9PmllKHtheGlzOmUuYXhpc30pfSk7dmFyIG5wLGFwLG9wLGlwLHNwLER1LHp1LFd1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtucD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIil9LGFwPShlLHQpPT57bGV0IHI9W10sYT10Lm51bU91dHB1dHM7cmV0dXJuIGVbMV0uZGltc1swXT4wJiYoZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChuPT5yLnB1c2goTnVtYmVyKG4pKSksYT1yLmxlbmd0aCksaWUoe251bU91dHB1dHM6YSxheGlzOnQuYXhpcyxzcGxpdFNpemVzOnJ9KX0sb3A9ZT0+YFxuZm4gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX11OyBpICs9IDF1ICkge1xuICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG59YCxpcD1lPT57bGV0IHQ9ZS5sZW5ndGgscj1bXTtmb3IobGV0IGE9MDthPHQ7KythKXtsZXQgbj1lW2FdLnNldEJ5SW5kaWNlcyhcImluZGljZXNcIixcImlucHV0W2dsb2JhbF9pZHhdXCIpO3Q9PT0xP3IucHVzaChuKTphPT09MD9yLnB1c2goYGlmIChvdXRwdXROdW1iZXIgPT0gJHthfXUpIHsgJHtufSB9YCk6YT09PXQtMT9yLnB1c2goYGVsc2UgeyAke259IH1gKTpyLnB1c2goYGVsc2UgaWYgKG91dHB1dE51bWJlciA9PSAke2F9KSB7ICR7bn0gfWApfXJldHVybmBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXROdW1iZXI6IHUzMiwgaW5kaWNlczogJHtlWzBdLnR5cGUuaW5kaWNlc30sIGdsb2JhbF9pZHg6IHUzMikge1xuICAgICAgICAke3Iuam9pbihgXG5gKX1cbiAgICAgIH1gfSxzcD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxhPXouc2l6ZShyKSxuPWVbMF0uZGF0YVR5cGUscz1yLmxlbmd0aCx1PXQuYXhpcyxsPXU8MD9yLmxlbmd0aCt1OnUsbz1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxwPUYoXCJpbnB1dFwiLG4sciksbT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSx5PVtdLGc9W10sdj0wO2ZvcihsZXQgUz0wO1M8dC5udW1PdXRwdXRzO1MrKyl7dis9dC5zcGxpdFNpemVzW1NdLG1bU109djtsZXQgST1yLnNsaWNlKCk7SVt0LmF4aXNdPXQuc3BsaXRTaXplc1tTXSxnLnB1c2goSSksb1tTXT1YKGBvdXRwdXQke1N9YCxuLGdbU10pLHkucHVzaCh7ZGltczpnW1NdLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX1sZXQgJD1zPDI/XCJpbmRpY2VzXCI6YGluZGljZXNbJHtsfV1gLGI9Uz0+YFxuICAke1MuZGVjbGFyZVZhcmlhYmxlcyhwLC4uLm8pfVxuICBjb25zdCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke20ubGVuZ3RofT4oJHttLm1hcChJPT5gJHtJfXVgKS5qb2luKFwiLFwiKX0pO1xuICAke29wKG0ubGVuZ3RoKX1cbiAgJHtpcChvKX1cblxuICAke1MubWFpblN0YXJ0KCl9XG4gICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYSl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7cC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgb3V0cHV0TnVtYmVyID0gY2FsY3VsYXRlT3V0cHV0SW5kZXgoJHskfSk7XG4gICAgaWYgKG91dHB1dE51bWJlciAhPSAwKSB7XG4gICAgICAgICR7JH0gLT0gc2l6ZUluQ29uY2F0QXhpc1tvdXRwdXROdW1iZXIgLSAxdV07XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyRGF0YShvdXRwdXROdW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0U2hhZGVyU291cmNlOmIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOnksZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSl9fSxEdT0oZSx0KT0+e25wKGUuaW5wdXRzKTtsZXQgcj1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6YXAoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHNwKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9LHp1PWU9PntsZXQgdD1lLmF4aXMscj1lLnNwbGl0U2l6ZXMsYT1lLm51bU91dHB1dHM8MD9yLmxlbmd0aDplLm51bU91dHB1dHM7aWYoYSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm51bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ2ggbXVzdCBiZSBlcXVhbFwiKTtyZXR1cm4gaWUoe2F4aXM6dCxudW1PdXRwdXRzOmEsc3BsaXRTaXplczpyfSl9fSk7dmFyIE51LHVwLGxwLGRwLFZ1LFV1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7dmUoKTtOdT1lPT5BcnJheS5mcm9tKGUuZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksdXA9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT02JiZlWzBdLmRhdGFUeXBlIT09MTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXNcIik7aWYoZVsxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIG9mIGludDY0IGRhdGEgdHlwZVwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EXCIpO2lmKE51KGVbMV0pLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvclwiKX0sbHA9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoOysrYSlyLnB1c2goZVthXSp0W2FdKTtyZXR1cm4gcn0sZHA9ZT0+e2xldCB0PWVbMF0uZGltcyxyPU51KGVbMV0pLGE9bHAodCxyKSxuPXouc2l6ZShhKSxzPWVbMF0uZGF0YVR5cGUsdT1GKFwiaW5wdXRcIixzLHQpLGw9WChcIm91dHB1dFwiLHMsYSksbz1wPT5gXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gJHt1LmluZGljZXMoLi4udCl9O1xuICAgICAgJHtwLmRlY2xhcmVWYXJpYWJsZXModSxsKX1cbiAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG4pfVxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgICBsZXQgaW5wdXREaW1WYWx1ZSA9ICR7bC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiaVwiKX0gICUgJHt1LmluZGljZXNHZXQoXCJpbnB1dFNoYXBlXCIsXCJpXCIpfTtcblxuICAgICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLFwiaW5wdXREaW1WYWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKSl9XG4gICAgfWA7cmV0dXJue25hbWU6XCJUaWxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cn1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfX0pLGdldFNoYWRlclNvdXJjZTpvfX0sVnU9ZT0+e3VwKGUuaW5wdXRzKSxlLmNvbXB1dGUoZHAoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIGNwLHBwLEd1LEZ1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7dmUoKTtjcD0oZSx0LHIsYSxuKT0+e2xldCBzPXouc2l6ZShyKSx1PU1hdGguY2VpbChzLzQpLGw9WChcIm91dHB1dERhdGFcIixuLHIsNCksbz1GKFwiYURhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcyw0KSxwPUYoXCJiRGF0YVwiLHRbMl0uZGF0YVR5cGUsdFsyXS5kaW1zLDQpLG09RihcImNEYXRhXCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsNCkseSxnPSh2LCQsYik9PmBzZWxlY3QoJHskfSwgJHt2fSwgJHtifSlgO2lmKCFhKXk9bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixnKG8uZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLHAuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLG0uZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtsZXQgdj0oJCxiLFM9XCJcIik9PntsZXQgST1gYURhdGFbaW5kZXhBJHtifV1bY29tcG9uZW50QSR7Yn1dYCxUPWBiRGF0YVtpbmRleEIke2J9XVtjb21wb25lbnRCJHtifV1gLEI9YGJvb2woY0RhdGFbaW5kZXhDJHtifV0gJiAkezQyNzgxOTAwODA+Pj4oMy1iKSo4fXUpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7Yn0gPSAke2wub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke2J9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHtifSA9ICR7by5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7Yn1gLGwpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHtifSA9ICR7cC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7Yn1gLGwpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRDJHtifSA9ICR7bS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7Yn1gLGwpfTtcbiAgICAgICAgICAgIGxldCBpbmRleEEke2J9ID0gb2Zmc2V0QSR7Yn0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleEIke2J9ID0gb2Zmc2V0QiR7Yn0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleEMke2J9ID0gb2Zmc2V0QyR7Yn0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHtifSA9IG9mZnNldEEke2J9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7Yn0gPSBvZmZzZXRCJHtifSAlIDR1O1xuICAgICAgICAgICAgJHskfVske2J9XSA9ICR7U30oJHtnKEksVCxCKX0pO1xuICAgICAgICAgIGB9O249PT05P3k9YFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDp5PWBcbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwxKX1cbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXMobSxvLHAsbCl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XG4gICAgICAgICR7eX1cbiAgICAgIH1gfSxwcD1lPT57bGV0IHQ9ZVsxXS5kaW1zLHI9ZVsyXS5kaW1zLGE9ZVswXS5kaW1zLG49ZVsxXS5kYXRhVHlwZSxzPSEoei5hcmVFcXVhbCh0LHIpJiZ6LmFyZUVxdWFsKHIsYSkpLHU9dCxsPXouc2l6ZSh0KTtpZihzKXtsZXQgbz1udC5jYWxjU2hhcGUobnQuY2FsY1NoYXBlKHQsciwhMSksYSwhMSk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSB3aGVyZSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTt1PW8sbD16LnNpemUodSl9cmV0dXJue25hbWU6XCJXaGVyZVwiLGdldFNoYWRlclNvdXJjZTpvPT5jcChvLGUsdSxzLG4pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTpufV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NC80KX19KX19LEd1PWU9PntlLmNvbXB1dGUocHAoZS5pbnB1dHMpKX19KTt2YXIgTHUsSHU9TCgoKT0+e1widXNlIHN0cmljdFwiO0NpKCk7QWkoKTtvcygpO2dzKCk7d3MoKTtyYSgpO1BzKCk7RHMoKTtOcygpO0dzKCk7SHMoKTtLcygpO0pzKCk7ZXUoKTtydSgpO291KCk7dnUoKTt4dSgpO2VuKCk7SXUoKTtfdSgpO1B1KCk7TXUoKTtXdSgpO1V1KCk7bXIoKTtRbigpO0Z1KCk7THU9bmV3IE1hcChbW1wiQWJzXCIsW0VpXV0sW1wiQWNvc1wiLFtfaV1dLFtcIkFjb3NoXCIsW09pXV0sW1wiQWRkXCIsW2lzXV0sW1wiQXJnTWF4XCIsW1NpLFhuXV0sW1wiQXJnTWluXCIsW3hpLFhuXV0sW1wiQXNpblwiLFtUaV1dLFtcIkFzaW5oXCIsW1JpXV0sW1wiQXRhblwiLFtQaV1dLFtcIkF0YW5oXCIsW2tpXV0sW1wiQXZlcmFnZVBvb2xcIixbY3UsZHVdXSxbXCJCaWFzQWRkXCIsW0lpXV0sW1wiQmlhc1NwbGl0R2VsdVwiLFthc11dLFtcIkNhc3RcIixbTWksQmldXSxbXCJDZWlsXCIsW3ppXV0sW1wiQ2xpcFYxMFwiLFtKbl1dLFtcIkNsaXBcIixbRGldXSxbXCJDb25jYXRcIixbeXMsYnNdXSxbXCJDb252XCIsW2FhLG5hXV0sW1wiQ29udlRyYW5zcG9zZVwiLFtScyxUc11dLFtcIkNvc1wiLFtXaV1dLFtcIkNvc2hcIixbTmldXSxbXCJEaXZcIixbc3NdXSxbXCJFaW5zdW1cIixbQnMsTXNdXSxbXCJFbHVcIixbVmkscm5dXSxbXCJFcXVhbFwiLFt1c11dLFtcIkVyZlwiLFtVaV1dLFtcIkV4cFwiLFtHaV1dLFtcIkV4cGFuZFwiLFtXc11dLFtcIkZsb29yXCIsW0ZpXV0sW1wiRnVzZWRDb252XCIsW2FhLG5hXV0sW1wiR2F0aGVyXCIsW1VzLFZzXV0sW1wiR2F0aGVyRWxlbWVudHNcIixbTHMsRnNdXSxbXCJHZWx1XCIsW0xpXV0sW1wiR2VtbVwiLFtqcyxxc11dLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsW211LGZ1XV0sW1wiR2xvYmFsTWF4UG9vbFwiLFt3dSxidV1dLFtcIkdyZWF0ZXJcIixbcHNdXSxbXCJHcmVhdGVyT3JFcXVhbFwiLFttc11dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFtYcyxZc11dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtacyxRc11dLFtcIkxlYWt5UmVsdVwiLFtIaSxybl1dLFtcIkxlc3NcIixbZnNdXSxbXCJMZXNzT3JFcXVhbFwiLFtoc11dLFtcIkxvZ1wiLFtuc11dLFtcIk1hdE11bFwiLFt0dV1dLFtcIk1heFBvb2xcIixbZ3UseXVdXSxbXCJNdWxcIixbbHNdXSxbXCJOZWdcIixbcWldXSxbXCJOb3RcIixbamldXSxbXCJQYWRcIixbbnUsYXVdXSxbXCJQb3dcIixbZHNdXSxbXCJSYW5nZVwiLFskdV1dLFtcIlJlY2lwcm9jYWxcIixbS2ldXSxbXCJSZWR1Y2VNaW5cIixbaGksWmVdXSxbXCJSZWR1Y2VNZWFuXCIsW2RpLFplXV0sW1wiUmVkdWNlTWF4XCIsW21pLFplXV0sW1wiUmVkdWNlU3VtXCIsW3lpLFplXV0sW1wiUmVkdWNlUHJvZFwiLFtnaSxaZV1dLFtcIlJlZHVjZUwxXCIsW2NpLFplXV0sW1wiUmVkdWNlTDJcIixbcGksWmVdXSxbXCJSZWR1Y2VMb2dTdW1cIixbd2ksWmVdXSxbXCJSZWR1Y2VMb2dTdW1FeHBcIixbZmksWmVdXSxbXCJSZWR1Y2VTdW1TcXVhcmVcIixbYmksWmVdXSxbXCJSZWx1XCIsW1lpXV0sW1wiUmVzaXplXCIsW1N1LEN1XV0sW1wiU2lnbW9pZFwiLFtYaV1dLFtcIlNpblwiLFtKaV1dLFtcIlNpbmhcIixbUWldXSxbXCJTbGljZVwiLFtUdSxSdV1dLFtcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixbQXUsRXVdXSxbXCJTcGxpdFwiLFtEdSx6dV1dLFtcIlNxcnRcIixbWmldXSxbXCJTb2Z0bWF4XCIsW2t1LEJ1XV0sW1wiU3ViXCIsW2NzXV0sW1wiVGFuXCIsW2VzXV0sW1wiVGFuaFwiLFt0c11dLFtcIlRocmVzaG9sZGVkUmVsdVwiLFtycyxybl1dLFtcIlRpbGVcIixbVnVdXSxbXCJUcmFuc3Bvc2VcIixbSm8sUW9dXSxbXCJXaGVyZVwiLFtHdV1dXSl9KTt2YXIgaG4sanU9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7eHQoKTt2ZSgpO2huPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMucmVwbz1uZXcgTWFwLHRoaXMuYXR0cmlidXRlc0JvdW5kPSExfWdldEFydGlmYWN0KHQpe3JldHVybiB0aGlzLnJlcG8uZ2V0KHQpfXNldEFydGlmYWN0KHQscil7dGhpcy5yZXBvLnNldCh0LHIpfXJ1bih0LHIsYSxuLHMsdSxsKXtsZXQgbz10aGlzLmJhY2tlbmQuZGV2aWNlLHA9dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO3Auc2V0UGlwZWxpbmUodC5jb21wdXRlUGlwZWxpbmUpO2xldCBtPVtdO2ZvcihsZXQgZyBvZiBuKW0ucHVzaCh7YmluZGluZzptLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOmcuYnVmZmVyfX0pO2ZvcihsZXQgZyBvZiBzKW0ucHVzaCh7YmluZGluZzptLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOmcuYnVmZmVyfX0pO2wmJm0ucHVzaCh7YmluZGluZzptLmxlbmd0aCxyZXNvdXJjZTpsfSk7bGV0IHk9by5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDp0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczptLGxhYmVsOnQucHJvZ3JhbUluZm8ubmFtZX0pO2lmKHAuc2V0QmluZEdyb3VwKDAseSkscC5kaXNwYXRjaFdvcmtncm91cHMoLi4udSksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLHRoaXMuYmFja2VuZC5pc1F1ZXJ5RW5hYmxlZCgpKXt0eXBlb2YgdGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YT5cInVcIiYmKHRoaXMuYmFja2VuZC5xdWVyeURhdGE9dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0aGlzLmJhY2tlbmQucXVlcnlTZXRDb3VudCo4LEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkUpKTtsZXQgZz10aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHRoaXMuYmFja2VuZC5xdWVyeVNldENvdW50KjgsR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpLnJlc29sdmVRdWVyeVNldCh0aGlzLmJhY2tlbmQucXVlcnlTZXQsMCwyLHRoaXMuYmFja2VuZC5xdWVyeURhdGEuYnVmZmVyLDApLHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpLmNvcHlCdWZmZXJUb0J1ZmZlcih0aGlzLmJhY2tlbmQucXVlcnlEYXRhLmJ1ZmZlciwwLGcuYnVmZmVyLDAsdGhpcy5iYWNrZW5kLnF1ZXJ5U2V0Q291bnQqOCksdGhpcy5iYWNrZW5kLmZsdXNoKCk7bGV0IHY9dGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCwkPXRoaXMuYmFja2VuZC5rZXJuZWxzLmdldCh2KSxiPWBbJHskWzBdfV0gJHskWzFdfWA7Zy5idWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpPT57bGV0IFM9bmV3IEJpZ1VpbnQ2NEFycmF5KGcuYnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLEk9U1swXSxUPVNbMV07Zy5idWZmZXIudW5tYXAoKSx0eXBlb2YgdGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2U+XCJ1XCImJih0aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZT1JKTtsZXQgQj1OdW1iZXIoSS10aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZSksUD1OdW1iZXIoVC10aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZSk7aWYoIU51bWJlci5pc1NhZmVJbnRlZ2VyKEIpfHwhTnVtYmVyLmlzU2FmZUludGVnZXIoUCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlXCIpO3RoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGcuaWQpO2xldCBEPVwiXCI7ci5mb3JFYWNoKChXLEgpPT57RCs9YGlucHV0WyR7SH1dOiBbJHtXLmRpbXN9XSB8ICR7Y3IoVy5kYXRhVHlwZSl9LCBgfSk7bGV0IFI9XCJcIjthLmZvckVhY2goKFcsSCk9PntSKz1gb3V0cHV0WyR7SH1dOiBbJHtXLmRpbXN9XSB8ICR7Y3IoVy5kYXRhVHlwZSl9LCBgfSksY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7dn18JHtifVwiICR7RH0ke1J9ZXhlY3V0aW9uIHRpbWU6ICR7UC1CfSBuc2ApfSl9dGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49MTYmJnRoaXMuYmFja2VuZC5mbHVzaCgpfWRpc3Bvc2UoKXt9YnVpbGQodCxyKXtsZXQgYT10aGlzLmJhY2tlbmQuZGV2aWNlLG49W107YS5mZWF0dXJlcy5oYXMoXCJzaGFkZXItZjE2XCIpJiZuLnB1c2goXCJlbmFibGUgZjE2O1wiKTtsZXQgcz1LbyhyKSx1PXQuZ2V0U2hhZGVyU291cmNlKHMpLGw9YCR7bi5qb2luKGBcbmApfVxuJHtzLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XG4ke3V9YCxvPWEuY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmwsbGFiZWw6dC5uYW1lfSk7X2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBzaGFkZXIgY29kZTogJHtsfWApO2xldCBwPWEuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6byxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCIsbGFiZWw6dC5uYW1lfSk7cmV0dXJue3Byb2dyYW1JbmZvOnQsY29tcHV0ZVBpcGVsaW5lOnB9fW5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKHQpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC54LGE9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnl8fDEsbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQuenx8MSxzPXRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO2lmKHI8PXMmJmE8PXMmJm48PXMpcmV0dXJuW3IsYSxuXTtsZXQgdT1yKmEqbixsPU1hdGguY2VpbChNYXRoLnNxcnQodSkpO2lmKGw+cyl7aWYobD1NYXRoLmNlaWwoTWF0aC5jYnJ0KHUpKSxsPnMpdGhyb3cgbmV3IEVycm9yKFwiVG90YWwgZGlzcGF0Y2ggc2l6ZSBleGNlZWRzIFdlYkdQVSBtYXhpbXVtLlwiKTtyZXR1cm5bbCxsLGxdfWVsc2UgcmV0dXJuW2wsbCwxXX19fSk7dmFyIGZwLG1wLGduLHF1PUwoKCk9PntcInVzZSBzdHJpY3RcIjt4dCgpO1VvKCk7SG8oKTtIdSgpO2p1KCk7ZnA9KGUsdCk9PntpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7dC5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7ZS5sZW5ndGh9LmApO2xldCByPVtdO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7KythKXtsZXQgbj1lW2FdLmRhdGFUeXBlO3N3aXRjaCh0W2FdKXtjYXNlXCJub25lXCI6e3IucHVzaChcIlwiKTticmVha31jYXNlXCJ0eXBlXCI6e3IucHVzaChgJHtufWApO2JyZWFrfWNhc2VcInJhbmtcIjp7bGV0IHM9ZVthXS5kaW1zLmxlbmd0aDtyLnB1c2goYCR7bn07JHtzfWApO2JyZWFrfWNhc2VcImRpbXNcIjp7bGV0IHM9ZVthXS5kaW1zLmpvaW4oXCIsXCIpO3IucHVzaChgJHtufTske3N9YCk7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7dFthXX1gKX19cmV0dXJuIHIuam9pbihcInxcIil9LG1wPShlLHQpPT57bGV0IHI9ZS5uYW1lO3JldHVybiBlLnNoYWRlckNhY2hlPy5oaW50JiYocis9XCJbXCIrZS5zaGFkZXJDYWNoZS5oaW50K1wiXVwiKSxyKz1gOiR7ZnAodCxlLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcz8/bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKFwiZGltc1wiKSl9YCxyfSxnbj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuY3VycmVudEtlcm5lbElkPW51bGw7dGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsO3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGw7dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MDt0aGlzLnF1ZXJ5U2V0Q291bnQ9Mjt0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nPW5ldyBNYXB9Z2V0IGN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCl7aWYodGhpcy5jdXJyZW50S2VybmVsSWQ9PT1udWxsKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IGN1cnJlbnRLZXJuZWxJZCBpcyBudWxsLiAoc2hvdWxkIG5vdCBoYXBwZW4pXCIpO2xldCB0PXRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO3JldHVybiB0fHwodD17fSx0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLHQpKSx0fWFzeW5jIGluaXRpYWxpemUodCl7aWYoIW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR3B1QmFja2VuZDogV2ViR1BVIGlzIG5vdCBhdmFpbGFibGUuXCIpO2xldCByPWF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJXZWJHcHVCYWNrZW5kOiBGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLlwiKTt0aGlzLmVudj10O2xldCBhPVtdLG49e3JlcXVpcmVkTGltaXRzOnttYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplLG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLG1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZTpyLmxpbWl0cy5tYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUsbWF4QnVmZmVyU2l6ZTpyLmxpbWl0cy5tYXhCdWZmZXJTaXplLG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDpyLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVYOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVk6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9LHJlcXVpcmVkRmVhdHVyZXM6YX07ci5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJmEucHVzaChcInRpbWVzdGFtcC1xdWVyeVwiKSxyLmZlYXR1cmVzLmhhcyhcInNoYWRlci1mMTZcIikmJmEucHVzaChcInNoYWRlci1mMTZcIiksdGhpcy5kZXZpY2U9YXdhaXQgci5yZXF1ZXN0RGV2aWNlKG4pLHRoaXMuZ3B1RGF0YU1hbmFnZXI9TG8odGhpcyksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgaG4odGhpcyksdGhpcy5rZXJuZWxzPW5ldyBNYXAsdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YT1uZXcgTWFwLHRoaXMua2VybmVsQ3VzdG9tRGF0YT1uZXcgTWFwLE5vKHQubG9nTGV2ZWwsISF0LmRlYnVnKSx0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvcj1zPT57cy5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvciYmY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHtzLmVycm9yLm1lc3NhZ2V9YCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJkZXZpY2VcIix7dmFsdWU6dGhpcy5kZXZpY2V9KX1kaXNwb3NlKCl7dHlwZW9mIHRoaXMucXVlcnlTZXQ8XCJ1XCImJnRoaXMucXVlcnlTZXQuZGVzdHJveSgpLHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpfWdldENvbW1hbmRFbmNvZGVyKCl7cmV0dXJuIHRoaXMuY29tbWFuZEVuY29kZXJ8fCh0aGlzLmNvbW1hbmRFbmNvZGVyPXRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCkpLHRoaXMuY29tbWFuZEVuY29kZXJ9Z2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCl7aWYoIXRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKXtsZXQgdD17fTt0aGlzLmlzUXVlcnlFbmFibGVkKCkmJih0eXBlb2YgdGhpcy5xdWVyeVNldD5cInVcIiYmKHRoaXMucXVlcnlTZXQ9dGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe3R5cGU6XCJ0aW1lc3RhbXBcIixjb3VudDp0aGlzLnF1ZXJ5U2V0Q291bnR9KSksdC50aW1lc3RhbXBXcml0ZXM9e3F1ZXJ5U2V0OnRoaXMucXVlcnlTZXQsYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDowLGVuZE9mUGFzc1dyaXRlSW5kZXg6MX0pLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKS5iZWdpbkNvbXB1dGVQYXNzKHQpfXJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXt0aGlzLmNvbW1hbmRFbmNvZGVyJiYodGhpcy5lbmRDb21wdXRlUGFzcygpLHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLmZpbmlzaCgpXSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKSx0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGwsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MCl9aXNRdWVyeUVuYWJsZWQoKXtyZXR1cm4hISh0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJnRoaXMuZW52LndlYmdwdS5wcm9maWxpbmdNb2RlPT09XCJkZWZhdWx0XCIpfXJ1bih0LHIsYSxuLHMpe2xldCB1PVtdO2ZvcihsZXQgST0wO0k8ci5sZW5ndGg7KytJKXtsZXQgVD10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChyW0ldLmRhdGEpO2lmKCFUKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke3JbSV0uZGF0YX1gKTt1W0ldPVR9bGV0IGw9bXAodCxyKSxvPXRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3QobCkse291dHB1dHM6cCxkaXNwYXRjaEdyb3VwOm0scHJvZ3JhbVVuaWZvcm1zOnl9PXQuZ2V0UnVuRGF0YShyKSxnPWEubGVuZ3RoPT09MD9wLm1hcCgoSSxUKT0+VCk6YTtpZihnLmxlbmd0aCE9PXAubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHtnLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke3AubGVuZ3RofS5gKTtsZXQgdj1bXSwkPVtdO2ZvcihsZXQgST0wO0k8cC5sZW5ndGg7KytJKXtpZighTnVtYmVyLmlzSW50ZWdlcihnW0ldKXx8Z1tJXTwtM3x8Z1tJXT49cC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHtnW0ldfWApO2lmKGdbSV09PT0tMyljb250aW51ZTtsZXQgVD1nW0ldPT09LTEsQj1nW0ldPT09LTIsUD1UfHxCP3MocFtJXS5kYXRhVHlwZSxwW0ldLmRpbXMpOm4oZ1tJXSxwW0ldLmRhdGFUeXBlLHBbSV0uZGltcyksRD10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChQLmRhdGEpO2lmKCFEKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHtQLmRhdGF9YCk7aWYoVCYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goRCksQil7bGV0IFI9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO1J8fChSPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLFIpKSxSLnB1c2goRCl9di5wdXNoKFApLCQucHVzaChEKX1sZXQgYjtpZih5KXtsZXQgST0wLFQ9MCxCPVtdLFA9MTt5LmZvckVhY2goVz0+e2xldCBIPXR5cGVvZiBXLmRhdGE9PVwibnVtYmVyXCI/W1cuZGF0YV06Vy5kYXRhLEs7c3dpdGNoKEgubGVuZ3RoKXtjYXNlIDE6Sz00O2JyZWFrO2Nhc2UgMjpLPTg7YnJlYWs7Y2FzZSAzOks9MTY7YnJlYWs7Y2FzZSA0Oks9MTY7YnJlYWs7Y2FzZSA1Oks9MTY7YnJlYWs7Y2FzZSA2Oks9MTY7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbGVuZ3RoOiAke0gubGVuZ3RofWApfShUPT09NXx8VD09PTYpJiYoSz0xNiksSz5QJiYoUD1LKSxJPU1hdGguY2VpbChJL0spKkssVD1ILmxlbmd0aCxCLnB1c2goSSksSSs9SC5sZW5ndGgqNH0pLEk9TWF0aC5jZWlsKEkvUCkqUDtsZXQgRD1uZXcgQXJyYXlCdWZmZXIoSSk7eS5mb3JFYWNoKChXLEgpPT57bGV0IEs9QltIXSxsZT10eXBlb2YgVy5kYXRhPT1cIm51bWJlclwiP1tXLmRhdGFdOlcuZGF0YTtXLnR5cGU9PT1cImludDMyXCI/bmV3IEludDMyQXJyYXkoRCxLLGxlLmxlbmd0aCkuc2V0KGxlKTpXLnR5cGU9PT1cInVpbnQzMlwiP25ldyBVaW50MzJBcnJheShELEssbGUubGVuZ3RoKS5zZXQobGUpOm5ldyBGbG9hdDMyQXJyYXkoRCxLLGxlLmxlbmd0aCkuc2V0KGxlKX0pO2xldCBSPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKEksR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoUi5idWZmZXIsMCxELDAsSSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKFIuaWQpLGI9e29mZnNldDowLHNpemU6SSxidWZmZXI6Ui5idWZmZXJ9fWxldCBTPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUobSk7cmV0dXJuIG98fChvPXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCxTKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KGwsbykpLF9lKFwiaW5mb1wiLCgpPT5gW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke3QubmFtZX1cIiAoa2V5PSR7bH0pIHdpdGggJHtTWzBdfXgke1NbMV19eCR7U1syXX1gKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bihvLHIsdix1LCQsUyxiKSx2fXVwbG9hZCh0LHIpe3RoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKHQscil9bWVtY3B5KHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkodCxyKX1hc3luYyBkb3dubG9hZCh0LHIpe2F3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQodCxyKX1hbGxvYyh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUodCkuaWR9ZnJlZSh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHQpfWNyZWF0ZUtlcm5lbCh0LHIsYSxuKXtsZXQgcz1MdS5nZXQodCk7aWYoIXMpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGltcGxlbWVudGVkOiAke3R9YCk7dGhpcy5rZXJuZWxzLnNldChyLFt0LG4sc1swXSxbc1sxXSxhXV0pfXJlbGVhc2VLZXJuZWwodCl7bGV0IHI9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodCk7aWYocil7Zm9yKGxldCBhIG9mIHIpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGEuaWQpO3RoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKHQpfXRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUodCksdGhpcy5rZXJuZWxzLmRlbGV0ZSh0KX1jb21wdXRlS2VybmVsKHQscixhKXtsZXQgbj10aGlzLmtlcm5lbHMuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke3R9YCk7bGV0W3MsdSxsLG9dPW47aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7c31dICR7dX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LG9bMF0mJihvWzFdPW9bMF0ob1sxXSksb1swXT12b2lkIDApLF9lKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske3N9XSAke3V9XCIuLi5gKTtsZXQgcD10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBwJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIiksbChyLG9bMV0pLDB9Y2F0Y2gobSl7cmV0dXJuIGEucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske3N9XSAke3V9XCIgZmFpbGVkLiAke219YCkpLDF9ZmluYWxseXtwJiZhLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4obT0+bT9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske3N9XSAke3V9XCI6ICR7bS5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgbSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKG0uaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LHIsYSxuKXtsZXQgcz10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtzfHwocz1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQscykpO2xldCB1PXMuZ2V0KHIpLGw9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGEsbix1Py5bMV0pO3JldHVybiBzLnNldChyLFtsLGFdKSxsfXVucmVnaXN0ZXJCdWZmZXJzKHQpe2xldCByPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO3ImJihyLmZvckVhY2goYT0+dGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYVsxXSkpLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHQpKX1nZXRCdWZmZXIodCl7bGV0IHI9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke3R9YCk7cmV0dXJuIHIuYnVmZmVyfWNyZWF0ZURvd25sb2FkZXIodCxyLGEpe3JldHVybiBhc3luYygpPT57bGV0IG49YXdhaXQgRm4odGhpcyx0LHIpO3JldHVybiBWbyhuLmJ1ZmZlcixhKX19fX0pO3ZhciBLdT17fTtrdChLdSx7aW5pdDooKT0+aHB9KTt2YXIgd3IsbGEsaHAsWXU9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7cXUoKTt4dCgpO2dlKCk7d3I9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LHIsYSxuKXt0aGlzLm1vZHVsZT10O3RoaXMuZGF0YVR5cGU9cjt0aGlzLmRhdGE9YTt0aGlzLmRpbXM9bn1nZXRGbG9hdDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD16LnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEZsb2F0MzJBcnJheTpuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0QmlnSW50NjRBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PXouc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgQmlnSW50NjRBcnJheTpuZXcgQmlnSW50NjRBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEludDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD16LnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEludDMyQXJyYXk6bmV3IEludDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1yZXNoYXBlKHQpe2lmKHouc2l6ZSh0KSE9PXouc2l6ZSh0aGlzLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmV3IHNoYXBlXCIpO3JldHVybiBuZXcgZSh0aGlzLm1vZHVsZSx0aGlzLmRhdGFUeXBlLHRoaXMuZGF0YSx0KX19LGxhPWNsYXNze2NvbnN0cnVjdG9yKHQscixhKXt0aGlzLm1vZHVsZT10O3RoaXMuYmFja2VuZD1yO3RoaXMuY3VzdG9tRGF0YU9mZnNldD0wO3RoaXMuY3VzdG9tRGF0YVNpemU9MDtsZXQgbj10LkhFQVBVMzIscz1hPj4yO3RoaXMub3BLZXJuZWxDb250ZXh0PW5bcysrXTtsZXQgdT1uW3MrK107dGhpcy5vdXRwdXRDb3VudD1uW3MrK10sdGhpcy5jdXN0b21EYXRhT2Zmc2V0PW5bcysrXSx0aGlzLmN1c3RvbURhdGFTaXplPW5bcysrXTtsZXQgbD1bXTtmb3IobGV0IG89MDtvPHU7bysrKXtsZXQgcD1uW3MrK10sbT1uW3MrK10seT1uW3MrK10sZz1bXTtmb3IobGV0IHY9MDt2PHk7disrKWcucHVzaChuW3MrK10pO2wucHVzaChuZXcgd3IodCxwLG0sZykpfXRoaXMuaW5wdXRzPWx9Z2V0IGtlcm5lbEN1c3RvbURhdGEoKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhfWdldCBjdXN0b21EYXRhQnVmZmVyKCl7cmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsdGhpcy5jdXN0b21EYXRhT2Zmc2V0K3RoaXMuY3VzdG9tRGF0YVNpemUpfWNvbXB1dGUodCxyKXtsZXQgYT1yPy5pbnB1dHM/Lm1hcChsPT50eXBlb2YgbD09XCJudW1iZXJcIj90aGlzLmlucHV0c1tsXTpsKT8/dGhpcy5pbnB1dHMsbj1yPy5vdXRwdXRzPz9bXSxzPShsLG8scCk9Pm5ldyB3cih0aGlzLm1vZHVsZSxvLHRoaXMub3V0cHV0KGwscCkscCksdT0obCxvKT0+e2xldCBwPXByKGwpO2lmKCFwKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2x9YCk7bGV0IG09cCp6LnNpemUobyk7cmV0dXJuIG5ldyB3cih0aGlzLm1vZHVsZSxsLHRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUobSkuaWQsbyl9O3JldHVybiB0aGlzLmJhY2tlbmQucnVuKHQsYSxuLHMsdSl9b3V0cHV0KHQscil7bGV0IGE9dGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7dHJ5e2xldCBuPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErci5sZW5ndGgpKjQpLHM9bj4+Mjt0aGlzLm1vZHVsZS5IRUFQVTMyW3MrK109ci5sZW5ndGg7Zm9yKGxldCB1PTA7dTxyLmxlbmd0aDt1KyspdGhpcy5tb2R1bGUuSEVBUFUzMltzKytdPXJbdV07cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQsbil9Y2F0Y2gobil7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtyfV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtufWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKGEpfX19LGhwPWFzeW5jKGUsdCk9PntsZXQgcj1lLmpzZXBJbml0O2lmKHImJm5hdmlnYXRvci5ncHUpe2lmKCF0Lndhc20uc2ltZCl0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIGZvciBXZWJHUFU9T04gYW5kIFNJTUQ9T0ZGLiBQbGVhc2Ugc2V0IGBlbnYud2FzbS5zaW1kYCB0byB0cnVlIHdoZW4gdXNpbmcgV2ViR1BVIEVQXCIpO2xldCBhPW5ldyBnbjthd2FpdCBhLmluaXRpYWxpemUodCkscihhLG49PmEuYWxsb2Mobiksbj0+YS5mcmVlKG4pLChuLHMsdSxsPSExKT0+e2lmKGwpX2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtufSwgZHN0PSR7c30sIHNpemU9JHt1fWApLGEubWVtY3B5KG4scyk7ZWxzZXtfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHtufSwgZ3B1RGF0YUlkPSR7c30sIHNpemU9JHt1fWApO2xldCBvPWUuSEVBUFU4LnN1YmFycmF5KG4sbit1KTthLnVwbG9hZChzLG8pfX0sYXN5bmMobixzLHUpPT57X2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtufSwgZGF0YU9mZnNldD0ke3N9LCBzaXplPSR7dX1gKSxhd2FpdCBhLmRvd25sb2FkKG4sKCk9PmUuSEVBUFU4LnN1YmFycmF5KHMscyt1KSl9LChuLHMsdSk9PmEuY3JlYXRlS2VybmVsKG4scyx1LHQuZGVidWd8fHQud2ViZ3B1LnByb2ZpbGluZ01vZGU9PT1cImRlZmF1bHRcIj9lLlVURjhUb1N0cmluZyhlLl9Kc2VwR2V0Tm9kZU5hbWUocykpOmAke3N9YCksbj0+YS5yZWxlYXNlS2VybmVsKG4pLChuLHMsdSxsKT0+e19lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke3V9LCBrZXJuZWw9JHtufSwgY29udGV4dERhdGFPZmZzZXQ9JHtzfWApO2xldCBvPW5ldyBsYShlLGEscyk7cmV0dXJuIGEuY29tcHV0ZUtlcm5lbChuLG8sbCl9KX19fSk7dmFyIEp1LGdwLHlwLFF1LHZyLFp1LGRhLGNhLGVsLHRsLFh1LHJsLG5sLGFsLG9sPUwoKCk9PntcInVzZSBzdHJpY3RcIjtCbygpO0RvKCk7RGUoKTtIdCgpO3FyKCk7SnU9ITEsZ3A9ZT0+e2xldCB0PVBlKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgYT10LnN0YWNrQWxsb2MoOCk7cmV0dXJuIHQuX09ydEdldElucHV0T3V0cHV0Q291bnQoZSxhLGErNCkhPT0wJiZBZShcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIiksW3QuSEVBUDMyW2EvNF0sdC5IRUFQMzJbYS80KzFdXX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX0seXA9KGUsdCk9PntQZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZBZShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxRdT1hc3luYyBlPT57eXAoZS53YXNtLm51bVRocmVhZHMsZnIoZS5sb2dMZXZlbCkpO3tsZXQgdD0oWXUoKSx2dChLdSkpLmluaXQ7YXdhaXQgdChQZSgpLGUpfUp1PSEwfSx2cj1uZXcgTWFwLFp1PSgpPT5KdSxkYT1lPT57bGV0IHQ9UGUoKSxyPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKHI9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSxjYT0oZSx0KT0+e2xldCByPVBlKCksYT0wLG49MCxzPTAsdT1bXSxsPVtdLG89W107dHJ5e1tuLHVdPU1vKHQpLGE9ci5fT3J0Q3JlYXRlU2Vzc2lvbihlWzBdLGVbMV0sbiksYT09PTAmJkFlKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIik7bGV0W3AsbV09Z3AoYSkseT1bXSxnPVtdLHY9W107Zm9yKGxldCBiPTA7YjxwO2IrKyl7bGV0IFM9ci5fT3J0R2V0SW5wdXROYW1lKGEsYik7Uz09PTAmJkFlKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLGwucHVzaChTKSx5LnB1c2goci5VVEY4VG9TdHJpbmcoUykpfWZvcihsZXQgYj0wO2I8bTtiKyspe2xldCBTPXIuX09ydEdldE91dHB1dE5hbWUoYSxiKTtTPT09MCYmQWUoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLG8ucHVzaChTKTtsZXQgST1yLlVURjhUb1N0cmluZyhTKTtnLnB1c2goSSk7e2xldCBUPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bSV0/P1wiY3B1XCI7aWYoVCE9PVwiY3B1XCImJlQhPT1cImNwdS1waW5uZWRcIiYmVCE9PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke1R9LmApO3YucHVzaChUKX19bGV0ICQ9bnVsbDtyZXR1cm4gdi5zb21lKGI9PmI9PT1cImdwdS1idWZmZXJcIikmJihzPXIuX09ydENyZWF0ZUJpbmRpbmcoYSkscz09PTAmJkFlKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpLCQ9e2hhbmRsZTpzLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczp2LG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6di5tYXAoYj0+VW4oYikpfSksdnIuc2V0KGEsW2EsbCxvLCRdKSxbYSx5LGddfWNhdGNoKHApe3Rocm93IGwuZm9yRWFjaChtPT5yLl9PcnRGcmVlKG0pKSxvLmZvckVhY2gobT0+ci5fT3J0RnJlZShtKSkscyE9PTAmJnIuX09ydFJlbGVhc2VCaW5kaW5nKHMpLGEhPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbihhKSxwfWZpbmFsbHl7ci5fZnJlZShlWzBdKSxuIT09MCYmci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKG4pLHUuZm9yRWFjaChwPT5yLl9mcmVlKHApKX19LGVsPShlLHQpPT57bGV0IHI9ZGEoZSk7cmV0dXJuIGNhKHIsdCl9LHRsPWU9PntsZXQgdD1QZSgpLHI9dnIuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W2EsbixzLHVdPXI7dSYmdC5fT3J0UmVsZWFzZUJpbmRpbmcodS5oYW5kbGUpLHQuanNlcFVucmVnaXN0ZXJCdWZmZXJzPy4oZSksbi5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLHMuZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihhKSx2ci5kZWxldGUoZSl9LFh1PShlLHQscixhLG4pPT57aWYoIWUpe3QucHVzaCgwKTtyZXR1cm59bGV0IHM9UGUoKSx1PWVbMF0sbD1lWzFdLG89ZVszXSxwLG07aWYodT09PVwic3RyaW5nXCImJm89PT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihvPT09XCJncHUtYnVmZmVyXCIpe2xldCB2PWVbMl0uZ3B1QnVmZmVyLCQ9cHIoVm4odSkpO209bC5yZWR1Y2UoKGIsUyk9PmIqUywxKSokLHA9cy5qc2VwUmVnaXN0ZXJCdWZmZXIoYSxuLHYsbSl9ZWxzZXtsZXQgdj1lWzJdO2lmKEFycmF5LmlzQXJyYXkodikpe209NCp2Lmxlbmd0aCxwPXMuX21hbGxvYyhtKSxyLnB1c2gocCk7bGV0ICQ9cC80O2ZvcihsZXQgYj0wO2I8di5sZW5ndGg7YisrKXtpZih0eXBlb2YgdltiXSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2J9IGlzIG5vdCBhIHN0cmluZ2ApO3MuSEVBUFUzMlskKytdPU1lKHZbYl0scil9fWVsc2UgbT12LmJ5dGVMZW5ndGgscD1zLl9tYWxsb2MobSksci5wdXNoKHApLHMuSEVBUFU4LnNldChuZXcgVWludDhBcnJheSh2LmJ1ZmZlcix2LmJ5dGVPZmZzZXQsbSkscCl9bGV0IHk9cy5zdGFja1NhdmUoKSxnPXMuc3RhY2tBbGxvYyg0KmwubGVuZ3RoKTt0cnl7bGV0IHY9Zy80O2wuZm9yRWFjaChiPT5zLkhFQVAzMlt2KytdPWIpO2xldCAkPXMuX09ydENyZWF0ZVRlbnNvcihWbih1KSxwLG0sZyxsLmxlbmd0aCxVbihvKSk7JD09PTAmJkFlKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHthfSwgaW5kZXg9JHtufS5gKSx0LnB1c2goJCl9ZmluYWxseXtzLnN0YWNrUmVzdG9yZSh5KX19LHJsPWFzeW5jKGUsdCxyLGEsbixzKT0+e2xldCB1PVBlKCksbD12ci5nZXQoZSk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W28scCxtLHldPWwsZz10Lmxlbmd0aCx2PWEubGVuZ3RoLCQ9MCxiPVtdLFM9W10sST1bXSxUPVtdLEI9dS5zdGFja1NhdmUoKSxQPXUuc3RhY2tBbGxvYyhnKjQpLEQ9dS5zdGFja0FsbG9jKGcqNCksUj11LnN0YWNrQWxsb2Modio0KSxXPXUuc3RhY2tBbGxvYyh2KjQpO3RyeXtbJCxiXT1rbyhzKTtmb3IobGV0IG9lPTA7b2U8ZztvZSsrKVh1KHJbb2VdLFMsVCxlLHRbb2VdKTtmb3IobGV0IG9lPTA7b2U8djtvZSsrKVh1KG5bb2VdLEksVCxlLGcrYVtvZV0pO2xldCBIPVAvNCxLPUQvNCxsZT1SLzQsTT1XLzQ7Zm9yKGxldCBvZT0wO29lPGc7b2UrKyl1LkhFQVBVMzJbSCsrXT1TW29lXSx1LkhFQVBVMzJbSysrXT1wW3Rbb2VdXTtmb3IobGV0IG9lPTA7b2U8djtvZSsrKXUuSEVBUFUzMltsZSsrXT1JW29lXSx1LkhFQVBVMzJbTSsrXT1tW2Fbb2VdXTtpZih5KXtsZXR7aGFuZGxlOm9lLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczp3ZSxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOmp9PXk7aWYocC5sZW5ndGghPT1nKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtnfSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7cC5sZW5ndGh9KS5gKTtmb3IobGV0IFNlPTA7U2U8ZztTZSsrKXtsZXQgVGU9dFtTZV07YXdhaXQgdS5fT3J0QmluZElucHV0KG9lLHBbVGVdLFNbU2VdKSE9PTAmJkFlKGBDYW4ndCBiaW5kIGlucHV0WyR7U2V9XSBmb3Igc2Vzc2lvbj0ke2V9LmApfWZvcihsZXQgU2U9MDtTZTx2O1NlKyspe2xldCBUZT1hW1NlXTtuW1NlXT8uWzNdP3UuX09ydEJpbmRPdXRwdXQob2UsbVtUZV0sSVtTZV0sMCkhPT0wJiZBZShgQ2FuJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske1NlfV0gZm9yIHNlc3Npb249JHtlfS5gKTp1Ll9PcnRCaW5kT3V0cHV0KG9lLG1bVGVdLDAsaltUZV0pIT09MCYmQWUoYENhbid0IGJpbmQgb3V0cHV0WyR7U2V9XSB0byAke3dlW1NlXX0gZm9yIHNlc3Npb249JHtlfS5gKX19bGV0IHE7eT9xPWF3YWl0IHUuX09ydFJ1bldpdGhCaW5kaW5nKG8seS5oYW5kbGUsdixSLCQpOnE9YXdhaXQgdS5fT3J0UnVuKG8sRCxQLGcsVyx2LFIsJCkscSE9PTAmJkFlKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2xldCB4ZT1bXTtmb3IobGV0IG9lPTA7b2U8djtvZSsrKXtsZXQgd2U9dS5IRUFQVTMyW1IvNCtvZV07aWYod2U9PT1JW29lXSl7eGUucHVzaChuW29lXSk7Y29udGludWV9bGV0IGo9dS5zdGFja1NhdmUoKSxTZT11LnN0YWNrQWxsb2MoNCo0KSxUZT0hMSxFZSxDZT0wO3RyeXt1Ll9PcnRHZXRUZW5zb3JEYXRhKHdlLFNlLFNlKzQsU2UrOCxTZSsxMikhPT0wJiZBZShgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke29lfS5gKTtsZXQgTGU9U2UvNCxxZT11LkhFQVBVMzJbTGUrK107Q2U9dS5IRUFQVTMyW0xlKytdO2xldCBVPXUuSEVBUFUzMltMZSsrXSxkZT11LkhFQVBVMzJbTGUrK10scGU9W107Zm9yKGxldCBPZT0wO09lPGRlO09lKyspcGUucHVzaCh1LkhFQVBVMzJbVS80K09lXSk7dS5fT3J0RnJlZShVKTtsZXQgTmU9cGUucmVkdWNlKChPZSx6ZSk9Pk9lKnplLDEpO0VlPWNyKHFlKTtsZXQgSGU9eT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW2Fbb2VdXTtpZihFZT09PVwic3RyaW5nXCIpe2lmKEhlPT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IE9lPVtdLHplPUNlLzQ7Zm9yKGxldCBHZT0wO0dlPE5lO0dlKyspe2xldCBldD11LkhFQVBVMzJbemUrK10sS2U9R2U9PT1OZS0xP3ZvaWQgMDp1LkhFQVBVMzJbemVdLWV0O09lLnB1c2godS5VVEY4VG9TdHJpbmcoZXQsS2UpKX14ZS5wdXNoKFtFZSxwZSxPZSxcImNwdVwiXSl9ZWxzZSBpZihIZT09PVwiZ3B1LWJ1ZmZlclwiJiZOZT4wKXtsZXQgT2U9dS5qc2VwR2V0QnVmZmVyKENlKSx6ZT1wcihxZSk7aWYoemU9PT12b2lkIDB8fCFZcihFZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7RWV9YCk7VGU9ITAseGUucHVzaChbRWUscGUse2dwdUJ1ZmZlcjpPZSxkb3dubG9hZDp1LmpzZXBDcmVhdGVEb3dubG9hZGVyKE9lLE5lKnplLEVlKSxkaXNwb3NlOigpPT57dS5fT3J0UmVsZWFzZVRlbnNvcih3ZSl9fSxcImdwdS1idWZmZXJcIl0pfWVsc2V7bGV0IE9lPUtyKEVlKSx6ZT1uZXcgT2UoTmUpO25ldyBVaW50OEFycmF5KHplLmJ1ZmZlcix6ZS5ieXRlT2Zmc2V0LHplLmJ5dGVMZW5ndGgpLnNldCh1LkhFQVBVOC5zdWJhcnJheShDZSxDZSt6ZS5ieXRlTGVuZ3RoKSkseGUucHVzaChbRWUscGUsemUsXCJjcHVcIl0pfX1maW5hbGx5e3Uuc3RhY2tSZXN0b3JlKGopLEVlPT09XCJzdHJpbmdcIiYmQ2UmJnUuX2ZyZWUoQ2UpLFRlfHx1Ll9PcnRSZWxlYXNlVGVuc29yKHdlKX19cmV0dXJuIHkmJnUuX09ydENsZWFyQm91bmRPdXRwdXRzKHkuaGFuZGxlKSx4ZX1maW5hbGx5e3Uuc3RhY2tSZXN0b3JlKEIpLFMuZm9yRWFjaChIPT51Ll9PcnRSZWxlYXNlVGVuc29yKEgpKSxJLmZvckVhY2goSD0+dS5fT3J0UmVsZWFzZVRlbnNvcihIKSksVC5mb3JFYWNoKEg9PnUuX2ZyZWUoSCkpLCQhPT0wJiZ1Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucygkKSxiLmZvckVhY2goSD0+dS5fZnJlZShIKSl9fSxubD1lPT57bGV0IHQ9UGUoKSxyPXZyLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7bGV0IGE9clswXSxuPXQuX09ydEVuZFByb2ZpbGluZyhhKTtuPT09MCYmQWUoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpLHQuX09ydEZyZWUobil9LGFsPWU9PntsZXQgdD1bXTtmb3IobGV0IHIgb2YgZSl7bGV0IGE9clsyXTshQXJyYXkuaXNBcnJheShhKSYmXCJidWZmZXJcImluIGEmJnQucHVzaChhLmJ1ZmZlcil9cmV0dXJuIHR9fSk7dmFyIGlsPUx0KChVeSx3cCk9Pnt3cC5leHBvcnRzPScvKiFcXG4gKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjE3LjAtZGV2LjIwMjMxMTAzLTE0MzlkYTM2ZmVcXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXFxuICovXFxuXCJ1c2Ugc3RyaWN0XCI7KCgpPT57dmFyIG9uPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgU3U9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgQ3U9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIEF1PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIEg9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgSnQ9KGUsdCk9PigpPT4odHx8ZSgodD17ZXhwb3J0czp7fX0pLmV4cG9ydHMsdCksdC5leHBvcnRzKSxJcj0oZSx0KT0+e2Zvcih2YXIgciBpbiB0KW9uKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxJdT0oZSx0LHIsbyk9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG4gb2YgQ3UodCkpIUF1LmNhbGwoZSxuKSYmbiE9PXImJm9uKGUsbix7Z2V0OigpPT50W25dLGVudW1lcmFibGU6IShvPVN1KHQsbikpfHxvLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIE10PWU9Pkl1KG9uKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciBhbj17fTtJcihhbix7cmVhZEZpbGU6KCk9PkV1fSk7dmFyIEV1LHNuPUgoKCk9PntFdT12b2lkIDB9KTt2YXIgdW49e307SXIodW4se2pvaW46KCk9PlR1fSk7dmFyIFR1LGxuPUgoKCk9PntUdT12b2lkIDB9KTt2YXIgdW89SnQoKHNvLGRuKT0+e1widXNlIHN0cmljdFwiO3ZhciBpbz0oKCk9Pnt2YXIgZT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKGU9ZXx8X19maWxlbmFtZSksZnVuY3Rpb24odD17fSl7dmFyIHI9dCxvLG47ci5yZWFkeT1uZXcgUHJvbWlzZSgobCxwKT0+e289bCxuPXB9KSxyLmpzZXBJbml0PShsLHAsaCxDLFQsVSxHLHVlKT0+e3IuWmE9bCxyLk9hPXAsci5RYT1oLHIuSmE9QyxyLlBhPVQsci5yYT1VLHIuUmE9RyxyLlNhPXVlLHA9KFksUSxKKT0+KC4uLmNlKT0+e2xldCBtZT1IZSxFPVE/LigpO2NlPVkoLi4uY2UpO2xldCB0ZT1RPy4oKTtyZXR1cm4gRSE9PXRlJiYoWT10ZSxKKEUpLFE9Sj1udWxsKSxIZSE9bWU/Z3IoKTpjZX0saD1ZPT5hc3luYyguLi5RKT0+e3RyeXtpZihyLkRhKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7bGV0IEo9ci5EYT17VGE6UVswXSxlcnJvcnM6W119LGNlPWF3YWl0IFkoLi4uUSk7aWYoci5EYSE9PUopdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO2wuZmx1c2goKTtsZXQgbWU9Si5lcnJvcnM7aWYoMDxtZS5sZW5ndGgpe2xldCBFPWF3YWl0IFByb21pc2UuYWxsKG1lKTtpZihFPUUuZmlsdGVyKHRlPT50ZSksMDxFLmxlbmd0aCl0aHJvdyBFcnJvcihFLmpvaW4oYFxcbmApKX1yZXR1cm4gY2V9ZmluYWxseXtyLkRhPW51bGx9fSxyLl9PcnRSdW49aChwKHIuX09ydFJ1biwoKT0+ci5fT3J0UnVuLFk9PnIuX09ydFJ1bj1ZKSksci5fT3J0UnVuV2l0aEJpbmRpbmc9aChwKHIuX09ydFJ1bldpdGhCaW5kaW5nLCgpPT5yLl9PcnRSdW5XaXRoQmluZGluZyxZPT5yLl9PcnRSdW5XaXRoQmluZGluZz1ZKSksci5fT3J0QmluZElucHV0PXAoci5fT3J0QmluZElucHV0LCgpPT5yLl9PcnRCaW5kSW5wdXQsWT0+ci5fT3J0QmluZElucHV0PVkpLHIuanNlcFJlZ2lzdGVyQnVmZmVyPShZLFEsSixjZSk9PmwucmVnaXN0ZXJCdWZmZXIoWSxRLEosY2UpLHIuanNlcFVucmVnaXN0ZXJCdWZmZXJzPVk9PntsLnVucmVnaXN0ZXJCdWZmZXJzKFkpfSxyLmpzZXBHZXRCdWZmZXI9WT0+bC5nZXRCdWZmZXIoWSksci5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oWSxRLEopPT5sLmNyZWF0ZURvd25sb2FkZXIoWSxRLEopfTt2YXIgcz1PYmplY3QuYXNzaWduKHt9LHIpLHU9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KGwscCk9Pnt0aHJvdyBwfSxhPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIsbT10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLGc9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLHg9XCJcIixiLHcsdjtpZihnKXt2YXIgeT0oc24oKSxNdChhbikpLFM9KGxuKCksTXQodW4pKTt4PW0/Uy5kaXJuYW1lKHgpK1wiL1wiOl9fZGlybmFtZStcIi9cIixiPShsLHApPT4obD1sLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwobCk6Uy5ub3JtYWxpemUobCkseS5yZWFkRmlsZVN5bmMobCxwP3ZvaWQgMDpcInV0ZjhcIikpLHY9bD0+KGw9YihsLCEwKSxsLmJ1ZmZlcnx8KGw9bmV3IFVpbnQ4QXJyYXkobCkpLGwpLHc9KGwscCxoLEM9ITApPT57bD1sLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwobCk6Uy5ub3JtYWxpemUobCkseS5yZWFkRmlsZShsLEM/dm9pZCAwOlwidXRmOFwiLChULFUpPT57VD9oKFQpOnAoQz9VLmJ1ZmZlcjpVKX0pfSwhci50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYodT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxkPShsLHApPT57dGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1sLHB9LHIuaW5zcGVjdD0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifWVsc2UoYXx8bSkmJihtP3g9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKHg9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLGUmJih4PWUpLHguaW5kZXhPZihcImJsb2I6XCIpIT09MD94PXguc3Vic3RyKDAseC5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTp4PVwiXCIsYj1sPT57dmFyIHA9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBwLm9wZW4oXCJHRVRcIixsLCExKSxwLnNlbmQobnVsbCkscC5yZXNwb25zZVRleHR9LG0mJih2PWw9Pnt2YXIgcD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHAub3BlbihcIkdFVFwiLGwsITEpLHAucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixwLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkocC5yZXNwb25zZSl9KSx3PShsLHAsaCk9Pnt2YXIgQz1uZXcgWE1MSHR0cFJlcXVlc3Q7Qy5vcGVuKFwiR0VUXCIsbCwhMCksQy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLEMub25sb2FkPSgpPT57Qy5zdGF0dXM9PTIwMHx8Qy5zdGF0dXM9PTAmJkMucmVzcG9uc2U/cChDLnJlc3BvbnNlKTpoKCl9LEMub25lcnJvcj1oLEMuc2VuZChudWxsKX0pO3ZhciBBPXIucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksUj1yLnByaW50RXJyfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihyLHMpLHM9bnVsbCxyLnRoaXNQcm9ncmFtJiYodT1yLnRoaXNQcm9ncmFtKSxyLnF1aXQmJihkPXIucXVpdCk7dmFyIFc7ci53YXNtQmluYXJ5JiYoVz1yLndhc21CaW5hcnkpO3ZhciBNPXIubm9FeGl0UnVudGltZXx8ITA7dHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZMZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIEQsXyx6PSExLEYscSxsZSxCLEsseGUsYWU7ZnVuY3Rpb24gd2UoKXt2YXIgbD1ELmJ1ZmZlcjtyLkhFQVA4PXE9bmV3IEludDhBcnJheShsKSxyLkhFQVAxNj1uZXcgSW50MTZBcnJheShsKSxyLkhFQVAzMj1CPW5ldyBJbnQzMkFycmF5KGwpLHIuSEVBUFU4PWxlPW5ldyBVaW50OEFycmF5KGwpLHIuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkobCksci5IRUFQVTMyPUs9bmV3IFVpbnQzMkFycmF5KGwpLHIuSEVBUEYzMj14ZT1uZXcgRmxvYXQzMkFycmF5KGwpLHIuSEVBUEY2ND1hZT1uZXcgRmxvYXQ2NEFycmF5KGwpfXZhciBqPVtdLFNlPVtdLE9lPVtdO2Z1bmN0aW9uIEllKCl7dmFyIGw9ci5wcmVSdW4uc2hpZnQoKTtqLnVuc2hpZnQobCl9dmFyIENlPTAsZHQ9bnVsbCxOZT1udWxsO2Z1bmN0aW9uIExlKGwpe3Rocm93IHIub25BYm9ydCYmci5vbkFib3J0KGwpLGw9XCJBYm9ydGVkKFwiK2wrXCIpXCIsUihsKSx6PSEwLEY9MSxsPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IobCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbihsKSxsfWZ1bmN0aW9uIE4obCl7cmV0dXJuIGwuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9dmFyIGRlO2lmKGRlPVwib3J0LXdhc20tc2ltZC53YXNtXCIsIU4oZGUpKXt2YXIgcGU9ZGU7ZGU9ci5sb2NhdGVGaWxlP3IubG9jYXRlRmlsZShwZSx4KTp4K3BlfWZ1bmN0aW9uIHplKGwpe2lmKGw9PWRlJiZXKXJldHVybiBuZXcgVWludDhBcnJheShXKTtpZih2KXJldHVybiB2KGwpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIFVlKGwpe2lmKCFXJiYoYXx8bSkpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYhbC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2gobCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihwPT57aWYoIXAub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrbCtcIlxcJ1wiO3JldHVybiBwLmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+emUobCkpO2lmKHcpcmV0dXJuIG5ldyBQcm9taXNlKChwLGgpPT57dyhsLEM9PnAobmV3IFVpbnQ4QXJyYXkoQykpLGgpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PnplKGwpKX1mdW5jdGlvbiBUZShsLHAsaCl7cmV0dXJuIFVlKGwpLnRoZW4oQz0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQyxwKSkudGhlbihDPT5DKS50aGVuKGgsQz0+e1IoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitDKSxMZShDKX0pfWZ1bmN0aW9uIGtlKGwscCl7dmFyIGg9ZGU7cmV0dXJuIFd8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxOKGgpfHxoLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxnfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9UZShoLGwscCk6ZmV0Y2goaCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihDPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhDLGwpLnRoZW4ocCxmdW5jdGlvbihUKXtyZXR1cm4gUihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitUKSxSKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksVGUoaCxsLHApfSkpfXZhciBHZSxYZT17OTEzNzkyOmw9PntyLnJhKFwiQWJzXCIsbCx2b2lkIDApfSw5MTM4NDM6bD0+e3IucmEoXCJOZWdcIixsLHZvaWQgMCl9LDkxMzg5NDpsPT57ci5yYShcIkZsb29yXCIsbCx2b2lkIDApfSw5MTM5NDc6bD0+e3IucmEoXCJDZWlsXCIsbCx2b2lkIDApfSw5MTM5OTk6bD0+e3IucmEoXCJSZWNpcHJvY2FsXCIsbCx2b2lkIDApfSw5MTQwNTc6bD0+e3IucmEoXCJTcXJ0XCIsbCx2b2lkIDApfSw5MTQxMDk6bD0+e3IucmEoXCJFeHBcIixsLHZvaWQgMCl9LDkxNDE2MDpsPT57ci5yYShcIkVyZlwiLGwsdm9pZCAwKX0sOTE0MjExOmw9PntyLnJhKFwiU2lnbW9pZFwiLGwsdm9pZCAwKX0sOTE0MjY2Omw9PntyLnJhKFwiTG9nXCIsbCx2b2lkIDApfSw5MTQzMTc6bD0+e3IucmEoXCJTaW5cIixsLHZvaWQgMCl9LDkxNDM2ODpsPT57ci5yYShcIkNvc1wiLGwsdm9pZCAwKX0sOTE0NDE5Omw9PntyLnJhKFwiVGFuXCIsbCx2b2lkIDApfSw5MTQ0NzA6bD0+e3IucmEoXCJBc2luXCIsbCx2b2lkIDApfSw5MTQ1MjI6bD0+e3IucmEoXCJBY29zXCIsbCx2b2lkIDApfSw5MTQ1NzQ6bD0+e3IucmEoXCJBdGFuXCIsbCx2b2lkIDApfSw5MTQ2MjY6bD0+e3IucmEoXCJTaW5oXCIsbCx2b2lkIDApfSw5MTQ2Nzg6bD0+e3IucmEoXCJDb3NoXCIsbCx2b2lkIDApfSw5MTQ3MzA6bD0+e3IucmEoXCJBc2luaFwiLGwsdm9pZCAwKX0sOTE0NzgzOmw9PntyLnJhKFwiQWNvc2hcIixsLHZvaWQgMCl9LDkxNDgzNjpsPT57ci5yYShcIkF0YW5oXCIsbCx2b2lkIDApfSw5MTQ4ODk6bD0+e3IucmEoXCJUYW5oXCIsbCx2b2lkIDApfSw5MTQ5NDE6bD0+e3IucmEoXCJOb3RcIixsLHZvaWQgMCl9LDkxNDk5MjoobCxwLGgpPT57ci5yYShcIkNsaXBWMTBcIixsLHttaW46cCxtYXg6aH0pfSw5MTUwNjQ6bD0+e3IucmEoXCJDbGlwXCIsbCx2b2lkIDApfSw5MTUxMTY6KGwscCk9PntyLnJhKFwiRWx1XCIsbCx7YWxwaGE6cH0pfSw5MTUxNzQ6bD0+e3IucmEoXCJSZWx1XCIsbCx2b2lkIDApfSw5MTUyMjY6KGwscCk9PntyLnJhKFwiTGVha3lSZWx1XCIsbCx7YWxwaGE6cH0pfSw5MTUyOTA6KGwscCk9PntyLnJhKFwiVGhyZXNob2xkZWRSZWx1XCIsbCx7YWxwaGE6cH0pfSw5MTUzNjA6KGwscCk9PntyLnJhKFwiQ2FzdFwiLGwse3RvOnB9KX0sOTE1NDE4Omw9PntyLnJhKFwiQWRkXCIsbCx2b2lkIDApfSw5MTU0Njk6bD0+e3IucmEoXCJTdWJcIixsLHZvaWQgMCl9LDkxNTUyMDpsPT57ci5yYShcIk11bFwiLGwsdm9pZCAwKX0sOTE1NTcxOmw9PntyLnJhKFwiRGl2XCIsbCx2b2lkIDApfSw5MTU2MjI6bD0+e3IucmEoXCJQb3dcIixsLHZvaWQgMCl9LDkxNTY3MzpsPT57ci5yYShcIkVxdWFsXCIsbCx2b2lkIDApfSw5MTU3MjY6bD0+e3IucmEoXCJHcmVhdGVyXCIsbCx2b2lkIDApfSw5MTU3ODE6bD0+e3IucmEoXCJHcmVhdGVyT3JFcXVhbFwiLGwsdm9pZCAwKX0sOTE1ODQzOmw9PntyLnJhKFwiTGVzc1wiLGwsdm9pZCAwKX0sOTE1ODk1Omw9PntyLnJhKFwiTGVzc09yRXF1YWxcIixsLHZvaWQgMCl9LDkxNTk1NDoobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VNZWFuXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTYxMTg6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlTWF4XCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTYyODE6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlTWluXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTY0NDQ6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlUHJvZFwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE2NjA4OihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZVN1bVwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE2NzcxOihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZUwxXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTY5MzM6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlTDJcIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNzA5NToobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VMb2dTdW1cIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNzI2MToobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VTdW1TcXVhcmVcIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNzQzMDoobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VMb2dTdW1FeHBcIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNzU5OTpsPT57ci5yYShcIldoZXJlXCIsbCx2b2lkIDApfSw5MTc2NTI6KGwscCxoKT0+e3IucmEoXCJUcmFuc3Bvc2VcIixsLHtwZXJtOnA/QXJyYXkuZnJvbShCLnN1YmFycmF5KGg+Pj4wLGgrcD4+PjApKTpbXX0pfSw5MTc3NjU6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSx0ZSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGwse2Zvcm1hdDpZP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6cCxkaWxhdGlvbnM6W2hdLGdyb3VwOkMsa2VybmVsX3NoYXBlOltUXSxwYWRzOltVLEddLHN0cmlkZXM6W3VlXSx3SXNDb25zdDooKT0+ISFxW1E+Pj4wXSxvdXRwdXRQYWRkaW5nOko/QXJyYXkuZnJvbShCLnN1YmFycmF5KGNlPj4+MCxjZStKPj4+MCkpOltdLG91dHB1dFNoYXBlOm1lP0FycmF5LmZyb20oQi5zdWJhcnJheShFPj4+MCxFK21lPj4+MCkpOltdLGFjdGl2YXRpb246X2UodGUpfSl9LDkxODE3OToobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsbCx7Zm9ybWF0OnVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6cCxkaWxhdGlvbnM6QXJyYXkuZnJvbShCLnN1YmFycmF5KGg+Pj4wLGgrMj4+PjApKSxncm91cDpDLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoVT4+PjAsVSs0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShCLnN1YmFycmF5KEc+Pj4wLEcrMj4+PjApKSx3SXNDb25zdDooKT0+ISFxW1k+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8UT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoSj4+PjAsSitRPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8Y2U/QXJyYXkuZnJvbShCLnN1YmFycmF5KG1lPj4+MCxtZStjZT4+PjApKTpbXSxhY3RpdmF0aW9uOl9lKEUpfSl9LDkxODczNjoobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFLHRlKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsbCx7Zm9ybWF0Olk/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpwLGRpbGF0aW9uczpbaF0sZ3JvdXA6QyxrZXJuZWxfc2hhcGU6W1RdLHBhZHM6W1UsR10sc3RyaWRlczpbdWVdLHdJc0NvbnN0OigpPT4hIXFbUT4+PjBdLG91dHB1dFBhZGRpbmc6Sj9BcnJheS5mcm9tKEIuc3ViYXJyYXkoY2U+Pj4wLGNlK0o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6bWU/QXJyYXkuZnJvbShCLnN1YmFycmF5KEU+Pj4wLEUrbWU+Pj4wKSk6W10sYWN0aXZhdGlvbjpfZSh0ZSl9KX0sOTE5MTUwOihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixsLHtmb3JtYXQ6dWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpwLGRpbGF0aW9uczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoaD4+PjAsaCsyPj4+MCkpLGdyb3VwOkMsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrMj4+PjApKSxwYWRzOkFycmF5LmZyb20oQi5zdWJhcnJheShVPj4+MCxVKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoRz4+PjAsRysyPj4+MCkpLHdJc0NvbnN0OigpPT4hIXFbWT4+PjBdLG91dHB1dFBhZGRpbmc6MDxRP0FycmF5LmZyb20oQi5zdWJhcnJheShKPj4+MCxKK1E+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxjZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkobWU+Pj4wLG1lK2NlPj4+MCkpOltdLGFjdGl2YXRpb246X2UoRSl9KX0sOTE5NzA3OihsLHApPT57ci5yYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsbCx7Zm9ybWF0OnA/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTE5Nzk4OihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIkF2ZXJhZ2VQb29sXCIsbCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnAsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOlQsZGlsYXRpb25zOltVLEddLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbUSxKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjAwODI6KGwscCk9PntyLnJhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixsLHtmb3JtYXQ6cD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjAxNzM6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiQXZlcmFnZVBvb2xcIixsLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6cCxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6VCxkaWxhdGlvbnM6W1UsR10sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltRLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMDQ1NzoobCxwKT0+e3IucmEoXCJHbG9iYWxNYXhQb29sXCIsbCx7Zm9ybWF0OnA/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwNTQ0OihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIk1heFBvb2xcIixsLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6cCxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6VCxkaWxhdGlvbnM6W1UsR10sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltRLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMDgyNDoobCxwKT0+e3IucmEoXCJHbG9iYWxNYXhQb29sXCIsbCx7Zm9ybWF0OnA/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwOTExOihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIk1heFBvb2xcIixsLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6cCxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6VCxkaWxhdGlvbnM6W1UsR10sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltRLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMTE5MToobCxwLGgsQyxUKT0+e3IucmEoXCJHZW1tXCIsbCx7YWxwaGE6cCxiZXRhOmgsdHJhbnNBOkMsdHJhbnNCOlR9KX0sOTIxMjk1Omw9PntyLnJhKFwiTWF0TXVsXCIsbCx2b2lkIDApfSw5MjEzNDk6KGwscCxoLEMpPT57ci5yYShcIkFyZ01heFwiLGwse2tlZXBEaW1zOiEhcCxzZWxlY3RMYXN0SW5kZXg6ISFoLGF4aXM6Q30pfSw5MjE0NTc6KGwscCxoLEMpPT57ci5yYShcIkFyZ01pblwiLGwse2tlZXBEaW1zOiEhcCxzZWxlY3RMYXN0SW5kZXg6ISFoLGF4aXM6Q30pfSw5MjE1NjU6KGwscCk9PntyLnJhKFwiU29mdG1heFwiLGwse2F4aXM6cH0pfSw5MjE2Mjg6KGwscCk9PntyLnJhKFwiQ29uY2F0XCIsbCx7YXhpczpwfSl9LDkyMTY4ODoobCxwLGgsQyxUKT0+e3IucmEoXCJTcGxpdFwiLGwse2F4aXM6cCxudW1PdXRwdXRzOmgsc3BsaXRTaXplczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTIxODMzOmw9PntyLnJhKFwiRXhwYW5kXCIsbCx2b2lkIDApfSw5MjE4ODc6KGwscCk9PntyLnJhKFwiR2F0aGVyXCIsbCx7YXhpczpOdW1iZXIocCl9KX0sOTIxOTU4OihsLHApPT57ci5yYShcIkdhdGhlckVsZW1lbnRzXCIsbCx7YXhpczpOdW1iZXIocCl9KX0sOTIyMDM3OihsLHAsaCxDLFQsVSxHLHVlLFksUSxKKT0+e3IucmEoXCJSZXNpemVcIixsLHthbnRpYWxpYXM6cCxheGVzOmg/QXJyYXkuZnJvbShCLnN1YmFycmF5KEM+Pj4wLEMraD4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpfZShUKSxjdWJpY0NvZWZmQTpVLGV4Y2x1ZGVPdXRzaWRlOkcsZXh0cmFwb2xhdGlvblZhbHVlOnVlLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpfZShZKSxtb2RlOl9lKFEpLG5lYXJlc3RNb2RlOl9lKEopfSl9LDkyMjM4ODoobCxwLGgsQyxULFUsRyk9PntyLnJhKFwiU2xpY2VcIixsLHtzdGFydHM6cD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoaD4+PjAsaCtwPj4+MCkpOltdLGVuZHM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdLGF4ZXM6VT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoRz4+PjAsRytVPj4+MCkpOltdfSl9LDkyMjYxOTpsPT57ci5yYShcIlRpbGVcIixsLHZvaWQgMCl9LDkyMjY3MToobCxwLGgpPT57ci5yYShcIkxheWVyTm9ybWFsaXphdGlvblwiLGwse2F4aXM6TnVtYmVyKHApLGVwc2lsb246TnVtYmVyKGgpfSl9LDkyMjc3ODoobCxwLGgpPT57ci5yYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGwse2Vwc2lsb246cCxmb3JtYXQ6aD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjI4OTI6KGwscCxoKT0+e3IucmEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixsLHtlcHNpbG9uOnAsZm9ybWF0Omg/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIzMDA2Omw9PntyLnJhKFwiUmFuZ2VcIixsLHZvaWQgMCl9LDkyMzA1OToobCxwKT0+e3IucmEoXCJFaW5zdW1cIixsLHtlcXVhdGlvbjpfZShwKX0pfSw5MjMxNDA6KGwscCxoLEMsVCk9PntyLnJhKFwiUGFkXCIsbCx7bW9kZTpwLHZhbHVlOmgscGFkczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTIzMjcyOmw9PntyLnJhKFwiR2VsdVwiLGwsdm9pZCAwKX0sOTIzMzI0Omw9PntyLnJhKFwiQmlhc0FkZFwiLGwsdm9pZCAwKX0sOTIzMzc5Omw9PntyLnJhKFwiQmlhc1NwbGl0R2VsdVwiLGwsdm9pZCAwKX0sOTIzNDQwOihsLHApPT57ci5yYShcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixsLHtlcHNpbG9uOnB9KX0sOTIzNTIxOihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lKT0+e3IucmEoXCJDb252XCIsbCx7Zm9ybWF0Olk/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6cCxkaWxhdGlvbnM6W2hdLGdyb3VwOkMsa2VybmVsX3NoYXBlOltUXSxwYWRzOlU/QXJyYXkuZnJvbShCLnN1YmFycmF5KEc+Pj4wLEcrVT4+PjApKTpbXSxzdHJpZGVzOlt1ZV0sd19pc19jb25zdDooKT0+ISFxW1E+Pj4wXSxhY3RpdmF0aW9uOl9lKEopLGFjdGl2YXRpb25fcGFyYW1zOmNlP0FycmF5LmZyb20oeGUuc3ViYXJyYXkobWU+Pj4wLG1lK2NlPj4+MCkpOltdfSl9LDkyMzkwMjoobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJDb252XCIsbCx7Zm9ybWF0OmNlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnAsZGlsYXRpb25zOltoLENdLGdyb3VwOlQsa2VybmVsX3NoYXBlOltVLEddLHBhZHM6dWU/QXJyYXkuZnJvbShCLnN1YmFycmF5KFk+Pj4wLFkrdWU+Pj4wKSk6W10sc3RyaWRlczpbUSxKXSx3X2lzX2NvbnN0OigpPT4hIXFbbWU+Pj4wXSxhY3RpdmF0aW9uOl9lKEUpLGFjdGl2YXRpb25fcGFyYW1zOnRlP0FycmF5LmZyb20oeGUuc3ViYXJyYXkoZmU+Pj4wLGZlK3RlPj4+MCkpOltdfSl9LDkyNDMwNDpsPT57ci5SYShsKX0sOTI0MzM4OihsLHApPT5yLlNhKGwscCxyLkRhLlRhLHIuRGEuZXJyb3JzKSw5MjQ0NTA6bD0+ci5PYShsKSw5MjQ0ODM6bD0+ci5RYShsKSw5MjQ1MTU6KGwscCxoKT0+e3IuSmEobCxwLGgsITApfSw5MjQ1NTQ6KGwscCxoKT0+e3IuSmEobCxwLGgpfX07ZnVuY3Rpb24gRmUobCl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2x9KWAsdGhpcy5zdGF0dXM9bH12YXIgeXQ9bD0+e2Zvcig7MDxsLmxlbmd0aDspbC5zaGlmdCgpKHIpfTtmdW5jdGlvbiBidChsKXt0aGlzLkhhPWwtMjQsdGhpcy5NYT1mdW5jdGlvbihwKXtLW3RoaXMuSGErND4+Mj4+PjBdPXB9LHRoaXMuTGE9ZnVuY3Rpb24ocCl7S1t0aGlzLkhhKzg+PjI+Pj4wXT1wfSx0aGlzLllhPWZ1bmN0aW9uKHAsaCl7dGhpcy5LYSgpLHRoaXMuTWEocCksdGhpcy5MYShoKX0sdGhpcy5LYT1mdW5jdGlvbigpe0tbdGhpcy5IYSsxNj4+Mj4+PjBdPTB9fXZhciBCdD0wLGxyPTAsS2U9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLGt0PShsLHAsaCk9PntwPj4+PTA7dmFyIEM9cCtoO2ZvcihoPXA7bFtoXSYmIShoPj1DKTspKytoO2lmKDE2PGgtcCYmbC5idWZmZXImJktlKXJldHVybiBLZS5kZWNvZGUobC5zdWJhcnJheShwLGgpKTtmb3IoQz1cIlwiO3A8aDspe3ZhciBUPWxbcCsrXTtpZihUJjEyOCl7dmFyIFU9bFtwKytdJjYzO2lmKChUJjIyNCk9PTE5MilDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChUJjMxKTw8NnxVKTtlbHNle3ZhciBHPWxbcCsrXSY2MztUPShUJjI0MCk9PTIyND8oVCYxNSk8PDEyfFU8PDZ8RzooVCY3KTw8MTh8VTw8MTJ8Rzw8NnxsW3ArK10mNjMsNjU1MzY+VD9DKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFQpOihULT02NTUzNixDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fFQ+PjEwLDU2MzIwfFQmMTAyMykpfX1lbHNlIEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoVCl9cmV0dXJuIEN9LF9lPShsLHApPT4obD4+Pj0wKT9rdChsZSxsLHApOlwiXCIsSXQ9bD0+e2Zvcih2YXIgcD0wLGg9MDtoPGwubGVuZ3RoOysraCl7dmFyIEM9bC5jaGFyQ29kZUF0KGgpOzEyNz49Qz9wKys6MjA0Nz49Qz9wKz0yOjU1Mjk2PD1DJiY1NzM0Mz49Qz8ocCs9NCwrK2gpOnArPTN9cmV0dXJuIHB9LER0PShsLHAsaCxDKT0+e2lmKGg+Pj49MCwhKDA8QykpcmV0dXJuIDA7dmFyIFQ9aDtDPWgrQy0xO2Zvcih2YXIgVT0wO1U8bC5sZW5ndGg7KytVKXt2YXIgRz1sLmNoYXJDb2RlQXQoVSk7aWYoNTUyOTY8PUcmJjU3MzQzPj1HKXt2YXIgdWU9bC5jaGFyQ29kZUF0KCsrVSk7Rz02NTUzNisoKEcmMTAyMyk8PDEwKXx1ZSYxMDIzfWlmKDEyNz49Ryl7aWYoaD49QylicmVhaztwW2grKz4+PjBdPUd9ZWxzZXtpZigyMDQ3Pj1HKXtpZihoKzE+PUMpYnJlYWs7cFtoKys+Pj4wXT0xOTJ8Rz4+Nn1lbHNle2lmKDY1NTM1Pj1HKXtpZihoKzI+PUMpYnJlYWs7cFtoKys+Pj4wXT0yMjR8Rz4+MTJ9ZWxzZXtpZihoKzM+PUMpYnJlYWs7cFtoKys+Pj4wXT0yNDB8Rz4+MTgscFtoKys+Pj4wXT0xMjh8Rz4+MTImNjN9cFtoKys+Pj4wXT0xMjh8Rz4+NiY2M31wW2grKz4+PjBdPTEyOHxHJjYzfX1yZXR1cm4gcFtoPj4+MF09MCxoLVR9LGF0PWw9PmwlND09PTAmJihsJTEwMCE9PTB8fGwlNDAwPT09MCksZHI9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0saXQ9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF0sRXQ9bD0+e3ZhciBwPUl0KGwpKzEsaD1SdChwKTtyZXR1cm4gaCYmRHQobCxsZSxoLHApLGh9LGN0PVtdLFR0PShsLHApPT57Y3QubGVuZ3RoPTA7dmFyIGg7Zm9yKHA+Pj0yO2g9bGVbbCsrPj4+MF07KXArPWghPTEwNSZwLGN0LnB1c2goaD09MTA1P0JbcD4+PjBdOmFlW3ArKz4+PjFdKSwrK3A7cmV0dXJuIGN0fSxPdD17fSxXdD0oKT0+e2lmKCFfdCl7dmFyIGw9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86dXx8XCIuL3RoaXMucHJvZ3JhbVwifSxwO2ZvcihwIGluIE90KU90W3BdPT09dm9pZCAwP2RlbGV0ZSBsW3BdOmxbcF09T3RbcF07dmFyIGg9W107Zm9yKHAgaW4gbCloLnB1c2goYCR7cH09JHtsW3BdfWApO190PWh9cmV0dXJuIF90fSxfdCxjcj1bbnVsbCxbXSxbXV0sVmU9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSx6dD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIFZ0KGwpe3ZhciBwPUFycmF5KEl0KGwpKzEpO3JldHVybiBEdChsLHAsMCxwLmxlbmd0aCkscH1mdW5jdGlvbiBuZShsLHAsaCxDKXtmdW5jdGlvbiBUKEUsdGUsZmUpe2ZvcihFPXR5cGVvZiBFPT1cIm51bWJlclwiP0UudG9TdHJpbmcoKTpFfHxcIlwiO0UubGVuZ3RoPHRlOylFPWZlWzBdK0U7cmV0dXJuIEV9ZnVuY3Rpb24gVShFLHRlKXtyZXR1cm4gVChFLHRlLFwiMFwiKX1mdW5jdGlvbiBHKEUsdGUpe2Z1bmN0aW9uIGZlKFh0KXtyZXR1cm4gMD5YdD8tMTowPFh0PzE6MH12YXIgdXQ7cmV0dXJuKHV0PWZlKEUuZ2V0RnVsbFllYXIoKS10ZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYodXQ9ZmUoRS5nZXRNb250aCgpLXRlLmdldE1vbnRoKCkpKT09PTAmJih1dD1mZShFLmdldERhdGUoKS10ZS5nZXREYXRlKCkpKSx1dH1mdW5jdGlvbiB1ZShFKXtzd2l0Y2goRS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBFO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBZKEUpe3ZhciB0ZT1FLkJhO2ZvcihFPW5ldyBEYXRlKG5ldyBEYXRlKEUuQ2ErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDx0ZTspe3ZhciBmZT1FLmdldE1vbnRoKCksdXQ9KGF0KEUuZ2V0RnVsbFllYXIoKSk/VmU6enQpW2ZlXTtpZih0ZT51dC1FLmdldERhdGUoKSl0ZS09dXQtRS5nZXREYXRlKCkrMSxFLnNldERhdGUoMSksMTE+ZmU/RS5zZXRNb250aChmZSsxKTooRS5zZXRNb250aCgwKSxFLnNldEZ1bGxZZWFyKEUuZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtFLnNldERhdGUoRS5nZXREYXRlKCkrdGUpO2JyZWFrfX1yZXR1cm4gZmU9bmV3IERhdGUoRS5nZXRGdWxsWWVhcigpKzEsMCw0KSx0ZT11ZShuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCw0KSksZmU9dWUoZmUpLDA+PUcodGUsRSk/MD49RyhmZSxFKT9FLmdldEZ1bGxZZWFyKCkrMTpFLmdldEZ1bGxZZWFyKCk6RS5nZXRGdWxsWWVhcigpLTF9bD4+Pj0wLHA+Pj49MCxoPj4+PTAsQz4+Pj0wO3ZhciBRPUJbQys0MD4+Mj4+PjBdO0M9e1dhOkJbQz4+Mj4+PjBdLFZhOkJbQys0Pj4yPj4+MF0sRWE6QltDKzg+PjI+Pj4wXSxJYTpCW0MrMTI+PjI+Pj4wXSxGYTpCW0MrMTY+PjI+Pj4wXSxDYTpCW0MrMjA+PjI+Pj4wXSx3YTpCW0MrMjQ+PjI+Pj4wXSxCYTpCW0MrMjg+PjI+Pj4wXSwkYTpCW0MrMzI+PjI+Pj4wXSxVYTpCW0MrMzY+PjI+Pj4wXSxYYTpRP19lKFEpOlwiXCJ9LGg9X2UoaCksUT17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgSiBpbiBRKWg9aC5yZXBsYWNlKG5ldyBSZWdFeHAoSixcImdcIiksUVtKXSk7dmFyIGNlPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksbWU9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO1E9e1wiJWFcIjpFPT5jZVtFLndhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6RT0+Y2VbRS53YV0sXCIlYlwiOkU9Pm1lW0UuRmFdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpFPT5tZVtFLkZhXSxcIiVDXCI6RT0+VSgoRS5DYSsxOTAwKS8xMDB8MCwyKSxcIiVkXCI6RT0+VShFLklhLDIpLFwiJWVcIjpFPT5UKEUuSWEsMixcIiBcIiksXCIlZ1wiOkU9PlkoRSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOkU9PlkoRSksXCIlSFwiOkU9PlUoRS5FYSwyKSxcIiVJXCI6RT0+KEU9RS5FYSxFPT0wP0U9MTI6MTI8RSYmKEUtPTEyKSxVKEUsMikpLFwiJWpcIjpFPT57Zm9yKHZhciB0ZT0wLGZlPTA7ZmU8PUUuRmEtMTt0ZSs9KGF0KEUuQ2ErMTkwMCk/VmU6enQpW2ZlKytdKTtyZXR1cm4gVShFLklhK3RlLDMpfSxcIiVtXCI6RT0+VShFLkZhKzEsMiksXCIlTVwiOkU9PlUoRS5WYSwyKSxcIiVuXCI6KCk9PmBcXG5gLFwiJXBcIjpFPT4wPD1FLkVhJiYxMj5FLkVhP1wiQU1cIjpcIlBNXCIsXCIlU1wiOkU9PlUoRS5XYSwyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6RT0+RS53YXx8NyxcIiVVXCI6RT0+VShNYXRoLmZsb29yKChFLkJhKzctRS53YSkvNyksMiksXCIlVlwiOkU9Pnt2YXIgdGU9TWF0aC5mbG9vcigoRS5CYSs3LShFLndhKzYpJTcpLzcpO2lmKDI+PShFLndhKzM3MS1FLkJhLTIpJTcmJnRlKyssdGUpdGU9PTUzJiYoZmU9KEUud2ErMzcxLUUuQmEpJTcsZmU9PTR8fGZlPT0zJiZhdChFLkNhKXx8KHRlPTEpKTtlbHNle3RlPTUyO3ZhciBmZT0oRS53YSs3LUUuQmEtMSklNzsoZmU9PTR8fGZlPT01JiZhdChFLkNhJTQwMC0xKSkmJnRlKyt9cmV0dXJuIFUodGUsMil9LFwiJXdcIjpFPT5FLndhLFwiJVdcIjpFPT5VKE1hdGguZmxvb3IoKEUuQmErNy0oRS53YSs2KSU3KS83KSwyKSxcIiV5XCI6RT0+KEUuQ2ErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOkU9PkUuQ2ErMTkwMCxcIiV6XCI6RT0+e0U9RS5VYTt2YXIgdGU9MDw9RTtyZXR1cm4gRT1NYXRoLmFicyhFKS82MCwodGU/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoRS82MCoxMDArRSU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOkU9PkUuWGEsXCIlJVwiOigpPT5cIiVcIn0saD1oLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpO2ZvcihKIGluIFEpaC5pbmNsdWRlcyhKKSYmKGg9aC5yZXBsYWNlKG5ldyBSZWdFeHAoSixcImdcIiksUVtKXShDKSkpO3JldHVybiBoPWgucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSxKPVZ0KGgpLEoubGVuZ3RoPnA/MDoocS5zZXQoSixsPj4+MCksSi5sZW5ndGgtMSl9ZnVuY3Rpb24gc3QobCl7dHJ5e2woKX1jYXRjaChwKXtMZShwKX19ZnVuY3Rpb24gcHIobCl7dmFyIHA9e30saDtmb3IoaCBpbiBsKShmdW5jdGlvbihDKXt2YXIgVD1sW0NdO3BbQ109dHlwZW9mIFQ9PVwiZnVuY3Rpb25cIj9mdW5jdGlvbigpe3d0LnB1c2goQyk7dHJ5e3JldHVybiBULmFwcGx5KG51bGwsYXJndW1lbnRzKX1maW5hbGx5e3p8fCh3dC5wb3AoKT09PUN8fExlKCksSGUmJkplPT09MSYmd3QubGVuZ3RoPT09MCYmKEplPTAsc3QocXQpLHR5cGVvZiBGaWJlcnM8XCJ1XCImJkZpYmVycy5hYigpKSl9fTpUfSkoaCk7cmV0dXJuIHB9dmFyIEplPTAsSGU9bnVsbCxmcj0wLHd0PVtdLEd0PXt9LE50PXt9LG1yPTAsdnQ9bnVsbCxocj1bXTtmdW5jdGlvbiBncigpe3JldHVybiBuZXcgUHJvbWlzZSgobCxwKT0+e3Z0PXtyZXNvbHZlOmwscmVqZWN0OnB9fSl9ZnVuY3Rpb24geXIoKXt2YXIgbD1SdCg2NTU0OCkscD1sKzEyO0tbbD4+Mj4+PjBdPXAsS1tsKzQ+PjI+Pj4wXT1wKzY1NTM2LHA9d3RbMF07dmFyIGg9R3RbcF07cmV0dXJuIGg9PT12b2lkIDAmJihoPW1yKyssR3RbcF09aCxOdFtoXT1wKSxCW2wrOD4+Mj4+PjBdPWgsbH1mdW5jdGlvbiBicihsKXtpZigheil7aWYoSmU9PT0wKXt2YXIgcD0hMSxoPSExO2woKEM9MCk9PntpZigheiYmKGZyPUMscD0hMCxoKSl7SmU9MixzdCgoKT0+UHQoSGUpKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5HYS5OYSYmQnJvd3Nlci5HYS5yZXN1bWUoKSxDPSExO3RyeXt2YXIgVD0oMCxfW050W0JbSGUrOD4+Mj4+PjBdXV0pKCl9Y2F0Y2godWUpe1Q9dWUsQz0hMH12YXIgVT0hMTtpZighSGUpe3ZhciBHPXZ0O0cmJih2dD1udWxsLChDP0cucmVqZWN0OkcucmVzb2x2ZSkoVCksVT0hMCl9aWYoQyYmIVUpdGhyb3cgVH19KSxoPSEwLHB8fChKZT0xLEhlPXlyKCksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuR2EuTmEmJkJyb3dzZXIuR2EucGF1c2UoKSxzdCgoKT0+S3QoSGUpKSl9ZWxzZSBKZT09PTI/KEplPTAsc3QoJHQpLFV0KEhlKSxIZT1udWxsLGhyLmZvckVhY2goQz0+e2lmKCF6KXRyeXtpZihDKCksIU0pdHJ5e0Y9Rj1DPUYsTXx8KHIub25FeGl0JiZyLm9uRXhpdChDKSx6PSEwKSxkKEMsbmV3IEZlKEMpKX1jYXRjaChUKXtUIGluc3RhbmNlb2YgRmV8fFQ9PVwidW53aW5kXCJ8fGQoMSxUKX19Y2F0Y2goVCl7VCBpbnN0YW5jZW9mIEZlfHxUPT1cInVud2luZFwifHxkKDEsVCl9fSkpOkxlKGBpbnZhbGlkIHN0YXRlOiAke0plfWApO3JldHVybiBmcn19ZnVuY3Rpb24gd3IobCl7cmV0dXJuIGJyKHA9PntsKCkudGhlbihwKX0pfXZhciB2cj17bjpmdW5jdGlvbihsLHAsaCl7cmV0dXJuIHdyKGFzeW5jKCk9Pnthd2FpdCByLlBhKGwscCxoKX0pfSxhOmZ1bmN0aW9uKGwscCxoKXt0aHJvdyBsPj4+PTAsbmV3IGJ0KGwpLllhKHA+Pj4wLGg+Pj4wKSxCdD1sLGxyKyssQnR9LGc6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sSjpmdW5jdGlvbigpe30sejpmdW5jdGlvbigpe30sQjpmdW5jdGlvbigpe30sTDpmdW5jdGlvbigpe3JldHVybiAwfSxIOmZ1bmN0aW9uKCl7fSxDOmZ1bmN0aW9uKCl7fSxHOmZ1bmN0aW9uKCl7fSxsOmZ1bmN0aW9uKCl7fSxBOmZ1bmN0aW9uKCl7fSx4OmZ1bmN0aW9uKCl7fSxJOmZ1bmN0aW9uKCl7fSx5OmZ1bmN0aW9uKCl7fSxtOigpPT4hMCxxOmZ1bmN0aW9uKGwscCxoKXtsPXArMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWw/KGw+Pj4wKSs0Mjk0OTY3Mjk2KnA6TmFOLGg+Pj49MCxsPW5ldyBEYXRlKDFlMypsKSxCW2g+PjI+Pj4wXT1sLmdldFVUQ1NlY29uZHMoKSxCW2grND4+Mj4+PjBdPWwuZ2V0VVRDTWludXRlcygpLEJbaCs4Pj4yPj4+MF09bC5nZXRVVENIb3VycygpLEJbaCsxMj4+Mj4+PjBdPWwuZ2V0VVRDRGF0ZSgpLEJbaCsxNj4+Mj4+PjBdPWwuZ2V0VVRDTW9udGgoKSxCW2grMjA+PjI+Pj4wXT1sLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxCW2grMjQ+PjI+Pj4wXT1sLmdldFVUQ0RheSgpLEJbaCsyOD4+Mj4+PjBdPShsLmdldFRpbWUoKS1EYXRlLlVUQyhsLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxyOmZ1bmN0aW9uKGwscCxoKXtsPXArMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWw/KGw+Pj4wKSs0Mjk0OTY3Mjk2KnA6TmFOLGg+Pj49MCxsPW5ldyBEYXRlKDFlMypsKSxCW2g+PjI+Pj4wXT1sLmdldFNlY29uZHMoKSxCW2grND4+Mj4+PjBdPWwuZ2V0TWludXRlcygpLEJbaCs4Pj4yPj4+MF09bC5nZXRIb3VycygpLEJbaCsxMj4+Mj4+PjBdPWwuZ2V0RGF0ZSgpLEJbaCsxNj4+Mj4+PjBdPWwuZ2V0TW9udGgoKSxCW2grMjA+PjI+Pj4wXT1sLmdldEZ1bGxZZWFyKCktMTkwMCxCW2grMjQ+PjI+Pj4wXT1sLmdldERheSgpLEJbaCsyOD4+Mj4+PjBdPShhdChsLmdldEZ1bGxZZWFyKCkpP2RyOml0KVtsLmdldE1vbnRoKCldK2wuZ2V0RGF0ZSgpLTF8MCxCW2grMzY+PjI+Pj4wXT0tKDYwKmwuZ2V0VGltZXpvbmVPZmZzZXQoKSkscD1uZXcgRGF0ZShsLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBDPW5ldyBEYXRlKGwuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7QltoKzMyPj4yPj4+MF09KHAhPUMmJmwuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oQyxwKSl8MH0sczpmdW5jdGlvbihsKXtsPj4+PTA7dmFyIHA9bmV3IERhdGUoQltsKzIwPj4yPj4+MF0rMTkwMCxCW2wrMTY+PjI+Pj4wXSxCW2wrMTI+PjI+Pj4wXSxCW2wrOD4+Mj4+PjBdLEJbbCs0Pj4yPj4+MF0sQltsPj4yPj4+MF0sMCksaD1CW2wrMzI+PjI+Pj4wXSxDPXAuZ2V0VGltZXpvbmVPZmZzZXQoKSxUPW5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksVT1uZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEc9TWF0aC5taW4oVSxUKTtyZXR1cm4gMD5oP0JbbCszMj4+Mj4+PjBdPSsoVCE9VSYmRz09Qyk6MDxoIT0oRz09QykmJihUPU1hdGgubWF4KFUsVCkscC5zZXRUaW1lKHAuZ2V0VGltZSgpKzZlNCooKDA8aD9HOlQpLUMpKSksQltsKzI0Pj4yPj4+MF09cC5nZXREYXkoKSxCW2wrMjg+PjI+Pj4wXT0oYXQocC5nZXRGdWxsWWVhcigpKT9kcjppdClbcC5nZXRNb250aCgpXStwLmdldERhdGUoKS0xfDAsQltsPj4yPj4+MF09cC5nZXRTZWNvbmRzKCksQltsKzQ+PjI+Pj4wXT1wLmdldE1pbnV0ZXMoKSxCW2wrOD4+Mj4+PjBdPXAuZ2V0SG91cnMoKSxCW2wrMTI+PjI+Pj4wXT1wLmdldERhdGUoKSxCW2wrMTY+PjI+Pj4wXT1wLmdldE1vbnRoKCksQltsKzIwPj4yPj4+MF09cC5nZXRZZWFyKCksbD1wLmdldFRpbWUoKS8xZTMsTHQoKEdlPWwsMTw9K01hdGguYWJzKEdlKT8wPEdlPytNYXRoLmZsb29yKEdlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKEdlLSsofn5HZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCkpLGw+Pj4wfSxvOmZ1bmN0aW9uKCl7cmV0dXJuLTUyfSxwOmZ1bmN0aW9uKCl7fSx2OmZ1bmN0aW9uKGwscCxoKXtmdW5jdGlvbiBDKFkpe3JldHVybihZPVkudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP1lbMV06XCJHTVRcIn1oPj4+PTA7dmFyIFQ9bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLFU9bmV3IERhdGUoVCwwLDEpLEc9bmV3IERhdGUoVCw2LDEpO1Q9VS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB1ZT1HLmdldFRpbWV6b25lT2Zmc2V0KCk7S1tsPj4+MD4+Mj4+PjBdPTYwKk1hdGgubWF4KFQsdWUpLEJbcD4+PjA+PjI+Pj4wXT0rKFQhPXVlKSxsPUMoVSkscD1DKEcpLGw9RXQobCkscD1FdChwKSx1ZTxUPyhLW2g+PjI+Pj4wXT1sLEtbaCs0Pj4yPj4+MF09cCk6KEtbaD4+Mj4+PjBdPXAsS1toKzQ+PjI+Pj4wXT1sKX0sZTooKT0+e0xlKFwiXCIpfSxiOmZ1bmN0aW9uKGwscCxoKXtyZXR1cm4gbD4+Pj0wLHA9VHQocD4+PjAsaD4+PjApLFhlW2xdLmFwcGx5KG51bGwscCl9LGk6ZnVuY3Rpb24obCxwLGgpe3JldHVybiBsPj4+PTAscD1UdChwPj4+MCxoPj4+MCksWGVbbF0uYXBwbHkobnVsbCxwKX0saDpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx3OmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGM6KCk9PnBlcmZvcm1hbmNlLm5vdygpLEs6ZnVuY3Rpb24obCxwLGgpe3JldHVybiBwPj4+PTAsbGUuY29weVdpdGhpbihsPj4+MD4+PjAscD4+PjAscCsoaD4+PjApPj4+MCl9LHU6ZnVuY3Rpb24obCl7bD4+Pj0wO3ZhciBwPWxlLmxlbmd0aDtpZig0Mjk0OTAxNzYwPGwpcmV0dXJuITE7Zm9yKHZhciBoPTE7ND49aDtoKj0yKXt2YXIgQz1wKigxKy4yL2gpO0M9TWF0aC5taW4oQyxsKzEwMDY2MzI5Nik7dmFyIFQ9TWF0aDtDPU1hdGgubWF4KGwsQyk7ZTp7VD1ULm1pbi5jYWxsKFQsNDI5NDkwMTc2MCxDKyg2NTUzNi1DJTY1NTM2KSU2NTUzNiktRC5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2O3RyeXtELmdyb3coVCksd2UoKTt2YXIgVT0xO2JyZWFrIGV9Y2F0Y2h7fVU9dm9pZCAwfWlmKFUpcmV0dXJuITB9cmV0dXJuITF9LEQ6ZnVuY3Rpb24obCxwKXtsPj4+PTAscD4+Pj0wO3ZhciBoPTA7cmV0dXJuIFd0KCkuZm9yRWFjaChmdW5jdGlvbihDLFQpe3ZhciBVPXAraDtmb3IoVD1LW2wrNCpUPj4yPj4+MF09VSxVPTA7VTxDLmxlbmd0aDsrK1UpcVtUKys+PjA+Pj4wXT1DLmNoYXJDb2RlQXQoVSk7cVtUPj4wPj4+MF09MCxoKz1DLmxlbmd0aCsxfSksMH0sRTpmdW5jdGlvbihsLHApe2w+Pj49MCxwPj4+PTA7dmFyIGg9V3QoKTtLW2w+PjI+Pj4wXT1oLmxlbmd0aDt2YXIgQz0wO3JldHVybiBoLmZvckVhY2goZnVuY3Rpb24oVCl7Qys9VC5sZW5ndGgrMX0pLEtbcD4+Mj4+PjBdPUMsMH0sZjooKT0+NTIsazpmdW5jdGlvbigpe3JldHVybiA1Mn0sdDpmdW5jdGlvbigpe3JldHVybiA3MH0sajpmdW5jdGlvbihsLHAsaCxDKXtwPj4+PTAsaD4+Pj0wLEM+Pj49MDtmb3IodmFyIFQ9MCxVPTA7VTxoO1UrKyl7dmFyIEc9S1twPj4yPj4+MF0sdWU9S1twKzQ+PjI+Pj4wXTtwKz04O2Zvcih2YXIgWT0wO1k8dWU7WSsrKXt2YXIgUT1sZVtHK1k+Pj4wXSxKPWNyW2xdO1E9PT0wfHxRPT09MTA/KChsPT09MT9BOlIpKGt0KEosMCkpLEoubGVuZ3RoPTApOkoucHVzaChRKX1UKz11ZX1yZXR1cm4gS1tDPj4yPj4+MF09VCwwfSxGOm5lLGQ6ZnVuY3Rpb24obCxwLGgsQyl7cmV0dXJuIG5lKGw+Pj4wLHA+Pj4wLGg+Pj4wLEM+Pj4wKX19OyhmdW5jdGlvbigpe2Z1bmN0aW9uIGwoaCl7aWYoaD1oLmV4cG9ydHMsaD1wcihoKSxfPWg9cHQoaCksRD1fLk0sd2UoKSxTZS51bnNoaWZ0KF8uTiksQ2UtLSxyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhDZSksQ2U9PTAmJihkdCE9PW51bGwmJihjbGVhckludGVydmFsKGR0KSxkdD1udWxsKSxOZSkpe3ZhciBDPU5lO05lPW51bGwsQygpfXJldHVybiBofXZhciBwPXthOnZyfTtpZihDZSsrLHIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKENlKSxyLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHIuaW5zdGFudGlhdGVXYXNtKHAsbCl9Y2F0Y2goaCl7UihcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2gpLG4oaCl9cmV0dXJuIGtlKHAsZnVuY3Rpb24oaCl7bChoLmluc3RhbmNlKX0pLmNhdGNoKG4pLHt9fSkoKSxyLl9PcnRJbml0PShsLHApPT4oci5fT3J0SW5pdD1fLk8pKGwscCksci5fT3J0R2V0TGFzdEVycm9yPShsLHApPT4oci5fT3J0R2V0TGFzdEVycm9yPV8uUCkobCxwKSxyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0obCxwLGgsQyxULFUsRyx1ZSxZLFEpPT4oci5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9Xy5RKShsLHAsaCxDLFQsVSxHLHVlLFksUSksci5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGwscCk9PihyLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1fLlIpKGwscCksci5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShsLHAsaCk9PihyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9Xy5TKShsLHAsaCksci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShsLHAsaCk9PihyLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9Xy5UKShsLHAsaCksci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWw9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9Xy5VKShsKSxyLl9PcnRDcmVhdGVTZXNzaW9uPShsLHAsaCk9PihyLl9PcnRDcmVhdGVTZXNzaW9uPV8uVikobCxwLGgpLHIuX09ydFJlbGVhc2VTZXNzaW9uPWw9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbj1fLlcpKGwpLHIuX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGwscCxoKT0+KHIuX09ydEdldElucHV0T3V0cHV0Q291bnQ9Xy5YKShsLHAsaCksci5fT3J0R2V0SW5wdXROYW1lPShsLHApPT4oci5fT3J0R2V0SW5wdXROYW1lPV8uWSkobCxwKSxyLl9PcnRHZXRPdXRwdXROYW1lPShsLHApPT4oci5fT3J0R2V0T3V0cHV0TmFtZT1fLlopKGwscCksci5fT3J0RnJlZT1sPT4oci5fT3J0RnJlZT1fLl8pKGwpLHIuX09ydENyZWF0ZVRlbnNvcj0obCxwLGgsQyxULFUpPT4oci5fT3J0Q3JlYXRlVGVuc29yPV8uJCkobCxwLGgsQyxULFUpLHIuX09ydEdldFRlbnNvckRhdGE9KGwscCxoLEMsVCk9PihyLl9PcnRHZXRUZW5zb3JEYXRhPV8uYWEpKGwscCxoLEMsVCksci5fT3J0UmVsZWFzZVRlbnNvcj1sPT4oci5fT3J0UmVsZWFzZVRlbnNvcj1fLmJhKShsKSxyLl9PcnRDcmVhdGVSdW5PcHRpb25zPShsLHAsaCxDKT0+KHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9Xy5jYSkobCxwLGgsQyksci5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGwscCxoKT0+KHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PV8uZGEpKGwscCxoKSxyLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1sPT4oci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9Xy5lYSkobCksci5fT3J0Q3JlYXRlQmluZGluZz1sPT4oci5fT3J0Q3JlYXRlQmluZGluZz1fLmZhKShsKSxyLl9PcnRCaW5kSW5wdXQ9KGwscCxoKT0+KHIuX09ydEJpbmRJbnB1dD1fLmdhKShsLHAsaCksci5fT3J0QmluZE91dHB1dD0obCxwLGgsQyk9PihyLl9PcnRCaW5kT3V0cHV0PV8uaGEpKGwscCxoLEMpLHIuX09ydENsZWFyQm91bmRPdXRwdXRzPWw9PihyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1fLmlhKShsKSxyLl9PcnRSZWxlYXNlQmluZGluZz1sPT4oci5fT3J0UmVsZWFzZUJpbmRpbmc9Xy5qYSkobCksci5fT3J0UnVuV2l0aEJpbmRpbmc9KGwscCxoLEMsVCk9PihyLl9PcnRSdW5XaXRoQmluZGluZz1fLmthKShsLHAsaCxDLFQpLHIuX09ydFJ1bj0obCxwLGgsQyxULFUsRyx1ZSk9PihyLl9PcnRSdW49Xy5sYSkobCxwLGgsQyxULFUsRyx1ZSksci5fT3J0RW5kUHJvZmlsaW5nPWw9PihyLl9PcnRFbmRQcm9maWxpbmc9Xy5tYSkobCksci5fSnNlcE91dHB1dD0obCxwLGgpPT4oci5fSnNlcE91dHB1dD1fLm5hKShsLHAsaCksci5fSnNlcEdldE5vZGVOYW1lPWw9PihyLl9Kc2VwR2V0Tm9kZU5hbWU9Xy5vYSkobCk7dmFyIFJ0PXIuX21hbGxvYz1sPT4oUnQ9ci5fbWFsbG9jPV8ucGEpKGwpLFV0PXIuX2ZyZWU9bD0+KFV0PXIuX2ZyZWU9Xy5xYSkobCksTHQ9bD0+KEx0PV8uc2EpKGwpLEZ0PSgpPT4oRnQ9Xy50YSkoKSxIdD1sPT4oSHQ9Xy51YSkobCksanQ9bD0+KGp0PV8udmEpKGwpLEt0PWw9PihLdD1fLnhhKShsKSxxdD0oKT0+KHF0PV8ueWEpKCksUHQ9bD0+KFB0PV8uemEpKGwpLCR0PSgpPT4oJHQ9Xy5BYSkoKTtyLl9fX3N0YXJ0X2VtX2pzPTkyNDU4NyxyLl9fX3N0b3BfZW1fanM9OTI0NzQ4O2Z1bmN0aW9uIHB0KGwpe2w9T2JqZWN0LmFzc2lnbih7fSxsKTt2YXIgcD1DPT4oKT0+QygpPj4+MCxoPUM9PlQ9PkMoVCk+Pj4wO3JldHVybiBsLl9fZXJybm9fbG9jYXRpb249cChsLl9fZXJybm9fbG9jYXRpb24pLGwubWFsbG9jPWgobC5tYWxsb2MpLGwuc3RhY2tTYXZlPXAobC5zdGFja1NhdmUpLGwuc3RhY2tBbGxvYz1oKGwuc3RhY2tBbGxvYyksbH1yLnN0YWNrQWxsb2M9anQsci5zdGFja1NhdmU9RnQsci5zdGFja1Jlc3RvcmU9SHQsci5VVEY4VG9TdHJpbmc9X2Usci5zdHJpbmdUb1VURjg9KGwscCxoKT0+RHQobCxsZSxwLGgpLHIubGVuZ3RoQnl0ZXNVVEY4PUl0O3ZhciB4dDtOZT1mdW5jdGlvbiBsKCl7eHR8fFl0KCkseHR8fChOZT1sKX07ZnVuY3Rpb24gWXQoKXtmdW5jdGlvbiBsKCl7aWYoIXh0JiYoeHQ9ITAsci5jYWxsZWRSdW49ITAsIXopKXtpZih5dChTZSksbyhyKSxyLm9uUnVudGltZUluaXRpYWxpemVkJiZyLm9uUnVudGltZUluaXRpYWxpemVkKCksci5wb3N0UnVuKWZvcih0eXBlb2Ygci5wb3N0UnVuPT1cImZ1bmN0aW9uXCImJihyLnBvc3RSdW49W3IucG9zdFJ1bl0pO3IucG9zdFJ1bi5sZW5ndGg7KXt2YXIgcD1yLnBvc3RSdW4uc2hpZnQoKTtPZS51bnNoaWZ0KHApfXl0KE9lKX19aWYoISgwPENlKSl7aWYoci5wcmVSdW4pZm9yKHR5cGVvZiByLnByZVJ1bj09XCJmdW5jdGlvblwiJiYoci5wcmVSdW49W3IucHJlUnVuXSk7ci5wcmVSdW4ubGVuZ3RoOylJZSgpO3l0KGopLDA8Q2V8fChyLnNldFN0YXR1cz8oci5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ci5zZXRTdGF0dXMoXCJcIil9LDEpLGwoKX0sMSkpOmwoKSl9fWlmKHIucHJlSW5pdClmb3IodHlwZW9mIHIucHJlSW5pdD09XCJmdW5jdGlvblwiJiYoci5wcmVJbml0PVtyLnByZUluaXRdKTswPHIucHJlSW5pdC5sZW5ndGg7KXIucHJlSW5pdC5wb3AoKSgpO3JldHVybiBZdCgpLHQucmVhZHl9fSkoKTt0eXBlb2Ygc289PVwib2JqZWN0XCImJnR5cGVvZiBkbj09XCJvYmplY3RcIj9kbi5leHBvcnRzPWlvOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCYmZGVmaW5lKFtdLCgpPT5pbyl9KTt2YXIgbG89SnQoKCk9Pnt9KTt2YXIgY289SnQoKCk9Pnt9KTt2YXIgcG89e307SXIocG8se2NwdXM6KCk9Pk91fSk7dmFyIE91LGZvPUgoKCk9PntPdT12b2lkIDB9KTt2YXIgZ289SnQoKGhvLGNuKT0+e1widXNlIHN0cmljdFwiO3ZhciBtbz0oKCk9Pnt2YXIgZT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKGU9ZXx8X19maWxlbmFtZSksZnVuY3Rpb24odD17fSl7ZnVuY3Rpb24gcigpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxDZX1mdW5jdGlvbiBvKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLGR0fWZ1bmN0aW9uIG4oKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksTmV9ZnVuY3Rpb24gcygpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxMZX1mdW5jdGlvbiB1KCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLE59ZnVuY3Rpb24gZCgpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxkZX12YXIgYT10LG0sZzthLnJlYWR5PW5ldyBQcm9taXNlKChpLGMpPT57bT1pLGc9Y30pLGEuanNlcEluaXQ9KGksYyxmLCQsSSxQLFYsb2UpPT57YS5RYj1pLGEud2I9YyxhLnliPWYsYS5qYj0kLGEueGI9SSxhLkVhPVAsYS56Yj1WLGEuQWI9b2UsYz0oZWUsWixyZSk9PiguLi5oZSk9PntsZXQgYmU9WmUsTz1aPy4oKTtoZT1lZSguLi5oZSk7bGV0IHNlPVo/LigpO3JldHVybiBPIT09c2UmJihlZT1zZSxyZShPKSxaPXJlPW51bGwpLFplIT1iZT9odSgpOmhlfSxmPWVlPT5hc3luYyguLi5aKT0+e3RyeXtpZihhLmJiKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7bGV0IHJlPWEuYmI9e0ZiOlpbMF0sZXJyb3JzOltdfSxoZT1hd2FpdCBlZSguLi5aKTtpZihhLmJiIT09cmUpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO2kuZmx1c2goKTtsZXQgYmU9cmUuZXJyb3JzO2lmKDA8YmUubGVuZ3RoKXtsZXQgTz1hd2FpdCBQcm9taXNlLmFsbChiZSk7aWYoTz1PLmZpbHRlcihzZT0+c2UpLDA8Ty5sZW5ndGgpdGhyb3cgRXJyb3IoTy5qb2luKGBcXG5gKSl9cmV0dXJuIGhlfWZpbmFsbHl7YS5iYj1udWxsfX0sYS5fT3J0UnVuPWYoYyhhLl9PcnRSdW4sKCk9PmEuX09ydFJ1bixlZT0+YS5fT3J0UnVuPWVlKSksYS5fT3J0UnVuV2l0aEJpbmRpbmc9ZihjKGEuX09ydFJ1bldpdGhCaW5kaW5nLCgpPT5hLl9PcnRSdW5XaXRoQmluZGluZyxlZT0+YS5fT3J0UnVuV2l0aEJpbmRpbmc9ZWUpKSxhLl9PcnRCaW5kSW5wdXQ9YyhhLl9PcnRCaW5kSW5wdXQsKCk9PmEuX09ydEJpbmRJbnB1dCxlZT0+YS5fT3J0QmluZElucHV0PWVlKSxhLmpzZXBSZWdpc3RlckJ1ZmZlcj0oZWUsWixyZSxoZSk9PmkucmVnaXN0ZXJCdWZmZXIoZWUsWixyZSxoZSksYS5qc2VwVW5yZWdpc3RlckJ1ZmZlcnM9ZWU9PntpLnVucmVnaXN0ZXJCdWZmZXJzKGVlKX0sYS5qc2VwR2V0QnVmZmVyPWVlPT5pLmdldEJ1ZmZlcihlZSksYS5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oZWUsWixyZSk9PmkuY3JlYXRlRG93bmxvYWRlcihlZSxaLHJlKX07dmFyIHg9T2JqZWN0LmFzc2lnbih7fSxhKSxiPVwiLi90aGlzLnByb2dyYW1cIix3PShpLGMpPT57dGhyb3cgY30sdj10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLHk9dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixTPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIixBPWEuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsUj1cIlwiO2Z1bmN0aW9uIFcoaSl7cmV0dXJuIGEubG9jYXRlRmlsZT9hLmxvY2F0ZUZpbGUoaSxSKTpSK2l9dmFyIE0sRCxfO2lmKFMpe3ZhciB6PShzbigpLE10KGFuKSksRj0obG4oKSxNdCh1bikpO1I9eT9GLmRpcm5hbWUoUikrXCIvXCI6X19kaXJuYW1lK1wiL1wiLE09KGMsZik9PihjPWMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChjKTpGLm5vcm1hbGl6ZShjKSx6LnJlYWRGaWxlU3luYyhjLGY/dm9pZCAwOlwidXRmOFwiKSksXz1jPT4oYz1NKGMsITApLGMuYnVmZmVyfHwoYz1uZXcgVWludDhBcnJheShjKSksYyksRD0oYyxmLCQsST0hMCk9PntjPWMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChjKTpGLm5vcm1hbGl6ZShjKSx6LnJlYWRGaWxlKGMsST92b2lkIDA6XCJ1dGY4XCIsKFAsVik9PntQPyQoUCk6ZihJP1YuYnVmZmVyOlYpfSl9LCFhLnRoaXNQcm9ncmFtJiYxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihiPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHc9KGMsZik9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWMsZn0sYS5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7bGV0IGk7dHJ5e2k9bG8oKX1jYXRjaChjKXt0aHJvdyBjb25zb2xlLmVycm9yKFxcJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkP1xcJyksY31nbG9iYWwuV29ya2VyPWkuV29ya2VyfWVsc2Uodnx8eSkmJih5P1I9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKFI9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLHR5cGVvZiBlPFwidVwiJiZlJiYoUj1lKSxSLmluZGV4T2YoXCJibG9iOlwiKSE9PTA/Uj1SLnN1YnN0cigwLFIucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6Uj1cIlwiLFN8fChNPWk9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLGksITEpLGMuc2VuZChudWxsKSxjLnJlc3BvbnNlVGV4dH0seSYmKF89aT0+e3ZhciBjPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYy5vcGVuKFwiR0VUXCIsaSwhMSksYy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGMuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShjLnJlc3BvbnNlKX0pLEQ9KGksYyxmKT0+e3ZhciAkPW5ldyBYTUxIdHRwUmVxdWVzdDskLm9wZW4oXCJHRVRcIixpLCEwKSwkLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsJC5vbmxvYWQ9KCk9PnskLnN0YXR1cz09MjAwfHwkLnN0YXR1cz09MCYmJC5yZXNwb25zZT9jKCQucmVzcG9uc2UpOmYoKX0sJC5vbmVycm9yPWYsJC5zZW5kKG51bGwpfSkpO1MmJnR5cGVvZiBwZXJmb3JtYW5jZT5cInVcIiYmKGdsb2JhbC5wZXJmb3JtYW5jZT1jbygpLnBlcmZvcm1hbmNlKTt2YXIgcT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLGxlPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtTJiYocT0oLi4uaSk9Pnoud3JpdGVTeW5jKDEsaS5qb2luKFwiIFwiKStgXFxuYCksbGU9KC4uLmkpPT56LndyaXRlU3luYygyLGkuam9pbihcIiBcIikrYFxcbmApKTt2YXIgQj1hLnByaW50fHxxLEs9YS5wcmludEVycnx8bGU7T2JqZWN0LmFzc2lnbihhLHgpLHg9bnVsbCxhLnRoaXNQcm9ncmFtJiYoYj1hLnRoaXNQcm9ncmFtKSxhLnF1aXQmJih3PWEucXVpdCk7dmFyIHhlO2Eud2FzbUJpbmFyeSYmKHhlPWEud2FzbUJpbmFyeSk7dmFyIGFlPWEubm9FeGl0UnVudGltZXx8ITA7dHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZLZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIHdlLGosU2UsT2U9ITEsSWUsQ2UsZHQsTmUsTGUsTixkZTtmdW5jdGlvbiBwZSgpe3ZhciBpPXdlLmJ1ZmZlcjthLkhFQVA4PUNlPW5ldyBJbnQ4QXJyYXkoaSksYS5IRUFQMTY9bmV3IEludDE2QXJyYXkoaSksYS5IRUFQMzI9TmU9bmV3IEludDMyQXJyYXkoaSksYS5IRUFQVTg9ZHQ9bmV3IFVpbnQ4QXJyYXkoaSksYS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShpKSxhLkhFQVBVMzI9TGU9bmV3IFVpbnQzMkFycmF5KGkpLGEuSEVBUEYzMj1OPW5ldyBGbG9hdDMyQXJyYXkoaSksYS5IRUFQRjY0PWRlPW5ldyBGbG9hdDY0QXJyYXkoaSl9dmFyIHplPWEuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKDUyNDI4ODA8PXplfHxLZShcIklOSVRJQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBTVEFDS19TSVpFLCB3YXMgXCIremUrXCIhIChTVEFDS19TSVpFPTUyNDI4ODApXCIpLEEpd2U9YS53YXNtTWVtb3J5O2Vsc2UgaWYoYS53YXNtTWVtb3J5KXdlPWEud2FzbU1lbW9yeTtlbHNlIGlmKHdlPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6emUvNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSwhKHdlLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBLKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLFMmJksoXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZC9vciByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO3BlKCksemU9d2UuYnVmZmVyLmJ5dGVMZW5ndGg7dmFyIFVlPVtdLFRlPVtdLGtlPVtdLEdlPTA7ZnVuY3Rpb24gWGUoKXtyZXR1cm4gYWV8fDA8R2V9dmFyIEZlPTAseXQ9bnVsbCxidD1udWxsO2Z1bmN0aW9uIEJ0KCl7RmUrKyxhLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhGZSl9ZnVuY3Rpb24gbHIoKXtpZihGZS0tLGEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmYS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEZlKSxGZT09MCYmKHl0IT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoeXQpLHl0PW51bGwpLGJ0KSl7dmFyIGk9YnQ7YnQ9bnVsbCxpKCl9fWZ1bmN0aW9uIEtlKGkpe3Rocm93IGEub25BYm9ydCYmYS5vbkFib3J0KGkpLGk9XCJBYm9ydGVkKFwiK2krXCIpXCIsSyhpKSxPZT0hMCxJZT0xLGk9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihpK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxnKGkpLGl9ZnVuY3Rpb24ga3QoaSl7cmV0dXJuIGkuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9dmFyIF9lO19lPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCIsa3QoX2UpfHwoX2U9VyhfZSkpO2Z1bmN0aW9uIEl0KGkpe2lmKGk9PV9lJiZ4ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGUpO2lmKF8pcmV0dXJuIF8oaSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gRHQoaSl7aWYoIXhlJiYodnx8eSkpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYhaS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goaSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihjPT57aWYoIWMub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIraStcIlxcJ1wiO3JldHVybiBjLmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+SXQoaSkpO2lmKEQpcmV0dXJuIG5ldyBQcm9taXNlKChjLGYpPT57RChpLCQ9PmMobmV3IFVpbnQ4QXJyYXkoJCkpLGYpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pkl0KGkpKX1mdW5jdGlvbiBhdChpLGMsZil7cmV0dXJuIER0KGkpLnRoZW4oJD0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoJCxjKSkudGhlbigkPT4kKS50aGVuKGYsJD0+e0soXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIiskKSxLZSgkKX0pfWZ1bmN0aW9uIGRyKGksYyl7dmFyIGY9X2U7cmV0dXJuIHhlfHx0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8a3QoZil8fGYuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fFN8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP2F0KGYsaSxjKTpmZXRjaChmLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKCQ9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKCQsaSkudGhlbihjLGZ1bmN0aW9uKEkpe3JldHVybiBLKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK0kpLEsoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxhdChmLGksYyl9KSl9dmFyIGl0LEV0PXs5MTQ5ODg6aT0+e2EuRWEoXCJBYnNcIixpLHZvaWQgMCl9LDkxNTAzOTppPT57YS5FYShcIk5lZ1wiLGksdm9pZCAwKX0sOTE1MDkwOmk9PnthLkVhKFwiRmxvb3JcIixpLHZvaWQgMCl9LDkxNTE0MzppPT57YS5FYShcIkNlaWxcIixpLHZvaWQgMCl9LDkxNTE5NTppPT57YS5FYShcIlJlY2lwcm9jYWxcIixpLHZvaWQgMCl9LDkxNTI1MzppPT57YS5FYShcIlNxcnRcIixpLHZvaWQgMCl9LDkxNTMwNTppPT57YS5FYShcIkV4cFwiLGksdm9pZCAwKX0sOTE1MzU2Omk9PnthLkVhKFwiRXJmXCIsaSx2b2lkIDApfSw5MTU0MDc6aT0+e2EuRWEoXCJTaWdtb2lkXCIsaSx2b2lkIDApfSw5MTU0NjI6aT0+e2EuRWEoXCJMb2dcIixpLHZvaWQgMCl9LDkxNTUxMzppPT57YS5FYShcIlNpblwiLGksdm9pZCAwKX0sOTE1NTY0Omk9PnthLkVhKFwiQ29zXCIsaSx2b2lkIDApfSw5MTU2MTU6aT0+e2EuRWEoXCJUYW5cIixpLHZvaWQgMCl9LDkxNTY2NjppPT57YS5FYShcIkFzaW5cIixpLHZvaWQgMCl9LDkxNTcxODppPT57YS5FYShcIkFjb3NcIixpLHZvaWQgMCl9LDkxNTc3MDppPT57YS5FYShcIkF0YW5cIixpLHZvaWQgMCl9LDkxNTgyMjppPT57YS5FYShcIlNpbmhcIixpLHZvaWQgMCl9LDkxNTg3NDppPT57YS5FYShcIkNvc2hcIixpLHZvaWQgMCl9LDkxNTkyNjppPT57YS5FYShcIkFzaW5oXCIsaSx2b2lkIDApfSw5MTU5Nzk6aT0+e2EuRWEoXCJBY29zaFwiLGksdm9pZCAwKX0sOTE2MDMyOmk9PnthLkVhKFwiQXRhbmhcIixpLHZvaWQgMCl9LDkxNjA4NTppPT57YS5FYShcIlRhbmhcIixpLHZvaWQgMCl9LDkxNjEzNzppPT57YS5FYShcIk5vdFwiLGksdm9pZCAwKX0sOTE2MTg4OihpLGMsZik9PnthLkVhKFwiQ2xpcFYxMFwiLGkse21pbjpjLG1heDpmfSl9LDkxNjI2MDppPT57YS5FYShcIkNsaXBcIixpLHZvaWQgMCl9LDkxNjMxMjooaSxjKT0+e2EuRWEoXCJFbHVcIixpLHthbHBoYTpjfSl9LDkxNjM3MDppPT57YS5FYShcIlJlbHVcIixpLHZvaWQgMCl9LDkxNjQyMjooaSxjKT0+e2EuRWEoXCJMZWFreVJlbHVcIixpLHthbHBoYTpjfSl9LDkxNjQ4NjooaSxjKT0+e2EuRWEoXCJUaHJlc2hvbGRlZFJlbHVcIixpLHthbHBoYTpjfSl9LDkxNjU1NjooaSxjKT0+e2EuRWEoXCJDYXN0XCIsaSx7dG86Y30pfSw5MTY2MTQ6aT0+e2EuRWEoXCJBZGRcIixpLHZvaWQgMCl9LDkxNjY2NTppPT57YS5FYShcIlN1YlwiLGksdm9pZCAwKX0sOTE2NzE2Omk9PnthLkVhKFwiTXVsXCIsaSx2b2lkIDApfSw5MTY3Njc6aT0+e2EuRWEoXCJEaXZcIixpLHZvaWQgMCl9LDkxNjgxODppPT57YS5FYShcIlBvd1wiLGksdm9pZCAwKX0sOTE2ODY5Omk9PnthLkVhKFwiRXF1YWxcIixpLHZvaWQgMCl9LDkxNjkyMjppPT57YS5FYShcIkdyZWF0ZXJcIixpLHZvaWQgMCl9LDkxNjk3NzppPT57YS5FYShcIkdyZWF0ZXJPckVxdWFsXCIsaSx2b2lkIDApfSw5MTcwMzk6aT0+e2EuRWEoXCJMZXNzXCIsaSx2b2lkIDApfSw5MTcwOTE6aT0+e2EuRWEoXCJMZXNzT3JFcXVhbFwiLGksdm9pZCAwKX0sOTE3MTUwOihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZU1lYW5cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE3MzE0OihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZU1heFwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTc0Nzc6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlTWluXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxNzY0MDooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VQcm9kXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxNzgwNDooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VTdW1cIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE3OTY3OihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZUwxXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxODEyOTooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VMMlwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTgyOTE6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlTG9nU3VtXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxODQ1NzooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VTdW1TcXVhcmVcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE4NjI2OihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZUxvZ1N1bUV4cFwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTg3OTU6aT0+e2EuRWEoXCJXaGVyZVwiLGksdm9pZCAwKX0sOTE4ODQ4OihpLGMsZik9PnthLkVhKFwiVHJhbnNwb3NlXCIsaSx7cGVybTpjP0FycmF5LmZyb20obigpLnN1YmFycmF5KGY+Pj4wLGYrYz4+PjApKTpbXX0pfSw5MTg5NjE6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPLHNlKT0+e2EuRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OmVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6W2ZdLGdyb3VwOiQsa2VybmVsX3NoYXBlOltJXSxwYWRzOltQLFZdLHN0cmlkZXM6W29lXSx3SXNDb25zdDooKT0+ISFyKClbWj4+PjBdLG91dHB1dFBhZGRpbmc6cmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaGU+Pj4wLGhlK3JlPj4+MCkpOltdLG91dHB1dFNoYXBlOmJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KE8+Pj4wLE8rYmU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShzZSl9KX0sOTE5Mzc1OihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyk9PnthLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDpvZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20obigpLnN1YmFycmF5KGY+Pj4wLGYrMj4+PjApKSxncm91cDokLGtlcm5lbFNoYXBlOkFycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrMj4+PjApKSxwYWRzOkFycmF5LmZyb20obigpLnN1YmFycmF5KFA+Pj4wLFArND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20obigpLnN1YmFycmF5KFY+Pj4wLFYrMj4+PjApKSx3SXNDb25zdDooKT0+ISFyKClbZWU+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8Wj9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShyZT4+PjAscmUrWj4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGhlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGJlPj4+MCxiZStoZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKE8pfSl9LDkxOTkzMjooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8sc2UpPT57YS5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6ZWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6JCxrZXJuZWxfc2hhcGU6W0ldLHBhZHM6W1AsVl0sc3RyaWRlczpbb2VdLHdJc0NvbnN0OigpPT4hIXIoKVtaPj4+MF0sb3V0cHV0UGFkZGluZzpyZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShoZT4+PjAsaGUrcmU+Pj4wKSk6W10sb3V0cHV0U2hhcGU6YmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTz4+PjAsTytiZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKHNlKX0pfSw5MjAzNDY6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPKT0+e2EuRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0Om9lP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoZj4+PjAsZisyPj4+MCkpLGdyb3VwOiQsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoUD4+PjAsUCs0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoVj4+PjAsVisyPj4+MCkpLHdJc0NvbnN0OigpPT4hIXIoKVtlZT4+PjBdLG91dHB1dFBhZGRpbmc6MDxaP0FycmF5LmZyb20obigpLnN1YmFycmF5KHJlPj4+MCxyZStaPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8aGU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoYmU+Pj4wLGJlK2hlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoTyl9KX0sOTIwOTAzOihpLGMpPT57YS5FYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwOTk0OihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyxzZSx5ZSk9PnthLkVhKFwiQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDokLHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W1AsVl0sa2VybmVsX3NoYXBlOltvZSxlZV0scGFkczpbWixyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIxMjc4OihpLGMpPT57YS5FYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIxMzY5OihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyxzZSx5ZSk9PnthLkVhKFwiQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDokLHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W1AsVl0sa2VybmVsX3NoYXBlOltvZSxlZV0scGFkczpbWixyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIxNjUzOihpLGMpPT57YS5FYShcIkdsb2JhbE1heFBvb2xcIixpLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjE3NDA6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPLHNlLHllKT0+e2EuRWEoXCJNYXhQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6JCxzdG9yYWdlX29yZGVyOkksZGlsYXRpb25zOltQLFZdLGtlcm5lbF9zaGFwZTpbb2UsZWVdLHBhZHM6W1oscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMjAyMDooaSxjKT0+e2EuRWEoXCJHbG9iYWxNYXhQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyMTA3OihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyxzZSx5ZSk9PnthLkVhKFwiTWF4UG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOiQsc3RvcmFnZV9vcmRlcjpJLGRpbGF0aW9uczpbUCxWXSxrZXJuZWxfc2hhcGU6W29lLGVlXSxwYWRzOltaLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjIzODc6KGksYyxmLCQsSSk9PnthLkVhKFwiR2VtbVwiLGkse2FscGhhOmMsYmV0YTpmLHRyYW5zQTokLHRyYW5zQjpJfSl9LDkyMjQ5MTppPT57YS5FYShcIk1hdE11bFwiLGksdm9pZCAwKX0sOTIyNTQ1OihpLGMsZiwkKT0+e2EuRWEoXCJBcmdNYXhcIixpLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOiR9KX0sOTIyNjUzOihpLGMsZiwkKT0+e2EuRWEoXCJBcmdNaW5cIixpLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOiR9KX0sOTIyNzYxOihpLGMpPT57YS5FYShcIlNvZnRtYXhcIixpLHtheGlzOmN9KX0sOTIyODI0OihpLGMpPT57YS5FYShcIkNvbmNhdFwiLGkse2F4aXM6Y30pfSw5MjI4ODQ6KGksYyxmLCQsSSk9PnthLkVhKFwiU3BsaXRcIixpLHtheGlzOmMsbnVtT3V0cHV0czpmLHNwbGl0U2l6ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTIzMDI5Omk9PnthLkVhKFwiRXhwYW5kXCIsaSx2b2lkIDApfSw5MjMwODM6KGksYyk9PnthLkVhKFwiR2F0aGVyXCIsaSx7YXhpczpOdW1iZXIoYyl9KX0sOTIzMTU0OihpLGMpPT57YS5FYShcIkdhdGhlckVsZW1lbnRzXCIsaSx7YXhpczpOdW1iZXIoYyl9KX0sOTIzMjMzOihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUpPT57YS5FYShcIlJlc2l6ZVwiLGkse2FudGlhbGlhczpjLGF4ZXM6Zj9BcnJheS5mcm9tKG4oKS5zdWJhcnJheSgkPj4+MCwkK2Y+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6VmUoSSksY3ViaWNDb2VmZkE6UCxleGNsdWRlT3V0c2lkZTpWLGV4dHJhcG9sYXRpb25WYWx1ZTpvZSxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6VmUoZWUpLG1vZGU6VmUoWiksbmVhcmVzdE1vZGU6VmUocmUpfSl9LDkyMzU4NDooaSxjLGYsJCxJLFAsVik9PnthLkVhKFwiU2xpY2VcIixpLHtzdGFydHM6Yz9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShmPj4+MCxmK2M+Pj4wKSk6W10sZW5kczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXSxheGVzOlA/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoVj4+PjAsVitQPj4+MCkpOltdfSl9LDkyMzgxNTppPT57YS5FYShcIlRpbGVcIixpLHZvaWQgMCl9LDkyMzg2NzooaSxjLGYpPT57YS5FYShcIkxheWVyTm9ybWFsaXphdGlvblwiLGkse2F4aXM6TnVtYmVyKGMpLGVwc2lsb246TnVtYmVyKGYpfSl9LDkyMzk3NDooaSxjLGYpPT57YS5FYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246Yyxmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjQwODg6KGksYyxmKT0+e2EuRWEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOmMsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI0MjAyOmk9PnthLkVhKFwiUmFuZ2VcIixpLHZvaWQgMCl9LDkyNDI1NTooaSxjKT0+e2EuRWEoXCJFaW5zdW1cIixpLHtlcXVhdGlvbjpWZShjKX0pfSw5MjQzMzY6KGksYyxmLCQsSSk9PnthLkVhKFwiUGFkXCIsaSx7bW9kZTpjLHZhbHVlOmYscGFkczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MjQ0Njg6aT0+e2EuRWEoXCJHZWx1XCIsaSx2b2lkIDApfSw5MjQ1MjA6aT0+e2EuRWEoXCJCaWFzQWRkXCIsaSx2b2lkIDApfSw5MjQ1NzU6aT0+e2EuRWEoXCJCaWFzU3BsaXRHZWx1XCIsaSx2b2lkIDApfSw5MjQ2MzY6KGksYyk9PnthLkVhKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246Y30pfSw5MjQ3MTc6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSk9PnthLkVhKFwiQ29udlwiLGkse2Zvcm1hdDplZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6JCxrZXJuZWxfc2hhcGU6W0ldLHBhZHM6UD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShWPj4+MCxWK1A+Pj4wKSk6W10sc3RyaWRlczpbb2VdLHdfaXNfY29uc3Q6KCk9PiEhcigpW1o+Pj4wXSxhY3RpdmF0aW9uOlZlKHJlKSxhY3RpdmF0aW9uX3BhcmFtczpoZT9BcnJheS5mcm9tKHUoKS5zdWJhcnJheShiZT4+PjAsYmUraGU+Pj4wKSk6W119KX0sOTI1MDk4OihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyxzZSx5ZSk9PnthLkVhKFwiQ29udlwiLGkse2Zvcm1hdDpoZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGRpbGF0aW9uczpbZiwkXSxncm91cDpJLGtlcm5lbF9zaGFwZTpbUCxWXSxwYWRzOm9lP0FycmF5LmZyb20obigpLnN1YmFycmF5KGVlPj4+MCxlZStvZT4+PjApKTpbXSxzdHJpZGVzOltaLHJlXSx3X2lzX2NvbnN0OigpPT4hIXIoKVtiZT4+PjBdLGFjdGl2YXRpb246VmUoTyksYWN0aXZhdGlvbl9wYXJhbXM6c2U/QXJyYXkuZnJvbSh1KCkuc3ViYXJyYXkoeWU+Pj4wLHllK3NlPj4+MCkpOltdfSl9LDkyNTUwMDppPT57YS56YihpKX0sOTI1NTM0OihpLGMpPT5hLkFiKGksYyxhLmJiLkZiLGEuYmIuZXJyb3JzKSw5MjU2NDY6aT0+YS53YihpKSw5MjU2Nzk6aT0+YS55YihpKSw5MjU3MTE6KGksYyxmKT0+e2EuamIoaSxjLGYsITApfSw5MjU3NTA6KGksYyxmKT0+e2EuamIoaSxjLGYpfX07ZnVuY3Rpb24gY3QoaSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2l9KWAsdGhpcy5zdGF0dXM9aX1mdW5jdGlvbiBUdChpKXtpLnRlcm1pbmF0ZSgpLGkub25tZXNzYWdlPSgpPT57fX1mdW5jdGlvbiBPdChpKXsoaT1uZS5RYVtpXSl8fEtlKCksbmUuRWIoaSl9ZnVuY3Rpb24gV3QoaSl7dmFyIGM9bmUudGIoKTtpZighYylyZXR1cm4gNjtuZS5ZYS5wdXNoKGMpLG5lLlFhW2kuWGFdPWMsYy5YYT1pLlhhO3ZhciBmPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOmkuR2IsYXJnOmkucmIscHRocmVhZF9wdHI6aS5YYX07cmV0dXJuIFMmJmMudW5yZWYoKSxjLnBvc3RNZXNzYWdlKGYsaS5NYiksMH12YXIgX3Q9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLGNyPShpLGMsZik9PntjPj4+PTA7dmFyICQ9YytmO2ZvcihmPWM7aVtmXSYmIShmPj0kKTspKytmO2lmKDE2PGYtYyYmaS5idWZmZXImJl90KXJldHVybiBfdC5kZWNvZGUoaS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj9pLnNsaWNlKGMsZik6aS5zdWJhcnJheShjLGYpKTtmb3IoJD1cIlwiO2M8Zjspe3ZhciBJPWlbYysrXTtpZihJJjEyOCl7dmFyIFA9aVtjKytdJjYzO2lmKChJJjIyNCk9PTE5MikkKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChJJjMxKTw8NnxQKTtlbHNle3ZhciBWPWlbYysrXSY2MztJPShJJjI0MCk9PTIyND8oSSYxNSk8PDEyfFA8PDZ8VjooSSY3KTw8MTh8UDw8MTJ8Vjw8NnxpW2MrK10mNjMsNjU1MzY+ST8kKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEkpOihJLT02NTUzNiwkKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fEk+PjEwLDU2MzIwfEkmMTAyMykpfX1lbHNlICQrPVN0cmluZy5mcm9tQ2hhckNvZGUoSSl9cmV0dXJuICR9LFZlPShpLGMpPT4oaT4+Pj0wKT9jcihvKCksaSxjKTpcIlwiO2Z1bmN0aW9uIHp0KGkpe2lmKEEpcmV0dXJuIEcoMSwxLGkpO0llPWksWGUoKXx8KG5lLkhiKCksYS5vbkV4aXQmJmEub25FeGl0KGkpLE9lPSEwKSx3KGksbmV3IGN0KGkpKX12YXIgVnQ9aT0+e2lmKEllPWksQSl0aHJvdyBwcihpKSxcInVud2luZFwiO3p0KGkpfSxuZT17YWI6W10sWWE6W10sbWI6W10sUWE6e30sZ2I6ZnVuY3Rpb24oKXtBP25lLnZiKCk6bmUudWIoKX0sdWI6ZnVuY3Rpb24oKXtVZS51bnNoaWZ0KCgpPT57QnQoKSxuZS5CYigoKT0+bHIoKSl9KX0sdmI6ZnVuY3Rpb24oKXtuZS5yZWNlaXZlT2JqZWN0VHJhbnNmZXI9bmUuRGIsbmUudGhyZWFkSW5pdFRMUz1uZS5sYixuZS5zZXRFeGl0U3RhdHVzPW5lLmtiLGFlPSExfSxrYjpmdW5jdGlvbihpKXtJZT1pfSxTYjpbXCIkdGVybWluYXRlV29ya2VyXCJdLEhiOmZ1bmN0aW9uKCl7Zm9yKHZhciBpIG9mIG5lLllhKVR0KGkpO2ZvcihpIG9mIG5lLmFiKVR0KGkpO25lLmFiPVtdLG5lLllhPVtdLG5lLlFhPVtdfSxFYjpmdW5jdGlvbihpKXt2YXIgYz1pLlhhO2RlbGV0ZSBuZS5RYVtjXSxuZS5hYi5wdXNoKGkpLG5lLllhLnNwbGljZShuZS5ZYS5pbmRleE9mKGkpLDEpLGkuWGE9MCxlbihjKX0sRGI6ZnVuY3Rpb24oKXt9LGxiOmZ1bmN0aW9uKCl7bmUubWIuZm9yRWFjaChpPT5pKCkpfSxDYjppPT5uZXcgUHJvbWlzZShjPT57aS5vbm1lc3NhZ2U9UD0+e1A9UC5kYXRhO3ZhciBWPVAuY21kO2lmKFAudGFyZ2V0VGhyZWFkJiZQLnRhcmdldFRocmVhZCE9U3IoKSl7dmFyIG9lPW5lLlFhW1AuUmJdO29lP29lLnBvc3RNZXNzYWdlKFAsUC50cmFuc2Zlckxpc3QpOksoXFwnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIlxcJytWK1xcJ1wiIHRvIHRhcmdldCBwdGhyZWFkIFxcJytQLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2UgVj09PVwiY2hlY2tNYWlsYm94XCI/JHQoKTpWPT09XCJzcGF3blRocmVhZFwiP1d0KFApOlY9PT1cImNsZWFudXBUaHJlYWRcIj9PdChQLnRocmVhZCk6Vj09PVwia2lsbFRocmVhZFwiPyhQPVAudGhyZWFkLFY9bmUuUWFbUF0sZGVsZXRlIG5lLlFhW1BdLFR0KFYpLGVuKFApLG5lLllhLnNwbGljZShuZS5ZYS5pbmRleE9mKFYpLDEpLFYuWGE9MCk6Vj09PVwiY2FuY2VsVGhyZWFkXCI/bmUuUWFbUC50aHJlYWRdLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pOlY9PT1cImxvYWRlZFwiPyhpLmxvYWRlZD0hMCxjKGkpKTpWPT09XCJhbGVydFwiP2FsZXJ0KFwiVGhyZWFkIFwiK1AudGhyZWFkSWQrXCI6IFwiK1AudGV4dCk6UC50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiP2kucG9zdE1lc3NhZ2UoUCk6Vj09PVwiY2FsbEhhbmRsZXJcIj9hW1AuaGFuZGxlcl0oLi4uUC5hcmdzKTpWJiZLKFwid29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kIFwiK1YpfSxpLm9uZXJyb3I9UD0+e3Rocm93IEsoXCJ3b3JrZXIgc2VudCBhbiBlcnJvciEgXCIrUC5maWxlbmFtZStcIjpcIitQLmxpbmVubytcIjogXCIrUC5tZXNzYWdlKSxQfSxTJiYoaS5vbihcIm1lc3NhZ2VcIixmdW5jdGlvbihQKXtpLm9ubWVzc2FnZSh7ZGF0YTpQfSl9KSxpLm9uKFwiZXJyb3JcIixmdW5jdGlvbihQKXtpLm9uZXJyb3IoUCl9KSk7dmFyIGY9W10sJD1bXCJvbkV4aXRcIixcIm9uQWJvcnRcIixcInByaW50XCIsXCJwcmludEVyclwiXSxJO2ZvcihJIG9mICQpYS5oYXNPd25Qcm9wZXJ0eShJKSYmZi5wdXNoKEkpO2kucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIixoYW5kbGVyczpmLHVybE9yQmxvYjphLm1haW5TY3JpcHRVcmxPckJsb2J8fGUsd2FzbU1lbW9yeTp3ZSx3YXNtTW9kdWxlOlNlfSl9KSxCYjpmdW5jdGlvbihpKXtpKCl9LHFiOmZ1bmN0aW9uKCl7dmFyIGk9VyhcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud29ya2VyLmpzXCIpO2k9bmV3IFdvcmtlcihpKSxuZS5hYi5wdXNoKGkpfSx0YjpmdW5jdGlvbigpe3JldHVybiBuZS5hYi5sZW5ndGg9PTAmJihuZS5xYigpLG5lLkNiKG5lLmFiWzBdKSksbmUuYWIucG9wKCl9fTthLlBUaHJlYWQ9bmU7dmFyIHN0PWk9Pntmb3IoOzA8aS5sZW5ndGg7KWkuc2hpZnQoKShhKX07YS5lc3RhYmxpc2hTdGFja1NwYWNlPWZ1bmN0aW9uKCl7dmFyIGk9U3IoKSxjPW4oKVtpKzUyPj4yPj4+MF07aT1uKClbaSs1Nj4+Mj4+PjBdLFpuKGMsYy1pKSxDcihjKX07ZnVuY3Rpb24gcHIoaSl7aWYoQSlyZXR1cm4gRygyLDAsaSk7VnQoaSl9YS5pbnZva2VFbnRyeVBvaW50PWZ1bmN0aW9uKGksYyl7aT1Rbi5hcHBseShudWxsLFtpLGNdKSxYZSgpP25lLmtiKGkpOnRuKGkpfTtmdW5jdGlvbiBKZShpKXt0aGlzLmZiPWktMjQsdGhpcy5wYj1mdW5jdGlvbihjKXtzKClbdGhpcy5mYis0Pj4yPj4+MF09Y30sdGhpcy5vYj1mdW5jdGlvbihjKXtzKClbdGhpcy5mYis4Pj4yPj4+MF09Y30sdGhpcy5nYj1mdW5jdGlvbihjLGYpe3RoaXMubmIoKSx0aGlzLnBiKGMpLHRoaXMub2IoZil9LHRoaXMubmI9ZnVuY3Rpb24oKXtzKClbdGhpcy5mYisxNj4+Mj4+PjBdPTB9fXZhciBIZT0wLGZyPTA7ZnVuY3Rpb24gd3QoaSxjLGYsJCl7cmV0dXJuIEE/RygzLDEsaSxjLGYsJCk6R3QoaSxjLGYsJCl9ZnVuY3Rpb24gR3QoaSxjLGYsJCl7aWYoaT4+Pj0wLGM+Pj49MCxmPj4+PTAsJD4+Pj0wLHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4gSyhcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpLDY7dmFyIEk9W107cmV0dXJuIEEmJkkubGVuZ3RoPT09MD93dChpLGMsZiwkKTooaT17R2I6ZixYYTppLHJiOiQsTWI6SX0sQT8oaS5PYj1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2UoaSxJKSwwKTpXdChpKSl9ZnVuY3Rpb24gTnQoaSxjLGYpe3JldHVybiBBP0coNCwxLGksYyxmKTowfWZ1bmN0aW9uIG1yKGksYyl7aWYoQSlyZXR1cm4gRyg1LDEsaSxjKX12YXIgdnQ9aT0+e2Zvcih2YXIgYz0wLGY9MDtmPGkubGVuZ3RoOysrZil7dmFyICQ9aS5jaGFyQ29kZUF0KGYpOzEyNz49JD9jKys6MjA0Nz49JD9jKz0yOjU1Mjk2PD0kJiY1NzM0Mz49JD8oYys9NCwrK2YpOmMrPTN9cmV0dXJuIGN9LGhyPShpLGMsZiwkKT0+e2lmKGY+Pj49MCwhKDA8JCkpcmV0dXJuIDA7dmFyIEk9ZjskPWYrJC0xO2Zvcih2YXIgUD0wO1A8aS5sZW5ndGg7KytQKXt2YXIgVj1pLmNoYXJDb2RlQXQoUCk7aWYoNTUyOTY8PVYmJjU3MzQzPj1WKXt2YXIgb2U9aS5jaGFyQ29kZUF0KCsrUCk7Vj02NTUzNisoKFYmMTAyMyk8PDEwKXxvZSYxMDIzfWlmKDEyNz49Vil7aWYoZj49JClicmVhaztjW2YrKz4+PjBdPVZ9ZWxzZXtpZigyMDQ3Pj1WKXtpZihmKzE+PSQpYnJlYWs7Y1tmKys+Pj4wXT0xOTJ8Vj4+Nn1lbHNle2lmKDY1NTM1Pj1WKXtpZihmKzI+PSQpYnJlYWs7Y1tmKys+Pj4wXT0yMjR8Vj4+MTJ9ZWxzZXtpZihmKzM+PSQpYnJlYWs7Y1tmKys+Pj4wXT0yNDB8Vj4+MTgsY1tmKys+Pj4wXT0xMjh8Vj4+MTImNjN9Y1tmKys+Pj4wXT0xMjh8Vj4+NiY2M31jW2YrKz4+PjBdPTEyOHxWJjYzfX1yZXR1cm4gY1tmPj4+MF09MCxmLUl9LGdyPShpLGMsZik9PmhyKGksbygpLGMsZik7ZnVuY3Rpb24geXIoaSxjKXtpZihBKXJldHVybiBHKDYsMSxpLGMpfWZ1bmN0aW9uIGJyKGksYyxmKXtpZihBKXJldHVybiBHKDcsMSxpLGMsZil9ZnVuY3Rpb24gd3IoaSxjLGYpe3JldHVybiBBP0coOCwxLGksYyxmKTowfWZ1bmN0aW9uIHZyKGksYyl7aWYoQSlyZXR1cm4gRyg5LDEsaSxjKX1mdW5jdGlvbiBSdChpLGMsZil7aWYoQSlyZXR1cm4gRygxMCwxLGksYyxmKX1mdW5jdGlvbiBVdChpLGMsZiwkKXtpZihBKXJldHVybiBHKDExLDEsaSxjLGYsJCl9ZnVuY3Rpb24gTHQoaSxjLGYsJCl7aWYoQSlyZXR1cm4gRygxMiwxLGksYyxmLCQpfWZ1bmN0aW9uIEZ0KGksYyxmLCQpe2lmKEEpcmV0dXJuIEcoMTMsMSxpLGMsZiwkKX1mdW5jdGlvbiBIdChpKXtpZihBKXJldHVybiBHKDE0LDEsaSl9ZnVuY3Rpb24ganQoaSxjKXtpZihBKXJldHVybiBHKDE1LDEsaSxjKX1mdW5jdGlvbiBLdChpLGMsZil7aWYoQSlyZXR1cm4gRygxNiwxLGksYyxmKX12YXIgcXQ9aT0+e2lmKCFPZSl0cnl7aWYoaSgpLCFYZSgpKXRyeXtBP3RuKEllKTpWdChJZSl9Y2F0Y2goYyl7YyBpbnN0YW5jZW9mIGN0fHxjPT1cInVud2luZFwifHx3KDEsYyl9fWNhdGNoKGMpe2MgaW5zdGFuY2VvZiBjdHx8Yz09XCJ1bndpbmRcInx8dygxLGMpfX07ZnVuY3Rpb24gUHQoaSl7aT4+Pj0wLHR5cGVvZiBBdG9taWNzLk5iPT1cImZ1bmN0aW9uXCImJihBdG9taWNzLk5iKG4oKSxpPj4yLGkpLnZhbHVlLnRoZW4oJHQpLGkrPTEyOCxBdG9taWNzLnN0b3JlKG4oKSxpPj4yLDEpKX1hLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdD1QdDtmdW5jdGlvbiAkdCgpe3ZhciBpPVNyKCk7aSYmKFB0KGkpLHF0KCgpPT5YbigpKSl9YS5jaGVja01haWxib3g9JHQ7dmFyIHB0PWk9PmklND09PTAmJihpJTEwMCE9PTB8fGklNDAwPT09MCkseHQ9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0sWXQ9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gbChpLGMsZiwkLEksUCxWLG9lKXtyZXR1cm4gQT9HKDE3LDEsaSxjLGYsJCxJLFAsVixvZSk6LTUyfWZ1bmN0aW9uIHAoaSxjLGYsJCxJLFAsVil7aWYoQSlyZXR1cm4gRygxOCwxLGksYyxmLCQsSSxQLFYpfXZhciBoPWk9Pnt2YXIgYz12dChpKSsxLGY9UXIoYyk7cmV0dXJuIGYmJmdyKGksZixjKSxmfSxDPVtdLFQ9KGksYyk9PntDLmxlbmd0aD0wO3ZhciBmO2ZvcihjPj49MjtmPW8oKVtpKys+Pj4wXTspYys9ZiE9MTA1JmMsQy5wdXNoKGY9PTEwNT9uKClbYz4+PjBdOmQoKVtjKys+Pj4xXSksKytjO3JldHVybiBDfSxVPWk9Pnt2YXIgYz1ybigpO3JldHVybiBpPWkoKSxDcihjKSxpfTtmdW5jdGlvbiBHKGksYyl7dmFyIGY9YXJndW1lbnRzLmxlbmd0aC0yLCQ9YXJndW1lbnRzO3JldHVybiBVKCgpPT57Zm9yKHZhciBJPW5uKDgqZiksUD1JPj4zLFY9MDtWPGY7VisrKXt2YXIgb2U9JFsyK1ZdO2QoKVtQK1Y+Pj4wXT1vZX1yZXR1cm4gWW4oaSxmLEksYyl9KX12YXIgdWU9W10sWT17fSxRPSgpPT57aWYoIUope3ZhciBpPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmJ8fFwiLi90aGlzLnByb2dyYW1cIn0sYztmb3IoYyBpbiBZKVlbY109PT12b2lkIDA/ZGVsZXRlIGlbY106aVtjXT1ZW2NdO3ZhciBmPVtdO2ZvcihjIGluIGkpZi5wdXNoKGAke2N9PSR7aVtjXX1gKTtKPWZ9cmV0dXJuIEp9LEo7ZnVuY3Rpb24gY2UoaSxjKXtpZihBKXJldHVybiBHKDE5LDEsaSxjKTtpPj4+PTAsYz4+Pj0wO3ZhciBmPTA7cmV0dXJuIFEoKS5mb3JFYWNoKGZ1bmN0aW9uKCQsSSl7dmFyIFA9YytmO2ZvcihJPXMoKVtpKzQqST4+Mj4+PjBdPVAsUD0wO1A8JC5sZW5ndGg7KytQKXIoKVtJKys+PjA+Pj4wXT0kLmNoYXJDb2RlQXQoUCk7cigpW0k+PjA+Pj4wXT0wLGYrPSQubGVuZ3RoKzF9KSwwfWZ1bmN0aW9uIG1lKGksYyl7aWYoQSlyZXR1cm4gRygyMCwxLGksYyk7aT4+Pj0wLGM+Pj49MDt2YXIgZj1RKCk7cygpW2k+PjI+Pj4wXT1mLmxlbmd0aDt2YXIgJD0wO3JldHVybiBmLmZvckVhY2goZnVuY3Rpb24oSSl7JCs9SS5sZW5ndGgrMX0pLHMoKVtjPj4yPj4+MF09JCwwfWZ1bmN0aW9uIEUoaSl7cmV0dXJuIEE/RygyMSwxLGkpOjUyfWZ1bmN0aW9uIHRlKGksYyxmLCQpe3JldHVybiBBP0coMjIsMSxpLGMsZiwkKTo1Mn1mdW5jdGlvbiBmZShpLGMsZiwkLEkpe3JldHVybiBBP0coMjMsMSxpLGMsZiwkLEkpOjcwfXZhciB1dD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gWHQoaSxjLGYsJCl7aWYoQSlyZXR1cm4gRygyNCwxLGksYyxmLCQpO2M+Pj49MCxmPj4+PTAsJD4+Pj0wO2Zvcih2YXIgST0wLFA9MDtQPGY7UCsrKXt2YXIgVj1zKClbYz4+Mj4+PjBdLG9lPXMoKVtjKzQ+PjI+Pj4wXTtjKz04O2Zvcih2YXIgZWU9MDtlZTxvZTtlZSsrKXt2YXIgWj1vKClbVitlZT4+PjBdLHJlPXV0W2ldO1o9PT0wfHxaPT09MTA/KChpPT09MT9COkspKGNyKHJlLDApKSxyZS5sZW5ndGg9MCk6cmUucHVzaChaKX1JKz1vZX1yZXR1cm4gcygpWyQ+PjI+Pj4wXT1JLDB9dmFyIE5uPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sVW49WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBkdShpKXt2YXIgYz1BcnJheSh2dChpKSsxKTtyZXR1cm4gaHIoaSxjLDAsYy5sZW5ndGgpLGN9dmFyIGN1PShpLGMpPT57cigpLnNldChpLGM+Pj4wKX07ZnVuY3Rpb24gTG4oaSxjLGYsJCl7ZnVuY3Rpb24gSShPLHNlLHllKXtmb3IoTz10eXBlb2YgTz09XCJudW1iZXJcIj9PLnRvU3RyaW5nKCk6T3x8XCJcIjtPLmxlbmd0aDxzZTspTz15ZVswXStPO3JldHVybiBPfWZ1bmN0aW9uIFAoTyxzZSl7cmV0dXJuIEkoTyxzZSxcIjBcIil9ZnVuY3Rpb24gVihPLHNlKXtmdW5jdGlvbiB5ZShhbyl7cmV0dXJuIDA+YW8/LTE6MDxhbz8xOjB9dmFyIFN0O3JldHVybihTdD15ZShPLmdldEZ1bGxZZWFyKCktc2UuZ2V0RnVsbFllYXIoKSkpPT09MCYmKFN0PXllKE8uZ2V0TW9udGgoKS1zZS5nZXRNb250aCgpKSk9PT0wJiYoU3Q9eWUoTy5nZXREYXRlKCktc2UuZ2V0RGF0ZSgpKSksU3R9ZnVuY3Rpb24gb2UoTyl7c3dpdGNoKE8uZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gTztjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gZWUoTyl7dmFyIHNlPU8uWmE7Zm9yKE89bmV3IERhdGUobmV3IERhdGUoTy4kYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHNlOyl7dmFyIHllPU8uZ2V0TW9udGgoKSxTdD0ocHQoTy5nZXRGdWxsWWVhcigpKT9ObjpVbilbeWVdO2lmKHNlPlN0LU8uZ2V0RGF0ZSgpKXNlLT1TdC1PLmdldERhdGUoKSsxLE8uc2V0RGF0ZSgxKSwxMT55ZT9PLnNldE1vbnRoKHllKzEpOihPLnNldE1vbnRoKDApLE8uc2V0RnVsbFllYXIoTy5nZXRGdWxsWWVhcigpKzEpKTtlbHNle08uc2V0RGF0ZShPLmdldERhdGUoKStzZSk7YnJlYWt9fXJldHVybiB5ZT1uZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHNlPW9lKG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDQpKSx5ZT1vZSh5ZSksMD49VihzZSxPKT8wPj1WKHllLE8pP08uZ2V0RnVsbFllYXIoKSsxOk8uZ2V0RnVsbFllYXIoKTpPLmdldEZ1bGxZZWFyKCktMX1pPj4+PTAsYz4+Pj0wLGY+Pj49MCwkPj4+PTA7dmFyIFo9bigpWyQrNDA+PjI+Pj4wXTskPXtLYjpuKClbJD4+Mj4+PjBdLEpiOm4oKVskKzQ+PjI+Pj4wXSxjYjpuKClbJCs4Pj4yPj4+MF0saWI6bigpWyQrMTI+PjI+Pj4wXSxlYjpuKClbJCsxNj4+Mj4+PjBdLCRhOm4oKVskKzIwPj4yPj4+MF0sV2E6bigpWyQrMjQ+PjI+Pj4wXSxaYTpuKClbJCsyOD4+Mj4+PjBdLFRiOm4oKVskKzMyPj4yPj4+MF0sSWI6bigpWyQrMzY+PjI+Pj4wXSxMYjpaP1ZlKFopOlwiXCJ9LGY9VmUoZiksWj17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgcmUgaW4gWilmPWYucmVwbGFjZShuZXcgUmVnRXhwKHJlLFwiZ1wiKSxaW3JlXSk7dmFyIGhlPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksYmU9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO1o9e1wiJWFcIjpPPT5oZVtPLldhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6Tz0+aGVbTy5XYV0sXCIlYlwiOk89PmJlW08uZWJdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpPPT5iZVtPLmViXSxcIiVDXCI6Tz0+UCgoTy4kYSsxOTAwKS8xMDB8MCwyKSxcIiVkXCI6Tz0+UChPLmliLDIpLFwiJWVcIjpPPT5JKE8uaWIsMixcIiBcIiksXCIlZ1wiOk89PmVlKE8pLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpPPT5lZShPKSxcIiVIXCI6Tz0+UChPLmNiLDIpLFwiJUlcIjpPPT4oTz1PLmNiLE89PTA/Tz0xMjoxMjxPJiYoTy09MTIpLFAoTywyKSksXCIlalwiOk89Pntmb3IodmFyIHNlPTAseWU9MDt5ZTw9Ty5lYi0xO3NlKz0ocHQoTy4kYSsxOTAwKT9ObjpVbilbeWUrK10pO3JldHVybiBQKE8uaWIrc2UsMyl9LFwiJW1cIjpPPT5QKE8uZWIrMSwyKSxcIiVNXCI6Tz0+UChPLkpiLDIpLFwiJW5cIjooKT0+YFxcbmAsXCIlcFwiOk89PjA8PU8uY2ImJjEyPk8uY2I/XCJBTVwiOlwiUE1cIixcIiVTXCI6Tz0+UChPLktiLDIpLFwiJXRcIjooKT0+XCJcdFwiLFwiJXVcIjpPPT5PLldhfHw3LFwiJVVcIjpPPT5QKE1hdGguZmxvb3IoKE8uWmErNy1PLldhKS83KSwyKSxcIiVWXCI6Tz0+e3ZhciBzZT1NYXRoLmZsb29yKChPLlphKzctKE8uV2ErNiklNykvNyk7aWYoMj49KE8uV2ErMzcxLU8uWmEtMiklNyYmc2UrKyxzZSlzZT09NTMmJih5ZT0oTy5XYSszNzEtTy5aYSklNyx5ZT09NHx8eWU9PTMmJnB0KE8uJGEpfHwoc2U9MSkpO2Vsc2V7c2U9NTI7dmFyIHllPShPLldhKzctTy5aYS0xKSU3Oyh5ZT09NHx8eWU9PTUmJnB0KE8uJGElNDAwLTEpKSYmc2UrK31yZXR1cm4gUChzZSwyKX0sXCIld1wiOk89Pk8uV2EsXCIlV1wiOk89PlAoTWF0aC5mbG9vcigoTy5aYSs3LShPLldhKzYpJTcpLzcpLDIpLFwiJXlcIjpPPT4oTy4kYSsxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6Tz0+Ty4kYSsxOTAwLFwiJXpcIjpPPT57Tz1PLkliO3ZhciBzZT0wPD1PO3JldHVybiBPPU1hdGguYWJzKE8pLzYwLChzZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyhPLzYwKjEwMCtPJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6Tz0+Ty5MYixcIiUlXCI6KCk9PlwiJVwifSxmPWYucmVwbGFjZSgvJSUvZyxcIlxcXFwwXFxcXDBcIik7Zm9yKHJlIGluIFopZi5pbmNsdWRlcyhyZSkmJihmPWYucmVwbGFjZShuZXcgUmVnRXhwKHJlLFwiZ1wiKSxaW3JlXSgkKSkpO3JldHVybiBmPWYucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSxyZT1kdShmKSxyZS5sZW5ndGg+Yz8wOihjdShyZSxpKSxyZS5sZW5ndGgtMSl9ZnVuY3Rpb24gJHIoaSl7dHJ5e2koKX1jYXRjaChjKXtLZShjKX19ZnVuY3Rpb24gcHUoaSl7dmFyIGM9e30sZjtmb3IoZiBpbiBpKShmdW5jdGlvbigkKXt2YXIgST1pWyRdO2NbJF09dHlwZW9mIEk9PVwiZnVuY3Rpb25cIj9mdW5jdGlvbigpe3hyLnB1c2goJCk7dHJ5e3JldHVybiBJLmFwcGx5KG51bGwsYXJndW1lbnRzKX1maW5hbGx5e09lfHwoeHIucG9wKCk9PT0kfHxLZSgpLFplJiZmdD09PTEmJnhyLmxlbmd0aD09PTAmJihmdD0wLEdlKz0xLCRyKHRvKSx0eXBlb2YgRmliZXJzPFwidVwiJiZGaWJlcnMuVWIoKSkpfX06SX0pKGYpO3JldHVybiBjfXZhciBmdD0wLFplPW51bGwsRm49MCx4cj1bXSxIbj17fSxqbj17fSxmdT0wLFpyPW51bGwsbXU9W107ZnVuY3Rpb24gaHUoKXtyZXR1cm4gbmV3IFByb21pc2UoKGksYyk9Pntacj17cmVzb2x2ZTppLHJlamVjdDpjfX0pfWZ1bmN0aW9uIGd1KCl7dmFyIGk9UXIoNjU1NDgpLGM9aSsxMjtzKClbaT4+Mj4+PjBdPWMscygpW2krND4+Mj4+PjBdPWMrNjU1MzYsYz14clswXTt2YXIgZj1IbltjXTtyZXR1cm4gZj09PXZvaWQgMCYmKGY9ZnUrKyxIbltjXT1mLGpuW2ZdPWMpLGM9ZixuKClbaSs4Pj4yPj4+MF09YyxpfWZ1bmN0aW9uIHl1KCl7dmFyIGk9bigpW1plKzg+PjI+Pj4wXTtyZXR1cm4gaT1qW2puW2ldXSwtLUdlLGkoKX1mdW5jdGlvbiBidShpKXtpZighT2Upe2lmKGZ0PT09MCl7dmFyIGM9ITEsZj0hMTtpKCgkPTApPT57aWYoIU9lJiYoRm49JCxjPSEwLGYpKXtmdD0yLCRyKCgpPT5ybyhaZSkpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLmhiLnNiJiZCcm93c2VyLmhiLnJlc3VtZSgpLCQ9ITE7dHJ5e3ZhciBJPXl1KCl9Y2F0Y2gob2Upe0k9b2UsJD0hMH12YXIgUD0hMTtpZighWmUpe3ZhciBWPVpyO1YmJihacj1udWxsLCgkP1YucmVqZWN0OlYucmVzb2x2ZSkoSSksUD0hMCl9aWYoJCYmIVApdGhyb3cgSX19KSxmPSEwLGN8fChmdD0xLFplPWd1KCksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuaGIuc2ImJkJyb3dzZXIuaGIucGF1c2UoKSwkcigoKT0+ZW8oWmUpKSl9ZWxzZSBmdD09PTI/KGZ0PTAsJHIobm8pLEtuKFplKSxaZT1udWxsLG11LmZvckVhY2goJD0+cXQoJCkpKTpLZShgaW52YWxpZCBzdGF0ZTogJHtmdH1gKTtyZXR1cm4gRm59fWZ1bmN0aW9uIHd1KGkpe3JldHVybiBidShjPT57aSgpLnRoZW4oYyl9KX1uZS5nYigpO3ZhciB2dT1bbnVsbCx6dCxwcix3dCxOdCxtcix5cixicix3cix2cixSdCxVdCxMdCxGdCxIdCxqdCxLdCxsLHAsY2UsbWUsRSx0ZSxmZSxYdF0sJHU9e3I6ZnVuY3Rpb24oaSxjLGYpe3JldHVybiB3dShhc3luYygpPT57YXdhaXQgYS54YihpLGMsZil9KX0sYjpmdW5jdGlvbihpLGMsZil7dGhyb3cgaT4+Pj0wLG5ldyBKZShpKS5nYihjPj4+MCxmPj4+MCksSGU9aSxmcisrLEhlfSxPOmZ1bmN0aW9uKGkpe3FuKGk+Pj4wLCF5LDEsIXYsMTMxMDcyLCExKSxuZS5sYigpfSxsOmZ1bmN0aW9uKGkpe2k+Pj49MCxBP3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOml9KTpPdChpKX0sSTpHdCxpOk50LFU6bXIsRTp5cixHOmJyLFY6d3IsUzp2cixLOlJ0LFI6VXQscDpMdCxGOkZ0LEM6SHQsVDpqdCxEOkt0LHE6KCk9PiEwLEE6ZnVuY3Rpb24oaSxjKXtpPj4+PTAsaT09Yz4+PjA/c2V0VGltZW91dCgoKT0+JHQoKSk6QT9wb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOmksY21kOlwiY2hlY2tNYWlsYm94XCJ9KTooaT1uZS5RYVtpXSkmJmkucG9zdE1lc3NhZ2Uoe2NtZDpcImNoZWNrTWFpbGJveFwifSl9LE06ZnVuY3Rpb24oKXtyZXR1cm4tMX0sTjpQdCxYOmZ1bmN0aW9uKGkpe1MmJm5lLlFhW2k+Pj4wXS5yZWYoKX0sdTpmdW5jdGlvbihpLGMsZil7aT1jKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFpPyhpPj4+MCkrNDI5NDk2NzI5NipjOk5hTixmPj4+PTAsaT1uZXcgRGF0ZSgxZTMqaSksbigpW2Y+PjI+Pj4wXT1pLmdldFVUQ1NlY29uZHMoKSxuKClbZis0Pj4yPj4+MF09aS5nZXRVVENNaW51dGVzKCksbigpW2YrOD4+Mj4+PjBdPWkuZ2V0VVRDSG91cnMoKSxuKClbZisxMj4+Mj4+PjBdPWkuZ2V0VVRDRGF0ZSgpLG4oKVtmKzE2Pj4yPj4+MF09aS5nZXRVVENNb250aCgpLG4oKVtmKzIwPj4yPj4+MF09aS5nZXRVVENGdWxsWWVhcigpLTE5MDAsbigpW2YrMjQ+PjI+Pj4wXT1pLmdldFVUQ0RheSgpLGk9KGkuZ2V0VGltZSgpLURhdGUuVVRDKGkuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsbigpW2YrMjg+PjI+Pj4wXT1pfSx2OmZ1bmN0aW9uKGksYyxmKXtpPWMrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWk/KGk+Pj4wKSs0Mjk0OTY3Mjk2KmM6TmFOLGY+Pj49MCxpPW5ldyBEYXRlKDFlMyppKSxuKClbZj4+Mj4+PjBdPWkuZ2V0U2Vjb25kcygpLG4oKVtmKzQ+PjI+Pj4wXT1pLmdldE1pbnV0ZXMoKSxuKClbZis4Pj4yPj4+MF09aS5nZXRIb3VycygpLG4oKVtmKzEyPj4yPj4+MF09aS5nZXREYXRlKCksbigpW2YrMTY+PjI+Pj4wXT1pLmdldE1vbnRoKCksbigpW2YrMjA+PjI+Pj4wXT1pLmdldEZ1bGxZZWFyKCktMTkwMCxuKClbZisyND4+Mj4+PjBdPWkuZ2V0RGF5KCksYz0ocHQoaS5nZXRGdWxsWWVhcigpKT94dDpZdClbaS5nZXRNb250aCgpXStpLmdldERhdGUoKS0xfDAsbigpW2YrMjg+PjI+Pj4wXT1jLG4oKVtmKzM2Pj4yPj4+MF09LSg2MCppLmdldFRpbWV6b25lT2Zmc2V0KCkpLGM9bmV3IERhdGUoaS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgJD1uZXcgRGF0ZShpLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO2k9KGMhPSQmJmkuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oJCxjKSl8MCxuKClbZiszMj4+Mj4+PjBdPWl9LHc6ZnVuY3Rpb24oaSl7aT4+Pj0wO3ZhciBjPW5ldyBEYXRlKG4oKVtpKzIwPj4yPj4+MF0rMTkwMCxuKClbaSsxNj4+Mj4+PjBdLG4oKVtpKzEyPj4yPj4+MF0sbigpW2krOD4+Mj4+PjBdLG4oKVtpKzQ+PjI+Pj4wXSxuKClbaT4+Mj4+PjBdLDApLGY9bigpW2krMzI+PjI+Pj4wXSwkPWMuZ2V0VGltZXpvbmVPZmZzZXQoKSxJPW5ldyBEYXRlKGMuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksUD1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLFY9TWF0aC5taW4oUCxJKTtyZXR1cm4gMD5mP24oKVtpKzMyPj4yPj4+MF09KyhJIT1QJiZWPT0kKTowPGYhPShWPT0kKSYmKEk9TWF0aC5tYXgoUCxJKSxjLnNldFRpbWUoYy5nZXRUaW1lKCkrNmU0KigoMDxmP1Y6SSktJCkpKSxuKClbaSsyND4+Mj4+PjBdPWMuZ2V0RGF5KCksZj0ocHQoYy5nZXRGdWxsWWVhcigpKT94dDpZdClbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsbigpW2krMjg+PjI+Pj4wXT1mLG4oKVtpPj4yPj4+MF09Yy5nZXRTZWNvbmRzKCksbigpW2krND4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLG4oKVtpKzg+PjI+Pj4wXT1jLmdldEhvdXJzKCksbigpW2krMTI+PjI+Pj4wXT1jLmdldERhdGUoKSxuKClbaSsxNj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxuKClbaSsyMD4+Mj4+PjBdPWMuZ2V0WWVhcigpLGk9Yy5nZXRUaW1lKCkvMWUzLEpuKChpdD1pLDE8PStNYXRoLmFicyhpdCk/MDxpdD8rTWF0aC5mbG9vcihpdC80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChpdC0rKH5+aXQ+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxpPj4+MH0sczpsLHQ6cCx6OmZ1bmN0aW9uKGksYyxmKXtmdW5jdGlvbiAkKFope3JldHVybihaPVoudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP1pbMV06XCJHTVRcIn1pPj4+PTAsYz4+Pj0wLGY+Pj49MDt2YXIgST1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksUD1uZXcgRGF0ZShJLDAsMSksVj1uZXcgRGF0ZShJLDYsMSk7ST1QLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIG9lPVYuZ2V0VGltZXpvbmVPZmZzZXQoKSxlZT1NYXRoLm1heChJLG9lKTtzKClbaT4+Mj4+PjBdPTYwKmVlLG4oKVtjPj4yPj4+MF09KyhJIT1vZSksaT0kKFApLGM9JChWKSxpPWgoaSksYz1oKGMpLG9lPEk/KHMoKVtmPj4yPj4+MF09aSxzKClbZis0Pj4yPj4+MF09Yyk6KHMoKVtmPj4yPj4+MF09YyxzKClbZis0Pj4yPj4+MF09aSl9LGQ6KCk9PntLZShcIlwiKX0sYzpmdW5jdGlvbihpLGMsZil7cmV0dXJuIGk+Pj49MCxjPVQoYz4+PjAsZj4+PjApLEV0W2ldLmFwcGx5KG51bGwsYyl9LGs6ZnVuY3Rpb24oaSxjLGYpe3JldHVybiBpPj4+PTAsYz1UKGM+Pj4wLGY+Pj4wKSxFdFtpXS5hcHBseShudWxsLGMpfSxtOmZ1bmN0aW9uKCl7fSxqOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LFc6KCk9Pnt0aHJvdyBHZSs9MSxcInVud2luZFwifSxCOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGY6KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCksZzpmdW5jdGlvbigpe3JldHVybiBTPyhmbygpLE10KHBvKSkuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeX0sTDpmdW5jdGlvbihpLGMsZiwkKXtmb3IobmUuUGI9Yz4+PjAsdWUubGVuZ3RoPWYsYz0kPj4+MD4+MywkPTA7JDxmOyQrKyl1ZVskXT1kKClbYyskPj4+MF07cmV0dXJuKDA+aT9FdFstaS0xXTp2dVtpXSkuYXBwbHkobnVsbCx1ZSl9LHk6ZnVuY3Rpb24oaSl7aT4+Pj0wO3ZhciBjPW8oKS5sZW5ndGg7aWYoaTw9Y3x8NDI5NDkwMTc2MDxpKXJldHVybiExO2Zvcih2YXIgZj0xOzQ+PWY7Zio9Mil7dmFyICQ9YyooMSsuMi9mKTskPU1hdGgubWluKCQsaSsxMDA2NjMyOTYpO3ZhciBJPU1hdGg7JD1NYXRoLm1heChpLCQpO2U6e0k9SS5taW4uY2FsbChJLDQyOTQ5MDE3NjAsJCsoNjU1MzYtJCU2NTUzNiklNjU1MzYpLXdlLmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTY7dHJ5e3dlLmdyb3coSSkscGUoKTt2YXIgUD0xO2JyZWFrIGV9Y2F0Y2h7fVA9dm9pZCAwfWlmKFApcmV0dXJuITB9cmV0dXJuITF9LFA6Y2UsUTptZSxIOlZ0LGg6RSxvOnRlLHg6ZmUsbjpYdCxhOndlfHxhLndhc21NZW1vcnksSjpMbixlOmZ1bmN0aW9uKGksYyxmLCQpe3JldHVybiBMbihpPj4+MCxjPj4+MCxmPj4+MCwkPj4+MCl9fTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBpKGYsJCl7cmV0dXJuIGY9Zi5leHBvcnRzLGY9cHUoZiksaj1mPXh1KGYpLG5lLm1iLnB1c2goai5EYSksVGUudW5zaGlmdChqLlkpLFNlPSQsbHIoKSxmfXZhciBjPXthOiR1fTtpZihCdCgpLGEuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gYS5pbnN0YW50aWF0ZVdhc20oYyxpKX1jYXRjaChmKXtLKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZiksZyhmKX1yZXR1cm4gZHIoYyxmdW5jdGlvbihmKXtpKGYuaW5zdGFuY2UsZi5tb2R1bGUpfSkuY2F0Y2goZykse319KSgpLGEuX09ydEluaXQ9KGksYyk9PihhLl9PcnRJbml0PWouWikoaSxjKSxhLl9PcnRHZXRMYXN0RXJyb3I9KGksYyk9PihhLl9PcnRHZXRMYXN0RXJyb3I9ai5fKShpLGMpLGEuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShpLGMsZiwkLEksUCxWLG9lLGVlLFopPT4oYS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ai4kKShpLGMsZiwkLEksUCxWLG9lLGVlLFopLGEuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShpLGMpPT4oYS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ai5hYSkoaSxjKSxhLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KGksYyxmKT0+KGEuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1qLmJhKShpLGMsZiksYS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShpLGMsZik9PihhLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9ai5jYSkoaSxjLGYpLGEuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1pPT4oYS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWouZGEpKGkpLGEuX09ydENyZWF0ZVNlc3Npb249KGksYyxmKT0+KGEuX09ydENyZWF0ZVNlc3Npb249ai5lYSkoaSxjLGYpLGEuX09ydFJlbGVhc2VTZXNzaW9uPWk9PihhLl9PcnRSZWxlYXNlU2Vzc2lvbj1qLmZhKShpKSxhLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShpLGMsZik9PihhLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PWouZ2EpKGksYyxmKSxhLl9PcnRHZXRJbnB1dE5hbWU9KGksYyk9PihhLl9PcnRHZXRJbnB1dE5hbWU9ai5oYSkoaSxjKSxhLl9PcnRHZXRPdXRwdXROYW1lPShpLGMpPT4oYS5fT3J0R2V0T3V0cHV0TmFtZT1qLmlhKShpLGMpLGEuX09ydEZyZWU9aT0+KGEuX09ydEZyZWU9ai5qYSkoaSksYS5fT3J0Q3JlYXRlVGVuc29yPShpLGMsZiwkLEksUCk9PihhLl9PcnRDcmVhdGVUZW5zb3I9ai5rYSkoaSxjLGYsJCxJLFApLGEuX09ydEdldFRlbnNvckRhdGE9KGksYyxmLCQsSSk9PihhLl9PcnRHZXRUZW5zb3JEYXRhPWoubGEpKGksYyxmLCQsSSksYS5fT3J0UmVsZWFzZVRlbnNvcj1pPT4oYS5fT3J0UmVsZWFzZVRlbnNvcj1qLm1hKShpKSxhLl9PcnRDcmVhdGVSdW5PcHRpb25zPShpLGMsZiwkKT0+KGEuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ai5uYSkoaSxjLGYsJCksYS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGksYyxmKT0+KGEuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWoub2EpKGksYyxmKSxhLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1pPT4oYS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ai5wYSkoaSksYS5fT3J0Q3JlYXRlQmluZGluZz1pPT4oYS5fT3J0Q3JlYXRlQmluZGluZz1qLnFhKShpKSxhLl9PcnRCaW5kSW5wdXQ9KGksYyxmKT0+KGEuX09ydEJpbmRJbnB1dD1qLnJhKShpLGMsZiksYS5fT3J0QmluZE91dHB1dD0oaSxjLGYsJCk9PihhLl9PcnRCaW5kT3V0cHV0PWouc2EpKGksYyxmLCQpLGEuX09ydENsZWFyQm91bmRPdXRwdXRzPWk9PihhLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1qLnRhKShpKSxhLl9PcnRSZWxlYXNlQmluZGluZz1pPT4oYS5fT3J0UmVsZWFzZUJpbmRpbmc9ai51YSkoaSksYS5fT3J0UnVuV2l0aEJpbmRpbmc9KGksYyxmLCQsSSk9PihhLl9PcnRSdW5XaXRoQmluZGluZz1qLnZhKShpLGMsZiwkLEkpLGEuX09ydFJ1bj0oaSxjLGYsJCxJLFAsVixvZSk9PihhLl9PcnRSdW49ai53YSkoaSxjLGYsJCxJLFAsVixvZSksYS5fT3J0RW5kUHJvZmlsaW5nPWk9PihhLl9PcnRFbmRQcm9maWxpbmc9ai54YSkoaSksYS5fSnNlcE91dHB1dD0oaSxjLGYpPT4oYS5fSnNlcE91dHB1dD1qLnlhKShpLGMsZiksYS5fSnNlcEdldE5vZGVOYW1lPWk9PihhLl9Kc2VwR2V0Tm9kZU5hbWU9ai56YSkoaSk7dmFyIFNyPWEuX3B0aHJlYWRfc2VsZj0oKT0+KFNyPWEuX3B0aHJlYWRfc2VsZj1qLkFhKSgpLFFyPWEuX21hbGxvYz1pPT4oUXI9YS5fbWFsbG9jPWouQmEpKGkpLEtuPWEuX2ZyZWU9aT0+KEtuPWEuX2ZyZWU9ai5DYSkoaSk7YS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9KCk9PihhLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1qLkRhKSgpO3ZhciBxbj1hLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD0oaSxjLGYsJCxJLFApPT4ocW49YS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9ai5GYSkoaSxjLGYsJCxJLFApO2EuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPSgpPT4oYS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9ai5HYSkoKTt2YXIgWW49KGksYyxmLCQpPT4oWW49ai5IYSkoaSxjLGYsJCksZW49aT0+KGVuPWouSWEpKGkpLHRuPWEuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWk9Pih0bj1hLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1qLkphKShpKSxYbj1hLl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94PSgpPT4oWG49YS5fX2Vtc2NyaXB0ZW5fY2hlY2tfbWFpbGJveD1qLkthKSgpLEpuPWk9PihKbj1qLkxhKShpKSxabj0oaSxjKT0+KFpuPWouTWEpKGksYykscm49KCk9Pihybj1qLk5hKSgpLENyPWk9PihDcj1qLk9hKShpKSxubj1pPT4obm49ai5QYSkoaSksUW49YS5keW5DYWxsX2lpPShpLGMpPT4oUW49YS5keW5DYWxsX2lpPWouUmEpKGksYyksZW89aT0+KGVvPWouU2EpKGkpLHRvPSgpPT4odG89ai5UYSkoKSxybz1pPT4ocm89ai5VYSkoaSksbm89KCk9Pihubz1qLlZhKSgpO2EuX19fc3RhcnRfZW1fanM9OTI1NzgzLGEuX19fc3RvcF9lbV9qcz05MjU5NDQ7ZnVuY3Rpb24geHUoaSl7aT1PYmplY3QuYXNzaWduKHt9LGkpO3ZhciBjPSQ9PigpPT4kKCk+Pj4wLGY9JD0+ST0+JChJKT4+PjA7cmV0dXJuIGkuX19lcnJub19sb2NhdGlvbj1jKGkuX19lcnJub19sb2NhdGlvbiksaS5wdGhyZWFkX3NlbGY9YyhpLnB0aHJlYWRfc2VsZiksaS5tYWxsb2M9ZihpLm1hbGxvYyksaS5zdGFja1NhdmU9YyhpLnN0YWNrU2F2ZSksaS5zdGFja0FsbG9jPWYoaS5zdGFja0FsbG9jKSxpfWEua2VlcFJ1bnRpbWVBbGl2ZT1YZSxhLndhc21NZW1vcnk9d2UsYS5zdGFja0FsbG9jPW5uLGEuc3RhY2tTYXZlPXJuLGEuc3RhY2tSZXN0b3JlPUNyLGEuVVRGOFRvU3RyaW5nPVZlLGEuc3RyaW5nVG9VVEY4PWdyLGEubGVuZ3RoQnl0ZXNVVEY4PXZ0LGEuRXhpdFN0YXR1cz1jdCxhLlBUaHJlYWQ9bmU7dmFyIEFyO2J0PWZ1bmN0aW9uIGkoKXtBcnx8b28oKSxBcnx8KGJ0PWkpfTtmdW5jdGlvbiBvbygpe2Z1bmN0aW9uIGkoKXtpZighQXImJihBcj0hMCxhLmNhbGxlZFJ1bj0hMCwhT2UpJiYoQXx8c3QoVGUpLG0oYSksYS5vblJ1bnRpbWVJbml0aWFsaXplZCYmYS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLCFBKSl7aWYoYS5wb3N0UnVuKWZvcih0eXBlb2YgYS5wb3N0UnVuPT1cImZ1bmN0aW9uXCImJihhLnBvc3RSdW49W2EucG9zdFJ1bl0pO2EucG9zdFJ1bi5sZW5ndGg7KXt2YXIgYz1hLnBvc3RSdW4uc2hpZnQoKTtrZS51bnNoaWZ0KGMpfXN0KGtlKX19aWYoISgwPEZlKSlpZihBKW0oYSksQXx8c3QoVGUpLHN0YXJ0V29ya2VyKGEpO2Vsc2V7aWYoYS5wcmVSdW4pZm9yKHR5cGVvZiBhLnByZVJ1bj09XCJmdW5jdGlvblwiJiYoYS5wcmVSdW49W2EucHJlUnVuXSk7YS5wcmVSdW4ubGVuZ3RoOylVZS51bnNoaWZ0KGEucHJlUnVuLnNoaWZ0KCkpO3N0KFVlKSwwPEZlfHwoYS5zZXRTdGF0dXM/KGEuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe2Euc2V0U3RhdHVzKFwiXCIpfSwxKSxpKCl9LDEpKTppKCkpfX1pZihhLnByZUluaXQpZm9yKHR5cGVvZiBhLnByZUluaXQ9PVwiZnVuY3Rpb25cIiYmKGEucHJlSW5pdD1bYS5wcmVJbml0XSk7MDxhLnByZUluaXQubGVuZ3RoOylhLnByZUluaXQucG9wKCkoKTtyZXR1cm4gb28oKSx0LnJlYWR5fX0pKCk7dHlwZW9mIGhvPT1cIm9iamVjdFwiJiZ0eXBlb2YgY249PVwib2JqZWN0XCI/Y24uZXhwb3J0cz1tbzp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQmJmRlZmluZShbXSwoKT0+bW8pfSk7dmFyIHlvPUp0KChtYyxfdSk9PntfdS5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBNb2R1bGU9e30sRU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCI7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7dmFyIG5vZGVXb3JrZXJUaHJlYWRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxwYXJlbnRQb3J0PW5vZGVXb3JrZXJUaHJlYWRzLnBhcmVudFBvcnQ7cGFyZW50UG9ydC5vbihcIm1lc3NhZ2VcIixlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKTt2YXIgZnM9cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlLE1vZHVsZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6bm9kZVdvcmtlclRocmVhZHMuV29ya2VyLGltcG9ydFNjcmlwdHM6ZT0+KDAsZXZhbCkoZnMucmVhZEZpbGVTeW5jKGUsXCJ1dGY4XCIpK1wiLy8jIHNvdXJjZVVSTD1cIitlKSxwb3N0TWVzc2FnZTplPT5wYXJlbnRQb3J0LnBvc3RNZXNzYWdlKGUpLHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpEYXRlLm5vd319KX12YXIgaW5pdGlhbGl6ZWRKUz0hMTtmdW5jdGlvbiB0aHJlYWRQcmludEVycigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7ZnMud3JpdGVTeW5jKDIsZStgXFxcXG5gKTtyZXR1cm59Y29uc29sZS5lcnJvcihlKX1mdW5jdGlvbiB0aHJlYWRBbGVydCgpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7cG9zdE1lc3NhZ2Uoe2NtZDpcImFsZXJ0XCIsdGV4dDplLHRocmVhZElkOk1vZHVsZS5fcHRocmVhZF9zZWxmKCl9KX12YXIgZXJyPXRocmVhZFByaW50RXJyO3NlbGYuYWxlcnQ9dGhyZWFkQWxlcnQsTW9kdWxlLmluc3RhbnRpYXRlV2FzbT0oZSx0KT0+e3ZhciBhPU1vZHVsZS53YXNtTW9kdWxlO01vZHVsZS53YXNtTW9kdWxlPW51bGw7dmFyIHI9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGEsZSk7cmV0dXJuIHQocil9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29uPz9lfTtmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGUpe3RyeXtpZihlLmRhdGEuY21kPT09XCJsb2FkXCIpe2xldCBhPVtdO3NlbGYub25tZXNzYWdlPXI9PmEucHVzaChyKSxzZWxmLnN0YXJ0V29ya2VyPXI9PntNb2R1bGU9cixwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtmb3IobGV0IHMgb2YgYSloYW5kbGVNZXNzYWdlKHMpO3NlbGYub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2V9LE1vZHVsZS53YXNtTW9kdWxlPWUuZGF0YS53YXNtTW9kdWxlO2Zvcihjb25zdCByIG9mIGUuZGF0YS5oYW5kbGVycylNb2R1bGVbcl09KC4uLnMpPT57cG9zdE1lc3NhZ2Uoe2NtZDpcImNhbGxIYW5kbGVyXCIsaGFuZGxlcjpyLGFyZ3M6c30pfTtpZihNb2R1bGUud2FzbU1lbW9yeT1lLmRhdGEud2FzbU1lbW9yeSxNb2R1bGUuYnVmZmVyPU1vZHVsZS53YXNtTWVtb3J5LmJ1ZmZlcixNb2R1bGUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD0hMCx0eXBlb2YgZS5kYXRhLnVybE9yQmxvYj09XCJzdHJpbmdcIilpbXBvcnRTY3JpcHRzKGUuZGF0YS51cmxPckJsb2IpO2Vsc2V7dmFyIHQ9VVJMLmNyZWF0ZU9iamVjdFVSTChlLmRhdGEudXJsT3JCbG9iKTtpbXBvcnRTY3JpcHRzKHQpLFVSTC5yZXZva2VPYmplY3RVUkwodCl9b3J0V2FzbVRocmVhZGVkKE1vZHVsZSl9ZWxzZSBpZihlLmRhdGEuY21kPT09XCJydW5cIil7TW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdChlLmRhdGEucHRocmVhZF9wdHIsMCwwLDEpLE1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQoZS5kYXRhLnB0aHJlYWRfcHRyKSxNb2R1bGUuZXN0YWJsaXNoU3RhY2tTcGFjZSgpLE1vZHVsZS5QVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2ZlcihlLmRhdGEpLE1vZHVsZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxpbml0aWFsaXplZEpTfHwoaW5pdGlhbGl6ZWRKUz0hMCk7dHJ5e01vZHVsZS5pbnZva2VFbnRyeVBvaW50KGUuZGF0YS5zdGFydF9yb3V0aW5lLGUuZGF0YS5hcmcpfWNhdGNoKGEpe2lmKGEhPVwidW53aW5kXCIpdGhyb3cgYX19ZWxzZSBlLmRhdGEuY21kPT09XCJjYW5jZWxcIj9Nb2R1bGUuX3B0aHJlYWRfc2VsZigpJiZNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KC0xKTplLmRhdGEudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcInx8KGUuZGF0YS5jbWQ9PT1cImNoZWNrTWFpbGJveFwiP2luaXRpYWxpemVkSlMmJk1vZHVsZS5jaGVja01haWxib3goKTplLmRhdGEuY21kJiYoZXJyKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIitlLmRhdGEuY21kKSxlcnIoZS5kYXRhKSkpfWNhdGNoKGEpe3Rocm93IE1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQmJk1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSxhfX1zZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlO1xcXFxuXFwnfSk7dmFyIG1uLFF0LGVyLFRyLHRyLFNvLGhuLERlPUgoKCk9PntcInVzZSBzdHJpY3RcIjttbj1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gMTA7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sUXQ9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LGVyPWU9Plt2b2lkIDAsNCwxLDEsMiwyLDQsOCx2b2lkIDAsMSwyLDgsNCw4LHZvaWQgMCx2b2lkIDAsdm9pZCAwXVtlXSxUcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJ1aW50NjRcIjpyZXR1cm4gQmlnVWludDY0QXJyYXk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7ZX1gKX19LHRyPWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fSxTbz1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJ1aW50MzJcIixobj1lPT57c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm4gMDtjYXNlXCJjcHVcIjpyZXR1cm4gMTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIDI7Y2FzZVwidGV4dHVyZVwiOnJldHVybiAzO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtlfWApfX19KTt2YXIgVnUsR3UsQ28sQW8sSW8sTnUsRWUsbXQ9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7VnU9W1wiVlwiLFwiSVwiLFwiV1wiLFwiRVwiLFwiRlwiXSxHdT0oZSx0KT0+e2NvbnNvbGUubG9nKGBbJHtWdVtlXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7dH1gKX0sSW89KGUsdCk9PntDbz1lLEFvPXR9LE51PShlLHQpPT57bGV0IHI9dHIoZSksbz10cihDbyk7cj49byYmR3Uocix0eXBlb2YgdD09XCJmdW5jdGlvblwiP3QoKTp0KX0sRWU9KC4uLmUpPT57QW8mJk51KC4uLmUpfX0pO3ZhciBFbyxUbz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtFbz0oZSx0KT0+bmV3KFRyKHQpKShlKX0pO3ZhciBPbz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgT3IsVXUsX28seW4sZ24sUm8sUG89SCgoKT0+e1widXNlIHN0cmljdFwiO210KCk7T28oKTtPcj1lPT5NYXRoLmNlaWwoZS8xNikqMTYsVXU9MSxfbz0oKT0+VXUrKyx5bj1hc3luYyhlLHQscixvKT0+e2xldCBuPU9yKHIpLHM9ZS5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR9KTt0cnl7bGV0IHU9ZS5nZXRDb21tYW5kRW5jb2RlcigpO2UuZW5kQ29tcHV0ZVBhc3MoKSx1LmNvcHlCdWZmZXJUb0J1ZmZlcih0LDAscywwLG4pLGUuZmx1c2goKSxhd2FpdCBzLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7bGV0IGQ9cy5nZXRNYXBwZWRSYW5nZSgpO2lmKG8pe2xldCBhPW8oKTtyZXR1cm4gYS5zZXQobmV3IFVpbnQ4QXJyYXkoZCwwLHIpKSxhfWVsc2UgcmV0dXJuIG5ldyBVaW50OEFycmF5KGQuc2xpY2UoMCxyKSl9ZmluYWxseXtzLmRlc3Ryb3koKX19LGduPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZz1bXSx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuZXh0ZXJuYWxCdWZmZXJzPW5ldyBNYXB9dXBsb2FkKHQscil7bGV0IG89ci5idWZmZXIsbj1yLmJ5dGVPZmZzZXQscz1yLmJ5dGVMZW5ndGgsdT1PcihzKSxkPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKGQub3JpZ2luYWxTaXplIT09cyl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtkLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke3N9YCk7bGV0IGE9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTp1LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLG09YS5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KG0pLnNldChuZXcgVWludDhBcnJheShvLG4scykpLGEudW5tYXAoKTtsZXQgZz10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxnLmNvcHlCdWZmZXJUb0J1ZmZlcihhLDAsZC5ncHVEYXRhLmJ1ZmZlciwwLHUpLEVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7dH0pYCksdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZy5wdXNoKGEpfW1lbWNweSh0LHIpe2xldCBvPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtsZXQgbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQocik7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtpZihvLm9yaWdpbmFsU2l6ZSE9PW4ub3JpZ2luYWxTaXplKXRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemVcIik7bGV0IHM9T3Ioby5vcmlnaW5hbFNpemUpLHU9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksdS5jb3B5QnVmZmVyVG9CdWZmZXIoby5ncHVEYXRhLmJ1ZmZlciwwLG4uZ3B1RGF0YS5idWZmZXIsMCxzKX1yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQscixvKXtsZXQgbjtpZihvKXtpZihuPXRoaXMuZXh0ZXJuYWxCdWZmZXJzLmdldChvKSxuPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGJ1ZmZlciBpcyBub3QgcmVnaXN0ZXJlZFwiKTtpZih0PT09bylyZXR1cm4gRWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtufSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLG47dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKG8pfWVsc2Ugbj1fbygpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobix7Z3B1RGF0YTp7aWQ6bix0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpyfSksdGhpcy5leHRlcm5hbEJ1ZmZlcnMuc2V0KHQsbiksRWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtufSwgcmVnaXN0ZXJlZC5gKSxufXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXtsZXQgcj10aGlzLmV4dGVybmFsQnVmZmVycy5nZXQodCk7ciE9PXZvaWQgMCYmKHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShyKSx0aGlzLmV4dGVybmFsQnVmZmVycy5kZWxldGUodCksRWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke3J9YCkpfWNyZWF0ZSh0LHI9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7bGV0IG89T3IodCksbixzPShyJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSx1PShyJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtpZihzfHx1KXtsZXQgYT1zP3RoaXMuZnJlZUJ1ZmZlcnM6dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMsbT1hLmdldChvKTttfHwobT1bXSxhLnNldChvLG0pKSxtLmxlbmd0aD4wP249bS5wb3AoKTpuPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm8sdXNhZ2U6cn0pfWVsc2Ugbj10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpvLHVzYWdlOnJ9KTtsZXQgZD17aWQ6X28oKSx0eXBlOjAsYnVmZmVyOm59O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZC5pZCx7Z3B1RGF0YTpkLG9yaWdpbmFsU2l6ZTp0fSksRWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3R9KSA9PiBpZD0ke2QuaWR9YCksZH1nZXQodCl7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KT8uZ3B1RGF0YX1yZWxlYXNlKHQpe2xldCByPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdFwiKTtyZXR1cm4gRWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7dH0pLCBncHVEYXRhSWQ9JHtyLmdwdURhdGEuaWR9YCksdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaChyLmdwdURhdGEuYnVmZmVyKSxyLm9yaWdpbmFsU2l6ZX1hc3luYyBkb3dubG9hZCh0LHIpe2xldCBvPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2F3YWl0IHluKHRoaXMuYmFja2VuZCxvLmdwdURhdGEuYnVmZmVyLG8ub3JpZ2luYWxTaXplLHIpfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nKXQuZGVzdHJveSgpO3RoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc9W107Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFP3RoaXMuZnJlZUJ1ZmZlcnMuZ2V0KHQuc2l6ZSkucHVzaCh0KToodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0/dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KHQuc2l6ZSkucHVzaCh0KTp0LmRlc3Ryb3koKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfWRpc3Bvc2UoKXt0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2godD0+e3QuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcH19LFJvPSguLi5lKT0+bmV3IGduKC4uLmUpfSk7dmFyIGJuLGllLFBlPUgoKCk9PntcInVzZSBzdHJpY3RcIjtibj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLl9jYWNoZUtleX19LGllPWU9Pm5ldyBibihlKX0pO3ZhciB3bixRZSxrLEN0LF9yLFJyLFByLGdlPUgoKCk9PntcInVzZSBzdHJpY3RcIjt3bj1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQscil7cmV0dXJuIHRbMV0hPT1yWzBdP3ZvaWQgMDpbdFswXSxyWzFdXX19LFFlPWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxyLG89ITEpe2xldCBuPXQubGVuZ3RoLHM9ci5sZW5ndGg7aWYobj09PTApcmV0dXJuIHI7aWYocz09PTApcmV0dXJuIHQ7bGV0IHU9TWF0aC5tYXgodC5sZW5ndGgsci5sZW5ndGgpLGQ9bmV3IEFycmF5KHUpO2lmKG8pe2lmKG48Mnx8czwyKXJldHVybjtsZXQgYT13bi5jYWxjTWF0TXVsU2hhcGUoW3Rbbi0yXSx0W24tMV1dLFtyW3MtMl0scltzLTFdXSk7aWYoYT09PXZvaWQgMClyZXR1cm47W2RbdS0yXSxkW3UtMV1dPWF9Zm9yKGxldCBhPW8/MzoxO2E8PXU7YSsrKXtsZXQgbT1uLWE8MD8xOnRbbi1hXSxnPXMtYTwwPzE6cltzLWFdO2lmKG0hPT1nJiZtPjEmJmc+MSlyZXR1cm47ZFt1LWFdPU1hdGgubWF4KG0sZyl9cmV0dXJuIGR9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxyKXtsZXQgbz10Lmxlbmd0aCxuPXIubGVuZ3RoO2lmKG8+bilyZXR1cm4hMTtmb3IobGV0IHM9MTtzPD1vO3MrKylpZih0W28tc10hPT0xJiZ0W28tc10hPT1yW24tc10pcmV0dXJuITE7cmV0dXJuITB9fSxrPWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscix0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAscil9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLG8pe2xldCBuPTE7Zm9yKGxldCBzPXI7czxvO3MrKyl7aWYodFtzXTwwKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7bio9dFtzXX1yZXR1cm4gbn1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IHI9dC5sZW5ndGg7aWYocj09PTApcmV0dXJuW107aWYocj09PTEpcmV0dXJuWzFdO2xldCBvPW5ldyBBcnJheShyKTtvW3ItMV09MSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgbj1yLTM7bj49MDstLW4pb1tuXT1vW24rMV0qdFtuKzFdO3JldHVybiBvfXN0YXRpYyBub3JtYWxpemVBeGlzKHQscil7aWYodDwtciYmdD49cil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K3I6dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LHIpe3JldHVybiB0Lm1hcChvPT50aGlzLm5vcm1hbGl6ZUF4aXMobyxyPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxyKXtyZXR1cm4gcj9yLm1hcChvPT50W29dKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LHIpe2xldCBvPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgobixzKT0+bityW3NdK3JbcytvXSl9c3RhdGljIGFyZUVxdWFsKHQscil7cmV0dXJuIHQubGVuZ3RoIT09ci5sZW5ndGg/ITE6dC5ldmVyeSgobyxuKT0+bz09PXJbbl0pfX0sQ3Q9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxyLG8sbixzLHUpe2lmKCF0JiZvLmxlbmd0aCE9PXIubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgZD0wO2Q8ci5sZW5ndGgtMjtkKyspZD49by5sZW5ndGg/by5wdXNoKHJbZCsyXSk6b1tkXT1yW2QrMl07Zm9yKGxldCBkPTA7ZDxvLmxlbmd0aDtkKyspaWYoZDxuLmxlbmd0aCl7aWYobltkXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugbi5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8by5sZW5ndGg7ZCsrKWlmKGQ8cy5sZW5ndGgpe2lmKHNbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugcy5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8by5sZW5ndGgqMjtkKyspaWYoZDx1Lmxlbmd0aCl7aWYodVtkXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSB1LnB1c2goMCk7Zm9yKGxldCBkPTA7ZDxvLmxlbmd0aDtkKyspe2lmKG9bZF08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKHVbZF0+PW9bZF18fHVbZCtvLmxlbmd0aF0+PW9bZF0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LHIsbyxuLHMsdSxkKXtpZihkKXtpZihzLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG4ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aC0yO2ErKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbYSsodT8xOjIpXSxyW2FdLG9bYV0sblthXSxzLGEsYSt0Lmxlbmd0aC0yLGQpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LHIsbyxuLHMsdSxkKXtpZihyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IGE9W3JbMF0sclsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQscixhLG8sbixzLHUsZCksYX1zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LHIsbyxuLHMsdSxkKXtpZih0Lmxlbmd0aDw9MHx8ci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgYT1bdFswXSxyWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxhLG8sbixzLHUsZCksYX1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQscixvLG4scyx1LGQsYSl7aWYodClmb3IobGV0IG09MDttPHIubGVuZ3RoLTI7bSsrKW8ucHVzaCgxKTtlbHNlIGZvcihsZXQgbT0wO208ci5sZW5ndGgtMjttKyspby5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoclttKzJdLG5bbV0sc1ttXSx1W21dLGQsbSxtK3IubGVuZ3RoLTIsYSkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LHIsbyxuLHMsdSxkLGEpe2xldCBtPW8qKG4tMSkrMTtpZihhJiZhIT09XCJOT1RTRVRcIilzd2l0Y2goYSl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gc1t1XT0wLHNbZF09MCxNYXRoLmZsb29yKCh0LW0pL3IrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihvIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCB4PSgodCtyLTEpL3ItMSkqcituLXQ7cmV0dXJuIHNbdV09TWF0aC5mbG9vcihhPT09XCJTQU1FX0xPV0VSXCI/KHgrMSkvMjp4LzIpLHNbZF09eC1zW3VdLE1hdGguZmxvb3IoKHQreC1uKS9yKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQrc1t1XStzW2RdLW0pL3IrMSl9fSxfcj1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxyLG8sbixzKXtpZih0Lmxlbmd0aCE9PTJ8fG8ubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgdSxkLGE7cj8odT10WzFdLGQ9dFswXSk6KHU9dFswXSxkPXRbMV0pO2xldCBtPS0xO2lmKG4/KGE9b1swXSxtPTEpOihhPW9bMV0sbT0wKSxvW21dIT09ZCl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYodTw9MHx8YTw9MHx8ZDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihzJiYhUWUuaXNWYWxpZEJyb2FkY2FzdChzLFt1LGFdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bdSxhLGRdfX0sUnI9LTM0MDI4MjM0NjYzODUyODg2ZTIyLFByPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIEx1LE1vLE1lLCRuLGx0LHFlLEF0LGh0LEJvLEwsWCx2bixrbyx4bixEbyx2ZT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO0x1PTY0LE1vPShlLHQpPT57aWYodD09PTMpdGhyb3cgbmV3IEVycm9yKFwidmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZFwiKTtzd2l0Y2goZSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHtlfWApfX0sTWU9KGUsdD0xKT0+e2xldCByPU1vKGUsdCk7cmV0dXJuIHR5cGVvZiByPT1cInN0cmluZ1wiP3I6clswXX0sJG49ZT0+W3t0eXBlOlwidWludDMyXCIsZGF0YTplfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6ay5jb21wdXRlU3RyaWRlcyhlKX1dLGx0PWU9PmUlND09PTA/NDplJTI9PT0wPzI6MSxxZT0oZT1cImYzMlwiLHQscj1cIjBcIik9PiF0fHx0PT09MT9gJHtlfSgke3J9KWA6YHZlYyR7dH08JHtlfT4oJHtyfSlgLEF0PShlLHQscik9PmU9PT1cImYzMlwiP3I6dD09PTE/YGYzMigke3J9KWA6YHZlYyR7dH1mKCR7cn0pYCxodD0oZSx0KT0+dD09PTQ/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnogKyAke2V9LncpYDp0PT09Mj9gKCR7ZX0ueCArICR7ZX0ueSlgOnQ9PT0zP2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56KWA6ZSxCbz0oZSx0LHIsbyxuKT0+e2xldCBzPXR5cGVvZiByPT1cIm51bWJlclwiLHU9cz9yOnIubGVuZ3RoLGQ9Wy4uLm5ldyBBcnJheSh1KS5rZXlzKCldLGE9dTwyP1widTMyXCI6dTw9ND9gdmVjJHt1fTx1MzI+YDpgYXJyYXk8dTMyLCAke3V9PmAsbT1Nbyh0LG4pLGc9dHlwZW9mIG09PVwic3RyaW5nXCI/bTptWzFdLHg9dHlwZW9mIG09PVwic3RyaW5nXCI/bTptWzBdLGI9e2luZGljZXM6YSx2YWx1ZTpnLHN0b3JhZ2U6eCx0ZW5zb3I6dH0sdz1OPT50eXBlb2YgTj09XCJzdHJpbmdcIj9OOmAke059dWAsdj17b2Zmc2V0VG9JbmRpY2VzOiExLGluZGljZXNUb09mZnNldDohMSxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDohMSxzZXQ6ITEsc2V0QnlJbmRpY2VzOiExLGdldDohMSxnZXRCeUluZGljZXM6ITF9LHk9cz9cInVuaWZvcm1zLlwiOlwiXCIsUz1gJHt5fSR7ZX1fc2hhcGVgLEE9YCR7eX0ke2V9X3N0cmlkZXNgLFI9XCJcIjtmb3IobGV0IE49MDtOPHUtMTtOKyspUis9YFxcbiAgICBsZXQgZGltJHtOfSA9IGN1cnJlbnQgLyAke0F9WyR7Tn1dO1xcbiAgICBsZXQgcmVzdCR7Tn0gPSBjdXJyZW50ICUgJHtBfVske059XTtcXG4gICAgaW5kaWNlc1ske059XSA9IGRpbSR7Tn07XFxuICAgIGN1cnJlbnQgPSByZXN0JHtOfTtcXG4gICAgYDtSKz1gaW5kaWNlc1ske3UtMX1dID0gY3VycmVudDtgO2xldCBXPXU8Mj9cIlwiOmBcXG4gIGZuIG8yaV8ke2V9KG9mZnNldDogdTMyKSAtPiAke2IuaW5kaWNlc30ge1xcbiAgICB2YXIgaW5kaWNlczogJHtiLmluZGljZXN9O1xcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcXG4gICAgJHtSfVxcbiAgICByZXR1cm4gaW5kaWNlcztcXG4gIH1gLE09Tj0+KHYub2Zmc2V0VG9JbmRpY2VzPSEwLHU8Mj9OOmBvMmlfJHtlfSgke059KWApLEQ9W107aWYodT49Milmb3IobGV0IE49dS0xO04+PTA7Ti0tKUQucHVzaChgJHtBfVske059XSAqIChpbmRpY2VzWyR7Tn1dKWApO2xldCBfPXU8Mj9cIlwiOmBcXG4gIGZuIGkyb18ke2V9KGluZGljZXM6ICR7Yi5pbmRpY2VzfSkgLT4gdTMyIHtcXG4gICAgcmV0dXJuICR7RC5qb2luKFwiK1wiKX07XFxuICB9YCx6PU49Pih2LmluZGljZXNUb09mZnNldD0hMCx1PDI/TjpgaTJvXyR7ZX0oJHtOfSlgKSxGPSguLi5OKT0+dT09PTA/XCIwdVwiOmAke2IuaW5kaWNlc30oJHtOLm1hcCh3KS5qb2luKFwiLFwiKX0pYCxxPShOLGRlKT0+dTwyP2Ake059YDpgJHtOfVske2RlfV1gLGxlPShOLGRlLHBlKT0+dTwyP2Ake059PSR7cGV9O2A6YCR7Tn1bJHtkZX1dPSR7cGV9O2AsQj17fSxLPShOLGRlKT0+e3YuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ9ITA7bGV0IHBlPWAke2RlLm5hbWV9YnJvYWRjYXN0ZWRJbmRpY2VzVG8ke2V9T2Zmc2V0YDtpZihwZSBpbiBCKXJldHVybmAke3BlfSgke059KWA7bGV0IHplPVtdO2ZvcihsZXQgVWU9dS0xO1VlPj0wO1VlLS0pe2xldCBUZT1kZS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFVlK2RlLnJhbmstdSk7emUucHVzaChgJHtxKEEsVWUpfSAqICgke1RlfSAlICR7cShTLFVlKX0pYCl9cmV0dXJuIEJbcGVdPWBmbiAke3BlfShvdXRwdXRJbmRpY2VzOiAke2RlLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XFxuICAgICAgICAgICAgIHJldHVybiAke3plLmxlbmd0aD4wP3plLmpvaW4oXCIrXCIpOlwiMHVcIn07XFxuICAgICAgICAgICB9YCxgJHtwZX0oJHtOfSlgfSx4ZT0oTixkZSk9PigoKT0+e2lmKGIuc3RvcmFnZT09PWIudmFsdWUpcmV0dXJuYCR7ZX1bJHtOfV09JHtkZX07YDtpZihiLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZiLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gJHtlfVske059XT12ZWMyPHUzMj4odTMyKCR7ZGV9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHtkZX0gPCAwKSk7YDtpZihiLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZiLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gJHtlfVske059XT12ZWMyPHUzMj4odTMyKCR7ZGV9KSwgMHUpO2A7aWYoYi5zdG9yYWdlPT09XCJ1MzJcIiYmYi52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmAke2V9WyR7Tn1dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7ZGV9KSk7YDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7Yi5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2IudmFsdWV9IHlldGApfSkoKSxhZT1OPT4oKCk9PntpZihiLnN0b3JhZ2U9PT1iLnZhbHVlKXJldHVybmAke2V9WyR7Tn1dYDtpZihiLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZiLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gaTMyKCR7ZX1bJHtOfV0ueClgO2lmKGIuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmIudmFsdWU9PT1cInUzMlwiKXJldHVybmB1MzIoJHtlfVske059XS54KWA7aWYoYi5zdG9yYWdlPT09XCJ1MzJcIiYmYi52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmB2ZWM0PGJvb2w+KGJvb2woJHtlfVske059XSAmIDB4RkZ1KSwgYm9vbCgke2V9WyR7Tn1dICYgMHhGRjAwdSksIGJvb2woJHtlfVske059XSAmIDB4RkYwMDAwdSksIGJvb2woJHtlfVske059XSAmIDB4RkYwMDAwMDB1KSlgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtiLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7Yi52YWx1ZX0geWV0YCl9KSgpLHdlPXU8Mj9cIlwiOmBcXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7Yi5pbmRpY2VzfSkgLT4gJHtnfSB7XFxuICAgIHJldHVybiAke2FlKGBpMm9fJHtlfShpbmRpY2VzKWApfTtcXG4gIH1gLGo9dTwyP1wiXCI6KCgpPT57bGV0IE49ZC5tYXAocGU9PmBkJHtwZX06IHUzMmApLmpvaW4oXCIsIFwiKSxkZT1kLm1hcChwZT0+YGQke3BlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXFxuICBmbiBnZXRfJHtlfSgke059KSAtPiAke2d9IHtcXG4gICAgcmV0dXJuIGdldF8ke2V9QnlJbmRpY2VzKCR7RihkZSl9KTtcXG4gIH1gfSkoKSxTZT0oLi4uTik9PntpZihOLmxlbmd0aCE9PXUpdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7dX1gKTtsZXQgZGU9Ti5tYXAodykuam9pbihcIixcIik7cmV0dXJuIHU9PT0wP2FlKFwiMHVcIik6dT09PTE/YWUoZGVbMF0pOih2LmdldD0hMCx2LmdldEJ5SW5kaWNlcz0hMCx2LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtkZX0pYCl9LE9lPU49PnU8Mj9hZShOKToodi5nZXRCeUluZGljZXM9ITAsdi5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9QnlJbmRpY2VzKCR7Tn0pYCksSWU9dTwyP1wiXCI6YFxcbiAgZm4gc2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtiLmluZGljZXN9LCB2YWx1ZTogJHtnfSkge1xcbiAgICAke3hlKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cXG4gIH1gLENlPXU8Mj9cIlwiOigoKT0+e2xldCBOPWQubWFwKHBlPT5gZCR7cGV9OiB1MzJgKS5qb2luKFwiLCBcIiksZGU9ZC5tYXAocGU9PmBkJHtwZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxcbiAgZm4gc2V0XyR7ZX0oJHtOfSwgdmFsdWU6ICR7Z30pIHtcXG4gICAgc2V0XyR7ZX1CeUluZGljZXMoJHtGKGRlKX0sIHZhbHVlKTtcXG4gIH1gfSkoKTtyZXR1cm57aW1wbDooKT0+e2xldCBOPVtdO3JldHVybiBzfHwoTi5wdXNoKGBjb25zdCAke1N9ID0gJHtiLmluZGljZXN9KCR7ci5qb2luKFwiLFwiKX0pO2ApLE4ucHVzaChgY29uc3QgJHtBfSA9ICR7Yi5pbmRpY2VzfSgke2suY29tcHV0ZVN0cmlkZXMocikuam9pbihcIixcIil9KTtgKSksdi5vZmZzZXRUb0luZGljZXMmJk4ucHVzaChXKSx2LmluZGljZXNUb09mZnNldCYmTi5wdXNoKF8pLHYuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQmJk9iamVjdC52YWx1ZXMoQikuZm9yRWFjaChkZT0+Ti5wdXNoKGRlKSksdi5zZXQmJk4ucHVzaChDZSksdi5zZXRCeUluZGljZXMmJk4ucHVzaChJZSksdi5nZXQmJk4ucHVzaChqKSx2LmdldEJ5SW5kaWNlcyYmTi5wdXNoKHdlKSxOLmpvaW4oYFxcbmApfSx0eXBlOmIsb2Zmc2V0VG9JbmRpY2VzOk0saW5kaWNlc1RvT2Zmc2V0OnosYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6SyxpbmRpY2VzOkYsaW5kaWNlc0dldDpxLGluZGljZXNTZXQ6bGUsc2V0OiguLi5OKT0+e2lmKE4ubGVuZ3RoIT09dSsxKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3V9YCk7bGV0IGRlPU5bdV07aWYodHlwZW9mIGRlIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcInZhbHVlIG11c3QgYmUgc3RyaW5nXCIpO2xldCBwZT1OLnNsaWNlKDAsdSkubWFwKHcpLmpvaW4oXCIsXCIpO3JldHVybiB1PT09MD94ZShcIjB1XCIsZGUpOnU9PT0xP3hlKHBlWzBdLGRlKToodi5zZXQ9ITAsdi5zZXRCeUluZGljZXM9ITAsdi5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9KCR7cGV9LCAke2RlfSlgKX0sc2V0QnlPZmZzZXQ6eGUsc2V0QnlJbmRpY2VzOihOLGRlKT0+dTwyP3hlKE4sZGUpOih2LnNldEJ5SW5kaWNlcz0hMCx2LmluZGljZXNUb09mZnNldD0hMCxgc2V0XyR7ZX1CeUluZGljZXMoJHtOfSwgJHtkZX0pO2ApLGdldDpTZSxnZXRCeU9mZnNldDphZSxnZXRCeUluZGljZXM6T2UsdXNhZ2U6bz9cImlucHV0XCI6XCJvdXRwdXRcIixuYW1lOmUsc3RyaWRlczpBLHNoYXBlOlMscmFuazp1fX0sTD0oZSx0LHIsbz0xKT0+Qm8oZSx0LHIsITAsbyksWD0oZSx0LHIsbz0xKT0+Qm8oZSx0LHIsITEsbyksdm49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cD10O3RoaXMuaW5kaWNlc0hlbHBlcnM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD1MdSl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdLHM9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLHU9cz9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gOmBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pbmRleCA6IHUzMixcXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj5gLGQ9cz9cImxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7XCI6YGxldCBnbG9iYWxfaWR4ID0gKHdvcmtncm91cF9pZC56ICogJHt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzBdKnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV19dSArXFxuICAgICAgICAgIHdvcmtncm91cF9pZC55ICogJHt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzBdfXUgKyB3b3JrZ3JvdXBfaWQueCkgKiAke3IqbypufXUgKyBsb2NhbF9pbmRleDtgO3JldHVybmBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtyfSwgJHtvfSwgJHtufSlcXG4gIGZuIG1haW4oJHt1fSkge1xcbiAgICAke2R9XFxuICBgfWRlY2xhcmVWYXJpYWJsZSh0LHIpe3RoaXMuaW5kaWNlc0hlbHBlcnMucHVzaCh0KSx0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOnQudHlwZS5pbmRpY2VzfSksdC5zdHJpZGVzLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnN0cmlkZXMucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6dC50eXBlLmluZGljZXN9KTtsZXQgbz10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLG49dC50eXBlLnN0b3JhZ2U7cmV0dXJuYEBncm91cCgwKSBAYmluZGluZygke3J9KSB2YXI8c3RvcmFnZSwgJHtvfT4gJHt0Lm5hbWV9OiBhcnJheTwke259PjtgfWRlY2xhcmVWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQubWFwKHI9PnRoaXMuZGVjbGFyZVZhcmlhYmxlKHIsdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKGBcXG5gKX1yZWdpc3RlclVuaWZvcm0odCxyKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQsdHlwZTpyfSksdGhpc311bmlmb3JtRGVjbGFyYXRpb24oKXtpZih0aGlzLnVuaWZvcm1zLmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgdD1bXTtmb3IobGV0e25hbWU6cix0eXBlOm99b2YgdGhpcy51bmlmb3Jtcyl0LnB1c2goYCR7cn06JHtvfWApO3JldHVybmBcXG4gICAgICBzdHJ1Y3QgVW5pZm9ybXMgeyAke3Quam9pbihcIiwgXCIpfSB9O1xcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YH1nZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpe3JldHVybiB0aGlzLnVuaWZvcm1EZWNsYXJhdGlvbigpK3RoaXMuaW5kaWNlc0hlbHBlcnMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcXG5gKX19LGtvPWU9Pm5ldyB2bihlKSx4bj0oZSx0KT0+e2xldCByPWUubGVuZ3RoLG89W107Zm9yKGxldCBuPTA7bjxyO24rKyl7bGV0IHM9ci0xLW4sdT1lW3NdfHwxOyh0W3QubGVuZ3RoLTEtbl18fDEpPjEmJnU9PT0xJiZvLnVuc2hpZnQocyl9cmV0dXJuIG99LERvPWU9PmU8PTR9KTt2YXIgRnUsV28sSHUsanUsZ3Qsem8sVm8scnI9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO0Z1PWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKX0sV289KGUsdCk9PnQmJnQubGVuZ3RoIT09ZT9bLi4ubmV3IEFycmF5KGUpLmtleXMoKV0ucmV2ZXJzZSgpOnQsSHU9KGUsdCk9Pmsuc29ydEJhc2VkT25QZXJtKGUsV28oZS5sZW5ndGgsdCkpLGp1PShlLHQscixvKT0+e2xldCBuPVtdO24ucHVzaChgZm4gcGVybShpOiAke28udHlwZS5pbmRpY2VzfSkgLT4gJHtyLnR5cGUuaW5kaWNlc30ge1xcbiAgICB2YXIgYTogJHtyLnR5cGUuaW5kaWNlc307YCk7Zm9yKGxldCBzPTA7czx0OysrcyluLnB1c2goci5pbmRpY2VzU2V0KFwiYVwiLGVbc10sYGlbJHtzfV1gKSk7cmV0dXJuIG4ucHVzaChcInJldHVybiBhO31cIiksbi5qb2luKGBcXG5gKX0sZ3Q9KGUsdCk9PntsZXQgcj1lLmRhdGFUeXBlLG89ZS5kaW1zLmxlbmd0aCxuPVdvKG8sdCkscz1EbyhvKSx1PUh1KGUuZGltcyxuKSxkPXM/dS5sZW5ndGg6dSxhPXM/bzplLmRpbXMsbT1YKFwib3V0cHV0XCIscixkKSxnPUwoXCJhXCIscixhKSx4PWI9PmBcXG4gICR7Yi5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZyxtKX1cXG5cXG4gICR7anUobixvLGcsbSl9XFxuXFxuICAke2IubWFpblN0YXJ0KCl9XFxuICAgICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XFxuXFxuICAgIGxldCBpbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xcblxcbiAgICAke20uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZy5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XFxuICB9YDtyZXR1cm57bmFtZTpcIlRyYW5zcG9zZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpzP1tcInJhbmtcIl06W1wiZGltc1wiXX0sZ2V0UnVuRGF0YTpiPT57bGV0IHc9ay5zaXplKHUpO3JldHVybntvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOmJbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh3LzY0KX0scHJvZ3JhbVVuaWZvcm1zOnM/W3t0eXBlOlwidWludDMyXCIsZGF0YTp3fSwuLi4kbihiWzBdLmRpbXMpLC4uLiRuKHUpXTpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOnd9XX19LGdldFNoYWRlclNvdXJjZTp4fX0sem89KGUsdCk9PntGdShlLmlucHV0cyksZS5jb21wdXRlKGd0KGUuaW5wdXRzWzBdLHQucGVybSkpfSxWbz1lPT5pZSh7cGVybTplLnBlcm19KX0pO3ZhciBLdSxxdSxZdSxYdSxKdSxadSxRdSxlbCx0bCxybCxldCxHbyxObyxVbyxMbyxGbyxIbyxqbyxLbyxxbyxZbyxYbz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO01yKCk7cnIoKTtLdT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxxdT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LFl1PXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LFh1PXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0sSnU9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG89dC1lO288dDsrK28pci5wdXNoKG8pO3JldHVybiByfSxadT0oZSx0KT0+e2xldCByPVtdLG89ZS5sZW5ndGg7Zm9yKGxldCBzPTA7czxvO3MrKyl0LmluZGV4T2Yocyk9PT0tMSYmci5wdXNoKGVbc10pO2xldCBuPXQubWFwKHM9PmVbc10pO3JldHVybltyLG5dfSxRdT0oZSx0KT0+e2xldCByPWUubGVuZ3RoK3QubGVuZ3RoLG89W10sbj0wO2ZvcihsZXQgcz0wO3M8cjtzKyspdC5pbmRleE9mKHMpPT09LTE/by5wdXNoKGVbbisrXSk6by5wdXNoKDEpO3JldHVybiBvfSxlbD0oZSx0KT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKGVbZS5sZW5ndGgtci0xXSE9PXQtMS1yKXJldHVybiExO3JldHVybiEwfSx0bD0oZSx0KT0+e2xldCByPVtdO2lmKCFlbChlLHQpKXtmb3IobGV0IG89MDtvPHQ7KytvKWUuaW5kZXhPZihvKT09PS0xJiZyLnB1c2gobyk7ZS5mb3JFYWNoKG89PnIucHVzaChvKSl9cmV0dXJuIHJ9LHJsPShlLHQscixvLG4scyx1KT0+e2xldCBkPXJbMF0uZGltcyxhPWsuc2l6ZShzKSxtPWsuc2l6ZSh1KSxnPUwoXCJfQVwiLHJbMF0uZGF0YVR5cGUsZCkseD1YKFwib3V0cHV0XCIsbixzKSxiPTMyLHc9YFxcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PCR7eC50eXBlLnN0b3JhZ2V9LCAke2J9PjtcXG4gICAgICAgYDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOnk9PmBcXG4gICAgICAgICR7eS5yZWdpc3RlclVuaWZvcm0oXCJyZWR1Y2VTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhnLHgpfVxcbiAgICAgICAgJHt3fVxcbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcXG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XFxuICAgICAgICAgfVxcbiAgICAgICAgICR7eS5tYWluU3RhcnQoYil9XFxuICAgICAgICAgIGxldCBsb2NhbF9pZHggPSBsb2NhbF9pZC54O1xcblxcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtifTtcXG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcXG5cXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9ICR7eC50eXBlLnN0b3JhZ2V9KCR7WXVbb119KTtcXG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XFxuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHtifSkge1xcbiAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9ICR7eC50eXBlLnN0b3JhZ2V9KCR7Zy5nZXRCeU9mZnNldChcIm9mZnNldCArIGtcIil9KTtcXG4gICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7S3Vbb119O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XFxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7Yn11KTtcXG4gICAgICAgICBmb3IgKHZhciBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydTsgcmVkdWNlU2l6ZSA+IDF1O1xcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xcbiAgICAgICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJlbnRTaXplKSB7XFxuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke3F1W29dfTtcXG4gICAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xcbiAgICAgICAgICAgfVxcbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICAgICAgIH1cXG5cXG4gICAgICAgICBpZiAobG9jYWxfaWR4ID09IDB1KSB7XFxuICAgICAgICAgICR7eC5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7bz09PVwibWVhblwiP2BiZXN0VmFsdWUgLyAke3gudHlwZS5zdG9yYWdlfSh1bmlmb3Jtcy5yZWR1Y2VTaXplKWA6YCR7WHVbb119YH1gKX07XFxuICAgICAgICAgfVxcbiAgICAgICAgfWAsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4OmF9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOm19XX0pfX0sZXQ9KGUsdCxyLG8pPT57bGV0IG49ZS5pbnB1dHMubGVuZ3RoPT09MT9yOlNuKGUuaW5wdXRzLHIpLHM9bi5heGVzO3MubGVuZ3RoPT09MCYmIW4ubm9vcFdpdGhFbXB0eUF4ZXMmJihzPWUuaW5wdXRzWzBdLmRpbXMubWFwKCh3LHYpPT52KSk7bGV0IHU9ay5ub3JtYWxpemVBeGVzKHMsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpLGQ9dSxhPWUuaW5wdXRzWzBdLG09dGwoZCxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCk7bS5sZW5ndGg+MCYmKGE9ZS5jb21wdXRlKGd0KGUuaW5wdXRzWzBdLG0pLHtpbnB1dHM6WzBdLG91dHB1dHM6Wy0xXX0pWzBdLGQ9SnUoZC5sZW5ndGgsYS5kaW1zLmxlbmd0aCkpO2xldFtnLHhdPVp1KGEuZGltcyxkKSxiPWc7bi5rZWVwRGltcyYmKGI9UXUoZyx1KSksZS5jb21wdXRlKHJsKHQse2hpbnQ6bi5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxbYV0sbyxlLmlucHV0c1swXS5kYXRhVHlwZSxiLHgpLHtpbnB1dHM6W2FdfSl9LEdvPShlLHQpPT57ZXQoZSxcIlJlZHVjZU1lYW5TaGFyZWRcIix0LFwibWVhblwiKX0sTm89KGUsdCk9PntldChlLFwiUmVkdWNlTDFTaGFyZWRcIix0LFwibDFcIil9LFVvPShlLHQpPT57ZXQoZSxcIlJlZHVjZUwyU2hhcmVkXCIsdCxcImwyXCIpfSxMbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VMb2dTdW1FeHBTaGFyZWRcIix0LFwibG9nU3VtRXhwXCIpfSxGbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VNYXhTaGFyZWRcIix0LFwibWF4XCIpfSxIbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VNaW5TaGFyZWRcIix0LFwibWluXCIpfSxqbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VQcm9kU2hhcmVkXCIsdCxcInByb2RcIil9LEtvPShlLHQpPT57ZXQoZSxcIlJlZHVjZVN1bVNoYXJlZFwiLHQsXCJzdW1cIil9LHFvPShlLHQpPT57ZXQoZSxcIlJlZHVjZVN1bVNxdWFyZVNoYXJlZFwiLHQsXCJzdW1TcXVhcmVcIil9LFlvPShlLHQpPT57ZXQoZSxcIlJlZHVjZUxvZ1N1bVNoYXJlZFwiLHQsXCJsb2dTdW1cIil9fSk7dmFyIHR0LG5sLEJyLFNuLHJ0LG9sLGFsLGlsLHNsLHVsLGxsLGRsLGNsLHBsLGZsLG50LEpvLFpvLFFvLGVhLHRhLHJhLG5hLG9hLGFhLGlhLFllLE1yPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtYbygpO3R0PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sbmw9ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJcIl0sQnI9KGUsdCxyLG8sbixzLHU9ITEsZD0hMSk9PntsZXQgYT1bXSxtPXJbMF0uZGltcyxnPWsubm9ybWFsaXplQXhlcyhuLHJbMF0uZGltcy5sZW5ndGgpLHg9IWQmJmcubGVuZ3RoPT09MDttLmZvckVhY2goKHosRik9Pnt4fHxnLmluZGV4T2YoRik+PTA/dSYmYS5wdXNoKDEpOmEucHVzaCh6KX0pO2xldCBiPVtdLHc9TChcIl9BXCIsclswXS5kYXRhVHlwZSxtKSx2PVgoXCJvdXRwdXRcIixzLGEpLHk9byh3LHYsZyksUz1gaW5wdXRPZmZzZXQgPSAke3cuaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzXCIpfTtgLEE9YGxldCAke1N9O2AsUj1gdmFyICR7U307YCxXPXlbMV09PT1cIlwiP1wiXCI6UixNPSh5WzFdPT09XCJcIj9BOlMpK2BcXG5gK3lbMl07Zm9yKGxldCB6PTAsRj0wO3o8clswXS5kaW1zLmxlbmd0aDt6KyspeHx8Zy5pbmRleE9mKHopPj0wPyh1JiZGKyssTT1gZm9yKHZhciBqJHt6fTogdTMyID0gMDsgaiR7en0gPCAke3JbMF0uZGltc1t6XX07IGoke3p9KyspIHtcXG4gICAgICAgICAgICAgICAgJHt5WzJdLmluY2x1ZGVzKFwibGFzdEluZGV4XCIpP2BsZXQgbGFzdEluZGV4ID0gaiR7en07YDpcIlwifVxcbiAgICAgICAgICAgICAgICAke3cuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLHosYGoke3p9YCl9XFxuICAgICAgICAgICAgICAgICR7TX1cXG4gICAgICAgICAgICAgIH1gKTooYi5wdXNoKGAke3cuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLHosdi5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEYpKX07YCksRisrKTtsZXQgRD1rLnNpemUoYSk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTp6PT5gXFxuICAgICAgICAke3ouZGVjbGFyZVZhcmlhYmxlcyh3LHYpfVxcblxcbiAgICAgICAgJHt6Lm1haW5TdGFydCgpfVxcbiAgICAgICAgICAke3ouZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhEKX1cXG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHt3LnR5cGUuaW5kaWNlc307XFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt2Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcblxcbiAgICAgICAgICAke2Iuam9pbihgXFxuYCl9XFxuICAgICAgICAgICR7eVswXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXFxuICAgICAgICAgICR7V31cXG4gICAgICAgICAgJHt5WzFdfVxcbiAgICAgICAgICAke019XFxuICAgICAgICAgICR7eVszXX1cXG4gICAgICAgICAgJHt5Lmxlbmd0aD09PTQ/di5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpOnkuc2xpY2UoNCkuam9pbihgXFxuYCl9XFxuICAgICAgICB9YCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEQvNjQpfX0pfX0sU249KGUsdCk9PntsZXQgcj1bXTtyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJmVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobz0+ci5wdXNoKE51bWJlcihvKSkpLGllKHtheGVzOnIsa2VlcERpbXM6dC5rZWVwRGltcyxub29wV2l0aEVtcHR5QXhlczp0Lm5vb3BXaXRoRW1wdHlBeGVzfSl9LHJ0PShlLHQscixvKT0+e2xldCBuPWUuaW5wdXRzLHM9bi5sZW5ndGg9PT0xP3I6U24obixyKTtlLmNvbXB1dGUoQnIodCx7aGludDpzLmNhY2hlS2V5fSxbblswXV0scy5ub29wV2l0aEVtcHR5QXhlcyYmcy5heGVzLmxlbmd0aD09PTA/bmw6byxzLmF4ZXMsblswXS5kYXRhVHlwZSxzLmtlZXBEaW1zLHMubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LG9sPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VMb2dTdW1cIix0LChvLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sYWw9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZUwxXCIsdCwobyxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJcIl0pfSxpbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlTDJcIix0LChvLG4pPT5bYHZhciB0ID0gJHtuLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke24udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LHNsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChvLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSx1bD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlTWF4XCIsdCwobyxuLHMpPT57bGV0IHU9W107Zm9yKGxldCBkPTA7ZDxvLnJhbms7ZCsrKShzLmluZGV4T2YoZCk+PTB8fHMubGVuZ3RoPT09MCkmJnUucHVzaChvLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixkLDApKTtyZXR1cm5bYCR7dS5qb2luKGBcXG5gKX1gLGB2YXIgdmFsdWUgPSAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcIlwiXX0pfSxsbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlTWVhblwiLHQsKG8sbixzKT0+e2xldCB1PTE7Zm9yKGxldCBkPTA7ZDxvLnJhbms7ZCsrKShzLmluZGV4T2YoZCk+PTB8fHMubGVuZ3RoPT09MCkmJih1Kj1lLmlucHV0c1swXS5kaW1zW2RdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLGBsZXQgdmFsdWUgPSAke24udHlwZS52YWx1ZX0oc3VtIC8gJHt1fSk7YF19KX0sZGw9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZU1pblwiLHQsKG8sbixzKT0+e2xldCB1PVtdO2ZvcihsZXQgZD0wO2Q8by5yYW5rO2QrKykocy5pbmRleE9mKGQpPj0wfHxzLmxlbmd0aD09PTApJiZ1LnB1c2goYGlucHV0SW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake3Uuam9pbihgXFxuYCl9YCxgdmFyIHZhbHVlID0gJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJcIl19KX0sY2w9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZVByb2RcIix0LChvLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJcIl0pfSxwbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlU3VtXCIsdCwobyxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwiXCJdKX0sZmw9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKG8sbik9PltgdmFyIHQgPSAke24udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7bi50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxudD0oZSx0LHIpPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiEhcjtsZXQgbz0xLG49MTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl0LmluZGV4T2Yocyk9PT0tMT9vKj1lW3NdOm4qPWVbc107cmV0dXJuIG48MzImJm8+MTAyNH0sSm89KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9sbChlLHQpOkdvKGUsdCl9LFpvPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/YWwoZSx0KTpObyhlLHQpfSxRbz0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2lsKGUsdCk6VW8oZSx0KX0sZWE9KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9zbChlLHQpOkxvKGUsdCl9LHRhPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/dWwoZSx0KTpGbyhlLHQpfSxyYT0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2RsKGUsdCk6SG8oZSx0KX0sbmE9KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9jbChlLHQpOmpvKGUsdCl9LG9hPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/cGwoZSx0KTpLbyhlLHQpfSxhYT0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2ZsKGUsdCk6cW8oZSx0KX0saWE9KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9vbChlLHQpOllvKGUsdCl9LFllPWU9PmllKGUpfSk7dmFyIHNhLHVhLGxhLGRhLENuLGNhPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO1BlKCk7TXIoKTtzYT1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSx1YT0oZSx0KT0+aWUoe2F4aXM6dC5heGlzLGtlZXBEaW1zOnQua2VlcERpbXMsc2VsZWN0TGFzdEluZGV4OnQuc2VsZWN0TGFzdEluZGV4fSksbGE9KGUsdCk9PntzYShlLmlucHV0cyk7bGV0IHI9KG4scyx1KT0+e2xldCBkPVtdO2ZvcihsZXQgYT0wO2E8bi5yYW5rO2ErKykodS5pbmRleE9mKGEpPj0wfHx1Lmxlbmd0aD09PTApJiZkLnB1c2goYGlucHV0SW5kaWNlc1ske2F9XSA9IDA7YCk7cmV0dXJuW2Ake2Quam9pbihgXFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xcbnZhciBiZXN0SW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPD1cIjpcIjxcIn0gdmFsdWUpIHtcXG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcXG4gICAgICAgICBiZXN0SW5kZXggPSBpMzIobGFzdEluZGV4KTtcXG4gICAgICAgfWAsXCJcIixzLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdEluZGV4XCIpXX0sbz1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6dWEoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKEJyKFwiQXJnTWluXCIse2hpbnQ6by5jYWNoZUtleX0sW2UuaW5wdXRzWzBdXSxyLFtvLmF4aXNdLDcsby5rZWVwRGltcykse2lucHV0czpbMF19KX0sZGE9KGUsdCk9PntzYShlLmlucHV0cyk7bGV0IHI9KG4scyx1KT0+e2xldCBkPVtdO2ZvcihsZXQgYT0wO2E8bi5yYW5rO2ErKykodS5pbmRleE9mKGEpPj0wfHx1Lmxlbmd0aD09PTApJiZkLnB1c2goYGlucHV0SW5kaWNlc1ske2F9XSA9IDA7YCk7cmV0dXJuW2Ake2Quam9pbihgXFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xcbnZhciBiZXN0SW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPj1cIjpcIj5cIn0gdmFsdWUpIHtcXG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcXG4gICAgICAgICBiZXN0SW5kZXggPSBpMzIobGFzdEluZGV4KTtcXG4gICAgICAgfWAsXCJcIixzLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdEluZGV4XCIpXX0sbz1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6dWEoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKEJyKFwiYXJnTWF4XCIse2hpbnQ6by5jYWNoZUtleX0sW2UuaW5wdXRzWzBdXSxyLFtvLmF4aXNdLDcsby5rZWVwRGltcykse2lucHV0czpbMF19KX0sQ249ZT0+aWUoZSl9KTt2YXIgbWwsaGwscGEsZmE9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTttbD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMzIwLDY0MCwxMjgwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcIm51bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxobD1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9ZVswXS5kaW1zWzJdLG89ay5zaXplKHQpLzQsbj1lWzBdLmRhdGFUeXBlLHM9TChcImlucHV0XCIsbix0LDQpLHU9TChcImJpYXNcIixuLFtyXSw0KSxkPUwoXCJyZXNpZHVhbFwiLG4sdCw0KSxhPVgoXCJvdXRwdXRcIixuLHQsNCk7cmV0dXJue25hbWU6XCJCaWFzQWRkXCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6Zz0+YFxcbiAgY29uc3QgY2hhbm5lbHMgPSAke3J9dSAvIDQ7XFxuICAke2cuZGVjbGFyZVZhcmlhYmxlcyhzLHUsZCxhKX1cXG5cXG4gICR7Zy5tYWluU3RhcnQoKX1cXG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobyl9XFxuICAgIGxldCB2YWx1ZSA9ICR7cy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9XFxuICAgICAgKyAke3UuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICR7YS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxcbiAgfWB9fSxwYT1lPT57bWwoZS5pbnB1dHMpLGUuY29tcHV0ZShobChlLmlucHV0cykpfX0pO3ZhciBnbCwkZSxtYSxoYSxnYSx5YSxiYSx3YSx2YSwkYSx4YSxBbix5bCxTYSxDYSxBYSxJYSxrcixFYSxEcixUYSxPYSxfYSxSYSxQYSxNYSxCYSxrYSxEYSxXYSx6YSxWYSxHYSxOYSxVYSxMYSxGYSxJbj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO1BlKCk7dmUoKTtnbD0oZSx0LHIsbyxuLHMpPT57bGV0IHU9TWF0aC5jZWlsKHQvNCksZD1cIlwiO3R5cGVvZiBuPT1cInN0cmluZ1wiP2Q9YCR7bn0oYSlgOmQ9bihcImFcIik7bGV0IGE9TChcImlucHV0RGF0YVwiLHIsW3VdLDQpLG09WChcIm91dHB1dERhdGFcIixvLFt1XSw0KTtyZXR1cm5gXFxuICAke2UuZGVjbGFyZVZhcmlhYmxlcyhhLG0pfVxcblxcbiAgJHtzPz9cIlwifVxcblxcbiAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cXG5cXG4gICAgbGV0IGEgPSAke2EuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgJHttLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGQpfVxcbiAgfWB9LCRlPShlLHQscixvLG4scz1lLmRhdGFUeXBlKT0+KHtuYW1lOnQsc2hhZGVyQ2FjaGU6e2hpbnQ6bn0sZ2V0U2hhZGVyU291cmNlOnU9PmdsKHUsay5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxzLHIsbyksZ2V0UnVuRGF0YTp1PT4oe291dHB1dHM6W3tkaW1zOmUuZGltcyxkYXRhVHlwZTpzfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoay5zaXplKHVbMF0uZGltcykvNjQvNCl9fSl9KSxtYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQWJzXCIsXCJhYnNcIikpfSxoYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQWNvc1wiLFwiYWNvc1wiKSl9LGdhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBY29zaFwiLFwiYWNvc2hcIikpfSx5YT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXNpblwiLFwiYXNpblwiKSl9LGJhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBc2luaFwiLFwiYXNpbmhcIikpfSx3YT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXRhblwiLFwiYXRhblwiKSl9LHZhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBdGFuaFwiLFwiYXRhbmhcIikpfSwkYT1lPT5pZShlKSx4YT0oZSx0KT0+e2xldCByO3N3aXRjaCh0LnRvKXtjYXNlIDEwOnI9XCJ2ZWM0PGYxNj5cIjticmVhaztjYXNlIDE6cj1cInZlYzQ8ZjMyPlwiO2JyZWFrO2Nhc2UgMTI6cj1cInZlYzQ8dTMyPlwiO2JyZWFrO2Nhc2UgNjpyPVwidmVjNDxpMzI+XCI7YnJlYWs7Y2FzZSA5OnI9XCJ2ZWM0PGJvb2w+XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlIFxcJ3RvXFwnIGZyb20gXFwnQ2FzdFxcJyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDYXN0XCIscix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LEFuPShlLHQpPT57bGV0IHI9TWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNsaXBcIixvPT5gY2xhbXAoJHtvfSwgY2xpcF9taW5fLCBjbGlwX21heF8pYCxgXFxuICAgIGNvbnN0IGNsaXBfbWluXzogdmVjNDwke3J9PiA9IHZlYzQoJHtyfSgke3QubWlufSkpO1xcbiAgICBjb25zdCBjbGlwX21heF86IHZlYzQ8JHtyfT4gPSB2ZWM0KCR7cn0oJHt0Lm1heH0pKTtcXG5gLHQuY2FjaGVLZXkpLHtpbnB1dHM6WzBdfSl9LHlsPWU9PntsZXQgdD1lLmxlbmd0aD49Mj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOlJyLHI9ZS5sZW5ndGg+PTM/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTpQcjtyZXR1cm4gaWUoe21pbjp0LG1heDpyfSl9LFNhPWU9PntsZXQgdD15bChlLmlucHV0cyk7QW4oZSx0KX0sQ2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNlaWxcIixcImNlaWxcIikpfSxBYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ29zXCIsXCJjb3NcIikpfSxJYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ29zaFwiLFwiY29zaFwiKSl9LGtyPWU9PmllKGUpLEVhPShlLHQpPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRWx1XCIscj0+YGVsdV92ZjMyKCR7cn0pYCxgXFxuICBjb25zdCBlbHVfYWxwaGFfOiBmMzIgPSBmMzIoJHt0LmFscGhhfSk7XFxuXFxuICBmbiBlbHVfZjMyKGE6IGYzMikgLT4gZjMyIHtcXG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XFxuICB9XFxuXFxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPiB7XFxuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xcbiAgfWAsdC5jYWNoZUtleSkpfSxEcj0oZSx0PVwiZjMyXCIpPT5gXFxuY29uc3QgcjA6ICR7dH0gPSAwLjMyNzU5MTE7XFxuY29uc3QgcjE6ICR7dH0gPSAwLjI1NDgyOTU5MjtcXG5jb25zdCByMjogJHt0fSA9IC0wLjI4NDQ5NjczNjtcXG5jb25zdCByMzogJHt0fSA9IDEuNDIxNDEzNzQxO1xcbmNvbnN0IHI0OiAke3R9ID0gLTEuNDUzMTUyMDI3O1xcbmNvbnN0IHI1OiAke3R9ID0gMS4wNjE0MDU0Mjk7XFxuXFxuZm4gZXJmX3ZmMzIodjogJHtlfSkgLT4gJHtlfSB7XFxuICBsZXQgYWJzdiA9IGFicyh2KTtcXG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XFxuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcXG59YCxUYT1lPT57bGV0IHQ9TWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkVyZlwiLHI9PmBlcmZfdmYzMigke3J9KWAsRHIoYHZlYzQ8JHt0fT5gLHQpKSl9LE9hPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LF9hPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxSYT1lPT57bGV0IHQ9TWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkdlbHVcIixyPT5gMC41ICogJHtyfSAqICgxLjAgKyBlcmZfdmYzMigke3J9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLERyKGB2ZWM0PCR7dH0+YCx0KSkpfSxQYT0oZSx0KT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLHI9PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke3J9LCAke3J9LCAke3J9ID49IHZlYzQ8ZjMyPigwLjApKWAsYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfOiBmMzIgPSBmMzIoJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LE1hPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LEJhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LGthPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxEYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiUmVsdVwiLHQ9PmBzZWxlY3QodmVjNDxmMzI+KDAuMCksICR7dH0sICR7dH0gPiB2ZWM0PGYzMj4oMC4wKSlgKSl9LFdhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSx6YT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxWYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LEdhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0sTmE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0sVWE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlRhbmhcIixcInRhbmhcIikpfSxMYT0oZSx0KT0+KGUuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlRocmVzaG9sZGVkUmVsdVwiLHI9PmBzZWxlY3QodmVjNDxmMzI+KDAuMCksICR7cn0sICR7cn0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXzogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpLDApLEZhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJMb2dcIixcImxvZ1wiKSl9fSk7dmFyIHdsLHZsLEhhLGphPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7SW4oKTt3bD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSx2bD1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IHI9TChcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCksbz1MKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbj1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLHM9ay5zaXplKHQpLzQ7cmV0dXJue25hbWU6XCJCaWFzU3BsaXRHZWx1XCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6ZD0+YFxcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcXG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xcblxcbiAgJHtkLmRlY2xhcmVWYXJpYWJsZXMocixvLG4pfVxcblxcbiAgJHtEcihcInZlYzRmXCIpfVxcblxcbiAgJHtkLm1haW5TdGFydCgpfVxcbiAgICAke2QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzKX1cXG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xcbiAgICBsZXQgYmF0Y2hJbmRleCA9IGdsb2JhbF9pZHggLyBoYWxmQ2hhbm5lbHM7XFxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcXG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XFxuICAgIGxldCB2YWx1ZVJpZ2h0ID0gaW5wdXRbaW5wdXRPZmZzZXQgKyBoYWxmQ2hhbm5lbHNdICsgYmlhc1tiaWFzSWR4ICsgaGFsZkNoYW5uZWxzXTtcXG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XFxuXFxuICAgICR7bi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlTGVmdCAqIGdlbHVSaWdodFwiKX1cXG4gIH1gfX0sSGE9ZT0+e3dsKGUuaW5wdXRzKSxlLmNvbXB1dGUodmwoZS5pbnB1dHMpKX19KTt2YXIgJGwseGwsb3QsS2EscWEsWWEsWGEsSmEsWmEsUWEsZWksdGkscmksbmk9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTt2ZSgpOyRsPShlLHQscixvLG4scyx1LGQsYSxtLGcpPT57bGV0IHg9ay5zaXplKG8pLGI9TWF0aC5jZWlsKHgvNCksdyx2O3R5cGVvZiB1PT1cInN0cmluZ1wiP3c9dj0oTSxEKT0+YCR7dX0oKCR7TX0pLCgke0R9KSlgOnR5cGVvZiB1PT1cImZ1bmN0aW9uXCI/dz12PXU6KHc9dS5zY2FsYXIsdj11LnZlY3Rvcik7bGV0IHk9XCJcIixTPVgoXCJvdXRwdXREYXRhXCIsbSxvLDQpLEE9TChcImFEYXRhXCIsZCx0LDQpLFI9TChcImJEYXRhXCIsYSxyLDQpO2lmKHMpe2xldCBNPUQ9PntsZXQgXz1rLmNvbXB1dGVTdHJpZGVzKEQpLHo9W107Zm9yKGxldCBGPUQubGVuZ3RoLTE7Rj49MDtGLS0pe2xldCBxPVMuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixGK28ubGVuZ3RoLUQubGVuZ3RoKTt6LnB1c2goYCR7X1tGXX11ICogKCR7cX0gJSAke0RbRl19dSlgKX1yZXR1cm4gei5sZW5ndGg+MD96LmpvaW4oXCIrXCIpOlwiMHVcIn07eT1gXFxuICAgICAgICAgIGZuIGNhbGNPZmZzZXRBKG91dHB1dEluZGljZXM6ICR7Uy50eXBlLmluZGljZXN9KSAtPiB1MzIge1xcbiAgICAgICAgICAgIHJldHVybiAke00odCl9O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZuIGNhbGNPZmZzZXRCKG91dHB1dEluZGljZXM6ICR7Uy50eXBlLmluZGljZXN9KSAtPiB1MzIge1xcbiAgICAgICAgICAgIHJldHVybiAke00ocil9O1xcbiAgICAgICAgICB9XFxuICAgICAgICBgfWxldCBXO2lmKG4paWYocyl7bGV0IE09ay5zaXplKHQpPT09MSxEPWsuc2l6ZShyKT09PTE7TXx8RD9XPVMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdihNP2Ake0EudHlwZS52YWx1ZX0oJHtBLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOkEuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLEQ/YCR7Ui50eXBlLnZhbHVlfSgke1IuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6Ui5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTpXPWBcXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4ICogNHVcIil9O1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRBID0gY2FsY09mZnNldEEob3V0cHV0SW5kaWNlcyk7XFxuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSBjYWxjT2Zmc2V0QihvdXRwdXRJbmRpY2VzKTtcXG4gICAgICAgICAgICAke1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdihBLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QSAvIDR1XCIpLFIuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIikpKX1cXG4gICAgICAgICAgYH1lbHNlIFc9Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix2KEEuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFIuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJubyBuZWNlc3NhcnkgdG8gdXNlIHNjYWxhciBpbXBsZW1lbnRhdGlvbiBmb3IgZWxlbWVudC13aXNlIGJpbmFyeSBvcCBpbXBsZW1lbnRhdGlvbi5cIik7bGV0IE09KEQsXyx6PVwiXCIpPT57bGV0IEY9YGFEYXRhW2luZGV4QSR7X31dW2NvbXBvbmVudEEke199XWAscT1gYkRhdGFbaW5kZXhCJHtffV1bY29tcG9uZW50QiR7X31dYDtyZXR1cm5gXFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke199ID0gJHtTLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtffXVgKX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldEEke199ID0gY2FsY09mZnNldEEob3V0cHV0SW5kaWNlcyR7X30pO1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHtffSA9IGNhbGNPZmZzZXRCKG91dHB1dEluZGljZXMke199KTtcXG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtffSA9IG9mZnNldEEke199IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGluZGV4QiR7X30gPSBvZmZzZXRCJHtffSAvIDR1O1xcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHtffSA9IG9mZnNldEEke199ICUgNHU7XFxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke199ID0gb2Zmc2V0QiR7X30gJSA0dTtcXG4gICAgICAgICAgICAke0R9WyR7X31dID0gJHt6fSgke3coRixxKX0pO1xcbiAgICAgICAgICBgfTttPT09OT9XPWBcXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcXG4gICAgICAgICAgICAke00oXCJkYXRhXCIsMCxcInUzMlwiKX1cXG4gICAgICAgICAgICAke00oXCJkYXRhXCIsMSxcInUzMlwiKX1cXG4gICAgICAgICAgICAke00oXCJkYXRhXCIsMixcInUzMlwiKX1cXG4gICAgICAgICAgICAke00oXCJkYXRhXCIsMyxcInUzMlwiKX1cXG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6Vz1gXFxuICAgICAgICAgICAgJHtNKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxcbiAgICAgICAgICAgICR7TShcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwxKX1cXG4gICAgICAgICAgICAke00oXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMil9XFxuICAgICAgICAgICAgJHtNKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxcbiAgICAgICAgICBgfXJldHVybmBcXG4gICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKEEsUixTKX1cXG5cXG4gICAgICAgICR7Zz8/XCJcIn1cXG4gICAgICAgICR7eX1cXG5cXG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGIpfVxcbiAgICAgICAgJHtXfVxcbiAgICAgIH1gfSx4bD0oZSx0LHIsbyxuLHMsdT1yLmRhdGFUeXBlKT0+e2xldCBkPSFrLmFyZUVxdWFsKHIuZGltcyxvLmRpbXMpLGE9ci5kaW1zLG09ay5zaXplKHIuZGltcyksZz0hMTtpZihkKXtsZXQgeD1RZS5jYWxjU2hhcGUoci5kaW1zLG8uZGltcywhMSk7aWYoIXgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTthPXgsbT1rLnNpemUoYSk7bGV0IGI9ay5zaXplKHIuZGltcyk9PT0xLHc9ay5zaXplKG8uZGltcyk9PT0xLHY9MTtmb3IobGV0IHk9MTt5PGEubGVuZ3RoO3krKyl7bGV0IFM9ci5kaW1zW3IuZGltcy5sZW5ndGgteV0/PzEsQT1vLmRpbXNbby5kaW1zLmxlbmd0aC15XT8/MTtpZihTPT09QSl2Kj1TO2Vsc2UgYnJlYWt9KHYlND09PTB8fGJ8fHcpJiYoZz0hMCl9ZWxzZSBnPSEwO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6dH0sZ2V0U2hhZGVyU291cmNlOng9PiRsKHgsci5kaW1zLG8uZGltcyxhLGcsZCxuLHIuZGF0YVR5cGUsby5kYXRhVHlwZSx1LHMpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NC80KX19KX19LG90PShlLHQscixvLG4scyk9PntlLmNvbXB1dGUoeGwodCxuPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLHIsbyxzKSl9LEthPWU9PntvdChlLFwiQWRkXCIsKHQscik9PmAke3R9KyR7cn1gKX0scWE9ZT0+e290KGUsXCJEaXZcIiwodCxyKT0+YCR7dH0vJHtyfWApfSxZYT1lPT57b3QoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PT0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH09PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sWGE9ZT0+e290KGUsXCJNdWxcIiwodCxyKT0+YCR7dH0qJHtyfWApfSxKYT1lPT57bGV0IHQ9TChcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTtvdChlLFwiUG93XCIse3NjYWxhcjoobyxuKT0+YHBvd19jdXN0b20oJHtvfSwke259KWAsdmVjdG9yOihvLG4pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHtvfSwke259KWB9LGBcXG4gICAgZm4gcG93X2N1c3RvbShhIDogJHt0fSwgYiA6ICR7dH0pIC0+ICR7dH0ge1xcbiAgICAgIGlmIChiID09ICR7dH0oMC4wKSkge1xcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcXG4gICAgICB9IGVsc2UgaWYgKGEgPCAke3R9KDAuMCkgJiYgZjMyKGIpICE9IGZsb29yKGYzMihiKSkpIHtcXG4gICAgICAgIHJldHVybiAke3R9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHNlbGVjdChzaWduKGEpLCAke3R9KDEuMCksIHJvdW5kKGYzMihhYnMoYikgJSAke3R9KDIuMCkpKSAhPSAxLjApICogJHt0fSgke3Q9PT1cImkzMlwiP1wicm91bmRcIjpcIlwifShwb3coZjMyKGFicyhhKSksIGYzMihiKSkpKTtcXG4gICAgfVxcbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCB2ZWN0b3JpemVkIHBvd1xcbiAgICAgIHJldHVybiB2ZWM0PCR7dH0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcXG4gICAgfVxcbiAgICAgIGApfSxaYT1lPT57b3QoZSxcIlN1YlwiLCh0LHIpPT5gJHt0fS0ke3J9YCl9LFFhPWU9PntvdChlLFwiR3JlYXRlclwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fT4ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxlaT1lPT57b3QoZSxcIkxlc3NcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH08JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PCR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sdGk9ZT0+e290KGUsXCJHcmVhdGVyT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fT49JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9Pj0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LHJpPWU9PntvdChlLFwiTGVzc09yRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH08PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fTw9JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfX0pO3ZhciBDbCxBbCxJbCxFbCxvaSxhaSxpaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7Q2w9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2xldCB0PWVbMF0uZGF0YVR5cGUscj1lWzBdLmRpbXMubGVuZ3RoO2ZvcihsZXQgbyBvZiBlKXtpZihvLmRhdGFUeXBlIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihvLmRpbXMubGVuZ3RoIT09cil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX0sQWw9ZT0+YFxcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX11OyBpICs9IDF1ICkge1xcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcXG4gICAgICAgIHJldHVybiBpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gJHtlfXU7XFxuICB9YCxJbD0oZSx0KT0+e2xldCByPWUubGVuZ3RoLG89W107Zm9yKGxldCBuPTA7bjxyOysrbil7bGV0IHM9dC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixlW25dLmdldEJ5SW5kaWNlcyhcImluZGljZXNcIikpO3I9PT0xP28ucHVzaChzKTpuPT09MD9vLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7bn11KSB7ICR7c30gfWApOm49PT1yLTE/by5wdXNoKGBlbHNlIHsgJHtzfSB9YCk6by5wdXNoKGBlbHNlIGlmIChpbnB1dEluZGV4ID09ICR7bn0pIHsgJHtzfSB9YCl9cmV0dXJuIG8uam9pbihgXFxuYCl9LEVsPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLnNsaWNlKCk7aWYodD49ci5sZW5ndGh8fHQ8LTEqci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7bGV0IG89dDwwP3IubGVuZ3RoK3Q6dCxuPXIuc2xpY2UoMCk7Zm9yKGxldCB3PTE7dzxlLmxlbmd0aDt3Kyspe2xldCB2PWVbd10uZGltcy5zbGljZSgpO2ZvcihsZXQgeT0wO3k8ci5sZW5ndGg7eSsrKWlmKHk9PT1vKW5bb10rPXZbeV07ZWxzZSBpZihyW3ldIT09dlt5XSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1sZXQgcz1rLnNpemUobiksdT1uZXcgQXJyYXkoZS5sZW5ndGgpLGQ9bmV3IEFycmF5KGUubGVuZ3RoKSxhPWVbMF0uZGF0YVR5cGUsbT0wO2ZvcihsZXQgdz0wO3c8ZS5sZW5ndGg7Kyt3KW0rPWVbd10uZGltc1tvXSx1W3ddPW0sZFt3XT1MKGBpbnB1dCR7d31gLGEsZVt3XS5kaW1zKTtsZXQgZz1YKFwib3V0cHV0XCIsYSxuKSx4PWcuaW5kaWNlc0dldChcImluZGljZXNcIixvKSxiPXc9PmBcXG4gICR7dy5kZWNsYXJlVmFyaWFibGVzKC4uLmQsZyl9XFxuXFxuICBjb25zdCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke3UubGVuZ3RofT4oJHt1Lm1hcCh2PT5gJHt2fXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgJHtBbCh1Lmxlbmd0aCl9XFxuXFxuICAke3cubWFpblN0YXJ0KCl9XFxuICAgICR7dy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHMpfVxcblxcbiAgICB2YXIgaW5kaWNlcyA9ICR7Zy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7eH0pO1xcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xcbiAgICAgICR7eH0gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xcbiAgICB9XFxuXFxuICAgICR7SWwoZCxnKX1cXG4gIH1gO3JldHVybntuYW1lOlwiQ29uY2F0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpifX0sb2k9KGUsdCk9PntDbChlLmlucHV0cyksZS5jb21wdXRlKEVsKGUuaW5wdXRzLHQuYXhpcykpfSxhaT1lPT5pZSh7YXhpczplLmF4aXN9KX0pO3ZhciBXZSxXcix6cixWcj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2U9KGUsdCk9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm5gdmVjMjwke3R9PmA7Y2FzZSAzOnJldHVybmB2ZWMzPCR7dH0+YDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt0fT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2V9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0sV3I9KGUsdD0hMSxyPSExLG89Myk9PlwiXCIsenI9KGUsdCk9PmBcXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cXG4gICAgICAvLyBUT0RPIHVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmUgd2hlbiBhY3RpdmF0aW9uIGlzIHN1cHBvcnRlZCBhYm92ZS5cXG4gICAgICAvLyAke3Q/XCJ2YWx1ZSA9IGFjdGl2YXRpb24odmFsdWUsIGNvb3Jkcyk7XCI6XCJcIn1cXG4gICAgICBgfSk7dmFyIEdyLEVuPUgoKCk9PntcInVzZSBzdHJpY3RcIjtHcj1gXFxuZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzIDogdmVjNDxpMzI+LCBzaGFwZSA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcXG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xcbn1cXG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcXG4gICAgb3V0U2hhcGVTdHJpZGVzLngsIG91dFNoYXBlU3RyaWRlcy55LCBvdXRTaGFwZVN0cmlkZXMueiwgMSkpO1xcbn1cXG5gfSk7dmFyIE5yLFVyLG5yPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO05yPShlLHQ9ITEpPT57c3dpdGNoKGUuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJ2YWx1ZSA9IG1heCh2YWx1ZSwgMC4wKTtcIn07Y2FzZVwiU2lnbW9pZFwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJ2YWx1ZSA9ICgxLjAgLyAoMS4wICsgZXhwKC12YWx1ZSkpKTtcIn07Y2FzZVwiQ2xpcFwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246YGNvbnN0IGNsaXBfbWluXz1mMzIoJHtlLmNsaXBNaW59KTtjb25zdCBjbGlwX21heF89ZjMyKCR7ZS5jbGlwTWF4fSk7YCxhcHBseUFjdGl2YXRpb246dD9cInZhbHVlID0gY2xhbXAodmFsdWUsIHZlYzQoY2xpcF9taW5fKSwgdmVjNChjbGlwX21heF8pKTtcIjpcInZhbHVlID0gY2xhbXAodmFsdWUsIGNsaXBfbWluXywgY2xpcF9tYXhfKTtcIn07ZGVmYXVsdDpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwiXCJ9fX0sVXI9ZT0+e2xldCB0PWU/LmFjdGl2YXRpb258fFwiXCI7aWYodD09PVwiQ2xpcFwiKXtsZXRbcixvXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8W1JyLFByXTtyZXR1cm57YWN0aXZhdGlvbjp0LGNsaXBNYXg6byxjbGlwTWluOnIsYWN0aXZhdGlvbkNhY2hlS2V5OmAke3R9OiR7cn0sJHtvfWB9fXJldHVybnthY3RpdmF0aW9uOnQsYWN0aXZhdGlvbkNhY2hlS2V5OnR9fX0pO3ZhciBUbCxPbCxvcixzaSxfbCxhcixSbCxMcixpcj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO25yKCk7VnIoKTtUbD0oZSx0KT0+ZT9gXFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgICBgOmBcXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgICBgLE9sPShlLHQpPT5lP2BcXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcXG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XFxuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xcbiAgICAgICAgJHt0PT09Mz9cIlwiOlwibGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTtcIn1cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcXG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTtcIn1cXG4gICAgICAgIH1gOmBcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcXG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcXG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07XCJ9XFxuICAgICAgICB9YCxvcj0oZSx0LHI9XCJmMzJcIixvLG49ITEscz0zMix1PSExLGQ9MzIpPT57bGV0IGE9dFsxXSplWzFdLG09dFswXSplWzBdLGc9bj9hOnMseD1uP3M6YSxiPWcvdFswXSx3PXMvdFsxXTtpZighKChuJiZiPT09NCYmZVsxXT09PTR8fCFuJiYoYj09PTN8fGI9PT00KSkmJmcldFswXT09PTAmJnMldFsxXT09PTAmJmVbMF09PT00KSl0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHtufSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7Yn0gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHtlWzFdfSBtdXN0IGJlIDQuXFxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7Yn0gbXVzdCBiZSAzIG9yIDQuXFxuICB0aWxlQVdpZHRoICR7Z30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0uIHRpbGVJbm5lciAke3N9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt0WzFdfS4gY29sUGVyVGhyZWFkICR7ZVswXX0gbXVzdCBiZSA0LmApO3JldHVybmBcXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke2J9PCR7cn0+LCAke2cvYn0+LCAke3h9PjtcXG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7cn0+LCAke20vZVswXX0+LCAke3N9PjtcXG5cXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XFxuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7Yn07XFxuY29uc3QgdGlsZUlubmVyID0gJHtzfTtcXG5cXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XFxuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcXG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XFxuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xcblxcbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcXG4gIGxldCBiYXRjaCA9ICR7dT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcXG4gICR7bz9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7by5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XFxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke2F9O1xcblxcbiAgbGV0IG51bVRpbGVzID0gJHt1P2Ake01hdGguY2VpbChkL3MpfWA6XCIoZGltSW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XFxuICB2YXIga1N0YXJ0ID0gJHt1P2BpMzIoZ2xvYmFsSWQueikgKiAke2R9YDpcIjBcIn07XFxuXFxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7cn0+LCByb3dQZXJUaHJlYWQ+O1xcblxcbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXFxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7d307XFxuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xcbiAgICAgICAgICAke1RsKG4sbyl9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHt3fTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcXG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcXG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke28/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgICB9XFxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XFxuICAgICAgICAgICR7Yj09PTM/XCJcIjpcImxldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTtcIn1cXG5cXG4gICAgICAgICAgJHtPbChuLGIpfVxcbiAgICAgIH1cXG5cXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICB9XFxuXFxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcXG4gIH1cXG59YH0sc2k9KGUsdCk9PmU/YFxcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgICAgICAgYDpgXFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgICAgICAgICBgLF9sPWU9PmU/XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTtcIjpcImxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdO1wiLGFyPShlLHQscj1cImYzMlwiLG8sbj0hMSxzPTMyLHU9ITEsZD0zMixhPSExKT0+e2xldCBtPWVbMV0qdFsxXSxnPWVbMF0qdFswXSx4PW4/bTpzLGI9bj9zOm07aWYoIShiJXRbMV09PT0wJiZ4JXRbMF09PT0wJiZzJXRbMV09PT0wKSl0aHJvdyBuZXcgRXJyb3IoYHRpbGVBSGlnaHQgJHtifSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfSwgdGlsZUFXaWR0aCAke3h9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LCB0aWxlSW5uZXIgJHtzfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfWApO2xldCB3PWIvdFsxXSx2PXgvdFswXSx5PXMvdFsxXSxTPWE/YFxcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcXG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XFxuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7bX07XFxuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7Z307XFxuXFxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2J9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3h9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xcbiAgICAgICAgICAke3NpKG4sbyl9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7c307IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XFxuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke2d9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHtvP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXFxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcXG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XFxuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt0WzBdfV07XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7bj9gbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV07YDpgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV1ba107YH1cXG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgfVxcbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfTtcXG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3RbMF19O1xcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgYDpgXFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcXG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xcblxcbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XFxubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcXG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke219O1xcblxcbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHt3fTtcXG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7dn07XFxubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke3l9O1xcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxcbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7d307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke3Z9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XFxuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcXG4gICAgICAke3NpKG4sbyl9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3l9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XFxuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7bz9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICB9XFxuICB9XFxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XFxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcXG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcXG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICR7X2wobil9XFxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxufVxcblxcbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xcbiAgfVxcbn1cXG5gO3JldHVybmBcXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke3h9PiwgJHtifT47XFxuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHtnfT4sICR7c30+O1xcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcXG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XFxuICBjb25zdCB0aWxlSW5uZXIgPSAke3N9O1xcblxcbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcXG4gICAgbGV0IGJhdGNoID0gJHt1P1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xcbiAgICAke28/YGxldCBiYXRjaEluZGljZXMgPSAke28ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxcbiAgICBsZXQgbnVtVGlsZXMgPSAke3U/YCR7TWF0aC5jZWlsKGQvcyl9YDpcIihkaW1Jbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcXG4gICAgdmFyIGtTdGFydCA9ICR7dT9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xcblxcbiAgICB2YXIgYWNjIDogYXJyYXk8YXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcXG5cXG4gICAgLy8gV2l0aG91dCB0aGlzIGluaXRpYWxpemF0aW9uIHN0cmFuZ2UgdmFsdWVzIHNob3cgdXAgaW4gYWNjLlxcbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IDAuMDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtTfVxcbiAgfVxcbmB9LFJsPShlLHQscixvLG4scz0hMSk9PntsZXQgdT1uWzBdLGQ9blsxXSxhPW5bMl0sbT1vWzBdLGc9b1sxXSx4PW9bMl0sYj1vWzNdLHc9eG4odSxhKSx2PXhuKGQsYSkseT1NZShvWzBdLnR5cGUudGVuc29yKSxTPSgpPT57bGV0IFc9Zy5yYW5rLE09bS5yYW5rLEQ9YHZhciBhSW5kaWNlczogJHtnLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IF89Vy0yLTEsej1NLTE7Xz49MDtfLS0sei0tKUQrPWBcXG5hSW5kaWNlc1ske199XSA9ICR7TT4xP2BiYXRjaEluZGljZXNbJHt6fV1gOlwiYmF0Y2hJbmRpY2VzXCJ9O2A7cmV0dXJuIHcuZm9yRWFjaChfPT57RCs9YFxcbmFJbmRpY2VzWyR7X31dID0gMDtgfSksRCs9YFxcbmFJbmRpY2VzWyR7Vy0yfV0gPSB1MzIocm93KTtcXG4gICAgICAgICAgICAgICAgICAgYUluZGljZXNbJHtXLTF9XSA9IHUzMihjb2xJbik7YCxEfSxBPSgpPT57bGV0IFc9eC5yYW5rLE09bS5yYW5rLEQ9YHZhciBiSW5kaWNlczogJHt4LnR5cGUuaW5kaWNlc307YDtmb3IobGV0IF89Vy0yLTEsej1NLTE7Xz49MDtfLS0sei0tKUQrPWBcXG5iSW5kaWNlc1ske199XSA9ICR7TT4xP2BiYXRjaEluZGljZXNbJHt6fV1gOlwiYmF0Y2hJbmRpY2VzXCJ9O2A7cmV0dXJuIHYuZm9yRWFjaChfPT57RCs9YFxcbmJJbmRpY2VzWyR7X31dID0gMDtgfSksRCs9YFxcbmJJbmRpY2VzWyR7Vy0yfV0gPSB1MzIocm93KTtcXG4gICAgICAgICAgICAgICAgICAgYkluZGljZXNbJHtXLTF9XSA9IHUzMihjb2xJbik7YCxEfTtyZXR1cm5gXFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7bS50eXBlLmluZGljZXN9KSAtPiAke1dlKGUseSl9IHtcXG4gICAgICB2YXIgdmFsdWUgPSAke1dlKGUseSl9KDAuMCk7XFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcXG4gICAgICBpZihyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltSW5uZXIpXFxuICAgICAge1xcbiAgICAgICAgJHtTKCl9XFxuICAgICAgICB2YWx1ZSA9ICR7Zy5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcblxcbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke20udHlwZS5pbmRpY2VzfSkgLT4gJHtXZShlLHkpfSB7XFxuICAgICAgdmFyIHZhbHVlID0gJHtXZShlLHkpfSgwLjApO1xcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XFxuICAgICAgaWYocm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyKVxcbiAgICAgIHtcXG4gICAgICAgICR7QSgpfVxcbiAgICAgICAgdmFsdWUgPSAke3guZ2V0QnlJbmRpY2VzKFwiYkluZGljZXNcIil9O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7V2UoZSx5KX0pIHtcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xcbiAgICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XFxuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XFxuICAgICAgICAke3Q/YHZhbHVlID0gdmFsdWUgKyAke3M/XCJiaWFzW2NvbEluXVwiOmAke1dlKGUseSl9KGJpYXNbcm93XSlgfTtgOlwiXCJ9XFxuICAgICAgICAke3J9XFxuICAgICAgICAke2Iuc2V0QnlJbmRpY2VzKFwidmVjMzx1MzI+KGNvb3JkcylcIixcInZhbHVlXCIpfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBgfSxMcj0oZSx0LHIsbyxuPSExKT0+e2xldCBzPWVbMF0uZGltcyx1PWVbMV0uZGltcyxkPXMuc2xpY2UoMCwtMiksYT11LnNsaWNlKDAsLTIpLG09bz9vLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksZz1MKFwiYmF0Y2hEaW1zXCIsZVswXS5kYXRhVHlwZSxtKSx4PVtnXSxiPVtkLGEsbV0sdz1rLnNpemUobSksdj1zW3MubGVuZ3RoLTJdLHk9c1tzLmxlbmd0aC0xXSxTPXVbdS5sZW5ndGgtMV0sQT15JTQ9PT0wJiZTJTQ9PT0wLHthY3RpdmF0aW9uRnVuY3Rpb246UixhcHBseUFjdGl2YXRpb246V309TnIodCxBKSxNPXY8PTg/WzQsMSwxXTpbNCw0LDFdLEQ9WzgsOCwxXSxfPVtNYXRoLmNlaWwoUy9EWzBdL01bMF0pLE1hdGguY2VpbCh2L0RbMV0vTVsxXSksTWF0aC5jZWlsKHcvRFsyXS9NWzJdKV0sej1NZShlWzBdLmRhdGFUeXBlKSxGPUE/NDoxLHE9TChcImFcIixlWzBdLmRhdGFUeXBlLFsuLi5kLHYseS9GXSxGKSxsZT1MKFwiYlwiLGVbMV0uZGF0YVR5cGUsWy4uLmEseSxTL0ZdLEYpLEI9WChcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsW3csdixTL0ZdLEYpO3gucHVzaChxKSx4LnB1c2gobGUpLHgucHVzaChCKTtsZXQgSz1bcSxsZV0seGU9ZS5sZW5ndGg+MixhZT1SbChGLHhlLFcseCxiLG4pO2lmKHhlKXtsZXQgaj1uP0Y6MTtLLnB1c2goTChcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxqKSl9bGV0IHdlPWo9PmBcXG4gIGNvbnN0IGRpbUFPdXRlcjogaTMyID0gJHt2fTtcXG4gIGNvbnN0IGRpbUJPdXRlcjogaTMyID0gJHtTfTtcXG4gIGNvbnN0IGRpbUlubmVyOiBpMzIgPSAke3l9O1xcbiAgJHtqLmRlY2xhcmVWYXJpYWJsZXMoLi4uSyxCKX1cXG4gICR7Un1cXG4gICR7YWV9XFxuICAke0E/b3IoTSxELHosZyk6YXIoTSxELHosZyl9XFxuICAgICAgICAgICAgICAgICAgICR7Zy5pbXBsKCl9YDtyZXR1cm57bmFtZTpcIk1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OnQuYWN0aXZhdGlvbkNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6X1swXSx5Ol9bMV0sejpfWzJdfX0pLGdldFNoYWRlclNvdXJjZTp3ZX19fSk7dmFyIFBsLHVpLGxpPUgoKCk9PntcInVzZSBzdHJpY3RcIjttdCgpO2dlKCk7dmUoKTtWcigpO0VuKCk7aXIoKTtQbD0oZSx0LHIsbyxuPSExLHMsdT0hMSxkPTQsYT00LG09NCxnPVwiZjMyXCIpPT57bGV0IHg9bGU9Pntzd2l0Y2gobGUpe2Nhc2UgMTpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleF07XCI7Y2FzZSAzOnJldHVybmByZXNEYXRhID0gdmVjMzwke2d9Pih4W3hJbmRleF0sIHhbeEluZGV4ICsgMV0sIHhbeEluZGV4ICsgMl0pO2A7Y2FzZSA0OnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4IC8gNF07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtsZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGI9bGU9Pntzd2l0Y2gobGUpe2Nhc2UgMTpyZXR1cm5cInJldHVybiB3W3JvdyAqIHdTaGFwZVszXSArIGNvbEluXTtcIjtjYXNlIDQ6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiB3U2hhcGVbM10gLyA0ICsgY29sSW5dO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7bGV9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx3PWU/YFxcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XFxuICAgIGA6YFxcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XFxuICAgIGAsdj1lP2BcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3cgLyBvdXRXaWR0aCxcXG4gICAgICByb3cgJSBvdXRXaWR0aCxcXG4gICAgICBjb2wpO1xcbiAgICBgOmBcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3csXFxuICAgICAgY29sIC8gb3V0V2lkdGgsXFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xcbiAgICBgLHk9ZT9cInhTaGFwZVsxXVwiOlwieFNoYXBlWzJdXCIsUz1lP1wieFNoYXBlWzJdXCI6XCJ4U2hhcGVbM11cIixBPWU/XCJyb3dcIjpcImNvbFwiLFI9ZT9cImNvbFwiOlwicm93XCIsVz1gXFxuICAgIGxldCBpbkNoYW5uZWxzID0gd1NoYXBlWzJdO1xcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XFxuICAgIGxldCBvdXRSb3cgPSAke0F9IC8gb3V0V2lkdGg7XFxuICAgIGxldCBvdXRDb2wgPSAke0F9ICUgb3V0V2lkdGg7XFxuXFxuICAgIGxldCBXUm93ID0gJHtSfSAvIChmaWx0ZXJEaW1zWzFdICogaW5DaGFubmVscyk7XFxuICAgIGxldCBXQ29sID0gJHtSfSAvIGluQ2hhbm5lbHMgJSBmaWx0ZXJEaW1zWzFdO1xcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHN0cmlkZVswXSArIGRpbGF0aW9uWzBdICogV1JvdyAtIHBhZFswXTtcXG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiBzdHJpZGVbMV0gKyBkaWxhdGlvblsxXSAqIFdDb2wgLSBwYWRbMV07XFxuICAgIGxldCB4Q2ggPSAke1J9ICUgaW5DaGFubmVscztcXG4gICAgdmFyIHJlc0RhdGEgPSAke1dlKGQsZyl9KDAuMCk7XFxuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXFxuICAgIC8vIHRoZSBcXCdzYW1lXFwnIHBhZGRpbmcgdHlwZS5cXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHt5fSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7U30pIHtcXG4gICAgICAke3d9XFxuICAgICAgbGV0IHhJbmRleCA9IGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB4U2hhcGUpO1xcbiAgICAgICR7eChkKX1cXG4gICAgfVxcbiAgICByZXR1cm4gcmVzRGF0YTtgLE09ZT90JiZvP2BcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtkfTtcXG4gICAgJHtXfWA6YFxcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xcbiAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUlubmVyKSB7XFxuICAgICAgJHtXfVxcbiAgICB9XFxuICAgIHJldHVybiAke1dlKGQsZyl9KDAuMCk7YDpvJiZyP2BcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtkfTtcXG4gICAgJHtXfWA6YFxcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xcbiAgICBpZiAocm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XFxuICAgICAgJHtXfVxcbiAgICB9XFxuICAgIHJldHVybiAke1dlKGQsZyl9KDAuMCk7YCxEPWAke2IoYSl9YCxfPVdlKG0sZyksej1lP1dlKGQsZyk6V2UoYSxnKSxGPWU/V2UoYSxnKTpXZShkLGcpO3JldHVybmBcXG4gICAgJHtXcihzLHUsbT09PTQsNCl9XFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7en0ge1xcbiAgICAgICR7ZT9NOkR9XFxuICAgIH1cXG5cXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtGfSB7XFxuICAgICAgJHtlP0Q6TX1cXG4gICAgfVxcblxcbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtffSkge1xcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bX07XFxuICAgICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1CT3V0ZXIpXFxuICAgICAge1xcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XFxuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xcbiAgICAgICR7dn1cXG4gICAgICAke3pyKG4scyl9XFxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XFxuICAgICAgfVxcbiAgICB9YH0sdWk9KGUsdCxyLG8sbixzLHUsZCk9PntsZXQgYT10LmZvcm1hdD09PVwiTkhXQ1wiLG09YT9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGc9clswXSx4PWE/clsyXTpyWzNdLGI9YT9yWzFdOnJbMl0sdz1hP3JbM106clsxXSx2PWEmJihtJTQ9PT0wfHxtJTM9PT0wKSYmdyU0PT09MCx5PWE/dzp4KmIsUz1hP3gqYjp3LEE9WzgsOCwxXSxSPW88PTg/WzQsMSwxXTpbNCw0LDFdLFc9W01hdGguY2VpbCh5L0FbMF0vUlswXSksTWF0aC5jZWlsKFMvQVsxXS9SWzFdKSxNYXRoLmNlaWwoZy9BWzJdL1JbMl0pXTtFZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7V31gKTtsZXQgTT12P2EmJm0lNCE9PTA/Mzo0OlJbMF0sRD1BWzFdKlJbMV0sXz1BWzBdKlJbMF0sej1NYXRoLm1heChBWzBdKk0sQVsxXSksRj1vJUQ9PT0wLHE9biVfPT09MCxsZT1zJXo9PT0wLEI9dj9bTSw0LDRdOlsxLDEsMV0sSz1NZShlWzBdLmRhdGFUeXBlKSx4ZT1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geDogYXJyYXk8JHt2JiZNPT09ND9gdmVjNDwke0t9PmA6S30+O2AsYEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gdzogYXJyYXk8JHt2P2B2ZWM0PCR7S30+YDpLfT47YF0sYWU9YFxcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7dj9gdmVjNDwke0t9PmA6S30pIHtcXG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt2P2B2ZWM0PCR7S30+YDpLfSh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7dj9gdmVjNDwke0t9PmA6S30pIHtcXG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XFxuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke3Y/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xcbiAgICAgIH1gO3JldHVybiB1JiYoeGUucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzOiBhcnJheTwke3Y/YHZlYzQ8JHtLfT5gOkt9PjtgKSxhZSs9YFxcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHt2P2B2ZWM0PCR7S30+YDpLfSB7XFxuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2E/XCJ3XCI6XCJ5XCJ9JHt2P1wiLyA0XCI6XCJcIn1dO1xcbiAgICAgICAgfWApLHtuYW1lOlwiQ29udjJETWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OldbMF0seTpXWzFdLHo6V1syXX19KSxnZXRTaGFkZXJTb3VyY2U6KCk9PmBcXG4gICAgICAgICR7R3J9XFxuICAgICAgICAvL3N0cnVjdCBVbmlmb3JtcyB7IHhTaGFwZSA6IHZlYzQ8aTMyPiwgd1NoYXBlIDogdmVjNDxpMzI+LCBvdXRTaGFwZSA6IHZlYzQ8aTMyPixcXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXFxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xcbiAgICAgICAgJHt4ZS5qb2luKFwiXCIpfVxcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7eGUubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdDogYXJyYXk8JHt2P2B2ZWM0PCR7S30+YDpLfT47XFxuICAgICAgICAvL0Bncm91cCgwKSBAYmluZGluZygke3hlLmxlbmd0aCsxfSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcXG5cXG4gICAgICAgIGNvbnN0IHhTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgd1NoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVsxXS5kaW1zLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBvdXRTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke3Iuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IG91dFNoYXBlU3RyaWRlcyA6IHZlYzM8aTMyPiA9IHZlYzM8aTMyPigke2suY29tcHV0ZVN0cmlkZXMocikuc2xpY2UoMCwzKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3QgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Qua2VybmVsU2hhcGVbMF19LCAke3Qua2VybmVsU2hhcGVbMV19KTtcXG4gICAgICAgIGNvbnN0IHBhZCA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3QucGFkc1swXX0sICR7dC5wYWRzWzFdfSk7XFxuICAgICAgICBjb25zdCBzdHJpZGUgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LnN0cmlkZXNbMF19LCAke3Quc3RyaWRlc1sxXX0pO1xcbiAgICAgICAgY29uc3QgZGlsYXRpb24gOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LmRpbGF0aW9uc1swXX0sICR7dC5kaWxhdGlvbnNbMV19KTtcXG4gICAgICAgIGNvbnN0IGRpbUFPdXRlciA6IGkzMiA9ICR7b307XFxuICAgICAgICBjb25zdCBkaW1CT3V0ZXIgOiBpMzIgPSAke259O1xcbiAgICAgICAgY29uc3QgZGltSW5uZXIgOiBpMzIgPSAke3N9O1xcbiAgICAgICAgJHthZX1cXG4gICAgICAgICR7UGwoYSxGLHEsbGUsdSx0LmFjdGl2YXRpb24udG9Mb3dlckNhc2UoKSwhMSxCWzBdLEJbMV0sQlsyXSxLKX1cXG4gICAgICAgICAgICAke3Y/b3IoUixBLEssdm9pZCAwLCFhLHopOmFyKFIsQSxLLHZvaWQgMCwhYSx6LCExLHZvaWQgMCxkKX1gfX19KTt2YXIgVG4sZGk9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtfbigpO25yKCk7VG49KGUsdCxyKT0+e2xldCBvPWUubGVuZ3RoPjIsbj1vP1widmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07XCI6XCJcIixzPWVbMF0uZGltcyx1PWVbMV0uZGltcyxkPXVbMF0vdC5ncm91cCx7YWN0aXZhdGlvbkZ1bmN0aW9uOmEsYXBwbHlBY3RpdmF0aW9uOm19PU5yKHQpLGc9dC5mb3JtYXQ9PT1cIk5IV0NcIix4PU9uKHMsdSx0LmRpbGF0aW9ucyx0LnBhZHMsdC5zdHJpZGVzLGcpLGI9ay5zaXplKHgpLHc9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUseCksdj1MKFwieFwiLGVbMF0uZGF0YVR5cGUscykseT1MKFwid1wiLGVbMV0uZGF0YVR5cGUsdSksUz1bdix5XTtvJiZTLnB1c2goTChcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcykpO2xldCBBPVI9PmBcXG4gIGNvbnN0IHN0cmlkZXM6IHZlYzI8dTMyPiA9IHZlYzIoJHt0LnN0cmlkZXNbMF19dSwgJHt0LnN0cmlkZXNbMV19dSk7XFxuICBjb25zdCBwYWRzOiB2ZWMyPHUzMj4gPSB2ZWMyKCR7dC5wYWRzWzBdfXUsICR7dC5wYWRzWzFdfXUpO1xcblxcbiAgJHtSLmRlY2xhcmVWYXJpYWJsZXMoLi4uUyx3KX1cXG5cXG4gICR7YX1cXG5cXG4gICR7Ui5tYWluU3RhcnQoKX1cXG4gICAgJHtSLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYil9XFxuXFxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XFxuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2c/MzoxfV07XFxuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7Zz8xOjJ9XSwgb3V0cHV0SW5kaWNlc1ske2c/MjozfV0pICogc3RyaWRlcyAtIHBhZHM7XFxuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgLyAke2R9dTtcXG5cXG4gICAgdmFyIHZhbHVlOiAke3cudHlwZS52YWx1ZX0gPSAke3cudHlwZS52YWx1ZX0oMCk7XFxuICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgJHt1WzFdfXU7IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3VbMV19dSArIHdJbkNoYW5uZWw7XFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCAke3VbMl19dTsgd0hlaWdodCsrKSB7XFxuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqICR7dC5kaWxhdGlvbnNbMF19dTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSAke3NbZz8xOjJdfXUpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCAke3VbM119dTsgd1dpZHRoKyspIHtcXG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHt0LmRpbGF0aW9uc1sxXX11O1xcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49ICR7c1tnPzI6M119dSkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxldCB4VmFsID0gJHtnP3YuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKTp2LmdldChcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIil9O1xcbiAgICAgICAgICBsZXQgd1ZhbCA9ICR7eS5nZXQoXCJvdXRwdXRfY2hhbm5lbFwiLFwid0luQ2hhbm5lbFwiLFwid0hlaWdodFwiLFwid1dpZHRoXCIpfTtcXG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAke259XFxuICAgICR7bX1cXG4gICAgJHt3LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XFxuICB9YDtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyP3IoeCk6eCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYi82NCl9fSksZ2V0U2hhZGVyU291cmNlOkF9fX0pO3ZhciBPbixjaSxNbCxwaSxSbixCbCxrbCxQbixfbj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO2xpKCk7aXIoKTtkaSgpO25yKCk7cnIoKTtPbj0oZSx0LHIsbyxuLHMpPT57bGV0IHU9ZVswXSxkPWUuc2xpY2Uocz8xOjIscz8zOjQpLGE9ZC5sZW5ndGgsbT10WzBdLHg9dC5zbGljZSgyKS5tYXAoKHYseSk9PnYrKHYtMSkqKHJbeV0tMSkpLHc9ZC5tYXAoKHYseSk9PnYrb1t5XStvW3krYV0pLm1hcCgodix5KT0+TWF0aC5mbG9vcigodi14W3ldK25beV0pL25beV0pKTtyZXR1cm4gdy5zcGxpY2UoMCwwLHUpLHcuc3BsaWNlKHM/MzoxLDAsbSksd30sY2k9WzIsMywxLDBdLE1sPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCBjb252IDFEIGFuZCAyRFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbz1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihyIT09byl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgbj1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtufURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5wYWRzLmxlbmd0aCE9PW4qMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7bioyfURgKTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpfSxwaT0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtmb3IobGV0IHM9MjtzPHRbMV0uZGltcy5sZW5ndGg7KytzKXJbcy0yXT09PTAmJihyW3MtMl09dFsxXS5kaW1zW3NdKTtsZXQgbz1lLnBhZHMuc2xpY2UoKTtDdC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxyLG8sZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBuPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obix7a2VybmVsU2hhcGU6cixwYWRzOm8sY2FjaGVLZXk6ZS5jYWNoZUtleX0pLG59LFJuPWU9PntsZXQgdD1VcihlKSxyPWUuZm9ybWF0LG89W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxuPWUuZGlsYXRpb25zLHM9ZS5ncm91cCx1PWUua2VybmVsX3NoYXBlLGQ9ZS5wYWRzLGE9ZS5zdHJpZGVzLG09ZS53X2lzX2NvbnN0KCk7cmV0dXJuIGllKHthdXRvUGFkOm8sZm9ybWF0OnIsZGlsYXRpb25zOm4sZ3JvdXA6cyxrZXJuZWxTaGFwZTp1LHBhZHM6ZCxzdHJpZGVzOmEsd0lzQ29uc3Q6bSwuLi50fSl9LEJsPShlLHQscik9PntsZXQgbz1waShyLHQpO2lmKHIuZ3JvdXAhPT0xKXtlLmNvbXB1dGUoVG4odCxvKSk7cmV0dXJufWxldCBuPXIuZm9ybWF0PT09XCJOSFdDXCIscz10Lmxlbmd0aD09PTMsdT10WzBdLmRpbXNbbj8xOjJdLGQ9dFswXS5kaW1zW24/MjozXSxhPXRbMF0uZGltc1tuPzM6MV0sbT10WzFdLmRpbXNbMl0sZz10WzFdLmRpbXNbM10seD1Pbih0WzBdLmRpbXMsdFsxXS5kaW1zLHIuZGlsYXRpb25zLG8ucGFkcyxyLnN0cmlkZXMsbiksYj14W24/MToyXSx3PXhbbj8yOjNdLHY9eFtuPzM6MV0seT1uJiZtPT09dSYmZz09PWQmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTA7aWYoeXx8bT09PTEmJmc9PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MSYmci5zdHJpZGVzWzBdPT09MSYmci5zdHJpZGVzWzFdPT09MSYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MCl7bGV0IF89eFswXSx6LEYscSxsZT1bXTtpZihuKXtsZXQgQj1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShndCh0WzFdLGNpKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO2lmKHIud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9QikseSl7bGV0IEs9dSpkKmE7ej10WzBdLnJlc2hhcGUoWzEsXyxLXSksRj1CLnJlc2hhcGUoWzEsSyx2XSkscT1bMSxfLHZdfWVsc2Ugej10WzBdLnJlc2hhcGUoW18sdSpkLGFdKSxGPUIucmVzaGFwZShbMSxhLHZdKSxxPVtfLGIqdyx2XTtsZS5wdXNoKHopLGxlLnB1c2goRil9ZWxzZSB6PXRbMF0ucmVzaGFwZShbXyxhLHUqZF0pLEY9dFsxXS5yZXNoYXBlKFsxLHYsYV0pLHE9W18sdixiKnddLGxlLnB1c2goRiksbGUucHVzaCh6KTtzJiZsZS5wdXNoKHRbMl0pLGUuY29tcHV0ZShMcihsZSxvLHgscSxuKSx7aW5wdXRzOmxlfSk7cmV0dXJufWxldCBTPSEwLEE9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoZ3QodFsxXSxjaSkse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPUEpO2xldCBSPVt0WzBdLEFdO3MmJlIucHVzaCh0WzJdKTtsZXQgVz1uP2Iqdzp2LE09bj92OmIqdyxEPW0qZyphO2UuY29tcHV0ZSh1aShSLG8seCxXLE0sRCxzLFMpLHtpbnB1dHM6Un0pfSxrbD0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbz1bZS5pbnB1dHNbMF0ucmVzaGFwZShyP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmby5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbj1bMCx0LnBhZHNbMF0sMCx0LnBhZHNbMV1dLHM9WzFdLmNvbmNhdCh0LnN0cmlkZXMpLHU9WzFdLmNvbmNhdCh0LmRpbGF0aW9ucyksZD1bMV0uY29uY2F0KHQua2VybmVsU2hhcGUpLGE9cGkoey4uLnQscGFkczpuLHN0cmlkZXM6cyxkaWxhdGlvbnM6dSxrZXJuZWxTaGFwZTpkfSxvKTtlLmNvbXB1dGUoVG4obyxhLG09PnI/W21bMF0sbVsyXSxtWzNdXTpbXSkpfSxQbj0oZSx0KT0+e01sKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Mz9rbChlLHQpOkJsKGUsZS5pbnB1dHMsdCl9fSk7dmFyIERsLGZpLG1pPUgoKCk9PntcInVzZSBzdHJpY3RcIjttdCgpO2dlKCk7VnIoKTtFbigpO2lyKCk7RGw9KGUsdD0hMSxyLG89ITEsbj00KT0+e2xldCBzPVdlKG4sXCJmMzJcIiksdT1BPT57c3dpdGNoKEEpe2Nhc2UgMTpyZXR1cm5cInJldHVybiBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB3U2hhcGUpXTtcIjtjYXNlIDQ6cmV0dXJuYFxcbiAgICAgICAgICAgIGxldCBjb29yZDEgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDEsIHJvd0lubmVyKTtcXG4gICAgICAgICAgICBsZXQgY29vcmQyID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAyLCByb3dJbm5lcik7XFxuICAgICAgICAgICAgbGV0IGNvb3JkMyA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMywgcm93SW5uZXIpO1xcbiAgICAgICAgICAgIGxldCB2MCA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHdTaGFwZSldO1xcbiAgICAgICAgICAgIGxldCB2MSA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQxLCB3U2hhcGUpXTtcXG4gICAgICAgICAgICBsZXQgdjIgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMiwgd1NoYXBlKV07XFxuICAgICAgICAgICAgbGV0IHYzID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDMsIHdTaGFwZSldO1xcbiAgICAgICAgICAgIHJldHVybiB2ZWM0PGYzMj4odjAsIHYxLCB2MiwgdjMpO1xcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtBfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sZD1lP2BcXG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIGlYUiwgaVhDLCB4Q2gpO1xcbiAgICAgIGA6YFxcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCBpWFIsIGlYQyk7XFxuICAgICAgYCxhPWU/YFxcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxcbiAgICAgIGJhdGNoLFxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxcbiAgICAgIGNvbCk7XFxuICAgIGA6YFxcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxcbiAgICAgIGJhdGNoLFxcbiAgICAgIHJvdyxcXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XFxuICAgIGAsbT1lP1wib3V0QmFja3Byb3BbMV1cIjpcIm91dEJhY2twcm9wWzJdXCIsZz1lP1wib3V0QmFja3Byb3BbMl1cIjpcIm91dEJhY2twcm9wWzNdXCIseD1lP1wicm93XCI6XCJjb2xcIixiPWU/XCJjb2xcIjpcInJvd1wiLHc9YFxcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtlP1wib3V0QmFja3Byb3BbM11cIjpcIm91dEJhY2twcm9wWzFdXCJ9O1xcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcXG4gICAgICBsZXQgb3V0Um93ID0gJHt4fSAvIG91dFdpZHRoO1xcbiAgICAgIGxldCBvdXRDb2wgPSAke3h9ICUgb3V0V2lkdGg7XFxuXFxuICAgICAgbGV0IFdSb3cgPSAke2J9IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcXG4gICAgICBsZXQgV0NvbCA9ICR7Yn0gLyBpbkNoYW5uZWxzICUgZmlsdGVyRGltc1sxXTtcXG4gICAgICBsZXQgeFIgPSBmMzIob3V0Um93IC0gcGFkc1swXSArIGRpbGF0aW9uWzBdICogV1JvdykgLyBmMzIoc3RyaWRlc1swXSk7XFxuICAgICAgbGV0IHhDID0gZjMyKG91dENvbCAtIHBhZHNbMV0gKyBkaWxhdGlvblsxXSAqIFdDb2wpIC8gZjMyKHN0cmlkZXNbMV0pO1xcbiAgICAgIGlmICh4UiA8IDAuMCB8fCB4UiA+PSBmMzIoJHttfSkgfHwgZnJhY3QoeFIpID4gMC4wKSB7XFxuICAgICAgICByZXR1cm4gJHtzfSgwLjApO1xcbiAgICAgIH1cXG4gICAgICBpZiAoeEMgPCAwLjAgfHwgeEMgPj0gZjMyKCR7Z30pIHx8IGZyYWN0KHhDKSA+IDAuMCkge1xcbiAgICAgICAgcmV0dXJuICR7c30oMC4wKTtcXG4gICAgICB9XFxuICAgICAgbGV0IGlYUiA9IGkzMih4Uik7XFxuICAgICAgbGV0IGlYQyA9IGkzMih4Qyk7XFxuICAgICAgbGV0IHhDaCA9ICR7Yn0gJSBpbkNoYW5uZWxzO1xcbiAgICAgICR7ZH1cXG4gICAgICByZXR1cm4geFtnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgeFNoYXBlKS8ke259XTtgLHY9ZT9gXFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcXG4gICAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUlubmVyKSB7XFxuICAgICAgICAke3d9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAke3N9KDAuMCk7YDpgXFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcXG4gICAgICBpZiAocm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XFxuICAgICAgICAke3d9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAke3N9KDAuMCk7YCx5PWBcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtlP1wib3V0QmFja3Byb3BbM11cIjpcIm91dEJhY2twcm9wWzFdXCJ9O1xcbiAgICAgIGxldCBjb29yZFggPSBmaWx0ZXJEaW1zLnggLSAxIC0gcm93IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcXG4gICAgICBsZXQgY29vcmRZID0gZmlsdGVyRGltcy55IC0gMSAtIChyb3cgLyBpbkNoYW5uZWxzKSAlIGZpbHRlckRpbXNbMV07XFxuICAgICAgaWYgKCR7ZT9cInJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlclwiOlwicm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQU91dGVyXCJ9ICAmJiBjb29yZFggPj0gMCAmJiBjb29yZFkgPj0gMCkge1xcbiAgICAgICAgbGV0IHJvd0lubmVyID0gcm93ICUgaW5DaGFubmVscztcXG4gICAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sLCByb3dJbm5lcik7XFxuICAgICAgICAke3Uobil9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAke3N9KDAuMCk7XFxuICAgICAgYDtyZXR1cm5gXFxuICAke1dyKHIsbyxuPT09NCw0KX1cXG4gIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7c30ge1xcbiAgICAke2U/djp5fVxcbiAgfVxcblxcbiAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtzfSB7XFxuICAgICR7ZT95OnZ9XFxuICB9XFxuXFxuICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUlucHV0IDogJHtzfSkge1xcbiAgICBsZXQgY29sID0gY29sSW4gKiAke259O1xcbiAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW5wdXQ7XFxuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xcbiAgICAgICR7YX1cXG4gICAgICAke3pyKHQscil9XFxuICAgICAgcmVzdWx0W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3Jkcywgb3V0U2hhcGUpLyR7bn1dID0gdmFsdWU7XFxuICAgIH1cXG4gIH1gfSxmaT0oZSx0LHIsbyxuLHMsdSxkKT0+e2xldCBhPXQuZm9ybWF0PT09XCJOSFdDXCIsbT1hP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sZz1yWzBdLHg9YT9yWzJdOnJbM10sYj1hP3JbMV06clsyXSx3PWE/clszXTpyWzFdLHY9YT9tJTQ9PT0wJiZ3JTQ9PT0wOnglND09PTAmJnclND09PTAseT1hP3c6eCpiLFM9YT94KmI6dyxBPXY/WzgsOCwxXTpbeTw9NHx8Uzw9ND80OjE2LHk+NCYmUzw9ND80OjE2LDFdLFI9dj9bNCw0LDFdOlt5PD00PzE6NCx5PjQmJlM8PTQ/MTo0LDFdLFc9W01hdGguY2VpbCh5L0FbMF0vUlswXSksTWF0aC5jZWlsKFMvQVsxXS9SWzFdKSxNYXRoLmNlaWwoZy9BWzJdL1JbMl0pXTtFZShcInZlcmJvc2VcIiwoKT0+YFtjb252X2JhY2twcm9wX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke1d9YCk7bGV0IE09dj80OjEsRD1NYXRoLm1heChBWzBdKk0sQVsxXSksXz1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geDogYXJyYXk8JHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O2AsXCJAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IFc6IGFycmF5PGYzMj47XCJdLHo9XCJcIjtyZXR1cm4gdSYmKF8ucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzOiBhcnJheTwke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifT47YCkseis9YFxcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0ge1xcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHthP1wid1wiOlwieVwifSR7dj9cIi8gNFwiOlwiXCJ9XTtcXG4gICAgICAgIH1gKSx7bmFtZTpcIkNvbnYyRFRyYW5zcG9zZU1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpXWzBdLHk6V1sxXSx6OldbMl19fSksZ2V0U2hhZGVyU291cmNlOigpPT5gXFxuICAgICAgICAke0dyfVxcbiAgICAgICAgJHtfLmpvaW4oYFxcbmApfVxcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7Xy5sZW5ndGh9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0OiBhcnJheTwke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifT47XFxuICAgICAgICBjb25zdCBvdXRCYWNrcHJvcCA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3QgeFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCB3U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzFdLmRpbXMuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IG91dFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ci5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgb3V0U2hhcGVTdHJpZGVzIDogdmVjMzxpMzI+ID0gdmVjMzxpMzI+KCR7ay5jb21wdXRlU3RyaWRlcyhyKS5zbGljZSgwLDMpLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5rZXJuZWxTaGFwZVthPzE6Ml19LCAke3Qua2VybmVsU2hhcGVbYT8yOjNdfSk7XFxuICAgICAgICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gZmlsdGVyRGltcyArIHZlYzI8aTMyPihcXG4gICAgICAgICAgICAgICR7dC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVthPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpfSxcXG4gICAgICAgICAgICAgICR7dC5kaWxhdGlvbnNbMV08PTE/MDoodC5rZXJuZWxTaGFwZVthPzI6M10tMSkqKHQuZGlsYXRpb25zWzFdLTEpfSk7XFxuICAgICAgICBjb25zdCBwYWRzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdKSAtIDEgLSAoJHt0LnBhZHNbMF0rdC5wYWRzWzJdfSkvMixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdKSAtIDEgLSAoJHt0LnBhZHNbMV0rdC5wYWRzWzNdfSkvMik7XFxuICAgICAgICBjb25zdCBzdHJpZGVzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5zdHJpZGVzWzBdfSwgJHt0LnN0cmlkZXNbMV19KTtcXG4gICAgICAgIGNvbnN0IGRpbGF0aW9uIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5kaWxhdGlvbnNbMF19LCAke3QuZGlsYXRpb25zWzFdfSk7XFxuICAgICAgICBjb25zdCBkaW1BT3V0ZXIgOiBpMzIgPSAke299O1xcbiAgICAgICAgY29uc3QgZGltQk91dGVyIDogaTMyID0gJHtufTtcXG4gICAgICAgIGNvbnN0IGRpbUlubmVyIDogaTMyID0gJHtzfTtcXG4gICAgICAgICR7en1cXG4gICAgICAgICR7RGwoYSx1LHQuYWN0aXZhdGlvbi50b0xvd2VyQ2FzZSgpLCExLE0pfVxcbiAgICAgICAgJHt2P29yKFIsQSxcImYzMlwiLHZvaWQgMCwhYSxEKTphcihSLEEsXCJmMzJcIix2b2lkIDAsIWEsRCwhMSx2b2lkIDAsZCl9YH19fSk7dmFyIFdsLE1uLGhpPUgoKCk9PntcInVzZSBzdHJpY3RcIjttdCgpO2dlKCk7dmUoKTtXbD0oZSx0LHIsbyxuLHMsdT0hMSxkKT0+e2xldCBhPXIuZm9ybWF0PT09XCJOSFdDXCIsbT1hPzE6MixnPWE/MjozLHg9YT8zOjEsYj1rLnNpemUobyksdz11PzI6MSx2PXIuZ3JvdXAseT10WzFdLmRpbXMsUz15WzBdL3YsQT15WzFdLFI9YFxcbiAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiB1MzIsIHZhbHVlIDogJHt1P2B2ZWM0PCR7ZH0+YDpkfSkge1xcbiAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7dT9gdmVjNDwke2R9PmA6ZH0odmFsdWUpO1xcbiAgfWA7biYmKFIrPWBcXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHt1P2B2ZWM0PCR7ZH0+YDpkfSB7XFxuICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7YT9cIndcIjpcInlcIn0ke3U/XCIvIDRcIjpcIlwifV07XFxuICAgIH1gKTtsZXQgVz11PzQ6MSxNPUwoXCJXXCIsdFsxXS5kYXRhVHlwZSx0WzFdLmRpbXMsVyksRD1MKFwiRHlcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyxXKSxfPVtELE1dO24mJl8ucHVzaChMKFwiYmlhc1wiLHRbMl0uZGF0YVR5cGUsW29beF1dLFcpKTtsZXQgej1YKFwicmVzdWx0XCIsdFswXS5kYXRhVHlwZSxvLFcpLEY9YHtcXG4gICAgICAgIGxldCBiYXRjaDogdTMyID0gJHtzP1wiZ2xvYmFsX2lkLnpcIjpcIndvcmtncm91cF9pZC56XCJ9IC8gb3V0U2hhcGVbMV07XFxuICAgICAgICBsZXQgciA9ICR7cz9cImdsb2JhbF9pZC56XCI6XCJ3b3JrZ3JvdXBfaWQuelwifSAlIG91dFNoYXBlWzFdO1xcbiAgICAgICAgbGV0IGMgPSAke3M/XCJnbG9iYWxfaWQueVwiOlwid29ya2dyb3VwX2lkLnlcIn0gKiAke3d9O1xcbiAgICAgICAgbGV0IGQxOiB1MzIgPSAke3M/XCJnbG9iYWxfaWQueFwiOlwid29ya2dyb3VwX2lkLnhcIn0gKiA0O1xcblxcbiAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHZlYzI8aTMyPihwYWRzKTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICB2YXIgZG90UHJvZDogYXJyYXk8dmVjNDwke2R9PiwgJHt3fT47XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7d307IGkrKykge1xcbiAgICAgICAgICBkb3RQcm9kW2ldID0gdmVjNDwke2R9PigwLjApO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgZmlsdGVyRGltc1swXTsgd1IgPSB3UiArIDEpIHtcXG4gICAgICAgICAgdmFyIGR5UiA9ICgke2R9KGR5Q29ybmVyLngpICsgJHtkfSh3UikpIC8gJHtkfShzdHJpZGVzLngpO1xcbiAgICAgICAgICBsZXQgd1JQZXJtID0gZmlsdGVyRGltc1swXSAtIDEgLSB3UjtcXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtkfShvdXRCYWNrcHJvcFsxXSkgfHxcXG4gICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjAgfHwgd1JQZXJtIDwgMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgZmlsdGVyRGltc1sxXTsgd0MgPSB3QyArIDEpIHtcXG4gICAgICAgICAgICBsZXQgZHlDID0gKCR7ZH0oZHlDb3JuZXIueSkgKyAke2R9KHdDKSkgLyAke2R9KHN0cmlkZXMueSk7XFxuICAgICAgICAgICAgbGV0IGR5QzIgPSAoJHtkfShkeUNvcm5lci55KSArIDEuMCArICR7ZH0od0MpKSAvICR7ZH0oc3RyaWRlcy55KTtcXG4gICAgICAgICAgICBsZXQgd0NQZXJtID0gZmlsdGVyRGltc1sxXSAtIDEgLSB3QztcXG4gICAgICAgICAgICBpZiAod0NQZXJtIDwgMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBiRHlDVmFsID0gdHJ1ZTtcXG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbDIgPSB0cnVlO1xcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZH0ob3V0QmFja3Byb3BbMl0pIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGJEeUNWYWwgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGR5QzIgPCAwLjAgfHwgZHlDMiA+PSAke2R9KG91dEJhY2twcm9wWzJdKSB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMyKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgYkR5Q1ZhbDIgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xcbiAgICAgICAgICAgIGxldCBpZHlDMjogdTMyID0gdTMyKGR5QzIpO1xcbiAgICAgICAgICAgIGlmIChiRHlDVmFsICYmIGJEeUNWYWwyKSB7XFxuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSBvdXRCYWNrcHJvcFszXTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGQyIDp1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XFxuXFxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcXG5cXG4gICAgICAgICAgICAgICAgeFZhbHVlID0gICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5QzJcIixcImQyXCIpfTtcXG5cXG4gICAgICAgICAgICAgICAgZG90UHJvZFsxXSA9IGRvdFByb2RbMV0gKyB2ZWM0PCR7ZH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJEeUNWYWwpIHtcXG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IG91dEJhY2twcm9wWyR7eH1dO1xcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDFcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDJcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcXG5cXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5Q1wiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2R9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2RbMF0gPSBkb3RQcm9kWzBdICsgdG1wdmFsO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbDIpIHtcXG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IG91dEJhY2twcm9wWzNdO1xcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDFcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDJcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcXG5cXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5QzJcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHRtcHZhbDtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke3d9OyBpID0gaSArIDEpIHtcXG4gICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZFtpXSArICR7bj9cImJpYXNbYytpXVwiOlwiMC4wXCJ9O1xcbiAgICAgICAgICAke3ouc2V0KFwiYmF0Y2hcIixcInJcIixcImMgKyBpXCIsXCJkMVwiLFwidmFsdWVcIil9O1xcbiAgICAgICAgfVxcbiAgICAgIH1gLHE9YFxcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7ei5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgbGV0IGJhdGNoID0gJHt6LmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsMCl9O1xcbiAgICAgICAgICBsZXQgZDEgPSAke3ouaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIix4KX07XFxuICAgICAgICAgIGxldCByID0gJHt6LmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsbSl9O1xcbiAgICAgICAgICBsZXQgYyA9ICR7ei5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGcpfTtcXG4gICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHBhZHM7XFxuICAgICAgICAgIGxldCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgICBsZXQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG4gICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvICR7QX07XFxuICAgICAgICAgIGxldCB3T3V0Q2hhbm5lbCA9IGQxIC0gZ3JvdXBJZCAqICR7QX07XFxuICAgICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgICAgdmFyIGRvdFByb2QgPSAwLjA7XFxuICAgICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IGVmZmVjdGl2ZUZpbHRlckRpbXMueDsgd1IgPSB3UiArIDEpIHtcXG4gICAgICAgICAgICBpZiAod1IgJSBkaWxhdGlvbnMueCAhPSAwKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGR5UiA9ICgke2R9KGR5UkNvcm5lcikgKyAke2R9KHdSKSkgLyAke2R9KHN0cmlkZXNbMF0pO1xcbiAgICAgICAgICAgIGxldCB3UlBlcm0gPSBmaWx0ZXJEaW1zLnggLSAxIC0gd1IgLyBkaWxhdGlvbnMueDtcXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2R9KG91dEJhY2twcm9wWyR7bX1dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XFxuICAgICAgICAgICAgICAgIHdSUGVybSA8IDApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XFxuXFxuICAgICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgZWZmZWN0aXZlRmlsdGVyRGltcy55OyB3QyA9IHdDICsgMSkge1xcbiAgICAgICAgICAgICAgaWYgKHdDICUgZGlsYXRpb25zLnkgIT0gMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkfShkeUNDb3JuZXIpICsgJHtkfSh3QykpIC8gJHtkfShzdHJpZGVzLnkpO1xcbiAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IGZpbHRlckRpbXMueSAtIDEgLSB3QyAvIGRpbGF0aW9ucy55O1xcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtkfShvdXRCYWNrcHJvcFske2d9XSkgfHxcXG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wIHx8IHdDUGVybSA8IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XFxuICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqICR7U307XFxuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCAke1N9OyBkMiA9IGQyICsgMSkge1xcbiAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHthP0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImlucHV0Q2hhbm5lbFwiKTpELmdldChcImJhdGNoXCIsXCJpbnB1dENoYW5uZWxcIixcImlkeVJcIixcImlkeUNcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtNLmdldChcImlucHV0Q2hhbm5lbFwiLFwid091dENoYW5uZWxcIixcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiKX07XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAxO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kICsgJHtuP1wiYmlhc1tkMV1cIjpcIjAuMFwifTtcXG4gICAgICAgICAgJHt6LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xcbiAgICAgICAgYDtyZXR1cm5gXFxuICAke2UuZGVjbGFyZVZhcmlhYmxlcyguLi5fLHopfVxcbiAgJHtSfVxcbiAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PHUzMj4gPSB2ZWM0PHUzMj4oJHtvLmpvaW4oXCIsXCIpfSk7XFxuICBjb25zdCBvdXRCYWNrcHJvcCA6IHZlYzQ8dTMyPiA9IHZlYzQ8dTMyPigke3RbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgY29uc3Qgc3RyaWRlcyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke3Iuc3RyaWRlc1swXX0sICR7ci5zdHJpZGVzWzFdfSk7XFxuICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KCR7ci5rZXJuZWxTaGFwZVthPzE6Ml19LCAke3Iua2VybmVsU2hhcGVbYT8yOjNdfSk7XFxuICBjb25zdCBkaWxhdGlvbnMgOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4oJHtyLmRpbGF0aW9uc1swXX0sICR7ci5kaWxhdGlvbnNbMV19KTtcXG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgOiB2ZWMyPHUzMj4gPSBmaWx0ZXJEaW1zICsgdmVjMjx1MzI+KFxcbiAgICAgICAgICAke3IuZGlsYXRpb25zWzBdPD0xPzA6KHIua2VybmVsU2hhcGVbYT8xOjJdLTEpKihyLmRpbGF0aW9uc1swXS0xKX0sXFxuICAgICAgICAgICR7ci5kaWxhdGlvbnNbMV08PTE/MDooci5rZXJuZWxTaGFwZVthPzI6M10tMSkqKHIuZGlsYXRpb25zWzFdLTEpfSk7XFxuICBjb25zdCBwYWRzIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdKSAtIDEgLSAoJHtyLnBhZHNbMF0rci5wYWRzWzJdfSkvMixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0pIC0gMSAtICgke3IucGFkc1sxXStyLnBhZHNbM119KS8yKTtcXG4gICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhiKX07XFxuICAke3U/RjpxfX1gfSxNbj0oZSx0LHIpPT57bGV0IG89ZS5sZW5ndGg+MixuPXQub3V0cHV0U2hhcGUscz1rLnNpemUobiksdT1bTWF0aC5jZWlsKHMvNjQpLDEsMV07RWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX2JhY2twcm9wX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3V9YCk7bGV0IGQ9TWUoZVswXS5kYXRhVHlwZSk7cmV0dXJue25hbWU6XCJDb252VHJhbnNwb3NlMkRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6dVswXSx5OnVbMV0sejp1WzJdfSxvdXRwdXRzOlt7ZGltczpyP3Iobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV19KSxnZXRTaGFkZXJTb3VyY2U6YT0+V2woYSxlLHQsbixvLHVbMV09PT0xJiZ1WzJdPT09MSwhMSxkKX19fSk7dmFyIHpsLFZsLEdsLGdpLHlpLE5sLFVsLExsLEZsLGJpLHdpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtQZSgpO21pKCk7aGkoKTtucigpO3JyKCk7emw9KGUsdCxyLG8sbixzKT0+KGUtMSkqdCtyKyhvLTEpKm4rMS1zLFZsPShlLHQscixvLG4pPT57bGV0IHM9TWF0aC5mbG9vcihlLzIpO3Q9PT1cIlNBTUVfVVBQRVJcIj8ocltvXT1zLHJbbl09ZS1zKTp0PT09XCJTQU1FX0xPV0VSXCImJihyW29dPWUtcyxyW25dPXMpfSxHbD0oZSx0LHIsbyxuLHMsdSxkLGEsbSk9PntsZXQgZz1lLmxlbmd0aC0yLHg9bS5sZW5ndGg9PT0wO2lmKGEubGVuZ3RoPT09MClmb3IobGV0IHY9MDt2PGc7Kyt2KWEucHVzaCgwKTtsZXQgYj1lWzBdLHc9dFtkPzM6MV0qbjtmb3IobGV0IHY9MCx5PWUubGVuZ3RoLWctKGQ/MTowKTt2PGc7Kyt2LCsreSl7bGV0IFM9ZVt5XSxBPXg/Uyp1W3ZdOm1bdl0sUj16bChTLHVbdl0sc1t2XSx0W3ldLHJbdl0sQSk7VmwoUixvLHMsdix2K2cpLHgmJm0ucHVzaCh1W3ZdKihTLTEpK2Fbdl0rKHRbeV0tMSkqclt2XSsxLXNbdl0tc1t2K2ddKX1tLnNwbGljZSgwLDAsYiksbS5zcGxpY2UoZD8zOjEsMCx3KX0sZ2k9KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7aWYoZS5rZXJuZWxTaGFwZS5sZW5ndGg9PT0wfHxlLmtlcm5lbFNoYXBlLnJlZHVjZSgoYix3KT0+Yip3LDEpPT09MCl7ci5sZW5ndGg9MDtmb3IobGV0IGI9MjtiPHRbMV0uZGltcy5sZW5ndGg7KytiKXIucHVzaCh0WzFdLmRpbXNbYl0pfWxldCBvPWUuZm9ybWF0PT09XCJOSFdDXCI7ci5zcGxpY2UoMCwwLHRbMV0uZGltc1swXSksci5zcGxpY2Uobz8zOjEsMCx0WzFdLmRpbXNbMV0pO2xldCBuPWUucGFkcy5zbGljZSgpLHM9ZS5vdXRwdXRTaGFwZS5zbGljZSgpLHU9ZS5vdXRwdXRQYWRkaW5nLnNsaWNlKCksZD10WzBdLmRpbXMsYT1lLmRpbGF0aW9ucy5zbGljZSgpO2lmKGEucmVkdWNlKChiLHcpPT5iK3csMCk9PT0wKXtsZXQgYj10WzBdLmRpbXMubGVuZ3RoLTI7YT1uZXcgQXJyYXkoYikuZmlsbCgxKX1sZXQgbT1lLnN0cmlkZXMuc2xpY2UoKTtpZihtLnJlZHVjZSgoYix3KT0+Yit3LDApPT09MCl7bGV0IGI9dFswXS5kaW1zLmxlbmd0aC0yO209bmV3IEFycmF5KGIpLmZpbGwoMSl9R2woZCxyLGEsZS5hdXRvUGFkLGUuZ3JvdXAsbixtLG8sdSxzKTtsZXQgZz1PYmplY3QuYXNzaWduKHt9LGUpLHg9ZS5jYWNoZUtleStbci5qb2luKFwibixcIiksbi5qb2luKFwiLFwiKSxtLmpvaW4oXCIsXCIpLHUuam9pbihcIixcIikscy5qb2luKFwiLFwiKSxhLmpvaW4oXCIsXCIpXS5qb2luKFwiX1wiKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihnLHtrZXJuZWxTaGFwZTpyLHBhZHM6bixvdXRwdXRQYWRkaW5nOnUsb3V0cHV0U2hhcGU6cyxkaWxhdGlvbnM6YSxzdHJpZGVzOm0sY2FjaGVLZXk6eH0pLGd9LHlpPWU9PntsZXQgdD1VcihlKSxyPWUuZm9ybWF0LG89W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVt0eXBlb2YgZS5hdXRvUGFkPlwidVwiPzA6ZS5hdXRvUGFkXSxuPWUuZGlsYXRpb25zLHM9ZS5ncm91cCx1PWUua2VybmVsU2hhcGUsZD1lLnBhZHMsYT1lLnN0cmlkZXMsbT1lLndJc0NvbnN0KCksZz1lLm91dHB1dFBhZGRpbmcseD1lLm91dHB1dFNoYXBlO3JldHVybiBpZSh7YXV0b1BhZDpvLGZvcm1hdDpyLGRpbGF0aW9uczpuLGdyb3VwOnMsa2VybmVsU2hhcGU6dSxvdXRwdXRQYWRkaW5nOmcsb3V0cHV0U2hhcGU6eCxwYWRzOmQsc3RyaWRlczphLHdJc0NvbnN0Om0sLi4udH0pfSxObD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCByPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxvPWVbMV0uZGltc1swXTtpZihyIT09byl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2xldCBuPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzJdLmRpbXNbMF0hPT1uKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IHM9ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLnJlZHVjZSgoZyx4KT0+Zyt4LDApPjAmJnQuZGlsYXRpb25zLmxlbmd0aCE9PXMpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c31EYCk7aWYodC5zdHJpZGVzLnJlZHVjZSgoZyx4KT0+Zyt4LDApPjAmJnQuc3RyaWRlcy5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzfURgKTtpZih0LnBhZHMucmVkdWNlKChnLHgpPT5nK3gsMCk+MCYmdC5wYWRzLmxlbmd0aCE9PXMqMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7cyoyfURgKTtpZih0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09cyYmdC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtzfURgKTtpZih0Lmtlcm5lbFNoYXBlLnJlZHVjZSgoZyx4KT0+Zyt4LDApPjAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYodC5vdXRwdXRTaGFwZS5sZW5ndGghPT0wJiZ0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG91dHB1dCBzaGFwZVwiKX0sVWw9WzIsMywxLDBdLExsPShlLHQscik9PntsZXQgbz1naShyLHQpLG49ci5mb3JtYXQ9PT1cIk5IV0NcIixzPXQubGVuZ3RoPT09MztpZihvLmdyb3VwIT09MSl7ZS5jb21wdXRlKE1uKHQsbykpO3JldHVybn1sZXQgdT1vLm91dHB1dFNoYXBlLGQ9dVtuPzE6Ml0sYT11W24/MjozXSxtPXVbbj8zOjFdLGc9dFsxXS5kaW1zWzJdLHg9dFsxXS5kaW1zWzNdLGI9dFswXS5kaW1zW24/MzoxXSx3PW4/ZCphOm0sdj1uP206ZCphLHk9Zyp4KmIsUz0hMCxBPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKGd0KHRbMV0sVWwpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1BKTtsZXQgUj1bdFswXSxBXTtzJiYoIW4mJnRbMl0uZGltcy5sZW5ndGg9PT0xP1IucHVzaCh0WzJdLnJlc2hhcGUoW3RbMl0uZGltc1swXSwxLDFdKSk6Ui5wdXNoKHRbMl0pKSxlLmNvbXB1dGUoZmkoUixvLHUsdyx2LHkscyxTKSx7aW5wdXRzOlJ9KX0sRmw9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG89W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO28ubGVuZ3RoPT09MyYmby5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbj10Lmtlcm5lbFNoYXBlOyhuLmxlbmd0aD09PTB8fG5bMF09PT0wKSYmKG49W2UuaW5wdXRzWzFdLmRpbXNbMl1dKTtsZXQgcz10LmRpbGF0aW9uczsocy5sZW5ndGg9PT0wfHxzWzBdPT09MCkmJihzPVsxXSk7bGV0IHU9dC5zdHJpZGVzOyh1Lmxlbmd0aD09PTB8fHVbMF09PT0wKSYmKHU9WzFdKTtsZXQgZD10LnBhZHM7ZC5sZW5ndGg9PT0wJiYoZD1bMCwwXSksZD1bMCxkWzBdLDAsZFsxXV0sdT1bMV0uY29uY2F0KHUpLHM9WzFdLmNvbmNhdChzKSxuPVsxXS5jb25jYXQobik7bGV0IGE9Z2koey4uLnQscGFkczpkLHN0cmlkZXM6dSxkaWxhdGlvbnM6cyxrZXJuZWxTaGFwZTpufSxvKTtlLmNvbXB1dGUoTW4obyxhLG09PnI/W21bMF0sbVsyXSxtWzNdXTpbbVswXSxtWzFdLG1bM11dKSl9LGJpPShlLHQpPT57TmwoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zP0ZsKGUsdCk6TGwoZSxlLmlucHV0cyx0KX19KTt2YXIgQm4sRnIsdmksSGwsamwsa24sRG4sS2wsJGkseGksU2k9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO0JuPVwiW2EtekEtWl18XFxcXFxcXFwuXFxcXFxcXFwuXFxcXFxcXFwuXCIsRnI9XCIoXCIrQm4rXCIpK1wiLHZpPVwiXlwiK0ZyK1wiJFwiLEhsPVwiKFwiK0ZyK1wiLCkqXCIrRnIsamw9XCJeXCIrSGwrXCIkXCIsa249Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxyKXtsZXQgbz10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7bz09PXZvaWQgMD9vPVtyXTpvLnB1c2gociksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQsbyl9fSxEbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMuZXF1YXRpb249cjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbbyxuXT1yLmluY2x1ZGVzKFwiLT5cIik/ci5zcGxpdChcIi0+XCIsMik6W3IsXCJcIl07aWYoIW8ubWF0Y2goUmVnRXhwKGpsKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihvLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChkLGEpPT57bGV0IG09dFthXS5kaW1zLnNsaWNlKCk7aWYoIWQubWF0Y2goUmVnRXhwKHZpKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgZz10aGlzLnByb2Nlc3NUZXJtKGQsITAsbSxhKTt0aGlzLmxocy5wdXNoKGcpfSksbj09PVwiXCIpbis9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbZCxhXSk9PmEuY291bnQ9PT0xfHxkPT09XCIuLi5cIikubWFwKChbZF0pPT5kKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW4ubWF0Y2goUmVnRXhwKEZyKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7bi5tYXRjaChSZWdFeHAoQm4sXCJnXCIpKT8uZm9yRWFjaChkPT57aWYoZD09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IGE9dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGQpO2lmKGE9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKGEuZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obiwhMCx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LHIsbyl7bGV0IG49dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG4hPT12b2lkIDApe2lmKG4uZGltVmFsdWUhPT1yJiZuLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7bi5jb3VudCsrLG4uaW5wdXRJbmRpY2VzLnB1c2gobyl9ZWxzZSBuPXtjb3VudDoxLGRpbVZhbHVlOnIsaW5wdXRJbmRpY2VzOltvXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbil9cHJvY2Vzc1Rlcm0odCxyLG8sbj0tMSl7bGV0IHM9by5sZW5ndGgsdT0hMSxkPVtdLGE9MDtpZighdC5tYXRjaChSZWdFeHAodmkpKSYmIXImJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IG09dC5tYXRjaChSZWdFeHAoQm4sXCJnXCIpKSxnPW5ldyBrbihuKTtyZXR1cm4gbT8uZm9yRWFjaCgoeCxiKT0+e2lmKHg9PT1cIi4uLlwiKXtpZih1KXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7dT0hMDtsZXQgdz1zLW0ubGVuZ3RoKzE7aWYodzwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYoZD1vLnNsaWNlKGEsYSt3KSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1kLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWQudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYocil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWQ7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgdj0wO3Y8ZC5sZW5ndGg7disrKXtsZXQgeT1TdHJpbmcuZnJvbUNoYXJDb2RlKFwiMFwiLmNoYXJDb2RlQXQoMCkrYik7Zy5hZGRTeW1ib2woeSxiK3YpLHRoaXMuYWRkU3ltYm9sKHksb1thKytdLG4pfX1lbHNlIGcuYWRkU3ltYm9sKHgsYiksdGhpcy5hZGRTeW1ib2woeCxvW2ErK10sbil9KSxnfX0sS2w9KGUsdCk9PntsZXQgcj1lWzBdLmRhdGFUeXBlLG89bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IFc9MDtXPGUubGVuZ3RoOysrVylvW1ddPUwoYGlucHV0JHtXfWAscixlW1ddLmRpbXMpO2xldCBuPXQub3V0cHV0RGltcyxzPWsuc2l6ZShuKSx1PVgoXCJvdXRwdXRcIixyLG4pLGQ9W10sYT1BcnJheS5mcm9tKHQucmhzLnN5bWJvbFRvSW5kaWNlcy5rZXlzKCkpLG09XCJ2YXIgcHJvZCA9IDEuMDtcIixnPVwidmFyIHN1bSA9IDAuMDtcIix4PVwic3VtICs9IHByb2Q7XCIsYj1bXSx3PVtdLHY9W10seT1bXSxTPXQuc3ltYm9sVG9JbmZvLnNpemU9PT1hLmxlbmd0aDt0LnN5bWJvbFRvSW5mby5mb3JFYWNoKChXLE0pPT57aWYoYS5pbmNsdWRlcyhNKSl7bGV0IEQ9YS5pbmRleE9mKE0pO3QubGhzLmZvckVhY2goKF8seik9PntpZihXLmlucHV0SW5kaWNlcy5pbmNsdWRlcyh6KSl7bGV0IEY9Xy5zeW1ib2xUb0luZGljZXMuZ2V0KE0pO2lmKEY9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7Ri5mb3JFYWNoKHE9PntkLnB1c2goYCR7b1t6XS5pbmRpY2VzU2V0KGBpbnB1dCR7en1JbmRpY2VzYCxxLHUuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixEKSl9YCl9KX19KX1lbHNlIHQubGhzLmZvckVhY2goKEQsXyk9PntsZXQgej10LnN5bWJvbFRvSW5mby5nZXQoTSk7aWYoej09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtpZih6LmlucHV0SW5kaWNlcy5pbmNsdWRlcyhfKSl7bGV0IEY9RC5zeW1ib2xUb0luZGljZXMuZ2V0KE0pO2lmKEY9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7Ri5mb3JFYWNoKHE9PntiLnB1c2goYCR7b1tfXS5pbmRpY2VzU2V0KGBpbnB1dCR7X31JbmRpY2VzYCxxLGAke019YCl9YCl9KSx5LnB1c2goYHByb2QgKj0gJHtvW19dLmdldEJ5SW5kaWNlcyhgaW5wdXQke199SW5kaWNlc2ApfTtgKX19KSx3LnB1c2goYGZvcih2YXIgJHtNfTogdTMyID0gMDsgJHtNfSA8ICR7dC5zeW1ib2xUb0luZm8uZ2V0KE0pPy5kaW1WYWx1ZX07ICR7TX0rKykge2ApLHYucHVzaChcIn1cIil9KTtsZXQgQT1TP1suLi5kLGBsZXQgc3VtID0gJHtvLm1hcCgoVyxNKT0+Vy5nZXRCeUluZGljZXMoYGlucHV0JHtNfUluZGljZXNgKSkuam9pbihcIiAqIFwiKX07YF06Wy4uLmQsZywuLi53LC4uLmIsbSwuLi55LHgsLi4udl0sUj1XPT5gXFxuICAgICAgJHtXLmRlY2xhcmVWYXJpYWJsZXMoLi4ubyx1KX1cXG5cXG4gICAgICAke1cubWFpblN0YXJ0KCl9XFxuICAgICAgICAke1cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzKX1cXG4gICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgJHtvLm1hcCgoTSxEKT0+YHZhciBpbnB1dCR7RH1JbmRpY2VzOiAke29bRF0udHlwZS5pbmRpY2VzfTtgKS5qb2luKGBcXG5gKX1cXG4gICAgICAgICR7QS5qb2luKGBcXG5gKX07XFxuICAgICAgICAke3Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xcbiAgICAgIH1gO3JldHVybntuYW1lOlwiRWluc3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5lcXVhdGlvbn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6Un19LCRpPShlLHQpPT57bGV0IHI9bmV3IERuKGUuaW5wdXRzLHQuZXF1YXRpb24pO2UuY29tcHV0ZShLbChlLmlucHV0cyxyKSl9LHhpPWU9PntsZXQgdD1lLmVxdWF0aW9uLnJlcGxhY2UoL1xcXFxzKy9nLFwiXCIpO3JldHVybiBpZSh7ZXF1YXRpb246dH0pfX0pO3ZhciBxbCxDaSxZbCxYbCxBaSxJaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO3FsPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbz1yLmxlbmd0aDx0Lmxlbmd0aD8wOnIubGVuZ3RoLXQubGVuZ3RoLG49dC5sZW5ndGg8ci5sZW5ndGg/MDp0Lmxlbmd0aC1yLmxlbmd0aDtmb3IoO288ci5sZW5ndGgmJm48dC5sZW5ndGg7KytvLCsrbilpZihyW29dIT09dFtuXSYmcltvXSE9PTEmJnRbbl0hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSxDaT0oZSx0KT0+e2xldCByPWUubGVuZ3RoLXQubGVuZ3RoLG89W107Zm9yKGxldCBuPTA7bjxyOysrbilvLnB1c2goZVtuXSk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24pby5wdXNoKHRbbl09PT0xP2VbbityXTp0W25dKTtyZXR1cm4gb30sWWw9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP0NpKGUsdCk6Q2kodCxlKSxYbD1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG89WWwodCxyKSxuPWsuc2l6ZShvKSxzPWVbMF0uZGF0YVR5cGUsdT1MKFwiaW5wdXRcIixzLHQpLGQ9WChcIm91dHB1dFwiLHMsbyksYT1tPT5gXFxuICBjb25zdCBpbnB1dFNoYXBlID0gJHt1LmluZGljZXMoLi4udCl9O1xcbiAgJHttLmRlY2xhcmVWYXJpYWJsZXModSxkKX1cXG4gICR7bS5tYWluU3RhcnQoKX1cXG4gICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG4pfVxcbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgdmFyIGlucHV0SW5kaWNlczogJHt1LnR5cGUuaW5kaWNlc307XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xcbiAgICAgIGlmICgke3UuaW5kaWNlc0dldChcImlucHV0U2hhcGVcIixcImlcIil9ID09IDEpIHtcXG4gICAgICAgICR7dS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsMCl9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICR7dS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsZC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGBpICsgJHtvLmxlbmd0aC10Lmxlbmd0aH1gKSl9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7ZC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKSl9XFxuICB9YDtyZXR1cm57bmFtZTpcIkV4cGFuZFwiLHNoYWRlckNhY2hlOntoaW50OmAke299YH0sZ2V0U2hhZGVyU291cmNlOmEsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX19KX19LEFpPWU9PntxbChlLmlucHV0cyksZS5jb21wdXRlKFhsKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBKbCxabCxFaSxUaSxPaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7Smw9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLlwiKX0sWmw9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbz1lWzFdLmRpbXMsbj1yLmxlbmd0aCxzPWsubm9ybWFsaXplQXhpcyh0LmF4aXMsbiksdT1yLnNsaWNlKDApO3Uuc3BsaWNlKHMsMSwuLi5vKTtsZXQgZD1yW3NdLGE9ay5zaXplKHUpLG09TChcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksZz1MKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLHg9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdSksYj0oKT0+e2xldCB2PW8ubGVuZ3RoLHk9YHZhciBpbmRpY2VzSW5kaWNlcyAgPSAke2cudHlwZS5pbmRpY2VzfSgwKTtgO2ZvcihsZXQgUz0wO1M8djtTKyspeSs9YCR7dj4xP2BpbmRpY2VzSW5kaWNlc1ske1N9XWA6XCJpbmRpY2VzSW5kaWNlc1wifSA9ICR7dS5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlc1ske3MrU31dYDpcIm91dHB1dEluZGljZXNcIn07YDt5Kz1gXFxuICAgICAgICB2YXIgaWR4ID0gJHtnLmdldEJ5SW5kaWNlcyhcImluZGljZXNJbmRpY2VzXCIpfTtcXG4gICAgICAgIGlmIChpZHggPCAwKSB7XFxuICAgICAgICAgIGlkeCA9IGlkeCArICR7ZH07XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZGF0YUluZGljZXMgPSAke20udHlwZS5pbmRpY2VzfSgwKTtcXG4gICAgICBgO2ZvcihsZXQgUz0wLEE9MDtTPG47UysrKVM9PT1zPyh5Kz1gJHtuPjE/YGRhdGFJbmRpY2VzWyR7U31dYDpcImRhdGFJbmRpY2VzXCJ9ID0gdTMyKGlkeCk7YCxBKz12KTooeSs9YCR7bj4xP2BkYXRhSW5kaWNlc1ske1N9XWA6XCJkYXRhSW5kaWNlc1wifSA9ICR7dS5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlc1ske0F9XWA6XCJvdXRwdXRJbmRpY2VzXCJ9O2AsQSsrKTtyZXR1cm4geX0sdz12PT5gXFxuICAgICAgJHt2LmRlY2xhcmVWYXJpYWJsZXMobSxnLHgpfVxcbiAgICAgICR7di5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGEpfVxcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3gub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAke2IoKX07XFxuICAgICAgICBsZXQgdmFsdWUgPSAke20uZ2V0QnlJbmRpY2VzKFwiZGF0YUluZGljZXNcIil9O1xcbiAgICAgICAgJHt4LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xcbiAgICAgIH1gO3JldHVybntuYW1lOlwiR2F0aGVyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6d319LEVpPWU9PmllKHtheGlzOmUuYXhpc30pLFRpPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7SmwociksZS5jb21wdXRlKFpsKGUuaW5wdXRzLHQpKX19KTt2YXIgUWwsZWQsX2ksUmksUGk9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO1FsPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBiZSByYW5rID49IDEuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxlZD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxvPWVbMF0uZGF0YVR5cGUsbj1yLmxlbmd0aCxzPWsuY29tcHV0ZVN0cmlkZXMociksdT1rLnNpemUociksZD1lWzFdLmRpbXMsYT1lWzFdLmRhdGFUeXBlLG09ay5zaXplKGQpLGc9ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxuKSx4PXJbZ10sYj1kLnNsaWNlKDApLHc9ay5zaXplKGIpLHY9TChcImlucHV0XCIsbyxyKSx5PUwoXCJpbmRpY2VzXCIsYSxbbV0pLFM9WChcIm91dHB1dFwiLG8sYiksQT1SPT5gXFxuICAgICAgY29uc3QgaW5wdXRTdHJpZGVzID0gYXJyYXk8dTMyLCAke3MubGVuZ3RofT4oJHtzLm1hcChXPT5gJHtXfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICR7Ui5kZWNsYXJlVmFyaWFibGVzKHYseSxTKX1cXG4gICAgICAke1IubWFpblN0YXJ0KCl9XFxuICAgICAgJHtSLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModyl9XFxuXFxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgdmFyIGlkeCA9ICR7eS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgIGlmIChpZHggPCAwKSB7XFxuICAgICAgICBpZHggPSBpZHggKyAke3h9O1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc3JjT2Zmc2V0ID0gdTMyKDApO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xcbiAgICAgICAgaWYgKGkgPT0gJHtnfSkge1xcbiAgICAgICAgICBzcmNPZmZzZXQgKz0gIHUzMihpZHgpICogaW5wdXRTdHJpZGVzW2ldO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3JjT2Zmc2V0ICs9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiaVwiKX0gKiBpbnB1dFN0cmlkZXNbaV07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFNob3VsZCBuZXZlciBoaXQgdGhpcyB3aXRoIHZhbGlkIHZhbHVlcyBpbiBpbmRpY2VzXFxuICAgICAgLy8gVGhpcyBpcyBhIGd1YXJkIGFnYWluc3QgbWFsaWNpb3VzIGRhdGEgaW4gdGhlIGluZGljZXMgaW5wdXRcXG4gICAgICBpZiAoc3JjT2Zmc2V0IDwgMCB8fCBzcmNPZmZzZXQgPj0gJHt1fSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtzcmNPZmZzZXRdO1xcbiAgfWA7cmV0dXJue25hbWU6XCJHYXRoZXJFbGVtZW50c1wiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwody82NCl9fSksZ2V0U2hhZGVyU291cmNlOkF9fSxfaT1lPT5pZSh7YXhpczplLmF4aXN9KSxSaT0oZSx0KT0+e2xldCByPWUuaW5wdXRzO1FsKHIpLGUuY29tcHV0ZShlZChlLmlucHV0cyx0KSl9fSk7dmFyIHRkLHJkLG5kLE1pLEJpLGtpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTt0ZD1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0scmQ9KGUsdCxyKT0+e2lmKHIubGVuZ3RoPT09MClyZXR1cm5cIjB1XCI7bGV0IG89ci5sZW5ndGg9PT0xJiZlIT09MXx8ci5sZW5ndGg9PT0yJiZyWzBdIT09ZSxuPXJbci5sZW5ndGgtMV0hPT10LHM9XCIwdVwiO3JldHVybiBvfHwocys9YCsgbSAqICR7cltyLmxlbmd0aC0xXX11YCksbnx8KHMrPVwiK25cIiksc30sbmQ9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKSxvPWVbMV0uZGltcy5zbGljZSgpLFtuLHMsdV09X3IuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocix0LnRyYW5zQSxvLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxkPVtuLHNdO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IGE9ay5zaXplKGQpLG09XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/bT1cInZhbHVlICs9IGFbayAqIE0gKyBtXSAqIGJbbiAqIEsgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP209XCJ2YWx1ZSArPSBhW2sgKiBNICsgbV0gKiBiW2sgKiBOICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj9tPVwidmFsdWUgKz0gYVttICogSyArIGtdICogYltuICogSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYobT1cInZhbHVlICs9IGFbbSAqIEsgKyBrXSAqIGJbayAqIE4gKyBuXTtcIik7bGV0IGc9TWUoZVswXS5kYXRhVHlwZSkseD10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gYWxwaGE7XCIsYj1lLmxlbmd0aD09PTM/YHZhbHVlICs9IGJldGEgKiBjWyR7cmQobixzLGVbMl0uZGltcyl9XTtgOlwiXCIsdz1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gYSA6IGFycmF5PCR7Z30+O2AsYEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gYiA6IGFycmF5PCR7Z30+O2BdO2UubGVuZ3RoPT09MyYmdy5wdXNoKGBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGMgOiBhcnJheTwke2d9PjtgKTtsZXQgdj15PT5gXFxuICBjb25zdCBNOiB1MzIgPSAke259dTtcXG4gIGNvbnN0IE46IHUzMiA9ICR7c311O1xcbiAgY29uc3QgSzogdTMyID0gJHt1fXU7XFxuICBjb25zdCBhbHBoYSA9ICR7Z30oJHt0LmFscGhhfSk7XFxuICBjb25zdCBiZXRhID0gJHtnfSgke3QuYmV0YX0pO1xcblxcbiAgJHt3LmpvaW4oYFxcbmApfVxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKCR7ZS5sZW5ndGh9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtnfT47XFxuXFxuICAke3kubWFpblN0YXJ0KCl9XFxuICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGEpfVxcblxcbiAgICBsZXQgbSA9IGdsb2JhbF9pZC54IC8gTjtcXG4gICAgbGV0IG4gPSBnbG9iYWxfaWQueCAlIE47XFxuXFxuICAgIHZhciB2YWx1ZSA9ICR7Z30oMCk7XFxuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPCR7dX11OyBrKyspIHtcXG4gICAgICAke219XFxuICAgIH1cXG5cXG4gICAgJHt4fVxcbiAgICAke2J9XFxuICAgIG91dHB1dFtnbG9iYWxfaWQueF0gPSB2YWx1ZTtcXG5cXG4gIH1gO3JldHVybntuYW1lOlwiR2VtbVwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSksZ2V0U2hhZGVyU291cmNlOnZ9fSxNaT0oZSx0KT0+e3RkKGUuaW5wdXRzKSxlLmNvbXB1dGUobmQoZS5pbnB1dHMsdCkpfSxCaT1lPT5pZShlKX0pO3ZhciBvZCxhZCxpZCxzZCxEaSxXaSx6aT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO1BlKCk7dmUoKTtvZD17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwifSxhZD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxvPXIsbj0yLHM9ay5zaXplVG9EaW1lbnNpb24ocixuKSx1PWsuc2l6ZUZyb21EaW1lbnNpb24ocixuKSxkPXJbMV0sYT1MKFwieFwiLGVbMF0uZGF0YVR5cGUsW3JbMF0sclsxXSx1XSksbT1MKFwic2NhbGVcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksZz1MKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zKSx4PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLFtyWzBdLHJbMV0sdV0pLGI9W2EsbSxnLHhdLHc9YS50eXBlLnZhbHVlLHY9NjQseT1TPT5gXFxuXFxuICBjb25zdCBDOiB1MzIgPSAke2R9O1xcbiAgY29uc3Qgbm9ybVNpemU6IHUzMiA9ICR7dX07XFxuICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke3QuZXBzaWxvbn07XFxuICB2YXI8d29ya2dyb3VwPiBtZWFuU2hhcmVkIDogJHt3fTtcXG4gIHZhcjx3b3JrZ3JvdXA+IHNxdWFyZWROb3JtU2hhcmVkIDogJHt3fTtcXG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cFNoYXJlZCA6IGFycmF5PCR7d30sICR7dn0+O1xcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9ICR7dn11O1xcbiAgJHtTLmRlY2xhcmVWYXJpYWJsZXMoLi4uYil9XFxuICAke1MubWFpblN0YXJ0KHYpfVxcbiAgICBsZXQgbm9ybSA9IGdsb2JhbF9pZHggLyB3b3JrZ3JvdXBTaXplO1xcbiAgICBsZXQgYmF0Y2ggPSBub3JtIC8gQztcXG4gICAgbGV0IGNoYW5uZWwgPSBub3JtICUgQztcXG4gICAgbGV0IGxvY2FsSW5kZXggPSBsb2NhbF9pZC54O1xcblxcbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcXG4gICAgdmFyIGluaXRpYWw6ICR7d30gPSAwO1xcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IG5vcm1TaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcXG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArICR7YS5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX07XFxuICAgIH1cXG4gICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gaW5pdGlhbDtcXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1lYW4gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXFxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcXG4gICAgICBpZiAobG9jYWxJbmRleCA8IGN1cnJTaXplKSB7XFxuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcXG4gICAgICB9XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICB9XFxuICAgIGlmIChsb2NhbEluZGV4ID09IDApIHtcXG4gICAgICBtZWFuU2hhcmVkID0gd29ya2dyb3VwU2hhcmVkWzBdIC8gJHt3fShub3JtU2l6ZSk7XFxuICAgIH1cXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAvLyByZWluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeS5cXG4gICAgaW5pdGlhbCA9IDA7XFxuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgbm9ybVNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xcbiAgICAgIGxldCBkZXZpYXRpb24gPSAgJHthLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSAtIG1lYW5TaGFyZWQ7XFxuICAgICAgaW5pdGlhbCA9IGluaXRpYWwgKyBkZXZpYXRpb24gKiBkZXZpYXRpb247XFxuICAgIH1cXG4gICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gaW5pdGlhbDtcXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHN1bSBvZiBzcXVhcmUgb2YgZGV2aWF0aW9uIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxcbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cFNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XFxuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XFxuICAgICAgfVxcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgfVxcbiAgICBpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxuICAgICAgc3F1YXJlZE5vcm1TaGFyZWQgPSB3b3JrZ3JvdXBTaGFyZWRbMF07XFxuICAgIH1cXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICBsZXQgaW52U3RkRGV2ID0gMSAvIHNxcnQoc3F1YXJlZE5vcm1TaGFyZWQgLyAke3d9KG5vcm1TaXplKSArIGVwc2lsb24pO1xcbiAgICBsZXQgY2hhbm5lbFNjYWxlID0gaW52U3RkRGV2ICogJHttLmdldEJ5T2Zmc2V0KFwiY2hhbm5lbFwiKX07XFxuICAgIGxldCBjaGFubmVsU2hpZnQgPSAke2cuZ2V0QnlPZmZzZXQoXCJjaGFubmVsXCIpfSAtIG1lYW5TaGFyZWQgKiBjaGFubmVsU2NhbGU7XFxuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgbm9ybVNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xcbiAgICAgIGxldCB2YWx1ZSA9ICR7YS5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0gKiBjaGFubmVsU2NhbGUgKyBjaGFubmVsU2hpZnQ7XFxuICAgICAgJHt4LnNldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIsXCJ2YWx1ZVwiKX07XFxuICAgIH1cXG4gIH1gO3JldHVybnsuLi5vZCxzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6c319KSxnZXRTaGFkZXJTb3VyY2U6eX19LGlkPShlLHQscixvLG4scyx1LGQpPT57bGV0IGE9bHQodSksbT1MKFwiaW5wdXRcIix0LmRhdGFUeXBlLHQuZGltcyxhKSxnPUwoXCJzY2FsZVwiLHIuZGF0YVR5cGUsci5kaW1zLGEpLHg9TChcImJpYXNcIixvLmRhdGFUeXBlLG8uZGltcyxhKSxiPTY0LHc9YT09PTE/XCJ2ZWMyZlwiOmBtYXQyeCR7YX1mYCx2PWE9PT0xP1wiZjMyXCI6YHZlYyR7YX1mYCx5PShELF8pPT5gJHt3fSgke0R9LCAke199KWAsUz1uKnUvYSxBPU1hdGguY2VpbChzL2IpLFI9RD0+YFxcbiAgY29uc3QgSDogdTMyID0gJHtzfTtcXG4gIGNvbnN0IEM6IHUzMiA9ICR7dS9hfTtcXG4gIGNvbnN0IGltYWdlU2l6ZTogdTMyID0gJHtzKnUvYX07XFxuXFxuICAke0QuZGVjbGFyZVZhcmlhYmxlcyhtKX1cXG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHt3fT47XFxuXFxuICAke0QubWFpblN0YXJ0KGIpfVxcbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvICR7Yn0gLyBDO1xcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSAoZ2xvYmFsX2lkeCAvICR7Yn0pICUgQztcXG4gICAgbGV0IHdnSWQgPSBnbG9iYWxfaWR4ICUgJHtifTtcXG4gICAgbGV0IHdnT2Zmc2V0ID0gd2dJZCAqICR7QX07XFxuICAgIGlmICh3Z09mZnNldCA+PSBIKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGV0IHdnTWF4ID0gbWluKHdnT2Zmc2V0ICsgJHtBfSwgSCk7XFxuXFxuICAgIGxldCBvZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiBpbWFnZVNpemUgKyBjdXJyZW50Q2hhbm5lbE51bWJlcjtcXG4gICAgdmFyIHN1bSA9ICR7cWUoXCJmMzJcIixhKX07XFxuICAgIHZhciBzcXVhcmVkU3VtID0gJHtxZShcImYzMlwiLGEpfTtcXG4gICAgZm9yICh2YXIgaTogdTMyID0gd2dPZmZzZXQ7IGkgPCB3Z01heDsgaSsrKSB7XFxuICAgICAgICBsZXQgdmFsdWUgPSAke3Z9KGlucHV0W29mZnNldCArIGkgKiBDXSk7XFxuICAgICAgICBzdW0gKz0gdmFsdWU7XFxuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlICogdmFsdWU7XFxuICAgIH1cXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt5KFwic3VtXCIsXCJzcXVhcmVkU3VtXCIpfTtcXG4gIH1gLFc9ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtQ29tcHV0ZU1lYW5cIixzaGFkZXJDYWNoZTp7aGludDpKU09OLnN0cmluZ2lmeSh7Y29tcG9uZW50czphLG4saDpzLGM6dX0pfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOltuLHUsYiwyXSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpuKnUvYX19KSxnZXRTaGFkZXJTb3VyY2U6Un0se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF0sTT1EPT5gXFxuICBjb25zdCBIOiB1MzIgPSAke3N9O1xcbiAgY29uc3QgQzogdTMyID0gJHt1L2F9O1xcbiAgY29uc3QgaW1hZ2VTaXplOiB1MzIgPSAke2IqdS9hfTtcXG4gIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7ZH07XFxuXFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHt3fT47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlIDogYXJyYXk8JHtnLnR5cGUuc3RvcmFnZX0+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzIDogYXJyYXk8JHt4LnR5cGUuc3RvcmFnZX0+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3d9PjtcXG5cXG4gICR7RC5tYWluU3RhcnQoKX1cXG4gICAgJHtELmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoUyl9XFxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gQztcXG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gZ2xvYmFsX2lkeCAlIEM7XFxuXFxuICAgIGxldCBvZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiBpbWFnZVNpemU7XFxuICAgIHZhciBzdW0gPSAke3FlKFwiZjMyXCIsYSl9O1xcbiAgICB2YXIgc3F1YXJlZFN1bSA9ICR7cWUoXCJmMzJcIixhKX07XFxuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2J9OyBpKyspIHtcXG4gICAgICAgIGxldCB2YWx1ZSA9IGlucHV0W29mZnNldCArIGkgKyBjdXJyZW50Q2hhbm5lbE51bWJlciAqICR7Yn1dO1xcbiAgICAgICAgc3VtICs9IHZhbHVlWzBdO1xcbiAgICAgICAgc3F1YXJlZFN1bSArPSB2YWx1ZVsxXTtcXG4gICAgfVxcbiAgICBzdW0gPSBzdW0gLyBmMzIoSCk7XFxuICAgIHNxdWFyZWRTdW0gPSBzcXVhcmVkU3VtIC8gZjMyKEgpO1xcbiAgICBsZXQgaW52U3RkRGV2ID0gMSAvIHNxcnQoc3F1YXJlZFN1bSAtIHN1bSAqIHN1bSArIGVwc2lsb24pO1xcbiAgICBsZXQgY2hhbm5lbFNjYWxlID0gaW52U3RkRGV2ICogJHt2fShzY2FsZVtjdXJyZW50Q2hhbm5lbE51bWJlcl0pO1xcbiAgICBsZXQgY2hhbm5lbFNoaWZ0ID0gJHt2fShiaWFzW2N1cnJlbnRDaGFubmVsTnVtYmVyXSkgLSBzdW0gKiBjaGFubmVsU2NhbGU7XFxuXFxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7eShcImNoYW5uZWxTY2FsZVwiLFwiY2hhbm5lbFNoaWZ0XCIpfTtcXG4gIH1gO3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlQ2hhbm5lbFNjYWxlU2hpZnRcIixzaGFkZXJDYWNoZTp7aGludDpKU09OLnN0cmluZ2lmeSh7Y29tcG9uZW50czphLG4saDpzLGM6dSxlcHNpbG9uOmR9KX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpbbix1LDJdLGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChTLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6TX0se2lucHV0czpbVyxyLG9dLG91dHB1dHM6Wy0xXX0pWzBdfSxzZD0oZSx0LHIpPT57bGV0IG89dFswXS5kaW1zLG49byxzPW9bMF0sdT1vW28ubGVuZ3RoLTFdLGQ9ay5zaXplRnJvbURpbWVuc2lvbihvLDEpL3UsYT1sdCh1KSxtPWsuc2l6ZShuKS9hLGc9TChcImlucHV0XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsYSkseD1YKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxuLGEpLGI9TWUodFswXS5kYXRhVHlwZSksdz1hPT09MT9cInZlYzJmXCI6YG1hdDJ4JHthfWZgLHY9YT09PTE/YjpgdmVjJHthfTwke2J9PmAseT1pZChlLHRbMF0sdFsxXSx0WzJdLHMsZCx1LHIuZXBzaWxvbiksUz1BPT5gXFxuICBjb25zdCBIOiB1MzIgPSAke2R9O1xcbiAgY29uc3QgQzogdTMyID0gJHt1L2F9O1xcblxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7Zy50eXBlLnN0b3JhZ2V9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVJbnB1dCA6IGFycmF5PCR7d30+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3gudHlwZS5zdG9yYWdlfT47XFxuXFxuICAke0EubWFpblN0YXJ0KCl9XFxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gKEMgKiBIKTtcXG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gZ2xvYmFsX2lkeCAlIEM7XFxuXFxuICAgIGxldCBzY2FsZU9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIEMgKyBjdXJyZW50Q2hhbm5lbE51bWJlcjtcXG4gICAgbGV0IHNjYWxlID0gc2NhbGVJbnB1dFtzY2FsZU9mZnNldF07XFxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHt2fShzY2FsZVswXSksICR7dn0oc2NhbGVbMV0pKTtcXG4gIH1gO2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3IuY2FjaGVLZXl9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6U30se2lucHV0czpbdFswXSx5XX0pfSxEaT1lPT5pZSh7ZXBzaWxvbjplLmVwc2lsb24sZm9ybWF0OmUuZm9ybWF0fSksV2k9KGUsdCk9Pnt0LmZvcm1hdD09PVwiTkhXQ1wiP3NkKGUsZS5pbnB1dHMsdCk6ZS5jb21wdXRlKGFkKGUuaW5wdXRzLHQpKX19KTt2YXIgdWQsbGQsVmksR2ksTmk9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtQZSgpO3ZlKCk7dWQ9ZT0+e2lmKCFlfHxlLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy5cIil9LGxkPShlLHQscik9PntsZXQgbz1lWzBdLmRpbXMsbj1lWzFdLHM9ZVsyXSx1PW8sZD1rLm5vcm1hbGl6ZUF4aXModC5heGlzLG8ubGVuZ3RoKSxhPWsuc2l6ZVRvRGltZW5zaW9uKG8sZCksbT1rLnNpemVGcm9tRGltZW5zaW9uKG8sZCksZz1rLnNpemUobi5kaW1zKSx4PXM/ay5zaXplKHMuZGltcyk6MDtpZihnIT09bXx8cyYmeCE9PW0pdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHttfS5cXG4gICAgICAgU2l6ZSBvZiBzY2FsZSBhbmQgYmlhcyAoaWYgcHJvdmlkZWQpIG11c3QgbWF0Y2ggdGhpcy5cXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHtnfSBhbmQgYmlhcyBzaXplIG9mICR7eH1gKTtsZXQgYj1bXTtmb3IobGV0IE09MDtNPG8ubGVuZ3RoOysrTSlNPGQ/Yi5wdXNoKG9bTV0pOmIucHVzaCgxKTtsZXQgdz1sdChtKSx2PU1lKGVbMF0uZGF0YVR5cGUpLHk9W0woXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsdyksTChcInNjYWxlXCIsbi5kYXRhVHlwZSxuLmRpbXMsdyldO3MmJnkucHVzaChMKFwiYmlhc1wiLHMuZGF0YVR5cGUscy5kaW1zLHcpKSx5LnB1c2goWChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdSx3KSk7bGV0IFM9cj4xLEE9cj4yO1MmJnkucHVzaChYKFwibWVhbkRhdGFPdXRwdXRcIiwxLGIpKSxBJiZ5LnB1c2goWChcImludlN0ZE91dHB1dFwiLDEsYikpO2xldCBSPU09PmBcXG4gIGNvbnN0IG5vcm1TaXplOiBmMzIgPSAke219O1xcbiAgY29uc3Qgbm9ybVNpemVWZWN0b3JpemVkOiB1MzIgPSAke20vd307XFxuICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke3QuZXBzaWxvbn07XFxuXFxuICAke00uZGVjbGFyZVZhcmlhYmxlcyguLi55KX1cXG4gICR7TS5tYWluU3RhcnQoKX1cXG4gICAgJHtNLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYSl9XFxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogbm9ybVNpemVWZWN0b3JpemVkO1xcbiAgICB2YXIgbWVhblZlY3RvciA9ICR7cWUoXCJmMzJcIix3KX07XFxuICAgIHZhciBtZWFuU3F1YXJlVmVjdG9yID0gJHtxZShcImYzMlwiLHcpfTtcXG5cXG4gICAgZm9yICh2YXIgaDogdTMyID0gMHU7IGggPCBub3JtU2l6ZVZlY3Rvcml6ZWQ7IGgrKykge1xcbiAgICAgIGxldCB2YWx1ZSA9ICR7QXQodix3LFwieFtoICsgb2Zmc2V0XVwiKX07XFxuICAgICAgbWVhblZlY3RvciArPSB2YWx1ZTtcXG4gICAgICBtZWFuU3F1YXJlVmVjdG9yICs9IHZhbHVlICogdmFsdWU7XFxuICAgIH1cXG4gICAgbGV0IG1lYW4gPSAke2h0KFwibWVhblZlY3RvclwiLHcpfSAvIG5vcm1TaXplO1xcbiAgICBsZXQgbWVhblNxdWFyZSA9IHNxcnQoJHtodChcIm1lYW5TcXVhcmVWZWN0b3JcIix3KX0gXFxuICAgICAgLyBub3JtU2l6ZSAtIG1lYW4gKiBtZWFuICsgZXBzaWxvbik7XFxuXFxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCBub3JtU2l6ZVZlY3Rvcml6ZWQ7IGorKykge1xcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7QXQodix3LFwieFtqICsgb2Zmc2V0XVwiKX07XFxuICAgICAgbGV0IGYzMnNjYWxlID0gJHtBdCh2LHcsXCJzY2FsZVtqXVwiKX07XFxuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHt5WzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAtIG1lYW4pIC8gbWVhblNxdWFyZSAqIGYzMnNjYWxlXFxuICAgICAgICAke3M/YCsgJHtBdCh2LHcsXCJiaWFzW2pdXCIpfWA6XCJcIn1cXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgICR7Uz9cIm1lYW5EYXRhT3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xcbiAgICAke0E/XCJpbnZTdGRPdXRwdXRbZ2xvYmFsX2lkeF0gPSAxIC8gbWVhblNxdWFyZVwiOlwiXCJ9O1xcbiAgfWAsVz1be2RpbXM6dSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIFMmJlcucHVzaCh7ZGltczpiLGRhdGFUeXBlOjF9KSxBJiZXLnB1c2goe2RpbXM6YixkYXRhVHlwZToxfSkse25hbWU6XCJMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke3J9fCR7ZS5sZW5ndGh9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlcsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSksZ2V0U2hhZGVyU291cmNlOlJ9fSxWaT1lPT5pZSh7YXhpczplLmF4aXMsZXBzaWxvbjplLmVwc2lsb259KSxHaT0oZSx0KT0+e3VkKGUuaW5wdXRzKSxlLmNvbXB1dGUobGQoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50KSl9fSk7dmFyIGRkLFVpLExpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2lyKCk7ZGQ9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpfSxVaT1lPT57ZGQoZS5pbnB1dHMpO2xldCB0PVFlLmNhbGNTaGFwZShlLmlucHV0c1swXS5kaW1zLGUuaW5wdXRzWzFdLmRpbXMsITApO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtlLmNvbXB1dGUoTHIoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIixhY3RpdmF0aW9uQ2FjaGVLZXk6XCJcIn0sdCkpfX0pO3ZhciBjZCxwZCxmZCxtZCxoZCxnZCx5ZCxiZCx3ZCxGaSxIaSxqaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO1BlKCk7dmUoKTtjZD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZSBtdXN0IGJlIGZsb2F0LlwiKTtpZihlLmxlbmd0aD49Mil7bGV0IHQ9ZVswXS5kaW1zLmxlbmd0aCoyPT09ZVsxXS5kaW1zWzBdO2lmKGUubGVuZ3RoPT09NCYmKHQ9ZVszXS5kaW1zWzBdKjI9PT1lWzFdLmRpbXNbMF0pLCF0KXRocm93IG5ldyBFcnJvcihcIlRoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLlwiKX19LHBkPShlLHQscixvLG4scyx1KT0+e2xldCBkPXIubGVuZ3RoLGE9XCJcIjtmb3IobGV0IG09ZC0xO20+PTA7LS1tKWErPWBcXG4gICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG0pfSkgLSAke25bbV19O1xcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChrID49ICR7clttXX0pIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7b1ttXX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICAgICAgdmFsdWUgPSAke3N9KCR7dX0pO1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgICAgICAke2F9XFxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XFxuICAgICAgICAgIH1cXG4gICAgICBgfSxmZD0oZSx0LHIsbyxuKT0+e2xldCBzPXIubGVuZ3RoLHU9XCJcIjtmb3IobGV0IGQ9cy0xO2Q+PTA7LS1kKXUrPWBcXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixkKX0pIC0gJHtuW2RdfTtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgayA9IC1rO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAkezIqKHJbZF0tMSl9O1xcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XFxuICAgICAgICAgICAgICAgICAgaWYoayA+PSAke3JbZF19KSB7XFxuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7b1tkXX07XFxuICAgICAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgICAgICAgICR7dX1cXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xcbiAgICAgICAgICBgfSxtZD0oZSx0LHIsbyxuKT0+e2xldCBzPXIubGVuZ3RoLHU9XCJcIjtmb3IobGV0IGQ9cy0xO2Q+PTA7LS1kKXUrPWBcXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixkKX0pIC0gJHtuW2RdfTtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgayA9IDA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gJHtyW2RdfSkge1xcbiAgICAgICAgICAgICAgICAgIGsgPSAke3JbZF0tMX07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke29bZF19O1xcbiAgICAgICAgICAgIGA7cmV0dXJuYFxcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XFxuICAgICAgICAgICAgICB2YXIgayA9IDA7XFxuICAgICAgICAgICAgICAke3V9XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcXG4gICAgICAgICAgYH0saGQ9KGUsdCxyLG8sbik9PntsZXQgcz1yLmxlbmd0aCx1PVwiXCI7Zm9yKGxldCBkPXMtMTtkPj0wOy0tZCl1Kz1gXFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsZCl9KSAtICR7bltkXX07XFxuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcXG4gICAgICAgICAgICAgICAgICBrICs9ICR7cltkXX07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gJHtyW2RdfSkge1xcbiAgICAgICAgICAgICAgICAgIGsgLT0gJHtyW2RdfTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7b1tkXX07XFxuICAgICAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgICAgICAgICR7dX1cXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xcbiAgICAgICAgICBgfSxnZD0oZSx0LHIsbyxuLHMpPT57c3dpdGNoKG4ubW9kZSl7Y2FzZSAwOnJldHVybiBwZChlLHQscixvLG4ucGFkcyxzLG4udmFsdWUpO2Nhc2UgMTpyZXR1cm4gZmQoZSx0LHIsbyxuLnBhZHMpO2Nhc2UgMjpyZXR1cm4gbWQoZSx0LHIsbyxuLnBhZHMpO2Nhc2UgMzpyZXR1cm4gaGQoZSx0LHIsbyxuLnBhZHMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0seWQ9KGUsdCxyLG8pPT57bGV0IG49dFswXS5kaW1zLHM9ay5wYWRTaGFwZShuLnNsaWNlKCksci5wYWRzKSx1PWsuc2l6ZShzKSxkPWsuY29tcHV0ZVN0cmlkZXMobiksYT1YKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxzKSxtPUwoXCJ4XCIsdFswXS5kYXRhVHlwZSxuKSxnPWdkKGEscyxuLGQscixvKTtyZXR1cm5gXFxuICAgICAgICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyhtLGEpfVxcbiAgICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XFxuXFxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7b30oMCk7XFxuICAgICAgICAgICAgICAke2d9XFxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gICAgICAgICAgfWB9LGJkPShlLHQpPT57bGV0IHI9ay5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpO3JldHVybntuYW1lOlwiUGFkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUocikvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpvPT55ZChvLGUsdCxcImYzMlwiKX19LHdkPShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IHI9ZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksbz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhP2VbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MCxuPWVbMF0uZGltcy5sZW5ndGgscz1uZXcgSW50MzJBcnJheSgyKm4pLmZpbGwoMCk7aWYoZS5sZW5ndGg+PTQpe2xldCBkPWVbM10uZ2V0QmlnSW50NjRBcnJheSgpO2ZvcihsZXQgYT0wO2E8ZC5sZW5ndGg7YSsrKXNbTnVtYmVyKGRbYV0pXT1OdW1iZXIoclthXSksc1tOdW1iZXIoZFthXSkrbl09TnVtYmVyKHJbYStkLmxlbmd0aF0pfWVsc2Ugci5mb3JFYWNoKChkLGEpPT5zW051bWJlcihhKV09TnVtYmVyKGQpKTtsZXQgdT1bXTtyZXR1cm4gcy5mb3JFYWNoKGQ9PnUucHVzaChkKSksaWUoe21vZGU6dC5tb2RlLHZhbHVlOm8scGFkczp1fSl9ZWxzZSByZXR1cm4gdH0sRmk9KGUsdCk9PntjZChlLmlucHV0cyk7bGV0IHI9d2QoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKGJkKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9LEhpPWU9PntsZXQgdD1lLm1vZGUscj1lLnZhbHVlLG89ZS5wYWRzO3JldHVybiBpZSh7bW9kZTp0LHZhbHVlOnIscGFkczpvfSl9fSk7dmFyIEhyLEtpLHFpLFlpLFhpLEppLFppLFFpLGVzLHRzLHJzLG5zLG9zLGFzLGlzLHNzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtIcj1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgc3VwcG9ydHMgMS1EIG9yIDItRCBpbnB1dHMgb25seSBmb3Igbm93LlwiKX0sS2k9KGUsdCxyKT0+e2xldCBvPXQuZm9ybWF0PT09XCJOSFdDXCIsbj1lLmRpbXMuc2xpY2UoKTtvJiZuLnNwbGljZSgxLDAsbi5wb3AoKSk7bGV0IHM9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSx1PXQua2VybmVsU2hhcGUuc2xpY2UoKSxkPXQuc3RyaWRlcy5zbGljZSgpLGE9cz90LmRpbGF0aW9ucy5zbGljZSgpOltdLG09dC5wYWRzLnNsaWNlKCk7Q3QuYWRqdXN0UG9vbEF0dHJpYnV0ZXMocixuLHUsZCxhLG0pO2xldCBnPUN0LmNvbXB1dGVQb29sT3V0cHV0U2hhcGUocixuLGQsYSx1LG0sdC5hdXRvUGFkKSx4PU9iamVjdC5hc3NpZ24oe30sdCk7cz9PYmplY3QuYXNzaWduKHgse2tlcm5lbFNoYXBlOnUsc3RyaWRlczpkLHBhZHM6bSxkaWxhdGlvbnM6YSxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbih4LHtrZXJuZWxTaGFwZTp1LHN0cmlkZXM6ZCxwYWRzOm0sY2FjaGVLZXk6dC5jYWNoZUtleX0pO2xldCBiPWcuc2xpY2UoKTtyZXR1cm4gYi5wdXNoKGIuc3BsaWNlKDEsMSlbMF0pLFt4LG8/YjpnXX0scWk9KGUsdCxyLG8sbixzLHUsZCk9PntsZXQgYT1uLmZvcm1hdD09PVwiTkhXQ1wiLG09cixnPXQudHlwZS52YWx1ZSx4PW0ubGVuZ3RoLGI9ay5zaXplKG8pLHc9WChcIm91dHB1dFwiLHQudHlwZS50ZW5zb3Isbyk7aWYobi5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCB2PW4ua2VybmVsU2hhcGVbbi5rZXJuZWxTaGFwZS5sZW5ndGgtMV0seT1uLnN0cmlkZXNbbi5zdHJpZGVzLmxlbmd0aC0xXSxTPW4ucGFkc1tuLnBhZHMubGVuZ3RoLzItMV0sQT1uLnBhZHNbbi5wYWRzLmxlbmd0aC0xXSxSPXgtKGE/MjoxKSxXPVwiXCIsTT1cIlwiLEQ9XCJcIjtpZihTK0EhPT0wP1c9YFxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7dn11OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske1J9XSA9IGluZGljZXNbJHtSfV0gKiAke3l9IC0gJHtTfSArIGk7XFxuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7Un1dIDwgMCB8fCB4SW5kaWNlc1ske1J9XSA+PSAke21bUl19KSB7XFxuICAgICAgICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgICAgICR7c31cXG4gICAgICAgICAgICAgICAgfWA6Vz1gXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHt2fXU7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Un1dID0gaW5kaWNlc1ske1J9XSAqICR7eX0gLSAke1N9ICsgaTtcXG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgICAgICR7c31cXG4gICAgICAgICAgICAgICAgfWAsbi5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgej1uLmtlcm5lbFNoYXBlW24ua2VybmVsU2hhcGUubGVuZ3RoLTJdLEY9bi5zdHJpZGVzW24uc3RyaWRlcy5sZW5ndGgtMl0scT1uLnBhZHNbbi5wYWRzLmxlbmd0aC8yLTJdLGxlPW4ucGFkc1tuLnBhZHMubGVuZ3RoLTJdLEI9eC0oYT8zOjIpLEs9bVtCXTtxK2xlIT09MD9NPWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCAke3p9dTsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtCfV0gPSBpbmRpY2VzWyR7Qn1dICogJHtGfSAtICR7cX0gKyBqO1xcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske0J9XSA8IDAgfHwgeEluZGljZXNbJHtCfV0gPj0gJHtLfSkge1xcbiAgICAgICAgICAgICAgICAgICAgcGFkKz0gJHt2fTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGA6TT1gXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgJHt6fXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Qn1dID0gaW5kaWNlc1ske0J9XSAqICR7Rn0gLSAke3F9ICsgajtcXG4gICAgICAgICAgICAgICAgYCxEPWBcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBgfXJldHVybmBcXG4gICAgICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyh0LHcpfVxcblxcbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGIpfVxcblxcbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke3cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgICAgICAgICB2YXIgdmFsdWU6ICR7Z30gPSAke2d9KCR7ZH0pO1xcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XFxuICAgICAgICAgICAgICAke019XFxuICAgICAgICAgICAgICAke1d9XFxuICAgICAgICAgICAgICAke0R9XFxuICAgICAgICAgICAgICAke3V9XFxuXFxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9YH1lbHNle2lmKGEpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCB2PWsuc2l6ZShuLmtlcm5lbFNoYXBlKSx5PWsuY29tcHV0ZVN0cmlkZXMobi5rZXJuZWxTaGFwZSksUz15Lmxlbmd0aCxBPW4ucGFkcy5sZW5ndGgsUj1uLnBhZHMucmVkdWNlKChELF8pPT5EK18pLFc9XCJcIjtyZXR1cm4gUj9XPWBcXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IGlucHV0RGltc1tqXSkge1xcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgICAke3N9XFxuICAgICAgICAgICAgICB9YDpXPWBcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAke3N9XFxuICAgICAgICAgICAgYCxgXFxuICAgICAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXModCx3KX1cXG5cXG4gICAgICAgICAgICBjb25zdCBwYWRzID0gYXJyYXk8dTMyLCAke0F9Pigke24ucGFkcy5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgICAgICBjb25zdCBpbnB1dERpbXMgPSBhcnJheTx1MzIsICR7eH0+KCR7bS5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgICAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gYXJyYXk8dTMyLCAke1N9Pigke3kubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICAgICAgY29uc3Qgc3RyaWRlcyA9IGFycmF5PHUzMiwgJHtTfT4oJHtuLnN0cmlkZXMubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XFxuXFxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYil9XFxuXFxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgICAgIGxldCB4SW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7U30+O1xcblxcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHt3LnR5cGUudmFsdWV9KCR7ZH0pO1xcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XFxuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcXG5cXG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHt2fXU7IGkrKykge1xcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDB1OyBqIDwgJHtTLTF9dTsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvIGtlcm5lbFN0cmlkZXNbal07XFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiBrZXJuZWxTdHJpZGVzW2pdO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtTLTF9XSA9IG9mZnNldDtcXG5cXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7eC1TfXU7IGogPCAke3h9dTsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogc3RyaWRlc1tqIC0gJHt4LVN9dV1cXG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHt4LVN9dV0gLSBwYWRzW2ogLSAydV07XFxuICAgICAgICAgICAgICAgICAgJHtXfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgJHt1fVxcblxcbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICAgICAgICAgICAgfWB9fSxZaT1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxYaT0oZSx0LHIsbyk9PntsZXRbbixzXT1LaSh0LG8sciksdT1rLnNpemUobi5rZXJuZWxTaGFwZSksZD1MKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zKSxhPWQudHlwZS52YWx1ZSxtPVwidmFsdWUgKz0geF92YWw7XCIsZz1cIlwiO3JldHVybiBuLmNvdW50SW5jbHVkZVBhZD9nKz1gdmFsdWUgLz0gJHthfSgke3V9KTtgOmcrPWB2YWx1ZSAvPSAke2F9KCR7dX0gLSBwYWQpO2Ase25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpvLmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGsuc2l6ZShzKS82NCl9fSksZ2V0U2hhZGVyU291cmNlOng9PnFpKHgsZCx0LmRpbXMscyxuLG0sZyxcIjAuMFwiKX19LEppPWU9PntsZXQgdD1lLmNvdW50X2luY2x1ZGVfcGFkIT09MCxyPVlpKGUpO2lmKHIuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7cmV0dXJuIGllKHtjb3VudEluY2x1ZGVQYWQ6dCwuLi5yfSl9LFppPShlLHQpPT57SHIoZS5pbnB1dHMpLGUuY29tcHV0ZShYaShcIkF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxRaT17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W10sY2FjaGVLZXk6XCJcIn0sZXM9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5RaSxjYWNoZUtleTp0fX0sdHM9KGUsdCk9PntIcihlLmlucHV0cyksZS5jb21wdXRlKFhpKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LHJzPShlLHQscixvKT0+e2xldFtuLHNdPUtpKHQsbyxyKSx1PWBcXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xcbiAgICBgLGQ9XCJcIixhPUwoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMpO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6by5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUocykvNjQpfX0pLGdldFNoYWRlclNvdXJjZTptPT5xaShtLGEsdC5kaW1zLHMsbix1LGQsXCItMWU1XCIpfX0sbnM9KGUsdCk9PntIcihlLmlucHV0cyksZS5jb21wdXRlKHJzKFwiTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0sb3M9ZT0+e2xldCB0PWUuc3RvcmFnZV9vcmRlcixyPWUuZGlsYXRpb25zLG89WWkoZSk7aWYodCE9PTApdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYoby5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO3JldHVybiBpZSh7c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOnIsLi4ub30pfSxhcz1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLlFpLGNhY2hlS2V5OnR9fSxpcz0oZSx0KT0+e0hyKGUuaW5wdXRzKSxlLmNvbXB1dGUocnMoXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBqcj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgdXM9SCgoKT0+e1widXNlIHN0cmljdFwiO2pyKCl9KTt2YXIgbHMsZHM9SCgoKT0+e1widXNlIHN0cmljdFwiO2xzPVwiMS4xNy4wLWRldi4yMDIzMTEwMy0xNDM5ZGEzNmZlXCJ9KTt2YXIgY3MsV24scHM9SCgoKT0+e1widXNlIHN0cmljdFwiO2RzKCk7Y3M9XCJ3YXJuaW5nXCIsV249e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246bHN9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTtjcz1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuIGNzfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KFduLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIGZzLG1zPUgoKCk9PntcInVzZSBzdHJpY3RcIjtwcygpO2ZzPVdufSk7dmFyIGhzPUgoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBncz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7S3IoKX0pO3ZhciBicz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgd3M9SCgoKT0+e1widXNlIHN0cmljdFwiO0tyKCl9KTt2YXIgS3I9SCgoKT0+e1widXNlIHN0cmljdFwiO2hzKCk7Z3MoKTticygpO3dzKCl9KTt2YXIgcXI9SCgoKT0+e1widXNlIHN0cmljdFwiO0tyKCl9KTt2YXIgdnM9SCgoKT0+e1widXNlIHN0cmljdFwiO2pyKCk7cXIoKX0pO3ZhciAkcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dnMoKX0pO3ZhciB4cz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgU3M9SCgoKT0+e1widXNlIHN0cmljdFwiO2pyKCk7cXIoKX0pO3ZhciBDcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7U3MoKX0pO3ZhciBBcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dXMoKTttcygpOyRzKCk7cXIoKTt4cygpO0NzKCl9KTt2YXIgU2QsQ2QsSXMsRXM9SCgoKT0+e1widXNlIHN0cmljdFwiO0FzKCk7RGUoKTt2ZSgpO1NkPShlLHQscik9PntsZXQgbz1lPT09dCxuPWU8dCYmcjwwLHM9ZT50JiZyPjA7aWYob3x8bnx8cyl0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSB0aGVzZSBpbnB1dHNcXCcgY29udGVudHMgYXJlIGludmFsaWQuXCIpfSxDZD0oZSx0LHIsbyk9PntsZXQgbj1NYXRoLmFicyhNYXRoLmNlaWwoKHQtZSkvcikpLHM9W25dLHU9bixkPVgoXCJvdXRwdXRcIixvLHMpLGE9ZC50eXBlLnN0b3JhZ2UsbT1nPT5gXFxuICAgICAgICAke2cuZGVjbGFyZVZhcmlhYmxlcyhkKX1cXG4gICAgICAgICR7Zy5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxcbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHthfSgke2V9KSArICR7YX0oZ2xvYmFsX2lkeCkgKiAke2F9KCR7cn0pO1xcbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmFuZ2VcIixzaGFkZXJDYWNoZTp7aGludDpbZSx0LHJdLm1hcChnPT5nLnRvU3RyaW5nKCkpLmpvaW4oXCJfXCIpfSxnZXRTaGFkZXJTb3VyY2U6bSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfX0pfX0sSXM9ZT0+e2xldCB0PTAscj0wLG89MDtlLmlucHV0c1swXS5kYXRhVHlwZT09PTY/KHQ9ZS5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdLG89ZS5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdKTplLmlucHV0c1swXS5kYXRhVHlwZT09PTEmJih0PWUuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0sbz1lLmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSksZnMud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZTZCh0LHIsbyksZS5jb21wdXRlKENkKHQscixvLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSx7aW5wdXRzOltdfSl9fSk7dmFyIEFkLElkLEVkLFRkLE9kLF9kLFJkLFBkLE1kLEJkLGtkLERkLFdkLHpkLFZkLFRzLE9zLF9zPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtBZD0oZSx0KT0+e2lmKGUuZXZlcnkocj0+cj4wfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZVwiKX0pKSxlLmxlbmd0aD4wKXtpZih0Lm1vZGU9PT1cImxpbmVhclwiKXtpZighKGUubGVuZ3RoPT09Mnx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBsaW5lYXIgbW9kZVwiKX1lbHNlIGlmKHQubW9kZT09PVwiY3ViaWNcIiYmIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZVwiKX19LElkPShlLHQscik9Pnt0LmV2ZXJ5KG49Pm4+PTAmJm48cnx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFua1wiKX0pKTtsZXQgbz1uZXcgQXJyYXkocikuZmlsbCgxKTtyZXR1cm4gdC5mb3JFYWNoKChuLHMpPT5vW25dPWVbc10pLG99LEVkPShlLHQscixvLG4scyk9PntsZXRbdSxkLGFdPXI+MTA/WzEsMiwzXTpbLTEsZS5sZW5ndGg+MT8xOi0xLC0xXSxtPWVbMF0uZGltcy5sZW5ndGg7aWYodT4wJiZlLmxlbmd0aD51JiZlW3VdLmRpbXMubGVuZ3RoPjApZVt1XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKGc9PnMucHVzaChnKSk7ZWxzZSBpZih0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIil0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZVwiKTtpZihkPjAmJmUubGVuZ3RoPmQmJmVbZF0uZGltcy5sZW5ndGg+MCl7aWYoZVtkXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKGc9Pm8ucHVzaChnKSksby5sZW5ndGghPT0wJiZvLmxlbmd0aCE9PW0mJnI+PTE4JiZvLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtBZChvLHQpLHQuYXhlcy5sZW5ndGg+MCYmSWQobyx0LmF4ZXMsbSkuZm9yRWFjaCgoZyx4KT0+b1t4XT1nKX1pZihhPjAmJmUubGVuZ3RoPmEmJihlW2FdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKGc9Pm4ucHVzaChOdW1iZXIoZykpKSxuLmxlbmd0aCE9PW18fHI+PTE4JiZuLmxlbmd0aD09PXQuYXhlcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzaXplcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtpZih0LmF4ZXMubGVuZ3RoPjApe2lmKG8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXFwnUmVzaXplIHJlcXVpcmVzIFwic2NhbGVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkXFwnKTtpZihuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFxcJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWRcXCcpfWlmKHR5cGVvZiBvPFwidVwiJiZ0eXBlb2YgbjxcInVcIiYmby5sZW5ndGg+MCYmbi5sZW5ndGg+bSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkXCIpfSxUZD1lPT5cImZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogZjMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogZjMyLCAgICBsZW5ndGhPcmlnaW5hbDogZjMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gZjMyIHsgXCIrKCgpPT57c3dpdGNoKGUpe2Nhc2VcImFzeW1tZXRyaWNcIjpyZXR1cm5cInJldHVybiB4UmVzaXplZCAvIHhTY2FsZTtcIjtjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpyZXR1cm5cImlmIChsZW5ndGhSZXNpemVkID4gMSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlIC0gMC41OyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJ0Zl9oYWxmX3BpeGVsX2Zvcl9ublwiOnJldHVyblwicmV0dXJuICh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGU7XCI7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnJldHVyblwiaWYgKGxlbmd0aFJlc2l6ZWQgPT0gMSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwidGZfY3JvcF9hbmRfcmVzaXplXCI6cmV0dXJuXCJpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9pU3RhcnQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSArICAgICAgICAgICAgICAgICAgICAgICAgICAgKHhSZXNpemVkICogKHJvaUVuZCAtIHJvaVN0YXJ0KSAqIChsZW5ndGhPcmlnaW5hbCAtIDEpKSAvIChsZW5ndGhSZXNpemVkIC0gMSk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChyb2lTdGFydCArIHJvaUVuZCkgKiBmMzIobGVuZ3RoT3JpZ2luYWwgLSAxKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuW1wiY29uc3Qgb3V0cHV0V2lkdGggPSB4U2NhbGUgKiBsZW5ndGhSZXNpemVkO1wiLFwiY29uc3QgYWRqdXN0bWVudCA9IGxlbmd0aFJlc2l6ZWQgLyBvdXRwdXRXaWR0aDtcIixcImNvbnN0IGNlbnRlciA9IGxlbmd0aE9yaWdpbmFsIC8gMjtcIixcImNvbnN0IG9mZnNldCA9IGNlbnRlciAqICgxIC0gYWRqdXN0bWVudCk7XCIsXCJyZXR1cm4gb2Zmc2V0ICsgKCh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGUpIC0gMC41O1wiXS5qb2luKGBcXG5gKTtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuXCJyZXR1cm4gKCh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGUpIC0gMC41O1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsT2Q9KGUsdCk9PlwiZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogZjMyLCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+IGYzMiB7XCIrKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsX2Q9KGUsdCxyKT0+e2xldCBvPW5ldyBBcnJheShyKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkocikuZmlsbCgxKSksbj1lLmxlbmd0aD09PTA/bzplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgocyx1KT0+e29bc109blt1XSxvW3Urcl09blt0Lmxlbmd0aCt1XX0pLG8pOm59LFJkPShlLHQscixvKT0+e2xldCBuPVtdO2lmKHIubGVuZ3RoPjApaWYoby5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKHM9Pm4ucHVzaChzKSksTWF0aC5tYXgoLi4ubyk+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7by5mb3JFYWNoKChzLHUpPT5uW3NdPXJbdV0pfWVsc2Ugci5mb3JFYWNoKHM9Pm4ucHVzaChzKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO249ZS5tYXAoKHMsdSk9Pk1hdGgucm91bmQocyp0W3VdKSl9cmV0dXJuIG59LFBkPShlLHQscixvKT0+e2xldCBuPSgoKT0+e3N3aXRjaChvLmtlZXBBc3BlY3RSYXRpb1BvbGljeSl7Y2FzZVwibm90X2xhcmdlclwiOnJldHVybiBvLmF4ZXMubGVuZ3RoPjA/TWF0aC5taW4oLi4uby5heGVzLm1hcCh1PT5yW3VdKSxOdW1iZXIuTUFYX1ZBTFVFKTpNYXRoLm1pbiguLi5yLE51bWJlci5NQVhfVkFMVUUpO2Nhc2VcIm5vdF9zbWFsbGVyXCI6cmV0dXJuIG8uYXhlcy5sZW5ndGg+MD9NYXRoLm1heCguLi5vLmF4ZXMubWFwKHU9PnJbdV0pLE51bWJlci5NSU5fVkFMVUUpOk1hdGgubWF4KC4uLnIsTnVtYmVyLk1JTl9WQUxVRSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke28ua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKTtyLmZpbGwoMSwwLHIubGVuZ3RoKTtsZXQgcz1lLnNsaWNlKCk7cmV0dXJuIG8uYXhlcy5sZW5ndGg+MD8oby5heGVzLmZvckVhY2godT0+clt1XT1uKSxvLmF4ZXMuZm9yRWFjaCh1PT5zW3VdPU1hdGgucm91bmQoZVt1XSpyW3VdKSkpOihyLmZpbGwobiwwLHIubGVuZ3RoKSxzLmZvckVhY2goKHUsZCk9PnNbZF09TWF0aC5yb3VuZCh1KnJbZF0pKSksc30sTWQ9KGUsdCxyLG8sbik9PmBcXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PGYzMiwgJHtyLmxlbmd0aH0+IHtcXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3QubGVuZ3RofT4oJHt0Lm1hcChzPT5gJHtzfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3IubGVuZ3RofT4oJHtyLm1hcChzPT5gJHtzfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgIGNvbnN0IHNjYWxlcyA9IGFycmF5PGYzMiwgJHtvLmxlbmd0aH0+KCR7by5tYXAocz0+YCR7c31mYCkuam9pbihcIixcIil9KTtcXG4gICAgICBjb25zdCByb2kgPSBhcnJheTxmMzIsICR7bi5sZW5ndGh9Pigke24ubWFwKHM9PmAke3N9ZmApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlczogYXJyYXk8ZjMyLCAke3IubGVuZ3RofT47XFxuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xcbiAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHtyLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6XCJvdXRwdXRJbmRpY2VzW2ldXCJ9O1xcbiAgICAgICAgaWYgKHNjYWxlc1tpXSA9PSAxLjApIHtcXG4gICAgICAgICAgb3JpZ2luYWxJbmRpY2VzW2ldID0gZjMyKG91dHB1dEluZGV4KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG9yaWdpbmFsSW5kaWNlc1tpXSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShmMzIob3V0cHV0SW5kZXgpLCBzY2FsZXNbaV0sXFxuICAgICAgICAgICAgICAgIGYzMihvdXRwdXRTaGFwZVtpXSksIGYzMihpbnB1dFNoYXBlW2ldKSwgcm9pW2ldLCByb2lbaSArICR7dC5sZW5ndGh9XSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBvcmlnaW5hbEluZGljZXM7XFxuICAgIH1gLEJkPShlLHQscixvLG4scyx1KT0+YFxcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xcbiAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHtyLmxlbmd0aH0+KCR7ci5tYXAoZD0+YCR7ZH11YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYXJyYXk8dTMyLCAke28ubGVuZ3RofT4oJHtvLm1hcChkPT5gJHtkfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgc2NhbGVzID0gYXJyYXk8ZjMyLCAke24ubGVuZ3RofT4oJHtuLm1hcChkPT5gJHtkfWZgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgcm9pID0gYXJyYXk8ZjMyLCAke3MubGVuZ3RofT4oJHtzLm1hcChkPT5gJHtkfWZgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XFxuICAgICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke28ubGVuZ3RofTsgaSsrKSB7XFxuICAgICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7by5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOlwib3V0cHV0SW5kaWNlc1tpXVwifTtcXG4gICAgICAgICAgdmFyIGlucHV0SW5kZXg6IHUzMjtcXG4gICAgICAgICAgaWYgKHNjYWxlc1tpXSA9PSAxLjApIHtcXG4gICAgICAgICAgICBpbnB1dEluZGV4ID0gb3V0cHV0SW5kZXg7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsX2lkeCA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShmMzIob3V0cHV0SW5kZXgpLCBzY2FsZXNbaV0sXFxuICAgICAgICAgICAgICAgICAgICBmMzIob3V0cHV0U2hhcGVbaV0pLCBmMzIoaW5wdXRTaGFwZVtpXSksIHJvaVtpXSwgcm9pW2kgKyAke3IubGVuZ3RofV0pO1xcbiAgICAgICAgICAgIGlmICghJHt1fSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgZjMyKGlucHV0U2hhcGVbaV0pKSkge1xcbiAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcXG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IDA7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+IChmMzIoaW5wdXRTaGFwZVtpXSkgLSAxKSkge1xcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gaW5wdXRTaGFwZVtpXSAtIDE7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlc1tpXSA8IDEpKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRJbmRleFwiKX1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpbnB1dEluZGljZXM7XFxuICAgIH1gLGtkPShlLHQpPT5gXFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7dC5sZW5ndGh9Pigke3QubWFwKHI9PmAke3J9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xcbiAgICAgICAgdmFyIGlucHV0SW5kZXggPSAke3QubGVuZ3RoPT09MT9cImlucHV0SW5kaWNlc1wiOlwiaW5wdXRJbmRpY2VzW2ldXCJ9O1xcbiAgICAgICAgaWYgKGlucHV0SW5kZXggPCAwIHx8IGlucHV0SW5kZXggPj0gaW5wdXRTaGFwZVtpXSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9YCxEZD0oZSx0LHIsbyxuLHMsdSk9PntsZXRbZCxhLG0sZ109ci5sZW5ndGg9PT0yP1stMSwwLDEsLTFdOm5bMV09PT0xP1swLDIsMywxXTpbMCwxLDIsM107cmV0dXJuYFxcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgcm93OiB1MzIsIGNvbDogdTMyKSAtPiBmMzIge1xcbiAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xcbiAgICAgIGlucHV0SW5kaWNlc1ske2F9XSA9IG1heCgwLCBtaW4ocm93LCAke3JbYV19IC0gMSkpO1xcbiAgICAgIGlucHV0SW5kaWNlc1ske219XSA9IG1heCgwLCBtaW4oY29sLCAke3JbbV19IC0gMSkpO1xcbiAgICAgIGlmICgke3IubGVuZ3RofSA+IDIpIHtcXG4gICAgICAgIGlucHV0SW5kaWNlc1ske2d9XSA9IGNoYW5uZWw7XFxuICAgICAgICBpbnB1dEluZGljZXNbJHtkfV0gPSBiYXRjaDtcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiBpbnB1dFske2UuaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzXCIpfV07XFxuICAgIH1cXG5cXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiBmMzIge1xcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzKTtcXG4gICAgICB2YXIgcm93OmYzMiA9IG9yaWdpbmFsSW5kaWNlc1ske2F9XTtcXG4gICAgICB2YXIgY29sOmYzMiA9IG9yaWdpbmFsSW5kaWNlc1ske219XTtcXG4gICAgICBpZiAoJHtzfSAmJiAocm93IDwgMCB8fCByb3cgPiAoJHtyW2FdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gJHtyW21dfSAtIDEpKSB7XFxuICAgICAgICByZXR1cm4gJHt1fTtcXG4gICAgICB9XFxuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7clthXX0gLSAxKSk7XFxuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7clttXX0gLSAxKSk7XFxuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcXG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XFxuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9IDA7XFxuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAwO1xcbiAgICAgIGlmICgke3IubGVuZ3RoPjJ9KSB7XFxuICAgICAgICBjaGFubmVsID0gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2d9XSk7XFxuICAgICAgICBiYXRjaCA9IHUzMihvcmlnaW5hbEluZGljZXNbJHtkfV0pO1xcbiAgICAgIH1cXG4gICAgICB2YXIgeDExOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcXG4gICAgICB2YXIgeDEyOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcXG4gICAgICB2YXIgeDIxOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcXG4gICAgICB2YXIgeDIyOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcXG4gICAgICB2YXIgZHgxOiBmMzIgPSByb3cgLSBmMzIocm93MSk7XFxuICAgICAgdmFyIGR4MjogZjMyID0gZjMyKHJvdzIgKSAtIHJvdztcXG4gICAgICB2YXIgZHkxID0gY29sIC0gZjMyKGNvbDEpO1xcbiAgICAgIHZhciBkeTIgPSBmMzIoY29sMikgLSBjb2w7XFxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xcbiAgICB9YH0sV2Q9KGUsdCxyLG8sbixzLHUsZCxhLG0pPT57bGV0W2cseF09ci5sZW5ndGg9PT0yP1swLDFdOm5bMV09PT0xP1syLDNdOlsxLDJdLGI9dz0+e2xldCB2PXc9PT1nP1wicm93XCI6XCJjb2xcIjtyZXR1cm5gXFxuICAgICAgZm4gJHt2fUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9LCBvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gZjMyIHtcXG4gICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7by5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOmBvdXRwdXRJbmRpY2VzWyR7d31dYH07XFxuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6IGYzMiA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShmMzIob3V0cHV0SW5kZXgpLCAke25bd119LFxcbiAgICAgICAgZjMyKCR7b1t3XX0pLCBmMzIoJHtyW3ddfSksICR7c1t3XX0sICR7c1t3XX0gKyAke3IubGVuZ3RofSk7XFxuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogZjMyID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XFxuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcXG5cXG4gICAgICAgIGlmICgke2R9ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtyW3ddfSAtIDEpKSkge1xcbiAgICAgICAgICByZXR1cm4gJHthfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBkYXRhOiBhcnJheTxmMzIsIDQ+ID0gYXJyYXk8ZjMyLCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcXG4gICAgICAgICAgdmFyICR7dn06IGYzMiA9IG9yaWdpbmFsSWR4ICsgZjMyKGkpO1xcbiAgICAgICAgICBpZiAoJHt2fSA8IDAgfHwgJHt2fSA+PSAke3Jbd119KSB7XFxuICAgICAgICAgICAgaWYgKCR7bX0pIHtcXG4gICAgICAgICAgICAgIGNvZWZzW2kgKyAxXSA9IDAuMDtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtkfSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuICR7YX07XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICR7dn0gPSBtYXgoMCwgbWluKCR7dn0sICR7clt3XX0gLSAxKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHZhciBpbnB1dEluZGljZXNDb3B5OiAke2UudHlwZS5pbmRpY2VzfSA9IGlucHV0SW5kaWNlcztcXG4gICAgICAgICAgaW5wdXRJbmRpY2VzQ29weVske3d9XSA9IHUzMigke3Z9KTtcXG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke3c9PT1nP2BpbnB1dFske2UuaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzQ29weVwiKX1dO2A6YFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0SW5kaWNlc0NvcHksIG91dHB1dEluZGljZXMpO2B9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xcbiAgICAgIH1gfTtyZXR1cm5gXFxuICAgICR7YihnKX07XFxuICAgICR7Yih4KX07XFxuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiBmMzIpIC0+IGFycmF5PGYzMiwgND4ge1xcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcXG4gICAgdmFyIGNvZWZmczogYXJyYXk8ZjMyLCA0PiA9IGFycmF5PGYzMiwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgdmFyIG9uZU1pbnVzQWJzUzogZjMyID0gMS4wIC0gYWJzUztcXG4gICAgdmFyIHR3b01pbnVzQWJzUzogZjMyID0gMi4wIC0gYWJzUztcXG4gICAgdmFyIG9uZVBsdXNBYnNTOiBmMzIgPSAxLjAgKyBhYnNTO1xcbiAgICBjb2VmZnNbMF0gPSAoKCR7dX0gKiBvbmVQbHVzQWJzUyAtIDUgKiAke3V9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7dX0pICogb25lUGx1c0Fic1MgLSA0ICogJHt1fTtcXG4gICAgY29lZmZzWzFdID0gKCgke3V9ICsgMikgKiBhYnNTIC0gKCR7dX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XFxuICAgIGNvZWZmc1syXSA9ICgoJHt1fSArIDIpICogb25lTWludXNBYnNTIC0gKCR7dX0gKyAzKSkgKiBvbmVNaW51c0Fic1MgKiBvbmVNaW51c0Fic1MgKyAxO1xcbiAgICBjb2VmZnNbM10gPSAoKCR7dX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHt1fSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHt1fSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHt1fTtcXG4gICAgcmV0dXJuIGNvZWZmcztcXG4gIH1cXG5cXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PGYzMiwgND4sIGNvZWZzOiBhcnJheTxmMzIsIDQ+KSAtPiBmMzIge1xcbiAgICB2YXIgY29lZnNTdW06IGYzMiA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XFxuICB9XFxuXFxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gZjMyIHtcXG4gICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRJbmRpY2VzO1xcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0SW5kaWNlcywgb3V0cHV0SW5kaWNlcyk7XFxuICB9XFxuICAgIGB9LHpkPShlLHQscixvLG4scyk9PntsZXQgdT1lLmRpbXMsZD1fZChzLHQuYXhlcyx1Lmxlbmd0aCksYT1SZCh1LG8sbix0LmF4ZXMpLG09by5zbGljZSgpO28ubGVuZ3RoPT09MCYmKG09dS5tYXAoKFMsQSk9PlM9PT0wPzE6YVtBXS9TKSx0LmtlZXBBc3BlY3RSYXRpb1BvbGljeSE9PVwic3RyZXRjaFwiJiYoYT1QZCh1LGEsbSx0KSkpO2xldCBnPVgoXCJvdXRwdXRcIixlLmRhdGFUeXBlLGEpLHg9TChcImlucHV0XCIsZS5kYXRhVHlwZSx1KSxiPWsuc2l6ZShhKSx3PXUubGVuZ3RoPT09YS5sZW5ndGgmJnUuZXZlcnkoKFMsQSk9PlM9PT1hW0FdKSx2PXQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLHk9Uz0+YFxcbiAgICAgICR7VGQodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSl9O1xcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcXG4gICAgICAgICAgICAgICR7a2QoeCx1KX07XFxuICAgICAgICAgICAgICAke09kKHQubmVhcmVzdE1vZGUscil9O1xcbiAgICAgICAgICAgICAgJHtCZCh4LGcsdSxhLG0sZCx2KX07XFxuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcXG4gICAgICAgICAgICAgICR7TWQoZyx1LGEsbSxkKX07XFxuICAgICAgICAgICAgICAke0RkKHgsZyx1LGEsbSx2LHQuZXh0cmFwb2xhdGlvblZhbHVlKX07XFxuICAgICAgICAgICAgICBgO2Nhc2VcImN1YmljXCI6cmV0dXJuYFxcbiAgICAgICAgICAgICR7V2QoeCxnLHUsYSxtLGQsdC5jdWJpY0NvZWZmQSx2LHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfTtcXG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xcbiAgICAgICR7Uy5kZWNsYXJlVmFyaWFibGVzKHgsZyl9XFxuICAgICAgJHtTLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYil9XFxuICAgICAgICBpZiAoJHt3fSkge1xcbiAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3gudHlwZS5pbmRpY2VzfTtcXG4gICAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0SW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXMpO1xcbiAgICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dEluZGljZXMpKSB7XFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFske3guaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVyblwib3V0cHV0W2dsb2JhbF9pZHhdID0gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXMpO1wiO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzKTtcIjtkZWZhdWx0OnRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHt0Lm1vZGV9YCl9fSkoKX07XFxuICAgICAgICB9XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSZXNpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke3J9fCR7bS5sZW5ndGg+MD9tOlwiXCJ9fCR7bi5sZW5ndGg+MD9uOlwiXCJ9YH0sZ2V0U2hhZGVyU291cmNlOnksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChiLzY0KX19KX19LFZkPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sVHM9KGUsdCk9PntsZXQgcj1bXSxvPVtdLG49W10scz1WZChlKTtFZChlLmlucHV0cyx0LHMscixvLG4pLGUuY29tcHV0ZSh6ZChlLmlucHV0c1swXSx0LHMscixvLG4pLHtpbnB1dHM6WzBdfSl9LE9zPWU9PntsZXQgdD1lLmFudGlhbGlhcyxyPWUuYXhlcyxvPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbj1lLmN1YmljQ29lZmZBLHM9ZS5leGNsdWRlT3V0c2lkZSE9PTAsdT1lLmV4dHJhcG9sYXRpb25WYWx1ZSxkPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LGE9ZS5tb2RlLG09ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiBpZSh7YW50aWFsaWFzOnQsYXhlczpyLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOm8sY3ViaWNDb2VmZkE6bixleGNsdWRlT3V0c2lkZTpzLGV4dHJhcG9sYXRpb25WYWx1ZTp1LGtlZXBBc3BlY3RSYXRpb1BvbGljeTpkLG1vZGU6YSxuZWFyZXN0TW9kZTptfSl9fSk7dmFyIEdkLE5kLFJzLFBzLE1zPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7UGUoKTt2ZSgpO0dkPWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0scj1lWzFdLG89ZVsyXTtpZih0LmRhdGFUeXBlIT09ci5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PW8uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG49dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0scz10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMl0hPT1zKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihvLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKG8uZGltc1tvLmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IHU9ZVszXTtpZih1LmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYodS5kaW1zW3UuZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCB1PWVbNF07aWYodS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKHUuZGltc1t1LmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LE5kPShlLHQscixvKT0+e2xldCBuPWVbMF0uZGltcyxzPWsuc2l6ZShuKSx1PW4sZD1zLGE9bi5zbGljZSgtMSlbMF0sbT1vP24uc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLGc9ZS5sZW5ndGg+Myx4PWUubGVuZ3RoPjQsYj1vJiZyPjEsdz1vJiZyPjIsdj1yPjMseT1sdChhKSxTPVtMKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHkpLEwoXCJza2lwXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMseSksTChcImdhbW1hXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMseSldO2cmJlMucHVzaChMKFwiYmV0YVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLHkpKSx4JiZTLnB1c2goTChcImJpYXNcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcyx5KSksUy5wdXNoKFgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHUseSkpLGImJlMucHVzaChYKFwibWVhbk91dHB1dFwiLDEsbSkpLHcmJlMucHVzaChYKFwiaW52U3RkT3V0cHV0XCIsMSxtKSksdiYmUy5wdXNoKFgoXCJpbnB1dFNraXBCaWFzU3VtXCIsZVswXS5kYXRhVHlwZSx1LHkpKTtsZXQgQT1NZShlWzBdLmRhdGFUeXBlKSxSPU09PmBcXG4gICAgICBjb25zdCBoaWRkZW5TaXplOiBmMzIgPSAke2F9O1xcbiAgICAgIGNvbnN0IGhpZGRlblNpemVWZWN0b3JpemVkOiB1MzIgPSAke2EveX07XFxuICAgICAgY29uc3QgZXBzaWxvbjogZjMyID0gJHt0LmVwc2lsb259O1xcblxcbiAgICAgICR7TS5kZWNsYXJlVmFyaWFibGVzKC4uLlMpfVxcblxcbiAgICAgICR7TS5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7TS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGQvYSl9XFxuICAgICAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIGhpZGRlblNpemVWZWN0b3JpemVkO1xcbiAgICAgICAgdmFyIHN1bSA9ICR7cWUoXCJmMzJcIix5KX07XFxuICAgICAgICB2YXIgc3F1YXJlU3VtID0gJHtxZShcImYzMlwiLHkpfTtcXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBoaWRkZW5TaXplVmVjdG9yaXplZDsgaSsrKSB7XFxuICAgICAgICAgIGxldCBza2lwVmFsdWUgPSBza2lwW29mZnNldCArIGldO1xcbiAgICAgICAgICBsZXQgYmlhc1ZhbHVlID0gJHt4P1wiYmlhc1tpXVwiOlwiMC4wXCJ9O1xcbiAgICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IHhbb2Zmc2V0ICsgaV07XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0VmFsdWUgKyBza2lwVmFsdWUgKyBiaWFzVmFsdWU7XFxuICAgICAgICAgICR7dj9cImlucHV0U2tpcEJpYXNTdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcIjpcIlwifVxcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcXG4gICAgICAgICAgbGV0IGYzMlZhbHVlID0gJHtBdChBLHksXCJ2YWx1ZVwiKX07XFxuICAgICAgICAgIHN1bSArPSBmMzJWYWx1ZTtcXG4gICAgICAgICAgc3F1YXJlU3VtICs9IGYzMlZhbHVlICogZjMyVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgbWVhbiA9ICR7aHQoXCJzdW1cIix5KX0gLyBoaWRkZW5TaXplO1xcbiAgICAgICAgbGV0IHZhcmlhbmNlID0gc3FydCgke2h0KFwic3F1YXJlU3VtXCIseSl9IC8gaGlkZGVuU2l6ZSAtIG1lYW4gKiBtZWFuICsgZXBzaWxvbik7XFxuICAgICAgICAke2I/XCJtZWFuT3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjtcIjpcIlwifVxcbiAgICAgICAgJHt3P1wiaW52U3RkT3V0cHV0W2dsb2JhbF9pZHhdID0gMS4wIC8gdmFyaWFuY2U7XCI6XCJcIn1cXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBoaWRkZW5TaXplVmVjdG9yaXplZDsgaSsrKSB7XFxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gLSAke0F9KG1lYW4pKSAvICR7QX0odmFyaWFuY2UpICogZ2FtbWFbaV1cXG4gICAgICAgICAgICsgJHtnP1wiYmV0YVtpXVwiOlwiMC4wXCJ9O1xcbiAgICAgICAgfVxcbiAgICAgIH1gLFc9W3tkaW1zOnUsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiByPjEmJlcucHVzaCh7ZGltczptLGRhdGFUeXBlOjF9KSxyPjImJlcucHVzaCh7ZGltczptLGRhdGFUeXBlOjF9KSxyPjMmJlcucHVzaCh7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KSx7bmFtZTpcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRTaGFkZXJTb3VyY2U6UixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VyxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkL2EvNjQpfX0pfX0sUnM9KGUsdCk9PntHZChlLmlucHV0cyk7bGV0IG89WzBdO2Uub3V0cHV0Q291bnQ+MSYmby5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJm8ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZvLnB1c2goMyksZS5jb21wdXRlKE5kKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6b30pfSxQcz1lPT57bGV0IHQ9ZS5lcHNpbG9uO3JldHVybiBpZSh7ZXBzaWxvbjp0fSl9fSk7dmFyIFVkLFlyLExkLEJzLEZkLEhkLGtzLERzLFdzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7UGUoKTt2ZSgpO1VkPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7aWYodC5heGVzLmxlbmd0aCE9PTApe2lmKHQuYXhlcy5sZW5ndGghPT10LnN0YXJ0cy5sZW5ndGh8fHQuYXhlcy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpfWVsc2UgaWYodC5zdGFydHMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtlLnNsaWNlKDEpLmZvckVhY2goKHIsbyk9PntpZihlW28rMV0uZGF0YVR5cGUhPT02JiZlW28rMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtvfSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCl9KX0sWXI9KGUsdCk9PntsZXQgcj1bXTtpZihlLmxlbmd0aD50KWlmKGVbdF0uZGF0YVR5cGU9PT03KWVbdF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobz0+ci5wdXNoKE51bWJlcihvKSkpO2Vsc2UgaWYoZVt0XS5kYXRhVHlwZT09PTYpZVt0XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaChvPT5yLnB1c2goTnVtYmVyKG8pKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO3JldHVybiByfSxMZD0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPVlyKGUsMSksbz1ZcihlLDIpLG49WXIoZSwzKTtyZXR1cm4gbi5sZW5ndGg9PT0wJiYobj1bLi4uQXJyYXkoZVswXS5kaW1zLmxlbmd0aCkua2V5cygpXSksaWUoe3N0YXJ0czpyLGVuZHM6byxheGVzOm59KX1lbHNlIHJldHVybiB0fSxCcz0oZSx0LHIsbyxuKT0+e2xldCBzPWU7cmV0dXJuIGU8MCYmKHMrPXJbb1t0XV0pLG5bdF08MD9NYXRoLm1heCgwLE1hdGgubWluKHMscltvW3RdXS0xKSk6TWF0aC5tYXgoMCxNYXRoLm1pbihzLHJbb1t0XV0pKX0sRmQ9KGUsdCxyLG8pPT5gZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XFxuICAgICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcXG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7ci5sZW5ndGh9OyBpID49IDA7IGktLSkge1xcbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7by5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOlwib3V0cHV0SW5kaWNlc1tpXVwifTtcXG4gICAgICAgICAgICB2YXIgaW5wdXRJbmRleCA9IG91dHB1dEluZGV4ICogc3RlcHNbaV0gKyBzdGFydHNbaV0gKyBjYXJyeTtcXG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0SW5kZXggLyBpbnB1dFNoYXBlW2ldO1xcbiAgICAgICAgICAgIGlucHV0SW5kZXggPSBpbnB1dEluZGV4ICUgaW5wdXRTaGFwZVtpXTtcXG4gICAgICAgICAgICBpZiAoc2lnbnNbaV0gPCAwKSB7XFxuICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gaW5wdXRTaGFwZVtpXSAtIGlucHV0SW5kZXggLSAxdSArIHN0YXJ0c1tpXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgJHtyLmxlbmd0aD09PTE/XCJpbnB1dEluZGljZXNcIjpcImlucHV0SW5kaWNlc1tpXVwifSA9IGlucHV0SW5kZXg7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIGlucHV0SW5kaWNlcztcXG4gICAgICB9YCxIZD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxvPWsuc2l6ZShyKSxuPXQuYXhlcy5sZW5ndGg+MD9rLm5vcm1hbGl6ZUF4ZXModC5heGVzLHIubGVuZ3RoKTpbLi4uQXJyYXkoci5sZW5ndGgpLmtleXMoKV0scz1ZcihlLDQpO3MuZm9yRWFjaCh5PT55IT09MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwic3RlcCBjYW5ub3QgYmUgMFwiKX0pKSxzLmxlbmd0aD09PTAmJihzPUFycmF5KG4ubGVuZ3RoKS5maWxsKDEpKTtsZXQgdT10LnN0YXJ0cy5tYXAoKHksUyk9PkJzKHksUyxyLG4scykpLGQ9dC5lbmRzLm1hcCgoeSxTKT0+QnMoeSxTLHIsbixzKSk7aWYobi5sZW5ndGghPT1yLmxlbmd0aClmb3IobGV0IHk9MDt5PHIubGVuZ3RoOysreSluLmluY2x1ZGVzKHkpfHwodS5zcGxpY2UoeSwwLDApLGQuc3BsaWNlKHksMCxyW3ldKSxzLnNwbGljZSh5LDAsMSkpO2xldCBhPXMubWFwKHk9Pk1hdGguc2lnbih5KSk7cy5mb3JFYWNoKCh5LFMsQSk9PntpZih5PDApe2xldCBSPShkW1NdLXVbU10pL3ksVz11W1NdLE09VytSKnNbU107dVtTXT1NLGRbU109VyxBW1NdPS15fX0pO2xldCBtPXIuc2xpY2UoMCk7bi5mb3JFYWNoKCh5LFMpPT57bVt5XT1NYXRoLmNlaWwoKGRbeV0tdVt5XSkvc1t5XSl9KTtsZXQgZz17ZGltczptLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9LHg9WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbSksYj1MKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLHIpLHc9ay5zaXplKG0pLHY9eT0+YFxcbiAgICAgICR7eS5kZWNsYXJlVmFyaWFibGVzKGIseCl9XFxuICAgICAgICBjb25zdCBzaWducyA9IGFycmF5PGkzMiwgJHthLmxlbmd0aH0+KCR7YS5tYXAoUz0+YCR7U31pYCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IGFycmF5PHUzMiwgJHt1Lmxlbmd0aH0+KCR7dS5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IGVuZHMgPSBhcnJheTx1MzIsICR7ZC5sZW5ndGh9Pigke2QubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBzdGVwcyA9IGFycmF5PHUzMiwgJHtzLmxlbmd0aH0+KCR7cy5tYXAoUz0+YCR7U311YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7ci5sZW5ndGh9Pigke3IubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XFxuXFxuICAgICAgICAke0ZkKGIseCxyLG0pfVxcbiAgICAgICAgJHt5Lm1haW5TdGFydCgpfVxcbiAgICAgICAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh3KX1cXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3gub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAgIGxldCBpbnB1dEluZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0SW5kaWNlcyk7XFxuICAgICAgICAgICR7eC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixiLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKSl9XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJTbGljZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7ZVs0XT8uZGltcz8/XCJcIn1gfSxnZXRTaGFkZXJTb3VyY2U6dixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W2ddLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfX0pfX0sa3M9KGUsdCk9PntVZChlLmlucHV0cyx0KTtsZXQgcj1MZChlLmlucHV0cyx0KTtlLmNvbXB1dGUoSGQoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sRHM9ZT0+e2xldCB0PWUuc3RhcnRzLHI9ZS5lbmRzLG89ZS5heGVzO3JldHVybiBpZSh7c3RhcnRzOnQsZW5kczpyLGF4ZXM6b30pfX0pO3ZhciBqZCxLZCx6cyxWcyxHcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7amQ9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LlwiKX0sS2Q9KGUsdCk9PntsZXQgcj1NZShlLmRhdGFUeXBlKSxvPWUuZGltcyxuPWsuc2l6ZShvKSxzPTY0LHU9dC5heGlzO2lmKHU8MCYmKHU9by5sZW5ndGgrdSksdTxvLmxlbmd0aC0xKXRocm93IG5ldyBFcnJvcihcInNvZnRtYXggb25seSBzdXBwb3J0cyBsYXN0IGF4aXMgZm9yIG5vdy5cIik7bGV0IGQ9b1t1XSxhPW4vZCxtPWx0KGQpLGc9ZC9tLHg9bT09PTE/cjpgdmVjJHttfTwke3J9PmAsYj0oeSxTKT0+Uz09PTQ/YG1heChtYXgoJHt5fS54LCAke3l9LnkpLCBtYXgoJHt5fS56LCAke3l9LncpKWA6Uz09PTI/YG1heCgke3l9LngsICR7eX0ueSlgOlM9PT0zP2BtYXgobWF4KCR7eX0ueCwgJHt5fS55KSwgJHt5fS56KWA6eSx3PXI9PT1cImYzMlwiP2B2YXIgdGhyZWFkTWF4ID0gJHt4fSgtMy40MDI4MjNlKzM4Zik7YDpgdmFyIHRocmVhZE1heCA9ICR7eH0oLTY1NTA0LjBoKTtgO3JldHVybntuYW1lOlwiU29mdG1heFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDphfX0pLGdldFNoYWRlclNvdXJjZTp5PT5gXFxuICAgICAgdmFyPHdvcmtncm91cD4gcm93TWF4U2hhcmVkIDogJHt4fTtcXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dTdW1TaGFyZWQgOiAke3h9O1xcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7eH0sICR7c30+O1xcblxcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geCA6IGFycmF5PCR7eH0+O1xcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0IDogYXJyYXk8JHt4fT47XFxuXFxuICAgICAgZm4gZ2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIpIC0+ICR7eH0ge1xcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcXG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcXG4gICAgICB9XFxuXFxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke3h9KSB7XFxuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtzfSwgMSwgMSlcXG4gICAgICBmbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LCBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjM3UpIHtcXG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkLngpO1xcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZC54KTtcXG4gICAgICAgIGNvbnN0IHdnID0gJHtzfTtcXG4gICAgICAgIGxldCByb3cgPSBnaW5kZXggLyB3ZztcXG4gICAgICAgIGxldCBjb2xzID0gJHtnfTtcXG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gJHtnfTtcXG5cXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XFxuICAgICAgICAke3d9XFxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XFxuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XFxuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xcbiAgICAgICAgfVxcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oY29scywgd2cpO1xcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XFxuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XFxuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xcbiAgICAgICAgICByb3dNYXhTaGFyZWQgPSAke3h9KCR7YihcInRocmVhZFNoYXJlZFswXVwiLG0pfSk7XFxuICAgICAgICB9XFxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxcbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7eH0oMC4wKTtcXG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XFxuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcXG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcXG4gICAgICAgIH1cXG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcXG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XFxuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XFxuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7eH0oJHtodChcInRocmVhZFNoYXJlZFswXVwiLG0pfSk7XFxuICAgICAgICB9XFxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XFxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xcbiAgICAgICAgICBsZXQgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcXG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9YH19LHpzPShlLHQpPT57amQoZS5pbnB1dHMpLGUuY29tcHV0ZShLZChlLmlucHV0c1swXSx0KSl9LFZzPWU9PmllKHtheGlzOmUuYXhpc30pfSk7dmFyIHFkLFlkLFhkLEpkLFpkLE5zLFVzLExzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtxZD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIil9LFlkPShlLHQpPT57bGV0IHI9W10sbz10Lm51bU91dHB1dHM7cmV0dXJuIGVbMV0uZGltc1swXT4wJiYoZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChuPT5yLnB1c2goTnVtYmVyKG4pKSksbz1yLmxlbmd0aCksaWUoe251bU91dHB1dHM6byxheGlzOnQuYXhpcyxzcGxpdFNpemVzOnJ9KX0sWGQ9ZT0+YFxcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XFxuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XFxuICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcXG4gICAgICAgIHJldHVybiBpO1xcbiAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuICR7ZX11O1xcbn1gLEpkPWU9PntsZXQgdD1lLmxlbmd0aCxyPVtdO2ZvcihsZXQgbz0wO288dDsrK28pe2xldCBuPWVbb10uc2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiLFwiaW5wdXRbZ2xvYmFsX2lkeF1cIik7dD09PTE/ci5wdXNoKG4pOm89PT0wP3IucHVzaChgaWYgKG91dHB1dE51bWJlciA9PSAke299dSkgeyAke259IH1gKTpvPT09dC0xP3IucHVzaChgZWxzZSB7ICR7bn0gfWApOnIucHVzaChgZWxzZSBpZiAob3V0cHV0TnVtYmVyID09ICR7b30pIHsgJHtufSB9YCl9cmV0dXJuYFxcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXROdW1iZXI6IHUzMiwgaW5kaWNlczogJHtlWzBdLnR5cGUuaW5kaWNlc30sIGdsb2JhbF9pZHg6IHUzMikge1xcbiAgICAgICAgJHtyLmpvaW4oYFxcbmApfVxcbiAgICAgIH1gfSxaZD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxvPWsuc2l6ZShyKSxuPWVbMF0uZGF0YVR5cGUscz1yLmxlbmd0aCx1PXQuYXhpcyxkPXU8MD9yLmxlbmd0aCt1OnUsYT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxtPUwoXCJpbnB1dFwiLG4sciksZz1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSx4PVtdLGI9W10sdz0wO2ZvcihsZXQgUz0wO1M8dC5udW1PdXRwdXRzO1MrKyl7dys9dC5zcGxpdFNpemVzW1NdLGdbU109dztsZXQgQT1yLnNsaWNlKCk7QVt0LmF4aXNdPXQuc3BsaXRTaXplc1tTXSxiLnB1c2goQSksYVtTXT1YKGBvdXRwdXQke1N9YCxuLGJbU10pLHgucHVzaCh7ZGltczpiW1NdLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX1sZXQgdj1zPDI/XCJpbmRpY2VzXCI6YGluZGljZXNbJHtkfV1gLHk9Uz0+YFxcbiAgJHtTLmRlY2xhcmVWYXJpYWJsZXMobSwuLi5hKX1cXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7Zy5sZW5ndGh9Pigke2cubWFwKEE9PmAke0F9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAke1hkKGcubGVuZ3RoKX1cXG4gICR7SmQoYSl9XFxuXFxuICAke1MubWFpblN0YXJ0KCl9XFxuICAgICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG8pfVxcblxcbiAgICB2YXIgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgbGV0IG91dHB1dE51bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KCR7dn0pO1xcbiAgICBpZiAob3V0cHV0TnVtYmVyICE9IDApIHtcXG4gICAgICAgICR7dn0gLT0gc2l6ZUluQ29uY2F0QXhpc1tvdXRwdXROdW1iZXIgLSAxdV07XFxuICAgIH1cXG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dE51bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XFxuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0U2hhZGVyU291cmNlOnksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOngsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9fSl9fSxOcz0oZSx0KT0+e3FkKGUuaW5wdXRzKTtsZXQgcj1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6WWQoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKFpkKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9LFVzPWU9PntsZXQgdD1lLmF4aXMscj1lLnNwbGl0U2l6ZXMsbz1lLm51bU91dHB1dHM8MD9yLmxlbmd0aDplLm51bU91dHB1dHM7aWYobyE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm51bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ2ggbXVzdCBiZSBlcXVhbFwiKTtyZXR1cm4gaWUoe2F4aXM6dCxudW1PdXRwdXRzOm8sc3BsaXRTaXplczpyfSl9fSk7dmFyIEZzLFFkLGVjLHRjLEhzLGpzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7dmUoKTtGcz1lPT5BcnJheS5mcm9tKGUuZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksUWQ9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT02JiZlWzBdLmRhdGFUeXBlIT09MTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXNcIik7aWYoZVsxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIG9mIGludDY0IGRhdGEgdHlwZVwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EXCIpO2lmKEZzKGVbMV0pLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvclwiKX0sZWM9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbylyLnB1c2goZVtvXSp0W29dKTtyZXR1cm4gcn0sdGM9ZT0+e2xldCB0PWVbMF0uZGltcyxyPUZzKGVbMV0pLG89ZWModCxyKSxuPWsuc2l6ZShvKSxzPWVbMF0uZGF0YVR5cGUsdT1MKFwiaW5wdXRcIixzLHQpLGQ9WChcIm91dHB1dFwiLHMsbyksYT1tPT5gXFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7dS5pbmRpY2VzKC4uLnQpfTtcXG4gICAgICAke20uZGVjbGFyZVZhcmlhYmxlcyh1LGQpfVxcbiAgICAgICR7bS5tYWluU3RhcnQoKX1cXG4gICAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhuKX1cXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3UudHlwZS5pbmRpY2VzfTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcXG4gICAgICAgIGxldCBpbnB1dERpbVZhbHVlID0gJHtkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCJpXCIpfSAgJSAke3UuaW5kaWNlc0dldChcImlucHV0U2hhcGVcIixcImlcIil9O1xcblxcbiAgICAgICAgJHt1LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIixcImlucHV0RGltVmFsdWVcIil9XFxuICAgICAgfVxcbiAgICAgICR7ZC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKSl9XFxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3J9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6YX19LEhzPWU9PntRZChlLmlucHV0cyksZS5jb21wdXRlKHRjKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciByYyxuYyxLcyxxcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO3ZlKCk7cmM9KGUsdCxyLG8sbik9PntsZXQgcz1rLnNpemUociksdT1NYXRoLmNlaWwocy80KSxkPVgoXCJvdXRwdXREYXRhXCIsbixyLDQpLGE9TChcImFEYXRhXCIsdFsxXS5kYXRhVHlwZSx0WzFdLmRpbXMsNCksbT1MKFwiYkRhdGFcIix0WzJdLmRhdGFUeXBlLHRbMl0uZGltcyw0KSxnPUwoXCJjRGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLDQpLHgsYj0odyx2LHkpPT5gc2VsZWN0KCR7dn0sICR7d30sICR7eX0pYDtpZighbyl4PWQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYihhLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxtLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxnLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7bGV0IHc9KHYseSxTPVwiXCIpPT57bGV0IEE9YGFEYXRhW2luZGV4QSR7eX1dW2NvbXBvbmVudEEke3l9XWAsUj1gYkRhdGFbaW5kZXhCJHt5fV1bY29tcG9uZW50QiR7eX1dYCxXPWBib29sKGNEYXRhW2luZGV4QyR7eX1dICYgJHs0Mjc4MTkwMDgwPj4+KDMteSkqOH11KWA7cmV0dXJuYFxcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt5fSA9ICR7ZC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eX11YCl9O1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHt5fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eX1gLGQpfTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7eX0gPSAke20uYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3l9YCxkKX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldEMke3l9ID0gJHtnLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt5fWAsZCl9O1xcbiAgICAgICAgICAgIGxldCBpbmRleEEke3l9ID0gb2Zmc2V0QSR7eX0gLyA0dTtcXG4gICAgICAgICAgICBsZXQgaW5kZXhCJHt5fSA9IG9mZnNldEIke3l9IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGluZGV4QyR7eX0gPSBvZmZzZXRDJHt5fSAvIDR1O1xcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHt5fSA9IG9mZnNldEEke3l9ICUgNHU7XFxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke3l9ID0gb2Zmc2V0QiR7eX0gJSA0dTtcXG4gICAgICAgICAgICAke3Z9WyR7eX1dID0gJHtTfSgke2IoQSxSLFcpfSk7XFxuICAgICAgICAgIGB9O249PT05P3g9YFxcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xcbiAgICAgICAgICAgICR7dyhcImRhdGFcIiwwLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7dyhcImRhdGFcIiwxLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7dyhcImRhdGFcIiwyLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7dyhcImRhdGFcIiwzLFwidTMyXCIpfVxcbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDp4PWBcXG4gICAgICAgICAgICAke3coXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMCl9XFxuICAgICAgICAgICAgJHt3KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxcbiAgICAgICAgICAgICR7dyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cXG4gICAgICAgICAgICAke3coXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMyl9XFxuICAgICAgICAgIGB9cmV0dXJuYFxcbiAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXMoZyxhLG0sZCl9XFxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cXG4gICAgICAgICR7eH1cXG4gICAgICB9YH0sbmM9ZT0+e2xldCB0PWVbMV0uZGltcyxyPWVbMl0uZGltcyxvPWVbMF0uZGltcyxuPWVbMV0uZGF0YVR5cGUscz0hKGsuYXJlRXF1YWwodCxyKSYmay5hcmVFcXVhbChyLG8pKSx1PXQsZD1rLnNpemUodCk7aWYocyl7bGV0IGE9UWUuY2FsY1NoYXBlKFFlLmNhbGNTaGFwZSh0LHIsITEpLG8sITEpO2lmKCFhKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgcGVyZm9ybSB3aGVyZSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTt1PWEsZD1rLnNpemUodSl9cmV0dXJue25hbWU6XCJXaGVyZVwiLGdldFNoYWRlclNvdXJjZTphPT5yYyhhLGUsdSxzLG4pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTpufV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NC80KX19KX19LEtzPWU9PntlLmNvbXB1dGUobmMoZS5pbnB1dHMpKX19KTt2YXIgWXMsWHM9SCgoKT0+e1widXNlIHN0cmljdFwiO2NhKCk7ZmEoKTtqYSgpO25pKCk7aWkoKTtfbigpO3dpKCk7U2koKTtJaSgpO09pKCk7UGkoKTtraSgpO3ppKCk7TmkoKTtMaSgpO2ppKCk7c3MoKTtFcygpO01yKCk7X3MoKTtNcygpO1dzKCk7R3MoKTtMcygpO2pzKCk7cnIoKTtJbigpO3FzKCk7WXM9bmV3IE1hcChbW1wiQWJzXCIsW21hXV0sW1wiQWNvc1wiLFtoYV1dLFtcIkFjb3NoXCIsW2dhXV0sW1wiQWRkXCIsW0thXV0sW1wiQXJnTWF4XCIsW2RhLENuXV0sW1wiQXJnTWluXCIsW2xhLENuXV0sW1wiQXNpblwiLFt5YV1dLFtcIkFzaW5oXCIsW2JhXV0sW1wiQXRhblwiLFt3YV1dLFtcIkF0YW5oXCIsW3ZhXV0sW1wiQXZlcmFnZVBvb2xcIixbWmksSmldXSxbXCJCaWFzQWRkXCIsW3BhXV0sW1wiQmlhc1NwbGl0R2VsdVwiLFtIYV1dLFtcIkNhc3RcIixbeGEsJGFdXSxbXCJDZWlsXCIsW0NhXV0sW1wiQ2xpcFYxMFwiLFtBbl1dLFtcIkNsaXBcIixbU2FdXSxbXCJDb25jYXRcIixbb2ksYWldXSxbXCJDb252XCIsW1BuLFJuXV0sW1wiQ29udlRyYW5zcG9zZVwiLFtiaSx5aV1dLFtcIkNvc1wiLFtBYV1dLFtcIkNvc2hcIixbSWFdXSxbXCJEaXZcIixbcWFdXSxbXCJFaW5zdW1cIixbJGkseGldXSxbXCJFbHVcIixbRWEsa3JdXSxbXCJFcXVhbFwiLFtZYV1dLFtcIkVyZlwiLFtUYV1dLFtcIkV4cFwiLFtPYV1dLFtcIkV4cGFuZFwiLFtBaV1dLFtcIkZsb29yXCIsW19hXV0sW1wiRnVzZWRDb252XCIsW1BuLFJuXV0sW1wiR2F0aGVyXCIsW1RpLEVpXV0sW1wiR2F0aGVyRWxlbWVudHNcIixbUmksX2ldXSxbXCJHZWx1XCIsW1JhXV0sW1wiR2VtbVwiLFtNaSxCaV1dLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsW3RzLGVzXV0sW1wiR2xvYmFsTWF4UG9vbFwiLFtpcyxhc11dLFtcIkdyZWF0ZXJcIixbUWFdXSxbXCJHcmVhdGVyT3JFcXVhbFwiLFt0aV1dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFtXaSxEaV1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtHaSxWaV1dLFtcIkxlYWt5UmVsdVwiLFtQYSxrcl1dLFtcIkxlc3NcIixbZWldXSxbXCJMZXNzT3JFcXVhbFwiLFtyaV1dLFtcIkxvZ1wiLFtGYV1dLFtcIk1hdE11bFwiLFtVaV1dLFtcIk1heFBvb2xcIixbbnMsb3NdXSxbXCJNdWxcIixbWGFdXSxbXCJOZWdcIixbQmFdXSxbXCJOb3RcIixbTWFdXSxbXCJQYWRcIixbRmksSGldXSxbXCJQb3dcIixbSmFdXSxbXCJSYW5nZVwiLFtJc11dLFtcIlJlY2lwcm9jYWxcIixba2FdXSxbXCJSZWR1Y2VNaW5cIixbcmEsWWVdXSxbXCJSZWR1Y2VNZWFuXCIsW0pvLFllXV0sW1wiUmVkdWNlTWF4XCIsW3RhLFllXV0sW1wiUmVkdWNlU3VtXCIsW29hLFllXV0sW1wiUmVkdWNlUHJvZFwiLFtuYSxZZV1dLFtcIlJlZHVjZUwxXCIsW1pvLFllXV0sW1wiUmVkdWNlTDJcIixbUW8sWWVdXSxbXCJSZWR1Y2VMb2dTdW1cIixbaWEsWWVdXSxbXCJSZWR1Y2VMb2dTdW1FeHBcIixbZWEsWWVdXSxbXCJSZWR1Y2VTdW1TcXVhcmVcIixbYWEsWWVdXSxbXCJSZWx1XCIsW0RhXV0sW1wiUmVzaXplXCIsW1RzLE9zXV0sW1wiU2lnbW9pZFwiLFtXYV1dLFtcIlNpblwiLFt6YV1dLFtcIlNpbmhcIixbVmFdXSxbXCJTbGljZVwiLFtrcyxEc11dLFtcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixbUnMsUHNdXSxbXCJTcGxpdFwiLFtOcyxVc11dLFtcIlNxcnRcIixbR2FdXSxbXCJTb2Z0bWF4XCIsW3pzLFZzXV0sW1wiU3ViXCIsW1phXV0sW1wiVGFuXCIsW05hXV0sW1wiVGFuaFwiLFtVYV1dLFtcIlRocmVzaG9sZGVkUmVsdVwiLFtMYSxrcl1dLFtcIlRpbGVcIixbSHNdXSxbXCJUcmFuc3Bvc2VcIixbem8sVm9dXSxbXCJXaGVyZVwiLFtLc11dXSl9KTt2YXIgWHIsSnM9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7bXQoKTt2ZSgpO1hyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMucmVwbz1uZXcgTWFwLHRoaXMuYXR0cmlidXRlc0JvdW5kPSExfWdldEFydGlmYWN0KHQpe3JldHVybiB0aGlzLnJlcG8uZ2V0KHQpfXNldEFydGlmYWN0KHQscil7dGhpcy5yZXBvLnNldCh0LHIpfXJ1bih0LHIsbyxuLHMsdSxkKXtsZXQgYT10aGlzLmJhY2tlbmQuZGV2aWNlLG09dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO20uc2V0UGlwZWxpbmUodC5jb21wdXRlUGlwZWxpbmUpO2xldCBnPVtdO2ZvcihsZXQgYiBvZiBuKWcucHVzaCh7YmluZGluZzpnLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOmIuYnVmZmVyfX0pO2ZvcihsZXQgYiBvZiBzKWcucHVzaCh7YmluZGluZzpnLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOmIuYnVmZmVyfX0pO2QmJmcucHVzaCh7YmluZGluZzpnLmxlbmd0aCxyZXNvdXJjZTpkfSk7bGV0IHg9YS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDp0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczpnLGxhYmVsOnQucHJvZ3JhbUluZm8ubmFtZX0pO2lmKG0uc2V0QmluZEdyb3VwKDAseCksbS5kaXNwYXRjaFdvcmtncm91cHMoLi4udSksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLHRoaXMuYmFja2VuZC5pc1F1ZXJ5RW5hYmxlZCgpKXt0eXBlb2YgdGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YT5cInVcIiYmKHRoaXMuYmFja2VuZC5xdWVyeURhdGE9dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0aGlzLmJhY2tlbmQucXVlcnlTZXRDb3VudCo4LEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkUpKTtsZXQgYj10aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHRoaXMuYmFja2VuZC5xdWVyeVNldENvdW50KjgsR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpLnJlc29sdmVRdWVyeVNldCh0aGlzLmJhY2tlbmQucXVlcnlTZXQsMCwyLHRoaXMuYmFja2VuZC5xdWVyeURhdGEuYnVmZmVyLDApLHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpLmNvcHlCdWZmZXJUb0J1ZmZlcih0aGlzLmJhY2tlbmQucXVlcnlEYXRhLmJ1ZmZlciwwLGIuYnVmZmVyLDAsdGhpcy5iYWNrZW5kLnF1ZXJ5U2V0Q291bnQqOCksdGhpcy5iYWNrZW5kLmZsdXNoKCk7bGV0IHc9dGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCx2PXRoaXMuYmFja2VuZC5rZXJuZWxzLmdldCh3KSx5PWBbJHt2WzBdfV0gJHt2WzFdfWA7Yi5idWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpPT57bGV0IFM9bmV3IEJpZ1VpbnQ2NEFycmF5KGIuYnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLEE9U1swXSxSPVNbMV07Yi5idWZmZXIudW5tYXAoKSx0eXBlb2YgdGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2U+XCJ1XCImJih0aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZT1BKTtsZXQgVz1OdW1iZXIoQS10aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZSksTT1OdW1iZXIoUi10aGlzLmJhY2tlbmQucXVlcnlUaW1lQmFzZSk7aWYoIU51bWJlci5pc1NhZmVJbnRlZ2VyKFcpfHwhTnVtYmVyLmlzU2FmZUludGVnZXIoTSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlXCIpO3RoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGIuaWQpO2xldCBEPVwiXCI7ci5mb3JFYWNoKCh6LEYpPT57RCs9YGlucHV0WyR7Rn1dOiBbJHt6LmRpbXN9XSB8ICR7UXQoei5kYXRhVHlwZSl9LCBgfSk7bGV0IF89XCJcIjtvLmZvckVhY2goKHosRik9PntfKz1gb3V0cHV0WyR7Rn1dOiBbJHt6LmRpbXN9XSB8ICR7UXQoei5kYXRhVHlwZSl9LCBgfSksY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7d318JHt5fVwiICR7RH0ke199ZXhlY3V0aW9uIHRpbWU6ICR7TS1XfSBuc2ApfSl9dGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49MTYmJnRoaXMuYmFja2VuZC5mbHVzaCgpfWRpc3Bvc2UoKXt9YnVpbGQodCxyKXtsZXQgbz10aGlzLmJhY2tlbmQuZGV2aWNlLG49W107by5mZWF0dXJlcy5oYXMoXCJzaGFkZXItZjE2XCIpJiZuLnB1c2goXCJlbmFibGUgZjE2O1wiKTtsZXQgcz1rbyhyKSx1PXQuZ2V0U2hhZGVyU291cmNlKHMpLGQ9YCR7bi5qb2luKGBcXG5gKX1cXG4ke3MuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cXG4ke3V9YCxhPW8uY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmQsbGFiZWw6dC5uYW1lfSk7RWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBzaGFkZXIgY29kZTogJHtkfWApO2xldCBtPW8uY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6YSxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCIsbGFiZWw6dC5uYW1lfSk7cmV0dXJue3Byb2dyYW1JbmZvOnQsY29tcHV0ZVBpcGVsaW5lOm19fW5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKHQpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC54LG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnl8fDEsbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQuenx8MSxzPXRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO2lmKHI8PXMmJm88PXMmJm48PXMpcmV0dXJuW3IsbyxuXTtsZXQgdT1yKm8qbixkPU1hdGguY2VpbChNYXRoLnNxcnQodSkpO2lmKGQ+cyl7aWYoZD1NYXRoLmNlaWwoTWF0aC5jYnJ0KHUpKSxkPnMpdGhyb3cgbmV3IEVycm9yKFwiVG90YWwgZGlzcGF0Y2ggc2l6ZSBleGNlZWRzIFdlYkdQVSBtYXhpbXVtLlwiKTtyZXR1cm5bZCxkLGRdfWVsc2UgcmV0dXJuW2QsZCwxXX19fSk7dmFyIG9jLGFjLEpyLFpzPUgoKCk9PntcInVzZSBzdHJpY3RcIjttdCgpO1RvKCk7UG8oKTtYcygpO0pzKCk7b2M9KGUsdCk9PntpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7dC5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7ZS5sZW5ndGh9LmApO2xldCByPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKXtsZXQgbj1lW29dLmRhdGFUeXBlO3N3aXRjaCh0W29dKXtjYXNlXCJub25lXCI6e3IucHVzaChcIlwiKTticmVha31jYXNlXCJ0eXBlXCI6e3IucHVzaChgJHtufWApO2JyZWFrfWNhc2VcInJhbmtcIjp7bGV0IHM9ZVtvXS5kaW1zLmxlbmd0aDtyLnB1c2goYCR7bn07JHtzfWApO2JyZWFrfWNhc2VcImRpbXNcIjp7bGV0IHM9ZVtvXS5kaW1zLmpvaW4oXCIsXCIpO3IucHVzaChgJHtufTske3N9YCk7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7dFtvXX1gKX19cmV0dXJuIHIuam9pbihcInxcIil9LGFjPShlLHQpPT57bGV0IHI9ZS5uYW1lO3JldHVybiBlLnNoYWRlckNhY2hlPy5oaW50JiYocis9XCJbXCIrZS5zaGFkZXJDYWNoZS5oaW50K1wiXVwiKSxyKz1gOiR7b2ModCxlLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcz8/bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKFwiZGltc1wiKSl9YCxyfSxKcj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuY3VycmVudEtlcm5lbElkPW51bGw7dGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsO3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGw7dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MDt0aGlzLnF1ZXJ5U2V0Q291bnQ9Mjt0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nPW5ldyBNYXB9Z2V0IGN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCl7aWYodGhpcy5jdXJyZW50S2VybmVsSWQ9PT1udWxsKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IGN1cnJlbnRLZXJuZWxJZCBpcyBudWxsLiAoc2hvdWxkIG5vdCBoYXBwZW4pXCIpO2xldCB0PXRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO3JldHVybiB0fHwodD17fSx0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLHQpKSx0fWFzeW5jIGluaXRpYWxpemUodCl7aWYoIW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR3B1QmFja2VuZDogV2ViR1BVIGlzIG5vdCBhdmFpbGFibGUuXCIpO2xldCByPWF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJXZWJHcHVCYWNrZW5kOiBGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLlwiKTt0aGlzLmVudj10O2xldCBvPVtdLG49e3JlcXVpcmVkTGltaXRzOnttYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplLG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLG1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZTpyLmxpbWl0cy5tYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUsbWF4QnVmZmVyU2l6ZTpyLmxpbWl0cy5tYXhCdWZmZXJTaXplLG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDpyLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVYOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVk6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9LHJlcXVpcmVkRmVhdHVyZXM6b307ci5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJm8ucHVzaChcInRpbWVzdGFtcC1xdWVyeVwiKSxyLmZlYXR1cmVzLmhhcyhcInNoYWRlci1mMTZcIikmJm8ucHVzaChcInNoYWRlci1mMTZcIiksdGhpcy5kZXZpY2U9YXdhaXQgci5yZXF1ZXN0RGV2aWNlKG4pLHRoaXMuZ3B1RGF0YU1hbmFnZXI9Um8odGhpcyksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgWHIodGhpcyksdGhpcy5rZXJuZWxzPW5ldyBNYXAsdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YT1uZXcgTWFwLHRoaXMua2VybmVsQ3VzdG9tRGF0YT1uZXcgTWFwLElvKHQubG9nTGV2ZWwsISF0LmRlYnVnKSx0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvcj1zPT57cy5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvciYmY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHtzLmVycm9yLm1lc3NhZ2V9YCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJkZXZpY2VcIix7dmFsdWU6dGhpcy5kZXZpY2V9KX1kaXNwb3NlKCl7dHlwZW9mIHRoaXMucXVlcnlTZXQ8XCJ1XCImJnRoaXMucXVlcnlTZXQuZGVzdHJveSgpLHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpfWdldENvbW1hbmRFbmNvZGVyKCl7cmV0dXJuIHRoaXMuY29tbWFuZEVuY29kZXJ8fCh0aGlzLmNvbW1hbmRFbmNvZGVyPXRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCkpLHRoaXMuY29tbWFuZEVuY29kZXJ9Z2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCl7aWYoIXRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKXtsZXQgdD17fTt0aGlzLmlzUXVlcnlFbmFibGVkKCkmJih0eXBlb2YgdGhpcy5xdWVyeVNldD5cInVcIiYmKHRoaXMucXVlcnlTZXQ9dGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe3R5cGU6XCJ0aW1lc3RhbXBcIixjb3VudDp0aGlzLnF1ZXJ5U2V0Q291bnR9KSksdC50aW1lc3RhbXBXcml0ZXM9e3F1ZXJ5U2V0OnRoaXMucXVlcnlTZXQsYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDowLGVuZE9mUGFzc1dyaXRlSW5kZXg6MX0pLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKS5iZWdpbkNvbXB1dGVQYXNzKHQpfXJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXt0aGlzLmNvbW1hbmRFbmNvZGVyJiYodGhpcy5lbmRDb21wdXRlUGFzcygpLHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLmZpbmlzaCgpXSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKSx0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGwsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MCl9aXNRdWVyeUVuYWJsZWQoKXtyZXR1cm4hISh0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJnRoaXMuZW52LndlYmdwdS5wcm9maWxpbmdNb2RlPT09XCJkZWZhdWx0XCIpfXJ1bih0LHIsbyxuLHMpe2xldCB1PVtdO2ZvcihsZXQgQT0wO0E8ci5sZW5ndGg7KytBKXtsZXQgUj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChyW0FdLmRhdGEpO2lmKCFSKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke3JbQV0uZGF0YX1gKTt1W0FdPVJ9bGV0IGQ9YWModCxyKSxhPXRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3QoZCkse291dHB1dHM6bSxkaXNwYXRjaEdyb3VwOmcscHJvZ3JhbVVuaWZvcm1zOnh9PXQuZ2V0UnVuRGF0YShyKSxiPW8ubGVuZ3RoPT09MD9tLm1hcCgoQSxSKT0+Uik6bztpZihiLmxlbmd0aCE9PW0ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHtiLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke20ubGVuZ3RofS5gKTtsZXQgdz1bXSx2PVtdO2ZvcihsZXQgQT0wO0E8bS5sZW5ndGg7KytBKXtpZighTnVtYmVyLmlzSW50ZWdlcihiW0FdKXx8YltBXTwtM3x8YltBXT49bS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHtiW0FdfWApO2lmKGJbQV09PT0tMyljb250aW51ZTtsZXQgUj1iW0FdPT09LTEsVz1iW0FdPT09LTIsTT1SfHxXP3MobVtBXS5kYXRhVHlwZSxtW0FdLmRpbXMpOm4oYltBXSxtW0FdLmRhdGFUeXBlLG1bQV0uZGltcyksRD10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChNLmRhdGEpO2lmKCFEKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHtNLmRhdGF9YCk7aWYoUiYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goRCksVyl7bGV0IF89dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO198fChfPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLF8pKSxfLnB1c2goRCl9dy5wdXNoKE0pLHYucHVzaChEKX1sZXQgeTtpZih4KXtsZXQgQT0wLFI9MCxXPVtdLE09MTt4LmZvckVhY2goej0+e2xldCBGPXR5cGVvZiB6LmRhdGE9PVwibnVtYmVyXCI/W3ouZGF0YV06ei5kYXRhLHE7c3dpdGNoKEYubGVuZ3RoKXtjYXNlIDE6cT00O2JyZWFrO2Nhc2UgMjpxPTg7YnJlYWs7Y2FzZSAzOnE9MTY7YnJlYWs7Y2FzZSA0OnE9MTY7YnJlYWs7Y2FzZSA1OnE9MTY7YnJlYWs7Y2FzZSA2OnE9MTY7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbGVuZ3RoOiAke0YubGVuZ3RofWApfShSPT09NXx8Uj09PTYpJiYocT0xNikscT5NJiYoTT1xKSxBPU1hdGguY2VpbChBL3EpKnEsUj1GLmxlbmd0aCxXLnB1c2goQSksQSs9Ri5sZW5ndGgqNH0pLEE9TWF0aC5jZWlsKEEvTSkqTTtsZXQgRD1uZXcgQXJyYXlCdWZmZXIoQSk7eC5mb3JFYWNoKCh6LEYpPT57bGV0IHE9V1tGXSxsZT10eXBlb2Ygei5kYXRhPT1cIm51bWJlclwiP1t6LmRhdGFdOnouZGF0YTt6LnR5cGU9PT1cImludDMyXCI/bmV3IEludDMyQXJyYXkoRCxxLGxlLmxlbmd0aCkuc2V0KGxlKTp6LnR5cGU9PT1cInVpbnQzMlwiP25ldyBVaW50MzJBcnJheShELHEsbGUubGVuZ3RoKS5zZXQobGUpOm5ldyBGbG9hdDMyQXJyYXkoRCxxLGxlLmxlbmd0aCkuc2V0KGxlKX0pO2xldCBfPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKEEsR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoXy5idWZmZXIsMCxELDAsQSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKF8uaWQpLHk9e29mZnNldDowLHNpemU6QSxidWZmZXI6Xy5idWZmZXJ9fWxldCBTPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoZyk7cmV0dXJuIGF8fChhPXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCxTKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KGQsYSkpLEVlKFwiaW5mb1wiLCgpPT5gW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke3QubmFtZX1cIiAoa2V5PSR7ZH0pIHdpdGggJHtTWzBdfXgke1NbMV19eCR7U1syXX1gKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bihhLHIsdyx1LHYsUyx5KSx3fXVwbG9hZCh0LHIpe3RoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKHQscil9bWVtY3B5KHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkodCxyKX1hc3luYyBkb3dubG9hZCh0LHIpe2F3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQodCxyKX1hbGxvYyh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUodCkuaWR9ZnJlZSh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHQpfWNyZWF0ZUtlcm5lbCh0LHIsbyxuKXtsZXQgcz1Zcy5nZXQodCk7aWYoIXMpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGltcGxlbWVudGVkOiAke3R9YCk7dGhpcy5rZXJuZWxzLnNldChyLFt0LG4sc1swXSxbc1sxXSxvXV0pfXJlbGVhc2VLZXJuZWwodCl7bGV0IHI9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodCk7aWYocil7Zm9yKGxldCBvIG9mIHIpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKG8uaWQpO3RoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKHQpfXRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUodCksdGhpcy5rZXJuZWxzLmRlbGV0ZSh0KX1jb21wdXRlS2VybmVsKHQscixvKXtsZXQgbj10aGlzLmtlcm5lbHMuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke3R9YCk7bGV0W3MsdSxkLGFdPW47aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7c31dICR7dX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LGFbMF0mJihhWzFdPWFbMF0oYVsxXSksYVswXT12b2lkIDApLEVlKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske3N9XSAke3V9XCIuLi5gKTtsZXQgbT10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBtJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIiksZChyLGFbMV0pLDB9Y2F0Y2goZyl7cmV0dXJuIG8ucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske3N9XSAke3V9XCIgZmFpbGVkLiAke2d9YCkpLDF9ZmluYWxseXttJiZvLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4oZz0+Zz9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske3N9XSAke3V9XCI6ICR7Zy5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgZyBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGcuaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LHIsbyxuKXtsZXQgcz10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtzfHwocz1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQscykpO2xldCB1PXMuZ2V0KHIpLGQ9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG8sbix1Py5bMV0pO3JldHVybiBzLnNldChyLFtkLG9dKSxkfXVucmVnaXN0ZXJCdWZmZXJzKHQpe2xldCByPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO3ImJihyLmZvckVhY2gobz0+dGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIob1sxXSkpLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHQpKX1nZXRCdWZmZXIodCl7bGV0IHI9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke3R9YCk7cmV0dXJuIHIuYnVmZmVyfWNyZWF0ZURvd25sb2FkZXIodCxyLG8pe3JldHVybiBhc3luYygpPT57bGV0IG49YXdhaXQgeW4odGhpcyx0LHIpO3JldHVybiBFbyhuLmJ1ZmZlcixvKX19fX0pO3ZhciBRcz17fTtJcihRcyx7aW5pdDooKT0+aWN9KTt2YXIgc3Isem4saWMsZXU9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7WnMoKTttdCgpO2dlKCk7c3I9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LHIsbyxuKXt0aGlzLm1vZHVsZT10O3RoaXMuZGF0YVR5cGU9cjt0aGlzLmRhdGE9bzt0aGlzLmRpbXM9bn1nZXRGbG9hdDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1rLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEZsb2F0MzJBcnJheTpuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0QmlnSW50NjRBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PWsuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgQmlnSW50NjRBcnJheTpuZXcgQmlnSW50NjRBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEludDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1rLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEludDMyQXJyYXk6bmV3IEludDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1yZXNoYXBlKHQpe2lmKGsuc2l6ZSh0KSE9PWsuc2l6ZSh0aGlzLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmV3IHNoYXBlXCIpO3JldHVybiBuZXcgZSh0aGlzLm1vZHVsZSx0aGlzLmRhdGFUeXBlLHRoaXMuZGF0YSx0KX19LHpuPWNsYXNze2NvbnN0cnVjdG9yKHQscixvKXt0aGlzLm1vZHVsZT10O3RoaXMuYmFja2VuZD1yO3RoaXMuY3VzdG9tRGF0YU9mZnNldD0wO3RoaXMuY3VzdG9tRGF0YVNpemU9MDtsZXQgbj10LkhFQVBVMzIscz1vPj4yO3RoaXMub3BLZXJuZWxDb250ZXh0PW5bcysrXTtsZXQgdT1uW3MrK107dGhpcy5vdXRwdXRDb3VudD1uW3MrK10sdGhpcy5jdXN0b21EYXRhT2Zmc2V0PW5bcysrXSx0aGlzLmN1c3RvbURhdGFTaXplPW5bcysrXTtsZXQgZD1bXTtmb3IobGV0IGE9MDthPHU7YSsrKXtsZXQgbT1uW3MrK10sZz1uW3MrK10seD1uW3MrK10sYj1bXTtmb3IobGV0IHc9MDt3PHg7dysrKWIucHVzaChuW3MrK10pO2QucHVzaChuZXcgc3IodCxtLGcsYikpfXRoaXMuaW5wdXRzPWR9Z2V0IGtlcm5lbEN1c3RvbURhdGEoKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhfWdldCBjdXN0b21EYXRhQnVmZmVyKCl7cmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsdGhpcy5jdXN0b21EYXRhT2Zmc2V0K3RoaXMuY3VzdG9tRGF0YVNpemUpfWNvbXB1dGUodCxyKXtsZXQgbz1yPy5pbnB1dHM/Lm1hcChkPT50eXBlb2YgZD09XCJudW1iZXJcIj90aGlzLmlucHV0c1tkXTpkKT8/dGhpcy5pbnB1dHMsbj1yPy5vdXRwdXRzPz9bXSxzPShkLGEsbSk9Pm5ldyBzcih0aGlzLm1vZHVsZSxhLHRoaXMub3V0cHV0KGQsbSksbSksdT0oZCxhKT0+e2xldCBtPWVyKGQpO2lmKCFtKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2R9YCk7bGV0IGc9bSprLnNpemUoYSk7cmV0dXJuIG5ldyBzcih0aGlzLm1vZHVsZSxkLHRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUoZykuaWQsYSl9O3JldHVybiB0aGlzLmJhY2tlbmQucnVuKHQsbyxuLHMsdSl9b3V0cHV0KHQscil7bGV0IG89dGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7dHJ5e2xldCBuPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErci5sZW5ndGgpKjQpLHM9bj4+Mjt0aGlzLm1vZHVsZS5IRUFQVTMyW3MrK109ci5sZW5ndGg7Zm9yKGxldCB1PTA7dTxyLmxlbmd0aDt1KyspdGhpcy5tb2R1bGUuSEVBUFUzMltzKytdPXJbdV07cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQsbil9Y2F0Y2gobil7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsXFwncyBvdXRwdXRbJHt0fV0gd2l0aCBkaW1zIFske3J9XS4gSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuIEVycm9yOiAke259YCl9ZmluYWxseXt0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUobyl9fX0saWM9YXN5bmMoZSx0KT0+e2xldCByPWUuanNlcEluaXQ7aWYociYmbmF2aWdhdG9yLmdwdSl7aWYoIXQud2FzbS5zaW1kKXRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgZm9yIFdlYkdQVT1PTiBhbmQgU0lNRD1PRkYuIFBsZWFzZSBzZXQgYGVudi53YXNtLnNpbWRgIHRvIHRydWUgd2hlbiB1c2luZyBXZWJHUFUgRVBcIik7bGV0IG89bmV3IEpyO2F3YWl0IG8uaW5pdGlhbGl6ZSh0KSxyKG8sbj0+by5hbGxvYyhuKSxuPT5vLmZyZWUobiksKG4scyx1LGQ9ITEpPT57aWYoZClFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke259LCBkc3Q9JHtzfSwgc2l6ZT0ke3V9YCksby5tZW1jcHkobixzKTtlbHNle0VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke259LCBncHVEYXRhSWQ9JHtzfSwgc2l6ZT0ke3V9YCk7bGV0IGE9ZS5IRUFQVTguc3ViYXJyYXkobixuK3UpO28udXBsb2FkKHMsYSl9fSxhc3luYyhuLHMsdSk9PntFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke259LCBkYXRhT2Zmc2V0PSR7c30sIHNpemU9JHt1fWApLGF3YWl0IG8uZG93bmxvYWQobiwoKT0+ZS5IRUFQVTguc3ViYXJyYXkocyxzK3UpKX0sKG4scyx1KT0+by5jcmVhdGVLZXJuZWwobixzLHUsdC5kZWJ1Z3x8dC53ZWJncHUucHJvZmlsaW5nTW9kZT09PVwiZGVmYXVsdFwiP2UuVVRGOFRvU3RyaW5nKGUuX0pzZXBHZXROb2RlTmFtZShzKSk6YCR7c31gKSxuPT5vLnJlbGVhc2VLZXJuZWwobiksKG4scyx1LGQpPT57RWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7dX0sIGtlcm5lbD0ke259LCBjb250ZXh0RGF0YU9mZnNldD0ke3N9YCk7bGV0IGE9bmV3IHpuKGUsbyxzKTtyZXR1cm4gby5jb21wdXRlS2VybmVsKG4sYSxkKX0pfX19KTt2YXIgd287d289dW8oKTt2YXIgUnU9Z28oKSxwbixmbj0hMSxFcj0hMSxibz0hMSxQdT0oKT0+e3RyeXtyZXR1cm4gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiPyExOih0eXBlb2YgTWVzc2FnZUNoYW5uZWw8XCJ1XCImJm5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKSl9Y2F0Y2h7cmV0dXJuITF9fSxNdT0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxCdT0oZSx0KT0+ZT90P1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS1zaW1kLndhc21cIjp0P1wib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiLHZvPWFzeW5jIGU9PntpZihmbilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoRXIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZGV0ZWN0ZWQuXCIpO2lmKGJvKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLlwiKTtFcj0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LHI9ZS5udW1UaHJlYWRzLG89ZS5zaW1kLG49cj4xJiZQdSgpLHM9byYmTXUoKSx1PWUud2FzbVBhdGhzLGQ9dHlwZW9mIHU9PVwic3RyaW5nXCI/dTp2b2lkIDAsYT1CdShzLG4pLG09dHlwZW9mIHU9PVwib2JqZWN0XCI/dVthXTp2b2lkIDAsZz0hMSx4PVtdO2lmKHQ+MCYmeC5wdXNoKG5ldyBQcm9taXNlKGI9PntzZXRUaW1lb3V0KCgpPT57Zz0hMCxiKCl9LHQpfSkpLHgucHVzaChuZXcgUHJvbWlzZSgoYix3KT0+e2xldCB2PW4/UnU6d28seT17bG9jYXRlRmlsZTooUyxBKT0+e2lmKG4mJlMuZW5kc1dpdGgoXCIud29ya2VyLmpzXCIpJiZ0eXBlb2YgQmxvYjxcInVcIilyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbeW8oKV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTtpZihTLmVuZHNXaXRoKFwiLndhc21cIikpe2lmKG0pcmV0dXJuIG07bGV0IFI9ZD8/QTtyZXR1cm4gYT09PVwib3J0LXdhc20tc2ltZC53YXNtXCI/UitcIm9ydC13YXNtLXNpbWQuanNlcC53YXNtXCI6YT09PVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI/UitcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6UithfXJldHVybiBBK1N9fTtpZihuKWlmKHR5cGVvZiBCbG9iPlwidVwiKXkubWFpblNjcmlwdFVybE9yQmxvYj0odm9pZCAwKShfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2xldCBTPWB2YXIgb3J0V2FzbVRocmVhZGVkPSR7di50b1N0cmluZygpfTtgO3kubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbU10se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfXYoeSkudGhlbihTPT57RXI9ITEsZm49ITAscG49UyxiKCl9LFM9PntFcj0hMSxibz0hMCx3KFMpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKHgpLGcpdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxSZT0oKT0+e2lmKGZuJiZwbilyZXR1cm4gcG47dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9O3ZhciBCZT0oZSx0KT0+e2xldCByPVJlKCksbz1yLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG49ci5fbWFsbG9jKG8pO3JldHVybiByLnN0cmluZ1RvVVRGOChlLG4sbyksdC5wdXNoKG4pLG59LFp0PShlLHQscixvKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYoci5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW24sc10pPT57bGV0IHU9dD90K246bjtpZih0eXBlb2Ygcz09XCJvYmplY3RcIiladChzLHUrXCIuXCIscixvKTtlbHNlIGlmKHR5cGVvZiBzPT1cInN0cmluZ1wifHx0eXBlb2Ygcz09XCJudW1iZXJcIilvKHUscy50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiBzPT1cImJvb2xlYW5cIilvKHUscz9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiBzfWApfSl9LEFlPWU9PntsZXQgdD1SZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IG89dC5zdGFja0FsbG9jKDgpO3QuX09ydEdldExhc3RFcnJvcihvLG8rNCk7bGV0IG49dC5IRUFQMzJbby80XSxzPXQuSEVBUFUzMltvLzQrMV0sdT1zP3QuVVRGOFRvU3RyaW5nKHMpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7bn0sIEVSUk9SX01FU1NBR0U6ICR7dX1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX07dmFyICRvPWU9PntsZXQgdD1SZSgpLHI9MCxvPVtdLG49ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApbi5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApbi5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihuLnRlcm1pbmF0ZT0hMSk7bGV0IHM9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYocz1CZShlLnRhZyxvKSkscj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKG4ubG9nU2V2ZXJpdHlMZXZlbCxuLmxvZ1ZlcmJvc2l0eUxldmVsLCEhbi50ZXJtaW5hdGUscykscj09PTAmJkFlKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZadChlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHUsZCk9PntsZXQgYT1CZSh1LG8pLG09QmUoZCxvKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShyLGEsbSkhPT0wJiZBZShgQ2FuXFwndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke3V9IC0gJHtkfS5gKX0pLFtyLG9dfWNhdGNoKHMpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhyKSxvLmZvckVhY2godT0+dC5fZnJlZSh1KSksc319O3ZhciBrdT1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSxEdT1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0sV3U9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKHI9Pih0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LHp1PShlLHQscik9Pntmb3IobGV0IG8gb2YgdCl7bGV0IG49dHlwZW9mIG89PVwic3RyaW5nXCI/bzpvLm5hbWU7c3dpdGNoKG4pe2Nhc2VcInhubnBhY2tcIjpuPVwiWE5OUEFDS1wiO2JyZWFrO2Nhc2VcIndlYm5uXCI6aWYobj1cIldFQk5OXCIsdHlwZW9mIG8hPVwic3RyaW5nXCIpe2xldCB1PW87aWYodT8uZGV2aWNlVHlwZSl7bGV0IGQ9QmUoXCJkZXZpY2VUeXBlXCIsciksYT1CZSh1LmRldmljZVR5cGUscik7UmUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsZCxhKSE9PTAmJkFlKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdkZXZpY2VUeXBlXFwnIC0gJHt1LmRldmljZVR5cGV9LmApfWlmKHU/LnBvd2VyUHJlZmVyZW5jZSl7bGV0IGQ9QmUoXCJwb3dlclByZWZlcmVuY2VcIixyKSxhPUJlKHUucG93ZXJQcmVmZXJlbmNlLHIpO1JlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGQsYSkhPT0wJiZBZShgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogXFwncG93ZXJQcmVmZXJlbmNlXFwnIC0gJHt1LnBvd2VyUHJlZmVyZW5jZX0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOmlmKG49XCJKU1wiLHR5cGVvZiBvIT1cInN0cmluZ1wiKXtsZXQgdT1vO2lmKHU/LnByZWZlcnJlZExheW91dCl7aWYodS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5DSFdcIiYmdS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciBcXCdOQ0hXXFwnIG9yIFxcJ05IV0NcXCc6ICR7dS5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGQ9QmUoXCJwcmVmZXJyZWRMYXlvdXRcIixyKSxhPUJlKHUucHJlZmVycmVkTGF5b3V0LHIpO1JlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGQsYSkhPT0wJiZBZShgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogXFwncHJlZmVycmVkTGF5b3V0XFwnIC0gJHt1LnByZWZlcnJlZExheW91dH0uYCl9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7bn1gKX1sZXQgcz1CZShuLHIpO1JlKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUscykhPT0wJiZBZShgQ2FuXFwndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke259LmApfX0seG89ZT0+e2xldCB0PVJlKCkscj0wLG89W10sbj1lfHx7fTtXdShuKTt0cnl7bGV0IHM9a3Uobi5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSx1PUR1KG4uZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGQ9dHlwZW9mIG4ubG9nSWQ9PVwic3RyaW5nXCI/QmUobi5sb2dJZCxvKTowLGE9bi5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGEpfHxhPDB8fGE+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2F9YCk7bGV0IG09bi5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihtKXx8bTwwfHxtPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHttfWApO2xldCBnPXR5cGVvZiBuLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/QmUobi5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLG8pOjA7aWYocj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhzLCEhbi5lbmFibGVDcHVNZW1BcmVuYSwhIW4uZW5hYmxlTWVtUGF0dGVybix1LCEhbi5lbmFibGVQcm9maWxpbmcsMCxkLGEsbSxnKSxyPT09MCYmQWUoXCJDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLG4uZXhlY3V0aW9uUHJvdmlkZXJzJiZ6dShyLG4uZXhlY3V0aW9uUHJvdmlkZXJzLG8pLG4uZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W3gsYl1vZiBPYmplY3QuZW50cmllcyhuLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgeCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHt4fWApO2lmKHR5cGVvZiBiIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihiKXx8YjwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke2J9YCk7bGV0IHc9QmUoeCxvKTt0Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUocix3LGIpIT09MCYmQWUoYENhblxcJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7eH0gLSAke2J9LmApfXJldHVybiBuLmV4dHJhIT09dm9pZCAwJiZadChuLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHgsYik9PntsZXQgdz1CZSh4LG8pLHY9QmUoYixvKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocix3LHYpIT09MCYmQWUoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7eH0gLSAke2J9LmApfSksW3Isb119Y2F0Y2gocyl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhyKSxvLmZvckVhY2godT0+dC5fZnJlZSh1KSksc319O0RlKCk7dmFyIHJ1PSExLHNjPWU9PntsZXQgdD1SZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IG89dC5zdGFja0FsbG9jKDgpO3JldHVybiB0Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50KGUsbyxvKzQpIT09MCYmQWUoXCJDYW5cXCd0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIiksW3QuSEVBUDMyW28vNF0sdC5IRUFQMzJbby80KzFdXX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX0sdWM9KGUsdCk9PntSZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZBZShcIkNhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9LG51PWFzeW5jIGU9Pnt1YyhlLndhc20ubnVtVGhyZWFkcyx0cihlLmxvZ0xldmVsKSk7e2xldCB0PShldSgpLE10KFFzKSkuaW5pdDthd2FpdCB0KFJlKCksZSl9cnU9ITB9LHVyPW5ldyBNYXAsb3U9KCk9PnJ1LFZuPWU9PntsZXQgdD1SZSgpLHI9dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7aWYocj09PTApdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsciksW3IsZS5ieXRlTGVuZ3RoXX0sR249KGUsdCk9PntsZXQgcj1SZSgpLG89MCxuPTAscz0wLHU9W10sZD1bXSxhPVtdO3RyeXtbbix1XT14byh0KSxvPXIuX09ydENyZWF0ZVNlc3Npb24oZVswXSxlWzFdLG4pLG89PT0wJiZBZShcIkNhblxcJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIik7bGV0W20sZ109c2MobykseD1bXSxiPVtdLHc9W107Zm9yKGxldCB5PTA7eTxtO3krKyl7bGV0IFM9ci5fT3J0R2V0SW5wdXROYW1lKG8seSk7Uz09PTAmJkFlKFwiQ2FuXFwndCBnZXQgYW4gaW5wdXQgbmFtZS5cIiksZC5wdXNoKFMpLHgucHVzaChyLlVURjhUb1N0cmluZyhTKSl9Zm9yKGxldCB5PTA7eTxnO3krKyl7bGV0IFM9ci5fT3J0R2V0T3V0cHV0TmFtZShvLHkpO1M9PT0wJiZBZShcIkNhblxcJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxhLnB1c2goUyk7bGV0IEE9ci5VVEY4VG9TdHJpbmcoUyk7Yi5wdXNoKEEpO3tsZXQgUj10eXBlb2YgdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PVwic3RyaW5nXCI/dC5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbjp0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW0FdPz9cImNwdVwiO2lmKFIhPT1cImNwdVwiJiZSIT09XCJjcHUtcGlubmVkXCImJlIhPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtSfS5gKTt3LnB1c2goUil9fWxldCB2PW51bGw7cmV0dXJuIHcuc29tZSh5PT55PT09XCJncHUtYnVmZmVyXCIpJiYocz1yLl9PcnRDcmVhdGVCaW5kaW5nKG8pLHM9PT0wJiZBZShcIkNhblxcJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpLHY9e2hhbmRsZTpzLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczp3LG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6dy5tYXAoeT0+aG4oeSkpfSksdXIuc2V0KG8sW28sZCxhLHZdKSxbbyx4LGJdfWNhdGNoKG0pe3Rocm93IGQuZm9yRWFjaChnPT5yLl9PcnRGcmVlKGcpKSxhLmZvckVhY2goZz0+ci5fT3J0RnJlZShnKSkscyE9PTAmJnIuX09ydFJlbGVhc2VCaW5kaW5nKHMpLG8hPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbihvKSxtfWZpbmFsbHl7ci5fZnJlZShlWzBdKSxuIT09MCYmci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKG4pLHUuZm9yRWFjaChtPT5yLl9mcmVlKG0pKX19LGF1PShlLHQpPT57bGV0IHI9Vm4oZSk7cmV0dXJuIEduKHIsdCl9LGl1PWU9PntsZXQgdD1SZSgpLHI9dXIuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W28sbixzLHVdPXI7dSYmdC5fT3J0UmVsZWFzZUJpbmRpbmcodS5oYW5kbGUpLHQuanNlcFVucmVnaXN0ZXJCdWZmZXJzPy4oZSksbi5mb3JFYWNoKGQ9PnQuX09ydEZyZWUoZCkpLHMuZm9yRWFjaChkPT50Ll9PcnRGcmVlKGQpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihvKSx1ci5kZWxldGUoZSl9LHR1PShlLHQscixvLG4pPT57aWYoIWUpe3QucHVzaCgwKTtyZXR1cm59bGV0IHM9UmUoKSx1PWVbMF0sZD1lWzFdLGE9ZVszXSxtLGc7aWYodT09PVwic3RyaW5nXCImJmE9PT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihhPT09XCJncHUtYnVmZmVyXCIpe2xldCB3PWVbMl0uZ3B1QnVmZmVyLHY9ZXIobW4odSkpO2c9ZC5yZWR1Y2UoKHksUyk9PnkqUywxKSp2LG09cy5qc2VwUmVnaXN0ZXJCdWZmZXIobyxuLHcsZyl9ZWxzZXtsZXQgdz1lWzJdO2lmKEFycmF5LmlzQXJyYXkodykpe2c9NCp3Lmxlbmd0aCxtPXMuX21hbGxvYyhnKSxyLnB1c2gobSk7bGV0IHY9bS80O2ZvcihsZXQgeT0wO3k8dy5sZW5ndGg7eSsrKXtpZih0eXBlb2Ygd1t5XSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke3l9IGlzIG5vdCBhIHN0cmluZ2ApO3MuSEVBUFUzMlt2KytdPUJlKHdbeV0scil9fWVsc2UgZz13LmJ5dGVMZW5ndGgsbT1zLl9tYWxsb2MoZyksci5wdXNoKG0pLHMuSEVBUFU4LnNldChuZXcgVWludDhBcnJheSh3LmJ1ZmZlcix3LmJ5dGVPZmZzZXQsZyksbSl9bGV0IHg9cy5zdGFja1NhdmUoKSxiPXMuc3RhY2tBbGxvYyg0KmQubGVuZ3RoKTt0cnl7bGV0IHc9Yi80O2QuZm9yRWFjaCh5PT5zLkhFQVAzMlt3KytdPXkpO2xldCB2PXMuX09ydENyZWF0ZVRlbnNvcihtbih1KSxtLGcsYixkLmxlbmd0aCxobihhKSk7dj09PTAmJkFlKGBDYW5cXCd0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke299LCBpbmRleD0ke259LmApLHQucHVzaCh2KX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKHgpfX0sc3U9YXN5bmMoZSx0LHIsbyxuLHMpPT57bGV0IHU9UmUoKSxkPXVyLmdldChlKTtpZighZCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbYSxtLGcseF09ZCxiPXQubGVuZ3RoLHc9by5sZW5ndGgsdj0wLHk9W10sUz1bXSxBPVtdLFI9W10sVz11LnN0YWNrU2F2ZSgpLE09dS5zdGFja0FsbG9jKGIqNCksRD11LnN0YWNrQWxsb2MoYio0KSxfPXUuc3RhY2tBbGxvYyh3KjQpLHo9dS5zdGFja0FsbG9jKHcqNCk7dHJ5e1t2LHldPSRvKHMpO2ZvcihsZXQgYWU9MDthZTxiO2FlKyspdHUoclthZV0sUyxSLGUsdFthZV0pO2ZvcihsZXQgYWU9MDthZTx3O2FlKyspdHUoblthZV0sQSxSLGUsYitvW2FlXSk7bGV0IEY9TS80LHE9RC80LGxlPV8vNCxCPXovNDtmb3IobGV0IGFlPTA7YWU8YjthZSsrKXUuSEVBUFUzMltGKytdPVNbYWVdLHUuSEVBUFUzMltxKytdPW1bdFthZV1dO2ZvcihsZXQgYWU9MDthZTx3O2FlKyspdS5IRUFQVTMyW2xlKytdPUFbYWVdLHUuSEVBUFUzMltCKytdPWdbb1thZV1dO2lmKHgpe2xldHtoYW5kbGU6YWUsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOndlLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6an09eDtpZihtLmxlbmd0aCE9PWIpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2J9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWxcXCdzIGlucHV0IGNvdW50ICgke20ubGVuZ3RofSkuYCk7Zm9yKGxldCBTZT0wO1NlPGI7U2UrKyl7bGV0IE9lPXRbU2VdO2F3YWl0IHUuX09ydEJpbmRJbnB1dChhZSxtW09lXSxTW1NlXSkhPT0wJiZBZShgQ2FuXFwndCBiaW5kIGlucHV0WyR7U2V9XSBmb3Igc2Vzc2lvbj0ke2V9LmApfWZvcihsZXQgU2U9MDtTZTx3O1NlKyspe2xldCBPZT1vW1NlXTtuW1NlXT8uWzNdP3UuX09ydEJpbmRPdXRwdXQoYWUsZ1tPZV0sQVtTZV0sMCkhPT0wJiZBZShgQ2FuXFwndCBiaW5kIHByZS1hbGxvY2F0ZWQgb3V0cHV0WyR7U2V9XSBmb3Igc2Vzc2lvbj0ke2V9LmApOnUuX09ydEJpbmRPdXRwdXQoYWUsZ1tPZV0sMCxqW09lXSkhPT0wJiZBZShgQ2FuXFwndCBiaW5kIG91dHB1dFske1NlfV0gdG8gJHt3ZVtTZV19IGZvciBzZXNzaW9uPSR7ZX0uYCl9fWxldCBLO3g/Sz1hd2FpdCB1Ll9PcnRSdW5XaXRoQmluZGluZyhhLHguaGFuZGxlLHcsXyx2KTpLPWF3YWl0IHUuX09ydFJ1bihhLEQsTSxiLHosdyxfLHYpLEshPT0wJiZBZShcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgeGU9W107Zm9yKGxldCBhZT0wO2FlPHc7YWUrKyl7bGV0IHdlPXUuSEVBUFUzMltfLzQrYWVdO2lmKHdlPT09QVthZV0pe3hlLnB1c2goblthZV0pO2NvbnRpbnVlfWxldCBqPXUuc3RhY2tTYXZlKCksU2U9dS5zdGFja0FsbG9jKDQqNCksT2U9ITEsSWUsQ2U9MDt0cnl7dS5fT3J0R2V0VGVuc29yRGF0YSh3ZSxTZSxTZSs0LFNlKzgsU2UrMTIpIT09MCYmQWUoYENhblxcJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke2FlfS5gKTtsZXQgTmU9U2UvNCxMZT11LkhFQVBVMzJbTmUrK107Q2U9dS5IRUFQVTMyW05lKytdO2xldCBOPXUuSEVBUFUzMltOZSsrXSxkZT11LkhFQVBVMzJbTmUrK10scGU9W107Zm9yKGxldCBUZT0wO1RlPGRlO1RlKyspcGUucHVzaCh1LkhFQVBVMzJbTi80K1RlXSk7dS5fT3J0RnJlZShOKTtsZXQgemU9cGUucmVkdWNlKChUZSxrZSk9PlRlKmtlLDEpO0llPVF0KExlKTtsZXQgVWU9eD8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW29bYWVdXTtpZihJZT09PVwic3RyaW5nXCIpe2lmKFVlPT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IFRlPVtdLGtlPUNlLzQ7Zm9yKGxldCBHZT0wO0dlPHplO0dlKyspe2xldCBYZT11LkhFQVBVMzJba2UrK10sRmU9R2U9PT16ZS0xP3ZvaWQgMDp1LkhFQVBVMzJba2VdLVhlO1RlLnB1c2godS5VVEY4VG9TdHJpbmcoWGUsRmUpKX14ZS5wdXNoKFtJZSxwZSxUZSxcImNwdVwiXSl9ZWxzZSBpZihVZT09PVwiZ3B1LWJ1ZmZlclwiJiZ6ZT4wKXtsZXQgVGU9dS5qc2VwR2V0QnVmZmVyKENlKSxrZT1lcihMZSk7aWYoa2U9PT12b2lkIDB8fCFTbyhJZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7SWV9YCk7T2U9ITAseGUucHVzaChbSWUscGUse2dwdUJ1ZmZlcjpUZSxkb3dubG9hZDp1LmpzZXBDcmVhdGVEb3dubG9hZGVyKFRlLHplKmtlLEllKSxkaXNwb3NlOigpPT57dS5fT3J0UmVsZWFzZVRlbnNvcih3ZSl9fSxcImdwdS1idWZmZXJcIl0pfWVsc2V7bGV0IFRlPVRyKEllKSxrZT1uZXcgVGUoemUpO25ldyBVaW50OEFycmF5KGtlLmJ1ZmZlcixrZS5ieXRlT2Zmc2V0LGtlLmJ5dGVMZW5ndGgpLnNldCh1LkhFQVBVOC5zdWJhcnJheShDZSxDZStrZS5ieXRlTGVuZ3RoKSkseGUucHVzaChbSWUscGUsa2UsXCJjcHVcIl0pfX1maW5hbGx5e3Uuc3RhY2tSZXN0b3JlKGopLEllPT09XCJzdHJpbmdcIiYmQ2UmJnUuX2ZyZWUoQ2UpLE9lfHx1Ll9PcnRSZWxlYXNlVGVuc29yKHdlKX19cmV0dXJuIHgmJnUuX09ydENsZWFyQm91bmRPdXRwdXRzKHguaGFuZGxlKSx4ZX1maW5hbGx5e3Uuc3RhY2tSZXN0b3JlKFcpLFMuZm9yRWFjaChGPT51Ll9PcnRSZWxlYXNlVGVuc29yKEYpKSxBLmZvckVhY2goRj0+dS5fT3J0UmVsZWFzZVRlbnNvcihGKSksUi5mb3JFYWNoKEY9PnUuX2ZyZWUoRikpLHYhPT0wJiZ1Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyh2KSx5LmZvckVhY2goRj0+dS5fZnJlZShGKSl9fSx1dT1lPT57bGV0IHQ9UmUoKSxyPXVyLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7bGV0IG89clswXSxuPXQuX09ydEVuZFByb2ZpbGluZyhvKTtuPT09MCYmQWUoXCJDYW5cXCd0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksdC5fT3J0RnJlZShuKX0sbHU9ZT0+e2xldCB0PVtdO2ZvcihsZXQgciBvZiBlKXtsZXQgbz1yWzJdOyFBcnJheS5pc0FycmF5KG8pJiZcImJ1ZmZlclwiaW4gbyYmdC5wdXNoKG8uYnVmZmVyKX1yZXR1cm4gdH07c2VsZi5vbm1lc3NhZ2U9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6dHJ5e3ZvKGUuZGF0YS5pbikudGhlbigoKT0+cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LXdhc21cIn0pLHQ9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCIsZXJyOnR9KSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LXdhc21cIixlcnI6dH0pfWJyZWFrO2Nhc2VcImluaXQtb3J0XCI6dHJ5e251KGUuZGF0YS5pbikudGhlbigoKT0+cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwifSksdD0+cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwiLGVycjp0fSkpfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC1vcnRcIixlcnI6dH0pfWJyZWFrO2Nhc2VcImNyZWF0ZV9hbGxvY2F0ZVwiOnRyeXtsZXR7bW9kZWw6dH09ZS5kYXRhLmluLHI9Vm4odCk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixvdXQ6cn0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJjcmVhdGVfZmluYWxpemVcIjp0cnl7bGV0e21vZGVsZGF0YTp0LG9wdGlvbnM6cn09ZS5kYXRhLmluLG89R24odCxyKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLG91dDpvfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcImNyZWF0ZVwiOnRyeXtsZXR7bW9kZWw6dCxvcHRpb25zOnJ9PWUuZGF0YS5pbixvPWF1KHQscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixvdXQ6b30pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJyZWxlYXNlXCI6dHJ5e2xldCB0PWUuZGF0YS5pbjtpdSh0KSxwb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIn0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwicnVuXCI6dHJ5e2xldHtzZXNzaW9uSWQ6dCxpbnB1dEluZGljZXM6cixpbnB1dHM6byxvdXRwdXRJbmRpY2VzOm4sb3B0aW9uczpzfT1lLmRhdGEuaW47c3UodCxyLG8sbixzKS50aGVuKHU9Pntwb3N0TWVzc2FnZSh7dHlwZTpcInJ1blwiLG91dDp1fSxsdSh1KSl9LHU9Pntwb3N0TWVzc2FnZSh7dHlwZTpcInJ1blwiLGVycjp1fSl9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcInJ1blwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOnRyeXtsZXQgdD1lLmRhdGEuaW47dXUodCkscG9zdE1lc3NhZ2Uoe3R5cGU6XCJlbmQtcHJvZmlsaW5nXCJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImVuZC1wcm9maWxpbmdcIixlcnI6dH0pfWJyZWFrO2Nhc2VcImlzLW9ydC1lbnYtaW5pdGlhbGl6ZWRcIjp0cnl7bGV0IHQ9b3UoKTtwb3N0TWVzc2FnZSh7dHlwZTpcImlzLW9ydC1lbnYtaW5pdGlhbGl6ZWRcIixvdXQ6dH0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiaXMtb3J0LWVudi1pbml0aWFsaXplZFwiLGVycjp0fSl9YnJlYWs7ZGVmYXVsdDp9fTt9KSgpO1xcbi8qKlxcbiAqIEBsaWNlbnNlXFxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXG4gKlxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcbiAqXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gKi9cXG4vKipcXG4gKiBAbGljZW5zZVxcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXFxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XFxuICpcXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcXG4gKlxcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICovXFxuLyoqXFxuICogQGxpY2Vuc2VcXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XFxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxcbiAqXFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxuICpcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAqL1xcbid9KTt2YXIgaHQsamUsYm4sJGEseGEscGEsZmEsbWEsaGEsZ2EseWEsYmEsd2EsdmEsSXQsdnAseW4sc2wsdWwsbGwsZGwsU2EsY2wscGwsZmwsbWwsQ2E9TCgoKT0+e1widXNlIHN0cmljdFwiOyR0KCk7b2woKTtIdCgpO2h0PSgpPT4hIUllLndhc20ucHJveHkmJnR5cGVvZiBkb2N1bWVudDxcInVcIixibj0hMSwkYT0hMSx4YT0hMSxtYT1bXSxoYT1bXSxnYT1bXSx5YT1bXSxiYT1bXSx3YT1bXSx2YT1bXSxJdD0oKT0+e2lmKGJufHwhJGF8fHhhfHwhamUpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0sdnA9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6Ym49ITEsZS5kYXRhLmVycj8oeGE9ITAscGFbMV0oZS5kYXRhLmVycikpOigkYT0hMCxwYVswXSgpKTticmVhaztjYXNlXCJpbml0LW9ydFwiOmUuZGF0YS5lcnI/ZmFbMV0oZS5kYXRhLmVycik6ZmFbMF0oKTticmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjplLmRhdGEuZXJyP21hLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6bWEuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJjcmVhdGVfZmluYWxpemVcIjplLmRhdGEuZXJyP2hhLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6aGEuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJjcmVhdGVcIjplLmRhdGEuZXJyP2dhLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6Z2Euc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJyZWxlYXNlXCI6ZS5kYXRhLmVycj95YS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnlhLnNoaWZ0KClbMF0oKTticmVhaztjYXNlXCJydW5cIjplLmRhdGEuZXJyP2JhLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6YmEuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJlbmQtcHJvZmlsaW5nXCI6ZS5kYXRhLmVycj93YS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOndhLnNoaWZ0KClbMF0oKTticmVhaztjYXNlXCJpcy1vcnQtZW52LWluaXRpYWxpemVkXCI6ZS5kYXRhLmVycj92YS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnZhLnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7ZGVmYXVsdDp9fSx5bj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQ/LnNyYzp2b2lkIDAsc2w9YXN5bmMoKT0+e2lmKGh0KCkpe2lmKCRhKXJldHVybjtpZihibil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKHhhKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7cmV0dXJuIGJuPSEwLEllLndhc20ud2FzbVBhdGhzPT09dm9pZCAwJiZ5biYmeW4uaW5kZXhPZihcImJsb2I6XCIpIT09MCYmKEllLndhc20ud2FzbVBhdGhzPXluLnN1YnN0cigwLCt5bi5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKChlLHQpPT57amU/LnRlcm1pbmF0ZSgpO2xldCByPVVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2lsKCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk7amU9bmV3IFdvcmtlcihyLHtuYW1lOlwib3J0LXdhc20tcHJveHktd29ya2VyXCJ9KSxqZS5vbmVycm9yPW49PnQobiksamUub25tZXNzYWdlPXZwLFVSTC5yZXZva2VPYmplY3RVUkwocikscGE9W2UsdF07bGV0IGE9e3R5cGU6XCJpbml0LXdhc21cIixpbjpJZS53YXNtfTtqZS5wb3N0TWVzc2FnZShhKX0pfWVsc2UgcmV0dXJuIFBvKEllLndhc20pfSx1bD1hc3luYyBlPT57aWYoaHQoKSlyZXR1cm4gSXQoKSxuZXcgUHJvbWlzZSgodCxyKT0+e2ZhPVt0LHJdO2xldCBhPXt0eXBlOlwiaW5pdC1vcnRcIixpbjplfTtqZS5wb3N0TWVzc2FnZShhKX0pO2F3YWl0IFF1KGUpfSxsbD1hc3luYyBlPT5odCgpPyhJdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57bWEucHVzaChbdCxyXSk7bGV0IGE9e3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixpbjp7bW9kZWw6ZX19O2plLnBvc3RNZXNzYWdlKGEsW2UuYnVmZmVyXSl9KSk6ZGEoZSksZGw9YXN5bmMoZSx0KT0+aHQoKT8oSXQoKSxuZXcgUHJvbWlzZSgocixhKT0+e2hhLnB1c2goW3IsYV0pO2xldCBuPXt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsaW46e21vZGVsZGF0YTplLG9wdGlvbnM6dH19O2plLnBvc3RNZXNzYWdlKG4pfSkpOmNhKGUsdCksU2E9YXN5bmMoZSx0KT0+e2lmKGh0KCkpe2lmKHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKXRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO3JldHVybiBJdCgpLG5ldyBQcm9taXNlKChyLGEpPT57Z2EucHVzaChbcixhXSk7bGV0IG49e3R5cGU6XCJjcmVhdGVcIixpbjp7bW9kZWw6ZSxvcHRpb25zOnR9fTtqZS5wb3N0TWVzc2FnZShuLFtlLmJ1ZmZlcl0pfSl9ZWxzZSByZXR1cm4gZWwoZSx0KX0sY2w9YXN5bmMgZT0+e2lmKGh0KCkpcmV0dXJuIEl0KCksbmV3IFByb21pc2UoKHQscik9Pnt5YS5wdXNoKFt0LHJdKTtsZXQgYT17dHlwZTpcInJlbGVhc2VcIixpbjplfTtqZS5wb3N0TWVzc2FnZShhKX0pO3RsKGUpfSxwbD1hc3luYyhlLHQscixhLG4scyk9PntpZihodCgpKXtpZihyLnNvbWUodT0+dVszXSE9PVwiY3B1XCIpKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvciBvbiBHUFUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO2lmKG4uc29tZSh1PT51KSl0aHJvdyBuZXcgRXJyb3IoXCJwcmUtYWxsb2NhdGVkIG91dHB1dCB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO3JldHVybiBJdCgpLG5ldyBQcm9taXNlKCh1LGwpPT57YmEucHVzaChbdSxsXSk7bGV0IG89cixwPXt0eXBlOlwicnVuXCIsaW46e3Nlc3Npb25JZDplLGlucHV0SW5kaWNlczp0LGlucHV0czpvLG91dHB1dEluZGljZXM6YSxvcHRpb25zOnN9fTtqZS5wb3N0TWVzc2FnZShwLGFsKG8pKX0pfWVsc2UgcmV0dXJuIHJsKGUsdCxyLGEsbixzKX0sZmw9YXN5bmMgZT0+e2lmKGh0KCkpcmV0dXJuIEl0KCksbmV3IFByb21pc2UoKHQscik9Pnt3YS5wdXNoKFt0LHJdKTtsZXQgYT17dHlwZTpcImVuZC1wcm9maWxpbmdcIixpbjplfTtqZS5wb3N0TWVzc2FnZShhKX0pO25sKGUpfSxtbD1hc3luYygpPT5odCgpPyhJdCgpLG5ldyBQcm9taXNlKChlLHQpPT57dmEucHVzaChbZSx0XSk7bGV0IHI9e3R5cGU6XCJpcy1vcnQtZW52LWluaXRpYWxpemVkXCJ9O2plLnBvc3RNZXNzYWdlKHIpfSkpOlp1KCl9KTt2YXIgd24saGwsJHAsdm4sZ2w9TCgoKT0+e1widXNlIHN0cmljdFwiOyR0KCk7Q2EoKTtEZSgpO2hsPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybltlLnR5cGUsZS5kaW1zLGUuZGF0YSxcImNwdVwiXTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse2dwdUJ1ZmZlcjplLmdwdUJ1ZmZlcn0sXCJncHUtYnVmZmVyXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0sJHA9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IFVlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIVlyKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6cixkb3dubG9hZDphLGRpc3Bvc2U6bn09ZVsyXTtyZXR1cm4gVWUuZnJvbUdwdUJ1ZmZlcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDphLGRpc3Bvc2U6bn0pfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZVszXX1gKX19LHZuPWNsYXNze2FzeW5jIGNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KXtsZXQgcj1hd2FpdCBmZXRjaCh0KTtpZihyLnN0YXR1cyE9PTIwMCl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIG1vZGVsOiAke3R9YCk7bGV0IGE9YXdhaXQgci5hcnJheUJ1ZmZlcigpO3JldHVybiBsbChuZXcgVWludDhBcnJheShhKSl9YXN5bmMgbG9hZE1vZGVsKHQscil7aWYoYXdhaXQgbWwoKXx8KHdufHwod249dWwoSWUpKSxhd2FpdCB3bix3bj12b2lkIDApLHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKHR5cGVvZiBwcm9jZXNzPFwidVwiJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGUpe2xldCBhPWF3YWl0KHZvaWQgMCkodCk7W3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBTYShhLHIpfWVsc2V7bGV0IGE9YXdhaXQgdGhpcy5jcmVhdGVTZXNzaW9uQWxsb2NhdGUodCk7W3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBkbChhLHIpfWVsc2VbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0IFNhKHQscil9YXN5bmMgZGlzcG9zZSgpe3JldHVybiBjbCh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKHQscixhKXtsZXQgbj1bXSxzPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goZz0+e2xldCB2PWdbMF0sJD1nWzFdLGI9dGhpcy5pbnB1dE5hbWVzLmluZGV4T2Yodik7aWYoYj09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHt2fSdgKTtuLnB1c2goJCkscy5wdXNoKGIpfSk7bGV0IHU9W10sbD1bXTtPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKGc9PntsZXQgdj1nWzBdLCQ9Z1sxXSxiPXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZih2KTtpZihiPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHt2fSdgKTt1LnB1c2goJCksbC5wdXNoKGIpfSk7bGV0IG89bi5tYXAoKGcsdik9PmhsKGcsKCk9PmBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW3Nbdl1dfVwiYCkpLHA9dS5tYXAoKGcsdik9Pmc/aGwoZywoKT0+YG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tsW3ZdXX1cImApOm51bGwpLG09YXdhaXQgcGwodGhpcy5zZXNzaW9uSWQscyxvLGwscCxhKSx5PXt9O2ZvcihsZXQgZz0wO2c8bS5sZW5ndGg7ZysrKXlbdGhpcy5vdXRwdXROYW1lc1tsW2ddXV09dVtnXT8/JHAobVtnXSk7cmV0dXJuIHl9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7ZmwodGhpcy5zZXNzaW9uSWQpfX19KTt2YXIgeHAsJG4seWw9TCgoKT0+e1widXNlIHN0cmljdFwiOyR0KCk7Q2EoKTtnbCgpO3hwPSgpPT57aWYoKHR5cGVvZiBJZS53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHxJZS53YXNtLmluaXRUaW1lb3V0PDApJiYoSWUud2FzbS5pbml0VGltZW91dD0wKSx0eXBlb2YgSWUud2FzbS5zaW1kIT1cImJvb2xlYW5cIiYmKEllLndhc20uc2ltZD0hMCksdHlwZW9mIEllLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYoSWUud2FzbS5wcm94eT0hMSksdHlwZW9mIEllLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoSWUud2FzbS5udW1UaHJlYWRzKXx8SWUud2FzbS5udW1UaHJlYWRzPD0wKXtsZXQgZT10eXBlb2YgbmF2aWdhdG9yPlwidVwiPyh2b2lkIDApKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O0llLndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgoZXx8MSkvMikpfX0sJG49Y2xhc3N7YXN5bmMgaW5pdCgpe3hwKCksYXdhaXQgc2woKX1hc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih0LHIpe2xldCBhPW5ldyB2bjtyZXR1cm4gYXdhaXQgYS5sb2FkTW9kZWwodCxyKSxQcm9taXNlLnJlc29sdmUoYSl9fX0pO3ZhciBibD17fTtrdChibCx7d2FzbUJhY2tlbmQ6KCk9PlNwfSk7dmFyIFNwLHdsPUwoKCk9PntcInVzZSBzdHJpY3RcIjt5bCgpO1NwPW5ldyAkbn0pO3ZhciBJcD17fTtrdChJcCx7SW5mZXJlbmNlU2Vzc2lvbjooKT0+cG8sVGVuc29yOigpPT5VZSxUcmFpbmluZ1Nlc3Npb246KCk9PmdvLGRlZmF1bHQ6KCk9PkNwLGVudjooKT0+SWUscmVnaXN0ZXJCYWNrZW5kOigpPT5mdH0pO21vZHVsZS5leHBvcnRzPXZ0KElwKTskdCgpOyR0KCk7JHQoKTt2YXIgYm89XCIxLjE3LjAtZGV2LjIwMjMxMTAzLTE0MzlkYTM2ZmVcIjt2YXIgQ3A9Um47e2xldCBlPSh3bCgpLHZ0KGJsKSkud2FzbUJhY2tlbmQ7dHlwZW9mIG5hdmlnYXRvcjxcInVcIiYmbmF2aWdhdG9yLmdwdSYmZnQoXCJ3ZWJncHVcIixlLDUpLGZ0KFwiY3B1XCIsZSwxMCksZnQoXCJ3YXNtXCIsZSwxMCksZnQoXCJ4bm5wYWNrXCIsZSw5KSxmdChcIndlYm5uXCIsZSw5KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoSWUudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6Ym8sZW51bWVyYWJsZTohMH0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3J0LndlYmdwdS5taW4uanMubWFwXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJjb25zdCBvcnQgPSByZXF1aXJlKCdvbm54cnVudGltZS13ZWIvd2ViZ3B1Jyk7XG5cbmNvbnN0IE1BWF9XSURUSCA9IDI4O1xuY29uc3QgTUFYX0hFSUdIVCA9IDI4O1xuY29uc3QgTU9ERUxfV0lEVEggPSAyODtcbmNvbnN0IE1PREVMX0hFSUdIVCA9IDI4O1xuXG5jb25zdCBNT0RFTF9NQVAgPSB7XG4gICAgc2FtX2I6IFtcIm1vZGVscy9tbmlzdF9jbm4ub25ueFwiXSxcbn07XG5cbmNvbnN0IGNvbmZpZyA9IGdldENvbmZpZygpO1xuXG5vcnQuZW52Lndhc20ubnVtVGhyZWFkcyA9IGNvbmZpZy50aHJlYWRzO1xub3J0LmVudi53YXNtLnByb3h5ID0gdHJ1ZTtcblxubGV0IGNhbnZhcztcbmxldCBmaWxlaW47XG5sZXQgZGVjb2Rlcl9sYXRlbmN5O1xuXG52YXIgaW1hZ2VfZW1iZWRkaW5ncztcbnZhciBzZXNzID0gW107XG52YXIgaW1hZ2VJbWFnZURhdGE7XG5cbmZ1bmN0aW9uIGxvZyhpKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXR1cycpLmlubmVySFRNTCArPSBgPGJyPlske3BlcmZvcm1hbmNlLm5vdygpLnRvRml4ZWQoMyl9XSBgICsgaTtcbiAgICBjb25zb2xlLmxvZyhpKTtcbn1cblxuLyoqXG4gKiBnZXQgc29tZSBwYXJhbWV0ZXJzIGZyb20gdXJsXG4gKi9cbmZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgICBjb25zdCBxdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpO1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIG1vZGVsOiBcInNhbV9iXCIsXG4gICAgICAgIHByb3ZpZGVyOiBcIndlYmdwdVwiLFxuICAgICAgICBkZXZpY2U6IFwiZ3B1XCIsXG4gICAgICAgIHRocmVhZHM6IFwiMVwiLFxuICAgIH07XG4gICAgbGV0IHZhcnMgPSBxdWVyeS5zcGxpdChcIiZcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwYWlyID0gdmFyc1tpXS5zcGxpdChcIj1cIik7XG4gICAgICAgIGlmIChwYWlyWzBdIGluIGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnW3BhaXJbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBhaXJbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBhcmd1bWVudDogXCIgKyBwYWlyWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25maWcudGhyZWFkcyA9IHBhcnNlSW50KGNvbmZpZy50aHJlYWRzKTtcbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNpemVUZW5zb3Iob3JpZ2luYWxUZW5zb3IpIHtcbiAgICAvLyBBc3N1bWluZyAnb3JpZ2luYWxUZW5zb3InIGlzIHlvdXIgT05OWCBSdW50aW1lIFdlYiB0ZW5zb3Igd2l0aCBkaW1lbnNpb25zIFsxLCAzLCAyOCwgMjhdXG4gICAgLy8gY29uc3Qgb3JpZ2luYWxTaGFwZSA9IG9yaWdpbmFsVGVuc29yLmRpbXM7IC8vIEdldCB0aGUgb3JpZ2luYWwgdGVuc29yJ3MgZGltZW5zaW9uc1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRlbnNvclxuICAgIC8vIGNvbnN0IHRvdGFsRWxlbWVudHMgPSBvcmlnaW5hbFNoYXBlLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyAqIHZhbCk7XG5cbiAgICAvLyBBc3N1bWluZyAnb3JpZ2luYWxEYXRhJyBpcyB5b3VyIEZsb2F0MzJBcnJheSBjb250YWluaW5nIHRoZSB0ZW5zb3IncyBkYXRhXG4gICAgY29uc3Qgb3JpZ2luYWxEYXRhID0gb3JpZ2luYWxUZW5zb3IuZGF0YTtcblxuICAgIC8vIFJlc2hhcGUgdGhlIHRlbnNvciB0byBbMSwgMSwgMjgsIDI4XVxuICAgIGNvbnN0IHJlc2hhcGVkVGVuc29yID0gbmV3IG9ydC5UZW5zb3Iob3JpZ2luYWxEYXRhLnNsaWNlKDAsIDI4KjI4KSwgWzEsIDEsIDI4LCAyOF0pOyAvLyBBZGp1c3QgdGhlIG5ldyBzaGFwZSBhcyBuZWVkZWRcblxuICAgIC8vICdyZXNoYXBlZFRlbnNvcicgbm93IGNvbnRhaW5zIHRoZSBkYXRhIGZyb20gJ29yaWdpbmFsVGVuc29yJyBidXQgd2l0aCB0aGUgbmV3IHNoYXBlIFsxLCAxLCAyOCwgMjhdXG4gICAgbG9nKGByZXNoYXBlZFRlbnNvciBpcyAke3Jlc2hhcGVkVGVuc29yLmRpbXN9YCk7XG4gICAgcmV0dXJuIHJlc2hhcGVkVGVuc29yO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtdWx0aXBseVRlbnNvcih0ZW5zb3IsIHNjYWxhcikge1xuICAgIC8vIEFzc3VtaW5nICd0ZW5zb3InIGlzIHlvdXIgT05OWCBSdW50aW1lIFdlYiB0ZW5zb3JcbiAgICBjb25zdCBkYXRhID0gdGVuc29yLmRhdGE7XG5cbiAgICAvLyBNdWx0aXBseSBldmVyeSBlbGVtZW50IGJ5IDI1NVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldICo9IHNjYWxhcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRlbnNvcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0S2V5c0FuZFZhbHVlcyhvcmlnaW5hbE9iamVjdCkge1xuICAgIGZvciAoa2V5IGluIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGxvZyhgb2JqZWN0WyR7a2V5fV06ICR7b3JpZ2luYWxPYmplY3Rba2V5XX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdpbmFsT2JqZWN0W2tleV07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlmV2hpdGVCYWNrZ3JvdW5kKGltZ0FyciwgdGhyZXNob2xkID0gMC4zKSB7XG4gICAgLy8gQXNzdW1pbmcgJ2ltZ0FycicgaXMgYSBKYXZhU2NyaXB0IGFycmF5IG9yIHR5cGVkIGFycmF5IHJlcHJlc2VudGluZyBpbWFnZSBkYXRhXG4gICAgLy8gY29uc3QgYmFja2dyb3VuZFZhbHVlID0gMjU1OyAvLyBWYWx1ZSByZXByZXNlbnRpbmcgdGhlIGJhY2tncm91bmQgY29sb3JcbiAgICBjb25zdCBiYWNrZ3JvdW5kVmFsdWUgPSAxOyAvLyBWYWx1ZSByZXByZXNlbnRpbmcgdGhlIGJhY2tncm91bmQgY29sb3JcblxuICAgIC8vIENvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgbWF0Y2hpbmcgdGhlIGJhY2tncm91bmQgdmFsdWVcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIC8vIEFzc3VtaW5nICd0ZW5zb3InIGlzIHlvdXIgT05OWCBSdW50aW1lIFdlYiB0ZW5zb3JcbiAgICBjb25zdCBkYXRhID0gaW1nQXJyLmRhdGE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgIGlmIChkYXRhW2ldID09IGJhY2tncm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gbG9nKGBkYXRhICR7aX0gaXMgJHtkYXRhW2ldfWApO1xuICAgICAgICAgICAgY291bnQgPSBjb3VudCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIG9mIGJhY2tncm91bmQgcGl4ZWxzXG4gICAgLy8gY29uc3QgcGVyY2VudCA9IGNvdW50IC8gaW1nQXJyLmxlbmd0aDtcbiAgICB2YXIgcGVyY2VudCA9IGNvdW50IC8gNzg0O1xuXG4gICAgbG9nKGBwZXJjZW50IHdoaXRlbmVzc3MgaXMgJHtwZXJjZW50fTsgY291bnQgaXMgJHtjb3VudH07ICR7aW1nQXJyLmRpbXN9YClcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwZXJjZW50YWdlIGV4Y2VlZHMgdGhlIHRocmVzaG9sZFxuICAgIGlmIChwZXJjZW50ID49IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpbnZlcnRJbWFnZShpbWdBcnIpIHtcbiAgICBjb25zdCBkYXRhID0gaW1nQXJyLmRhdGE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IDEgLSBkYXRhW2ldO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1nQXJyO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZURhdGFGcm9tVGVuc29yKGltYWdlVGVuc29yLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gQ29udmVydCB0aGUgdGVuc29yIGRhdGEgdG8gYSByZWd1bGFyIGFycmF5IChBc3N1bWluZyBpdCdzIGEgRmxvYXQzMkFycmF5IG9yIHNpbWlsYXIpXG4gICAgdGVuc29yRGF0YSA9IEFycmF5LmZyb20oaW1hZ2VUZW5zb3IuZGF0YSk7XG4gICAgdGVuc29yRGF0YSA9IHRlbnNvckRhdGEubWFwKHZhbHVlID0+IHZhbHVlICogMjU1KTtcblxuICAgIGNvbnNvbGUubG9nKGBbaHRtbERpc3BsYXlJbWFnZV0gdGVuc29yRGF0YS5sZW5ndGg6ICR7dGVuc29yRGF0YS5sZW5ndGh9YClcblxuICAgIGNvbnN0IGdyYXlzY2FsZURhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGVuc29yRGF0YSk7XG5cbiAgICBjb25zdCByZ2JhRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpOyAvLyBSR0JBIHBpeGVsIGRhdGFcblxuICAgIC8vIFBvcHVsYXRlIHRoZSBSR0JBIHBpeGVsIGRhdGEgd2l0aCB0aGUgZ3JheXNjYWxlIHZhbHVlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGggKiBoZWlnaHQ7IGkrKykge1xuICAgICAgICBjb25zdCBncmF5c2NhbGVWYWx1ZSA9IGdyYXlzY2FsZURhdGFbaV07XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzYW1lIGdyYXlzY2FsZSB2YWx1ZSBmb3IgUkdCQSBjaGFubmVscyAoUiwgRywgQiwgQSlcbiAgICAgICAgY29uc3QgcGl4ZWxJbmRleCA9IGkgKiA0O1xuICAgICAgICByZ2JhRGF0YVtwaXhlbEluZGV4XSA9IGdyYXlzY2FsZVZhbHVlOyAvLyBSZWQgY2hhbm5lbFxuICAgICAgICByZ2JhRGF0YVtwaXhlbEluZGV4ICsgMV0gPSBncmF5c2NhbGVWYWx1ZTsgLy8gR3JlZW4gY2hhbm5lbFxuICAgICAgICByZ2JhRGF0YVtwaXhlbEluZGV4ICsgMl0gPSBncmF5c2NhbGVWYWx1ZTsgLy8gQmx1ZSBjaGFubmVsXG4gICAgICAgIHJnYmFEYXRhW3BpeGVsSW5kZXggKyAzXSA9IDI1NTsgLy8gQWxwaGEgY2hhbm5lbCAoZnVsbHkgb3BhcXVlKVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbiBJbWFnZURhdGEgb2JqZWN0IGZyb20gdGhlIFJHQkEgcGl4ZWwgZGF0YVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEocmdiYURhdGEsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgY29uc29sZS5sb2coYFtodG1sRGlzcGxheUltYWdlXSBpbWFnZURhdGE6ICR7aW1hZ2VEYXRhfSMjI2ApXG5cbiAgICAvLyBVc2UgaW1hZ2VEYXRhIHdpdGggYSBjYW52YXMsIHB1dEltYWdlRGF0YSgpLCBvciBvdGhlciBjYW52YXMgb3BlcmF0aW9uc1xuICAgIHJldHVybiBpbWFnZURhdGE7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGh0bWxEaXNwbGF5SW1hZ2UoaW1hZ2VUZW5zb3IsIGVsZW1lbnRJRCwgd2lkdGg9MjgsIGhlaWdodD0yOCkge1xuICAgIC8vIHdpZHRoID0gaW1hZ2VUZW5zb3IuZGltc1syXTtcbiAgICAvLyBoZWlnaHQgPSBpbWFnZVRlbnNvci5kaW1zWzNdO1xuXG4gICAgY29uc29sZS5sb2coYFtodG1sRGlzcGxheUltYWdlXSBpbWFnZVRlbnNvcjogJHt3aWR0aH0sICR7aGVpZ2h0fSMjI2ApO1xuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gYXdhaXQgZ2V0SW1hZ2VEYXRhRnJvbVRlbnNvcihpbWFnZVRlbnNvciwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAvLyBDcmVhdGUgYSBjYW52YXMgYW5kIGRyYXcgdGhlIGltYWdlIGRhdGEgb250byBpdFxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gICAgLy8gQ29udmVydCB0aGUgY2FudmFzIGNvbnRlbnQgdG8gYSBkYXRhIFVSTFxuICAgIGNvbnN0IGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTsgLy8gQ2hhbmdlICdpbWFnZS9wbmcnIHRvIHRoZSBkZXNpcmVkIGltYWdlIGZvcm1hdFxuXG4gICAgY29uc3QgaW1nRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJRCk7XG4gICAgaW1nRWxlbWVudC5zcmMgPSBkYXRhVVJMO1xufVxuXG4vKlxuKiBpbnZlcnQgYSB3aGl0ZSBiYWNrZ3JvdW5kIHRvIGJsYWNrIG9yIHJlbWFpbiBzbyBpZiBibGFja1xuKi9cbmFzeW5jIGZ1bmN0aW9uIGludmVydFdoaXRlQmFja2dyb3VuZChpbWdBcnIpIHtcbiAgICBpc1doaXRlID0gYXdhaXQgaWZXaGl0ZUJhY2tncm91bmQoaW1nQXJyKTtcbiAgICAvLyBpc1doaXRlID0gdHJ1ZTtcbiAgICBpZiAoaXNXaGl0ZSA9PSB0cnVlKSB7XG4gICAgICAgIC8vIGludmVydCBpbWFnZVxuICAgICAgICBsb2coYHlhYXkhIGltYWdlIGlzIHdoaXRlIGJhY2tncm91bmQ7IGdvdHRhIGludmVydCFgKTtcbiAgICAgICAgaW1nQXJyID0gYXdhaXQgaW52ZXJ0SW1hZ2UoaW1nQXJyKTtcbiAgICAgICAgcmV0dXJuIGltZ0FycjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2coYG5vbyEgaW1nIGlzIE5PVCB3aGl0ZSBiYWNrZ3JvdW5kYCk7XG4gICAgICAgIHJldHVybiBpbWdBcnI7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpbWFnZVByZXByb2Nlc3NpbmcoaW1nQXJyKSB7XG5cbiAgICAvLyAxLCAxLCAyOCwgMjhcbiAgICBpbWdBcnIgPSBhd2FpdCBvcnQuVGVuc29yLmZyb21JbWFnZShpbWdBcnIsIG9wdGlvbnMgPSB7cmVzaXplZFdpZHRoOiBNT0RFTF9XSURUSCwgcmVzaXplZEhlaWdodDogTU9ERUxfSEVJR0hUfSk7XG5cbiAgICAvLyBhYmMgPSBhd2FpdCBpZldoaXRlQmFja2dyb3VuZChpbWdBcnIpO1xuXG4gICAgaW1nQXJyID0gYXdhaXQgcmVzaXplVGVuc29yKGltZ0Fycik7XG5cbiAgICAvLyBmaW5kX3doaXRlX2JhY2tncm91bmRcbiAgICBpbWdBcnIgPSBhd2FpdCBpbnZlcnRXaGl0ZUJhY2tncm91bmQoaW1nQXJyKTtcbiAgICAvLyBiaXR3aXNlX25vdFxuICAgIC8vIGF3YWl0IGh0bWxEaXNwbGF5SW1hZ2UoaW1nQXJyLCAnZGVidWctaW1hZ2UnKTsgLy8gZm9yIERFQlVHR0lOR1xuXG4gICAgcmV0dXJuIGltZ0FycjsgXG5cbn1cblxuLyoqXG4gKiBoYW5kbGVyIGNhbGxlZCB3aGVuIGltYWdlIGF2YWlsYWJsZVxuICogcnVuIHRoZSBtb2RlbCAoZW5jb2Rlcikgb24gdGhlIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1vZGVsRm9yd2FyZChpbWcpIHtcbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZywgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZywgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcblxuICAgIGNvbnN0IHByZWRpY3Rpb25fZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdGlvbi1lbGVtZW50XCIpO1xuICAgIC8vIHByZWRpY3Rpb25fZWxlbWVudC5pbm5lclRleHQgPSBcIlwiO1xuICAgIGZpbGVpbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgLy8gZGVjb2Rlcl9sYXRlbmN5LmlubmVyVGV4dCA9IFwiXCI7XG4gICAgY2FudmFzLnN0eWxlLmN1cnNvciA9IFwid2FpdFwiO1xuICAgIGltYWdlX2VtYmVkZGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHdpZHRoID0gaW1nLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG4gICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCA+IE1BWF9XSURUSCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogKE1BWF9XSURUSCAvIHdpZHRoKTtcbiAgICAgICAgICAgIHdpZHRoID0gTUFYX1dJRFRIO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhlaWdodCA+IE1BWF9IRUlHSFQpIHtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggKiAoTUFYX0hFSUdIVCAvIGhlaWdodCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBNQVhfSEVJR0hUO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb25zb2xlLmxvZyhgW21vZGVsRm9yd2FyZF0gaW1nLmhlaWdodDogJHtpbWcuaGVpZ2h0fSMjIyBpbWcud2lkdGg6ICR7aW1nLndpZHRofWApXG4gICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaW1hZ2VJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgY29uc3QgaW1nVGVuc29yID0gYXdhaXQgaW1hZ2VQcmVwcm9jZXNzaW5nKGltYWdlSW1hZ2VEYXRhKTtcblxuICAgIC8vIGF3YWl0IGh0bWxEaXNwbGF5SW1hZ2UoaW1nVGVuc29yLCAnZGVidWctaW1hZ2UnKTsgLy8gZm9yIERFQlVHR0lOR1xuXG4gICAgbG9nKGAjIyNpbWdUZW5zb3IuZGltcyBpcyB0aGlzOiAke2ltZ1RlbnNvci5kaW1zfSMjI2ApO1xuICAgIGxvZyhgIyMjaW1nVGVuc29yIHNhbXBsZSBpcyB0aGlzOiAke2ltZ1RlbnNvci5kYXRhLnNsaWNlKDExMCwgMTE5KX0jIyNgKTtcbiAgICBcbiAgICBjb25zdCBmZWVkID0geyBcImlucHV0LjFcIjogaW1nVGVuc29yIH07XG4gICAgY29uc3QgcyA9IGF3YWl0IHNlc3NbMF07XG5cbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKFwiW2RlYnVnXSBzOlwiLCBzKVxuICAgIGltYWdlX2VtYmVkZGluZ3MgPSBhd2FpdCBzLnJ1bihmZWVkKTsgLy8gTU9ERUwuRk9SV0FSRFxuXG4gICAgY29uc3QgZW1iX3Byb3BlcnR5ID0gYXdhaXQgZ2V0S2V5c0FuZFZhbHVlcyhpbWFnZV9lbWJlZGRpbmdzKTtcbiAgICBwcm9icyA9IGVtYl9wcm9wZXJ0eVsnY3B1RGF0YSddO1xuICAgIG1heF9wcm9iID0gTWF0aC5tYXgoLi4ucHJvYnMpO1xuICAgIG1heEluZCA9IHByb2JzLmluZGV4T2YobWF4X3Byb2IpO1xuXG4gICAgcHJvYnNBcnJheSA9IEFycmF5LmZyb20ocHJvYnMpXG4gICAgZXhwUHJvYk51bXMgPSBwcm9ic0FycmF5Lm1hcChmdW5jdGlvbihlYWNoX2VsZW1lbnQpe1xuICAgICAgICByZXR1cm4gTnVtYmVyKE1hdGguZXhwKGVhY2hfZWxlbWVudCkpO1xuICAgIH0pO1xuICAgIHRvdGFsUHJvYk51bXMgPSBleHBQcm9iTnVtcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICBleHBQcm9iUHJvYnMgPSBleHBQcm9iTnVtcy5tYXAoZnVuY3Rpb24oZWFjaF9lbGVtZW50KXtcbiAgICAgICAgcmV0dXJuIE51bWJlcigoKGVhY2hfZWxlbWVudC90b3RhbFByb2JOdW1zKSoxMDApLnRvRml4ZWQoMikpO1xuICAgIH0pO1xuICAgIHByZWRpY3Rpb25fZWxlbWVudC5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cInRvb2x0aXBfY3VzdG9tXCI+Q2xhc3M6ICR7bWF4SW5kfTxzcGFuIGNsYXNzPVwidG9vbHRpcHRleHRfY3VzdG9tXCI+UHJvYmFiaWxpdGllczogJHtleHBQcm9iUHJvYnMuam9pbihcIiUsIFwiKX0lPC9zcGFuPjwvZGl2PmA7XG5cbiAgICBmaWxlaW4uZGlzYWJsZWQgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIGZldGNoIGFuZCBjYWNoZSB1cmxcblVzZXMgZnVuY3Rpb25zOlxuMS4gbG9nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kQ2FjaGUodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihcIm9ubnhcIik7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5jbGVhcl9jYWNoZSkge2NhY2hlLmRlbGV0ZSh1cmwpO31cblxuICAgICAgICBsZXQgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaCh1cmwpO1xuICAgICAgICBpZiAoY2FjaGVkUmVzcG9uc2UgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZS5hZGQodXJsKTtcbiAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2godXJsKTtcbiAgICAgICAgICAgIGxvZyhgJHt1cmx9IChmcm9tIG5ldHdvcmspYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2coYCR7dXJsfSAoZnJvbSBjYWNoZSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2FjaGVkUmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nKGAke3VybH0gKGZyb20gbmV0d29yaylgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybCkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICB9XG59XG5cbi8qXG4gKiBsb2FkIGVuY29kZXIgYW5kIGRlY29kZXIgc2VxdWVudGlhbGx5XG5Vc2VzIGZ1bmN0aW9uczpcbjEuIGZldGNoQW5kQ2FjaGVcbjIuIG1vZGVsRm9yd2FyZCAobW9kZWwgZm9yd2FyZClcbjMuIGxvZ1xuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkX21vZGVsKG1vZGVsLCBpZHgsIGltZykge1xuICAgIC8vIC0tLSBzZWxlY3QgZGV2aWNlIHdlYm5uIG9yIHdlYmdwdVxuICAgIGxldCBwcm92aWRlciA9IGNvbmZpZy5wcm92aWRlcjtcbiAgICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgICAgIGNhc2UgXCJ3ZWJublwiOlxuICAgICAgICAgICAgaWYgKCEoXCJtbFwiIGluIG5hdmlnYXRvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJubiBpcyBOT1Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdmlkZXIgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ3ZWJublwiLFxuICAgICAgICAgICAgICAgIGRldmljZVR5cGU6IGNvbmZpZy5kZXZpY2UsXG4gICAgICAgICAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiAnZGVmYXVsdCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndlYmdwdVwiOlxuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IuZ3B1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2ViZ3B1IGlzIE5PVCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3Qgb3B0ID0geyBleGVjdXRpb25Qcm92aWRlcnM6IFtwcm92aWRlcl0gfTtcbiAgICAvLyAtLS0gc2VsZWN0IGRldmljZSB3ZWJubiBvciB3ZWJncHVcblxuICAgIGxvZyhgW2xvYWRfbW9kZWxdIGlkeCBpcyB3aGF0PyAke2lkeH1gKVxuXG4gICAgZmV0Y2hBbmRDYWNoZShtb2RlbFtpZHhdKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIHNlc3NbaWR4XSA9IG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZShkYXRhLCBvcHQpOyAvLyBkYXRhIGFuZCBkZXZpY2VcblxuICAgICAgICAvLyAtLSB1c2VsZXNzIGdhcmJhZ2VcbiAgICAgICAgc2Vzc1tpZHhdLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbG9nKGAke21vZGVsW2lkeF19IGxvYWRlZC4geW95YCk7XG4gICAgICAgICAgICBpZiAoaWR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBsb2coXCJbbG9hZF9tb2RlbF0gaWR4IGlzIDA7IHNvIGdvaW5nIGZvciBuZXh0IHJlY3Vyc2lvbiBvZiBtb2RlbFwiKTtcbiAgICAgICAgICAgICAgICAvLyBsb2FkX21vZGVsKG1vZGVsLCAxKTsgLy8gcmVjdXJzaXZlIGxvYWRfbW9kZWwgP1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgbG9nKGAke21vZGVsW2lkeF19IGZhaWxlZCB3aXRoICR7ZX0uYCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGltZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2coXCJpbWcgaXMgdW5kZWZpbmVkIVwiKTtcbiAgICAgICAgICAgIC8vIG1vZGVsRm9yd2FyZChpbWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge2xvZyhcImltZyBpcyBub3QgdW5kZWZpbmVkIVwiKX1cbiAgICAgICAgLy8gLS0gdXNlbGVzcyBnYXJiYWdlXG5cbiAgICB9KVxufVxuXG4vKlxudXNlcyB0aGUgZnVuY3Rpb25zOlxuMS4gbG9hZF9tb2RlbFxuMi4gbW9kZWxGb3J3YXJkIChlbmNvZGVyKVxuMy4gaGFuZGxlQ2xpY2sgKGRlY29kZXIpXG40LiBsb2dcbiovXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICAgIGNvbnN0IG1vZGVsID0gTU9ERUxfTUFQW2NvbmZpZy5tb2RlbF07IC8vIGxvYWQgdGhlIG1vZGVsIChlbmNvZGVyIG9yIGRlY29kZXIpID9cbiAgICAvLyAtLS0gWzFdIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgdXNlclxuICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW1nX2NhbnZhc1wiKTtcbiAgICAvLyBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcbiAgICAvLyBjYW52YXMuc3R5bGUuY3Vyc29yID0gXCJ3YWl0XCI7XG5cbiAgICBmaWxlaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGUtaW5cIik7XG4gICAgLy8gZGVjb2Rlcl9sYXRlbmN5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWNvZGVyX2xhdGVuY3lcIik7XG5cbiAgICBsZXQgaW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcmlnaW5hbC1pbWFnZVwiKTtcbiAgICAvLyAtLS0gWzFdIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgdXNlclxuXG4gICAgY29uc29sZS5sb2coXCJbZGVidWddIEJFRk9SRSBtb2RlbCBsb2FkaW5nLi4uXCIpXG4gICAgbG9hZF9tb2RlbChtb2RlbCwgMCwgaW1nKS50aGVuKCgpID0+IHt9LCAoZSkgPT4ge2xvZyhlKTt9KTsgLy8gW0VYVF9GVU5DXSBsb2FkX21vZGVsXG4gICAgY29uc29sZS5sb2coXCJbZGVidWddIG1vZGVsIGxvYWRlZDsgc2VzczpcIiwgc2VzcylcbiAgICAvLyBsb2FkX21vZGVsKG1vZGVsLCAwLCBpbWcpLnRoZW4oKCkgPT4ge30sIChlKSA9PiB7fSk7IC8vIFtFWFRfRlVOQ10gbG9hZF9tb2RlbFxuXG4gICAgLy8gLS0tIFsyXSBpbWFnZSB1cGxvYWRcbiAgICBmaWxlaW4ub25jaGFuZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBldnQudGFyZ2V0IHx8IHdpbmRvdy5ldmVudC5zcmMsIGZpbGVzID0gdGFyZ2V0LmZpbGVzO1xuICAgICAgICBpZiAoRmlsZVJlYWRlciAmJiBmaWxlcyAmJiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiBtb2RlbEZvcndhcmQoaW1nKTsgLy8gW0VYVF9GVU5DXSBtb2RlbEZvcndhcmRcbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZXNbMF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAtLS0gWzJdIGltYWdlIHVwbG9hZFxufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7IG1haW4oKTsgfSk7XG4iXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiYSIsImkiLCJzZWxmIiwiV3IiLCJCdCIsImZ0IiwiTnIiLCJIYSIsInFhIiwiT24iLCJJZSIsIlhhIiwiSmEiLCJUbiIsIlphIiwiZW8iLCJ0byIsInJvIiwibHIiLCJHciIsImFvIiwib28iLCJzbyIsInVvIiwiRmUiLCJVZSIsIkxyIiwicG8iLCJIciIsImdvIiwiX24iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtsIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiQmwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiTWwiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIkwiLCJlIiwidCIsIkx0Iiwia3QiLCJyIiwiZ2V0IiwiZW51bWVyYWJsZSIsInZ0IiwibiIsImNhbGwiLCJEbCIsInZhbHVlIiwiVnIiLCJNYXAiLCJpbml0IiwiY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIiLCJUeXBlRXJyb3IiLCJzZXQiLCJiYWNrZW5kIiwicHJpb3JpdHkiLCJFcnJvciIsImluZGV4T2YiLCJzcGxpY2UiLCJzIiwibGVuZ3RoIiwicHVzaCIsImFzeW5jIiwiaW5pdGlhbGl6ZWQiLCJhYm9ydGVkIiwiaW5pdFByb21pc2UiLCJ1IiwibmFtZSIsImVyciIsIm1hcCIsImpvaW4iLCJMYSIsImphIiwiS2EiLCJ3YXNtIiwid2ViZ2wiLCJ3ZWJncHUiLCJ2ZXJzaW9ucyIsImNvbW1vbiIsImxvZ0xldmVsIiwiWWEiLCJRYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiZGltcyIsImhlaWdodCIsImdldENvbnRleHQiLCJ0ZW5zb3JMYXlvdXQiLCJvIiwicCIsImZvcm1hdCIsImwiLCJub3JtIiwibWVhbiIsImJpYXMiLCJtIiwieSIsImciLCJ2IiwiJCIsImIiLCJTIiwiSSIsImRhdGEiLCJUIiwiQiIsIlAiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRvRGF0YVVSTCIsImNyZWF0ZUltYWdlRGF0YSIsIkQiLCJubyIsIlVyIiwidGVuc29yRm9ybWF0IiwiRmxvYXQzMkFycmF5IiwiSFRNTEltYWdlRWxlbWVudCIsIkltYWdlRGF0YSIsIkltYWdlQml0bWFwIiwicmVzaXplZEhlaWdodCIsInJlc2l6ZWRXaWR0aCIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsIlByb21pc2UiLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3JjIiwib25sb2FkIiwicHV0SW1hZ2VEYXRhIiwiZG93bmxvYWQiLCJkaXNwb3NlIiwibG9jYXRpb24iLCJ0eXBlIiwidGV4dHVyZSIsImRhdGFUeXBlIiwiZ3B1QnVmZmVyIiwiaW8iLCJVaW50OEFycmF5IiwiSW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQzMkFycmF5IiwiQmlnSW50NjRBcnJheSIsImZyb20iLCJCaWdVaW50NjRBcnJheSIsImxvIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIlJhbmdlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInRoaXMiLCJkYXRhTG9jYXRpb24iLCJjcHVEYXRhIiwiZ3B1VGV4dHVyZURhdGEiLCJkb3dubG9hZGVyIiwiZGlzcG9zZXIiLCJncHVCdWZmZXJEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiQmlnSW50Iiwic2l6ZSIsImZyb21JbWFnZSIsImZyb21UZXh0dXJlIiwiZnJvbUdwdUJ1ZmZlciIsImZyb21QaW5uZWRCdWZmZXIiLCJ0b0ltYWdlRGF0YSIsImVuc3VyZVZhbGlkIiwiZ2V0RGF0YSIsImlzRG93bmxvYWRpbmciLCJyZXNoYXBlIiwiRnIiLCJjbyIsImhhbmRsZXIiLCJydW4iLCJvdXRwdXROYW1lcyIsImlucHV0TmFtZXMiLCJyZWxlYXNlIiwiY3JlYXRlIiwiQXJyYXlCdWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJleGVjdXRpb25Qcm92aWRlcnMiLCJzdGFydFByb2ZpbGluZyIsImVuZFByb2ZpbGluZyIsImZvIiwibW8iLCJobyIsImV2YWxNb2RlbCIsIm9wdGltaXplck1vZGVsIiwiY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlciIsImNoZWNrcG9pbnRTdGF0ZSIsInRyYWluTW9kZWwiLCJ0eXBlTmFycm93aW5nRm9yUnVuU3RlcCIsImNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzIiwicnVuVHJhaW5TdGVwIiwibG9hZFBhcmFtZXRlcnNCdWZmZXIiLCJnZXRDb250aWd1b3VzUGFyYW1ldGVycyIsInlvIiwiUm4iLCJJbmZlcmVuY2VTZXNzaW9uIiwiVGVuc29yIiwiVHJhaW5pbmdTZXNzaW9uIiwiZW52IiwicmVnaXN0ZXJCYWNrZW5kIiwiJHQiLCJQbiIsInJlYWRGaWxlIiwiV2wiLCJrbiIsIkJuIiwiTmwiLCJNbiIsIiRvIiwidm8iLCJEbiIsIndvIiwiY3VycmVudFNjcmlwdCIsIl9fZmlsZW5hbWUiLCJyZWFkeSIsImQiLCJmIiwianNlcEluaXQiLCJ3IiwiQyIsIl8iLCJHIiwiViIsInVlIiwiT2EiLCJQYSIsInJhIiwiUmEiLCJTYSIsIlkiLCJaIiwiSiIsImNlIiwibWUiLCJZZSIsIkUiLCJ0ZSIsIk90IiwicmVzb2x2ZSIsInJlamVjdCIsIkRhIiwiVGEiLCJlcnJvcnMiLCJmbHVzaCIsImFsbCIsImZpbHRlciIsIl9PcnRSdW4iLCJfT3J0UnVuV2l0aEJpbmRpbmciLCJfT3J0QmluZElucHV0IiwianNlcFJlZ2lzdGVyQnVmZmVyIiwicmVnaXN0ZXJCdWZmZXIiLCJqc2VwVW5yZWdpc3RlckJ1ZmZlcnMiLCJ1bnJlZ2lzdGVyQnVmZmVycyIsImpzZXBHZXRCdWZmZXIiLCJnZXRCdWZmZXIiLCJqc2VwQ3JlYXRlRG93bmxvYWRlciIsImNyZWF0ZURvd25sb2FkZXIiLCJhc3NpZ24iLCJ3aW5kb3ciLCJpbXBvcnRTY3JpcHRzIiwicHJvY2VzcyIsIm5vZGUiLCJkaXJuYW1lIiwiX19kaXJuYW1lIiwic3RhcnRzV2l0aCIsIlVSTCIsIm5vcm1hbGl6ZSIsInJlYWRGaWxlU3luYyIsImJ1ZmZlciIsInRoaXNQcm9ncmFtIiwiYXJndiIsInJlcGxhY2UiLCJzbGljZSIsImV4aXRDb2RlIiwiaW5zcGVjdCIsImhyZWYiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInN0YXR1cyIsIm9uZXJyb3IiLCJwcmludCIsImNvbnNvbGUiLCJsb2ciLCJiaW5kIiwicHJpbnRFcnIiLCJlcnJvciIsInF1aXQiLCJ3YXNtQmluYXJ5Iiwibm9FeGl0UnVudGltZSIsIldlYkFzc2VtYmx5IiwicWUiLCJSIiwiSCIsIksiLCJsZSIsIk0iLCJxIiwieGUiLCJvZSIsIlciLCJ3ZSIsIkhFQVA4IiwiSEVBUDE2IiwiSEVBUDMyIiwiSEVBUFU4IiwiSEVBUFUxNiIsIkhFQVBVMzIiLCJIRUFQRjMyIiwiSEVBUEY2NCIsImoiLCJTZSIsIlRlIiwiRWUiLCJwcmVSdW4iLCJzaGlmdCIsInVuc2hpZnQiLCJkZSIsIkNlIiwiZ3QiLCJMZSIsIm9uQWJvcnQiLCJSdW50aW1lRXJyb3IiLCJVIiwicGUiLCJsb2NhdGVGaWxlIiwiTmUiLCJPZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwib2siLCJhcnJheUJ1ZmZlciIsImNhdGNoIiwiSGUiLCJpbnN0YW50aWF0ZSIsIkdlIiwiZXQiLCJtaW4iLCJtYXgiLCJhbHBoYSIsImtlZXBEaW1zIiwibm9vcFdpdGhFbXB0eUF4ZXMiLCJheGVzIiwic3ViYXJyYXkiLCJwZXJtIiwiYXV0b1BhZCIsImRpbGF0aW9ucyIsImdyb3VwIiwia2VybmVsX3NoYXBlIiwicGFkcyIsInN0cmlkZXMiLCJ3SXNDb25zdCIsIm91dHB1dFBhZGRpbmciLCJvdXRwdXRTaGFwZSIsImFjdGl2YXRpb24iLCJSZSIsImtlcm5lbFNoYXBlIiwiZmUiLCJhdXRvX3BhZCIsImNlaWxfbW9kZSIsImNvdW50X2luY2x1ZGVfcGFkIiwic3RvcmFnZV9vcmRlciIsImJldGEiLCJ0cmFuc0EiLCJ0cmFuc0IiLCJzZWxlY3RMYXN0SW5kZXgiLCJheGlzIiwibnVtT3V0cHV0cyIsInNwbGl0U2l6ZXMiLCJhbnRpYWxpYXMiLCJjb29yZGluYXRlVHJhbnNmb3JtTW9kZSIsImN1YmljQ29lZmZBIiwiZXhjbHVkZU91dHNpZGUiLCJleHRyYXBvbGF0aW9uVmFsdWUiLCJrZWVwQXNwZWN0UmF0aW9Qb2xpY3kiLCJtb2RlIiwibmVhcmVzdE1vZGUiLCJzdGFydHMiLCJlbmRzIiwiZXBzaWxvbiIsImVxdWF0aW9uIiwid19pc19jb25zdCIsImFjdGl2YXRpb25fcGFyYW1zIiwiS2UiLCJtZXNzYWdlIiwiQXQiLCJFdCIsIk1hIiwiVXQiLCJKZSIsIlRleHREZWNvZGVyIiwicXQiLCJkZWNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ6dCIsImNoYXJDb2RlQXQiLCJLdCIsImx0IiwieHIiLCJkdCIsIld0IiwiR3QiLCJ5dCIsIk50IiwiVnQiLCJZdCIsIlVTRVIiLCJMT0dOQU1FIiwiUEFUSCIsIlBXRCIsIkhPTUUiLCJMQU5HIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2VzIiwiU3IiLCJWZSIsIlh0IiwibmUiLCJ0b1N0cmluZyIsInVyIiwicHQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldERheSIsIkRhdGUiLCJCYSIsIkNhIiwiZ2V0VGltZSIsInNldERhdGUiLCJzZXRNb250aCIsInNldEZ1bGxZZWFyIiwiV2EiLCJWYSIsIkVhIiwiSWEiLCJGYSIsIndhIiwiJGEiLCJVYSIsIlJlZ0V4cCIsInNwbGl0Iiwic3Vic3RyaW5nIiwiTWF0aCIsImZsb29yIiwiYWJzIiwiaW5jbHVkZXMiLCJKdCIsImN0IiwidHQiLCJJciIsIl90IiwiUXQiLCJadCIsIkFyIiwiRXIiLCJQciIsIkZ0IiwiQnJvd3NlciIsIkdhIiwiTmEiLCJyZXN1bWUiLCJPciIsInBhdXNlIiwib3IiLCJUdCIsImVyIiwiZm9yRWFjaCIsIm9uRXhpdCIsIlRyIiwiUnIiLCJ6IiwiQSIsIngiLCJOYU4iLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENEYXkiLCJVVEMiLCJnZXRTZWNvbmRzIiwiZ2V0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJzZXRUaW1lIiwiZ2V0WWVhciIsInRyIiwiY2VpbCIsInRvVGltZVN0cmluZyIsIm1hdGNoIiwiYXBwbHkiLCJoIiwibm93IiwiYyIsInBlcmZvcm1hbmNlIiwiY29weVdpdGhpbiIsImdyb3ciLCJrIiwiRiIsImFyZ3VtZW50cyIsInBvcCIsImlyIiwiRmliZXJzIiwiYWIiLCJDciIsIl9fZXJybm9fbG9jYXRpb24iLCJtYWxsb2MiLCJzdGFja1NhdmUiLCJzdGFja0FsbG9jIiwiYnQiLCJOIiwibW9uaXRvclJ1bkRlcGVuZGVuY2llcyIsImNsZWFySW50ZXJ2YWwiLCJpbnN0YW50aWF0ZVdhc20iLCJpbnN0YW50aWF0ZVN0cmVhbWluZyIsInplIiwiaW5zdGFuY2UiLCJfT3J0SW5pdCIsIk8iLCJfT3J0R2V0TGFzdEVycm9yIiwiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zIiwiUSIsIl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlciIsIl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUiLCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5IiwiX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyIsIl9PcnRDcmVhdGVTZXNzaW9uIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwiX09ydEdldElucHV0T3V0cHV0Q291bnQiLCJYIiwiX09ydEdldElucHV0TmFtZSIsIl9PcnRHZXRPdXRwdXROYW1lIiwiX09ydEZyZWUiLCJfT3J0Q3JlYXRlVGVuc29yIiwiX09ydEdldFRlbnNvckRhdGEiLCJhYSIsIl9PcnRSZWxlYXNlVGVuc29yIiwiYmEiLCJfT3J0Q3JlYXRlUnVuT3B0aW9ucyIsImNhIiwiX09ydEFkZFJ1bkNvbmZpZ0VudHJ5IiwiZGEiLCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnMiLCJlYSIsIl9PcnRDcmVhdGVCaW5kaW5nIiwiZmEiLCJnYSIsIl9PcnRCaW5kT3V0cHV0IiwiaGEiLCJfT3J0Q2xlYXJCb3VuZE91dHB1dHMiLCJpYSIsIl9PcnRSZWxlYXNlQmluZGluZyIsImthIiwibGEiLCJfT3J0RW5kUHJvZmlsaW5nIiwibWEiLCJfSnNlcE91dHB1dCIsIm5hIiwiX0pzZXBHZXROb2RlTmFtZSIsIm9hIiwiUnQiLCJfbWFsbG9jIiwicGEiLCJfZnJlZSIsInNhIiwicnIiLCJ0YSIsIm5yIiwidWEiLCJhciIsInZhIiwieGEiLCJ5YSIsInphIiwiQWEiLCJzciIsImNhbGxlZFJ1biIsIm9uUnVudGltZUluaXRpYWxpemVkIiwicG9zdFJ1biIsInNldFN0YXR1cyIsInNldFRpbWVvdXQiLCJfX19zdGFydF9lbV9qcyIsIl9fX3N0b3BfZW1fanMiLCJzdGFja1Jlc3RvcmUiLCJVVEY4VG9TdHJpbmciLCJzdHJpbmdUb1VURjgiLCJsZW5ndGhCeXRlc1VURjgiLCJwcmVJbml0IiwieG8iLCJTbyIsIkNvIiwiY3B1cyIsIlZsIiwiUm8iLCJHbCIsIlduIiwiTm4iLCJqciIsIlRvIiwiRmwiLCJMbCIsIkhsIiwiUG8iLCJQZSIsIk1lIiwiZHIiLCJBZSIsImtvIiwiamwiLCJxbCIsIktsIiwiWWwiLCJNbyIsIlZuIiwiY3IiLCJwciIsIktyIiwiZnIiLCJZciIsIlVuIiwiWGwiLCJKbCIsInpvIiwiV28iLCJObyIsIlFsIiwiX2UiLCJWbyIsIlhyIiwiWmwiLCJGbyIsIkZuIiwiR24iLCJMbyIsIkxuIiwiaWUiLCJIbiIsIm50IiwiTXQiLCJKciIsIlFyIiwiWnIiLCJqbyIsIkJlIiwicW4iLCJtdCIsIlFlIiwiRHQiLCJTdCIsInFvIiwiam4iLCJLbyIsIktuIiwiWW8iLCJ0ZCIsIlhvIiwicmQiLCJuZCIsIkN0IiwiSm8iLCJRbyIsImFkIiwib2QiLCJpZCIsInNkIiwidWQiLCJsZCIsImRkIiwiY2QiLCJwZCIsImZkIiwiYXQiLCJabyIsImVpIiwidGkiLCJyaSIsIm5pIiwiYWkiLCJvaSIsImlpIiwic2kiLCJ1aSIsIm90IiwibWQiLCJ0biIsIlluIiwiaXQiLCJoZCIsImdkIiwieWQiLCJiZCIsIndkIiwidmQiLCIkZCIsInhkIiwiU2QiLCJDZCIsInN0IiwiZGkiLCJjaSIsInBpIiwiZmkiLCJtaSIsImhpIiwiZ2kiLCJ5aSIsImJpIiwid2kiLCJaZSIsInZpIiwiJGkiLCJ4aSIsIlNpIiwiWG4iLCJJZCIsIkFkIiwiSWkiLCJFZCIsIiRlIiwiRWkiLCJfaSIsIk9pIiwiVGkiLCJSaSIsIlBpIiwia2kiLCJCaSIsIk1pIiwiSm4iLCJfZCIsIkRpIiwiemkiLCJXaSIsIk5pIiwicm4iLCJWaSIsIm5uIiwiVWkiLCJHaSIsIkZpIiwiTGkiLCJIaSIsImppIiwicWkiLCJLaSIsIllpIiwiWGkiLCJKaSIsIlFpIiwiWmkiLCJlcyIsInRzIiwicnMiLCJucyIsIlRkIiwiUmQiLCJhcyIsIlBkIiwia2QiLCJ1dCIsImlzIiwic3MiLCJ1cyIsImxzIiwiZHMiLCJjcyIsInBzIiwiZnMiLCJtcyIsImhzIiwiTWQiLCJEZCIsInpkIiwiV2QiLCJ5cyIsImJzIiwiV2UiLCJhbiIsIm9uIiwidW4iLCJsbiIsImRuIiwiTmQiLCJWZCIsImdyIiwidnMiLCJVZCIsInlyIiwiR2QiLCJjbiIsIkZkIiwiJHMiLCJDcyIsIkxkIiwiSXMiLCJIZCIsImpkIiwicWQiLCJBcyIsIktkIiwiWWQiLCJYZCIsIkpkIiwiT3MiLCJUcyIsIlFkIiwiWmQiLCJlYyIsInRjIiwiUnMiLCJwbiIsImtzIiwibmMiLCJhYyIsIkJzIiwiTXMiLCJvYyIsInpzIiwiaWMiLCJzYyIsIldzIiwidWMiLCJsYyIsIlZzIiwiVXMiLCJkYyIsImNjIiwiRnMiLCJMcyIsInBjIiwiZmMiLCJtYyIsImpzIiwicXMiLCJoYyIsImdjIiwieWMiLCJiYyIsIllzIiwiWHMiLCJ3YyIsInZjIiwiUXMiLCJacyIsIiRjIiwidHUiLCJ4YyIsIlNjIiwiQ2MiLCJJYyIsIkFjIiwiRWMiLCJfYyIsIk9jIiwiVGMiLCJudSIsImF1IiwiZm4iLCJpdSIsInN1IiwidXUiLCJsdSIsImR1IiwiY3UiLCJwdSIsImZ1IiwibXUiLCJodSIsImd1IiwieXUiLCJidSIsInd1IiwiUGMiLCJrYyIsIiR1IiwiQmMiLCJNYyIsIkRjIiwiemMiLCJXYyIsIk5jIiwiVmMiLCJVYyIsIkdjIiwiRmMiLCJMYyIsIkhjIiwiamMiLCJxYyIsIktjIiwiU3UiLCJDdSIsIlljIiwiWGMiLCJBdSIsIkV1IiwiSmMiLCJtbiIsIlFjIiwiT3UiLCJaYyIsImVwIiwiVHUiLCJSdSIsInRwIiwicnAiLCJrdSIsIkJ1IiwibnAiLCJhcCIsIm9wIiwiaXAiLCJzcCIsIkR1IiwienUiLCJOdSIsInVwIiwibHAiLCJkcCIsIlZ1IiwiY3AiLCJwcCIsIkd1IiwiTHUiLCJobiIsImZwIiwibXAiLCJnbiIsIklvIiwiX28iLCJFbyIsInpuIiwiQW8iLCJhZSIsIlFiIiwid2IiLCJ5YiIsImpiIiwieGIiLCJ6YiIsIkFiIiwiZWUiLCJyZSIsImhlIiwiYmUiLCJydCIsInNlIiwieG4iLCJiYiIsIkZiIiwiRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCIsIldvcmtlciIsIndyaXRlU3luYyIsIklOSVRJQUxfTUVNT1JZIiwid2FzbU1lbW9yeSIsIk1lbW9yeSIsImluaXRpYWwiLCJtYXhpbXVtIiwic2hhcmVkIiwianQiLCIkciIsInllIiwidGVybWluYXRlIiwib25tZXNzYWdlIiwiRWIiLCJ0YiIsImNtZCIsInN0YXJ0X3JvdXRpbmUiLCJHYiIsImFyZyIsInJiIiwicHRocmVhZF9wdHIiLCJ1bnJlZiIsInBvc3RNZXNzYWdlIiwiTWIiLCJIYiIsIm1iIiwiZ2IiLCJ2YiIsInViIiwiQmIiLCJyZWNlaXZlT2JqZWN0VHJhbnNmZXIiLCJEYiIsInRocmVhZEluaXRUTFMiLCJsYiIsInNldEV4aXRTdGF0dXMiLCJrYiIsIlNiIiwiQ24iLCJDYiIsInRhcmdldFRocmVhZCIsIk1yIiwiUmIiLCJ0cmFuc2Zlckxpc3QiLCJ0aHJlYWQiLCJsb2FkZWQiLCJhbGVydCIsInRocmVhZElkIiwidGV4dCIsInRhcmdldCIsImFyZ3MiLCJmaWxlbmFtZSIsImxpbmVubyIsImhhbmRsZXJzIiwidXJsT3JCbG9iIiwibWFpblNjcmlwdFVybE9yQmxvYiIsIndhc21Nb2R1bGUiLCJxYiIsIlBUaHJlYWQiLCJmYiIsInBiIiwib2IiLCJuYiIsIk9iIiwiZXN0YWJsaXNoU3RhY2tTcGFjZSIsIkRyIiwiaW52b2tlRW50cnlQb2ludCIsIkluIiwiX3IiLCJBdG9taWNzIiwiTmIiLCJzdG9yZSIsIl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdCIsImNoZWNrTWFpbGJveCIsIlNuIiwiQW4iLCJFbiIsIlB0IiwiS2IiLCJKYiIsImNiIiwiaWIiLCJlYiIsIlRiIiwiSWIiLCJMYiIsInZsIiwiJGwiLCJrciIsInd0IiwiX2EiLCJCciIsIlNsIiwiQ2wiLCJUbCIsIlJsIiwiaGIiLCJzYiIsIkVsIiwiQWwiLCJfbCIsIk9sIiwicmVmIiwidGltZU9yaWdpbiIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJQYiIsIlViIiwieGwiLCJwdGhyZWFkX3NlbGYiLCJQbCIsIl9wdGhyZWFkX3NlbGYiLCJfX2Vtc2NyaXB0ZW5fdGxzX2luaXQiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQiLCJ6ciIsIl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCIsIl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94IiwiZHluQ2FsbF9paSIsInN0YXJ0V29ya2VyIiwia2VlcFJ1bnRpbWVBbGl2ZSIsIkV4aXRTdGF0dXMiLCJPbyIsImdmIiwiVWwiLCJIdCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJ2YWxpZGF0ZSIsImluaXRUaW1lb3V0IiwibnVtVGhyZWFkcyIsInNpbWQiLCJ3YXNtUGF0aHMiLCJlbmRzV2l0aCIsIkJsb2IiLCJjcmVhdGVPYmplY3RVUkwiLCJyYWNlIiwicXIiLCJoYXMiLCJhZGQiLCJlbnRyaWVzIiwiQm8iLCJsb2dTZXZlcml0eUxldmVsIiwiaXNJbnRlZ2VyIiwibG9nVmVyYm9zaXR5TGV2ZWwiLCJ0YWciLCJleHRyYSIsIldlYWtTZXQiLCJEbyIsInNlc3Npb24iLCJ1c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5Iiwic29tZSIsImVuYWJsZU1lbVBhdHRlcm4iLCJkZXZpY2VUeXBlIiwicG93ZXJQcmVmZXJlbmNlIiwicHJlZmVycmVkTGF5b3V0IiwiZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCIsImV4ZWN1dGlvbk1vZGUiLCJsb2dJZCIsIm9wdGltaXplZE1vZGVsRmlsZVBhdGgiLCJlbmFibGVDcHVNZW1BcmVuYSIsImVuYWJsZVByb2ZpbGluZyIsImZyZWVEaW1lbnNpb25PdmVycmlkZXMiLCJEZSIsInh0IiwidG9JU09TdHJpbmciLCJVbyIsIkdvIiwiSG8iLCJkZXZpY2UiLCJjcmVhdGVCdWZmZXIiLCJ1c2FnZSIsIkdQVUJ1ZmZlclVzYWdlIiwiQ09QWV9EU1QiLCJNQVBfUkVBRCIsImdldENvbW1hbmRFbmNvZGVyIiwiZW5kQ29tcHV0ZVBhc3MiLCJjb3B5QnVmZmVyVG9CdWZmZXIiLCJtYXBBc3luYyIsIkdQVU1hcE1vZGUiLCJSRUFEIiwiZ2V0TWFwcGVkUmFuZ2UiLCJkZXN0cm95Iiwic3RvcmFnZUNhY2hlIiwiZnJlZUJ1ZmZlcnMiLCJmcmVlVW5pZm9ybUJ1ZmZlcnMiLCJidWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyIsImJ1ZmZlcnNQZW5kaW5nIiwiZXh0ZXJuYWxCdWZmZXJzIiwidXBsb2FkIiwiYnl0ZU9mZnNldCIsIm9yaWdpbmFsU2l6ZSIsIm1hcHBlZEF0Q3JlYXRpb24iLCJNQVBfV1JJVEUiLCJDT1BZX1NSQyIsInVubWFwIiwiZ3B1RGF0YSIsIm1lbWNweSIsInJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJkZWxldGUiLCJ1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJTVE9SQUdFIiwiVU5JRk9STSIsInJlZnJlc2hQZW5kaW5nQnVmZmVycyIsImtlIiwiY2FjaGVLZXkiLCJfY2FjaGVLZXkiLCJzb3J0IiwiZ2UiLCJjYWxjTWF0TXVsU2hhcGUiLCJjYWxjU2hhcGUiLCJpc1ZhbGlkQnJvYWRjYXN0IiwiZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSIsInNpemVGcm9tRGltZW5zaW9uIiwic2l6ZVRvRGltZW5zaW9uIiwiY29tcHV0ZVN0cmlkZXMiLCJub3JtYWxpemVBeGlzIiwibm9ybWFsaXplQXhlcyIsInNvcnRCYXNlZE9uUGVybSIsInJldmVyc2UiLCJwYWRTaGFwZSIsImFyZUVxdWFsIiwiZXZlcnkiLCJhZGp1c3RQb29sQXR0cmlidXRlcyIsImFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCIsImFkanVzdFBhZEFuZFJldHVyblNoYXBlIiwiY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSIsImNvbXB1dGVTaGFwZUhlbHBlciIsImNvbXB1dGVDb252T3V0cHV0U2hhcGUiLCJnZXRTaGFwZU9mR2VtbVJlc3VsdCIsInZlIiwia2V5cyIsImluZGljZXMiLCJzdG9yYWdlIiwidGVuc29yIiwib2Zmc2V0VG9JbmRpY2VzIiwiaW5kaWNlc1RvT2Zmc2V0IiwiYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQiLCJzZXRCeUluZGljZXMiLCJnZXRCeUluZGljZXMiLCJpbXBsIiwidmFsdWVzIiwiaW5kaWNlc0dldCIsInJhbmsiLCJpbmRpY2VzU2V0Iiwic2V0QnlPZmZzZXQiLCJnZXRCeU9mZnNldCIsInNoYXBlIiwibm9ybWFsaXplZERpc3BhdGNoR3JvdXAiLCJpbmRpY2VzSGVscGVycyIsInVuaWZvcm1zIiwidmFyaWFibGVJbmRleCIsImd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMiLCJtYWluU3RhcnQiLCJkZWNsYXJlVmFyaWFibGUiLCJkZWNsYXJlVmFyaWFibGVzIiwicmVnaXN0ZXJVbmlmb3JtIiwidW5pZm9ybURlY2xhcmF0aW9uIiwiYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyIsIm1yIiwic2hhZGVyQ2FjaGUiLCJoaW50IiwiaW5wdXREZXBlbmRlbmNpZXMiLCJnZXRSdW5EYXRhIiwib3V0cHV0cyIsImRpc3BhdGNoR3JvdXAiLCJwcm9ncmFtVW5pZm9ybXMiLCJnZXRTaGFkZXJTb3VyY2UiLCJpbnB1dHMiLCJjb21wdXRlIiwibGkiLCJlbiIsInN1bSIsInByb2QiLCJzdW1TcXVhcmUiLCJsb2dTdW1FeHAiLCJsMSIsImwyIiwibG9nU3VtIiwiZ2V0QmlnSW50NjRBcnJheSIsIkNpIiwiQWkiLCJRbiIsImdldEZsb2F0MzJBcnJheSIsIm9zIiwiZ3MiLCJzY2FsYXIiLCJ2ZWN0b3IiLCJ3cyIsInNuIiwiWm4iLCJociIsImFjdGl2YXRpb25GdW5jdGlvbiIsImFwcGx5QWN0aXZhdGlvbiIsImNsaXBNaW4iLCJjbGlwTWF4IiwiYWN0aXZhdGlvbkNhY2hlS2V5IiwiYnIiLCJ4cyIsInRvTG93ZXJDYXNlIiwiU3MiLCJrZXJuZWxDdXN0b21EYXRhIiwid1QiLCJjb25jYXQiLCJFcyIsIl9zIiwiUHMiLCJyZWR1Y2UiLCJmaWxsIiwiRHMiLCJzeW1ib2xUb0luZGljZXMiLCJpbnB1dEluZGV4IiwiYWRkU3ltYm9sIiwiaGFzRWxsaXBzaXMiLCJzeW1ib2xUb0luZm8iLCJsaHMiLCJvdXRwdXREaW1zIiwicHJvY2Vzc1Rlcm0iLCJjb3VudCIsImVsbGlwc2lzRGltcyIsImRpbVZhbHVlIiwicmhzIiwiaW5wdXRJbmRpY2VzIiwiTnMiLCJHcyIsIkhzIiwiS3MiLCJKcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb21wb25lbnRzIiwiZXUiLCJvdXRwdXRDb3VudCIsInJ1Iiwib3UiLCJ2dSIsImNlaWxNb2RlIiwiY291bnRJbmNsdWRlUGFkIiwic3RvcmFnZU9yZGVyIiwieHUiLCJnZXRJbnQzMkFycmF5IiwidmFsaWRhdGVJbnB1dENvbnRlbnQiLCJJdSIsInJvdW5kIiwiTUFYX1ZBTFVFIiwiTUlOX1ZBTFVFIiwiY3VzdG9tRGF0YUJ1ZmZlciIsIl91IiwiUHUiLCJzaWduIiwiTXUiLCJXdSIsIlV1IiwiRnUiLCJIdSIsImp1IiwicmVwbyIsImF0dHJpYnV0ZXNCb3VuZCIsImdldEFydGlmYWN0Iiwic2V0QXJ0aWZhY3QiLCJnZXRDb21wdXRlUGFzc0VuY29kZXIiLCJzZXRQaXBlbGluZSIsImNvbXB1dGVQaXBlbGluZSIsImJpbmRpbmciLCJyZXNvdXJjZSIsImNyZWF0ZUJpbmRHcm91cCIsImxheW91dCIsImdldEJpbmRHcm91cExheW91dCIsImxhYmVsIiwicHJvZ3JhbUluZm8iLCJzZXRCaW5kR3JvdXAiLCJkaXNwYXRjaFdvcmtncm91cHMiLCJwZW5kaW5nRGlzcGF0Y2hOdW1iZXIiLCJpc1F1ZXJ5RW5hYmxlZCIsInF1ZXJ5RGF0YSIsImdwdURhdGFNYW5hZ2VyIiwicXVlcnlTZXRDb3VudCIsIlFVRVJZX1JFU09MVkUiLCJyZXNvbHZlUXVlcnlTZXQiLCJxdWVyeVNldCIsImN1cnJlbnRLZXJuZWxJZCIsImtlcm5lbHMiLCJxdWVyeVRpbWVCYXNlIiwiYnVpbGQiLCJmZWF0dXJlcyIsImNyZWF0ZVNoYWRlck1vZHVsZSIsImNvZGUiLCJjcmVhdGVDb21wdXRlUGlwZWxpbmUiLCJlbnRyeVBvaW50Iiwibm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUiLCJsaW1pdHMiLCJtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbiIsInNxcnQiLCJjYnJ0IiwicXUiLCJjb21tYW5kRW5jb2RlciIsImNvbXB1dGVQYXNzRW5jb2RlciIsInNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nIiwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEiLCJpbml0aWFsaXplIiwiZ3B1IiwicmVxdWVzdEFkYXB0ZXIiLCJyZXF1aXJlZExpbWl0cyIsIm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSIsIm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSIsIm1heEJ1ZmZlclNpemUiLCJtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVkiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVoiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVxdWVzdERldmljZSIsInByb2dyYW1NYW5hZ2VyIiwia2VybmVsUGVyc2lzdGVudERhdGEiLCJkZWJ1ZyIsIm9udW5jYXB0dXJlZGVycm9yIiwiR1BVVmFsaWRhdGlvbkVycm9yIiwiY3JlYXRlQ29tbWFuZEVuY29kZXIiLCJjcmVhdGVRdWVyeVNldCIsInRpbWVzdGFtcFdyaXRlcyIsImJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXgiLCJlbmRPZlBhc3NXcml0ZUluZGV4IiwiYmVnaW5Db21wdXRlUGFzcyIsImVuZCIsInF1ZXVlIiwic3VibWl0IiwiZmluaXNoIiwicHJvZmlsaW5nTW9kZSIsInRlbXBvcmFyeURhdGEiLCJ3cml0ZUJ1ZmZlciIsIm9mZnNldCIsImFsbG9jIiwiZnJlZSIsImNyZWF0ZUtlcm5lbCIsInJlbGVhc2VLZXJuZWwiLCJjb21wdXRlS2VybmVsIiwicHVzaEVycm9yU2NvcGUiLCJwb3BFcnJvclNjb3BlIiwiS3UiLCJocCIsIndyIiwiSnUiLCJncCIsInlwIiwiUXUiLCJ2ciIsIlp1IiwiZWwiLCJ0bCIsIlh1IiwicmwiLCJubCIsImFsIiwiaHQiLCJqZSIsImJuIiwiSXQiLCJ2cCIsInluIiwic2wiLCJ1bCIsImxsIiwiZGwiLCJjbCIsInBsIiwiZmwiLCJtbCIsInduIiwiaGwiLCIkcCIsInZuIiwieHAiLCIkbiIsIll1IiwiY3VzdG9tRGF0YU9mZnNldCIsImN1c3RvbURhdGFTaXplIiwib3BLZXJuZWxDb250ZXh0Iiwib3V0cHV0Iiwib2wiLCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiIsImhhbmRsZSIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9ucyIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQiLCJpbCIsIlV5Iiwid3AiLCJwcm94eSIsIm91dCIsInJldm9rZU9iamVjdFVSTCIsImluIiwibW9kZWwiLCJtb2RlbGRhdGEiLCJvcHRpb25zIiwic2Vzc2lvbklkIiwib3V0cHV0SW5kaWNlcyIsImdsIiwiY3JlYXRlU2Vzc2lvbkFsbG9jYXRlIiwibG9hZE1vZGVsIiwieWwiLCJibCIsIndhc21CYWNrZW5kIiwiU3AiLCJ3bCIsIklwIiwiZGVmYXVsdCIsIkNwIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwidW5kZWZpbmVkIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsIm9ydCIsIk1PREVMX1dJRFRIIiwiTU9ERUxfSEVJR0hUIiwiTU9ERUxfTUFQIiwic2FtX2IiLCJjb25maWciLCJwcm92aWRlciIsInRocmVhZHMiLCJ2YXJzIiwic2VhcmNoIiwicGFpciIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhcnNlSW50IiwiZ2V0Q29uZmlnIiwiY2FudmFzIiwiZmlsZWluIiwiaW1hZ2VfZW1iZWRkaW5ncyIsImltYWdlSW1hZ2VEYXRhIiwic2VzcyIsImdldEVsZW1lbnRCeUlkIiwiaW5uZXJIVE1MIiwidG9GaXhlZCIsImltYWdlUHJlcHJvY2Vzc2luZyIsImltZ0FyciIsIm9yaWdpbmFsVGVuc29yIiwib3JpZ2luYWxEYXRhIiwicmVzaGFwZWRUZW5zb3IiLCJyZXNpemVUZW5zb3IiLCJpc1doaXRlIiwidGhyZXNob2xkIiwicGVyY2VudCIsImlmV2hpdGVCYWNrZ3JvdW5kIiwiaW52ZXJ0SW1hZ2UiLCJpbnZlcnRXaGl0ZUJhY2tncm91bmQiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1nIiwiaWR4Iiwib3B0IiwidXJsIiwiY2FjaGUiLCJjYWNoZXMiLCJjbGVhcl9jYWNoZSIsImNhY2hlZFJlc3BvbnNlIiwiZmV0Y2hBbmRDYWNoZSIsImxvYWRfbW9kZWwiLCJvbmNoYW5nZSIsImV2dCIsImZpbGVzIiwiZXZlbnQiLCJGaWxlUmVhZGVyIiwiZmlsZVJlYWRlciIsInByZWRpY3Rpb25fZWxlbWVudCIsImRpc2FibGVkIiwic3R5bGUiLCJjdXJzb3IiLCJjdHgiLCJpbWdUZW5zb3IiLCJmZWVkIiwiZW1iX3Byb3BlcnR5Iiwib3JpZ2luYWxPYmplY3QiLCJrZXkiLCJnZXRLZXlzQW5kVmFsdWVzIiwicHJvYnMiLCJtYXhfcHJvYiIsIm1heEluZCIsInByb2JzQXJyYXkiLCJleHBQcm9iTnVtcyIsImVhY2hfZWxlbWVudCIsImV4cCIsInRvdGFsUHJvYk51bXMiLCJleHBQcm9iUHJvYnMiLCJtb2RlbEZvcndhcmQiLCJyZXN1bHQiLCJyZWFkQXNEYXRhVVJMIiwibWFpbiJdLCJzb3VyY2VSb290IjoiIn0=