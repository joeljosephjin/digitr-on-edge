/*! For license information please see bundle.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}(self,(()=>(()=>{var e={122:(e,t,n)=>{"use strict";var r,a,i,o,s,u,l,d,c,p,f,h,m,g,y,w,$,v,b,x,S,_,C,E,I,A,O,T,R="/index.js",k=Object.defineProperty,B=Object.getOwnPropertyDescriptor,M=Object.getOwnPropertyNames,D=Object.prototype.hasOwnProperty,P=(e,t)=>()=>(e&&(t=e(e=0)),t),z=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),W=(e,t)=>{for(var n in t)k(e,n,{get:t[n],enumerable:!0})},N=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let n of M(t))!D.call(e,n)&&undefined!==n&&k(e,n,{get:()=>t[n],enumerable:!(r=B(t,n))||r.enumerable});return e})(k({},"__esModule",{value:!0}),e),G=P((()=>{a=new Map,i=[],o=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=a.get(e);if(void 0===r)a.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=i.indexOf(e);-1!==t&&i.splice(t,1);for(let t=0;t<i.length;t++)if(a.get(i[t]).priority<=n)return void i.splice(t,0,e);i.push(e)}}},s=async e=>{let t=0===e.length?i:e,n=[];for(let e of t){let t=a.get(e);if(t){if(t.initialized)return t.backend;if(t.aborted)continue;let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(a){r||n.push({name:e,err:a}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)}})),U=P((()=>{G()})),V=P((()=>{u="1.17.0-dev.20231103-1439da36fe"})),j=P((()=>{V(),l="warning",d={wasm:{},webgl:{},webgpu:{},versions:{common:u},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);l=e}},get logLevel(){return l}},Object.defineProperty(d,"logLevel",{enumerable:!0})})),F=P((()=>{j(),c=d})),H=P((()=>{p=(e,t)=>{let n=document.createElement("canvas");n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[3]):(a=e.dims[3],i=e.dims[2]);let o,s,u=void 0!==t?.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?o=[255,255,255,255]:"number"==typeof l.mean?o=[l.mean,l.mean,l.mean,l.mean]:(o=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(o[3]=l.mean[3])),void 0===l||void 0===l.bias?s=[0,0,0,0]:"number"==typeof l.bias?s=[l.bias,l.bias,l.bias,l.bias]:(s=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(s[3]=l.bias[3]));let d=i*a,c=0,p=d,f=2*d,h=-1;"RGBA"===u?(c=0,p=d,f=2*d,h=3*d):"RGB"===u?(c=0,p=d,f=2*d):"RBG"===u&&(c=0,f=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<a;n++){let a=(e.data[c++]-s[0])*o[0],i=(e.data[p++]-s[1])*o[1],u=(e.data[f++]-s[2])*o[2],l=-1===h?255:(e.data[h++]-s[3])*o[3];r.fillStyle="rgba("+a+","+i+","+u+","+l+")",r.fillRect(n,t,1,1)}return n.toDataURL()}throw new Error("Can not access image data")},f=(e,t)=>{let n,r=document.createElement("canvas").getContext("2d");if(null==r)throw new Error("Can not access image data");{let a,i,o;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[1],o=e.dims[3]):(a=e.dims[3],i=e.dims[2],o=e.dims[1]);let s,u,l=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?s=[255,255,255,255]:"number"==typeof d.mean?s=[d.mean,d.mean,d.mean,d.mean]:(s=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(s[3]=d.mean[3])),void 0===d||void 0===d.bias?u=[0,0,0,0]:"number"==typeof d.bias?u=[d.bias,d.bias,d.bias,d.bias]:(u=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(u[3]=d.bias[3]));let c=i*a;if(void 0!==t&&(void 0!==t.format&&4===o&&"RGBA"!==t.format||3===o&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let p=4,f=0,h=1,m=2,g=3,y=0,w=c,$=2*c,v=-1;"RGBA"===l?(y=0,w=c,$=2*c,v=3*c):"RGB"===l?(y=0,w=c,$=2*c):"RBG"===l&&(y=0,$=c,w=2*c),n=r.createImageData(a,i);for(let t=0;t<i*a;f+=p,h+=p,m+=p,g+=p,t++)n.data[f]=(e.data[y++]-u[0])*s[0],n.data[h]=(e.data[w++]-u[1])*s[1],n.data[m]=(e.data[$++]-u[2])*s[2],n.data[g]=-1===v?255:(e.data[v++]-u[3])*s[3]}return n}})),L=P((()=>{K(),h=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:a,width:i}=t,o=t.norm??{mean:255,bias:0};n="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],r="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=a*i,d="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l),c=4,p=0,f=1,h=2,m=3,g=0,y=l,w=2*l,$=-1;"RGB"===s&&(c=3,p=0,f=1,h=2,m=-1),"RGBA"===u?$=3*l:"RBG"===u?(g=0,w=l,y=2*l):"BGR"===u&&(w=0,y=l,g=2*l);for(let t=0;t<l;t++,p+=c,h+=c,f+=c,m+=c)d[g++]=(e[p]+r[0])/n[0],d[y++]=(e[f]+r[1])/n[1],d[w++]=(e[h]+r[2])/n[2],-1!==$&&-1!==m&&(d[$++]=(e[m]+r[3])/n[3]);return new C("float32",d,"RGBA"===u?[1,4,a,i]:[1,3,a,i])},m=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,o="string"==typeof e,s=t??{};if(r){let r=document.createElement("canvas");r.width=e.width,r.height=e.height;let a=r.getContext("2d");if(null==a)throw new Error("Can not access image data");{let r=e.height,i=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=r,s.width=i}else s.tensorFormat="RGBA",s.height=r,s.width=i;a.drawImage(e,0,0),n=a.getImageData(0,0,i,r).data}}else{if(!a){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=document.createElement("canvas");r.width=e.width,r.height=e.height;let a=r.getContext("2d");if(null!=a){let t=e.height,r=e.width;return a.drawImage(e,0,0,r,t),n=a.getImageData(0,0,r,t).data,s.height=t,s.width=r,h(n,s)}throw new Error("Can not access image data")}if(o)return new Promise(((t,n)=>{let r=document.createElement("canvas"),a=r.getContext("2d");if(!e||!a)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,a.drawImage(i,0,0,r.width,r.height);let e=a.getImageData(0,0,r.width,r.height);s.height=r.height,s.width=r.width,t(h(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,a;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,a=t.resizedWidth):(r=e.height,a=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=r,s.width=a,void 0!==t){let t=document.createElement("canvas");t.width=a,t.height=r;let i=t.getContext("2d");if(null==i)throw new Error("Can not access image data");i.putImageData(e,0,0),n=i.getImageData(0,0,a,r).data}else n=e.data}}if(void 0!==n)return h(n,s);throw new Error("Input data provided is not supported - aborted tensor creation")},g=(e,t)=>{let{width:n,height:r,download:a,dispose:i}=t;return new C({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:a,dispose:i})},y=(e,t)=>{let{dataType:n,dims:r,download:a,dispose:i}=t;return new C({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:a,dispose:i})},w=(e,t,n)=>new C({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),q=P((()=>{$=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),v=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),b=!1,x=()=>{if(!b){b=!0;let e=typeof BigInt64Array<"u"&&"function"==typeof BigInt64Array.from,t=typeof BigUint64Array<"u"&&"function"==typeof BigUint64Array.from;e&&($.set("int64",BigInt64Array),v.set(BigInt64Array,"int64")),t&&($.set("uint64",BigUint64Array),v.set(BigUint64Array,"uint64"))}}})),Y=P((()=>{K(),S=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},_=(e,t)=>{switch(e.location){case"cpu":return new C(e.type,e.data,t);case"cpu-pinned":return new C({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new C({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new C({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),K=P((()=>{H(),L(),q(),Y(),C=class{constructor(e,t,n){let r,a;if(x(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,a=e.dims,e.location){case"cpu-pinned":{let t=$.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"bool"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,o;if("string"==typeof e)if(r=e,o=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");i=t}else{let n=$.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);i=t}}else if(o=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else{let t=v.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===o)o=[i.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");a=o,this.cpuData=i,this.dataLocation="cpu"}let i=S(a);if(this.cpuData&&i!==this.cpuData.length)throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=i}static async fromImage(e,t){return m(e,t)}static fromTexture(e,t){return g(e,t)}static fromGpuBuffer(e,t){return y(e,t)}static fromPinnedBuffer(e,t,n){return w(e,t,n)}toDataURL(e){return p(this,e)}toImageData(e){return f(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return _(this,e)}}})),X=P((()=>{K(),E=C})),J=P((()=>{G(),X(),I=class e{constructor(e){this.handler=e}async run(e,t,n){let r={},a={};if("object"!=typeof e||null===e||e instanceof E||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,o=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==o.indexOf(n)){let a=t[n];(null===a||a instanceof E)&&(e=!0,i=!1,r[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(let e of this.outputNames)r[e]=null;let o=await this.handler.run(e,r,a),s={};for(let e in o)if(Object.hasOwnProperty.call(o,e)){let t=o[e];s[e]=t instanceof E?t:new E(t.type,t.data,t.dims)}return s}async release(){return this.handler.dispose()}static async create(t,n,r,a){let i,o={};if("string"==typeof t){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,s=0,u=t.byteLength;if("object"==typeof n&&null!==n)o=n;else if("number"==typeof n){if(s=n,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(u=t.byteLength-s,"number"==typeof r){if(u=r,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||s+u>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-s}].`);if("object"==typeof a&&null!==a)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(e,s,u)}}let u=(o.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await(await s(u)).createInferenceSessionHandler(i,o);return new e(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),Q=P((()=>{J(),A=I})),Z=P((()=>{})),ee=P((()=>{G(),X(),O=class e{constructor(e){this.handler=e}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,n){let r=t.evalModel||"",a=t.optimizerModel||"",i=n||{},o=(i.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),u=await s(o);if(u.createTrainingSessionHandler){let n=await u.createTrainingSessionHandler(t.checkpointState,t.trainModel,r,a,i);return new e(n)}throw new Error("Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.")}typeNarrowingForRunStep(e,t,n){let r={},a={};if("object"!=typeof e||null===e||e instanceof E||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,o=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==o.indexOf(n)){let a=t[n];(null===a||a instanceof E)&&(e=!0,i=!1,r[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(let e of this.outputNames)r[e]=null;return[r,a]}convertHandlerReturnTypeToMapOfTensors(e){let t={};for(let n in e)if(Object.hasOwnProperty.call(e,n)){let r=e[n];t[n]=r instanceof E?r:new E(r.type,r.data,r.dims)}return t}async runTrainStep(e,t,n){let[r,a]=this.typeNarrowingForRunStep(e,t,n),i=await this.handler.runTrainStep(e,r,a);return this.convertHandlerReturnTypeToMapOfTensors(i)}async loadParametersBuffer(e,t){throw new Error("Method not implemented.")}async getContiguousParameters(e){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}})),te=P((()=>{ee(),T=O})),ne={};W(ne,{InferenceSession:()=>A,Tensor:()=>E,TrainingSession:()=>T,env:()=>c,registerBackend:()=>o});var re=P((()=>{U(),F(),Q(),X(),Z(),te()})),ae={};W(ae,{readFile:()=>ie});var ie,oe=P((()=>{ie=void 0})),se={};W(se,{join:()=>ue});var ue,le=P((()=>{ue=void 0})),de=z(((n,a)=>{var i,o=(i=(i=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||R,function(e={}){var t,n,r=e;r.ready=new Promise(((e,r)=>{t=e,n=r})),r.jsepInit=(e,t,n,a,i,o,s,u)=>{r.Za=e,r.Oa=t,r.Qa=n,r.Ja=a,r.Pa=i,r.ra=o,r.Ra=s,r.Sa=u,t=(e,t,n)=>(...r)=>{let a=be,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),be!=a?new Promise(((e,t)=>{Ie={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(r.Da)throw Error("Session already started");let a=r.Da={Ta:n[0],errors:[]},i=await t(...n);if(r.Da!==a)throw Error("Session mismatch");e.flush();let o=a.errors;if(0<o.length){let e=await Promise.all(o);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return i}finally{r.Da=null}},r._OrtRun=n(t(r._OrtRun,(()=>r._OrtRun),(e=>r._OrtRun=e))),r._OrtRunWithBinding=n(t(r._OrtRunWithBinding,(()=>r._OrtRunWithBinding),(e=>r._OrtRunWithBinding=e))),r._OrtBindInput=t(r._OrtBindInput,(()=>r._OrtBindInput),(e=>r._OrtBindInput=e)),r.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),r.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},r.jsepGetBuffer=t=>e.getBuffer(t),r.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r)};var a,o,s,u=Object.assign({},r),l="./this.program",d=(e,t)=>{throw t},c="object"==typeof window,p="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var m=(oe(),N(ae)),g=(le(),N(se));h=p?g.dirname(h)+"/":"//",a=(e,t)=>(e=e.startsWith("file://")?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),s=e=>((e=a(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):g.normalize(e),m.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!r.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),d=(e,t)=>{throw process.exitCode=e,t},r.inspect=()=>"[Emscripten Module object]"}else(c||p)&&(p?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),i&&(h=i),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},p&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,w=r.print||console.log.bind(console),$=r.printErr||console.error.bind(console);Object.assign(r,u),u=null,r.thisProgram&&(l=r.thisProgram),r.quit&&(d=r.quit),r.wasmBinary&&(y=r.wasmBinary);var v=r.noExitRuntime||!0;"object"!=typeof WebAssembly&&U("no native wasm support detected");var b,x,S,_,C,E,I,A,O,T=!1;function R(){var e=b.buffer;r.HEAP8=_=new Int8Array(e),r.HEAP16=new Int16Array(e),r.HEAP32=E=new Int32Array(e),r.HEAPU8=C=new Uint8Array(e),r.HEAPU16=new Uint16Array(e),r.HEAPU32=I=new Uint32Array(e),r.HEAPF32=A=new Float32Array(e),r.HEAPF64=O=new Float64Array(e)}var k=[],B=[],M=[];function D(){var e=r.preRun.shift();k.unshift(e)}var P,z=0,W=null,G=null;function U(e){throw r.onAbort&&r.onAbort(e),$(e="Aborted("+e+")"),T=!0,S=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function V(e){return e.startsWith("data:application/octet-stream;base64,")}if(!V(P="ort-wasm-simd.wasm")){var j=P;P=r.locateFile?r.locateFile(j,h):h+j}function F(e){if(e==P&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function H(e,t,n){return function(e){if(!y&&(c||p)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>F(e)));if(o)return new Promise(((t,n)=>{o(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>F(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{$("failed to asynchronously prepare wasm: "+e),U(e)}))}var L,q={913792:e=>{r.ra("Abs",e,void 0)},913843:e=>{r.ra("Neg",e,void 0)},913894:e=>{r.ra("Floor",e,void 0)},913947:e=>{r.ra("Ceil",e,void 0)},913999:e=>{r.ra("Reciprocal",e,void 0)},914057:e=>{r.ra("Sqrt",e,void 0)},914109:e=>{r.ra("Exp",e,void 0)},914160:e=>{r.ra("Erf",e,void 0)},914211:e=>{r.ra("Sigmoid",e,void 0)},914266:e=>{r.ra("Log",e,void 0)},914317:e=>{r.ra("Sin",e,void 0)},914368:e=>{r.ra("Cos",e,void 0)},914419:e=>{r.ra("Tan",e,void 0)},914470:e=>{r.ra("Asin",e,void 0)},914522:e=>{r.ra("Acos",e,void 0)},914574:e=>{r.ra("Atan",e,void 0)},914626:e=>{r.ra("Sinh",e,void 0)},914678:e=>{r.ra("Cosh",e,void 0)},914730:e=>{r.ra("Asinh",e,void 0)},914783:e=>{r.ra("Acosh",e,void 0)},914836:e=>{r.ra("Atanh",e,void 0)},914889:e=>{r.ra("Tanh",e,void 0)},914941:e=>{r.ra("Not",e,void 0)},914992:(e,t,n)=>{r.ra("ClipV10",e,{min:t,max:n})},915064:e=>{r.ra("Clip",e,void 0)},915116:(e,t)=>{r.ra("Elu",e,{alpha:t})},915174:e=>{r.ra("Relu",e,void 0)},915226:(e,t)=>{r.ra("LeakyRelu",e,{alpha:t})},915290:(e,t)=>{r.ra("ThresholdedRelu",e,{alpha:t})},915360:(e,t)=>{r.ra("Cast",e,{to:t})},915418:e=>{r.ra("Add",e,void 0)},915469:e=>{r.ra("Sub",e,void 0)},915520:e=>{r.ra("Mul",e,void 0)},915571:e=>{r.ra("Div",e,void 0)},915622:e=>{r.ra("Pow",e,void 0)},915673:e=>{r.ra("Equal",e,void 0)},915726:e=>{r.ra("Greater",e,void 0)},915781:e=>{r.ra("GreaterOrEqual",e,void 0)},915843:e=>{r.ra("Less",e,void 0)},915895:e=>{r.ra("LessOrEqual",e,void 0)},915954:(e,t,n,a,i)=>{r.ra("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916118:(e,t,n,a,i)=>{r.ra("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916281:(e,t,n,a,i)=>{r.ra("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916444:(e,t,n,a,i)=>{r.ra("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916608:(e,t,n,a,i)=>{r.ra("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916771:(e,t,n,a,i)=>{r.ra("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},916933:(e,t,n,a,i)=>{r.ra("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917095:(e,t,n,a,i)=>{r.ra("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917261:(e,t,n,a,i)=>{r.ra("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917430:(e,t,n,a,i)=>{r.ra("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},917599:e=>{r.ra("Where",e,void 0)},917652:(e,t,n)=>{r.ra("Transpose",e,{perm:t?Array.from(E.subarray(n>>>0,n+t>>>0)):[]})},917765:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m)=>{r.ra("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[d>>>0],outputPadding:c?Array.from(E.subarray(p>>>0,p+c>>>0)):[],outputShape:f?Array.from(E.subarray(h>>>0,h+f>>>0)):[],activation:ee(m)})},918179:(e,t,n,a,i,o,s,u,l,d,c,p,f,h)=>{r.ra("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(E.subarray(n>>>0,n+2>>>0)),group:a,kernelShape:Array.from(E.subarray(i>>>0,i+2>>>0)),pads:Array.from(E.subarray(o>>>0,o+4>>>0)),strides:Array.from(E.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<d?Array.from(E.subarray(c>>>0,c+d>>>0)):[],outputShape:0<p?Array.from(E.subarray(f>>>0,f+p>>>0)):[],activation:ee(h)})},918736:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m)=>{r.ra("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[d>>>0],outputPadding:c?Array.from(E.subarray(p>>>0,p+c>>>0)):[],outputShape:f?Array.from(E.subarray(h>>>0,h+f>>>0)):[],activation:ee(m)})},919150:(e,t,n,a,i,o,s,u,l,d,c,p,f,h)=>{r.ra("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(E.subarray(n>>>0,n+2>>>0)),group:a,kernelShape:Array.from(E.subarray(i>>>0,i+2>>>0)),pads:Array.from(E.subarray(o>>>0,o+4>>>0)),strides:Array.from(E.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<d?Array.from(E.subarray(c>>>0,c+d>>>0)):[],outputShape:0<p?Array.from(E.subarray(f>>>0,f+p>>>0)):[],activation:ee(h)})},919707:(e,t)=>{r.ra("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},919798:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920082:(e,t)=>{r.ra("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},920173:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920457:(e,t)=>{r.ra("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},920544:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},920824:(e,t)=>{r.ra("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},920911:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,c,p,f],strides:[h,m]})},921191:(e,t,n,a,i)=>{r.ra("Gemm",e,{alpha:t,beta:n,transA:a,transB:i})},921295:e=>{r.ra("MatMul",e,void 0)},921349:(e,t,n,a)=>{r.ra("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},921457:(e,t,n,a)=>{r.ra("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},921565:(e,t)=>{r.ra("Softmax",e,{axis:t})},921628:(e,t)=>{r.ra("Concat",e,{axis:t})},921688:(e,t,n,a,i)=>{r.ra("Split",e,{axis:t,numOutputs:n,splitSizes:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},921833:e=>{r.ra("Expand",e,void 0)},921887:(e,t)=>{r.ra("Gather",e,{axis:Number(t)})},921958:(e,t)=>{r.ra("GatherElements",e,{axis:Number(t)})},922037:(e,t,n,a,i,o,s,u,l,d,c)=>{r.ra("Resize",e,{antialias:t,axes:n?Array.from(E.subarray(a>>>0,a+n>>>0)):[],coordinateTransformMode:ee(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:ee(l),mode:ee(d),nearestMode:ee(c)})},922388:(e,t,n,a,i,o,s)=>{r.ra("Slice",e,{starts:t?Array.from(E.subarray(n>>>0,n+t>>>0)):[],ends:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[],axes:o?Array.from(E.subarray(s>>>0,s+o>>>0)):[]})},922619:e=>{r.ra("Tile",e,void 0)},922671:(e,t,n)=>{r.ra("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},922778:(e,t,n)=>{r.ra("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},922892:(e,t,n)=>{r.ra("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},923006:e=>{r.ra("Range",e,void 0)},923059:(e,t)=>{r.ra("Einsum",e,{equation:ee(t)})},923140:(e,t,n,a,i)=>{r.ra("Pad",e,{mode:t,value:n,pads:a?Array.from(E.subarray(i>>>0,i+a>>>0)):[]})},923272:e=>{r.ra("Gelu",e,void 0)},923324:e=>{r.ra("BiasAdd",e,void 0)},923379:e=>{r.ra("BiasSplitGelu",e,void 0)},923440:(e,t)=>{r.ra("SkipLayerNormalization",e,{epsilon:t})},923521:(e,t,n,a,i,o,s,u,l,d,c,p,f)=>{r.ra("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:a,kernel_shape:[i],pads:o?Array.from(E.subarray(s>>>0,s+o>>>0)):[],strides:[u],w_is_const:()=>!!_[d>>>0],activation:ee(c),activation_params:p?Array.from(A.subarray(f>>>0,f+p>>>0)):[]})},923902:(e,t,n,a,i,o,s,u,l,d,c,p,f,h,m,g)=>{r.ra("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:t,dilations:[n,a],group:i,kernel_shape:[o,s],pads:u?Array.from(E.subarray(l>>>0,l+u>>>0)):[],strides:[d,c],w_is_const:()=>!!_[f>>>0],activation:ee(h),activation_params:m?Array.from(A.subarray(g>>>0,g+m>>>0)):[]})},924304:e=>{r.Ra(e)},924338:(e,t)=>r.Sa(e,t,r.Da.Ta,r.Da.errors),924450:e=>r.Oa(e),924483:e=>r.Qa(e),924515:(e,t,n)=>{r.Ja(e,t,n,!0)},924554:(e,t,n)=>{r.Ja(e,t,n)}};function Y(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var K=e=>{for(;0<e.length;)e.shift()(r)};function X(e){this.Ha=e-24,this.Ma=function(e){I[this.Ha+4>>2>>>0]=e},this.La=function(e){I[this.Ha+8>>2>>>0]=e},this.Ya=function(e,t){this.Ka(),this.Ma(e),this.La(t)},this.Ka=function(){I[this.Ha+16>>2>>>0]=0}}var J,Q=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Z=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Q)return Q.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},ee=(e,t)=>(e>>>=0)?Z(C,e,t):"",te=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},ne=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},re=e=>e%4==0&&(e%100!=0||e%400==0),ie=[0,31,60,91,121,152,182,213,244,274,305,335],ue=[0,31,59,90,120,151,181,212,243,273,304,334],de=e=>{var t=te(e)+1,n=Re(t);return n&&ne(e,C,n,t),n},ce=[],pe=(e,t)=>{var n;for(ce.length=0,t>>=2;n=C[e++>>>0];)t+=105!=n&t,ce.push(105==n?E[t>>>0]:O[t++>>>1]),++t;return ce},fe={},he=()=>{if(!J){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"};for(e in fe)void 0===fe[e]?delete t[e]:t[e]=fe[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);J=n}return J},me=[null,[],[]],ge=[31,29,31,30,31,30,31,31,30,31,30,31],ye=[31,28,31,30,31,30,31,31,30,31,30,31];function we(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return a(e,t,"0")}function o(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.Ba;for(e=new Date(new Date(e.Ca+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(re(e.getFullYear())?ge:ye)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=o(t,e)?0>=o(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0;var l=E[40+(r>>>=0)>>2>>>0];for(var d in r={Wa:E[r>>2>>>0],Va:E[r+4>>2>>>0],Ea:E[r+8>>2>>>0],Ia:E[r+12>>2>>>0],Fa:E[r+16>>2>>>0],Ca:E[r+20>>2>>>0],wa:E[r+24>>2>>>0],Ba:E[r+28>>2>>>0],$a:E[r+32>>2>>>0],Ua:E[r+36>>2>>>0],Xa:l?ee(l):""},n=ee(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(d,"g"),l[d]);var c="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(d in l={"%a":e=>c[e.wa].substring(0,3),"%A":e=>c[e.wa],"%b":e=>p[e.Fa].substring(0,3),"%B":e=>p[e.Fa],"%C":e=>i((e.Ca+1900)/100|0,2),"%d":e=>i(e.Ia,2),"%e":e=>a(e.Ia,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>i(e.Ea,2),"%I":e=>(0==(e=e.Ea)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Fa-1;t+=(re(e.Ca+1900)?ge:ye)[n++]);return i(e.Ia+t,3)},"%m":e=>i(e.Fa+1,2),"%M":e=>i(e.Va,2),"%n":()=>"\n","%p":e=>0<=e.Ea&&12>e.Ea?"AM":"PM","%S":e=>i(e.Wa,2),"%t":()=>"\t","%u":e=>e.wa||7,"%U":e=>i(Math.floor((e.Ba+7-e.wa)/7),2),"%V":e=>{var t=Math.floor((e.Ba+7-(e.wa+6)%7)/7);if(2>=(e.wa+371-e.Ba-2)%7&&t++,t)53==t&&(4==(n=(e.wa+371-e.Ba)%7)||3==n&&re(e.Ca)||(t=1));else{t=52;var n=(e.wa+7-e.Ba-1)%7;(4==n||5==n&&re(e.Ca%400-1))&&t++}return i(t,2)},"%w":e=>e.wa,"%W":e=>i(Math.floor((e.Ba+7-(e.wa+6)%7)/7),2),"%y":e=>(e.Ca+1900).toString().substring(2),"%Y":e=>e.Ca+1900,"%z":e=>(0<=(e=e.Ua)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.Xa,"%%":()=>"%"},n=n.replace(/%%/g,"\0\0"),l)n.includes(d)&&(n=n.replace(new RegExp(d,"g"),l[d](r)));return d=function(e){var t=Array(te(e)+1);return ne(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),d.length>t?0:(_.set(d,e>>>0),d.length-1)}function $e(e){try{e()}catch(e){U(e)}}var ve=0,be=null,xe=0,Se=[],_e={},Ce={},Ee=0,Ie=null,Ae=[];var Oe={n:function(e,t,n){return function(e){return function(e){if(!T){if(0===ve){var t=!1,n=!1;e(((e=0)=>{if(!T&&(xe=e,t=!0,n)){ve=2,$e((()=>Ne(be))),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),e=!1;try{var r=(0,x[Ce[E[be+8>>2>>>0]]])()}catch(t){r=t,e=!0}var a=!1;if(!be){var i=Ie;i&&(Ie=null,(e?i.reject:i.resolve)(r),a=!0)}if(e&&!a)throw r}})),n=!0,t||(ve=1,be=function(){var e=Re(65548),t=e+12;I[e>>2>>>0]=t,I[e+4>>2>>>0]=t+65536,t=Se[0];var n=_e[t];return void 0===n&&(n=Ee++,_e[t]=n,Ce[n]=t),E[e+8>>2>>>0]=n,e}(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),$e((()=>ze(be))))}else 2===ve?(ve=0,$e(Ge),ke(be),be=null,Ae.forEach((e=>{if(!T)try{if(e(),!v)try{S=S=e=S,v||(r.onExit&&r.onExit(e),T=!0),d(e,new Y(e))}catch(e){e instanceof Y||"unwind"==e||d(1,e)}}catch(e){e instanceof Y||"unwind"==e||d(1,e)}}))):U(`invalid state: ${ve}`);return xe}}((t=>{e().then(t)}))}((async()=>{await r.Pa(e,t,n)}))},a:function(e,t,n){throw new X(e>>>=0).Ya(t>>>0,n>>>0),e},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),E[n>>2>>>0]=e.getUTCSeconds(),E[n+4>>2>>>0]=e.getUTCMinutes(),E[n+8>>2>>>0]=e.getUTCHours(),E[n+12>>2>>>0]=e.getUTCDate(),E[n+16>>2>>>0]=e.getUTCMonth(),E[n+20>>2>>>0]=e.getUTCFullYear()-1900,E[n+24>>2>>>0]=e.getUTCDay(),E[n+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),E[n>>2>>>0]=e.getSeconds(),E[n+4>>2>>>0]=e.getMinutes(),E[n+8>>2>>>0]=e.getHours(),E[n+12>>2>>>0]=e.getDate(),E[n+16>>2>>>0]=e.getMonth(),E[n+20>>2>>>0]=e.getFullYear()-1900,E[n+24>>2>>>0]=e.getDay(),E[n+28>>2>>>0]=(re(e.getFullYear())?ie:ue)[e.getMonth()]+e.getDate()-1|0,E[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();E[n+32>>2>>>0]=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t))},s:function(e){e>>>=0;var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,a);return 0>n?E[e+32>>2>>>0]=+(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(re(t.getFullYear())?ie:ue)[t.getMonth()]+t.getDate()-1|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Be((L=e,1<=+Math.abs(L)?0<L?+Math.floor(L/4294967296)>>>0:~~+Math.ceil((L-+(~~L>>>0))/4294967296)>>>0:0)),e>>>0},o:function(){return-52},p:function(){},v:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}n>>>=0;var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var s=o.getTimezoneOffset();I[e>>>0>>2>>>0]=60*Math.max(a,s),E[t>>>0>>2>>>0]=+(a!=s),e=r(i),t=r(o),e=de(e),t=de(t),s<a?(I[n>>2>>>0]=e,I[n+4>>2>>>0]=t):(I[n>>2>>>0]=t,I[n+4>>2>>>0]=e)},e:()=>{U("")},b:function(e,t,n){return e>>>=0,t=pe(t>>>0,n>>>0),q[e].apply(null,t)},i:function(e,t,n){return e>>>=0,t=pe(t>>>0,n>>>0),q[e].apply(null,t)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(e,t,n){return t>>>=0,C.copyWithin(e>>>0>>>0,t>>>0,t+(n>>>0)>>>0)},u:function(e){e>>>=0;var t=C.length;if(4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r);e:{a=a.min.call(a,4294901760,r+(65536-r%65536)%65536)-b.buffer.byteLength+65535>>>16;try{b.grow(a),R();var i=1;break e}catch{}i=void 0}if(i)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var n=0;return he().forEach((function(r,a){var i=t+n;for(a=I[e+4*a>>2>>>0]=i,i=0;i<r.length;++i)_[a++>>0>>>0]=r.charCodeAt(i);_[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var n=he();I[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),I[t>>2>>>0]=r,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(e,t,n,r){t>>>=0,n>>>=0,r>>>=0;for(var a=0,i=0;i<n;i++){var o=I[t>>2>>>0],s=I[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=C[o+u>>>0],d=me[e];0===l||10===l?((1===e?w:$)(Z(d,0)),d.length=0):d.push(l)}a+=s}return I[r>>2>>>0]=a,0},F:we,d:function(e,t,n,r){return we(e>>>0,t>>>0,n>>>0,r>>>0)}};(function(){function e(e){if(e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){Se.push(t);try{return r.apply(null,arguments)}finally{T||(Se.pop()===t||U(),be&&1===ve&&0===Se.length&&(ve=0,$e(We),typeof Fibers<"u"&&Fibers.ab()))}}:r}(t);return n}(e=e.exports),x=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),b=x.M,R(),B.unshift(x.N),z--,r.monitorRunDependencies&&r.monitorRunDependencies(z),0==z&&(null!==W&&(clearInterval(W),W=null),G)){var t=G;G=null,t()}return e}var t={a:Oe};if(z++,r.monitorRunDependencies&&r.monitorRunDependencies(z),r.instantiateWasm)try{return r.instantiateWasm(t,e)}catch(e){$("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var n=P;return y||"function"!=typeof WebAssembly.instantiateStreaming||V(n)||n.startsWith("file://")||f||"function"!=typeof fetch?H(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return $("wasm streaming compile failed: "+r),$("falling back to ArrayBuffer instantiation"),H(n,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)})(),r._OrtInit=(e,t)=>(r._OrtInit=x.O)(e,t),r._OrtGetLastError=(e,t)=>(r._OrtGetLastError=x.P)(e,t),r._OrtCreateSessionOptions=(e,t,n,a,i,o,s,u,l,d)=>(r._OrtCreateSessionOptions=x.Q)(e,t,n,a,i,o,s,u,l,d),r._OrtAppendExecutionProvider=(e,t)=>(r._OrtAppendExecutionProvider=x.R)(e,t),r._OrtAddFreeDimensionOverride=(e,t,n)=>(r._OrtAddFreeDimensionOverride=x.S)(e,t,n),r._OrtAddSessionConfigEntry=(e,t,n)=>(r._OrtAddSessionConfigEntry=x.T)(e,t,n),r._OrtReleaseSessionOptions=e=>(r._OrtReleaseSessionOptions=x.U)(e),r._OrtCreateSession=(e,t,n)=>(r._OrtCreateSession=x.V)(e,t,n),r._OrtReleaseSession=e=>(r._OrtReleaseSession=x.W)(e),r._OrtGetInputOutputCount=(e,t,n)=>(r._OrtGetInputOutputCount=x.X)(e,t,n),r._OrtGetInputName=(e,t)=>(r._OrtGetInputName=x.Y)(e,t),r._OrtGetOutputName=(e,t)=>(r._OrtGetOutputName=x.Z)(e,t),r._OrtFree=e=>(r._OrtFree=x._)(e),r._OrtCreateTensor=(e,t,n,a,i,o)=>(r._OrtCreateTensor=x.$)(e,t,n,a,i,o),r._OrtGetTensorData=(e,t,n,a,i)=>(r._OrtGetTensorData=x.aa)(e,t,n,a,i),r._OrtReleaseTensor=e=>(r._OrtReleaseTensor=x.ba)(e),r._OrtCreateRunOptions=(e,t,n,a)=>(r._OrtCreateRunOptions=x.ca)(e,t,n,a),r._OrtAddRunConfigEntry=(e,t,n)=>(r._OrtAddRunConfigEntry=x.da)(e,t,n),r._OrtReleaseRunOptions=e=>(r._OrtReleaseRunOptions=x.ea)(e),r._OrtCreateBinding=e=>(r._OrtCreateBinding=x.fa)(e),r._OrtBindInput=(e,t,n)=>(r._OrtBindInput=x.ga)(e,t,n),r._OrtBindOutput=(e,t,n,a)=>(r._OrtBindOutput=x.ha)(e,t,n,a),r._OrtClearBoundOutputs=e=>(r._OrtClearBoundOutputs=x.ia)(e),r._OrtReleaseBinding=e=>(r._OrtReleaseBinding=x.ja)(e),r._OrtRunWithBinding=(e,t,n,a,i)=>(r._OrtRunWithBinding=x.ka)(e,t,n,a,i),r._OrtRun=(e,t,n,a,i,o,s,u)=>(r._OrtRun=x.la)(e,t,n,a,i,o,s,u),r._OrtEndProfiling=e=>(r._OrtEndProfiling=x.ma)(e),r._JsepOutput=(e,t,n)=>(r._JsepOutput=x.na)(e,t,n),r._JsepGetNodeName=e=>(r._JsepGetNodeName=x.oa)(e);var Te,Re=r._malloc=e=>(Re=r._malloc=x.pa)(e),ke=r._free=e=>(ke=r._free=x.qa)(e),Be=e=>(Be=x.sa)(e),Me=()=>(Me=x.ta)(),De=e=>(De=x.ua)(e),Pe=e=>(Pe=x.va)(e),ze=e=>(ze=x.xa)(e),We=()=>(We=x.ya)(),Ne=e=>(Ne=x.za)(e),Ge=()=>(Ge=x.Aa)();function Ue(){function e(){if(!Te&&(Te=!0,r.calledRun=!0,!T)){if(K(B),t(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for("function"==typeof r.postRun&&(r.postRun=[r.postRun]);r.postRun.length;){var e=r.postRun.shift();M.unshift(e)}K(M)}}if(!(0<z)){if(r.preRun)for("function"==typeof r.preRun&&(r.preRun=[r.preRun]);r.preRun.length;)D();K(k),0<z||(r.setStatus?(r.setStatus("Running..."),setTimeout((function(){setTimeout((function(){r.setStatus("")}),1),e()}),1)):e())}}if(r.___start_em_js=924587,r.___stop_em_js=924748,r.stackAlloc=Pe,r.stackSave=Me,r.stackRestore=De,r.UTF8ToString=ee,r.stringToUTF8=(e,t,n)=>ne(e,C,t,n),r.lengthBytesUTF8=te,G=function e(){Te||Ue(),Te||(G=e)},r.preInit)for("function"==typeof r.preInit&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Ue(),e.ready});"object"==typeof n&&"object"==typeof a?a.exports=o:void 0===(r=(()=>o).apply(t,[]))||(e.exports=r)})),ce=z((()=>{})),pe=z((()=>{})),fe={};W(fe,{cpus:()=>he});var he,me,ge,ye,we,$e,ve,be,xe,Se,_e,Ce,Ee,Ie,Ae,Oe,Te,Re,ke,Be,Me,De,Pe,ze,We,Ne,Ge,Ue,Ve,je,Fe,He,Le,qe,Ye,Ke,Xe,Je,Qe,Ze,et,tt,nt,rt,at,it,ot,st,ut,lt,dt,ct,pt,ft,ht,mt,gt,yt,wt,$t,vt,bt,xt,St,_t,Ct,Et,It,At,Ot,Tt,Rt,kt,Bt,Mt,Dt,Pt,zt,Wt,Nt,Gt,Ut,Vt,jt,Ft,Ht,Lt,qt,Yt,Kt,Xt,Jt,Qt,Zt,en,tn,nn,rn,an,on,sn,un,ln,dn,cn,pn,fn,hn,mn,gn,yn,wn,$n,vn,bn,xn,Sn,_n,Cn,En,In,An,On,Tn,Rn,kn,Bn,Mn,Dn,Pn,zn,Wn,Nn,Gn,Un,Vn,jn,Fn,Hn,Ln,qn,Yn,Kn,Xn,Jn,Qn,Zn,er,tr,nr,rr,ar,ir,or,sr,ur,lr,dr,cr,pr,fr,hr,mr,gr,yr,wr,$r,vr,br,xr,Sr,_r,Cr,Er,Ir,Ar,Or,Tr,Rr,kr,Br,Mr,Dr,Pr,zr,Wr,Nr,Gr,Ur,Vr,jr,Fr,Hr,Lr,qr,Yr,Kr,Xr,Jr,Qr,Zr,ea,ta,na,ra,aa,ia,oa,sa,ua,la,da,ca,pa,fa,ha,ma,ga,ya,wa,$a,va,ba,xa,Sa,_a,Ca,Ea,Ia,Aa,Oa,Ta,Ra,ka,Ba,Ma,Da,Pa,za,Wa,Na,Ga,Ua,Va,ja,Fa,Ha,La,qa,Ya,Ka,Xa,Ja,Qa,Za,ei,ti,ni,ri,ai,ii,oi,si,ui,li,di,ci,pi,fi,hi,mi,gi,yi,wi,$i,vi,bi,xi,Si,_i,Ci,Ei,Ii,Ai,Oi,Ti,Ri,ki,Bi,Mi,Di,Pi,zi,Wi,Ni,Gi,Ui,Vi,ji,Fi,Hi,Li,qi,Yi,Ki,Xi,Ji,Qi,Zi,eo,to,no,ro,ao,io,oo,so,uo,lo,co,po,fo,ho,mo,go,yo,wo,$o,vo,bo,xo,So,_o,Co,Eo,Io,Ao,Oo,To,Ro,ko,Bo,Mo,Do,Po,zo,Wo,No=P((()=>{he=void 0})),Go=z(((a,i)=>{var o,s=(o=(o=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||R,function(e={}){function t(){return k.buffer!=P.buffer&&F(),P}function r(){return k.buffer!=P.buffer&&F(),z}function a(){return k.buffer!=P.buffer&&F(),W}function i(){return k.buffer!=P.buffer&&F(),G}function s(){return k.buffer!=P.buffer&&F(),U}function u(){return k.buffer!=P.buffer&&F(),V}var l,d,c=e;c.ready=new Promise(((e,t)=>{l=e,d=t})),c.jsepInit=(e,t,n,r,a,i,o,s)=>{c.Qb=e,c.wb=t,c.yb=n,c.jb=r,c.xb=a,c.Ea=i,c.zb=o,c.Ab=s,t=(e,t,n)=>(...r)=>{let a=xt,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),xt!=a?new Promise(((e,t)=>{At={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(c.bb)throw Error("Session already started");let r=c.bb={Fb:n[0],errors:[]},a=await t(...n);if(c.bb!==r)throw Error("Session mismatch");e.flush();let i=r.errors;if(0<i.length){let e=await Promise.all(i);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return a}finally{c.bb=null}},c._OrtRun=n(t(c._OrtRun,(()=>c._OrtRun),(e=>c._OrtRun=e))),c._OrtRunWithBinding=n(t(c._OrtRunWithBinding,(()=>c._OrtRunWithBinding),(e=>c._OrtRunWithBinding=e))),c._OrtBindInput=t(c._OrtBindInput,(()=>c._OrtBindInput),(e=>c._OrtBindInput=e)),c.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),c.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},c.jsepGetBuffer=t=>e.getBuffer(t),c.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r)};var p,f,h,m=Object.assign({},c),g="./this.program",y=(e,t)=>{throw t},w="object"==typeof window,$="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,x="";function S(e){return c.locateFile?c.locateFile(e,x):x+e}if(v){var _=(oe(),N(ae)),C=(le(),N(se));let e;x=$?C.dirname(x)+"/":"//",p=(e,t)=>(e=e.startsWith("file://")?new URL(e):C.normalize(e),_.readFileSync(e,t?void 0:"utf8")),h=e=>((e=p(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):C.normalize(e),_.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),y=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{e=ce()}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=e.Worker}else(w||$)&&($?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),typeof o<"u"&&o&&(x=o),x=0!==x.indexOf("blob:")?x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},$&&(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));v&&typeof performance>"u"&&(n.g.performance=pe().performance);var E=console.log.bind(console),I=console.error.bind(console);v&&(E=(...e)=>_.writeSync(1,e.join(" ")+"\n"),I=(...e)=>_.writeSync(2,e.join(" ")+"\n"));var A,O=c.print||E,T=c.printErr||I;Object.assign(c,m),m=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(y=c.quit),c.wasmBinary&&(A=c.wasmBinary);var R=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&re("no native wasm support detected");var k,B,M,D,P,z,W,G,U,V,j=!1;function F(){var e=k.buffer;c.HEAP8=P=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=W=new Int32Array(e),c.HEAPU8=z=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=G=new Uint32Array(e),c.HEAPF32=U=new Float32Array(e),c.HEAPF64=V=new Float64Array(e)}var H=c.INITIAL_MEMORY||16777216;if(5242880<=H||re("INITIAL_MEMORY should be larger than STACK_SIZE, was "+H+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:H/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw T("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&T("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");F(),H=k.buffer.byteLength;var L=[],q=[],Y=[],K=0;function X(){return R||0<K}var J,Q=0,Z=null,ee=null;function te(){Q++,c.monitorRunDependencies&&c.monitorRunDependencies(Q)}function ne(){if(Q--,c.monitorRunDependencies&&c.monitorRunDependencies(Q),0==Q&&(null!==Z&&(clearInterval(Z),Z=null),ee)){var e=ee;ee=null,e()}}function re(e){throw c.onAbort&&c.onAbort(e),T(e="Aborted("+e+")"),j=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),d(e),e}function ie(e){return e.startsWith("data:application/octet-stream;base64,")}function ue(e){if(e==J&&A)return new Uint8Array(A);if(h)return h(e);throw"both async and sync fetching of the wasm failed"}function de(e,t,n){return function(e){if(!A&&(w||$)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>ue(e)));if(f)return new Promise(((t,n)=>{f(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>ue(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{T("failed to asynchronously prepare wasm: "+e),re(e)}))}ie(J="ort-wasm-simd-threaded.wasm")||(J=S(J));var he,me={914988:e=>{c.Ea("Abs",e,void 0)},915039:e=>{c.Ea("Neg",e,void 0)},915090:e=>{c.Ea("Floor",e,void 0)},915143:e=>{c.Ea("Ceil",e,void 0)},915195:e=>{c.Ea("Reciprocal",e,void 0)},915253:e=>{c.Ea("Sqrt",e,void 0)},915305:e=>{c.Ea("Exp",e,void 0)},915356:e=>{c.Ea("Erf",e,void 0)},915407:e=>{c.Ea("Sigmoid",e,void 0)},915462:e=>{c.Ea("Log",e,void 0)},915513:e=>{c.Ea("Sin",e,void 0)},915564:e=>{c.Ea("Cos",e,void 0)},915615:e=>{c.Ea("Tan",e,void 0)},915666:e=>{c.Ea("Asin",e,void 0)},915718:e=>{c.Ea("Acos",e,void 0)},915770:e=>{c.Ea("Atan",e,void 0)},915822:e=>{c.Ea("Sinh",e,void 0)},915874:e=>{c.Ea("Cosh",e,void 0)},915926:e=>{c.Ea("Asinh",e,void 0)},915979:e=>{c.Ea("Acosh",e,void 0)},916032:e=>{c.Ea("Atanh",e,void 0)},916085:e=>{c.Ea("Tanh",e,void 0)},916137:e=>{c.Ea("Not",e,void 0)},916188:(e,t,n)=>{c.Ea("ClipV10",e,{min:t,max:n})},916260:e=>{c.Ea("Clip",e,void 0)},916312:(e,t)=>{c.Ea("Elu",e,{alpha:t})},916370:e=>{c.Ea("Relu",e,void 0)},916422:(e,t)=>{c.Ea("LeakyRelu",e,{alpha:t})},916486:(e,t)=>{c.Ea("ThresholdedRelu",e,{alpha:t})},916556:(e,t)=>{c.Ea("Cast",e,{to:t})},916614:e=>{c.Ea("Add",e,void 0)},916665:e=>{c.Ea("Sub",e,void 0)},916716:e=>{c.Ea("Mul",e,void 0)},916767:e=>{c.Ea("Div",e,void 0)},916818:e=>{c.Ea("Pow",e,void 0)},916869:e=>{c.Ea("Equal",e,void 0)},916922:e=>{c.Ea("Greater",e,void 0)},916977:e=>{c.Ea("GreaterOrEqual",e,void 0)},917039:e=>{c.Ea("Less",e,void 0)},917091:e=>{c.Ea("LessOrEqual",e,void 0)},917150:(e,t,n,r,i)=>{c.Ea("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917314:(e,t,n,r,i)=>{c.Ea("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917477:(e,t,n,r,i)=>{c.Ea("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917640:(e,t,n,r,i)=>{c.Ea("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917804:(e,t,n,r,i)=>{c.Ea("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},917967:(e,t,n,r,i)=>{c.Ea("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918129:(e,t,n,r,i)=>{c.Ea("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918291:(e,t,n,r,i)=>{c.Ea("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918457:(e,t,n,r,i)=>{c.Ea("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918626:(e,t,n,r,i)=>{c.Ea("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},918795:e=>{c.Ea("Where",e,void 0)},918848:(e,t,n)=>{c.Ea("Transpose",e,{perm:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[]})},918961:(e,n,r,i,o,s,u,l,d,p,f,h,m,g,y)=>{c.Ea("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:m?Array.from(a().subarray(g>>>0,g+m>>>0)):[],activation:xe(y)})},919375:(e,n,r,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(m>>>0,m+h>>>0)):[],activation:xe(g)})},919932:(e,n,r,i,o,s,u,l,d,p,f,h,m,g,y)=>{c.Ea("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:m?Array.from(a().subarray(g>>>0,g+m>>>0)):[],activation:xe(y)})},920346:(e,n,r,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(m>>>0,m+h>>>0)):[],activation:xe(g)})},920903:(e,t)=>{c.Ea("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},920994:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},921278:(e,t)=>{c.Ea("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},921369:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},921653:(e,t)=>{c.Ea("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},921740:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},922020:(e,t)=>{c.Ea("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},922107:(e,t,n,r,a,i,o,s,u,l,d,p,f,h,m,g)=>{c.Ea("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,f],strides:[h,m]})},922387:(e,t,n,r,a)=>{c.Ea("Gemm",e,{alpha:t,beta:n,transA:r,transB:a})},922491:e=>{c.Ea("MatMul",e,void 0)},922545:(e,t,n,r)=>{c.Ea("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},922653:(e,t,n,r)=>{c.Ea("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},922761:(e,t)=>{c.Ea("Softmax",e,{axis:t})},922824:(e,t)=>{c.Ea("Concat",e,{axis:t})},922884:(e,t,n,r,i)=>{c.Ea("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},923029:e=>{c.Ea("Expand",e,void 0)},923083:(e,t)=>{c.Ea("Gather",e,{axis:Number(t)})},923154:(e,t)=>{c.Ea("GatherElements",e,{axis:Number(t)})},923233:(e,t,n,r,i,o,s,u,l,d,p)=>{c.Ea("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(r>>>0,r+n>>>0)):[],coordinateTransformMode:xe(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:xe(l),mode:xe(d),nearestMode:xe(p)})},923584:(e,t,n,r,i,o,s)=>{c.Ea("Slice",e,{starts:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[],ends:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[],axes:o?Array.from(a().subarray(s>>>0,s+o>>>0)):[]})},923815:e=>{c.Ea("Tile",e,void 0)},923867:(e,t,n)=>{c.Ea("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},923974:(e,t,n)=>{c.Ea("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},924088:(e,t,n)=>{c.Ea("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},924202:e=>{c.Ea("Range",e,void 0)},924255:(e,t)=>{c.Ea("Einsum",e,{equation:xe(t)})},924336:(e,t,n,r,i)=>{c.Ea("Pad",e,{mode:t,value:n,pads:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},924468:e=>{c.Ea("Gelu",e,void 0)},924520:e=>{c.Ea("BiasAdd",e,void 0)},924575:e=>{c.Ea("BiasSplitGelu",e,void 0)},924636:(e,t)=>{c.Ea("SkipLayerNormalization",e,{epsilon:t})},924717:(e,n,r,i,o,u,l,d,p,f,h,m,g)=>{c.Ea("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:i,kernel_shape:[o],pads:u?Array.from(a().subarray(l>>>0,l+u>>>0)):[],strides:[d],w_is_const:()=>!!t()[f>>>0],activation:xe(h),activation_params:m?Array.from(s().subarray(g>>>0,g+m>>>0)):[]})},925098:(e,n,r,i,o,u,l,d,p,f,h,m,g,y,w,$)=>{c.Ea("Conv",e,{format:m?"NHWC":"NCHW",auto_pad:n,dilations:[r,i],group:o,kernel_shape:[u,l],pads:d?Array.from(a().subarray(p>>>0,p+d>>>0)):[],strides:[f,h],w_is_const:()=>!!t()[g>>>0],activation:xe(y),activation_params:w?Array.from(s().subarray($>>>0,$+w>>>0)):[]})},925500:e=>{c.zb(e)},925534:(e,t)=>c.Ab(e,t,c.bb.Fb,c.bb.errors),925646:e=>c.wb(e),925679:e=>c.yb(e),925711:(e,t,n)=>{c.jb(e,t,n,!0)},925750:(e,t,n)=>{c.jb(e,t,n)}};function ge(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ye(e){e.terminate(),e.onmessage=()=>{}}function we(e){(e=Ce.Qa[e])||re(),Ce.Eb(e)}function $e(e){var t=Ce.tb();if(!t)return 6;Ce.Ya.push(t),Ce.Qa[e.Xa]=t,t.Xa=e.Xa;var n={cmd:"run",start_routine:e.Gb,arg:e.rb,pthread_ptr:e.Xa};return v&&t.unref(),t.postMessage(n,e.Mb),0}var ve=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,be=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&ve)return ve.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},xe=(e,t)=>(e>>>=0)?be(r(),e,t):"";function Se(e){if(b)return it(1,1,e);D=e,X()||(Ce.Hb(),c.onExit&&c.onExit(e),j=!0),y(e,new ge(e))}var _e=e=>{if(D=e,b)throw Ie(e),"unwind";Se(e)},Ce={ab:[],Ya:[],mb:[],Qa:{},gb:function(){b?Ce.vb():Ce.ub()},ub:function(){L.unshift((()=>{te(),Ce.Bb((()=>ne()))}))},vb:function(){Ce.receiveObjectTransfer=Ce.Db,Ce.threadInitTLS=Ce.lb,Ce.setExitStatus=Ce.kb,R=!1},kb:function(e){D=e},Sb:["$terminateWorker"],Hb:function(){for(var e of Ce.Ya)ye(e);for(e of Ce.ab)ye(e);Ce.ab=[],Ce.Ya=[],Ce.Qa=[]},Eb:function(e){var t=e.Xa;delete Ce.Qa[t],Ce.ab.push(e),Ce.Ya.splice(Ce.Ya.indexOf(e),1),e.Xa=0,Wt(t)},Db:function(){},lb:function(){Ce.mb.forEach((e=>e()))},Cb:e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=kt()){var a=Ce.Qa[n.Rb];a?a.postMessage(n,n.transferList):T('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"checkMailbox"===r?Ke():"spawnThread"===r?$e(n):"cleanupThread"===r?we(n.thread):"killThread"===r?(n=n.thread,r=Ce.Qa[n],delete Ce.Qa[n],ye(r),Wt(n),Ce.Ya.splice(Ce.Ya.indexOf(r),1),r.Xa=0):"cancelThread"===r?Ce.Qa[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?c[n.handler](...n.args):r&&T("worker sent an unknown command "+r)},e.onerror=e=>{throw T("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var n,r=[];for(n of["onExit","onAbort","print","printErr"])c.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,urlOrBlob:c.mainScriptUrlOrBlob||o,wasmMemory:k,wasmModule:M})})),Bb:function(e){e()},qb:function(){var e=S("ort-wasm-simd-threaded.worker.js");e=new Worker(e),Ce.ab.push(e)},tb:function(){return 0==Ce.ab.length&&(Ce.qb(),Ce.Cb(Ce.ab[0])),Ce.ab.pop()}};c.PThread=Ce;var Ee=e=>{for(;0<e.length;)e.shift()(c)};function Ie(e){if(b)return it(2,0,e);_e(e)}function Ae(e){this.fb=e-24,this.pb=function(e){i()[this.fb+4>>2>>>0]=e},this.ob=function(e){i()[this.fb+8>>2>>>0]=e},this.gb=function(e,t){this.nb(),this.pb(e),this.ob(t)},this.nb=function(){i()[this.fb+16>>2>>>0]=0}}function Oe(e,t,n,r){return b?it(3,1,e,t,n,r):Te(e,t,n,r)}function Te(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,typeof SharedArrayBuffer>"u")return T("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?Oe(e,t,n,r):(e={Gb:n,Xa:e,rb:r,Mb:a},b?(e.Ob="spawnThread",postMessage(e,a),0):$e(e))}function Re(e,t,n){return b?it(4,1,e,t,n):0}function ke(e,t){if(b)return it(5,1,e,t)}c.establishStackSpace=function(){var e=kt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],Vt(t,t-e),Ft(t)},c.invokeEntryPoint=function(e,t){e=Lt.apply(null,[e,t]),X()?Ce.kb(e):Nt(e)};var Be=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Me=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},De=(e,t,n)=>Me(e,r(),t,n);function Pe(e,t){if(b)return it(6,1,e,t)}function ze(e,t,n){if(b)return it(7,1,e,t,n)}function We(e,t,n){return b?it(8,1,e,t,n):0}function Ne(e,t){if(b)return it(9,1,e,t)}function Ge(e,t,n){if(b)return it(10,1,e,t,n)}function Ue(e,t,n,r){if(b)return it(11,1,e,t,n,r)}function Ve(e,t,n,r){if(b)return it(12,1,e,t,n,r)}function je(e,t,n,r){if(b)return it(13,1,e,t,n,r)}function Fe(e){if(b)return it(14,1,e)}function He(e,t){if(b)return it(15,1,e,t)}function Le(e,t,n){if(b)return it(16,1,e,t,n)}var qe=e=>{if(!j)try{if(e(),!X())try{b?Nt(D):_e(D)}catch(e){e instanceof ge||"unwind"==e||y(1,e)}}catch(e){e instanceof ge||"unwind"==e||y(1,e)}};function Ye(e){e>>>=0,"function"==typeof Atomics.Nb&&(Atomics.Nb(a(),e>>2,e).value.then(Ke),e+=128,Atomics.store(a(),e>>2,1))}function Ke(){var e=kt();e&&(Ye(e),qe((()=>Gt())))}c.__emscripten_thread_mailbox_await=Ye,c.checkMailbox=Ke;var Xe=e=>e%4==0&&(e%100!=0||e%400==0),Je=[0,31,60,91,121,152,182,213,244,274,305,335],Qe=[0,31,59,90,120,151,181,212,243,273,304,334];function Ze(e,t,n,r,a,i,o,s){return b?it(17,1,e,t,n,r,a,i,o,s):-52}function et(e,t,n,r,a,i,o){if(b)return it(18,1,e,t,n,r,a,i,o)}var tt=e=>{var t=Be(e)+1,n=Bt(t);return n&&De(e,n,t),n},nt=[],rt=(e,t)=>{var n;for(nt.length=0,t>>=2;n=r()[e++>>>0];)t+=105!=n&t,nt.push(105==n?a()[t>>>0]:u()[t++>>>1]),++t;return nt},at=e=>{var t=jt();return e=e(),Ft(t),e};function it(e,t){var n=arguments.length-2,r=arguments;return at((()=>{for(var a=Ht(8*n),i=a>>3,o=0;o<n;o++){var s=r[2+o];u()[i+o>>>0]=s}return zt(e,n,a,t)}))}var ot,st=[],ut={},lt=()=>{if(!ot){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in ut)void 0===ut[e]?delete t[e]:t[e]=ut[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);ot=n}return ot};function dt(e,n){if(b)return it(19,1,e,n);e>>>=0,n>>>=0;var r=0;return lt().forEach((function(a,o){var s=n+r;for(o=i()[e+4*o>>2>>>0]=s,s=0;s<a.length;++s)t()[o++>>0>>>0]=a.charCodeAt(s);t()[o>>0>>>0]=0,r+=a.length+1})),0}function ct(e,t){if(b)return it(20,1,e,t);e>>>=0,t>>>=0;var n=lt();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function pt(e){return b?it(21,1,e):52}function ft(e,t,n,r){return b?it(22,1,e,t,n,r):52}function ht(e,t,n,r,a){return b?it(23,1,e,t,n,r,a):70}var mt=[null,[],[]];function gt(e,t,n,a){if(b)return it(24,1,e,t,n,a);t>>>=0,n>>>=0,a>>>=0;for(var o=0,s=0;s<n;s++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var d=0;d<l;d++){var c=r()[u+d>>>0],p=mt[e];0===c||10===c?((1===e?O:T)(be(p,0)),p.length=0):p.push(c)}o+=l}return i()[a>>2>>>0]=o,0}var yt=[31,29,31,30,31,30,31,31,30,31,30,31],wt=[31,28,31,30,31,30,31,31,30,31,30,31];function $t(e,n,r,i){function o(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return o(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function l(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function d(e){var t=e.Za;for(e=new Date(new Date(e.$a+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?yt:wt)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=l(new Date(e.getFullYear(),0,4)),n=l(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,n>>>=0,r>>>=0,i>>>=0;var c=a()[i+40>>2>>>0];for(var p in i={Kb:a()[i>>2>>>0],Jb:a()[i+4>>2>>>0],cb:a()[i+8>>2>>>0],ib:a()[i+12>>2>>>0],eb:a()[i+16>>2>>>0],$a:a()[i+20>>2>>>0],Wa:a()[i+24>>2>>>0],Za:a()[i+28>>2>>>0],Tb:a()[i+32>>2>>>0],Ib:a()[i+36>>2>>>0],Lb:c?xe(c):""},r=xe(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),c[p]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(p in c={"%a":e=>f[e.Wa].substring(0,3),"%A":e=>f[e.Wa],"%b":e=>h[e.eb].substring(0,3),"%B":e=>h[e.eb],"%C":e=>s((e.$a+1900)/100|0,2),"%d":e=>s(e.ib,2),"%e":e=>o(e.ib,2," "),"%g":e=>d(e).toString().substring(2),"%G":e=>d(e),"%H":e=>s(e.cb,2),"%I":e=>(0==(e=e.cb)?e=12:12<e&&(e-=12),s(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.eb-1;t+=(Xe(e.$a+1900)?yt:wt)[n++]);return s(e.ib+t,3)},"%m":e=>s(e.eb+1,2),"%M":e=>s(e.Jb,2),"%n":()=>"\n","%p":e=>0<=e.cb&&12>e.cb?"AM":"PM","%S":e=>s(e.Kb,2),"%t":()=>"\t","%u":e=>e.Wa||7,"%U":e=>s(Math.floor((e.Za+7-e.Wa)/7),2),"%V":e=>{var t=Math.floor((e.Za+7-(e.Wa+6)%7)/7);if(2>=(e.Wa+371-e.Za-2)%7&&t++,t)53==t&&(4==(n=(e.Wa+371-e.Za)%7)||3==n&&Xe(e.$a)||(t=1));else{t=52;var n=(e.Wa+7-e.Za-1)%7;(4==n||5==n&&Xe(e.$a%400-1))&&t++}return s(t,2)},"%w":e=>e.Wa,"%W":e=>s(Math.floor((e.Za+7-(e.Wa+6)%7)/7),2),"%y":e=>(e.$a+1900).toString().substring(2),"%Y":e=>e.$a+1900,"%z":e=>(0<=(e=e.Ib)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.Lb,"%%":()=>"%"},r=r.replace(/%%/g,"\0\0"),c)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),c[p](i)));return p=function(e){var t=Array(Be(e)+1);return Me(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),p.length>n?0:(((e,n)=>{t().set(e,n>>>0)})(p,e),p.length-1)}function vt(e){try{e()}catch(e){re(e)}}var bt=0,xt=null,St=0,_t=[],Ct={},Et={},It=0,At=null,Ot=[];Ce.gb();var Tt=[null,Se,Ie,Oe,Re,ke,Pe,ze,We,Ne,Ge,Ue,Ve,je,Fe,He,Le,Ze,et,dt,ct,pt,ft,ht,gt],Rt={r:function(e,t,n){return function(e){return function(e){if(!j){if(0===bt){var t=!1,n=!1;e(((e=0)=>{if(!j&&(St=e,t=!0,n)){bt=2,vt((()=>Kt(xt))),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),e=!1;try{var r=function(){var e=a()[xt+8>>2>>>0];return e=B[Et[e]],--K,e()}()}catch(t){r=t,e=!0}var i=!1;if(!xt){var o=At;o&&(At=null,(e?o.reject:o.resolve)(r),i=!0)}if(e&&!i)throw r}})),n=!0,t||(bt=1,xt=function(){var e=Bt(65548),t=e+12;i()[e>>2>>>0]=t,i()[e+4>>2>>>0]=t+65536,t=_t[0];var n=Ct[t];return void 0===n&&(n=It++,Ct[t]=n,Et[n]=t),t=n,a()[e+8>>2>>>0]=t,e}(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),vt((()=>qt(xt))))}else 2===bt?(bt=0,vt(Xt),Mt(xt),xt=null,Ot.forEach((e=>qe(e)))):re(`invalid state: ${bt}`);return St}}((t=>{e().then(t)}))}((async()=>{await c.xb(e,t,n)}))},b:function(e,t,n){throw new Ae(e>>>=0).gb(t>>>0,n>>>0),e},O:function(e){Dt(e>>>0,!$,1,!w,131072,!1),Ce.lb()},l:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):we(e)},I:Te,i:Re,U:ke,E:Pe,G:ze,V:We,S:Ne,K:Ge,R:Ue,p:Ve,F:je,C:Fe,T:He,D:Le,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>Ke())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=Ce.Qa[e])&&e.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Ye,X:function(e){v&&Ce.Qa[e>>>0].ref()},u:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getUTCSeconds(),a()[n+4>>2>>>0]=e.getUTCMinutes(),a()[n+8>>2>>>0]=e.getUTCHours(),a()[n+12>>2>>>0]=e.getUTCDate(),a()[n+16>>2>>>0]=e.getUTCMonth(),a()[n+20>>2>>>0]=e.getUTCFullYear()-1900,a()[n+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[n+28>>2>>>0]=e},v:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getSeconds(),a()[n+4>>2>>>0]=e.getMinutes(),a()[n+8>>2>>>0]=e.getHours(),a()[n+12>>2>>>0]=e.getDate(),a()[n+16>>2>>>0]=e.getMonth(),a()[n+20>>2>>>0]=e.getFullYear()-1900,a()[n+24>>2>>>0]=e.getDay(),t=(Xe(e.getFullYear())?Je:Qe)[e.getMonth()]+e.getDate()-1|0,a()[n+28>>2>>>0]=t,a()[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t)),a()[n+32>>2>>>0]=e},w:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(o,i);return 0>n?a()[e+32>>2>>>0]=+(i!=o&&s==r):0<n!=(s==r)&&(i=Math.max(o,i),t.setTime(t.getTime()+6e4*((0<n?s:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(Xe(t.getFullYear())?Je:Qe)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Ut((he=e,1<=+Math.abs(he)?0<he?+Math.floor(he/4294967296)>>>0:~~+Math.ceil((he-+(~~he>>>0))/4294967296)>>>0:0)),e>>>0},s:Ze,t:et,z:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var o=(new Date).getFullYear(),s=new Date(o,0,1),u=new Date(o,6,1);o=s.getTimezoneOffset();var l=u.getTimezoneOffset(),d=Math.max(o,l);i()[e>>2>>>0]=60*d,a()[t>>2>>>0]=+(o!=l),e=r(s),t=r(u),e=tt(e),t=tt(t),l<o?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)},d:()=>{re("")},c:function(e,t,n){return e>>>=0,t=rt(t>>>0,n>>>0),me[e].apply(null,t)},k:function(e,t,n){return e>>>=0,t=rt(t>>>0,n>>>0),me[e].apply(null,t)},m:function(){},j:function(){return Date.now()},W:()=>{throw K+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return v?(No(),N(fe)).cpus().length:navigator.hardwareConcurrency},L:function(e,t,n,r){for(Ce.Pb=t>>>0,st.length=n,t=r>>>0>>3,r=0;r<n;r++)st[r]=u()[t+r>>>0];return(0>e?me[-e-1]:Tt[e]).apply(null,st)},y:function(e){e>>>=0;var t=r().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var i=Math;a=Math.max(e,a);e:{i=i.min.call(i,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(i),F();var o=1;break e}catch{}o=void 0}if(o)return!0}return!1},P:dt,Q:ct,H:_e,h:pt,o:ft,x:ht,n:gt,a:k||c.wasmMemory,J:$t,e:function(e,t,n,r){return $t(e>>>0,t>>>0,n>>>0,r>>>0)}};(function(){function e(e,t){return e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){_t.push(t);try{return r.apply(null,arguments)}finally{j||(_t.pop()===t||re(),xt&&1===bt&&0===_t.length&&(bt=0,K+=1,vt(Yt),typeof Fibers<"u"&&Fibers.Ub()))}}:r}(t);return n}(e=e.exports),B=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),Ce.mb.push(B.Da),q.unshift(B.Y),M=t,ne(),e}var t={a:Rt};if(te(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){T("Module.instantiateWasm callback failed with error: "+e),d(e)}(function(e,t){var n=J;return A||"function"!=typeof WebAssembly.instantiateStreaming||ie(n)||n.startsWith("file://")||v||"function"!=typeof fetch?de(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return T("wasm streaming compile failed: "+r),T("falling back to ArrayBuffer instantiation"),de(n,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(d)})(),c._OrtInit=(e,t)=>(c._OrtInit=B.Z)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=B._)(e,t),c._OrtCreateSessionOptions=(e,t,n,r,a,i,o,s,u,l)=>(c._OrtCreateSessionOptions=B.$)(e,t,n,r,a,i,o,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=B.aa)(e,t),c._OrtAddFreeDimensionOverride=(e,t,n)=>(c._OrtAddFreeDimensionOverride=B.ba)(e,t,n),c._OrtAddSessionConfigEntry=(e,t,n)=>(c._OrtAddSessionConfigEntry=B.ca)(e,t,n),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=B.da)(e),c._OrtCreateSession=(e,t,n)=>(c._OrtCreateSession=B.ea)(e,t,n),c._OrtReleaseSession=e=>(c._OrtReleaseSession=B.fa)(e),c._OrtGetInputOutputCount=(e,t,n)=>(c._OrtGetInputOutputCount=B.ga)(e,t,n),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=B.ha)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=B.ia)(e,t),c._OrtFree=e=>(c._OrtFree=B.ja)(e),c._OrtCreateTensor=(e,t,n,r,a,i)=>(c._OrtCreateTensor=B.ka)(e,t,n,r,a,i),c._OrtGetTensorData=(e,t,n,r,a)=>(c._OrtGetTensorData=B.la)(e,t,n,r,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=B.ma)(e),c._OrtCreateRunOptions=(e,t,n,r)=>(c._OrtCreateRunOptions=B.na)(e,t,n,r),c._OrtAddRunConfigEntry=(e,t,n)=>(c._OrtAddRunConfigEntry=B.oa)(e,t,n),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=B.pa)(e),c._OrtCreateBinding=e=>(c._OrtCreateBinding=B.qa)(e),c._OrtBindInput=(e,t,n)=>(c._OrtBindInput=B.ra)(e,t,n),c._OrtBindOutput=(e,t,n,r)=>(c._OrtBindOutput=B.sa)(e,t,n,r),c._OrtClearBoundOutputs=e=>(c._OrtClearBoundOutputs=B.ta)(e),c._OrtReleaseBinding=e=>(c._OrtReleaseBinding=B.ua)(e),c._OrtRunWithBinding=(e,t,n,r,a)=>(c._OrtRunWithBinding=B.va)(e,t,n,r,a),c._OrtRun=(e,t,n,r,a,i,o,s)=>(c._OrtRun=B.wa)(e,t,n,r,a,i,o,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=B.xa)(e),c._JsepOutput=(e,t,n)=>(c._JsepOutput=B.ya)(e,t,n),c._JsepGetNodeName=e=>(c._JsepGetNodeName=B.za)(e);var kt=c._pthread_self=()=>(kt=c._pthread_self=B.Aa)(),Bt=c._malloc=e=>(Bt=c._malloc=B.Ba)(e),Mt=c._free=e=>(Mt=c._free=B.Ca)(e);c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=B.Da)();var Dt=c.__emscripten_thread_init=(e,t,n,r,a,i)=>(Dt=c.__emscripten_thread_init=B.Fa)(e,t,n,r,a,i);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=B.Ga)();var Pt,zt=(e,t,n,r)=>(zt=B.Ha)(e,t,n,r),Wt=e=>(Wt=B.Ia)(e),Nt=c.__emscripten_thread_exit=e=>(Nt=c.__emscripten_thread_exit=B.Ja)(e),Gt=c.__emscripten_check_mailbox=()=>(Gt=c.__emscripten_check_mailbox=B.Ka)(),Ut=e=>(Ut=B.La)(e),Vt=(e,t)=>(Vt=B.Ma)(e,t),jt=()=>(jt=B.Na)(),Ft=e=>(Ft=B.Oa)(e),Ht=e=>(Ht=B.Pa)(e),Lt=c.dynCall_ii=(e,t)=>(Lt=c.dynCall_ii=B.Ra)(e,t),qt=e=>(qt=B.Sa)(e),Yt=()=>(Yt=B.Ta)(),Kt=e=>(Kt=B.Ua)(e),Xt=()=>(Xt=B.Va)();function Jt(){function e(){if(!Pt&&(Pt=!0,c.calledRun=!0,!j)&&(b||Ee(q),l(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();Y.unshift(e)}Ee(Y)}}if(!(0<Q))if(b)l(c),b||Ee(q),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)L.unshift(c.preRun.shift());Ee(L),0<Q||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.___start_em_js=925783,c.___stop_em_js=925944,c.keepRuntimeAlive=X,c.wasmMemory=k,c.stackAlloc=Ht,c.stackSave=jt,c.stackRestore=Ft,c.UTF8ToString=xe,c.stringToUTF8=De,c.lengthBytesUTF8=Be,c.ExitStatus=ge,c.PThread=Ce,ee=function e(){Pt||Jt(),Pt||(ee=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return Jt(),e.ready});"object"==typeof a&&"object"==typeof i?i.exports=s:void 0===(r=(()=>s).apply(t,[]))||(e.exports=r)})),Uo=z(((e,t)=>{t.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'})),Vo=P((()=>{me=de(),ge=Go(),we=!1,$e=!1,ve=!1,be=()=>{try{return!(typeof SharedArrayBuffer>"u")&&(typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},xe=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Se=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",_e=async e=>{if(we)return Promise.resolve();if($e)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ve)throw new Error("previous call to 'initializeWebAssembly()' failed.");$e=!0;let t=e.initTimeout,n=e.numThreads,r=e.simd,a=n>1&&be(),i=r&&xe(),o=e.wasmPaths,s="string"==typeof o?o:void 0,u=Se(i,a),l="object"==typeof o?o[u]:void 0,d=!1,c=[];if(t>0&&c.push(new Promise((e=>{setTimeout((()=>{d=!0,e()}),t)}))),c.push(new Promise(((e,t)=>{let n=a?ge:me,r={locateFile:(e,t)=>{if(a&&e.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Uo()],{type:"text/javascript"}));if(e.endsWith(".wasm")){if(l)return l;let e=s??t;return"ort-wasm-simd.wasm"===u?e+"ort-wasm-simd.jsep.wasm":"ort-wasm-simd-threaded.wasm"===u?e+"ort-wasm-simd-threaded.jsep.wasm":e+u}return t+e}};if(a)if(typeof Blob>"u")r.mainScriptUrlOrBlob=(void 0)("/","ort-wasm-threaded.js");else{let e=`var ortWasmThreaded=${n.toString()};`;r.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(r).then((t=>{$e=!1,we=!0,ye=t,e()}),(e=>{$e=!1,ve=!0,t(e)}))}))),await Promise.race(c),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ce=()=>{if(we&&ye)return ye;throw new Error("WebAssembly is not initialized yet.")}})),jo=P((()=>{Vo(),Ee=(e,t)=>{let n=Ce(),r=n.lengthBytesUTF8(e)+1,a=n._malloc(r);return n.stringToUTF8(e,a,r),t.push(a),a},Ie=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,a])=>{let i=t?t+e:e;if("object"==typeof a)Ie(a,i+".",n,r);else if("string"==typeof a||"number"==typeof a)r(i,a.toString());else{if("boolean"!=typeof a)throw new Error("Can't handle extra config type: "+typeof a);r(i,a?"1":"0")}}))},Ae=e=>{let t=Ce(),n=t.stackSave();try{let n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);let r=t.HEAP32[n/4],a=t.HEAPU32[n/4+1],i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}})),Fo=P((()=>{Vo(),jo(),Oe=e=>{let t=Ce(),n=0,r=[],a=e||{};try{if(void 0===e?.logSeverityLevel)a.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)a.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(a.terminate=!1);let i=0;return void 0!==e?.tag&&(i=Ee(e.tag,r)),n=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,i),0===n&&Ae("Can't create run options."),void 0!==e?.extra&&Ie(e.extra,"",new WeakSet,((e,a)=>{let i=Ee(e,r),o=Ee(a,r);0!==t._OrtAddRunConfigEntry(n,i,o)&&Ae(`Can't set a run config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),Ho=P((()=>{Vo(),jo(),Te=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Re=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},ke=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},Be=(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof r){let t=r;if(t?.deviceType){let r=Ee("deviceType",n),a=Ee(t.deviceType,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'deviceType' - ${t.deviceType}.`)}if(t?.powerPreference){let r=Ee("powerPreference",n),a=Ee(t.powerPreference,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'powerPreference' - ${t.powerPreference}.`)}}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);let r=Ee("preferredLayout",n),a=Ee(t.preferredLayout,n);0!==Ce()._OrtAddSessionConfigEntry(e,r,a)&&Ae(`Can't set a session config entry: 'preferredLayout' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=Ee(t,n);0!==Ce()._OrtAppendExecutionProvider(e,a)&&Ae(`Can't append execution provider: ${t}.`)}},Me=e=>{let t=Ce(),n=0,r=[],a=e||{};ke(a);try{let e=Te(a.graphOptimizationLevel??"all"),i=Re(a.executionMode??"sequential"),o="string"==typeof a.logId?Ee(a.logId,r):0,s=a.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw new Error(`log serverity level is not valid: ${s}`);let u=a.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let l="string"==typeof a.optimizedModelFilePath?Ee(a.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!a.enableCpuMemArena,!!a.enableMemPattern,i,!!a.enableProfiling,0,o,s,u,l),0===n&&Ae("Can't create session options."),a.executionProviders&&Be(n,a.executionProviders,r),a.freeDimensionOverrides)for(let[e,i]of Object.entries(a.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof i||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let a=Ee(e,r);0!==t._OrtAddFreeDimensionOverride(n,a,i)&&Ae(`Can't set a free dimension override: ${e} - ${i}.`)}return void 0!==a.extra&&Ie(a.extra,"",new WeakSet,((e,a)=>{let i=Ee(e,r),o=Ee(a,r);0!==t._OrtAddSessionConfigEntry(n,i,o)&&Ae(`Can't set a session config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseSessionOptions(n),r.forEach((e=>t._free(e))),e}}})),Lo=P((()=>{De=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Pe=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ze=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],We=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ne=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ge=e=>"float32"===e||"int32"===e||"int64"===e||"bool"===e||"float16"===e||"uint32"===e,Ue=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}})),qo=P((()=>{Lo(),Ve=["V","I","W","E","F"],je=(e,t)=>{console.log(`[${Ve[e]},${(new Date).toISOString()}]${t}`)},Le=(e,t)=>{Fe=e,He=t},qe=(e,t)=>{let n=Ne(e);n>=Ne(Fe)&&je(n,"function"==typeof t?t():t)},Ye=(...e)=>{He&&qe(...e)}})),Yo=P((()=>{Lo(),Ke=(e,t)=>new(We(t))(e)})),Ko=P((()=>{})),Xo=P((()=>{qo(),Ko(),Xe=e=>16*Math.ceil(e/16),Je=1,Qe=()=>Je++,Ze=async(e,t,n,r)=>{let a=Xe(n),i=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=e.getCommandEncoder();e.endComputePass(),o.copyBufferToBuffer(t,0,i,0,a),e.flush(),await i.mapAsync(GPUMapMode.READ);let s=i.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(s,0,n)),e}return new Uint8Array(s.slice(0,n))}finally{i.destroy()}},et=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,t){let n=t.buffer,r=t.byteOffset,a=t.byteLength,i=Xe(a),o=this.storageCache.get(e);if(!o)throw new Error("gpu data for uploading does not exist");if(o.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${a}`);let s=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=s.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,r,a)),s.unmap();let l=this.backend.getCommandEncoder();this.backend.endComputePass(),l.copyBufferToBuffer(s,0,o.gpuData.buffer,0,i),Ye("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(s)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=Xe(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}registerExternalBuffer(e,t,n){let r;if(n){if(r=this.externalBuffers.get(n),void 0===r)throw new Error("previous buffer is not registered");if(e===n)return Ye("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;this.externalBuffers.delete(n)}else r=Qe();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),this.externalBuffers.set(e,r),Ye("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){let t=this.externalBuffers.get(e);void 0!==t&&(this.storageCache.delete(t),this.externalBuffers.delete(e),Ye("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=Xe(e),a=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||i){let e=a?this.freeBuffers:this.freeUniformBuffers,i=e.get(r);i||(i=[],e.set(r,i)),n=i.length>0?i.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let o={id:Qe(),type:0,buffer:n};return this.storageCache.set(o.id,{gpuData:o,originalSize:e}),Ye("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${o.id}`)),o}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return Ye("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");await Ze(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},tt=(...e)=>new et(...e)})),Jo=P((()=>{nt=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}},rt=e=>new nt(e)})),Qo=P((()=>{at=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},it=class{static calcShape(e,t,n=!1){let r=e.length,a=t.length;if(0===r)return t;if(0===a)return e;let i=Math.max(e.length,t.length),o=new Array(i);if(n){if(r<2||a<2)return;let n=at.calcMatMulShape([e[r-2],e[r-1]],[t[a-2],t[a-1]]);if(void 0===n)return;[o[i-2],o[i-1]]=n}for(let s=n?3:1;s<=i;s++){let n=r-s<0?1:e[r-s],u=a-s<0?1:t[a-s];if(n!==u&&n>1&&u>1)return;o[i-s]=Math.max(n,u)}return o}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(1!==e[n-a]&&e[n-a]!==t[r-a])return!1;return!0}},ot=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let a=t;a<n;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=e[a]}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},st=class e{static adjustPoolAttributes(e,t,n,r,a,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,a,i,o,s){if(s){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<t.length-2;u++)e.adjustPadAndReturnShape(t[u+(o?1:2)],n[u],r[u],a[u],i,u,u+t.length-2,s)}}static computePoolOutputShape(t,n,r,a,i,o,s){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return e.computeShapeHelper(t,n,u,r,a,i,o,s),u}static computeConvOutputShape(t,n,r,a,i,o,s){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[t[0],n[0]];return e.computeShapeHelper(!1,t,u,r,a,i,o,s),u}static computeShapeHelper(t,n,r,a,i,o,s,u){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],a[t],i[t],o[t],s,t,t+n.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,a,i,o,s){let u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[i]+a[o]-u)/t+1);switch(s){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return a[i]=Math.floor("SAME_LOWER"===s?(n+1)/2:n/2),a[o]=n-a[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},ut=class{static getShapeOfGemmResult(e,t,n,r,a){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,o,s;t?(i=e[1],o=e[0]):(i=e[0],o=e[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==o)throw new Error("dimension mismatch");if(i<=0||s<=0||o<=0)throw new Error("invalid shape specified");if(a&&!it.isValidBroadcast(a,[i,s]))throw new Error("gemm: invalid bias shape for broadcast");return[i,s,o]}},lt=-34028234663852886e22,dt=34028234663852886e22})),Zo=P((()=>{Lo(),Qo(),ct=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},pt=(e,t=1)=>{let n=ct(e,t);return"string"==typeof n?n:n[0]},ft=e=>[{type:"uint32",data:e},{type:"uint32",data:ot.computeStrides(e)}],ht=e=>e%4==0?4:e%2==0?2:1,mt=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,gt=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}f(${n})`,yt=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,wt=(e,t,n,r,a)=>{let i="number"==typeof n,o=i?n:n.length,s=[...new Array(o).keys()],u=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,l=ct(t,a),d="string"==typeof l?l:l[1],c="string"==typeof l?l:l[0],p={indices:u,value:d,storage:c,tensor:t},f=e=>"string"==typeof e?e:`${e}u`,h={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=i?"uniforms.":"",g=`${m}${e}_shape`,y=`${m}${e}_strides`,w="";for(let e=0;e<o-1;e++)w+=`\n    let dim${e} = current / ${y}[${e}];\n    let rest${e} = current % ${y}[${e}];\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;w+=`indices[${o-1}] = current;`;let $=o<2?"":`\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\n    var indices: ${p.indices};\n    var current = offset;\n    ${w}\n    return indices;\n  }`,v=[];if(o>=2)for(let e=o-1;e>=0;e--)v.push(`${y}[${e}] * (indices[${e}])`);let b=o<2?"":`\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\n    return ${v.join("+")};\n  }`,x=(...e)=>0===o?"0u":`${p.indices}(${e.map(f).join(",")})`,S=(e,t)=>o<2?`${e}`:`${e}[${t}]`,_={},C=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),E=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),I=o<2?"":`\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${d} {\n    return ${E(`i2o_${e}(indices)`)};\n  }`,A=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn get_${e}(${t}) -> ${d} {\n    return get_${e}ByIndices(${x(n)});\n  }`})(),O=o<2?"":`\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${d}) {\n    ${C(`i2o_${e}(indices)`,"value")}\n  }`,T=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn set_${e}(${t}, value: ${d}) {\n    set_${e}ByIndices(${x(n)}, value);\n  }`})();return{impl:()=>{let e=[];return i||(e.push(`const ${g} = ${p.indices}(${n.join(",")});`),e.push(`const ${y} = ${p.indices}(${ot.computeStrides(n).join(",")});`)),h.offsetToIndices&&e.push($),h.indicesToOffset&&e.push(b),h.broadcastedIndicesToOffset&&Object.values(_).forEach((t=>e.push(t))),h.set&&e.push(T),h.setByIndices&&e.push(O),h.get&&e.push(A),h.getByIndices&&e.push(I),e.join("\n")},type:p,offsetToIndices:t=>(h.offsetToIndices=!0,o<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(h.indicesToOffset=!0,o<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{h.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in _)return`${r}(${t})`;let a=[];for(let e=o-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-o);a.push(`${S(y,e)} * (${t} % ${S(g,e)})`)}return _[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${a.length>0?a.join("+"):"0u"};\n           }`,`${r}(${t})`},indices:x,indicesGet:S,indicesSet:(e,t,n)=>o<2?`${e}=${n};`:`${e}[${t}]=${n};`,set:(...t)=>{if(t.length!==o+1)throw new Error(`indices length must be ${o}`);let n=t[o];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,o).map(f).join(",");return 0===o?C("0u",n):1===o?C(r[0],n):(h.set=!0,h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:C,setByIndices:(t,n)=>o<2?C(t,n):(h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==o)throw new Error(`indices length must be ${o}`);let n=t.map(f).join(",");return 0===o?E("0u"):1===o?E(n[0]):(h.get=!0,h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:E,getByIndices:t=>o<2?E(t):(h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r?"input":"output",name:e,strides:y,shape:g,rank:o}},$t=(e,t,n,r=1)=>wt(e,t,n,!0,r),vt=(e,t,n,r=1)=>wt(e,t,n,!1,r),bt=class{constructor(e){this.normalizedDispatchGroup=e,this.indicesHelpers=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=64){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2],a=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\n  fn main(${a?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\n    ${a?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${t*n*r}u + local_index;`}\n  `}declareVariable(e,t){this.indicesHelpers.push(e),e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:e.type.indices}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:e.type.indices});let n="input"===e.usage?"read":"read_write",r=e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\n")}registerUniform(e,t){return this.uniforms.push({name:e,type:t}),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n}of this.uniforms)e.push(`${t}:${n}`);return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map((e=>e.impl())).join("\n")}},xt=e=>new bt(e),St=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;a++){let i=n-1-a,o=e[i]||1;(t[t.length-1-a]||1)>1&&1===o&&r.unshift(i)}return r},_t=e=>e<=4})),es=P((()=>{Qo(),Jo(),Zo(),Ct=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.")},Et=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,It=(e,t)=>ot.sortBasedOnPerm(e,Et(e.length,t)),At=(e,t,n,r)=>{let a=[];a.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)a.push(n.indicesSet("a",e[r],`i[${r}]`));return a.push("return a;}"),a.join("\n")},Ot=(e,t)=>{let n=e.dataType,r=e.dims.length,a=Et(r,t),i=_t(r),o=It(e.dims,a),s=i?o.length:o,u=i?r:e.dims,l=vt("output",n,s),d=$t("a",n,u);return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:i?["rank"]:["dims"]},getRunData:e=>{let t=ot.size(o);return{outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:i?[{type:"uint32",data:t},...ft(e[0].dims),...ft(o)]:[{type:"uint32",data:t}]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(d,l)}\n\n  ${At(a,r,d,l)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${l.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${l.setByOffset("global_idx",d.getByIndices("aIndices"))}\n  }`}},Tt=(e,t)=>{Ct(e.inputs),e.compute(Ot(e.inputs[0],t.perm))},Rt=e=>rt({perm:e.perm})})),ts=P((()=>{Qo(),Zo(),ns(),es(),kt={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Bt={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Mt={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Dt={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Pt=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},zt=(e,t)=>{let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]},Wt=(e,t)=>{let n=e.length+t.length,r=[],a=0;for(let i=0;i<n;i++)-1===t.indexOf(i)?r.push(e[a++]):r.push(1);return r},Nt=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Gt=(e,t)=>{let n=[];if(!Nt(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},Ut=(e,t,n,r,a,i,o)=>{let s=n[0].dims,u=ot.size(i),l=ot.size(o),d=$t("_A",n[0].dataType,s),c=vt("output",a,i),p=`\n          var<workgroup> aBestValues : array<${c.type.storage}, 32>;\n       `;return{name:e,shaderCache:t,getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,c)}\n        ${p}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(32)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / 32;\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${c.type.storage}(${Mt[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + 32) {\n           let candidate = ${c.type.storage}(${d.getByOffset("offset + k")});\n           bestValue = ${kt[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, 32u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${Bt[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${c.setByOffset("outputIndex","mean"===r?`bestValue / ${c.type.storage}(uniforms.reduceSize)`:`${Dt[r]}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:u},programUniforms:[{type:"uint32",data:l}]})}},Vt=(e,t,n,r)=>{let a=1===e.inputs.length?n:nn(e.inputs,n),i=a.axes;0===i.length&&!a.noopWithEmptyAxes&&(i=e.inputs[0].dims.map(((e,t)=>t)));let o=ot.normalizeAxes(i,e.inputs[0].dims.length),s=o,u=e.inputs[0],l=Gt(s,e.inputs[0].dims.length);l.length>0&&(u=e.compute(Ot(e.inputs[0],l),{inputs:[0],outputs:[-1]})[0],s=Pt(s.length,u.dims.length));let[d,c]=zt(u.dims,s),p=d;a.keepDims&&(p=Wt(d,o)),e.compute(Ut(t,{hint:a.cacheKey,inputDependencies:["type"]},[u],r,e.inputs[0].dataType,p,c),{inputs:[u]})},jt=(e,t)=>{Vt(e,"ReduceMeanShared",t,"mean")},Ft=(e,t)=>{Vt(e,"ReduceL1Shared",t,"l1")},Ht=(e,t)=>{Vt(e,"ReduceL2Shared",t,"l2")},Lt=(e,t)=>{Vt(e,"ReduceLogSumExpShared",t,"logSumExp")},qt=(e,t)=>{Vt(e,"ReduceMaxShared",t,"max")},Yt=(e,t)=>{Vt(e,"ReduceMinShared",t,"min")},Kt=(e,t)=>{Vt(e,"ReduceProdShared",t,"prod")},Xt=(e,t)=>{Vt(e,"ReduceSumShared",t,"sum")},Jt=(e,t)=>{Vt(e,"ReduceSumSquareShared",t,"sumSquare")},Qt=(e,t)=>{Vt(e,"ReduceLogSumShared",t,"logSum")}})),ns=P((()=>{Qo(),Jo(),Zo(),ts(),Zt=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},en=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],tn=(e,t,n,r,a,i,o=!1,s=!1)=>{let u=[],l=n[0].dims,d=ot.normalizeAxes(a,n[0].dims.length),c=!s&&0===d.length;l.forEach(((e,t)=>{c||d.indexOf(t)>=0?o&&u.push(1):u.push(e)}));let p=[],f=$t("_A",n[0].dataType,l),h=vt("output",i,u),m=r(f,h,d),g=`inputOffset = ${f.indicesToOffset("inputIndices")};`,y=`let ${g};`,w=`var ${g};`,$=""===m[1]?"":w,v=(""===m[1]?y:g)+"\n"+m[2];for(let e=0,t=0;e<n[0].dims.length;e++)c||d.indexOf(e)>=0?(o&&t++,v=`for(var j${e}: u32 = 0; j${e} < ${n[0].dims[e]}; j${e}++) {\n                ${m[2].includes("lastIndex")?`let lastIndex = j${e};`:""}\n                ${f.indicesSet("inputIndices",e,`j${e}`)}\n                ${v}\n              }`):(p.push(`${f.indicesSet("inputIndices",e,h.indicesGet("outputIndices",t))};`),t++);let b=ot.size(u);return{name:e,shaderCache:t,getShaderSource:e=>`\n        ${e.declareVariables(f,h)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n          var inputIndices: ${f.type.indices};\n          let outputIndices = ${h.offsetToIndices("global_idx")};\n\n          ${p.join("\n")}\n          ${m[0]}       // init ops for reduce max/min\n          ${$}\n          ${m[1]}\n          ${v}\n          ${m[3]}\n          ${4===m.length?h.setByOffset("global_idx","value"):m.slice(4).join("\n")}\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(b/64)}})}},nn=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),rt({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rn=(e,t,n,r)=>{let a=e.inputs,i=1===a.length?n:nn(a,n);e.compute(tn(t,{hint:i.cacheKey},[a[0]],i.noopWithEmptyAxes&&0===i.axes.length?en:r,i.axes,a[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},an=(e,t)=>{Zt(e.inputs),rn(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,"value = log(value);"]))},on=(e,t)=>{Zt(e.inputs),rn(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByOffset("inputOffset")});`,""]))},sn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"]))},un=(e,t)=>{Zt(e.inputs),rn(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByOffset("inputOffset")});`,"value = log(value);"]))},ln=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("inputIndices",t,0));return[`${r.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = max(value, ${e.getByOffset("inputOffset")});`,""]}))},dn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMean",t,((t,n,r)=>{let a=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(a*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${a});`]}))},cn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`inputIndices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = min(value, ${e.getByOffset("inputOffset")});`,""]}))},pn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByOffset("inputOffset")};`,""]))},fn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,""]))},hn=(e,t)=>{Zt(e.inputs),rn(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += t * t;`,""]))},mn=(e,t,n)=>{if(0===t.length)return!!n;let r=1,a=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:a*=e[n];return a<32&&r>1024},gn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dn(e,t):jt(e,t)},yn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?on(e,t):Ft(e,t)},wn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?sn(e,t):Ht(e,t)},$n=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?un(e,t):Lt(e,t)},vn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ln(e,t):qt(e,t)},bn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cn(e,t):Yt(e,t)},xn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pn(e,t):Kt(e,t)},Sn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fn(e,t):Xt(e,t)},_n=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hn(e,t):Jt(e,t)},Cn=(e,t)=>{mn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?an(e,t):Qt(e,t)},En=e=>rt(e)})),rs=P((()=>{Lo(),Jo(),ns(),In=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},An=(e,t)=>rt({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),On=(e,t)=>{In(e.inputs);let n=1===e.inputs.length?t:An(e.inputs,t);e.compute(tn("ArgMin",{hint:n.cacheKey},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]}),[n.axis],7,n.keepDims),{inputs:[0]})},Tn=(e,t)=>{In(e.inputs);let n=1===e.inputs.length?t:An(e.inputs,t);e.compute(tn("argMax",{hint:n.cacheKey},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]}),[n.axis],7,n.keepDims),{inputs:[0]})},Rn=e=>rt(e)})),as=P((()=>{Qo(),Zo(),kn=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Bn=e=>{let t=e[0].dims,n=e[0].dims[2],r=ot.size(t)/4,a=e[0].dataType,i=$t("input",a,t,4),o=$t("bias",a,[n],4),s=$t("residual",a,t,4),u=vt("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(i,o,s,u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${i.getByOffset("global_idx")}\n      + ${o.getByOffset("global_idx % channels")} + ${s.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx","value")}\n  }`}},Mn=e=>{kn(e.inputs),e.compute(Bn(e.inputs))}})),is=P((()=>{Lo(),Qo(),Jo(),Zo(),Dn=(e,t,n,r,a,i)=>{let o=Math.ceil(t/4),s="";s="string"==typeof a?`${a}(a)`:a("a");let u=$t("inputData",n,[o],4),l=vt("outputData",r,[o],4);return`\n  ${e.declareVariables(u,l)}\n\n  ${i??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    let a = ${u.getByOffset("global_idx")};\n    ${l.setByOffset("global_idx",s)}\n  }`},Pn=(e,t,n,r,a,i=e.dataType)=>({name:t,shaderCache:{hint:a},getShaderSource:t=>Dn(t,ot.size(e.dims),e.dataType,i,n,r),getRunData:t=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(ot.size(t[0].dims)/64/4)}})}),zn=e=>{e.compute(Pn(e.inputs[0],"Abs","abs"))},Wn=e=>{e.compute(Pn(e.inputs[0],"Acos","acos"))},Nn=e=>{e.compute(Pn(e.inputs[0],"Acosh","acosh"))},Gn=e=>{e.compute(Pn(e.inputs[0],"Asin","asin"))},Un=e=>{e.compute(Pn(e.inputs[0],"Asinh","asinh"))},Vn=e=>{e.compute(Pn(e.inputs[0],"Atan","atan"))},jn=e=>{e.compute(Pn(e.inputs[0],"Atanh","atanh"))},Fn=e=>rt(e),Hn=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Pn(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},Ln=(e,t)=>{let n=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<${n}> = vec4(${n}(${t.min}));\n    const clip_max_: vec4<${n}> = vec4(${n}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},qn=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:lt,n=e.length>=3?e[2].getFloat32Array()[0]:dt;return rt({min:t,max:n})},Yn=e=>{let t=qn(e.inputs);Ln(e,t)},Kn=e=>{e.compute(Pn(e.inputs[0],"Ceil","ceil"))},Xn=e=>{e.compute(Pn(e.inputs[0],"Cos","cos"))},Jn=e=>{e.compute(Pn(e.inputs[0],"Cosh","cosh"))},Qn=e=>rt(e),Zn=(e,t)=>{e.compute(Pn(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},er=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,tr=e=>{let t=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),er(`vec4<${t}>`,t)))},nr=e=>{e.compute(Pn(e.inputs[0],"Exp","exp"))},rr=e=>{e.compute(Pn(e.inputs[0],"Floor","floor"))},ar=e=>{let t=pt(e.inputs[0].dataType);e.compute(Pn(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),er(`vec4<${t}>`,t)))},ir=(e,t)=>{e.compute(Pn(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},or=e=>{e.compute(Pn(e.inputs[0],"Not",(e=>`!${e}`)))},sr=e=>{e.compute(Pn(e.inputs[0],"Neg",(e=>`-${e}`)))},ur=e=>{e.compute(Pn(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},lr=e=>{e.compute(Pn(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},dr=e=>{e.compute(Pn(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},cr=e=>{e.compute(Pn(e.inputs[0],"Sin","sin"))},pr=e=>{e.compute(Pn(e.inputs[0],"Sinh","sinh"))},fr=e=>{e.compute(Pn(e.inputs[0],"Sqrt","sqrt"))},hr=e=>{e.compute(Pn(e.inputs[0],"Tan","tan"))},mr=e=>{e.compute(Pn(e.inputs[0],"Tanh","tanh"))},gr=(e,t)=>(e.compute(Pn(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),yr=e=>{e.compute(Pn(e.inputs[0],"Log","log"))}})),os=P((()=>{Qo(),Zo(),is(),wr=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},$r=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=$t("input",e[0].dataType,e[0].dims,4),r=$t("bias",e[0].dataType,[e[0].dims[2]],4),a=vt("output",e[0].dataType,t,4),i=ot.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,r,a)}\n\n  ${er("vec4f")}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},vr=e=>{wr(e.inputs),e.compute($r(e.inputs))}})),ss=P((()=>{Lo(),Qo(),Zo(),br=(e,t,n,r,a,i,o,s,u,l,d)=>{let c,p,f=ot.size(r),h=Math.ceil(f/4);"string"==typeof o?c=p=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?c=p=o:(c=o.scalar,p=o.vector);let m,g="",y=vt("outputData",l,r,4),w=$t("aData",s,t,4),$=$t("bData",u,n,4);if(i){let e=e=>{let t=ot.computeStrides(e),n=[];for(let a=e.length-1;a>=0;a--){let i=y.indicesGet("outputIndices",a+r.length-e.length);n.push(`${t[a]}u * (${i} % ${e[a]}u)`)}return n.length>0?n.join("+"):"0u"};g=`\n          fn calcOffsetA(outputIndices: ${y.type.indices}) -> u32 {\n            return ${e(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${y.type.indices}) -> u32 {\n            return ${e(n)};\n          }\n        `}if(a)if(i){let e=1===ot.size(t),r=1===ot.size(n);m=e||r?y.setByOffset("global_idx",p(e?`${w.type.value}(${w.getByOffset("0")}.x)`:w.getByOffset("global_idx"),r?`${$.type.value}(${$.getByOffset("0")}.x)`:$.getByOffset("global_idx"))):`\n            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${y.setByOffset("global_idx",p(w.getByOffset("offsetA / 4u"),$.getByOffset("offsetB / 4u")))}\n          `}else m=y.setByOffset("global_idx",p(w.getByOffset("global_idx"),$.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${y.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = calcOffsetA(outputIndices${t});\n            let offsetB${t} = calcOffsetB(outputIndices${t});\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${c(r,a)});\n          `};m=9===l?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(w,$,y)}\n\n        ${d??""}\n        ${g}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n        ${m}\n      }`},xr=(e,t,n,r,a,i,o=n.dataType)=>{let s=!ot.areEqual(n.dims,r.dims),u=n.dims,l=ot.size(n.dims),d=!1;if(s){let e=it.calcShape(n.dims,r.dims,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");u=e,l=ot.size(u);let t=1===ot.size(n.dims),a=1===ot.size(r.dims),i=1;for(let e=1;e<u.length;e++){let t=n.dims[n.dims.length-e]??1;if(t!==(r.dims[r.dims.length-e]??1))break;i*=t}(i%4==0||t||a)&&(d=!0)}else d=!0;return{name:e,shaderCache:{hint:t},getShaderSource:e=>br(e,n.dims,r.dims,u,d,s,a,n.dataType,r.dataType,o,i),getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},Sr=(e,t,n,r,a,i)=>{e.compute(xr(t,a??"",e.inputs[0],e.inputs[1],n,r,i))},_r=e=>{Sr(e,"Add",((e,t)=>`${e}+${t}`))},Cr=e=>{Sr(e,"Div",((e,t)=>`${e}/${t}`))},Er=e=>{Sr(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},Ir=e=>{Sr(e,"Mul",((e,t)=>`${e}*${t}`))},Ar=e=>{let t=$t("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Sr(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Or=e=>{Sr(e,"Sub",((e,t)=>`${e}-${t}`))},Tr=e=>{Sr(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Rr=e=>{Sr(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},kr=e=>{Sr(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Br=e=>{Sr(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),us=P((()=>{Qo(),Jo(),Zo(),Mr=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,n=e[0].dims.length;for(let r of e){if(r.dataType!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}},Dr=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Pr=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;++a){let i=t.setByOffset("global_idx",e[a].getByIndices("indices"));1===n?r.push(i):0===a?r.push(`if (inputIndex == ${a}u) { ${i} }`):a===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${a}) { ${i} }`)}return r.join("\n")},zr=(e,t)=>{let n=e[0].dims.slice();if(t>=n.length||t<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");let r=t<0?n.length+t:t,a=n.slice(0);for(let t=1;t<e.length;t++){let i=e[t].dims.slice();for(let e=0;e<n.length;e++)if(e===r)a[r]+=i[e];else if(n[e]!==i[e])throw new Error("non concat dimensions must match")}let i=ot.size(a),o=new Array(e.length),s=new Array(e.length),u=e[0].dataType,l=0;for(let t=0;t<e.length;++t)l+=e[t].dims[r],o[t]=l,s[t]=$t(`input${t}`,u,e[t].dims);let d=vt("output",u,a),c=d.indicesGet("indices",r);return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n  ${e.declareVariables(...s,d)}\n\n  const sizeInConcatAxis = array<u32, ${o.length}>(${o.map((e=>`${e}u`)).join(",")});\n  ${Dr(o.length)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n    var indices = ${d.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${c});\n    if (inputIndex != 0u) {\n      ${c} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Pr(s,d)}\n  }`}},Wr=(e,t)=>{Mr(e.inputs),e.compute(zr(e.inputs,t.axis))},Nr=e=>rt({axis:e.axis})})),ls=P((()=>{Gr=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Ur=(e,t=!1,n=!1,r=3)=>"",Vr=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `})),ds=P((()=>{jr="\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n"})),cs=P((()=>{Qo(),Fr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Hr=e=>{let t=e?.activation||"";if("Clip"===t){let[n,r]=e?.activation_params||[lt,dt];return{activation:t,clipMax:r,clipMin:n,activationCacheKey:`${t}:${n},${r}`}}return{activation:t,activationCacheKey:t}}})),ps=P((()=>{Qo(),Zo(),cs(),ls(),Lr=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,qr=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Yr=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32)=>{let u=t[1]*e[1],l=t[0]*e[0],d=a?u:i,c=a?i:u,p=d/t[0],f=i/t[1];if((!a||4!==p||4!==e[1])&&(a||3!==p&&4!==p)||d%t[0]!=0||i%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${a} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${p} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${p}<${n}>, ${d/p}>, ${c}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${p};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${o?"0":"i32(globalId.z)"};\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let numTiles = ${o?`${Math.ceil(s/i)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${f};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Lr(a,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${qr(a,p)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Kr=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Xr=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Jr=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32,u=!1)=>{let l=e[1]*t[1],d=e[0]*t[0],c=a?l:i,p=a?i:l;if(p%t[1]!=0||c%t[0]!=0||i%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let f=p/t[1],h=c/t[0],m=i/t[1],g=u?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${l};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${Kr(a,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${l};\n\nlet tileRowA = i32(localId.y) * ${f};\nlet tileColA = i32(localId.x) * ${h};\nlet tileRowB = i32(localId.y) * ${m};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${h}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Kr(a,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Xr(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${o?"0":"i32(globalId.z)"};\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${o?`${Math.ceil(s/i)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${g}\n  }\n`},Qr=(e,t,n,r,a,i=!1)=>{let o=a[0],s=a[1],u=a[2],l=r[0],d=r[1],c=r[2],p=r[3],f=St(o,u),h=St(s,u),m=pt(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${Gr(e,m)} {\n      var value = ${Gr(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${(()=>{let e=d.rank,t=l.rank,n=`var aIndices: ${d.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\naIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return f.forEach((e=>{n+=`\naIndices[${e}] = 0;`})),n+=`\naIndices[${e-2}] = u32(row);\n                   aIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${Gr(e,m)} {\n      var value = ${Gr(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${(()=>{let e=c.rank,t=l.rank,n=`var bIndices: ${c.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\nbIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return h.forEach((e=>{n+=`\nbIndices[${e}] = 0;`})),n+=`\nbIndices[${e-2}] = u32(row);\n                   bIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${c.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Gr(e,m)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${i?"bias[colIn]":`${Gr(e,m)}(bias[row])`};`:""}\n        ${n}\n        ${p.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Zr=(e,t,n,r,a=!1)=>{let i=e[0].dims,o=e[1].dims,s=i.slice(0,-2),u=o.slice(0,-2),l=r?r.slice(0,-2):n.slice(0,-2),d=$t("batchDims",e[0].dataType,l),c=[d],p=[s,u,l],f=ot.size(l),h=i[i.length-2],m=i[i.length-1],g=o[o.length-1],y=m%4==0&&g%4==0,{activationFunction:w,applyActivation:$}=Fr(t,y),v=h<=8?[4,1,1]:[4,4,1],b=[8,8,1],x=[Math.ceil(g/b[0]/v[0]),Math.ceil(h/b[1]/v[1]),Math.ceil(f/b[2]/v[2])],S=pt(e[0].dataType),_=y?4:1,C=$t("a",e[0].dataType,[...s,h,m/_],_),E=$t("b",e[1].dataType,[...u,m,g/_],_),I=vt("result",e[0].dataType,[f,h,g/_],_);c.push(C),c.push(E),c.push(I);let A=[C,E],O=e.length>2,T=Qr(_,O,$,c,p,a);if(O){let t=a?_:1;A.push($t("bias",e[2].dataType,e[2].dims,t))}return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]}}),getShaderSource:e=>`\n  const dimAOuter: i32 = ${h};\n  const dimBOuter: i32 = ${g};\n  const dimInner: i32 = ${m};\n  ${e.declareVariables(...A,I)}\n  ${w}\n  ${T}\n  ${y?Yr(v,b,S,d):Jr(v,b,S,d)}\n                   ${d.impl()}`}}})),fs=P((()=>{qo(),Qo(),Zo(),ls(),ds(),ps(),ea=(e,t,n,r,a=!1,i,o=!1,s=4,u=4,l=4,d="f32")=>{let c=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",p=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",m=e?"row":"col",g=e?"col":"row",y=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${m} / outWidth;\n    let outCol = ${m} % outWidth;\n\n    let WRow = ${g} / (filterDims[1] * inChannels);\n    let WCol = ${g} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${g} % inChannels;\n    var resData = ${Gr(s,d)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\n      ${c}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(s)}\n    }\n    return resData;`,w=e?t&&r?`\n    let col = colIn * ${s};\n    ${y}`:`\n    let col = colIn * ${s};\n    if (row < dimAOuter && col < dimInner) {\n      ${y}\n    }\n    return ${Gr(s,d)}(0.0);`:r&&n?`\n    let col = colIn * ${s};\n    ${y}`:`\n    let col = colIn * ${s};\n    if (row < dimInner && col < dimBOuter) {\n      ${y}\n    }\n    return ${Gr(s,d)}(0.0);`,$=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,v=Gr(l,d),b=Gr(e?s:u,d),x=Gr(e?u:s,d);return`\n    ${Ur(i,o,4===l,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\n      ${e?w:$}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\n      ${e?$:w}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${v}) {\n      let col = colIn * ${l};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${p}\n      ${Vr(a,i)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ta=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],c=u?n[2]:n[3],p=u?n[1]:n[2],f=u?n[3]:n[1],h=u&&(l%4==0||l%3==0)&&f%4==0,m=u?f:c*p,g=u?c*p:f,y=[8,8,1],w=r<=8?[4,1,1]:[4,4,1],$=[Math.ceil(m/y[0]/w[0]),Math.ceil(g/y[1]/w[1]),Math.ceil(d/y[2]/w[2])];Ye("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${$}`));let v=h?u&&l%4!=0?3:4:w[0],b=y[1]*w[1],x=y[0]*w[0],S=Math.max(y[0]*v,y[1]),_=r%b==0,C=a%x==0,E=i%S==0,I=h?[v,4,4]:[1,1,1],A=pt(e[0].dataType),O=[`@group(0) @binding(0) var<storage, read> x: array<${h&&4===v?`vec4<${A}>`:A}>;`,`@group(0) @binding(1) var<storage, read> w: array<${h?`vec4<${A}>`:A}>;`],T=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${h?`vec4<${A}>`:A}) {\n        result[flatIndex] = ${h?`vec4<${A}>`:A}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${h?`vec4<${A}>`:A}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${h?"/ 4":""}, value);\n      }`;return o&&(O.push(`@group(0) @binding(2) var<storage, read> bias: array<${h?`vec4<${A}>`:A}>;`),T+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?`vec4<${A}>`:A} {\n          return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]}}),getShaderSource:()=>`\n        ${jr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${O.join("")}\n        @group(0) @binding(${O.length}) var<storage, read_write> result: array<${h?`vec4<${A}>`:A}>;\n        //@group(0) @binding(${O.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${ot.computeStrides(n).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${r};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${i};\n        ${T}\n        ${ea(u,_,C,E,o,t.activation.toLowerCase(),!1,I[0],I[1],I[2],A)}\n            ${h?Yr(w,y,A,void 0,!u,S):Jr(w,y,A,void 0,!u,S,!1,void 0,s)}`}}})),hs=P((()=>{Qo(),Zo(),ms(),cs(),na=(e,t,n)=>{let r=e.length>2,a=r?"value += b[output_channel];":"",i=e[0].dims,o=e[1].dims,s=o[0]/t.group,{activationFunction:u,applyActivation:l}=Fr(t),d="NHWC"===t.format,c=ra(i,o,t.dilations,t.pads,t.strides,d),p=ot.size(c),f=vt("output",e[0].dataType,c),h=$t("x",e[0].dataType,i),m=$t("w",e[1].dataType,o),g=[h,m];return r&&g.push($t("b",e[2].dataType,e[2].dims)),{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n?n(c):c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:e=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${e.declareVariables(...g,f)}\n\n  ${u}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n    let outputIndices = ${f.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${d?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${d?1:2}], outputIndices[${d?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${s}u;\n\n    var value: ${f.type.value} = ${f.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${o[1]}u; wInChannel++) {\n      let input_channel = group_id * ${o[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${o[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${i[d?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${o[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${i[d?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${d?h.get("batch","xHeight","xWidth","input_channel"):h.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${m.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${a}\n    ${l}\n    ${f.setByOffset("global_idx","value")}\n  }`}}})),ms=P((()=>{Qo(),Jo(),fs(),ps(),hs(),cs(),es(),ra=(e,t,n,r,a,i)=>{let o=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-d[t]+a[t])/a[t])));return c.splice(0,0,o),c.splice(i?3:1,0,l),c},aa=[2,3,1,0],ia=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},oa=(e,t)=>{let n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();st.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),a},sa=e=>{let t=Hr(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,i=e.group,o=e.kernel_shape,s=e.pads,u=e.strides,l=e.w_is_const();return rt({autoPad:r,format:n,dilations:a,group:i,kernelShape:o,pads:s,strides:u,wIsConst:l,...t})},ua=(e,t,n)=>{let r=oa(n,t);if(1!==n.group)return void e.compute(na(t,r));let a="NHWC"===n.format,i=3===t.length,o=t[0].dims[a?1:2],s=t[0].dims[a?2:3],u=t[0].dims[a?3:1],l=t[1].dims[2],d=t[1].dims[3],c=ra(t[0].dims,t[1].dims,n.dilations,r.pads,n.strides,a),p=c[a?1:2],f=c[a?2:3],h=c[a?3:1],m=a&&l===o&&d===s&&0===n.pads[0]&&0===n.pads[1];if(m||1===l&&1===d&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let l,d,g,y=c[0],w=[];if(a){let r=e.kernelCustomData.wT??e.compute(Ot(t[1],aa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*s*u;l=t[0].reshape([1,y,e]),d=r.reshape([1,e,h]),g=[1,y,h]}else l=t[0].reshape([y,o*s,u]),d=r.reshape([1,u,h]),g=[y,p*f,h];w.push(l),w.push(d)}else l=t[0].reshape([y,u,o*s]),d=t[1].reshape([1,h,u]),g=[y,h,p*f],w.push(d),w.push(l);return i&&w.push(t[2]),void e.compute(Zr(w,r,c,g,a),{inputs:w})}let g=e.kernelCustomData.wT??e.compute(Ot(t[1],aa),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let y=[t[0],g];i&&y.push(t[2]);let w=a?p*f:h,$=a?h:p*f,v=l*d*u;e.compute(ta(y,r,c,w,$,v,i,!0),{inputs:y})},la=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),o=[1].concat(t.dilations),s=[1].concat(t.kernelShape),u=oa({...t,pads:a,strides:i,dilations:o,kernelShape:s},r);e.compute(na(r,u,(e=>n?[e[0],e[2],e[3]]:[])))},da=(e,t)=>{ia(e.inputs,t),3===e.inputs[0].dims.length?la(e,t):ua(e,e.inputs,t)}})),gs=P((()=>{qo(),Qo(),ls(),ds(),ps(),ca=(e,t=!1,n,r=!1,a=4)=>{let i=Gr(a,"f32"),o=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",s=e?"row":"col",u=e?"col":"row",l=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${s} / outWidth;\n      let outCol = ${s} % outWidth;\n\n      let WRow = ${u} / (filterDims[1] * inChannels);\n      let WCol = ${u} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${e?"outBackprop[1]":"outBackprop[2]"}) || fract(xR) > 0.0) {\n        return ${i}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${e?"outBackprop[2]":"outBackprop[3]"}) || fract(xC) > 0.0) {\n        return ${i}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${u} % inChannels;\n      ${e?"\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      "}\n      return x[getIndexFromCoords4D(coord, xShape)/${a}];`,d=e?`\n      let col = colIn * ${a};\n      if (row < dimAOuter && col < dimInner) {\n        ${l}\n      }\n      return ${i}(0.0);`:`\n      let col = colIn * ${a};\n      if (row < dimInner && col < dimBOuter) {\n        ${l}\n      }\n      return ${i}(0.0);`,c=`\n      let col = colIn * ${a};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\n      }\n      return ${i}(0.0);\n      `;return`\n  ${Ur(n,r,4===a,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?d:c}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?c:d}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${i}) {\n    let col = colIn * ${a};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${o}\n      ${Vr(t,n)}\n      result[getIndexFromCoords4D(coords, outShape)/${a}] = value;\n    }\n  }`},pa=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],c=u?n[2]:n[3],p=u?n[1]:n[2],f=u?n[3]:n[1],h=u?l%4==0&&f%4==0:c%4==0&&f%4==0,m=u?f:c*p,g=u?c*p:f,y=h?[8,8,1]:[m<=4||g<=4?4:16,m>4&&g<=4?4:16,1],w=h?[4,4,1]:[m<=4?1:4,m>4&&g<=4?1:4,1],$=[Math.ceil(m/y[0]/w[0]),Math.ceil(g/y[1]/w[1]),Math.ceil(d/y[2]/w[2])];Ye("verbose",(()=>`[conv_backprop_mm_webgpu] dispatch = ${$}`));let v=h?4:1,b=Math.max(y[0]*v,y[1]),x=[`@group(0) @binding(0) var<storage, read> x: array<${h?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],S="";return o&&(x.push(`@group(0) @binding(2) var<storage, read> bias: array<${h?"vec4<f32>":"f32"}>;`),S+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?"vec4<f32>":"f32"} {\n          return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:$[0],y:$[1],z:$[2]}}),getShaderSource:()=>`\n        ${jr}\n        ${x.join("\n")}\n        @group(0) @binding(${x.length}) var<storage, read_write> result: array<${h?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${ot.computeStrides(n).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[u?1:2]}, ${t.kernelShape[u?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[u?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[u?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${r};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${i};\n        ${S}\n        ${ca(u,o,t.activation.toLowerCase(),!1,v)}\n        ${h?Yr(w,y,"f32",void 0,!u,b):Jr(w,y,"f32",void 0,!u,b,!1,void 0,s)}`}}})),ys=P((()=>{qo(),Qo(),Zo(),fa=(e,t,n,r,a,i,o=!1,s)=>{let u="NHWC"===n.format,l=u?1:2,d=u?2:3,c=u?3:1,p=ot.size(r),f=o?2:1,h=n.group,m=t[1].dims,g=m[0]/h,y=m[1],w=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${o?`vec4<${s}>`:s}) {\n    result[flatIndex] = ${o?`vec4<${s}>`:s}(value);\n  }`;a&&(w+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${o?`vec4<${s}>`:s} {\n      return bias[coords.${u?"w":"y"}${o?"/ 4":""}];\n    }`);let $=o?4:1,v=$t("W",t[1].dataType,t[1].dims,$),b=$t("Dy",t[0].dataType,t[0].dims,$),x=[b,v];a&&x.push($t("bias",t[2].dataType,[r[c]],$));let S=vt("result",t[0].dataType,r,$),_=`{\n        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${i?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${i?"global_id.y":"workgroup_id.y"} * ${f};\n        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${s}>, ${f}>;\n        for (var i = 0; i < ${f}; i++) {\n          dotProd[i] = vec4<${s}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${s}(dyCorner.x) + ${s}(wR)) / ${s}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${s}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${s}(dyCorner.y) + ${s}(wC)) / ${s}(strides.y);\n            let dyC2 = (${s}(dyCorner.y) + 1.0 + ${s}(wC)) / ${s}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${s}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${s}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${b.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${s}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${c}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${v.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${b.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${s}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${f}; i = i + 1) {\n          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};\n          ${S.set("batch","r","c + i","d1","value")};\n        }\n      }`,C=`\n          let outputIndices = ${S.offsetToIndices("global_idx")};\n          let batch = ${S.indicesGet("outputIndices",0)};\n          let d1 = ${S.indicesGet("outputIndices",c)};\n          let r = ${S.indicesGet("outputIndices",l)};\n          let c = ${S.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${y};\n          let wOutChannel = d1 - groupId * ${y};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${s}(dyRCorner) + ${s}(wR)) / ${s}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${s}(outBackprop[${l}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${s}(dyCCorner) + ${s}(wC)) / ${s}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${s}(outBackprop[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${g};\n              for (var d2: u32 = 0; d2 < ${g}; d2 = d2 + 1) {\n                let xValue = ${u?b.get("batch","idyR","idyC","inputChannel"):b.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${v.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${a?"bias[d1]":"0.0"};\n          ${S.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...x,S)}\n  ${w}\n  const outShape : vec4<u32> = vec4<u32>(${r.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[u?1:2]}, ${n.kernelShape[u?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${n.dilations[0]<=1?0:(n.kernelShape[u?1:2]-1)*(n.dilations[0]-1)},\n          ${n.dilations[1]<=1?0:(n.kernelShape[u?2:3]-1)*(n.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)};\n  ${o?_:C}}`},ha=(e,t,n)=>{let r=e.length>2,a=t.outputShape,i=ot.size(a),o=[Math.ceil(i/64),1,1];Ye("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${o}`));let s=pt(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:o[0],y:o[1],z:o[2]},outputs:[{dims:n?n(a):a,dataType:e[0].dataType}]}),getShaderSource:n=>fa(n,e,t,a,r,1===o[1]&&1===o[2],!1,s)}}})),ws=P((()=>{Jo(),gs(),ys(),cs(),es(),ma=(e,t,n,r,a,i)=>(e-1)*t+n+(r-1)*a+1-i,ga=(e,t,n,r,a)=>{let i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[a]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[a]=i)},ya=(e,t,n,r,a,i,o,s,u,l)=>{let d=e.length-2,c=0===l.length;if(0===u.length)for(let e=0;e<d;++e)u.push(0);let p=e[0],f=t[s?3:1]*a;for(let a=0,p=e.length-d-(s?1:0);a<d;++a,++p){let s=e[p],f=c?s*o[a]:l[a],h=ma(s,o[a],i[a],t[p],n[a],f);ga(h,r,i,a,a+d),c&&l.push(o[a]*(s-1)+u[a]+(t[p]-1)*n[a]+1-i[a]-i[a+d])}l.splice(0,0,p),l.splice(s?3:1,0,f)},wa=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let a=e.pads.slice(),i=e.outputShape.slice(),o=e.outputPadding.slice(),s=t[0].dims,u=e.dilations.slice();if(0===u.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}let l=e.strides.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}ya(s,n,u,e.autoPad,e.group,a,l,r,o,i);let d=Object.assign({},e),c=e.cacheKey+[n.join("n,"),a.join(","),l.join(","),o.join(","),i.join(","),u.join(",")].join("_");return Object.assign(d,{kernelShape:n,pads:a,outputPadding:o,outputShape:i,dilations:u,strides:l,cacheKey:c}),d},$a=e=>{let t=Hr(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,i=e.group,o=e.kernelShape,s=e.pads,u=e.strides,l=e.wIsConst(),d=e.outputPadding,c=e.outputShape;return rt({autoPad:r,format:n,dilations:a,group:i,kernelShape:o,outputPadding:d,outputShape:c,pads:s,strides:u,wIsConst:l,...t})},va=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},ba=[2,3,1,0],xa=(e,t,n)=>{let r=wa(n,t),a="NHWC"===n.format,i=3===t.length;if(1!==r.group)return void e.compute(ha(t,r));let o=r.outputShape,s=o[a?1:2],u=o[a?2:3],l=o[a?3:1],d=a?s*u:l,c=a?l:s*u,p=t[1].dims[2]*t[1].dims[3]*t[0].dims[a?3:1],f=e.kernelCustomData.wT??e.compute(Ot(t[1],ba),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=f);let h=[t[0],f];i&&(a||1!==t[2].dims.length?h.push(t[2]):h.push(t[2].reshape([t[2].dims[0],1,1]))),e.compute(pa(h,r,o,d,c,p,i,!0),{inputs:h})},Sa=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===r.length&&r.push(e.inputs[2]);let a=t.kernelShape;(0===a.length||0===a[0])&&(a=[e.inputs[1].dims[2]]);let i=t.dilations;(0===i.length||0===i[0])&&(i=[1]);let o=t.strides;(0===o.length||0===o[0])&&(o=[1]);let s=t.pads;0===s.length&&(s=[0,0]),s=[0,s[0],0,s[1]],o=[1].concat(o),i=[1].concat(i),a=[1].concat(a);let u=wa({...t,pads:s,strides:o,dilations:i,kernelShape:a},r);e.compute(ha(r,u,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])))},_a=(e,t)=>{va(e.inputs,t),3===e.inputs[0].dims.length?Sa(e,t):xa(e,e.inputs,t)}})),$s=P((()=>{Qo(),Jo(),Zo(),Ia="^"+(Ea="("+(Ca="[a-zA-Z]|\\.\\.\\.")+")+")+"$",Aa="^("+Ea+",)*"+Ea+"$",Oa=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Ta=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(Aa)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(Ia)))throw new Error("Invalid LHS term");let a=this.processTerm(t,!0,r,n);this.lhs.push(a)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(Ea)))throw new Error("Invalid RHS");r.match(RegExp(Ca,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!0,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let a=n.length,i=!1,o=[],s=0;if(!e.match(RegExp(Ia))&&!t&&""!==e)throw new Error("Invalid LHS term");let u=e.match(RegExp(Ca,"g")),l=new Oa(r);return u?.forEach(((e,d)=>{if("..."===e){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let e=a-u.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(o=n.slice(s,s+e),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=o}for(let e=0;e<o.length;e++){let t=String.fromCharCode("0".charCodeAt(0)+d);l.addSymbol(t,d+e),this.addSymbol(t,n[s++],r)}}else l.addSymbol(e,d),this.addSymbol(e,n[s++],r)})),l}},Ra=(e,t)=>{let n=e[0].dataType,r=new Array(e.length);for(let t=0;t<e.length;++t)r[t]=$t(`input${t}`,n,e[t].dims);let a=t.outputDims,i=ot.size(a),o=vt("output",n,a),s=[],u=Array.from(t.rhs.symbolToIndices.keys()),l=[],d=[],c=[],p=[],f=t.symbolToInfo.size===u.length;t.symbolToInfo.forEach(((e,n)=>{if(u.includes(n)){let a=u.indexOf(n);t.lhs.forEach(((t,i)=>{if(e.inputIndices.includes(i)){let e=t.symbolToIndices.get(n);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{s.push(`${r[i].indicesSet(`input${i}Indices`,e,o.indicesGet("outputIndices",a))}`)}))}}))}else t.lhs.forEach(((e,a)=>{let i=t.symbolToInfo.get(n);if(void 0===i)throw new Error("Invalid symbol error");if(i.inputIndices.includes(a)){let t=e.symbolToIndices.get(n);if(void 0===t)throw new Error("Invalid symbol error");t.forEach((e=>{l.push(`${r[a].indicesSet(`input${a}Indices`,e,`${n}`)}`)})),p.push(`prod *= ${r[a].getByIndices(`input${a}Indices`)};`)}})),d.push(`for(var ${n}: u32 = 0; ${n} < ${t.symbolToInfo.get(n)?.dimValue}; ${n}++) {`),c.push("}")}));let h=f?[...s,`let sum = ${r.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...s,"var sum = 0.0;",...d,...l,"var prod = 1.0;",...p,"sum += prod;",...c];return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:e=>`\n      ${e.declareVariables(...r,o)}\n\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n        var outputIndices = ${o.offsetToIndices("global_idx")};\n        ${r.map(((e,t)=>`var input${t}Indices: ${r[t].type.indices};`)).join("\n")}\n        ${h.join("\n")};\n        ${o.setByOffset("global_idx","sum")};\n      }`}},ka=(e,t)=>{let n=new Ta(e.inputs,t.equation);e.compute(Ra(e.inputs,n))},Ba=e=>{let t=e.equation.replace(/\s+/g,"");return rt({equation:t})}})),vs=P((()=>{Qo(),Zo(),Ma=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,a=t.length<n.length?0:t.length-n.length;for(;r<n.length&&a<t.length;++r,++a)if(n[r]!==t[a]&&1!==n[r]&&1!==t[a])throw new Error("Expand requires shape to be broadcastable to input")},Da=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let a=0;a<t.length;++a)r.push(1===t[a]?e[a+n]:t[a]);return r},Pa=(e,t)=>e.length>t.length?Da(e,t):Da(t,e),za=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=Pa(t,n),a=ot.size(r),i=e[0].dataType,o=$t("input",i,t),s=vt("output",i,r);return{name:"Expand",shaderCache:{hint:`${r}`},getShaderSource:e=>`\n  const inputShape = ${o.indices(...t)};\n  ${e.declareVariables(o,s)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let outputIndices = ${s.offsetToIndices("global_idx")};\n    var inputIndices: ${o.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${o.indicesGet("inputShape","i")} == 1) {\n        ${o.indicesSet("inputIndices","i",0)}\n      } else {\n        ${o.indicesSet("inputIndices","i",s.indicesGet("outputIndices","i + "+(r.length-t.length)))}\n      }\n    }\n    ${s.setByOffset("global_idx",o.getByIndices("inputIndices"))}\n  }`,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}})}},Wa=e=>{Ma(e.inputs),e.compute(za(e.inputs),{inputs:[0]})}})),bs=P((()=>{Qo(),Jo(),Zo(),Na=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},Ga=(e,t)=>{let n=e[0].dims,r=e[1].dims,a=n.length,i=ot.normalizeAxis(t.axis,a),o=n.slice(0);o.splice(i,1,...r);let s=n[i],u=ot.size(o),l=$t("data",e[0].dataType,e[0].dims),d=$t("inputIndices",e[1].dataType,e[1].dims),c=vt("output",e[0].dataType,o);return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:e=>`\n      ${e.declareVariables(l,d,c)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        let outputIndices = ${c.offsetToIndices("global_idx")};\n        ${(()=>{let e=r.length,t=`var indicesIndices  = ${d.type.indices}(0);`;for(let n=0;n<e;n++)t+=`${e>1?`indicesIndices[${n}]`:"indicesIndices"} = ${o.length>1?`outputIndices[${i+n}]`:"outputIndices"};`;t+=`\n        var idx = ${d.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${s};\n        }\n        var dataIndices = ${l.type.indices}(0);\n      `;for(let n=0,r=0;n<a;n++)n===i?(t+=(a>1?`dataIndices[${n}]`:"dataIndices")+" = u32(idx);",r+=e):(t+=`${a>1?`dataIndices[${n}]`:"dataIndices"} = ${o.length>1?`outputIndices[${r}]`:"outputIndices"};`,r++);return t})()};\n        let value = ${l.getByIndices("dataIndices")};\n        ${c.setByOffset("global_idx","value")};\n      }`}},Ua=e=>rt({axis:e.axis}),Va=(e,t)=>{let n=e.inputs;Na(n),e.compute(Ga(e.inputs,t))}})),xs=P((()=>{Qo(),Jo(),Zo(),ja=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},Fa=(e,t)=>{let n=e[0].dims,r=e[0].dataType,a=n.length,i=ot.computeStrides(n),o=ot.size(n),s=e[1].dims,u=e[1].dataType,l=ot.size(s),d=ot.normalizeAxis(t.axis,a),c=n[d],p=s.slice(0),f=ot.size(p),h=$t("input",r,n),m=$t("indices",u,[l]),g=vt("output",r,p);return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:e=>`\n      const inputStrides = array<u32, ${i.length}>(${i.map((e=>`${e}u`)).join(",")});\n      ${e.declareVariables(h,m,g)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n\n      let outputIndices = ${g.offsetToIndices("global_idx")};\n\n      var idx = ${m.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${c};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${n.length}; i++) {\n        if (i == ${d}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${g.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${o}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`}},Ha=e=>rt({axis:e.axis}),La=(e,t)=>{let n=e.inputs;ja(n),e.compute(Fa(e.inputs,t))}})),Ss=P((()=>{Qo(),Jo(),Zo(),qa=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Ya=(e,t,n)=>{if(0===n.length)return"0u";let r=1===n.length&&1!==e||2===n.length&&n[0]!==e,a=n[n.length-1]!==t,i="0u";return r||(i+=`+ m * ${n[n.length-1]}u`),a||(i+="+n"),i},Ka=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[a,i,o]=ut.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),s=[a,i];if(!s)throw new Error("Can't use gemm on the given tensors");let u=ot.size(s),l="";t.transA&&t.transB?l="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?l="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?l="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(l="value += a[m * K + k] * b[k * N + n];");let d=pt(e[0].dataType),c=1===t.alpha?"":"value *= alpha;",p=3===e.length?`value += beta * c[${Ya(a,i,e[2].dims)}];`:"",f=[`@group(0) @binding(0) var<storage, read> a : array<${d}>;`,`@group(0) @binding(1) var<storage, read> b : array<${d}>;`];return 3===e.length&&f.push(`@group(0) @binding(2) var<storage, read> c : array<${d}>;`),{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:n=>`\n  const M: u32 = ${a}u;\n  const N: u32 = ${i}u;\n  const K: u32 = ${o}u;\n  const alpha = ${d}(${t.alpha});\n  const beta = ${d}(${t.beta});\n\n  ${f.join("\n")}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${d}>;\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${d}(0);\n    for (var k: u32 = 0u; k<${o}u; k++) {\n      ${l}\n    }\n\n    ${c}\n    ${p}\n    output[global_id.x] = value;\n\n  }`}},Xa=(e,t)=>{qa(e.inputs),e.compute(Ka(e.inputs,t))},Ja=e=>rt(e)})),_s=P((()=>{Lo(),Qo(),Jo(),Zo(),Qa={name:"InstanceNormalization"},Za=(e,t)=>{let n=e[0].dims,r=n,a=ot.sizeToDimension(n,2),i=ot.sizeFromDimension(n,2),o=n[1],s=$t("x",e[0].dataType,[n[0],n[1],i]),u=$t("scale",e[1].dataType,e[1].dims),l=$t("bias",e[2].dataType,e[2].dims),d=vt("output",e[0].dataType,[n[0],n[1],i]),c=[s,u,l,d],p=s.type.value;return{...Qa,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:a}}),getShaderSource:e=>`\n\n  const C: u32 = ${o};\n  const normSize: u32 = ${i};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${p};\n  var<workgroup> squaredNormShared : ${p};\n  var<workgroup> workgroupShared : array<${p}, 64>;\n  const workgroupSize = 64u;\n  ${e.declareVariables(...c)}\n  ${e.mainStart(64)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${p} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${s.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${p}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${s.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${p}(normSize) + epsilon);\n    let channelScale = invStdDev * ${u.getByOffset("channel")};\n    let channelShift = ${l.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${s.get("batch","channel","h")} * channelScale + channelShift;\n      ${d.set("batch","channel","h","value")};\n    }\n  }`}},ei=(e,t,n,r,a,i,o,s)=>{let u=ht(o),l=$t("input",t.dataType,t.dims,u),d=$t("scale",n.dataType,n.dims,u),c=$t("bias",r.dataType,r.dims,u),p=1===u?"vec2f":`mat2x${u}f`,f=1===u?"f32":`vec${u}f`,h=(e,t)=>`${p}(${e}, ${t})`,m=a*o/u,g=Math.ceil(i/64),y=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:u,n:a,h:i,c:o})},getRunData:()=>({outputs:[{dims:[a,o,64,2],dataType:1}],dispatchGroup:{x:a*o/u}}),getShaderSource:e=>`\n  const H: u32 = ${i};\n  const C: u32 = ${o/u};\n  const imageSize: u32 = ${i*o/u};\n\n  ${e.declareVariables(l)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${p}>;\n\n  ${e.mainStart(64)}\n    let currentImageNumber = global_idx / 64 / C;\n    let currentChannelNumber = (global_idx / 64) % C;\n    let wgId = global_idx % 64;\n    let wgOffset = wgId * ${g};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${g}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${mt("f32",u)};\n    var squaredSum = ${mt("f32",u)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${f}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${h("sum","squaredSum")};\n  }`},{inputs:[t],outputs:[-1]})[0];return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:u,n:a,h:i,c:o,epsilon:s})},getRunData:()=>({outputs:[{dims:[a,o,2],dataType:1}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:e=>`\n  const H: u32 = ${i};\n  const C: u32 = ${o/u};\n  const imageSize: u32 = ${64*o/u};\n  const epsilon: f32 = ${s};\n\n  @group(0) @binding(0) var<storage, read> input : array<${p}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${d.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${c.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${p}>;\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${mt("f32",u)};\n    var squaredSum = ${mt("f32",u)};\n    for (var i: u32 = 0; i < 64; i++) {\n        let value = input[offset + i + currentChannelNumber * 64];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${f}(scale[currentChannelNumber]);\n    let channelShift = ${f}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${h("channelScale","channelShift")};\n  }`},{inputs:[y,n,r],outputs:[-1]})[0]},ti=(e,t,n)=>{let r=t[0].dims,a=r,i=r[0],o=r[r.length-1],s=ot.sizeFromDimension(r,1)/o,u=ht(o),l=ot.size(a)/u,d=$t("input",t[0].dataType,t[0].dims,u),c=vt("output",t[0].dataType,a,u),p=pt(t[0].dataType),f=1===u?"vec2f":`mat2x${u}f`,h=1===u?p:`vec${u}<${p}>`,m=ei(e,t[0],t[1],t[2],i,s,o,n.epsilon);e.compute({name:"InstanceNormalization",shaderCache:{hint:`${n.cacheKey}`},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:e=>`\n  const H: u32 = ${s};\n  const C: u32 = ${o/u};\n\n  @group(0) @binding(0) var<storage, read> input : array<${d.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${f}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${c.type.storage}>;\n\n  ${e.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${h}(scale[0]), ${h}(scale[1]));\n  }`},{inputs:[t[0],m]})},ni=e=>rt({epsilon:e.epsilon,format:e.format}),ri=(e,t)=>{"NHWC"===t.format?ti(e,e.inputs,t):e.compute(Za(e.inputs,t))}})),Cs=P((()=>{Lo(),Qo(),Jo(),Zo(),ai=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ii=(e,t,n)=>{let r=e[0].dims,a=e[1],i=e[2],o=r,s=ot.normalizeAxis(t.axis,r.length),u=ot.sizeToDimension(r,s),l=ot.sizeFromDimension(r,s),d=ot.size(a.dims),c=i?ot.size(i.dims):0;if(d!==l||i&&c!==l)throw new Error(`Size of X.shape()[axis:] == ${l}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${d} and bias size of ${c}`);let p=[];for(let e=0;e<r.length;++e)e<s?p.push(r[e]):p.push(1);let f=ht(l),h=pt(e[0].dataType),m=[$t("x",e[0].dataType,e[0].dims,f),$t("scale",a.dataType,a.dims,f)];i&&m.push($t("bias",i.dataType,i.dims,f)),m.push(vt("output",e[0].dataType,o,f));let g=n>1,y=n>2;g&&m.push(vt("meanDataOutput",1,p)),y&&m.push(vt("invStdOutput",1,p));let w=[{dims:o,dataType:e[0].dataType}];return g&&w.push({dims:p,dataType:1}),y&&w.push({dims:p,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${n}|${e.length}`},getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:e=>`\n  const normSize: f32 = ${l};\n  const normSizeVectorized: u32 = ${l/f};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${e.declareVariables(...m)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${mt("f32",f)};\n    var meanSquareVector = ${mt("f32",f)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${gt(h,f,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${yt("meanVector",f)} / normSize;\n    let meanSquare = sqrt(${yt("meanSquareVector",f)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${gt(h,f,"x[j + offset]")};\n      let f32scale = ${gt(h,f,"scale[j]")};\n      output[j + offset] = ${m[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${i?`+ ${gt(h,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${g?"meanDataOutput[global_idx] = mean":""};\n    ${y?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`}},oi=e=>rt({axis:e.axis,epsilon:e.epsilon}),si=(e,t)=>{ai(e.inputs),e.compute(ii(e.inputs,t,e.outputCount))}})),Es=P((()=>{Qo(),ps(),ui=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},li=e=>{ui(e.inputs);let t=it.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(Zr(e.inputs,{activation:"",activationCacheKey:""},t))}})),Is=P((()=>{Lo(),Qo(),Jo(),Zo(),di=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType)throw new Error("Input type must be float.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},ci=(e,t,n,r,a,i,o)=>{let s="";for(let t=n.length-1;t>=0;--t)s+=`\n            k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${n[t]}) {\n              break;\n            }\n            offset += k * ${r[t]};\n        `;return`\n          value = ${i}(${o});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${s}\n            value = x[offset];\n          }\n      `},pi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(n[t]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${n[t]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},fi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${n[t]}) {\n                  k = ${n[t]-1};\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},hi=(e,t,n,r,a)=>{let i="";for(let t=n.length-1;t>=0;--t)i+=`\n                k = i32(${e.indicesGet("indices",t)}) - ${a[t]};\n                if (k < 0)  {\n                  k += ${n[t]};\n                }\n                if (k >= ${n[t]}) {\n                  k -= ${n[t]};\n                }\n                offset += k * ${r[t]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},mi=(e,t,n,r,a,i)=>{switch(a.mode){case 0:return ci(e,0,n,r,a.pads,i,a.value);case 1:return pi(e,0,n,r,a.pads);case 2:return fi(e,0,n,r,a.pads);case 3:return hi(e,0,n,r,a.pads);default:throw new Error("Invalid mode")}},gi=(e,t,n,r)=>{let a=t[0].dims,i=ot.padShape(a.slice(),n.pads),o=ot.size(i),s=ot.computeStrides(a),u=vt("output",t[0].dataType,i),l=$t("x",t[0].dataType,a),d=mi(u,0,a,s,n,r);return`\n              ${e.declareVariables(l,u)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n              let indices = ${u.offsetToIndices("global_idx")};\n\n              var value = ${r}(0);\n              ${d}\n              output[global_idx] = value;\n          }`},yi=(e,t)=>{let n=ot.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ot.size(n)/64)}}),getShaderSource:n=>gi(n,e,t,"f32")}},wi=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,i=new Int32Array(2*a).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)i[Number(t[e])]=Number(n[e]),i[Number(t[e])+a]=Number(n[e+t.length])}else n.forEach(((e,t)=>i[Number(t)]=Number(e)));let o=[];return i.forEach((e=>o.push(e))),rt({mode:t.mode,value:r,pads:o})}return t},$i=(e,t)=>{di(e.inputs);let n=wi(e.inputs,t);e.compute(yi(e.inputs,n),{inputs:[0]})},vi=e=>{let t=e.mode,n=e.value,r=e.pads;return rt({mode:t,value:n,pads:r})}})),As=P((()=>{Qo(),Jo(),Zo(),bi=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},xi=(e,t,n)=>{let r="NHWC"===t.format,a=e.dims.slice();r&&a.splice(1,0,a.pop());let i=Object.hasOwnProperty.call(t,"dilations"),o=t.kernelShape.slice(),s=t.strides.slice(),u=i?t.dilations.slice():[],l=t.pads.slice();st.adjustPoolAttributes(n,a,o,s,u,l);let d=st.computePoolOutputShape(n,a,s,u,o,l,t.autoPad),c=Object.assign({},t);i?Object.assign(c,{kernelShape:o,strides:s,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:o,strides:s,pads:l,cacheKey:t.cacheKey});let p=d.slice();return p.push(p.splice(1,1)[0]),[c,r?p:d]},Si=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===a.format,l=n,d=t.type.value,c=l.length,p=ot.size(r),f=vt("output",t.type.tensor,r);if(a.kernelShape.length<=2){let n=a.kernelShape[a.kernelShape.length-1],r=a.strides[a.strides.length-1],h=a.pads[a.pads.length/2-1],m=c-(u?2:1),g="",y="",w="";if(g=h+a.pads[a.pads.length-1]!==0?`\n                for (var i: u32 = 0u; i < ${n}u; i++) {\n                  xIndices[${m}] = indices[${m}] * ${r} - ${h} + i;\n                  if (xIndices[${m}] < 0 || xIndices[${m}] >= ${l[m]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`:`\n                for (var i: u32 = 0u; i < ${n}u; i++) {\n                  xIndices[${m}] = indices[${m}] * ${r} - ${h} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`,2===a.kernelShape.length){let e=a.kernelShape[a.kernelShape.length-2],t=a.strides[a.strides.length-2],r=a.pads[a.pads.length/2-2],i=a.pads[a.pads.length-2],o=c-(u?3:2),s=l[o];y=r+i!==0?`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\n                  if (xIndices[${o}] < 0 || xIndices[${o}] >= ${s}) {\n                    pad+= ${n};\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\n                `,w="\n              }\n            "}return`\n            ${e.declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var value: ${d} = ${d}(${s});\n              var pad = 0;\n              ${y}\n              ${g}\n              ${w}\n              ${o}\n\n              output[global_idx] = value;\n            }`}{if(u)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let n=ot.size(a.kernelShape),r=ot.computeStrides(a.kernelShape),d=r.length,h=a.pads.length,m="";return m=a.pads.reduce(((e,t)=>e+t))?`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${i}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${i}\n            `,`\n            ${e.declareVariables(t,f)}\n\n            const pads = array<u32, ${h}>(${a.pads.map((e=>`${e}u`)).join(",")});\n            const inputDims = array<u32, ${c}>(${l.map((e=>`${e}u`)).join(",")});\n            const kernelStrides = array<u32, ${d}>(${r.map((e=>`${e}u`)).join(",")});\n            const strides = array<u32, ${d}>(${a.strides.map((e=>`${e}u`)).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              let xIndices = ${f.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${d}>;\n\n              var value = ${f.type.value}(${s});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${d-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${d-1}] = offset;\n\n                isPad = false;\n                for (var j = ${c-d}u; j < ${c}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${c-d}u]\n                    + offsets[j - ${c-d}u] - pads[j - 2u];\n                  ${m}\n              }\n              ${o}\n\n              output[global_idx] = value;\n            }`}},_i=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ci=(e,t,n,r)=>{let[a,i]=xi(t,r,n),o=ot.size(a.kernelShape),s=$t("x",t.dataType,t.dims),u=s.type.value,l="";return a.countIncludePad?l+=`value /= ${u}(${o});`:l+=`value /= ${u}(${o} - pad);`,{name:e,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ot.size(i)/64)}}),getShaderSource:e=>Si(e,s,t.dims,i,a,"value += x_val;",l,"0.0")}},Ei=e=>{let t=0!==e.count_include_pad,n=_i(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return rt({countIncludePad:t,...n})},Ii=(e,t)=>{bi(e.inputs),e.compute(Ci("AveragePool",e.inputs[0],!1,t))},Ai={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Oi=e=>{let t=e.format;return{format:t,...Ai,cacheKey:t}},Ti=(e,t)=>{bi(e.inputs),e.compute(Ci("GlobalAveragePool",e.inputs[0],!0,t))},Ri=(e,t,n,r)=>{let[a,i]=xi(t,r,n),o=$t("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ot.size(i)/64)}}),getShaderSource:e=>Si(e,o,t.dims,i,a,"\n      value = max(x_val, value);\n    ","","-1e5")}},ki=(e,t)=>{bi(e.inputs),e.compute(Ri("MaxPool",e.inputs[0],!1,t))},Bi=e=>{let t=e.storage_order,n=e.dilations,r=_i(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return rt({storageOrder:t,dilations:n,...r})},Mi=e=>{let t=e.format;return{format:t,...Ai,cacheKey:t}},Di=(e,t)=>{bi(e.inputs),e.compute(Ri("GlobalMaxPool",e.inputs[0],!0,t))}})),Os=P((()=>{re(),Lo(),Zo(),Pi=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},zi=(e,t,n,r)=>{let a=Math.abs(Math.ceil((t-e)/n)),i=[a],o=a,s=vt("output",r,i),u=s.type.storage;return{name:"Range",shaderCache:{hint:[e,t,n].map((e=>e.toString())).join("_")},getShaderSource:t=>`\n        ${t.declareVariables(s)}\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n        output[global_idx] = ${u}(${e}) + ${u}(global_idx) * ${u}(${n});\n      }`,getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)}})}},Wi=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),c.webgpu.validateInputContent&&Pi(t,n,r),e.compute(zi(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),Ts=P((()=>{Qo(),Jo(),Zo(),Ni=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},Gi=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},Ui=(e,t,n,r,a,i)=>{let[o,s,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(s>0&&e.length>s&&e[s].dims.length>0){if(e[s].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ni(r,t),t.axes.length>0&&Gi(r,t.axes,l).forEach(((e,t)=>r[t]=e))}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach((e=>a.push(Number(e)))),a.length!==l||n>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof a<"u"&&r.length>0&&a.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},Vi=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join("\n");case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",ji=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Fi=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),a=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=a[i],r[i+n]=a[t.length+i]})),r):a},Hi=(e,t,n,r)=>{let a=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>a.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>a[e]=n[t]))}else n.forEach((e=>a.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");a=e.map(((e,n)=>Math.round(e*t[n])))}return a},Li=(e,t,n,r)=>{let a=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map((e=>n[e])),Number.MAX_VALUE):Math.min(...n,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map((e=>n[e])),Number.MIN_VALUE):Math.max(...n,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();n.fill(1,0,n.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach((e=>n[e]=a)),r.axes.forEach((t=>i[t]=Math.round(e[t]*n[t])))):(n.fill(a,0,n.length),i.forEach(((e,t)=>i[t]=Math.round(e*n[t])))),i},qi=(e,t,n,r,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${n.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\n      const outputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n      const scales = array<f32, ${r.length}>(${r.map((e=>`${e}f`)).join(",")});\n      const roi = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\n      var originalIndices: array<f32, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var outputIndex = ${1===n.length?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Yi=(e,t,n,r,a,i,o)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n        const outputShape = array<u32, ${r.length}>(${r.map((e=>`${e}u`)).join(",")});\n        const scales = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\n        const roi = array<f32, ${i.length}>(${i.map((e=>`${e}f`)).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${r.length}; i++) {\n          var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${n.length}]);\n            if (!${o} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,Ki=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${1===t.length?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Xi=(e,t,n,r,a,i,o)=>{let[s,u,l,d]=2===n.length?[-1,0,1,-1]:1===a[1]?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${u}] = max(0, min(row, ${n[u]} - 1));\n      inputIndices[${l}] = max(0, min(col, ${n[l]} - 1));\n      if (${n.length} > 2) {\n        inputIndices[${d}] = channel;\n        inputIndices[${s}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${u}];\n      var col:f32 = originalIndices[${l}];\n      if (${i} && (row < 0 || row > (${n[u]} - 1) || col < 0 || col > ${n[l]} - 1)) {\n        return ${o};\n      }\n      row = max(0, min(row, ${n[u]} - 1));\n      col = max(0, min(col, ${n[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${n.length>2}) {\n        channel = u32(originalIndices[${d}]);\n        batch = u32(originalIndices[${s}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Ji=(e,t,n,r,a,i,o,s,u,l)=>{let[d,c]=2===n.length?[0,1]:1===a[1]?[2,3]:[1,2],p=o=>{let c=o===d?"row":"col";return`\n      fn ${c}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${1===r.length?"outputIndices":`outputIndices[${o}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[o]},\n        f32(${r[o]}), f32(${n[o]}), ${i[o]}, ${i[o]} + ${n.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${s} && (originalIdx < 0 || originalIdx > (${n[o]} - 1))) {\n          return ${u};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${c}: f32 = originalIdx + f32(i);\n          if (${c} < 0 || ${c} >= ${n[o]}) {\n            if (${l}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${s}) {\n              return ${u};\n            } else {\n              ${c} = max(0, min(${c}, ${n[o]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${o}] = u32(${c});\n          data[i + 1] = ${o===d?`input[${e.indicesToOffset("inputIndicesCopy")}];`:"\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);"}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${p(d)};\n    ${p(c)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};\n    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Qi=(e,t,n,r,a,i)=>{let o=e.dims,s=Fi(i,t.axes,o.length),u=Hi(o,r,a,t.axes),l=r.slice();0===r.length&&(l=o.map(((e,t)=>0===e?1:u[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(u=Li(o,0,l,t)));let d=vt("output",e.dataType,u),c=$t("input",e.dataType,o),p=ot.size(u),f=o.length===u.length&&o.every(((e,t)=>e===u[t])),h="tf_crop_and_resize"===t.coordinateTransformMode;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${l.length>0?l:""}|${a.length>0?a:""}`},getShaderSource:e=>`\n      ${Vi(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Ki(c,o)};\n              ${ji(t.nearestMode,n)};\n              ${Yi(c,d,o,u,l,s,h)};\n              `;case"linear":return`\n              ${qi(d,o,u,l,s)};\n              ${Xi(c,d,o,0,l,h,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Ji(c,d,o,u,l,s,t.cubicCoeffA,h,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${e.declareVariables(c,d)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n        if (${f}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${d.offsetToIndices("global_idx")};\n          var inputIndices: ${c.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${c.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)}})}},Zi=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},eo=(e,t)=>{let n=[],r=[],a=[],i=Zi(e);Ui(e.inputs,t,i,n,r,a),e.compute(Qi(e.inputs[0],t,i,n,r,a),{inputs:[0]})},to=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,a=e.cubicCoeffA,i=0!==e.excludeOutside,o=e.extrapolationValue,s=e.keepAspectRatioPolicy,u=e.mode,l=""===e.nearestMode?"simple":e.nearestMode;return rt({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:a,excludeOutside:i,extrapolationValue:o,keepAspectRatioPolicy:s,mode:u,nearestMode:l})}})),Rs=P((()=>{Lo(),Qo(),Jo(),Zo(),no=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},ro=(e,t,n,r)=>{let a=e[0].dims,i=a,o=ot.size(a),s=a.slice(-1)[0],u=r?a.slice(0,-1).concat(1):[],l=e.length>3,d=e.length>4,c=r&&n>1,p=r&&n>2,f=n>3,h=ht(s),m=[$t("x",e[0].dataType,e[0].dims,h),$t("skip",e[1].dataType,e[1].dims,h),$t("gamma",e[2].dataType,e[2].dims,h)];l&&m.push($t("beta",e[3].dataType,e[3].dims,h)),d&&m.push($t("bias",e[4].dataType,e[4].dims,h)),m.push(vt("output",e[0].dataType,i,h)),c&&m.push(vt("meanOutput",1,u)),p&&m.push(vt("invStdOutput",1,u)),f&&m.push(vt("inputSkipBiasSum",e[0].dataType,i,h));let g=pt(e[0].dataType),y=[{dims:i,dataType:e[0].dataType}];return n>1&&y.push({dims:u,dataType:1}),n>2&&y.push({dims:u,dataType:1}),n>3&&y.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:e=>`\n      const hiddenSize: f32 = ${s};\n      const hiddenSizeVectorized: u32 = ${s/h};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${e.declareVariables(...m)}\n\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(o/s)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${mt("f32",h)};\n        var squareSum = ${mt("f32",h)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${d?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${f?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${gt(g,h,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${yt("sum",h)} / hiddenSize;\n        let variance = sqrt(${yt("squareSum",h)} / hiddenSize - mean * mean + epsilon);\n        ${c?"meanOutput[global_idx] = mean;":""}\n        ${p?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${g}(mean)) / ${g}(variance) * gamma[i]\n           + ${l?"beta[i]":"0.0"};\n        }\n      }`,getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(o/s/64)}})}},ao=(e,t)=>{no(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(ro(e.inputs,t,e.outputCount,!1),{outputs:n})},io=e=>{let t=e.epsilon;return rt({epsilon:t})}})),ks=P((()=>{Lo(),Qo(),Jo(),Zo(),oo=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},so=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},uo=(e,t)=>{if(e.length>1){let t=so(e,1),n=so(e,2),r=so(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),rt({starts:t,ends:n,axes:r})}return t},lo=(e,t,n,r,a)=>{let i=e;return e<0&&(i+=n[r[t]]),a[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},co=(e,t,n,r)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${1===n.length?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,po=(e,t)=>{let n=e[0].dims,r=ot.size(n),a=t.axes.length>0?ot.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=so(e,4);i.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===i.length&&(i=Array(a.length).fill(1));let o=t.starts.map(((e,t)=>lo(e,t,n,a,i))),s=t.ends.map(((e,t)=>lo(e,t,n,a,i)));if(a.length!==n.length)for(let e=0;e<n.length;++e)a.includes(e)||(o.splice(e,0,0),s.splice(e,0,n[e]),i.splice(e,0,1));let u=i.map((e=>Math.sign(e)));i.forEach(((e,t,n)=>{if(e<0){let r=(s[t]-o[t])/e,a=o[t],u=a+r*i[t];o[t]=u,s[t]=a,n[t]=-e}}));let l=n.slice(0);a.forEach(((e,t)=>{l[e]=Math.ceil((s[e]-o[e])/i[e])}));let d={dims:l,dataType:e[0].dataType},c=vt("output",e[0].dataType,l),p=$t("input",e[0].dataType,n),f=ot.size(l);return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:e=>`\n      ${e.declareVariables(p,c)}\n        const signs = array<i32, ${u.length}>(${u.map((e=>`${e}i`)).join(",")});\n        const starts = array<u32, ${o.length}>(${o.map((e=>`${e}u`)).join(",")});\n        const ends = array<u32, ${s.length}>(${s.map((e=>`${e}u`)).join(",")});\n        const steps = array<u32, ${i.length}>(${i.map((e=>`${e}u`)).join(",")});\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\n\n        ${co(p,c,n,l)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n          let outputIndices = ${c.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${c.setByOffset("global_idx",p.getByIndices("inputIndices"))}\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)}})}},fo=(e,t)=>{oo(e.inputs,t);let n=uo(e.inputs,t);e.compute(po(e.inputs,n),{inputs:[0]})},ho=e=>{let t=e.starts,n=e.ends,r=e.axes;return rt({starts:t,ends:n,axes:r})}})),Bs=P((()=>{Qo(),Jo(),Zo(),mo=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},go=(e,t)=>{let n=pt(e.dataType),r=e.dims,a=ot.size(r),i=t.axis;if(i<0&&(i=r.length+i),i<r.length-1)throw new Error("softmax only supports last axis for now.");let o=r[i],s=a/o,u=ht(o),l=o/u,d=1===u?n:`vec${u}<${n}>`,c="f32"===n?`var threadMax = ${d}(-3.402823e+38f);`:`var threadMax = ${d}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:s}}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${d};\n      var<workgroup> rowSumShared : ${d};\n      var<workgroup> threadShared : array<${d}, 64>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${d}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${d}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${d} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${d}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(64, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = 64;\n        let row = gindex / wg;\n        let cols = ${l};\n        let row_stride : i32 = ${l};\n\n        // find the rows max\n        ${c}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${d}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",u)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${d}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${d}(${yt("threadShared[0]",u)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},yo=(e,t)=>{mo(e.inputs),e.compute(go(e.inputs[0],t))},wo=e=>rt({axis:e.axis})})),Ms=P((()=>{Qo(),Jo(),Zo(),$o=e=>{if(!e||e.length<1)throw new Error("too few inputs")},vo=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),rt({numOutputs:r,axis:t.axis,splitSizes:n})},bo=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,xo=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let a=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(a):0===r?n.push(`if (outputNumber == ${r}u) { ${a} }`):r===t-1?n.push(`else { ${a} }`):n.push(`else if (outputNumber == ${r}) { ${a} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},So=(e,t)=>{let n=e[0].dims,r=ot.size(n),a=e[0].dataType,i=n.length,o=t.axis,s=o<0?n.length+o:o,u=new Array(t.numOutputs),l=$t("input",a,n),d=new Array(t.numOutputs),c=[],p=[],f=0;for(let r=0;r<t.numOutputs;r++){f+=t.splitSizes[r],d[r]=f;let i=n.slice();i[t.axis]=t.splitSizes[r],p.push(i),u[r]=vt(`output${r}`,a,p[r]),c.push({dims:p[r],dataType:e[0].dataType})}let h=i<2?"indices":`indices[${s}]`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:e=>`\n  ${e.declareVariables(l,...u)}\n  const sizeInConcatAxis = array<u32, ${d.length}>(${d.map((e=>`${e}u`)).join(",")});\n  ${bo(d.length)}\n  ${xo(u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n\n    var indices = ${l.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${h});\n    if (outputNumber != 0) {\n        ${h} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`,getRunData:()=>({outputs:c,dispatchGroup:{x:Math.ceil(r/64)}})}},_o=(e,t)=>{$o(e.inputs);let n=1===e.inputs.length?t:vo(e.inputs,t);e.compute(So(e.inputs,n),{inputs:[0]})},Co=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return rt({axis:t,numOutputs:r,splitSizes:n})}})),Ds=P((()=>{Lo(),Qo(),Zo(),Eo=e=>Array.from(e.getBigInt64Array(),Number),Io=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Eo(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Ao=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Oo=e=>{let t=e[0].dims,n=Eo(e[1]),r=Ao(t,n),a=ot.size(r),i=e[0].dataType,o=$t("input",i,t),s=vt("output",i,r);return{name:"Tile",shaderCache:{hint:`${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:e=>`\n      const inputShape = ${o.indices(...t)};\n      ${e.declareVariables(o,s)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n      let outputIndices = ${s.offsetToIndices("global_idx")};\n      var inputIndices: ${o.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${s.indicesGet("outputIndices","i")}  % ${o.indicesGet("inputShape","i")};\n\n        ${o.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${s.setByOffset("global_idx",o.getByIndices("inputIndices"))}\n    }`}},To=e=>{Io(e.inputs),e.compute(Oo(e.inputs),{inputs:[0]})}})),Ps=P((()=>{Lo(),Qo(),Zo(),Ro=(e,t,n,r,a)=>{let i,o=ot.size(n),s=Math.ceil(o/4),u=vt("outputData",a,n,4),l=$t("aData",t[1].dataType,t[1].dims,4),d=$t("bData",t[2].dataType,t[2].dims,4),c=$t("cData",t[0].dataType,t[0].dims,4),p=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`,i=`bool(cData[indexC${t}] & ${4278190080>>>8*(3-t)}u)`;return`\n            let outputIndices${t} = ${u.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${l.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let offsetB${t} = ${d.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let offsetC${t} = ${c.broadcastedIndicesToOffset(`outputIndices${t}`,u)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let indexC${t} = offsetC${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${p(r,a,i)});\n          `};i=9===a?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}else i=u.setByOffset("global_idx",p(l.getByOffset("global_idx"),d.getByOffset("global_idx"),c.getByOffset("global_idx")));return`\n        ${e.declareVariables(c,l,d,u)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        ${i}\n      }`},ko=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,a=e[1].dataType,i=!(ot.areEqual(t,n)&&ot.areEqual(n,r)),o=t,s=ot.size(t);if(i){let e=it.calcShape(it.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can't perform where op on the given tensors");o=e,s=ot.size(o)}return{name:"Where",getShaderSource:t=>Ro(t,e,o,i,a),getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:Math.ceil(s/64/4)}})}},Bo=e=>{e.compute(ko(e.inputs))}})),zs=P((()=>{rs(),as(),os(),ss(),us(),ms(),ws(),$s(),vs(),bs(),xs(),Ss(),_s(),Cs(),Es(),Is(),As(),Os(),ns(),Ts(),Rs(),ks(),Bs(),Ms(),Ds(),es(),is(),Ps(),Mo=new Map([["Abs",[zn]],["Acos",[Wn]],["Acosh",[Nn]],["Add",[_r]],["ArgMax",[Tn,Rn]],["ArgMin",[On,Rn]],["Asin",[Gn]],["Asinh",[Un]],["Atan",[Vn]],["Atanh",[jn]],["AveragePool",[Ii,Ei]],["BiasAdd",[Mn]],["BiasSplitGelu",[vr]],["Cast",[Hn,Fn]],["Ceil",[Kn]],["ClipV10",[Ln]],["Clip",[Yn]],["Concat",[Wr,Nr]],["Conv",[da,sa]],["ConvTranspose",[_a,$a]],["Cos",[Xn]],["Cosh",[Jn]],["Div",[Cr]],["Einsum",[ka,Ba]],["Elu",[Zn,Qn]],["Equal",[Er]],["Erf",[tr]],["Exp",[nr]],["Expand",[Wa]],["Floor",[rr]],["FusedConv",[da,sa]],["Gather",[Va,Ua]],["GatherElements",[La,Ha]],["Gelu",[ar]],["Gemm",[Xa,Ja]],["GlobalAveragePool",[Ti,Oi]],["GlobalMaxPool",[Di,Mi]],["Greater",[Tr]],["GreaterOrEqual",[kr]],["InstanceNormalization",[ri,ni]],["LayerNormalization",[si,oi]],["LeakyRelu",[ir,Qn]],["Less",[Rr]],["LessOrEqual",[Br]],["Log",[yr]],["MatMul",[li]],["MaxPool",[ki,Bi]],["Mul",[Ir]],["Neg",[sr]],["Not",[or]],["Pad",[$i,vi]],["Pow",[Ar]],["Range",[Wi]],["Reciprocal",[ur]],["ReduceMin",[bn,En]],["ReduceMean",[gn,En]],["ReduceMax",[vn,En]],["ReduceSum",[Sn,En]],["ReduceProd",[xn,En]],["ReduceL1",[yn,En]],["ReduceL2",[wn,En]],["ReduceLogSum",[Cn,En]],["ReduceLogSumExp",[$n,En]],["ReduceSumSquare",[_n,En]],["Relu",[lr]],["Resize",[eo,to]],["Sigmoid",[dr]],["Sin",[cr]],["Sinh",[pr]],["Slice",[fo,ho]],["SkipLayerNormalization",[ao,io]],["Split",[_o,Co]],["Sqrt",[fr]],["Softmax",[yo,wo]],["Sub",[Or]],["Tan",[hr]],["Tanh",[mr]],["ThresholdedRelu",[gr,Qn]],["Tile",[To]],["Transpose",[Tt,Rt]],["Where",[Bo]]])})),Ws=P((()=>{Lo(),qo(),Zo(),Do=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,a,i,o){let s=this.backend.device,u=this.backend.getComputePassEncoder();u.setPipeline(e.computePipeline);let l=[];for(let e of r)l.push({binding:l.length,resource:{buffer:e.buffer}});for(let e of a)l.push({binding:l.length,resource:{buffer:e.buffer}});o&&l.push({binding:l.length,resource:o});let d=s.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:l,label:e.programInfo.name});if(u.setBindGroup(0,d),u.dispatchWorkgroups(...i),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(8*this.backend.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let e=this.backend.gpuDataManager.create(8*this.backend.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,e.buffer,0,8*this.backend.querySetCount),this.backend.flush();let r=this.backend.currentKernelId,a=this.backend.kernels.get(r),i=`[${a[0]}] ${a[1]}`;e.buffer.mapAsync(GPUMapMode.READ).then((()=>{let a=new BigUint64Array(e.buffer.getMappedRange()),o=a[0],s=a[1];e.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=o);let u=Number(o-this.backend.queryTimeBase),l=Number(s-this.backend.queryTimeBase);if(!Number.isSafeInteger(u)||!Number.isSafeInteger(l))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id);let d="";t.forEach(((e,t)=>{d+=`input[${t}]: [${e.dims}] | ${Pe(e.dataType)}, `}));let c="";n.forEach(((e,t)=>{c+=`output[${t}]: [${e.dims}] | ${Pe(e.dataType)}, `})),console.log(`[profiling] kernel "${r}|${i}" ${d}${c}execution time: ${l-u} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){let n=this.backend.device,r=[];n.features.has("shader-f16")&&r.push("enable f16;");let a=xt(t),i=e.getShaderSource(a),o=`${r.join("\n")}\n${a.additionalImplementations}\n${i}`,s=n.createShaderModule({code:o,label:e.name});return Ye("verbose",(()=>`[WebGPU] shader code: ${o}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:s,entryPoint:"main"},layout:"auto",label:e.name})}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&n<=a&&r<=a)return[t,n,r];let i=t*n*r,o=Math.ceil(Math.sqrt(i));if(o>a){if(o=Math.ceil(Math.cbrt(i)),o>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}return[o,o,1]}}})),Ns=P((()=>{qo(),Yo(),Xo(),zs(),Ws(),Po=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let a=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${a}`);break;case"rank":{let t=e[r].dims.length;n.push(`${a};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${a};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},zo=(e,t)=>{let n=e.name;return e.shaderCache?.hint&&(n+="["+e.shaderCache.hint+"]"),n+=`:${Po(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,n},Wo=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.querySetCount=2,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n};t.features.has("timestamp-query")&&n.push("timestamp-query"),t.features.has("shader-f16")&&n.push("shader-f16"),this.device=await t.requestDevice(r),this.gpuDataManager=tt(this),this.programManager=new Do(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Le(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!(!this.device.features.has("timestamp-query")||"default"!==this.env.webgpu.profilingMode)}run(e,t,n,r,a){let i=[];for(let e=0;e<t.length;++e){let n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);i[e]=n}let o=zo(e,t),s=this.programManager.getArtifact(o),{outputs:u,dispatchGroup:l,programUniforms:d}=e.getRunData(t),c=0===n.length?u.map(((e,t)=>t)):n;if(c.length!==u.length)throw new Error(`Output size ${c.length} must be equal to ${u.length}.`);let p,f=[],h=[];for(let e=0;e<u.length;++e){if(!Number.isInteger(c[e])||c[e]<-3||c[e]>=u.length)throw new Error(`Invalid output index: ${c[e]}`);if(-3===c[e])continue;let t=-1===c[e],n=-2===c[e],i=t||n?a(u[e].dataType,u[e].dims):r(c[e],u[e].dataType,u[e].dims),o=this.gpuDataManager.get(i.data);if(!o)throw new Error(`no GPU data for output: ${i.data}`);if(t&&this.temporaryData.push(o),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(o)}f.push(i),h.push(o)}if(d){let e=0,t=0,n=[],r=1;d.forEach((a=>{let i,o="number"==typeof a.data?[a.data]:a.data;switch(o.length){case 1:i=4;break;case 2:i=8;break;case 3:case 4:case 5:case 6:i=16;break;default:throw new Error(`unsupported data length: ${o.length}`)}(5===t||6===t)&&(i=16),i>r&&(r=i),e=Math.ceil(e/i)*i,t=o.length,n.push(e),e+=4*o.length})),e=Math.ceil(e/r)*r;let a=new ArrayBuffer(e);d.forEach(((e,t)=>{let r=n[t],i="number"==typeof e.data?[e.data]:e.data;"int32"===e.type?new Int32Array(a,r,i.length).set(i):"uint32"===e.type?new Uint32Array(a,r,i.length).set(i):new Float32Array(a,r,i.length).set(i)}));let i=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(i.buffer,0,a,0,e),this.gpuDataManager.release(i.id),p={offset:0,size:e,buffer:i.buffer}}let m=this.programManager.normalizeDispatchGroupSize(l);return s||(s=this.programManager.build(e,m),this.programManager.setArtifact(o,s)),Ye("info",(()=>`[ProgramManager] run "${e.name}" (key=${o}) with ${m[0]}x${m[1]}x${m[2]}`)),this.programManager.run(s,t,f,i,h,m,p),f}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let a=Mo.get(e);if(!a)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r,a[0],[a[1],n]])}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let[a,i,o,s]=r;if(null!==this.currentKernelId)throw new Error(`kernel "[${a}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,s[0]&&(s[1]=s[0](s[1]),s[0]=void 0),Ye("info",(()=>`[WebGPU] Start to run kernel "[${a}] ${i}"...`));let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),o(t,s[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${i}" failed. ${e}`)),1}finally{u&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${a}] ${i}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let a=this.sessionExternalDataMapping.get(e);a||(a=new Map,this.sessionExternalDataMapping.set(e,a));let i=a.get(t),o=this.gpuDataManager.registerExternalBuffer(n,r,i?.[1]);return a.set(t,[o,n]),o}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[1]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await Ze(this,e,t);return Ke(r.buffer,n)}}}})),Gs={};W(Gs,{init:()=>js});var Us,Vs,js,Fs,Hs,Ls,qs,Ys,Ks,Xs,Js,Qs,Zs,eu,tu,nu,ru,au,iu,ou,su,uu,lu,du,cu,pu,fu,hu,mu,gu,yu,wu,$u,vu,bu,xu,Su,_u,Cu,Eu,Iu,Au,Ou,Tu,Ru,ku,Bu,Mu,Du,Pu=P((()=>{Lo(),Ns(),qo(),Qo(),Us=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=ot.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(ot.size(t)!==ot.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Vs=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0;let r=e.HEAPU32,a=n>>2;this.opKernelContext=r[a++];let i=r[a++];this.outputCount=r[a++],this.customDataOffset=r[a++],this.customDataSize=r[a++];let o=[];for(let t=0;t<i;t++){let t=r[a++],n=r[a++],i=r[a++],s=[];for(let e=0;e<i;e++)s.push(r[a++]);o.push(new Us(e,t,n,s))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new Us(this.module,t,this.output(e,n),n)),((e,t)=>{let n=ze(e);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n*ot.size(t);return new Us(this.module,e,this.backend.gpuDataManager.create(r).id,t)}))}output(e,t){let n=this.module.stackSave();try{let n=this.module.stackAlloc(4*(1+t.length)),r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},js=async(e,t)=>{let n=e.jsepInit;if(n&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let r=new Wo;await r.initialize(t),n(r,(e=>r.alloc(e)),(e=>r.free(e)),((t,n,a,i=!1)=>{if(i)Ye("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${a}`)),r.memcpy(t,n);else{Ye("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${a}`));let i=e.HEAPU8.subarray(t,t+a);r.upload(n,i)}}),(async(t,n,a)=>{Ye("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${a}`)),await r.download(t,(()=>e.HEAPU8.subarray(n,n+a)))}),((n,a,i)=>r.createKernel(n,a,i,t.debug||"default"===t.webgpu.profilingMode?e.UTF8ToString(e._JsepGetNodeName(a)):`${a}`)),(e=>r.releaseKernel(e)),((t,n,a,i)=>{Ye("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${a}, kernel=${t}, contextDataOffset=${n}`));let o=new Vs(e,r,n);return r.computeKernel(t,o,i)}))}}})),zu=P((()=>{Fo(),Ho(),Lo(),Vo(),jo(),Fs=!1,Hs=e=>{let t=Ce(),n=t.stackSave();try{let n=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,n,n+4)&&Ae("Can't get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(n)}},Ls=(e,t)=>{0!==Ce()._OrtInit(e,t)&&Ae("Can't initialize onnxruntime.")},qs=async e=>{Ls(e.wasm.numThreads,Ne(e.logLevel));{let t=(Pu(),N(Gs)).init;await t(Ce(),e)}Fs=!0},Ys=new Map,Ks=()=>Fs,Xs=e=>{let t=Ce(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Js=(e,t)=>{let n=Ce(),r=0,a=0,i=0,o=[],s=[],u=[];try{[a,o]=Me(t),r=n._OrtCreateSession(e[0],e[1],a),0===r&&Ae("Can't create a session.");let[l,d]=Hs(r),c=[],p=[],f=[];for(let e=0;e<l;e++){let t=n._OrtGetInputName(r,e);0===t&&Ae("Can't get an input name."),s.push(t),c.push(n.UTF8ToString(t))}for(let e=0;e<d;e++){let a=n._OrtGetOutputName(r,e);0===a&&Ae("Can't get an output name."),u.push(a);let i=n.UTF8ToString(a);p.push(i);{let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[i]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}.`);f.push(e)}}let h=null;return f.some((e=>"gpu-buffer"===e))&&(i=n._OrtCreateBinding(r),0===i&&Ae("Can't create IO binding."),h={handle:i,outputPreferredLocations:f,outputPreferredLocationsEncoded:f.map((e=>Ue(e)))}),Ys.set(r,[r,s,u,h]),[r,c,p]}catch(e){throw s.forEach((e=>n._OrtFree(e))),u.forEach((e=>n._OrtFree(e))),0!==i&&n._OrtReleaseBinding(i),0!==r&&n._OrtReleaseSession(r),e}finally{n._free(e[0]),0!==a&&n._OrtReleaseSessionOptions(a),o.forEach((e=>n._free(e)))}},Qs=(e,t)=>{let n=Xs(e);return Js(n,t)},Zs=e=>{let t=Ce(),n=Ys.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,a,i,o]=n;o&&t._OrtReleaseBinding(o.handle),t.jsepUnregisterBuffers?.(e),a.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(r),Ys.delete(e)},eu=(e,t,n,r,a)=>{if(!e)return void t.push(0);let i,o,s=Ce(),u=e[0],l=e[1],d=e[3];if("string"===u&&"gpu-buffer"===d)throw new Error("String tensor is not supported on GPU.");if("gpu-buffer"===d){let t=e[2].gpuBuffer,n=ze(De(u));o=l.reduce(((e,t)=>e*t),1)*n,i=s.jsepRegisterBuffer(r,a,t,o)}else{let t=e[2];if(Array.isArray(t)){o=4*t.length,i=s._malloc(o),n.push(i);let e=i/4;for(let r=0;r<t.length;r++){if("string"!=typeof t[r])throw new TypeError(`tensor data at index ${r} is not a string`);s.HEAPU32[e++]=Ee(t[r],n)}}else o=t.byteLength,i=s._malloc(o),n.push(i),s.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),i)}let c=s.stackSave(),p=s.stackAlloc(4*l.length);try{let e=p/4;l.forEach((t=>s.HEAP32[e++]=t));let n=s._OrtCreateTensor(De(u),i,o,p,l.length,Ue(d));0===n&&Ae(`Can't create tensor for input/output. session=${r}, index=${a}.`),t.push(n)}finally{s.stackRestore(c)}},tu=async(e,t,n,r,a,i)=>{let o=Ce(),s=Ys.get(e);if(!s)throw new Error(`cannot run inference. invalid session id: ${e}`);let[u,l,d,c]=s,p=t.length,f=r.length,h=0,m=[],g=[],y=[],w=[],$=o.stackSave(),v=o.stackAlloc(4*p),b=o.stackAlloc(4*p),x=o.stackAlloc(4*f),S=o.stackAlloc(4*f);try{[h,m]=Oe(i);for(let r=0;r<p;r++)eu(n[r],g,w,e,t[r]);for(let t=0;t<f;t++)eu(a[t],y,w,e,p+r[t]);let s,$=v/4,_=b/4,C=x/4,E=S/4;for(let e=0;e<p;e++)o.HEAPU32[$++]=g[e],o.HEAPU32[_++]=l[t[e]];for(let e=0;e<f;e++)o.HEAPU32[C++]=y[e],o.HEAPU32[E++]=d[r[e]];if(c){let{handle:n,outputPreferredLocations:i,outputPreferredLocationsEncoded:s}=c;if(l.length!==p)throw new Error(`input count from feeds (${p}) is expected to be always equal to model's input count (${l.length}).`);for(let r=0;r<p;r++){let a=t[r];0!==await o._OrtBindInput(n,l[a],g[r])&&Ae(`Can't bind input[${r}] for session=${e}.`)}for(let t=0;t<f;t++){let u=r[t];a[t]?.[3]?0!==o._OrtBindOutput(n,d[u],y[t],0)&&Ae(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==o._OrtBindOutput(n,d[u],0,s[u])&&Ae(`Can't bind output[${t}] to ${i[t]} for session=${e}.`)}}s=c?await o._OrtRunWithBinding(u,c.handle,f,x,h):await o._OrtRun(u,b,v,p,S,f,x,h),0!==s&&Ae("failed to call OrtRun().");let I=[];for(let e=0;e<f;e++){let t=o.HEAPU32[x/4+e];if(t===y[e]){I.push(a[e]);continue}let n,i=o.stackSave(),s=o.stackAlloc(16),u=!1,l=0;try{0!==o._OrtGetTensorData(t,s,s+4,s+8,s+12)&&Ae(`Can't access output tensor data on index ${e}.`);let a=s/4,i=o.HEAPU32[a++];l=o.HEAPU32[a++];let d=o.HEAPU32[a++],p=o.HEAPU32[a++],f=[];for(let e=0;e<p;e++)f.push(o.HEAPU32[d/4+e]);o._OrtFree(d);let h=f.reduce(((e,t)=>e*t),1);n=Pe(i);let m=c?.outputPreferredLocations[r[e]];if("string"===n){if("gpu-buffer"===m)throw new Error("String tensor is not supported on GPU.");let e=[],t=l/4;for(let n=0;n<h;n++){let r=o.HEAPU32[t++],a=n===h-1?void 0:o.HEAPU32[t]-r;e.push(o.UTF8ToString(r,a))}I.push([n,f,e,"cpu"])}else if("gpu-buffer"===m&&h>0){let e=o.jsepGetBuffer(l),r=ze(i);if(void 0===r||!Ge(n))throw new Error(`Unsupported data type: ${n}`);u=!0,I.push([n,f,{gpuBuffer:e,download:o.jsepCreateDownloader(e,h*r,n),dispose:()=>{o._OrtReleaseTensor(t)}},"gpu-buffer"])}else{let e=new(We(n))(h);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(o.HEAPU8.subarray(l,l+e.byteLength)),I.push([n,f,e,"cpu"])}}finally{o.stackRestore(i),"string"===n&&l&&o._free(l),u||o._OrtReleaseTensor(t)}}return c&&o._OrtClearBoundOutputs(c.handle),I}finally{o.stackRestore($),g.forEach((e=>o._OrtReleaseTensor(e))),y.forEach((e=>o._OrtReleaseTensor(e))),w.forEach((e=>o._free(e))),0!==h&&o._OrtReleaseRunOptions(h),m.forEach((e=>o._free(e)))}},nu=e=>{let t=Ce(),n=Ys.get(e);if(!n)throw new Error("invalid session id");let r=n[0],a=t._OrtEndProfiling(r);0===a&&Ae("Can't get an profile file name."),t._OrtFree(a)},ru=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),Wu=z(((e,t)=>{t.exports='/*!\n * ONNX Runtime Web v1.17.0-dev.20231103-1439da36fe\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var on=Object.defineProperty;var Su=Object.getOwnPropertyDescriptor;var Cu=Object.getOwnPropertyNames;var Au=Object.prototype.hasOwnProperty;var H=(e,t)=>()=>(e&&(t=e(e=0)),t);var Jt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ir=(e,t)=>{for(var r in t)on(e,r,{get:t[r],enumerable:!0})},Iu=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Cu(t))!Au.call(e,n)&&n!==r&&on(e,n,{get:()=>t[n],enumerable:!(o=Su(t,n))||o.enumerable});return e};var Mt=e=>Iu(on({},"__esModule",{value:!0}),e);var an={};Ir(an,{readFile:()=>Eu});var Eu,sn=H(()=>{Eu=void 0});var un={};Ir(un,{join:()=>Tu});var Tu,ln=H(()=>{Tu=void 0});var uo=Jt((so,dn)=>{"use strict";var io=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((l,p)=>{o=l,n=p}),r.jsepInit=(l,p,h,C,T,U,G,ue)=>{r.Za=l,r.Oa=p,r.Qa=h,r.Ja=C,r.Pa=T,r.ra=U,r.Ra=G,r.Sa=ue,p=(Y,Q,J)=>(...ce)=>{let me=He,E=Q?.();ce=Y(...ce);let te=Q?.();return E!==te&&(Y=te,J(E),Q=J=null),He!=me?gr():ce},h=Y=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let J=r.Da={Ta:Q[0],errors:[]},ce=await Y(...Q);if(r.Da!==J)throw Error("Session mismatch");l.flush();let me=J.errors;if(0<me.length){let E=await Promise.all(me);if(E=E.filter(te=>te),0<E.length)throw Error(E.join(`\n`))}return ce}finally{r.Da=null}},r._OrtRun=h(p(r._OrtRun,()=>r._OrtRun,Y=>r._OrtRun=Y)),r._OrtRunWithBinding=h(p(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Y=>r._OrtRunWithBinding=Y)),r._OrtBindInput=p(r._OrtBindInput,()=>r._OrtBindInput,Y=>r._OrtBindInput=Y),r.jsepRegisterBuffer=(Y,Q,J,ce)=>l.registerBuffer(Y,Q,J,ce),r.jsepUnregisterBuffers=Y=>{l.unregisterBuffers(Y)},r.jsepGetBuffer=Y=>l.getBuffer(Y),r.jsepCreateDownloader=(Y,Q,J)=>l.createDownloader(Y,Q,J)};var s=Object.assign({},r),u="./this.program",d=(l,p)=>{throw p},a=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x="",b,w,v;if(g){var y=(sn(),Mt(an)),S=(ln(),Mt(un));x=m?S.dirname(x)+"/":__dirname+"/",b=(l,p)=>(l=l.startsWith("file://")?new URL(l):S.normalize(l),y.readFileSync(l,p?void 0:"utf8")),v=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),w=(l,p,h,C=!0)=>{l=l.startsWith("file://")?new URL(l):S.normalize(l),y.readFile(l,C?void 0:"utf8",(T,U)=>{T?h(T):p(C?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,p)=>{throw process.exitCode=l,p},r.inspect=()=>"[Emscripten Module object]"}else(a||m)&&(m?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),e&&(x=e),x.indexOf("blob:")!==0?x=x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):x="",b=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.send(null),p.responseText},m&&(v=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),w=(l,p,h)=>{var C=new XMLHttpRequest;C.open("GET",l,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?p(C.response):h()},C.onerror=h,C.send(null)});var A=r.print||console.log.bind(console),R=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(d=r.quit);var W;r.wasmBinary&&(W=r.wasmBinary);var M=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Le("no native wasm support detected");var D,_,z=!1,F,q,le,B,K,xe,ae;function we(){var l=D.buffer;r.HEAP8=q=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=B=new Int32Array(l),r.HEAPU8=le=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=K=new Uint32Array(l),r.HEAPF32=xe=new Float32Array(l),r.HEAPF64=ae=new Float64Array(l)}var j=[],Se=[],Oe=[];function Ie(){var l=r.preRun.shift();j.unshift(l)}var Ce=0,dt=null,Ne=null;function Le(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",R(l),z=!0,F=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function N(l){return l.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!N(de)){var pe=de;de=r.locateFile?r.locateFile(pe,x):x+pe}function ze(l){if(l==de&&W)return new Uint8Array(W);if(v)return v(l);throw"both async and sync fetching of the wasm failed"}function Ue(l){if(!W&&(a||m)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at \'"+l+"\'";return p.arrayBuffer()}).catch(()=>ze(l));if(w)return new Promise((p,h)=>{w(l,C=>p(new Uint8Array(C)),h)})}return Promise.resolve().then(()=>ze(l))}function Te(l,p,h){return Ue(l).then(C=>WebAssembly.instantiate(C,p)).then(C=>C).then(h,C=>{R("failed to asynchronously prepare wasm: "+C),Le(C)})}function ke(l,p){var h=de;return W||typeof WebAssembly.instantiateStreaming!="function"||N(h)||h.startsWith("file://")||g||typeof fetch!="function"?Te(h,l,p):fetch(h,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,l).then(p,function(T){return R("wasm streaming compile failed: "+T),R("falling back to ArrayBuffer instantiation"),Te(h,l,p)}))}var Ge,Xe={913792:l=>{r.ra("Abs",l,void 0)},913843:l=>{r.ra("Neg",l,void 0)},913894:l=>{r.ra("Floor",l,void 0)},913947:l=>{r.ra("Ceil",l,void 0)},913999:l=>{r.ra("Reciprocal",l,void 0)},914057:l=>{r.ra("Sqrt",l,void 0)},914109:l=>{r.ra("Exp",l,void 0)},914160:l=>{r.ra("Erf",l,void 0)},914211:l=>{r.ra("Sigmoid",l,void 0)},914266:l=>{r.ra("Log",l,void 0)},914317:l=>{r.ra("Sin",l,void 0)},914368:l=>{r.ra("Cos",l,void 0)},914419:l=>{r.ra("Tan",l,void 0)},914470:l=>{r.ra("Asin",l,void 0)},914522:l=>{r.ra("Acos",l,void 0)},914574:l=>{r.ra("Atan",l,void 0)},914626:l=>{r.ra("Sinh",l,void 0)},914678:l=>{r.ra("Cosh",l,void 0)},914730:l=>{r.ra("Asinh",l,void 0)},914783:l=>{r.ra("Acosh",l,void 0)},914836:l=>{r.ra("Atanh",l,void 0)},914889:l=>{r.ra("Tanh",l,void 0)},914941:l=>{r.ra("Not",l,void 0)},914992:(l,p,h)=>{r.ra("ClipV10",l,{min:p,max:h})},915064:l=>{r.ra("Clip",l,void 0)},915116:(l,p)=>{r.ra("Elu",l,{alpha:p})},915174:l=>{r.ra("Relu",l,void 0)},915226:(l,p)=>{r.ra("LeakyRelu",l,{alpha:p})},915290:(l,p)=>{r.ra("ThresholdedRelu",l,{alpha:p})},915360:(l,p)=>{r.ra("Cast",l,{to:p})},915418:l=>{r.ra("Add",l,void 0)},915469:l=>{r.ra("Sub",l,void 0)},915520:l=>{r.ra("Mul",l,void 0)},915571:l=>{r.ra("Div",l,void 0)},915622:l=>{r.ra("Pow",l,void 0)},915673:l=>{r.ra("Equal",l,void 0)},915726:l=>{r.ra("Greater",l,void 0)},915781:l=>{r.ra("GreaterOrEqual",l,void 0)},915843:l=>{r.ra("Less",l,void 0)},915895:l=>{r.ra("LessOrEqual",l,void 0)},915954:(l,p,h,C,T)=>{r.ra("ReduceMean",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916118:(l,p,h,C,T)=>{r.ra("ReduceMax",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916281:(l,p,h,C,T)=>{r.ra("ReduceMin",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916444:(l,p,h,C,T)=>{r.ra("ReduceProd",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916608:(l,p,h,C,T)=>{r.ra("ReduceSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916771:(l,p,h,C,T)=>{r.ra("ReduceL1",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},916933:(l,p,h,C,T)=>{r.ra("ReduceL2",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917095:(l,p,h,C,T)=>{r.ra("ReduceLogSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917261:(l,p,h,C,T)=>{r.ra("ReduceSumSquare",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917430:(l,p,h,C,T)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},917599:l=>{r.ra("Where",l,void 0)},917652:(l,p,h)=>{r.ra("Transpose",l,{perm:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[]})},917765:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[T],pads:[U,G],strides:[ue],wIsConst:()=>!!q[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},918179:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:ue?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(T>>>0,T+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!q[Y>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},918736:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:C,kernel_shape:[T],pads:[U,G],strides:[ue],wIsConst:()=>!!q[Q>>>0],outputPadding:J?Array.from(B.subarray(ce>>>0,ce+J>>>0)):[],outputShape:me?Array.from(B.subarray(E>>>0,E+me>>>0)):[],activation:_e(te)})},919150:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E)=>{r.ra("ConvTranspose",l,{format:ue?"NHWC":"NCHW",autoPad:p,dilations:Array.from(B.subarray(h>>>0,h+2>>>0)),group:C,kernelShape:Array.from(B.subarray(T>>>0,T+2>>>0)),pads:Array.from(B.subarray(U>>>0,U+4>>>0)),strides:Array.from(B.subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!q[Y>>>0],outputPadding:0<Q?Array.from(B.subarray(J>>>0,J+Q>>>0)):[],outputShape:0<ce?Array.from(B.subarray(me>>>0,me+ce>>>0)):[],activation:_e(E)})},919707:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},919798:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920082:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},920173:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920457:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},920544:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},920824:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},920911:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:C,storage_order:T,dilations:[U,G],kernel_shape:[ue,Y],pads:[Q,J,ce,me],strides:[E,te]})},921191:(l,p,h,C,T)=>{r.ra("Gemm",l,{alpha:p,beta:h,transA:C,transB:T})},921295:l=>{r.ra("MatMul",l,void 0)},921349:(l,p,h,C)=>{r.ra("ArgMax",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},921457:(l,p,h,C)=>{r.ra("ArgMin",l,{keepDims:!!p,selectLastIndex:!!h,axis:C})},921565:(l,p)=>{r.ra("Softmax",l,{axis:p})},921628:(l,p)=>{r.ra("Concat",l,{axis:p})},921688:(l,p,h,C,T)=>{r.ra("Split",l,{axis:p,numOutputs:h,splitSizes:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},921833:l=>{r.ra("Expand",l,void 0)},921887:(l,p)=>{r.ra("Gather",l,{axis:Number(p)})},921958:(l,p)=>{r.ra("GatherElements",l,{axis:Number(p)})},922037:(l,p,h,C,T,U,G,ue,Y,Q,J)=>{r.ra("Resize",l,{antialias:p,axes:h?Array.from(B.subarray(C>>>0,C+h>>>0)):[],coordinateTransformMode:_e(T),cubicCoeffA:U,excludeOutside:G,extrapolationValue:ue,keepAspectRatioPolicy:_e(Y),mode:_e(Q),nearestMode:_e(J)})},922388:(l,p,h,C,T,U,G)=>{r.ra("Slice",l,{starts:p?Array.from(B.subarray(h>>>0,h+p>>>0)):[],ends:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[],axes:U?Array.from(B.subarray(G>>>0,G+U>>>0)):[]})},922619:l=>{r.ra("Tile",l,void 0)},922671:(l,p,h)=>{r.ra("LayerNormalization",l,{axis:Number(p),epsilon:Number(h)})},922778:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},922892:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},923006:l=>{r.ra("Range",l,void 0)},923059:(l,p)=>{r.ra("Einsum",l,{equation:_e(p)})},923140:(l,p,h,C,T)=>{r.ra("Pad",l,{mode:p,value:h,pads:C?Array.from(B.subarray(T>>>0,T+C>>>0)):[]})},923272:l=>{r.ra("Gelu",l,void 0)},923324:l=>{r.ra("BiasAdd",l,void 0)},923379:l=>{r.ra("BiasSplitGelu",l,void 0)},923440:(l,p)=>{r.ra("SkipLayerNormalization",l,{epsilon:p})},923521:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me)=>{r.ra("Conv",l,{format:Y?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:C,kernel_shape:[T],pads:U?Array.from(B.subarray(G>>>0,G+U>>>0)):[],strides:[ue],w_is_const:()=>!!q[Q>>>0],activation:_e(J),activation_params:ce?Array.from(xe.subarray(me>>>0,me+ce>>>0)):[]})},923902:(l,p,h,C,T,U,G,ue,Y,Q,J,ce,me,E,te,fe)=>{r.ra("Conv",l,{format:ce?"NHWC":"NCHW",auto_pad:p,dilations:[h,C],group:T,kernel_shape:[U,G],pads:ue?Array.from(B.subarray(Y>>>0,Y+ue>>>0)):[],strides:[Q,J],w_is_const:()=>!!q[me>>>0],activation:_e(E),activation_params:te?Array.from(xe.subarray(fe>>>0,fe+te>>>0)):[]})},924304:l=>{r.Ra(l)},924338:(l,p)=>r.Sa(l,p,r.Da.Ta,r.Da.errors),924450:l=>r.Oa(l),924483:l=>r.Qa(l),924515:(l,p,h)=>{r.Ja(l,p,h,!0)},924554:(l,p,h)=>{r.Ja(l,p,h)}};function Fe(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var yt=l=>{for(;0<l.length;)l.shift()(r)};function bt(l){this.Ha=l-24,this.Ma=function(p){K[this.Ha+4>>2>>>0]=p},this.La=function(p){K[this.Ha+8>>2>>>0]=p},this.Ya=function(p,h){this.Ka(),this.Ma(p),this.La(h)},this.Ka=function(){K[this.Ha+16>>2>>>0]=0}}var Bt=0,lr=0,Ke=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,kt=(l,p,h)=>{p>>>=0;var C=p+h;for(h=p;l[h]&&!(h>=C);)++h;if(16<h-p&&l.buffer&&Ke)return Ke.decode(l.subarray(p,h));for(C="";p<h;){var T=l[p++];if(T&128){var U=l[p++]&63;if((T&224)==192)C+=String.fromCharCode((T&31)<<6|U);else{var G=l[p++]&63;T=(T&240)==224?(T&15)<<12|U<<6|G:(T&7)<<18|U<<12|G<<6|l[p++]&63,65536>T?C+=String.fromCharCode(T):(T-=65536,C+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else C+=String.fromCharCode(T)}return C},_e=(l,p)=>(l>>>=0)?kt(le,l,p):"",It=l=>{for(var p=0,h=0;h<l.length;++h){var C=l.charCodeAt(h);127>=C?p++:2047>=C?p+=2:55296<=C&&57343>=C?(p+=4,++h):p+=3}return p},Dt=(l,p,h,C)=>{if(h>>>=0,!(0<C))return 0;var T=h;C=h+C-1;for(var U=0;U<l.length;++U){var G=l.charCodeAt(U);if(55296<=G&&57343>=G){var ue=l.charCodeAt(++U);G=65536+((G&1023)<<10)|ue&1023}if(127>=G){if(h>=C)break;p[h++>>>0]=G}else{if(2047>=G){if(h+1>=C)break;p[h++>>>0]=192|G>>6}else{if(65535>=G){if(h+2>=C)break;p[h++>>>0]=224|G>>12}else{if(h+3>=C)break;p[h++>>>0]=240|G>>18,p[h++>>>0]=128|G>>12&63}p[h++>>>0]=128|G>>6&63}p[h++>>>0]=128|G&63}}return p[h>>>0]=0,h-T},at=l=>l%4===0&&(l%100!==0||l%400===0),dr=[0,31,60,91,121,152,182,213,244,274,305,335],it=[0,31,59,90,120,151,181,212,243,273,304,334],Et=l=>{var p=It(l)+1,h=Rt(p);return h&&Dt(l,le,h,p),h},ct=[],Tt=(l,p)=>{ct.length=0;var h;for(p>>=2;h=le[l++>>>0];)p+=h!=105&p,ct.push(h==105?B[p>>>0]:ae[p++>>>1]),++p;return ct},Ot={},Wt=()=>{if(!_t){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},p;for(p in Ot)Ot[p]===void 0?delete l[p]:l[p]=Ot[p];var h=[];for(p in l)h.push(`${p}=${l[p]}`);_t=h}return _t},_t,cr=[null,[],[]],Ve=[31,29,31,30,31,30,31,31,30,31,30,31],zt=[31,28,31,30,31,30,31,31,30,31,30,31];function Vt(l){var p=Array(It(l)+1);return Dt(l,p,0,p.length),p}function ne(l,p,h,C){function T(E,te,fe){for(E=typeof E=="number"?E.toString():E||"";E.length<te;)E=fe[0]+E;return E}function U(E,te){return T(E,te,"0")}function G(E,te){function fe(Xt){return 0>Xt?-1:0<Xt?1:0}var ut;return(ut=fe(E.getFullYear()-te.getFullYear()))===0&&(ut=fe(E.getMonth()-te.getMonth()))===0&&(ut=fe(E.getDate()-te.getDate())),ut}function ue(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function Y(E){var te=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<te;){var fe=E.getMonth(),ut=(at(E.getFullYear())?Ve:zt)[fe];if(te>ut-E.getDate())te-=ut-E.getDate()+1,E.setDate(1),11>fe?E.setMonth(fe+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+te);break}}return fe=new Date(E.getFullYear()+1,0,4),te=ue(new Date(E.getFullYear(),0,4)),fe=ue(fe),0>=G(te,E)?0>=G(fe,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}l>>>=0,p>>>=0,h>>>=0,C>>>=0;var Q=B[C+40>>2>>>0];C={Wa:B[C>>2>>>0],Va:B[C+4>>2>>>0],Ea:B[C+8>>2>>>0],Ia:B[C+12>>2>>>0],Fa:B[C+16>>2>>>0],Ca:B[C+20>>2>>>0],wa:B[C+24>>2>>>0],Ba:B[C+28>>2>>>0],$a:B[C+32>>2>>>0],Ua:B[C+36>>2>>>0],Xa:Q?_e(Q):""},h=_e(h),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var J in Q)h=h.replace(new RegExp(J,"g"),Q[J]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),me="January February March April May June July August September October November December".split(" ");Q={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>me[E.Fa].substring(0,3),"%B":E=>me[E.Fa],"%C":E=>U((E.Ca+1900)/100|0,2),"%d":E=>U(E.Ia,2),"%e":E=>T(E.Ia,2," "),"%g":E=>Y(E).toString().substring(2),"%G":E=>Y(E),"%H":E=>U(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),U(E,2)),"%j":E=>{for(var te=0,fe=0;fe<=E.Fa-1;te+=(at(E.Ca+1900)?Ve:zt)[fe++]);return U(E.Ia+te,3)},"%m":E=>U(E.Fa+1,2),"%M":E=>U(E.Va,2),"%n":()=>`\n`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>U(E.Wa,2),"%t":()=>"\t","%u":E=>E.wa||7,"%U":E=>U(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var te=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&te++,te)te==53&&(fe=(E.wa+371-E.Ba)%7,fe==4||fe==3&&at(E.Ca)||(te=1));else{te=52;var fe=(E.wa+7-E.Ba-1)%7;(fe==4||fe==5&&at(E.Ca%400-1))&&te++}return U(te,2)},"%w":E=>E.wa,"%W":E=>U(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var te=0<=E;return E=Math.abs(E)/60,(te?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},h=h.replace(/%%/g,"\\0\\0");for(J in Q)h.includes(J)&&(h=h.replace(new RegExp(J,"g"),Q[J](C)));return h=h.replace(/\\0\\0/g,"%"),J=Vt(h),J.length>p?0:(q.set(J,l>>>0),J.length-1)}function st(l){try{l()}catch(p){Le(p)}}function pr(l){var p={},h;for(h in l)(function(C){var T=l[C];p[C]=typeof T=="function"?function(){wt.push(C);try{return T.apply(null,arguments)}finally{z||(wt.pop()===C||Le(),He&&Je===1&&wt.length===0&&(Je=0,st(qt),typeof Fibers<"u"&&Fibers.ab()))}}:T})(h);return p}var Je=0,He=null,fr=0,wt=[],Gt={},Nt={},mr=0,vt=null,hr=[];function gr(){return new Promise((l,p)=>{vt={resolve:l,reject:p}})}function yr(){var l=Rt(65548),p=l+12;K[l>>2>>>0]=p,K[l+4>>2>>>0]=p+65536,p=wt[0];var h=Gt[p];return h===void 0&&(h=mr++,Gt[p]=h,Nt[h]=p),B[l+8>>2>>>0]=h,l}function br(l){if(!z){if(Je===0){var p=!1,h=!1;l((C=0)=>{if(!z&&(fr=C,p=!0,h)){Je=2,st(()=>Pt(He)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var T=(0,_[Nt[B[He+8>>2>>>0]]])()}catch(ue){T=ue,C=!0}var U=!1;if(!He){var G=vt;G&&(vt=null,(C?G.reject:G.resolve)(T),U=!0)}if(C&&!U)throw T}}),h=!0,p||(Je=1,He=yr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),st(()=>Kt(He)))}else Je===2?(Je=0,st($t),Ut(He),He=null,hr.forEach(C=>{if(!z)try{if(C(),!M)try{F=F=C=F,M||(r.onExit&&r.onExit(C),z=!0),d(C,new Fe(C))}catch(T){T instanceof Fe||T=="unwind"||d(1,T)}}catch(T){T instanceof Fe||T=="unwind"||d(1,T)}})):Le(`invalid state: ${Je}`);return fr}}function wr(l){return br(p=>{l().then(p)})}var vr={n:function(l,p,h){return wr(async()=>{await r.Pa(l,p,h)})},a:function(l,p,h){throw l>>>=0,new bt(l).Ya(p>>>0,h>>>0),Bt=l,lr++,Bt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getUTCSeconds(),B[h+4>>2>>>0]=l.getUTCMinutes(),B[h+8>>2>>>0]=l.getUTCHours(),B[h+12>>2>>>0]=l.getUTCDate(),B[h+16>>2>>>0]=l.getUTCMonth(),B[h+20>>2>>>0]=l.getUTCFullYear()-1900,B[h+24>>2>>>0]=l.getUTCDay(),B[h+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),B[h>>2>>>0]=l.getSeconds(),B[h+4>>2>>>0]=l.getMinutes(),B[h+8>>2>>>0]=l.getHours(),B[h+12>>2>>>0]=l.getDate(),B[h+16>>2>>>0]=l.getMonth(),B[h+20>>2>>>0]=l.getFullYear()-1900,B[h+24>>2>>>0]=l.getDay(),B[h+28>>2>>>0]=(at(l.getFullYear())?dr:it)[l.getMonth()]+l.getDate()-1|0,B[h+36>>2>>>0]=-(60*l.getTimezoneOffset()),p=new Date(l.getFullYear(),6,1).getTimezoneOffset();var C=new Date(l.getFullYear(),0,1).getTimezoneOffset();B[h+32>>2>>>0]=(p!=C&&l.getTimezoneOffset()==Math.min(C,p))|0},s:function(l){l>>>=0;var p=new Date(B[l+20>>2>>>0]+1900,B[l+16>>2>>>0],B[l+12>>2>>>0],B[l+8>>2>>>0],B[l+4>>2>>>0],B[l>>2>>>0],0),h=B[l+32>>2>>>0],C=p.getTimezoneOffset(),T=new Date(p.getFullYear(),6,1).getTimezoneOffset(),U=new Date(p.getFullYear(),0,1).getTimezoneOffset(),G=Math.min(U,T);return 0>h?B[l+32>>2>>>0]=+(T!=U&&G==C):0<h!=(G==C)&&(T=Math.max(U,T),p.setTime(p.getTime()+6e4*((0<h?G:T)-C))),B[l+24>>2>>>0]=p.getDay(),B[l+28>>2>>>0]=(at(p.getFullYear())?dr:it)[p.getMonth()]+p.getDate()-1|0,B[l>>2>>>0]=p.getSeconds(),B[l+4>>2>>>0]=p.getMinutes(),B[l+8>>2>>>0]=p.getHours(),B[l+12>>2>>>0]=p.getDate(),B[l+16>>2>>>0]=p.getMonth(),B[l+20>>2>>>0]=p.getYear(),l=p.getTime()/1e3,Lt((Ge=l,1<=+Math.abs(Ge)?0<Ge?+Math.floor(Ge/4294967296)>>>0:~~+Math.ceil((Ge-+(~~Ge>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,p,h){function C(Y){return(Y=Y.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Y[1]:"GMT"}h>>>=0;var T=new Date().getFullYear(),U=new Date(T,0,1),G=new Date(T,6,1);T=U.getTimezoneOffset();var ue=G.getTimezoneOffset();K[l>>>0>>2>>>0]=60*Math.max(T,ue),B[p>>>0>>2>>>0]=+(T!=ue),l=C(U),p=C(G),l=Et(l),p=Et(p),ue<T?(K[h>>2>>>0]=l,K[h+4>>2>>>0]=p):(K[h>>2>>>0]=p,K[h+4>>2>>>0]=l)},e:()=>{Le("")},b:function(l,p,h){return l>>>=0,p=Tt(p>>>0,h>>>0),Xe[l].apply(null,p)},i:function(l,p,h){return l>>>=0,p=Tt(p>>>0,h>>>0),Xe[l].apply(null,p)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,p,h){return p>>>=0,le.copyWithin(l>>>0>>>0,p>>>0,p+(h>>>0)>>>0)},u:function(l){l>>>=0;var p=le.length;if(4294901760<l)return!1;for(var h=1;4>=h;h*=2){var C=p*(1+.2/h);C=Math.min(C,l+100663296);var T=Math;C=Math.max(l,C);e:{T=T.min.call(T,4294901760,C+(65536-C%65536)%65536)-D.buffer.byteLength+65535>>>16;try{D.grow(T),we();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(l,p){l>>>=0,p>>>=0;var h=0;return Wt().forEach(function(C,T){var U=p+h;for(T=K[l+4*T>>2>>>0]=U,U=0;U<C.length;++U)q[T++>>0>>>0]=C.charCodeAt(U);q[T>>0>>>0]=0,h+=C.length+1}),0},E:function(l,p){l>>>=0,p>>>=0;var h=Wt();K[l>>2>>>0]=h.length;var C=0;return h.forEach(function(T){C+=T.length+1}),K[p>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,p,h,C){p>>>=0,h>>>=0,C>>>=0;for(var T=0,U=0;U<h;U++){var G=K[p>>2>>>0],ue=K[p+4>>2>>>0];p+=8;for(var Y=0;Y<ue;Y++){var Q=le[G+Y>>>0],J=cr[l];Q===0||Q===10?((l===1?A:R)(kt(J,0)),J.length=0):J.push(Q)}T+=ue}return K[C>>2>>>0]=T,0},F:ne,d:function(l,p,h,C){return ne(l>>>0,p>>>0,h>>>0,C>>>0)}};(function(){function l(h){if(h=h.exports,h=pr(h),_=h=pt(h),D=_.M,we(),Se.unshift(_.N),Ce--,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),Ce==0&&(dt!==null&&(clearInterval(dt),dt=null),Ne)){var C=Ne;Ne=null,C()}return h}var p={a:vr};if(Ce++,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),r.instantiateWasm)try{return r.instantiateWasm(p,l)}catch(h){R("Module.instantiateWasm callback failed with error: "+h),n(h)}return ke(p,function(h){l(h.instance)}).catch(n),{}})(),r._OrtInit=(l,p)=>(r._OrtInit=_.O)(l,p),r._OrtGetLastError=(l,p)=>(r._OrtGetLastError=_.P)(l,p),r._OrtCreateSessionOptions=(l,p,h,C,T,U,G,ue,Y,Q)=>(r._OrtCreateSessionOptions=_.Q)(l,p,h,C,T,U,G,ue,Y,Q),r._OrtAppendExecutionProvider=(l,p)=>(r._OrtAppendExecutionProvider=_.R)(l,p),r._OrtAddFreeDimensionOverride=(l,p,h)=>(r._OrtAddFreeDimensionOverride=_.S)(l,p,h),r._OrtAddSessionConfigEntry=(l,p,h)=>(r._OrtAddSessionConfigEntry=_.T)(l,p,h),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=_.U)(l),r._OrtCreateSession=(l,p,h)=>(r._OrtCreateSession=_.V)(l,p,h),r._OrtReleaseSession=l=>(r._OrtReleaseSession=_.W)(l),r._OrtGetInputOutputCount=(l,p,h)=>(r._OrtGetInputOutputCount=_.X)(l,p,h),r._OrtGetInputName=(l,p)=>(r._OrtGetInputName=_.Y)(l,p),r._OrtGetOutputName=(l,p)=>(r._OrtGetOutputName=_.Z)(l,p),r._OrtFree=l=>(r._OrtFree=_._)(l),r._OrtCreateTensor=(l,p,h,C,T,U)=>(r._OrtCreateTensor=_.$)(l,p,h,C,T,U),r._OrtGetTensorData=(l,p,h,C,T)=>(r._OrtGetTensorData=_.aa)(l,p,h,C,T),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=_.ba)(l),r._OrtCreateRunOptions=(l,p,h,C)=>(r._OrtCreateRunOptions=_.ca)(l,p,h,C),r._OrtAddRunConfigEntry=(l,p,h)=>(r._OrtAddRunConfigEntry=_.da)(l,p,h),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=_.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=_.fa)(l),r._OrtBindInput=(l,p,h)=>(r._OrtBindInput=_.ga)(l,p,h),r._OrtBindOutput=(l,p,h,C)=>(r._OrtBindOutput=_.ha)(l,p,h,C),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=_.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=_.ja)(l),r._OrtRunWithBinding=(l,p,h,C,T)=>(r._OrtRunWithBinding=_.ka)(l,p,h,C,T),r._OrtRun=(l,p,h,C,T,U,G,ue)=>(r._OrtRun=_.la)(l,p,h,C,T,U,G,ue),r._OrtEndProfiling=l=>(r._OrtEndProfiling=_.ma)(l),r._JsepOutput=(l,p,h)=>(r._JsepOutput=_.na)(l,p,h),r._JsepGetNodeName=l=>(r._JsepGetNodeName=_.oa)(l);var Rt=r._malloc=l=>(Rt=r._malloc=_.pa)(l),Ut=r._free=l=>(Ut=r._free=_.qa)(l),Lt=l=>(Lt=_.sa)(l),Ft=()=>(Ft=_.ta)(),Ht=l=>(Ht=_.ua)(l),jt=l=>(jt=_.va)(l),Kt=l=>(Kt=_.xa)(l),qt=()=>(qt=_.ya)(),Pt=l=>(Pt=_.za)(l),$t=()=>($t=_.Aa)();r.___start_em_js=924587,r.___stop_em_js=924748;function pt(l){l=Object.assign({},l);var p=C=>()=>C()>>>0,h=C=>T=>C(T)>>>0;return l.__errno_location=p(l.__errno_location),l.malloc=h(l.malloc),l.stackSave=p(l.stackSave),l.stackAlloc=h(l.stackAlloc),l}r.stackAlloc=jt,r.stackSave=Ft,r.stackRestore=Ht,r.UTF8ToString=_e,r.stringToUTF8=(l,p,h)=>Dt(l,le,p,h),r.lengthBytesUTF8=It;var xt;Ne=function l(){xt||Yt(),xt||(Ne=l)};function Yt(){function l(){if(!xt&&(xt=!0,r.calledRun=!0,!z)){if(yt(Se),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var p=r.postRun.shift();Oe.unshift(p)}yt(Oe)}}if(!(0<Ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ie();yt(j),0<Ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Yt(),t.ready}})();typeof so=="object"&&typeof dn=="object"?dn.exports=io:typeof define=="function"&&define.amd&&define([],()=>io)});var lo=Jt(()=>{});var co=Jt(()=>{});var po={};Ir(po,{cpus:()=>Ou});var Ou,fo=H(()=>{Ou=void 0});var go=Jt((ho,cn)=>{"use strict";var mo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=Ce.buffer&&pe(),Ce}function o(){return we.buffer!=Ce.buffer&&pe(),dt}function n(){return we.buffer!=Ce.buffer&&pe(),Ne}function s(){return we.buffer!=Ce.buffer&&pe(),Le}function u(){return we.buffer!=Ce.buffer&&pe(),N}function d(){return we.buffer!=Ce.buffer&&pe(),de}var a=t,m,g;a.ready=new Promise((i,c)=>{m=i,g=c}),a.jsepInit=(i,c,f,$,I,P,V,oe)=>{a.Qb=i,a.wb=c,a.yb=f,a.jb=$,a.xb=I,a.Ea=P,a.zb=V,a.Ab=oe,c=(ee,Z,re)=>(...he)=>{let be=Ze,O=Z?.();he=ee(...he);let se=Z?.();return O!==se&&(ee=se,re(O),Z=re=null),Ze!=be?hu():he},f=ee=>async(...Z)=>{try{if(a.bb)throw Error("Session already started");let re=a.bb={Fb:Z[0],errors:[]},he=await ee(...Z);if(a.bb!==re)throw Error("Session mismatch");i.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(se=>se),0<O.length)throw Error(O.join(`\n`))}return he}finally{a.bb=null}},a._OrtRun=f(c(a._OrtRun,()=>a._OrtRun,ee=>a._OrtRun=ee)),a._OrtRunWithBinding=f(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,ee=>a._OrtRunWithBinding=ee)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,ee=>a._OrtBindInput=ee),a.jsepRegisterBuffer=(ee,Z,re,he)=>i.registerBuffer(ee,Z,re,he),a.jsepUnregisterBuffers=ee=>{i.unregisterBuffers(ee)},a.jsepGetBuffer=ee=>i.getBuffer(ee),a.jsepCreateDownloader=(ee,Z,re)=>i.createDownloader(ee,Z,re)};var x=Object.assign({},a),b="./this.program",w=(i,c)=>{throw c},v=typeof window=="object",y=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=a.ENVIRONMENT_IS_PTHREAD||!1,R="";function W(i){return a.locateFile?a.locateFile(i,R):R+i}var M,D,_;if(S){var z=(sn(),Mt(an)),F=(ln(),Mt(un));R=y?F.dirname(R)+"/":__dirname+"/",M=(c,f)=>(c=c.startsWith("file://")?new URL(c):F.normalize(c),z.readFileSync(c,f?void 0:"utf8")),_=c=>(c=M(c,!0),c.buffer||(c=new Uint8Array(c)),c),D=(c,f,$,I=!0)=>{c=c.startsWith("file://")?new URL(c):F.normalize(c),z.readFile(c,I?void 0:"utf8",(P,V)=>{P?$(P):f(I?V.buffer:V)})},!a.thisProgram&&1<process.argv.length&&(b=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),w=(c,f)=>{throw process.exitCode=c,f},a.inspect=()=>"[Emscripten Module object]";let i;try{i=lo()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else(v||y)&&(y?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.indexOf("blob:")!==0?R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1):R="",S||(M=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},y&&(_=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),D=(i,c,f)=>{var $=new XMLHttpRequest;$.open("GET",i,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?c($.response):f()},$.onerror=f,$.send(null)}));S&&typeof performance>"u"&&(global.performance=co().performance);var q=console.log.bind(console),le=console.error.bind(console);S&&(q=(...i)=>z.writeSync(1,i.join(" ")+`\n`),le=(...i)=>z.writeSync(2,i.join(" ")+`\n`));var B=a.print||q,K=a.printErr||le;Object.assign(a,x),x=null,a.thisProgram&&(b=a.thisProgram),a.quit&&(w=a.quit);var xe;a.wasmBinary&&(xe=a.wasmBinary);var ae=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Ke("no native wasm support detected");var we,j,Se,Oe=!1,Ie,Ce,dt,Ne,Le,N,de;function pe(){var i=we.buffer;a.HEAP8=Ce=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAP32=Ne=new Int32Array(i),a.HEAPU8=dt=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAPU32=Le=new Uint32Array(i),a.HEAPF32=N=new Float32Array(i),a.HEAPF64=de=new Float64Array(i)}var ze=a.INITIAL_MEMORY||16777216;if(5242880<=ze||Ke("INITIAL_MEMORY should be larger than STACK_SIZE, was "+ze+"! (STACK_SIZE=5242880)"),A)we=a.wasmMemory;else if(a.wasmMemory)we=a.wasmMemory;else if(we=new WebAssembly.Memory({initial:ze/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),ze=we.buffer.byteLength;var Ue=[],Te=[],ke=[],Ge=0;function Xe(){return ae||0<Ge}var Fe=0,yt=null,bt=null;function Bt(){Fe++,a.monitorRunDependencies&&a.monitorRunDependencies(Fe)}function lr(){if(Fe--,a.monitorRunDependencies&&a.monitorRunDependencies(Fe),Fe==0&&(yt!==null&&(clearInterval(yt),yt=null),bt)){var i=bt;bt=null,i()}}function Ke(i){throw a.onAbort&&a.onAbort(i),i="Aborted("+i+")",K(i),Oe=!0,Ie=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),g(i),i}function kt(i){return i.startsWith("data:application/octet-stream;base64,")}var _e;_e="ort-wasm-simd-threaded.wasm",kt(_e)||(_e=W(_e));function It(i){if(i==_e&&xe)return new Uint8Array(xe);if(_)return _(i);throw"both async and sync fetching of the wasm failed"}function Dt(i){if(!xe&&(v||y)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>It(i));if(D)return new Promise((c,f)=>{D(i,$=>c(new Uint8Array($)),f)})}return Promise.resolve().then(()=>It(i))}function at(i,c,f){return Dt(i).then($=>WebAssembly.instantiate($,c)).then($=>$).then(f,$=>{K("failed to asynchronously prepare wasm: "+$),Ke($)})}function dr(i,c){var f=_e;return xe||typeof WebAssembly.instantiateStreaming!="function"||kt(f)||f.startsWith("file://")||S||typeof fetch!="function"?at(f,i,c):fetch(f,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,i).then(c,function(I){return K("wasm streaming compile failed: "+I),K("falling back to ArrayBuffer instantiation"),at(f,i,c)}))}var it,Et={914988:i=>{a.Ea("Abs",i,void 0)},915039:i=>{a.Ea("Neg",i,void 0)},915090:i=>{a.Ea("Floor",i,void 0)},915143:i=>{a.Ea("Ceil",i,void 0)},915195:i=>{a.Ea("Reciprocal",i,void 0)},915253:i=>{a.Ea("Sqrt",i,void 0)},915305:i=>{a.Ea("Exp",i,void 0)},915356:i=>{a.Ea("Erf",i,void 0)},915407:i=>{a.Ea("Sigmoid",i,void 0)},915462:i=>{a.Ea("Log",i,void 0)},915513:i=>{a.Ea("Sin",i,void 0)},915564:i=>{a.Ea("Cos",i,void 0)},915615:i=>{a.Ea("Tan",i,void 0)},915666:i=>{a.Ea("Asin",i,void 0)},915718:i=>{a.Ea("Acos",i,void 0)},915770:i=>{a.Ea("Atan",i,void 0)},915822:i=>{a.Ea("Sinh",i,void 0)},915874:i=>{a.Ea("Cosh",i,void 0)},915926:i=>{a.Ea("Asinh",i,void 0)},915979:i=>{a.Ea("Acosh",i,void 0)},916032:i=>{a.Ea("Atanh",i,void 0)},916085:i=>{a.Ea("Tanh",i,void 0)},916137:i=>{a.Ea("Not",i,void 0)},916188:(i,c,f)=>{a.Ea("ClipV10",i,{min:c,max:f})},916260:i=>{a.Ea("Clip",i,void 0)},916312:(i,c)=>{a.Ea("Elu",i,{alpha:c})},916370:i=>{a.Ea("Relu",i,void 0)},916422:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},916486:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},916556:(i,c)=>{a.Ea("Cast",i,{to:c})},916614:i=>{a.Ea("Add",i,void 0)},916665:i=>{a.Ea("Sub",i,void 0)},916716:i=>{a.Ea("Mul",i,void 0)},916767:i=>{a.Ea("Div",i,void 0)},916818:i=>{a.Ea("Pow",i,void 0)},916869:i=>{a.Ea("Equal",i,void 0)},916922:i=>{a.Ea("Greater",i,void 0)},916977:i=>{a.Ea("GreaterOrEqual",i,void 0)},917039:i=>{a.Ea("Less",i,void 0)},917091:i=>{a.Ea("LessOrEqual",i,void 0)},917150:(i,c,f,$,I)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917314:(i,c,f,$,I)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917477:(i,c,f,$,I)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917640:(i,c,f,$,I)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917804:(i,c,f,$,I)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},917967:(i,c,f,$,I)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918129:(i,c,f,$,I)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918291:(i,c,f,$,I)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918457:(i,c,f,$,I)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918626:(i,c,f,$,I)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},918795:i=>{a.Ea("Where",i,void 0)},918848:(i,c,f)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[]})},918961:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se)=>{a.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[I],pads:[P,V],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ve(se)})},919375:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O)=>{a.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(P>>>0,P+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ve(O)})},919932:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se)=>{a.Ea("ConvTranspose",i,{format:ee?"NHWC":"NCHW",autoPad:c,dilations:[f],group:$,kernel_shape:[I],pads:[P,V],strides:[oe],wIsConst:()=>!!r()[Z>>>0],outputPadding:re?Array.from(n().subarray(he>>>0,he+re>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:Ve(se)})},920346:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O)=>{a.Ea("ConvTranspose",i,{format:oe?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:$,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(P>>>0,P+4>>>0)),strides:Array.from(n().subarray(V>>>0,V+2>>>0)),wIsConst:()=>!!r()[ee>>>0],outputPadding:0<Z?Array.from(n().subarray(re>>>0,re+Z>>>0)):[],outputShape:0<he?Array.from(n().subarray(be>>>0,be+he>>>0)):[],activation:Ve(O)})},920903:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},920994:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},921278:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},921369:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},921653:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},921740:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},922020:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},922107:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:$,storage_order:I,dilations:[P,V],kernel_shape:[oe,ee],pads:[Z,re,he,be],strides:[O,se]})},922387:(i,c,f,$,I)=>{a.Ea("Gemm",i,{alpha:c,beta:f,transA:$,transB:I})},922491:i=>{a.Ea("MatMul",i,void 0)},922545:(i,c,f,$)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},922653:(i,c,f,$)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!f,axis:$})},922761:(i,c)=>{a.Ea("Softmax",i,{axis:c})},922824:(i,c)=>{a.Ea("Concat",i,{axis:c})},922884:(i,c,f,$,I)=>{a.Ea("Split",i,{axis:c,numOutputs:f,splitSizes:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},923029:i=>{a.Ea("Expand",i,void 0)},923083:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},923154:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},923233:(i,c,f,$,I,P,V,oe,ee,Z,re)=>{a.Ea("Resize",i,{antialias:c,axes:f?Array.from(n().subarray($>>>0,$+f>>>0)):[],coordinateTransformMode:Ve(I),cubicCoeffA:P,excludeOutside:V,extrapolationValue:oe,keepAspectRatioPolicy:Ve(ee),mode:Ve(Z),nearestMode:Ve(re)})},923584:(i,c,f,$,I,P,V)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[],ends:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[],axes:P?Array.from(n().subarray(V>>>0,V+P>>>0)):[]})},923815:i=>{a.Ea("Tile",i,void 0)},923867:(i,c,f)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(f)})},923974:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},924088:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},924202:i=>{a.Ea("Range",i,void 0)},924255:(i,c)=>{a.Ea("Einsum",i,{equation:Ve(c)})},924336:(i,c,f,$,I)=>{a.Ea("Pad",i,{mode:c,value:f,pads:$?Array.from(n().subarray(I>>>0,I+$>>>0)):[]})},924468:i=>{a.Ea("Gelu",i,void 0)},924520:i=>{a.Ea("BiasAdd",i,void 0)},924575:i=>{a.Ea("BiasSplitGelu",i,void 0)},924636:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},924717:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be)=>{a.Ea("Conv",i,{format:ee?"NHWC":"NCHW",auto_pad:c,dilations:[f],group:$,kernel_shape:[I],pads:P?Array.from(n().subarray(V>>>0,V+P>>>0)):[],strides:[oe],w_is_const:()=>!!r()[Z>>>0],activation:Ve(re),activation_params:he?Array.from(u().subarray(be>>>0,be+he>>>0)):[]})},925098:(i,c,f,$,I,P,V,oe,ee,Z,re,he,be,O,se,ye)=>{a.Ea("Conv",i,{format:he?"NHWC":"NCHW",auto_pad:c,dilations:[f,$],group:I,kernel_shape:[P,V],pads:oe?Array.from(n().subarray(ee>>>0,ee+oe>>>0)):[],strides:[Z,re],w_is_const:()=>!!r()[be>>>0],activation:Ve(O),activation_params:se?Array.from(u().subarray(ye>>>0,ye+se>>>0)):[]})},925500:i=>{a.zb(i)},925534:(i,c)=>a.Ab(i,c,a.bb.Fb,a.bb.errors),925646:i=>a.wb(i),925679:i=>a.yb(i),925711:(i,c,f)=>{a.jb(i,c,f,!0)},925750:(i,c,f)=>{a.jb(i,c,f)}};function ct(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Tt(i){i.terminate(),i.onmessage=()=>{}}function Ot(i){(i=ne.Qa[i])||Ke(),ne.Eb(i)}function Wt(i){var c=ne.tb();if(!c)return 6;ne.Ya.push(c),ne.Qa[i.Xa]=c,c.Xa=i.Xa;var f={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return S&&c.unref(),c.postMessage(f,i.Mb),0}var _t=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,cr=(i,c,f)=>{c>>>=0;var $=c+f;for(f=c;i[f]&&!(f>=$);)++f;if(16<f-c&&i.buffer&&_t)return _t.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,f):i.subarray(c,f));for($="";c<f;){var I=i[c++];if(I&128){var P=i[c++]&63;if((I&224)==192)$+=String.fromCharCode((I&31)<<6|P);else{var V=i[c++]&63;I=(I&240)==224?(I&15)<<12|P<<6|V:(I&7)<<18|P<<12|V<<6|i[c++]&63,65536>I?$+=String.fromCharCode(I):(I-=65536,$+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else $+=String.fromCharCode(I)}return $},Ve=(i,c)=>(i>>>=0)?cr(o(),i,c):"";function zt(i){if(A)return G(1,1,i);Ie=i,Xe()||(ne.Hb(),a.onExit&&a.onExit(i),Oe=!0),w(i,new ct(i))}var Vt=i=>{if(Ie=i,A)throw pr(i),"unwind";zt(i)},ne={ab:[],Ya:[],mb:[],Qa:{},gb:function(){A?ne.vb():ne.ub()},ub:function(){Ue.unshift(()=>{Bt(),ne.Bb(()=>lr())})},vb:function(){ne.receiveObjectTransfer=ne.Db,ne.threadInitTLS=ne.lb,ne.setExitStatus=ne.kb,ae=!1},kb:function(i){Ie=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ne.Ya)Tt(i);for(i of ne.ab)Tt(i);ne.ab=[],ne.Ya=[],ne.Qa=[]},Eb:function(i){var c=i.Xa;delete ne.Qa[c],ne.ab.push(i),ne.Ya.splice(ne.Ya.indexOf(i),1),i.Xa=0,en(c)},Db:function(){},lb:function(){ne.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=P=>{P=P.data;var V=P.cmd;if(P.targetThread&&P.targetThread!=Sr()){var oe=ne.Qa[P.Rb];oe?oe.postMessage(P,P.transferList):K(\'Internal error! Worker sent a message "\'+V+\'" to target pthread \'+P.targetThread+", but that thread no longer exists!")}else V==="checkMailbox"?$t():V==="spawnThread"?Wt(P):V==="cleanupThread"?Ot(P.thread):V==="killThread"?(P=P.thread,V=ne.Qa[P],delete ne.Qa[P],Tt(V),en(P),ne.Ya.splice(ne.Ya.indexOf(V),1),V.Xa=0):V==="cancelThread"?ne.Qa[P.thread].postMessage({cmd:"cancel"}):V==="loaded"?(i.loaded=!0,c(i)):V==="alert"?alert("Thread "+P.threadId+": "+P.text):P.target==="setimmediate"?i.postMessage(P):V==="callHandler"?a[P.handler](...P.args):V&&K("worker sent an unknown command "+V)},i.onerror=P=>{throw K("worker sent an error! "+P.filename+":"+P.lineno+": "+P.message),P},S&&(i.on("message",function(P){i.onmessage({data:P})}),i.on("error",function(P){i.onerror(P)}));var f=[],$=["onExit","onAbort","print","printErr"],I;for(I of $)a.hasOwnProperty(I)&&f.push(I);i.postMessage({cmd:"load",handlers:f,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Se})}),Bb:function(i){i()},qb:function(){var i=W("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ne.ab.push(i)},tb:function(){return ne.ab.length==0&&(ne.qb(),ne.Cb(ne.ab[0])),ne.ab.pop()}};a.PThread=ne;var st=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=function(){var i=Sr(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],Zn(c,c-i),Cr(c)};function pr(i){if(A)return G(2,0,i);Vt(i)}a.invokeEntryPoint=function(i,c){i=Qn.apply(null,[i,c]),Xe()?ne.kb(i):tn(i)};function Je(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,f){this.nb(),this.pb(c),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var He=0,fr=0;function wt(i,c,f,$){return A?G(3,1,i,c,f,$):Gt(i,c,f,$)}function Gt(i,c,f,$){if(i>>>=0,c>>>=0,f>>>=0,$>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var I=[];return A&&I.length===0?wt(i,c,f,$):(i={Gb:f,Xa:i,rb:$,Mb:I},A?(i.Ob="spawnThread",postMessage(i,I),0):Wt(i))}function Nt(i,c,f){return A?G(4,1,i,c,f):0}function mr(i,c){if(A)return G(5,1,i,c)}var vt=i=>{for(var c=0,f=0;f<i.length;++f){var $=i.charCodeAt(f);127>=$?c++:2047>=$?c+=2:55296<=$&&57343>=$?(c+=4,++f):c+=3}return c},hr=(i,c,f,$)=>{if(f>>>=0,!(0<$))return 0;var I=f;$=f+$-1;for(var P=0;P<i.length;++P){var V=i.charCodeAt(P);if(55296<=V&&57343>=V){var oe=i.charCodeAt(++P);V=65536+((V&1023)<<10)|oe&1023}if(127>=V){if(f>=$)break;c[f++>>>0]=V}else{if(2047>=V){if(f+1>=$)break;c[f++>>>0]=192|V>>6}else{if(65535>=V){if(f+2>=$)break;c[f++>>>0]=224|V>>12}else{if(f+3>=$)break;c[f++>>>0]=240|V>>18,c[f++>>>0]=128|V>>12&63}c[f++>>>0]=128|V>>6&63}c[f++>>>0]=128|V&63}}return c[f>>>0]=0,f-I},gr=(i,c,f)=>hr(i,o(),c,f);function yr(i,c){if(A)return G(6,1,i,c)}function br(i,c,f){if(A)return G(7,1,i,c,f)}function wr(i,c,f){return A?G(8,1,i,c,f):0}function vr(i,c){if(A)return G(9,1,i,c)}function Rt(i,c,f){if(A)return G(10,1,i,c,f)}function Ut(i,c,f,$){if(A)return G(11,1,i,c,f,$)}function Lt(i,c,f,$){if(A)return G(12,1,i,c,f,$)}function Ft(i,c,f,$){if(A)return G(13,1,i,c,f,$)}function Ht(i){if(A)return G(14,1,i)}function jt(i,c){if(A)return G(15,1,i,c)}function Kt(i,c,f){if(A)return G(16,1,i,c,f)}var qt=i=>{if(!Oe)try{if(i(),!Xe())try{A?tn(Ie):Vt(Ie)}catch(c){c instanceof ct||c=="unwind"||w(1,c)}}catch(c){c instanceof ct||c=="unwind"||w(1,c)}};function Pt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then($t),i+=128,Atomics.store(n(),i>>2,1))}a.__emscripten_thread_mailbox_await=Pt;function $t(){var i=Sr();i&&(Pt(i),qt(()=>Xn()))}a.checkMailbox=$t;var pt=i=>i%4===0&&(i%100!==0||i%400===0),xt=[0,31,60,91,121,152,182,213,244,274,305,335],Yt=[0,31,59,90,120,151,181,212,243,273,304,334];function l(i,c,f,$,I,P,V,oe){return A?G(17,1,i,c,f,$,I,P,V,oe):-52}function p(i,c,f,$,I,P,V){if(A)return G(18,1,i,c,f,$,I,P,V)}var h=i=>{var c=vt(i)+1,f=Qr(c);return f&&gr(i,f,c),f},C=[],T=(i,c)=>{C.length=0;var f;for(c>>=2;f=o()[i++>>>0];)c+=f!=105&c,C.push(f==105?n()[c>>>0]:d()[c++>>>1]),++c;return C},U=i=>{var c=rn();return i=i(),Cr(c),i};function G(i,c){var f=arguments.length-2,$=arguments;return U(()=>{for(var I=nn(8*f),P=I>>3,V=0;V<f;V++){var oe=$[2+V];d()[P+V>>>0]=oe}return Yn(i,f,I,c)})}var ue=[],Y={},Q=()=>{if(!J){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"},c;for(c in Y)Y[c]===void 0?delete i[c]:i[c]=Y[c];var f=[];for(c in i)f.push(`${c}=${i[c]}`);J=f}return J},J;function ce(i,c){if(A)return G(19,1,i,c);i>>>=0,c>>>=0;var f=0;return Q().forEach(function($,I){var P=c+f;for(I=s()[i+4*I>>2>>>0]=P,P=0;P<$.length;++P)r()[I++>>0>>>0]=$.charCodeAt(P);r()[I>>0>>>0]=0,f+=$.length+1}),0}function me(i,c){if(A)return G(20,1,i,c);i>>>=0,c>>>=0;var f=Q();s()[i>>2>>>0]=f.length;var $=0;return f.forEach(function(I){$+=I.length+1}),s()[c>>2>>>0]=$,0}function E(i){return A?G(21,1,i):52}function te(i,c,f,$){return A?G(22,1,i,c,f,$):52}function fe(i,c,f,$,I){return A?G(23,1,i,c,f,$,I):70}var ut=[null,[],[]];function Xt(i,c,f,$){if(A)return G(24,1,i,c,f,$);c>>>=0,f>>>=0,$>>>=0;for(var I=0,P=0;P<f;P++){var V=s()[c>>2>>>0],oe=s()[c+4>>2>>>0];c+=8;for(var ee=0;ee<oe;ee++){var Z=o()[V+ee>>>0],re=ut[i];Z===0||Z===10?((i===1?B:K)(cr(re,0)),re.length=0):re.push(Z)}I+=oe}return s()[$>>2>>>0]=I,0}var Nn=[31,29,31,30,31,30,31,31,30,31,30,31],Un=[31,28,31,30,31,30,31,31,30,31,30,31];function du(i){var c=Array(vt(i)+1);return hr(i,c,0,c.length),c}var cu=(i,c)=>{r().set(i,c>>>0)};function Ln(i,c,f,$){function I(O,se,ye){for(O=typeof O=="number"?O.toString():O||"";O.length<se;)O=ye[0]+O;return O}function P(O,se){return I(O,se,"0")}function V(O,se){function ye(ao){return 0>ao?-1:0<ao?1:0}var St;return(St=ye(O.getFullYear()-se.getFullYear()))===0&&(St=ye(O.getMonth()-se.getMonth()))===0&&(St=ye(O.getDate()-se.getDate())),St}function oe(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ee(O){var se=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<se;){var ye=O.getMonth(),St=(pt(O.getFullYear())?Nn:Un)[ye];if(se>St-O.getDate())se-=St-O.getDate()+1,O.setDate(1),11>ye?O.setMonth(ye+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+se);break}}return ye=new Date(O.getFullYear()+1,0,4),se=oe(new Date(O.getFullYear(),0,4)),ye=oe(ye),0>=V(se,O)?0>=V(ye,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}i>>>=0,c>>>=0,f>>>=0,$>>>=0;var Z=n()[$+40>>2>>>0];$={Kb:n()[$>>2>>>0],Jb:n()[$+4>>2>>>0],cb:n()[$+8>>2>>>0],ib:n()[$+12>>2>>>0],eb:n()[$+16>>2>>>0],$a:n()[$+20>>2>>>0],Wa:n()[$+24>>2>>>0],Za:n()[$+28>>2>>>0],Tb:n()[$+32>>2>>>0],Ib:n()[$+36>>2>>>0],Lb:Z?Ve(Z):""},f=Ve(f),Z={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in Z)f=f.replace(new RegExp(re,"g"),Z[re]);var he="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");Z={"%a":O=>he[O.Wa].substring(0,3),"%A":O=>he[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>P((O.$a+1900)/100|0,2),"%d":O=>P(O.ib,2),"%e":O=>I(O.ib,2," "),"%g":O=>ee(O).toString().substring(2),"%G":O=>ee(O),"%H":O=>P(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),P(O,2)),"%j":O=>{for(var se=0,ye=0;ye<=O.eb-1;se+=(pt(O.$a+1900)?Nn:Un)[ye++]);return P(O.ib+se,3)},"%m":O=>P(O.eb+1,2),"%M":O=>P(O.Jb,2),"%n":()=>`\n`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>P(O.Kb,2),"%t":()=>"\t","%u":O=>O.Wa||7,"%U":O=>P(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var se=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&se++,se)se==53&&(ye=(O.Wa+371-O.Za)%7,ye==4||ye==3&&pt(O.$a)||(se=1));else{se=52;var ye=(O.Wa+7-O.Za-1)%7;(ye==4||ye==5&&pt(O.$a%400-1))&&se++}return P(se,2)},"%w":O=>O.Wa,"%W":O=>P(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var se=0<=O;return O=Math.abs(O)/60,(se?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(re in Z)f.includes(re)&&(f=f.replace(new RegExp(re,"g"),Z[re]($)));return f=f.replace(/\\0\\0/g,"%"),re=du(f),re.length>c?0:(cu(re,i),re.length-1)}function $r(i){try{i()}catch(c){Ke(c)}}function pu(i){var c={},f;for(f in i)(function($){var I=i[$];c[$]=typeof I=="function"?function(){xr.push($);try{return I.apply(null,arguments)}finally{Oe||(xr.pop()===$||Ke(),Ze&&ft===1&&xr.length===0&&(ft=0,Ge+=1,$r(to),typeof Fibers<"u"&&Fibers.Ub()))}}:I})(f);return c}var ft=0,Ze=null,Fn=0,xr=[],Hn={},jn={},fu=0,Zr=null,mu=[];function hu(){return new Promise((i,c)=>{Zr={resolve:i,reject:c}})}function gu(){var i=Qr(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=xr[0];var f=Hn[c];return f===void 0&&(f=fu++,Hn[c]=f,jn[f]=c),c=f,n()[i+8>>2>>>0]=c,i}function yu(){var i=n()[Ze+8>>2>>>0];return i=j[jn[i]],--Ge,i()}function bu(i){if(!Oe){if(ft===0){var c=!1,f=!1;i(($=0)=>{if(!Oe&&(Fn=$,c=!0,f)){ft=2,$r(()=>ro(Ze)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),$=!1;try{var I=yu()}catch(oe){I=oe,$=!0}var P=!1;if(!Ze){var V=Zr;V&&(Zr=null,($?V.reject:V.resolve)(I),P=!0)}if($&&!P)throw I}}),f=!0,c||(ft=1,Ze=gu(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),$r(()=>eo(Ze)))}else ft===2?(ft=0,$r(no),Kn(Ze),Ze=null,mu.forEach($=>qt($))):Ke(`invalid state: ${ft}`);return Fn}}function wu(i){return bu(c=>{i().then(c)})}ne.gb();var vu=[null,zt,pr,wt,Nt,mr,yr,br,wr,vr,Rt,Ut,Lt,Ft,Ht,jt,Kt,l,p,ce,me,E,te,fe,Xt],$u={r:function(i,c,f){return wu(async()=>{await a.xb(i,c,f)})},b:function(i,c,f){throw i>>>=0,new Je(i).gb(c>>>0,f>>>0),He=i,fr++,He},O:function(i){qn(i>>>0,!y,1,!v,131072,!1),ne.lb()},l:function(i){i>>>=0,A?postMessage({cmd:"cleanupThread",thread:i}):Ot(i)},I:Gt,i:Nt,U:mr,E:yr,G:br,V:wr,S:vr,K:Rt,R:Ut,p:Lt,F:Ft,C:Ht,T:jt,D:Kt,q:()=>!0,A:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>$t()):A?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ne.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Pt,X:function(i){S&&ne.Qa[i>>>0].ref()},u:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getUTCSeconds(),n()[f+4>>2>>>0]=i.getUTCMinutes(),n()[f+8>>2>>>0]=i.getUTCHours(),n()[f+12>>2>>>0]=i.getUTCDate(),n()[f+16>>2>>>0]=i.getUTCMonth(),n()[f+20>>2>>>0]=i.getUTCFullYear()-1900,n()[f+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>2>>>0]=i},v:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getSeconds(),n()[f+4>>2>>>0]=i.getMinutes(),n()[f+8>>2>>>0]=i.getHours(),n()[f+12>>2>>>0]=i.getDate(),n()[f+16>>2>>>0]=i.getMonth(),n()[f+20>>2>>>0]=i.getFullYear()-1900,n()[f+24>>2>>>0]=i.getDay(),c=(pt(i.getFullYear())?xt:Yt)[i.getMonth()]+i.getDate()-1|0,n()[f+28>>2>>>0]=c,n()[f+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var $=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=$&&i.getTimezoneOffset()==Math.min($,c))|0,n()[f+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),f=n()[i+32>>2>>>0],$=c.getTimezoneOffset(),I=new Date(c.getFullYear(),6,1).getTimezoneOffset(),P=new Date(c.getFullYear(),0,1).getTimezoneOffset(),V=Math.min(P,I);return 0>f?n()[i+32>>2>>>0]=+(I!=P&&V==$):0<f!=(V==$)&&(I=Math.max(P,I),c.setTime(c.getTime()+6e4*((0<f?V:I)-$))),n()[i+24>>2>>>0]=c.getDay(),f=(pt(c.getFullYear())?xt:Yt)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=f,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,Jn((it=i,1<=+Math.abs(it)?0<it?+Math.floor(it/4294967296)>>>0:~~+Math.ceil((it-+(~~it>>>0))/4294967296)>>>0:0)),i>>>0},s:l,t:p,z:function(i,c,f){function $(Z){return(Z=Z.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Z[1]:"GMT"}i>>>=0,c>>>=0,f>>>=0;var I=new Date().getFullYear(),P=new Date(I,0,1),V=new Date(I,6,1);I=P.getTimezoneOffset();var oe=V.getTimezoneOffset(),ee=Math.max(I,oe);s()[i>>2>>>0]=60*ee,n()[c>>2>>>0]=+(I!=oe),i=$(P),c=$(V),i=h(i),c=h(c),oe<I?(s()[f>>2>>>0]=i,s()[f+4>>2>>>0]=c):(s()[f>>2>>>0]=c,s()[f+4>>2>>>0]=i)},d:()=>{Ke("")},c:function(i,c,f){return i>>>=0,c=T(c>>>0,f>>>0),Et[i].apply(null,c)},k:function(i,c,f){return i>>>=0,c=T(c>>>0,f>>>0),Et[i].apply(null,c)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ge+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return S?(fo(),Mt(po)).cpus().length:navigator.hardwareConcurrency},L:function(i,c,f,$){for(ne.Pb=c>>>0,ue.length=f,c=$>>>0>>3,$=0;$<f;$++)ue[$]=d()[c+$>>>0];return(0>i?Et[-i-1]:vu[i]).apply(null,ue)},y:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var f=1;4>=f;f*=2){var $=c*(1+.2/f);$=Math.min($,i+100663296);var I=Math;$=Math.max(i,$);e:{I=I.min.call(I,4294901760,$+(65536-$%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(I),pe();var P=1;break e}catch{}P=void 0}if(P)return!0}return!1},P:ce,Q:me,H:Vt,h:E,o:te,x:fe,n:Xt,a:we||a.wasmMemory,J:Ln,e:function(i,c,f,$){return Ln(i>>>0,c>>>0,f>>>0,$>>>0)}};(function(){function i(f,$){return f=f.exports,f=pu(f),j=f=xu(f),ne.mb.push(j.Da),Te.unshift(j.Y),Se=$,lr(),f}var c={a:$u};if(Bt(),a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(f){K("Module.instantiateWasm callback failed with error: "+f),g(f)}return dr(c,function(f){i(f.instance,f.module)}).catch(g),{}})(),a._OrtInit=(i,c)=>(a._OrtInit=j.Z)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=j._)(i,c),a._OrtCreateSessionOptions=(i,c,f,$,I,P,V,oe,ee,Z)=>(a._OrtCreateSessionOptions=j.$)(i,c,f,$,I,P,V,oe,ee,Z),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=j.aa)(i,c),a._OrtAddFreeDimensionOverride=(i,c,f)=>(a._OrtAddFreeDimensionOverride=j.ba)(i,c,f),a._OrtAddSessionConfigEntry=(i,c,f)=>(a._OrtAddSessionConfigEntry=j.ca)(i,c,f),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=j.da)(i),a._OrtCreateSession=(i,c,f)=>(a._OrtCreateSession=j.ea)(i,c,f),a._OrtReleaseSession=i=>(a._OrtReleaseSession=j.fa)(i),a._OrtGetInputOutputCount=(i,c,f)=>(a._OrtGetInputOutputCount=j.ga)(i,c,f),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=j.ha)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=j.ia)(i,c),a._OrtFree=i=>(a._OrtFree=j.ja)(i),a._OrtCreateTensor=(i,c,f,$,I,P)=>(a._OrtCreateTensor=j.ka)(i,c,f,$,I,P),a._OrtGetTensorData=(i,c,f,$,I)=>(a._OrtGetTensorData=j.la)(i,c,f,$,I),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=j.ma)(i),a._OrtCreateRunOptions=(i,c,f,$)=>(a._OrtCreateRunOptions=j.na)(i,c,f,$),a._OrtAddRunConfigEntry=(i,c,f)=>(a._OrtAddRunConfigEntry=j.oa)(i,c,f),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=j.pa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=j.qa)(i),a._OrtBindInput=(i,c,f)=>(a._OrtBindInput=j.ra)(i,c,f),a._OrtBindOutput=(i,c,f,$)=>(a._OrtBindOutput=j.sa)(i,c,f,$),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=j.ta)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=j.ua)(i),a._OrtRunWithBinding=(i,c,f,$,I)=>(a._OrtRunWithBinding=j.va)(i,c,f,$,I),a._OrtRun=(i,c,f,$,I,P,V,oe)=>(a._OrtRun=j.wa)(i,c,f,$,I,P,V,oe),a._OrtEndProfiling=i=>(a._OrtEndProfiling=j.xa)(i),a._JsepOutput=(i,c,f)=>(a._JsepOutput=j.ya)(i,c,f),a._JsepGetNodeName=i=>(a._JsepGetNodeName=j.za)(i);var Sr=a._pthread_self=()=>(Sr=a._pthread_self=j.Aa)(),Qr=a._malloc=i=>(Qr=a._malloc=j.Ba)(i),Kn=a._free=i=>(Kn=a._free=j.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=j.Da)();var qn=a.__emscripten_thread_init=(i,c,f,$,I,P)=>(qn=a.__emscripten_thread_init=j.Fa)(i,c,f,$,I,P);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=j.Ga)();var Yn=(i,c,f,$)=>(Yn=j.Ha)(i,c,f,$),en=i=>(en=j.Ia)(i),tn=a.__emscripten_thread_exit=i=>(tn=a.__emscripten_thread_exit=j.Ja)(i),Xn=a.__emscripten_check_mailbox=()=>(Xn=a.__emscripten_check_mailbox=j.Ka)(),Jn=i=>(Jn=j.La)(i),Zn=(i,c)=>(Zn=j.Ma)(i,c),rn=()=>(rn=j.Na)(),Cr=i=>(Cr=j.Oa)(i),nn=i=>(nn=j.Pa)(i),Qn=a.dynCall_ii=(i,c)=>(Qn=a.dynCall_ii=j.Ra)(i,c),eo=i=>(eo=j.Sa)(i),to=()=>(to=j.Ta)(),ro=i=>(ro=j.Ua)(i),no=()=>(no=j.Va)();a.___start_em_js=925783,a.___stop_em_js=925944;function xu(i){i=Object.assign({},i);var c=$=>()=>$()>>>0,f=$=>I=>$(I)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=f(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=f(i.stackAlloc),i}a.keepRuntimeAlive=Xe,a.wasmMemory=we,a.stackAlloc=nn,a.stackSave=rn,a.stackRestore=Cr,a.UTF8ToString=Ve,a.stringToUTF8=gr,a.lengthBytesUTF8=vt,a.ExitStatus=ct,a.PThread=ne;var Ar;bt=function i(){Ar||oo(),Ar||(bt=i)};function oo(){function i(){if(!Ar&&(Ar=!0,a.calledRun=!0,!Oe)&&(A||st(Te),m(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!A)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();ke.unshift(c)}st(ke)}}if(!(0<Fe))if(A)m(a),A||st(Te),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Ue.unshift(a.preRun.shift());st(Ue),0<Fe||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),i()},1)):i())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return oo(),t.ready}})();typeof ho=="object"&&typeof cn=="object"?cn.exports=mo:typeof define=="function"&&define.amd&&define([],()=>mo)});var yo=Jt((mc,_u)=>{_u.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var mn,Qt,er,Tr,tr,So,hn,De=H(()=>{"use strict";mn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Qt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},er=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Tr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},tr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},So=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",hn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Vu,Gu,Co,Ao,Io,Nu,Ee,mt=H(()=>{"use strict";De();Vu=["V","I","W","E","F"],Gu=(e,t)=>{console.log(`[${Vu[e]},${new Date().toISOString()}]${t}`)},Io=(e,t)=>{Co=e,Ao=t},Nu=(e,t)=>{let r=tr(e),o=tr(Co);r>=o&&Gu(r,typeof t=="function"?t():t)},Ee=(...e)=>{Ao&&Nu(...e)}});var Eo,To=H(()=>{"use strict";De();Eo=(e,t)=>new(Tr(t))(e)});var Oo=H(()=>{"use strict"});var Or,Uu,_o,yn,gn,Ro,Po=H(()=>{"use strict";mt();Oo();Or=e=>Math.ceil(e/16)*16,Uu=1,_o=()=>Uu++,yn=async(e,t,r,o)=>{let n=Or(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let d=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(d,0,r)),a}else return new Uint8Array(d.slice(0,r))}finally{s.destroy()}},gn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Or(s),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=a.getMappedRange();new Uint8Array(m).set(new Uint8Array(o,n,s)),a.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(a,0,d.gpuData.buffer,0,u),Ee("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Or(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=_o();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ee("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Or(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,m=a.get(o);m||(m=[],a.set(o,m)),m.length>0?n=m.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let d={id:_o(),type:0,buffer:n};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Ee("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ee("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await yn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Ro=(...e)=>new gn(...e)});var bn,ie,Pe=H(()=>{"use strict";bn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ie=e=>new bn(e)});var wn,Qe,k,Ct,_r,Rr,Pr,ge=H(()=>{"use strict";wn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},Qe=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),d=new Array(u);if(o){if(n<2||s<2)return;let a=wn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[d[u-2],d[u-1]]=a}for(let a=o?3:1;a<=u;a++){let m=n-a<0?1:t[n-a],g=s-a<0?1:r[s-a];if(m!==g&&m>1&&g>1)return;d[u-a]=Math.max(m,g)}return d}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},k=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},Ct=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<n.length){if(n[d]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let d=0;d<o.length;d++)if(d<s.length){if(s[d]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let d=0;d<o.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=o[d]||u[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,d){if(d){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,d)}}static computePoolOutputShape(t,r,o,n,s,u,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,d),a}static computeConvOutputShape(t,r,o,n,s,u,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,d),a}static computeShapeHelper(t,r,o,n,s,u,d,a){if(t)for(let m=0;m<r.length-2;m++)o.push(1);else for(let m=0;m<r.length-2;m++)o.push(e.adjustPadAndReturnShape(r[m+2],n[m],s[m],u[m],d,m,m+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,d,a){let m=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[d]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let x=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(x+1)/2:x/2),s[d]=x-s[u],Math.floor((t+x-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[d]-m)/r+1)}},_r=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,d,a;r?(u=t[1],d=t[0]):(u=t[0],d=t[1]);let m=-1;if(n?(a=o[0],m=1):(a=o[1],m=0),o[m]!==d)throw new Error("dimension mismatch");if(u<=0||a<=0||d<=0)throw new Error("invalid shape specified");if(s&&!Qe.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,d]}},Rr=-34028234663852886e22,Pr=34028234663852886e22});var Lu,Mo,Me,$n,lt,qe,At,ht,Bo,L,X,vn,ko,xn,Do,ve=H(()=>{"use strict";De();ge();Lu=64,Mo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Me=(e,t=1)=>{let r=Mo(e,t);return typeof r=="string"?r:r[0]},$n=e=>[{type:"uint32",data:e},{type:"uint32",data:k.computeStrides(e)}],lt=e=>e%4===0?4:e%2===0?2:1,qe=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,At=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,ht=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Bo=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,d=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,m=Mo(t,n),g=typeof m=="string"?m:m[1],x=typeof m=="string"?m:m[0],b={indices:a,value:g,storage:x,tensor:t},w=N=>typeof N=="string"?N:`${N}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=s?"uniforms.":"",S=`${y}${e}_shape`,A=`${y}${e}_strides`,R="";for(let N=0;N<u-1;N++)R+=`\n    let dim${N} = current / ${A}[${N}];\n    let rest${N} = current % ${A}[${N}];\n    indices[${N}] = dim${N};\n    current = rest${N};\n    `;R+=`indices[${u-1}] = current;`;let W=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${R}\n    return indices;\n  }`,M=N=>(v.offsetToIndices=!0,u<2?N:`o2i_${e}(${N})`),D=[];if(u>=2)for(let N=u-1;N>=0;N--)D.push(`${A}[${N}] * (indices[${N}])`);let _=u<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${D.join("+")};\n  }`,z=N=>(v.indicesToOffset=!0,u<2?N:`i2o_${e}(${N})`),F=(...N)=>u===0?"0u":`${b.indices}(${N.map(w).join(",")})`,q=(N,de)=>u<2?`${N}`:`${N}[${de}]`,le=(N,de,pe)=>u<2?`${N}=${pe};`:`${N}[${de}]=${pe};`,B={},K=(N,de)=>{v.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in B)return`${pe}(${N})`;let ze=[];for(let Ue=u-1;Ue>=0;Ue--){let Te=de.indicesGet("outputIndices",Ue+de.rank-u);ze.push(`${q(A,Ue)} * (${Te} % ${q(S,Ue)})`)}return B[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {\n             return ${ze.length>0?ze.join("+"):"0u"};\n           }`,`${pe}(${N})`},xe=(N,de)=>(()=>{if(b.storage===b.value)return`${e}[${N}]=${de};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${N}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${N}]=vec2<u32>(u32(${de}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${N}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ae=N=>(()=>{if(b.storage===b.value)return`${e}[${N}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${N}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${N}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${N}] & 0xFFu), bool(${e}[${N}] & 0xFF00u), bool(${e}[${N}] & 0xFF0000u), bool(${e}[${N}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),we=u<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${g} {\n    return ${ae(`i2o_${e}(indices)`)};\n  }`,j=u<2?"":(()=>{let N=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn get_${e}(${N}) -> ${g} {\n    return get_${e}ByIndices(${F(de)});\n  }`})(),Se=(...N)=>{if(N.length!==u)throw new Error(`indices length must be ${u}`);let de=N.map(w).join(",");return u===0?ae("0u"):u===1?ae(de[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${de})`)},Oe=N=>u<2?ae(N):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${N})`),Ie=u<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${g}) {\n    ${xe(`i2o_${e}(indices)`,"value")}\n  }`,Ce=u<2?"":(()=>{let N=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn set_${e}(${N}, value: ${g}) {\n    set_${e}ByIndices(${F(de)}, value);\n  }`})();return{impl:()=>{let N=[];return s||(N.push(`const ${S} = ${b.indices}(${r.join(",")});`),N.push(`const ${A} = ${b.indices}(${k.computeStrides(r).join(",")});`)),v.offsetToIndices&&N.push(W),v.indicesToOffset&&N.push(_),v.broadcastedIndicesToOffset&&Object.values(B).forEach(de=>N.push(de)),v.set&&N.push(Ce),v.setByIndices&&N.push(Ie),v.get&&N.push(j),v.getByIndices&&N.push(we),N.join(`\n`)},type:b,offsetToIndices:M,indicesToOffset:z,broadcastedIndicesToOffset:K,indices:F,indicesGet:q,indicesSet:le,set:(...N)=>{if(N.length!==u+1)throw new Error(`indices length must be ${u}`);let de=N[u];if(typeof de!="string")throw new Error("value must be string");let pe=N.slice(0,u).map(w).join(",");return u===0?xe("0u",de):u===1?xe(pe[0],de):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:xe,setByIndices:(N,de)=>u<2?xe(N,de):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${N}, ${de});`),get:Se,getByOffset:ae,getByIndices:Oe,usage:o?"input":"output",name:e,strides:A,shape:S,rank:u}},L=(e,t,r,o=1)=>Bo(e,t,r,!0,o),X=(e,t,r,o=1)=>Bo(e,t,r,!1,o),vn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Lu){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,d=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*o*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${d}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},ko=e=>new vn(e),xn=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},Do=e=>e<=4});var Fu,Wo,Hu,ju,gt,zo,Vo,rr=H(()=>{"use strict";ge();Pe();ve();Fu=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Wo=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Hu=(e,t)=>k.sortBasedOnPerm(e,Wo(e.length,t)),ju=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},gt=(e,t)=>{let r=e.dataType,o=e.dims.length,n=Wo(o,t),s=Do(o),u=Hu(e.dims,n),d=s?u.length:u,a=s?o:e.dims,m=X("output",r,d),g=L("a",r,a),x=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(g,m)}\n\n  ${ju(n,o,g,m)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",g.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:b=>{let w=k.size(u);return{outputs:[{dims:u,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:s?[{type:"uint32",data:w},...$n(b[0].dims),...$n(u)]:[{type:"uint32",data:w}]}},getShaderSource:x}},zo=(e,t)=>{Fu(e.inputs),e.compute(gt(e.inputs[0],t.perm))},Vo=e=>ie({perm:e.perm})});var Ku,qu,Yu,Xu,Ju,Zu,Qu,el,tl,rl,et,Go,No,Uo,Lo,Fo,Ho,jo,Ko,qo,Yo,Xo=H(()=>{"use strict";ge();ve();Mr();rr();Ku={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},qu={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Yu={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Xu={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Ju=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Zu=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},Qu=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},el=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},tl=(e,t)=>{let r=[];if(!el(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},rl=(e,t,r,o,n,s,u)=>{let d=r[0].dims,a=k.size(s),m=k.size(u),g=L("_A",r[0].dataType,d),x=X("output",n,s),b=32,w=`\n          var<workgroup> aBestValues : array<${x.type.storage}, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:y=>`\n        ${y.registerUniform("reduceSize","u32").declareVariables(g,x)}\n        ${w}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${y.mainStart(b)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${x.type.storage}(${Yu[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = ${x.type.storage}(${g.getByOffset("offset + k")});\n           bestValue = ${Ku[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${qu[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${x.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${x.type.storage}(uniforms.reduceSize)`:`${Xu[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:m}]})}},et=(e,t,r,o)=>{let n=e.inputs.length===1?r:Sn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((w,v)=>v));let u=k.normalizeAxes(s,e.inputs[0].dims.length),d=u,a=e.inputs[0],m=tl(d,e.inputs[0].dims.length);m.length>0&&(a=e.compute(gt(e.inputs[0],m),{inputs:[0],outputs:[-1]})[0],d=Ju(d.length,a.dims.length));let[g,x]=Zu(a.dims,d),b=g;n.keepDims&&(b=Qu(g,u)),e.compute(rl(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,b,x),{inputs:[a]})},Go=(e,t)=>{et(e,"ReduceMeanShared",t,"mean")},No=(e,t)=>{et(e,"ReduceL1Shared",t,"l1")},Uo=(e,t)=>{et(e,"ReduceL2Shared",t,"l2")},Lo=(e,t)=>{et(e,"ReduceLogSumExpShared",t,"logSumExp")},Fo=(e,t)=>{et(e,"ReduceMaxShared",t,"max")},Ho=(e,t)=>{et(e,"ReduceMinShared",t,"min")},jo=(e,t)=>{et(e,"ReduceProdShared",t,"prod")},Ko=(e,t)=>{et(e,"ReduceSumShared",t,"sum")},qo=(e,t)=>{et(e,"ReduceSumSquareShared",t,"sumSquare")},Yo=(e,t)=>{et(e,"ReduceLogSumShared",t,"logSum")}});var tt,nl,Br,Sn,rt,ol,al,il,sl,ul,ll,dl,cl,pl,fl,nt,Jo,Zo,Qo,ea,ta,ra,na,oa,aa,ia,Ye,Mr=H(()=>{"use strict";ge();Pe();ve();Xo();tt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},nl=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Br=(e,t,r,o,n,s,u=!1,d=!1)=>{let a=[],m=r[0].dims,g=k.normalizeAxes(n,r[0].dims.length),x=!d&&g.length===0;m.forEach((z,F)=>{x||g.indexOf(F)>=0?u&&a.push(1):a.push(z)});let b=[],w=L("_A",r[0].dataType,m),v=X("output",s,a),y=o(w,v,g),S=`inputOffset = ${w.indicesToOffset("inputIndices")};`,A=`let ${S};`,R=`var ${S};`,W=y[1]===""?"":R,M=(y[1]===""?A:S)+`\n`+y[2];for(let z=0,F=0;z<r[0].dims.length;z++)x||g.indexOf(z)>=0?(u&&F++,M=`for(var j${z}: u32 = 0; j${z} < ${r[0].dims[z]}; j${z}++) {\n                ${y[2].includes("lastIndex")?`let lastIndex = j${z};`:""}\n                ${w.indicesSet("inputIndices",z,`j${z}`)}\n                ${M}\n              }`):(b.push(`${w.indicesSet("inputIndices",z,v.indicesGet("outputIndices",F))};`),F++);let D=k.size(a);return{name:e,shaderCache:t,getShaderSource:z=>`\n        ${z.declareVariables(w,v)}\n\n        ${z.mainStart()}\n          ${z.guardAgainstOutOfBoundsWorkgroupSizes(D)}\n          var inputIndices: ${w.type.indices};\n          let outputIndices = ${v.offsetToIndices("global_idx")};\n\n          ${b.join(`\n`)}\n          ${y[0]}       // init ops for reduce max/min\n          ${W}\n          ${y[1]}\n          ${M}\n          ${y[3]}\n          ${y.length===4?v.setByOffset("global_idx","value"):y.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(D/64)}})}},Sn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ie({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rt=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:Sn(n,r);e.compute(Br(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?nl:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},ol=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},al=(e,t)=>{tt(e.inputs),rt(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},il=(e,t)=>{tt(e.inputs),rt(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},sl=(e,t)=>{tt(e.inputs),rt(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},ul=(e,t)=>{tt(e.inputs),rt(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(o.indicesSet("inputIndices",d,0));return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},ll=(e,t)=>{tt(e.inputs),rt(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&(u*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},dl=(e,t)=>{tt(e.inputs),rt(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`inputIndices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},cl=(e,t)=>{tt(e.inputs),rt(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},pl=(e,t)=>{tt(e.inputs),rt(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},fl=(e,t)=>{tt(e.inputs),rt(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},nt=(e,t,r)=>{if(t.length===0)return!!r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},Jo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ll(e,t):Go(e,t)},Zo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?al(e,t):No(e,t)},Qo=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?il(e,t):Uo(e,t)},ea=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?sl(e,t):Lo(e,t)},ta=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ul(e,t):Fo(e,t)},ra=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dl(e,t):Ho(e,t)},na=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cl(e,t):jo(e,t)},oa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pl(e,t):Ko(e,t)},aa=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fl(e,t):qo(e,t)},ia=(e,t)=>{nt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ol(e,t):Yo(e,t)},Ye=e=>ie(e)});var sa,ua,la,da,Cn,ca=H(()=>{"use strict";De();Pe();Mr();sa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},ua=(e,t)=>ie({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),la=(e,t)=>{sa(e.inputs);let r=(n,s,u)=>{let d=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&d.push(`inputIndices[${a}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ua(e.inputs,t);e.compute(Br("ArgMin",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},da=(e,t)=>{sa(e.inputs);let r=(n,s,u)=>{let d=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&d.push(`inputIndices[${a}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ua(e.inputs,t);e.compute(Br("argMax",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Cn=e=>ie(e)});var ml,hl,pa,fa=H(()=>{"use strict";ge();ve();ml=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hl=e=>{let t=e[0].dims,r=e[0].dims[2],o=k.size(t)/4,n=e[0].dataType,s=L("input",n,t,4),u=L("bias",n,[r],4),d=L("residual",n,t,4),a=X("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:g=>`\n  const channels = ${r}u / 4;\n  ${g.declareVariables(s,u,d,a)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},pa=e=>{ml(e.inputs),e.compute(hl(e.inputs))}});var gl,$e,ma,ha,ga,ya,ba,wa,va,$a,xa,An,yl,Sa,Ca,Aa,Ia,kr,Ea,Dr,Ta,Oa,_a,Ra,Pa,Ma,Ba,ka,Da,Wa,za,Va,Ga,Na,Ua,La,Fa,In=H(()=>{"use strict";De();ge();Pe();ve();gl=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),d="";typeof n=="string"?d=`${n}(a)`:d=n("a");let a=L("inputData",r,[u],4),m=X("outputData",o,[u],4);return`\n  ${e.declareVariables(a,m)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx",d)}\n  }`},$e=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n},getShaderSource:u=>gl(u,k.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(k.size(u[0].dims)/64/4)}})}),ma=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},ha=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},ga=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},ya=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},ba=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},wa=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},va=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},$a=e=>ie(e),xa=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},An=(e,t)=>{let r=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},yl=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Rr,r=e.length>=3?e[2].getFloat32Array()[0]:Pr;return ie({min:t,max:r})},Sa=e=>{let t=yl(e.inputs);An(e,t)},Ca=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},Aa=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},Ia=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},kr=e=>ie(e),Ea=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Dr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Ta=e=>{let t=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Dr(`vec4<${t}>`,t)))},Oa=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},_a=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},Ra=e=>{let t=Me(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Dr(`vec4<${t}>`,t)))},Pa=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},Ma=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},Ba=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},ka=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Da=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},Wa=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},za=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},Va=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},Ga=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},Na=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},Ua=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},La=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),Fa=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var wl,vl,Ha,ja=H(()=>{"use strict";ge();ve();In();wl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},vl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=L("input",e[0].dataType,e[0].dims,4),o=L("bias",e[0].dataType,[e[0].dims[2]],4),n=X("output",e[0].dataType,t,4),s=k.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:d=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${d.declareVariables(r,o,n)}\n\n  ${Dr("vec4f")}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ha=e=>{wl(e.inputs),e.compute(vl(e.inputs))}});var $l,xl,ot,Ka,qa,Ya,Xa,Ja,Za,Qa,ei,ti,ri,ni=H(()=>{"use strict";De();ge();ve();$l=(e,t,r,o,n,s,u,d,a,m,g)=>{let x=k.size(o),b=Math.ceil(x/4),w,v;typeof u=="string"?w=v=(M,D)=>`${u}((${M}),(${D}))`:typeof u=="function"?w=v=u:(w=u.scalar,v=u.vector);let y="",S=X("outputData",m,o,4),A=L("aData",d,t,4),R=L("bData",a,r,4);if(s){let M=D=>{let _=k.computeStrides(D),z=[];for(let F=D.length-1;F>=0;F--){let q=S.indicesGet("outputIndices",F+o.length-D.length);z.push(`${_[F]}u * (${q} % ${D[F]}u)`)}return z.length>0?z.join("+"):"0u"};y=`\n          fn calcOffsetA(outputIndices: ${S.type.indices}) -> u32 {\n            return ${M(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${S.type.indices}) -> u32 {\n            return ${M(r)};\n          }\n        `}let W;if(n)if(s){let M=k.size(t)===1,D=k.size(r)===1;M||D?W=S.setByOffset("global_idx",v(M?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"),D?`${R.type.value}(${R.getByOffset("0")}.x)`:R.getByOffset("global_idx"))):W=`\n            let outputIndices = ${S.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${S.setByOffset("global_idx",v(A.getByOffset("offsetA / 4u"),R.getByOffset("offsetB / 4u")))}\n          `}else W=S.setByOffset("global_idx",v(A.getByOffset("global_idx"),R.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let M=(D,_,z="")=>{let F=`aData[indexA${_}][componentA${_}]`,q=`bData[indexB${_}][componentB${_}]`;return`\n            let outputIndices${_} = ${S.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offsetA${_} = calcOffsetA(outputIndices${_});\n            let offsetB${_} = calcOffsetB(outputIndices${_});\n            let indexA${_} = offsetA${_} / 4u;\n            let indexB${_} = offsetB${_} / 4u;\n            let componentA${_} = offsetA${_} % 4u;\n            let componentB${_} = offsetB${_} % 4u;\n            ${D}[${_}] = ${z}(${w(F,q)});\n          `};m===9?W=`\n            var data = vec4<u32>(0);\n            ${M("data",0,"u32")}\n            ${M("data",1,"u32")}\n            ${M("data",2,"u32")}\n            ${M("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:W=`\n            ${M("outputData[global_idx]",0)}\n            ${M("outputData[global_idx]",1)}\n            ${M("outputData[global_idx]",2)}\n            ${M("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(A,R,S)}\n\n        ${g??""}\n        ${y}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        ${W}\n      }`},xl=(e,t,r,o,n,s,u=r.dataType)=>{let d=!k.areEqual(r.dims,o.dims),a=r.dims,m=k.size(r.dims),g=!1;if(d){let x=Qe.calcShape(r.dims,o.dims,!1);if(!x)throw new Error("Can\'t perform binary op on the given tensors");a=x,m=k.size(a);let b=k.size(r.dims)===1,w=k.size(o.dims)===1,v=1;for(let y=1;y<a.length;y++){let S=r.dims[r.dims.length-y]??1,A=o.dims[o.dims.length-y]??1;if(S===A)v*=S;else break}(v%4===0||b||w)&&(g=!0)}else g=!0;return{name:e,shaderCache:{hint:t},getShaderSource:x=>$l(x,r.dims,o.dims,a,g,d,n,r.dataType,o.dataType,u,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(m/64/4)}})}},ot=(e,t,r,o,n,s)=>{e.compute(xl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},Ka=e=>{ot(e,"Add",(t,r)=>`${t}+${r}`)},qa=e=>{ot(e,"Div",(t,r)=>`${t}/${r}`)},Ya=e=>{ot(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Xa=e=>{ot(e,"Mul",(t,r)=>`${t}*${r}`)},Ja=e=>{let t=L("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ot(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Za=e=>{ot(e,"Sub",(t,r)=>`${t}-${r}`)},Qa=e=>{ot(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},ei=e=>{ot(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},ti=e=>{ot(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},ri=e=>{ot(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Cl,Al,Il,El,oi,ai,ii=H(()=>{"use strict";ge();Pe();ve();Cl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},Al=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Il=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},El=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let w=1;w<e.length;w++){let v=e[w].dims.slice();for(let y=0;y<r.length;y++)if(y===o)n[o]+=v[y];else if(r[y]!==v[y])throw new Error("non concat dimensions must match")}let s=k.size(n),u=new Array(e.length),d=new Array(e.length),a=e[0].dataType,m=0;for(let w=0;w<e.length;++w)m+=e[w].dims[o],u[w]=m,d[w]=L(`input${w}`,a,e[w].dims);let g=X("output",a,n),x=g.indicesGet("indices",o),b=w=>`\n  ${w.declareVariables(...d,g)}\n\n  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map(v=>`${v}u`).join(",")});\n  ${Al(u.length)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n\n    var indices = ${g.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${x});\n    if (inputIndex != 0u) {\n      ${x} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Il(d,g)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:b}},oi=(e,t)=>{Cl(e.inputs),e.compute(El(e.inputs,t.axis))},ai=e=>ie({axis:e.axis})});var We,Wr,zr,Vr=H(()=>{"use strict";We=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Wr=(e,t=!1,r=!1,o=3)=>"",zr=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `});var Gr,En=H(()=>{"use strict";Gr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Nr,Ur,nr=H(()=>{"use strict";ge();Nr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Ur=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Rr,Pr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var Tl,Ol,or,si,_l,ar,Rl,Lr,ir=H(()=>{"use strict";ge();ve();nr();Vr();Tl=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Ol=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,or=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32)=>{let a=t[1]*e[1],m=t[0]*e[0],g=n?a:s,x=n?s:a,b=g/t[0],w=s/t[1];if(!((n&&b===4&&e[1]===4||!n&&(b===3||b===4))&&g%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${g/b}>, ${x}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${w};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Tl(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Ol(n,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},si=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,_l=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",ar=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32,a=!1)=>{let m=e[1]*t[1],g=e[0]*t[0],x=n?m:s,b=n?s:m;if(!(b%t[1]===0&&x%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${x} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=b/t[1],v=x/t[0],y=s/t[1],S=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${m};\n    let globalColStart = i32(workgroupId.x) * ${g};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${x}; inputCol = inputCol + ${t[0]}) {\n          ${si(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${m};\n\nlet tileRowA = i32(localId.y) * ${w};\nlet tileColA = i32(localId.x) * ${v};\nlet tileRowB = i32(localId.y) * ${y};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${si(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${_l(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${x}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${S}\n  }\n`},Rl=(e,t,r,o,n,s=!1)=>{let u=n[0],d=n[1],a=n[2],m=o[0],g=o[1],x=o[2],b=o[3],w=xn(u,a),v=xn(d,a),y=Me(o[0].type.tensor),S=()=>{let W=g.rank,M=m.rank,D=`var aIndices: ${g.type.indices};`;for(let _=W-2-1,z=M-1;_>=0;_--,z--)D+=`\naIndices[${_}] = ${M>1?`batchIndices[${z}]`:"batchIndices"};`;return w.forEach(_=>{D+=`\naIndices[${_}] = 0;`}),D+=`\naIndices[${W-2}] = u32(row);\n                   aIndices[${W-1}] = u32(colIn);`,D},A=()=>{let W=x.rank,M=m.rank,D=`var bIndices: ${x.type.indices};`;for(let _=W-2-1,z=M-1;_>=0;_--,z--)D+=`\nbIndices[${_}] = ${M>1?`batchIndices[${z}]`:"batchIndices"};`;return v.forEach(_=>{D+=`\nbIndices[${_}] = 0;`}),D+=`\nbIndices[${W-2}] = u32(row);\n                   bIndices[${W-1}] = u32(colIn);`,D};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,y)} {\n      var value = ${We(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${S()}\n        value = ${g.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${We(e,y)} {\n      var value = ${We(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${A()}\n        value = ${x.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${We(e,y)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${We(e,y)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Lr=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s.slice(0,-2),a=u.slice(0,-2),m=o?o.slice(0,-2):r.slice(0,-2),g=L("batchDims",e[0].dataType,m),x=[g],b=[d,a,m],w=k.size(m),v=s[s.length-2],y=s[s.length-1],S=u[u.length-1],A=y%4===0&&S%4===0,{activationFunction:R,applyActivation:W}=Nr(t,A),M=v<=8?[4,1,1]:[4,4,1],D=[8,8,1],_=[Math.ceil(S/D[0]/M[0]),Math.ceil(v/D[1]/M[1]),Math.ceil(w/D[2]/M[2])],z=Me(e[0].dataType),F=A?4:1,q=L("a",e[0].dataType,[...d,v,y/F],F),le=L("b",e[1].dataType,[...a,y,S/F],F),B=X("result",e[0].dataType,[w,v,S/F],F);x.push(q),x.push(le),x.push(B);let K=[q,le],xe=e.length>2,ae=Rl(F,xe,W,x,b,n);if(xe){let j=n?F:1;K.push(L("bias",e[2].dataType,e[2].dims,j))}let we=j=>`\n  const dimAOuter: i32 = ${v};\n  const dimBOuter: i32 = ${S};\n  const dimInner: i32 = ${y};\n  ${j.declareVariables(...K,B)}\n  ${R}\n  ${ae}\n  ${A?or(M,D,z,g):ar(M,D,z,g)}\n                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]}}),getShaderSource:we}}});var Pl,ui,li=H(()=>{"use strict";mt();ge();ve();Vr();En();ir();Pl=(e,t,r,o,n=!1,s,u=!1,d=4,a=4,m=4,g="f32")=>{let x=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},b=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,v=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"xShape[1]":"xShape[2]",S=e?"xShape[2]":"xShape[3]",A=e?"row":"col",R=e?"col":"row",W=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${R} / (filterDims[1] * inChannels);\n    let WCol = ${R} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${R} % inChannels;\n    var resData = ${We(d,g)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${S}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${x(d)}\n    }\n    return resData;`,M=e?t&&o?`\n    let col = colIn * ${d};\n    ${W}`:`\n    let col = colIn * ${d};\n    if (row < dimAOuter && col < dimInner) {\n      ${W}\n    }\n    return ${We(d,g)}(0.0);`:o&&r?`\n    let col = colIn * ${d};\n    ${W}`:`\n    let col = colIn * ${d};\n    if (row < dimInner && col < dimBOuter) {\n      ${W}\n    }\n    return ${We(d,g)}(0.0);`,D=`${b(a)}`,_=We(m,g),z=e?We(d,g):We(a,g),F=e?We(a,g):We(d,g);return`\n    ${Wr(s,u,m===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${z} {\n      ${e?M:D}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${F} {\n      ${e?D:M}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${m};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${v}\n      ${zr(n,s)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ui=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",m=a?e[0].dims[3]:e[0].dims[1],g=r[0],x=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],v=a&&(m%4===0||m%3===0)&&w%4===0,y=a?w:x*b,S=a?x*b:w,A=[8,8,1],R=o<=8?[4,1,1]:[4,4,1],W=[Math.ceil(y/A[0]/R[0]),Math.ceil(S/A[1]/R[1]),Math.ceil(g/A[2]/R[2])];Ee("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${W}`);let M=v?a&&m%4!==0?3:4:R[0],D=A[1]*R[1],_=A[0]*R[0],z=Math.max(A[0]*M,A[1]),F=o%D===0,q=n%_===0,le=s%z===0,B=v?[M,4,4]:[1,1,1],K=Me(e[0].dataType),xe=[`@group(0) @binding(0) var<storage, read> x: array<${v&&M===4?`vec4<${K}>`:K}>;`,`@group(0) @binding(1) var<storage, read> w: array<${v?`vec4<${K}>`:K}>;`],ae=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${K}>`:K}) {\n        result[flatIndex] = ${v?`vec4<${K}>`:K}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${K}>`:K}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`;return u&&(xe.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?`vec4<${K}>`:K}>;`),ae+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${K}>`:K} {\n          return bias[coords.${a?"w":"y"}${v?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${Gr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${xe.join("")}\n        @group(0) @binding(${xe.length}) var<storage, read_write> result: array<${v?`vec4<${K}>`:K}>;\n        //@group(0) @binding(${xe.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${ae}\n        ${Pl(a,F,q,le,u,t.activation.toLowerCase(),!1,B[0],B[1],B[2],K)}\n            ${v?or(R,A,K,void 0,!a,z):ar(R,A,K,void 0,!a,z,!1,void 0,d)}`}}});var Tn,di=H(()=>{"use strict";ge();ve();_n();nr();Tn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,d=u[0]/t.group,{activationFunction:a,applyActivation:m}=Nr(t),g=t.format==="NHWC",x=On(s,u,t.dilations,t.pads,t.strides,g),b=k.size(x),w=X("output",e[0].dataType,x),v=L("x",e[0].dataType,s),y=L("w",e[1].dataType,u),S=[v,y];o&&S.push(L("b",e[2].dataType,e[2].dims));let A=R=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${R.declareVariables(...S,w)}\n\n  ${a}\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n    let outputIndices = ${w.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${g?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${w.type.value} = ${w.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[g?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[g?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${g?v.get("batch","xHeight","xWidth","input_channel"):v.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${y.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${m}\n    ${w.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(x):x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:A}}});var On,ci,Ml,pi,Rn,Bl,kl,Pn,_n=H(()=>{"use strict";ge();Pe();li();ir();di();nr();rr();On=(e,t,r,o,n,s)=>{let u=e[0],d=e.slice(s?1:2,s?3:4),a=d.length,m=t[0],x=t.slice(2).map((v,y)=>v+(v-1)*(r[y]-1)),w=d.map((v,y)=>v+o[y]+o[y+a]).map((v,y)=>Math.floor((v-x[y]+n[y])/n[y]));return w.splice(0,0,u),w.splice(s?3:1,0,m),w},ci=[2,3,1,0],Ml=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},pi=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();Ct.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},Rn=e=>{let t=Ur(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,d=e.pads,a=e.strides,m=e.w_is_const();return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:d,strides:a,wIsConst:m,...t})},Bl=(e,t,r)=>{let o=pi(r,t);if(r.group!==1){e.compute(Tn(t,o));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],d=t[0].dims[n?2:3],a=t[0].dims[n?3:1],m=t[1].dims[2],g=t[1].dims[3],x=On(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),b=x[n?1:2],w=x[n?2:3],v=x[n?3:1],y=n&&m===u&&g===d&&r.pads[0]===0&&r.pads[1]===0;if(y||m===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let _=x[0],z,F,q,le=[];if(n){let B=e.kernelCustomData.wT??e.compute(gt(t[1],ci),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=B),y){let K=u*d*a;z=t[0].reshape([1,_,K]),F=B.reshape([1,K,v]),q=[1,_,v]}else z=t[0].reshape([_,u*d,a]),F=B.reshape([1,a,v]),q=[_,b*w,v];le.push(z),le.push(F)}else z=t[0].reshape([_,a,u*d]),F=t[1].reshape([1,v,a]),q=[_,v,b*w],le.push(F),le.push(z);s&&le.push(t[2]),e.compute(Lr(le,o,x,q,n),{inputs:le});return}let S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],ci),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let R=[t[0],A];s&&R.push(t[2]);let W=n?b*w:v,M=n?v:b*w,D=m*g*a;e.compute(ui(R,o,x,W,M,D,s,S),{inputs:R})},kl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),d=[1].concat(t.kernelShape),a=pi({...t,pads:n,strides:s,dilations:u,kernelShape:d},o);e.compute(Tn(o,a,m=>r?[m[0],m[2],m[3]]:[]))},Pn=(e,t)=>{Ml(e.inputs,t),e.inputs[0].dims.length===3?kl(e,t):Bl(e,e.inputs,t)}});var Dl,fi,mi=H(()=>{"use strict";mt();ge();Vr();En();ir();Dl=(e,t=!1,r,o=!1,n=4)=>{let s=We(n,"f32"),u=A=>{switch(A){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${A} is not supported.`)}},d=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,a=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"outBackprop[1]":"outBackprop[2]",g=e?"outBackprop[2]":"outBackprop[3]",x=e?"row":"col",b=e?"col":"row",w=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${x} / outWidth;\n      let outCol = ${x} % outWidth;\n\n      let WRow = ${b} / (filterDims[1] * inChannels);\n      let WCol = ${b} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${b} % inChannels;\n      ${d}\n      return x[getIndexFromCoords4D(coord, xShape)/${n}];`,v=e?`\n      let col = colIn * ${n};\n      if (row < dimAOuter && col < dimInner) {\n        ${w}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${n};\n      if (row < dimInner && col < dimBOuter) {\n        ${w}\n      }\n      return ${s}(0.0);`,y=`\n      let col = colIn * ${n};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(n)}\n      }\n      return ${s}(0.0);\n      `;return`\n  ${Wr(r,o,n===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?v:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?y:v}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${n};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${a}\n      ${zr(t,r)}\n      result[getIndexFromCoords4D(coords, outShape)/${n}] = value;\n    }\n  }`},fi=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",m=a?e[0].dims[3]:e[0].dims[1],g=r[0],x=a?r[2]:r[3],b=a?r[1]:r[2],w=a?r[3]:r[1],v=a?m%4===0&&w%4===0:x%4===0&&w%4===0,y=a?w:x*b,S=a?x*b:w,A=v?[8,8,1]:[y<=4||S<=4?4:16,y>4&&S<=4?4:16,1],R=v?[4,4,1]:[y<=4?1:4,y>4&&S<=4?1:4,1],W=[Math.ceil(y/A[0]/R[0]),Math.ceil(S/A[1]/R[1]),Math.ceil(g/A[2]/R[2])];Ee("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${W}`);let M=v?4:1,D=Math.max(A[0]*M,A[1]),_=[`@group(0) @binding(0) var<storage, read> x: array<${v?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],z="";return u&&(_.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?"vec4<f32>":"f32"}>;`),z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?"vec4<f32>":"f32"} {\n          return bias[coords.${a?"w":"y"}${v?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${Gr}\n        ${_.join(`\n`)}\n        @group(0) @binding(${_.length}) var<storage, read_write> result: array<${v?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${z}\n        ${Dl(a,u,t.activation.toLowerCase(),!1,M)}\n        ${v?or(R,A,"f32",void 0,!a,D):ar(R,A,"f32",void 0,!a,D,!1,void 0,d)}`}}});var Wl,Mn,hi=H(()=>{"use strict";mt();ge();ve();Wl=(e,t,r,o,n,s,u=!1,d)=>{let a=r.format==="NHWC",m=a?1:2,g=a?2:3,x=a?3:1,b=k.size(o),w=u?2:1,v=r.group,y=t[1].dims,S=y[0]/v,A=y[1],R=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${u?`vec4<${d}>`:d}(value);\n  }`;n&&(R+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${d}>`:d} {\n      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];\n    }`);let W=u?4:1,M=L("W",t[1].dataType,t[1].dims,W),D=L("Dy",t[0].dataType,t[0].dims,W),_=[D,M];n&&_.push(L("bias",t[2].dataType,[o[x]],W));let z=X("result",t[0].dataType,o,W),F=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${D.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${x}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${z.set("batch","r","c + i","d1","value")};\n        }\n      }`,q=`\n          let outputIndices = ${z.offsetToIndices("global_idx")};\n          let batch = ${z.indicesGet("outputIndices",0)};\n          let d1 = ${z.indicesGet("outputIndices",x)};\n          let r = ${z.indicesGet("outputIndices",m)};\n          let c = ${z.indicesGet("outputIndices",g)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${A};\n          let wOutChannel = d1 - groupId * ${A};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${m}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${g}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${S};\n              for (var d2: u32 = 0; d2 < ${S}; d2 = d2 + 1) {\n                let xValue = ${a?D.get("batch","idyR","idyC","inputChannel"):D.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${M.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${z.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(..._,z)}\n  ${R}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${u?F:q}}`},Mn=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=k.size(n),u=[Math.ceil(s/64),1,1];Ee("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let d=Me(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>Wl(a,e,t,n,o,u[1]===1&&u[2]===1,!1,d)}}});var zl,Vl,Gl,gi,yi,Nl,Ul,Ll,Fl,bi,wi=H(()=>{"use strict";Pe();mi();hi();nr();rr();zl=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,Vl=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},Gl=(e,t,r,o,n,s,u,d,a,m)=>{let g=e.length-2,x=m.length===0;if(a.length===0)for(let v=0;v<g;++v)a.push(0);let b=e[0],w=t[d?3:1]*n;for(let v=0,y=e.length-g-(d?1:0);v<g;++v,++y){let S=e[y],A=x?S*u[v]:m[v],R=zl(S,u[v],s[v],t[y],r[v],A);Vl(R,o,s,v,v+g),x&&m.push(u[v]*(S-1)+a[v]+(t[y]-1)*r[v]+1-s[v]-s[v+g])}m.splice(0,0,b),m.splice(d?3:1,0,w)},gi=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,w)=>b*w,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),d=t[0].dims,a=e.dilations.slice();if(a.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;a=new Array(b).fill(1)}let m=e.strides.slice();if(m.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;m=new Array(b).fill(1)}Gl(d,r,a,e.autoPad,e.group,n,m,o,u,s);let g=Object.assign({},e),x=e.cacheKey+[r.join("n,"),n.join(","),m.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:m,cacheKey:x}),g},yi=e=>{let t=Ur(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,d=e.pads,a=e.strides,m=e.wIsConst(),g=e.outputPadding,x=e.outputShape;return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:g,outputShape:x,pads:d,strides:a,wIsConst:m,...t})},Nl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((g,x)=>g+x,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((g,x)=>g+x,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((g,x)=>g+x,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((g,x)=>g+x,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ul=[2,3,1,0],Ll=(e,t,r)=>{let o=gi(r,t),n=r.format==="NHWC",s=t.length===3;if(o.group!==1){e.compute(Mn(t,o));return}let u=o.outputShape,d=u[n?1:2],a=u[n?2:3],m=u[n?3:1],g=t[1].dims[2],x=t[1].dims[3],b=t[0].dims[n?3:1],w=n?d*a:m,v=n?m:d*a,y=g*x*b,S=!0,A=e.kernelCustomData.wT??e.compute(gt(t[1],Ul),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let R=[t[0],A];s&&(!n&&t[2].dims.length===1?R.push(t[2].reshape([t[2].dims[0],1,1])):R.push(t[2])),e.compute(fi(R,o,u,w,v,y,s,S),{inputs:R})},Fl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=gi({...t,pads:d,strides:u,dilations:s,kernelShape:n},o);e.compute(Mn(o,a,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},bi=(e,t)=>{Nl(e.inputs,t),e.inputs[0].dims.length===3?Fl(e,t):Ll(e,e.inputs,t)}});var Bn,Fr,vi,Hl,jl,kn,Dn,Kl,$i,xi,Si=H(()=>{"use strict";ge();Pe();ve();Bn="[a-zA-Z]|\\\\.\\\\.\\\\.",Fr="("+Bn+")+",vi="^"+Fr+"$",Hl="("+Fr+",)*"+Fr,jl="^"+Hl+"$",kn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Dn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(jl)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,a)=>{let m=t[a].dims.slice();if(!d.match(RegExp(vi)))throw new Error("Invalid LHS term");let g=this.processTerm(d,!0,m,a);this.lhs.push(g)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([d,a])=>a.count===1||d==="...").map(([d])=>d).join("");else if(!n.match(RegExp(Fr)))throw new Error("Invalid RHS");n.match(RegExp(Bn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(d);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,d=[],a=0;if(!t.match(RegExp(vi))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(Bn,"g")),g=new kn(n);return m?.forEach((x,b)=>{if(x==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-m.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(a,a+w),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<d.length;v++){let y=String.fromCharCode("0".charCodeAt(0)+b);g.addSymbol(y,b+v),this.addSymbol(y,o[a++],n)}}else g.addSymbol(x,b),this.addSymbol(x,o[a++],n)}),g}},Kl=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let W=0;W<e.length;++W)o[W]=L(`input${W}`,r,e[W].dims);let n=t.outputDims,s=k.size(n),u=X("output",r,n),d=[],a=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",g="var sum = 0.0;",x="sum += prod;",b=[],w=[],v=[],y=[],S=t.symbolToInfo.size===a.length;t.symbolToInfo.forEach((W,M)=>{if(a.includes(M)){let D=a.indexOf(M);t.lhs.forEach((_,z)=>{if(W.inputIndices.includes(z)){let F=_.symbolToIndices.get(M);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(q=>{d.push(`${o[z].indicesSet(`input${z}Indices`,q,u.indicesGet("outputIndices",D))}`)})}})}else t.lhs.forEach((D,_)=>{let z=t.symbolToInfo.get(M);if(z===void 0)throw new Error("Invalid symbol error");if(z.inputIndices.includes(_)){let F=D.symbolToIndices.get(M);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(q=>{b.push(`${o[_].indicesSet(`input${_}Indices`,q,`${M}`)}`)}),y.push(`prod *= ${o[_].getByIndices(`input${_}Indices`)};`)}}),w.push(`for(var ${M}: u32 = 0; ${M} < ${t.symbolToInfo.get(M)?.dimValue}; ${M}++) {`),v.push("}")});let A=S?[...d,`let sum = ${o.map((W,M)=>W.getByIndices(`input${M}Indices`)).join(" * ")};`]:[...d,g,...w,...b,m,...y,x,...v],R=W=>`\n      ${W.declareVariables(...o,u)}\n\n      ${W.mainStart()}\n        ${W.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${u.offsetToIndices("global_idx")};\n        ${o.map((M,D)=>`var input${D}Indices: ${o[D].type.indices};`).join(`\n`)}\n        ${A.join(`\n`)};\n        ${u.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:R}},$i=(e,t)=>{let r=new Dn(e.inputs,t.equation);e.compute(Kl(e.inputs,r))},xi=e=>{let t=e.equation.replace(/\\s+/g,"");return ie({equation:t})}});var ql,Ci,Yl,Xl,Ai,Ii=H(()=>{"use strict";ge();ve();ql=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Ci=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},Yl=(e,t)=>e.length>t.length?Ci(e,t):Ci(t,e),Xl=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Yl(t,r),n=k.size(o),s=e[0].dataType,u=L("input",s,t),d=X("output",s,o),a=m=>`\n  const inputShape = ${u.indices(...t)};\n  ${m.declareVariables(u,d)}\n  ${m.mainStart()}\n  ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    var inputIndices: ${u.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${u.indicesGet("inputShape","i")} == 1) {\n        ${u.indicesSet("inputIndices","i",0)}\n      } else {\n        ${u.indicesSet("inputIndices","i",d.indicesGet("outputIndices",`i + ${o.length-t.length}`))}\n      }\n    }\n    ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:a,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Ai=e=>{ql(e.inputs),e.compute(Xl(e.inputs),{inputs:[0]})}});var Jl,Zl,Ei,Ti,Oi=H(()=>{"use strict";ge();Pe();ve();Jl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Zl=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=k.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let d=r[s],a=k.size(u),m=L("data",e[0].dataType,e[0].dims),g=L("inputIndices",e[1].dataType,e[1].dims),x=X("output",e[0].dataType,u),b=()=>{let v=o.length,y=`var indicesIndices  = ${g.type.indices}(0);`;for(let S=0;S<v;S++)y+=`${v>1?`indicesIndices[${S}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+S}]`:"outputIndices"};`;y+=`\n        var idx = ${g.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${d};\n        }\n        var dataIndices = ${m.type.indices}(0);\n      `;for(let S=0,A=0;S<n;S++)S===s?(y+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = u32(idx);`,A+=v):(y+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = ${u.length>1?`outputIndices[${A}]`:"outputIndices"};`,A++);return y},w=v=>`\n      ${v.declareVariables(m,g,x)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n        let outputIndices = ${x.offsetToIndices("global_idx")};\n        ${b()};\n        let value = ${m.getByIndices("dataIndices")};\n        ${x.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:w}},Ei=e=>ie({axis:e.axis}),Ti=(e,t)=>{let r=e.inputs;Jl(r),e.compute(Zl(e.inputs,t))}});var Ql,ed,_i,Ri,Pi=H(()=>{"use strict";ge();Pe();ve();Ql=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},ed=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=k.computeStrides(r),u=k.size(r),d=e[1].dims,a=e[1].dataType,m=k.size(d),g=k.normalizeAxis(t.axis,n),x=r[g],b=d.slice(0),w=k.size(b),v=L("input",o,r),y=L("indices",a,[m]),S=X("output",o,b),A=R=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(W=>`${W}u`).join(",")});\n      ${R.declareVariables(v,y,S)}\n      ${R.mainStart()}\n      ${R.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n\n      let outputIndices = ${S.offsetToIndices("global_idx")};\n\n      var idx = ${y.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${x};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${g}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${S.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${u}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:A}},_i=e=>ie({axis:e.axis}),Ri=(e,t)=>{let r=e.inputs;Ql(r),e.compute(ed(e.inputs,t))}});var td,rd,nd,Mi,Bi,ki=H(()=>{"use strict";ge();Pe();ve();td=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},rd=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},nd=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=_r.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[n,s];if(!d)throw new Error("Can\'t use gemm on the given tensors");let a=k.size(d),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let g=Me(e[0].dataType),x=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${rd(n,s,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let v=y=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${g}(${t.alpha});\n  const beta = ${g}(${t.beta});\n\n  ${w.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${g}>;\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${g}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${m}\n    }\n\n    ${x}\n    ${b}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:v}},Mi=(e,t)=>{td(e.inputs),e.compute(nd(e.inputs,t))},Bi=e=>ie(e)});var od,ad,id,sd,Di,Wi,zi=H(()=>{"use strict";De();ge();Pe();ve();od={name:"InstanceNormalization"},ad=(e,t)=>{let r=e[0].dims,o=r,n=2,s=k.sizeToDimension(r,n),u=k.sizeFromDimension(r,n),d=r[1],a=L("x",e[0].dataType,[r[0],r[1],u]),m=L("scale",e[1].dataType,e[1].dims),g=L("bias",e[2].dataType,e[2].dims),x=X("output",e[0].dataType,[r[0],r[1],u]),b=[a,m,g,x],w=a.type.value,v=64,y=S=>`\n\n  const C: u32 = ${d};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${w};\n  var<workgroup> squaredNormShared : ${w};\n  var<workgroup> workgroupShared : array<${w}, ${v}>;\n  const workgroupSize = ${v}u;\n  ${S.declareVariables(...b)}\n  ${S.mainStart(v)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${w} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${a.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${w}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${a.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${w}(normSize) + epsilon);\n    let channelScale = invStdDev * ${m.getByOffset("channel")};\n    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${a.get("batch","channel","h")} * channelScale + channelShift;\n      ${x.set("batch","channel","h","value")};\n    }\n  }`;return{...od,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:y}},id=(e,t,r,o,n,s,u,d)=>{let a=lt(u),m=L("input",t.dataType,t.dims,a),g=L("scale",r.dataType,r.dims,a),x=L("bias",o.dataType,o.dims,a),b=64,w=a===1?"vec2f":`mat2x${a}f`,v=a===1?"f32":`vec${a}f`,y=(D,_)=>`${w}(${D}, ${_})`,S=n*u/a,A=Math.ceil(s/b),R=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${s*u/a};\n\n  ${D.declareVariables(m)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart(b)}\n    let currentImageNumber = global_idx / ${b} / C;\n    let currentChannelNumber = (global_idx / ${b}) % C;\n    let wgId = global_idx % ${b};\n    let wgOffset = wgId * ${A};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${A}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${qe("f32",a)};\n    var squaredSum = ${qe("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${v}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${y("sum","squaredSum")};\n  }`,W=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,b,2],dataType:1}],dispatchGroup:{x:n*u/a}}),getShaderSource:R},{inputs:[t],outputs:[-1]})[0],M=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${b*u/a};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${w}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${g.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${x.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart()}\n    ${D.guardAgainstOutOfBoundsWorkgroupSizes(S)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${qe("f32",a)};\n    var squaredSum = ${qe("f32",a)};\n    for (var i: u32 = 0; i < ${b}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${b}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${v}(scale[currentChannelNumber]);\n    let channelShift = ${v}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${y("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u,epsilon:d})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:M},{inputs:[W,r,o],outputs:[-1]})[0]},sd=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],d=k.sizeFromDimension(o,1)/u,a=lt(u),m=k.size(n)/a,g=L("input",t[0].dataType,t[0].dims,a),x=X("output",t[0].dataType,n,a),b=Me(t[0].dataType),w=a===1?"vec2f":`mat2x${a}f`,v=a===1?b:`vec${a}<${b}>`,y=id(e,t[0],t[1],t[2],s,d,u,r.epsilon),S=A=>`\n  const H: u32 = ${d};\n  const C: u32 = ${u/a};\n\n  @group(0) @binding(0) var<storage, read> input : array<${g.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${x.type.storage}>;\n\n  ${A.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${v}(scale[0]), ${v}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:S},{inputs:[t[0],y]})},Di=e=>ie({epsilon:e.epsilon,format:e.format}),Wi=(e,t)=>{t.format==="NHWC"?sd(e,e.inputs,t):e.compute(ad(e.inputs,t))}});var ud,ld,Vi,Gi,Ni=H(()=>{"use strict";De();ge();Pe();ve();ud=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ld=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,d=k.normalizeAxis(t.axis,o.length),a=k.sizeToDimension(o,d),m=k.sizeFromDimension(o,d),g=k.size(n.dims),x=s?k.size(s.dims):0;if(g!==m||s&&x!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${g} and bias size of ${x}`);let b=[];for(let M=0;M<o.length;++M)M<d?b.push(o[M]):b.push(1);let w=lt(m),v=Me(e[0].dataType),y=[L("x",e[0].dataType,e[0].dims,w),L("scale",n.dataType,n.dims,w)];s&&y.push(L("bias",s.dataType,s.dims,w)),y.push(X("output",e[0].dataType,u,w));let S=r>1,A=r>2;S&&y.push(X("meanDataOutput",1,b)),A&&y.push(X("invStdOutput",1,b));let R=M=>`\n  const normSize: f32 = ${m};\n  const normSizeVectorized: u32 = ${m/w};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${M.declareVariables(...y)}\n  ${M.mainStart()}\n    ${M.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${qe("f32",w)};\n    var meanSquareVector = ${qe("f32",w)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${At(v,w,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${ht("meanVector",w)} / normSize;\n    let meanSquare = sqrt(${ht("meanSquareVector",w)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${At(v,w,"x[j + offset]")};\n      let f32scale = ${At(v,w,"scale[j]")};\n      output[j + offset] = ${y[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${At(v,w,"bias[j]")}`:""}\n      );\n    }\n\n    ${S?"meanDataOutput[global_idx] = mean":""};\n    ${A?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,W=[{dims:u,dataType:e[0].dataType}];return S&&W.push({dims:b,dataType:1}),A&&W.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:R}},Vi=e=>ie({axis:e.axis,epsilon:e.epsilon}),Gi=(e,t)=>{ud(e.inputs),e.compute(ld(e.inputs,t,e.outputCount))}});var dd,Ui,Li=H(()=>{"use strict";ge();ir();dd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Ui=e=>{dd(e.inputs);let t=Qe.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(Lr(e.inputs,{activation:"",activationCacheKey:""},t))}});var cd,pd,fd,md,hd,gd,yd,bd,wd,Fi,Hi,ji=H(()=>{"use strict";De();ge();Pe();ve();cd=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},pd=(e,t,r,o,n,s,u)=>{let d=r.length,a="";for(let m=d-1;m>=0;--m)a+=`\n            k = i32(${e.indicesGet("indices",m)}) - ${n[m]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[m]}) {\n              break;\n            }\n            offset += k * ${o[m]};\n        `;return`\n          value = ${s}(${u});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${a}\n            value = x[offset];\n          }\n      `},fd=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[d]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[d]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},md=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[d]}) {\n                  k = ${r[d]-1};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},hd=(e,t,r,o,n)=>{let s=r.length,u="";for(let d=s-1;d>=0;--d)u+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${n[d]};\n                if (k < 0)  {\n                  k += ${r[d]};\n                }\n                if (k >= ${r[d]}) {\n                  k -= ${r[d]};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},gd=(e,t,r,o,n,s)=>{switch(n.mode){case 0:return pd(e,t,r,o,n.pads,s,n.value);case 1:return fd(e,t,r,o,n.pads);case 2:return md(e,t,r,o,n.pads);case 3:return hd(e,t,r,o,n.pads);default:throw new Error("Invalid mode")}},yd=(e,t,r,o)=>{let n=t[0].dims,s=k.padShape(n.slice(),r.pads),u=k.size(s),d=k.computeStrides(n),a=X("output",t[0].dataType,s),m=L("x",t[0].dataType,n),g=gd(a,s,n,d,r,o);return`\n              ${e.declareVariables(m,a)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${a.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${g}\n              output[global_idx] = value;\n          }`},bd=(e,t)=>{let r=k.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(r)/64)}}),getShaderSource:o=>yd(o,e,t,"f32")}},wd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let a=0;a<d.length;a++)s[Number(d[a])]=Number(r[a]),s[Number(d[a])+n]=Number(r[a+d.length])}else r.forEach((d,a)=>s[Number(a)]=Number(d));let u=[];return s.forEach(d=>u.push(d)),ie({mode:t.mode,value:o,pads:u})}else return t},Fi=(e,t)=>{cd(e.inputs);let r=wd(e.inputs,t);e.compute(bd(e.inputs,r),{inputs:[0]})},Hi=e=>{let t=e.mode,r=e.value,o=e.pads;return ie({mode:t,value:r,pads:o})}});var Hr,Ki,qi,Yi,Xi,Ji,Zi,Qi,es,ts,rs,ns,os,as,is,ss=H(()=>{"use strict";ge();Pe();ve();Hr=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Ki=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),d=t.strides.slice(),a=s?t.dilations.slice():[],m=t.pads.slice();Ct.adjustPoolAttributes(r,n,u,d,a,m);let g=Ct.computePoolOutputShape(r,n,d,a,u,m,t.autoPad),x=Object.assign({},t);s?Object.assign(x,{kernelShape:u,strides:d,pads:m,dilations:a,cacheKey:t.cacheKey}):Object.assign(x,{kernelShape:u,strides:d,pads:m,cacheKey:t.cacheKey});let b=g.slice();return b.push(b.splice(1,1)[0]),[x,o?b:g]},qi=(e,t,r,o,n,s,u,d)=>{let a=n.format==="NHWC",m=r,g=t.type.value,x=m.length,b=k.size(o),w=X("output",t.type.tensor,o);if(n.kernelShape.length<=2){let v=n.kernelShape[n.kernelShape.length-1],y=n.strides[n.strides.length-1],S=n.pads[n.pads.length/2-1],A=n.pads[n.pads.length-1],R=x-(a?2:1),W="",M="",D="";if(S+A!==0?W=`\n                for (var i: u32 = 0u; i < ${v}u; i++) {\n                  xIndices[${R}] = indices[${R}] * ${y} - ${S} + i;\n                  if (xIndices[${R}] < 0 || xIndices[${R}] >= ${m[R]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:W=`\n                for (var i: u32 = 0u; i < ${v}u; i++) {\n                  xIndices[${R}] = indices[${R}] * ${y} - ${S} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let z=n.kernelShape[n.kernelShape.length-2],F=n.strides[n.strides.length-2],q=n.pads[n.pads.length/2-2],le=n.pads[n.pads.length-2],B=x-(a?3:2),K=m[B];q+le!==0?M=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${F} - ${q} + j;\n                  if (xIndices[${B}] < 0 || xIndices[${B}] >= ${K}) {\n                    pad+= ${v};\n                    continue;\n                  }\n              `:M=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${B}] = indices[${B}] * ${F} - ${q} + j;\n                `,D=`\n              }\n            `}return`\n            ${e.declareVariables(t,w)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              var xIndices = ${w.offsetToIndices("global_idx")};\n\n              var value: ${g} = ${g}(${d});\n              var pad = 0;\n              ${M}\n              ${W}\n              ${D}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(a)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let v=k.size(n.kernelShape),y=k.computeStrides(n.kernelShape),S=y.length,A=n.pads.length,R=n.pads.reduce((D,_)=>D+_),W="";return R?W=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:W=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,w)}\n\n            const pads = array<u32, ${A}>(${n.pads.map(D=>`${D}u`).join(",")});\n            const inputDims = array<u32, ${x}>(${m.map(D=>`${D}u`).join(",")});\n            const kernelStrides = array<u32, ${S}>(${y.map(D=>`${D}u`).join(",")});\n            const strides = array<u32, ${S}>(${n.strides.map(D=>`${D}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              let xIndices = ${w.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${w.type.value}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${v}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${x-S}u; j < ${x}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${x-S}u]\n                    + offsets[j - ${x-S}u] - pads[j - 2u];\n                  ${W}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},Yi=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xi=(e,t,r,o)=>{let[n,s]=Ki(t,o,r),u=k.size(n.kernelShape),d=L("x",t.dataType,t.dims),a=d.type.value,m="value += x_val;",g="";return n.countIncludePad?g+=`value /= ${a}(${u});`:g+=`value /= ${a}(${u} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:x=>qi(x,d,t.dims,s,n,m,g,"0.0")}},Ji=e=>{let t=e.count_include_pad!==0,r=Yi(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ie({countIncludePad:t,...r})},Zi=(e,t)=>{Hr(e.inputs),e.compute(Xi("AveragePool",e.inputs[0],!1,t))},Qi={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},es=e=>{let t=e.format;return{format:t,...Qi,cacheKey:t}},ts=(e,t)=>{Hr(e.inputs),e.compute(Xi("GlobalAveragePool",e.inputs[0],!0,t))},rs=(e,t,r,o)=>{let[n,s]=Ki(t,o,r),u=`\n      value = max(x_val, value);\n    `,d="",a=L("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:m=>qi(m,a,t.dims,s,n,u,d,"-1e5")}},ns=(e,t)=>{Hr(e.inputs),e.compute(rs("MaxPool",e.inputs[0],!1,t))},os=e=>{let t=e.storage_order,r=e.dilations,o=Yi(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ie({storageOrder:t,dilations:r,...o})},as=e=>{let t=e.format;return{format:t,...Qi,cacheKey:t}},is=(e,t)=>{Hr(e.inputs),e.compute(rs("GlobalMaxPool",e.inputs[0],!0,t))}});var jr=H(()=>{"use strict"});var us=H(()=>{"use strict";jr()});var ls,ds=H(()=>{"use strict";ls="1.17.0-dev.20231103-1439da36fe"});var cs,Wn,ps=H(()=>{"use strict";ds();cs="warning",Wn={wasm:{},webgl:{},webgpu:{},versions:{common:ls},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);cs=e}},get logLevel(){return cs}};Object.defineProperty(Wn,"logLevel",{enumerable:!0})});var fs,ms=H(()=>{"use strict";ps();fs=Wn});var hs=H(()=>{"use strict"});var gs=H(()=>{"use strict";Kr()});var bs=H(()=>{"use strict"});var ws=H(()=>{"use strict";Kr()});var Kr=H(()=>{"use strict";hs();gs();bs();ws()});var qr=H(()=>{"use strict";Kr()});var vs=H(()=>{"use strict";jr();qr()});var $s=H(()=>{"use strict";vs()});var xs=H(()=>{"use strict"});var Ss=H(()=>{"use strict";jr();qr()});var Cs=H(()=>{"use strict";Ss()});var As=H(()=>{"use strict";us();ms();$s();qr();xs();Cs()});var Sd,Cd,Is,Es=H(()=>{"use strict";As();De();ve();Sd=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},Cd=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,d=X("output",o,s),a=d.type.storage,m=g=>`\n        ${g.declareVariables(d)}\n        ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${a}(${e}) + ${a}(global_idx) * ${a}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(g=>g.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},Is=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),fs.webgpu.validateInputContent&&Sd(t,r,o),e.compute(Cd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var Ad,Id,Ed,Td,Od,_d,Rd,Pd,Md,Bd,kd,Dd,Wd,zd,Vd,Ts,Os,_s=H(()=>{"use strict";ge();Pe();ve();Ad=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Id=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},Ed=(e,t,r,o,n,s)=>{let[u,d,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(g=>s.push(g));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(g=>o.push(g)),o.length!==0&&o.length!==m&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ad(o,t),t.axes.length>0&&Id(o,t.axes,m).forEach((g,x)=>o[x]=g)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(g=>n.push(Number(g))),n.length!==m||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},Td=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Od=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",_d=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},Rd=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},Pd=(e,t,r,o)=>{let n=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return o.axes.length>0?(o.axes.forEach(u=>r[u]=n),o.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(n,0,r.length),s.forEach((u,d)=>s[d]=Math.round(u*r[d]))),s},Md=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Bd=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(d=>`${d}u`).join(",")});\n        const outputShape = array<u32, ${o.length}>(${o.map(d=>`${d}u`).join(",")});\n        const scales = array<f32, ${n.length}>(${n.map(d=>`${d}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(d=>`${d}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${o.length}; i++) {\n          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,kd=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Dd=(e,t,r,o,n,s,u)=>{let[d,a,m,g]=r.length===2?[-1,0,1,-1]:n[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${a}] = max(0, min(row, ${r[a]} - 1));\n      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${g}] = channel;\n        inputIndices[${d}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${a}];\n      var col:f32 = originalIndices[${m}];\n      if (${s} && (row < 0 || row > (${r[a]} - 1) || col < 0 || col > ${r[m]} - 1)) {\n        return ${u};\n      }\n      row = max(0, min(row, ${r[a]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${g}]);\n        batch = u32(originalIndices[${d}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Wd=(e,t,r,o,n,s,u,d,a,m)=>{let[g,x]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],b=w=>{let v=w===g?"row":"col";return`\n      fn ${v}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${w}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[w]},\n        f32(${o[w]}), f32(${r[w]}), ${s[w]}, ${s[w]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[w]} - 1))) {\n          return ${a};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${v}: f32 = originalIdx + f32(i);\n          if (${v} < 0 || ${v} >= ${r[w]}) {\n            if (${m}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${a};\n            } else {\n              ${v} = max(0, min(${v}, ${r[w]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${w}] = u32(${v});\n          data[i + 1] = ${w===g?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${b(g)};\n    ${b(x)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},zd=(e,t,r,o,n,s)=>{let u=e.dims,d=_d(s,t.axes,u.length),a=Rd(u,o,n,t.axes),m=o.slice();o.length===0&&(m=u.map((S,A)=>S===0?1:a[A]/S),t.keepAspectRatioPolicy!=="stretch"&&(a=Pd(u,a,m,t)));let g=X("output",e.dataType,a),x=L("input",e.dataType,u),b=k.size(a),w=u.length===a.length&&u.every((S,A)=>S===a[A]),v=t.coordinateTransformMode==="tf_crop_and_resize",y=S=>`\n      ${Td(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${kd(x,u)};\n              ${Od(t.nearestMode,r)};\n              ${Bd(x,g,u,a,m,d,v)};\n              `;case"linear":return`\n              ${Md(g,u,a,m,d)};\n              ${Dd(x,g,u,a,m,v,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Wd(x,g,u,a,m,d,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${S.declareVariables(x,g)}\n      ${S.mainStart()}\n        ${S.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        if (${w}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${g.offsetToIndices("global_idx")};\n          var inputIndices: ${x.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${x.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${n.length>0?n:""}`},getShaderSource:y,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},Vd=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Ts=(e,t)=>{let r=[],o=[],n=[],s=Vd(e);Ed(e.inputs,t,s,r,o,n),e.compute(zd(e.inputs[0],t,s,r,o,n),{inputs:[0]})},Os=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,a=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return ie({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:d,mode:a,nearestMode:m})}});var Gd,Nd,Rs,Ps,Ms=H(()=>{"use strict";De();ge();Pe();ve();Gd=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},Nd=(e,t,r,o)=>{let n=e[0].dims,s=k.size(n),u=n,d=s,a=n.slice(-1)[0],m=o?n.slice(0,-1).concat(1):[],g=e.length>3,x=e.length>4,b=o&&r>1,w=o&&r>2,v=r>3,y=lt(a),S=[L("x",e[0].dataType,e[0].dims,y),L("skip",e[1].dataType,e[1].dims,y),L("gamma",e[2].dataType,e[2].dims,y)];g&&S.push(L("beta",e[3].dataType,e[3].dims,y)),x&&S.push(L("bias",e[4].dataType,e[4].dims,y)),S.push(X("output",e[0].dataType,u,y)),b&&S.push(X("meanOutput",1,m)),w&&S.push(X("invStdOutput",1,m)),v&&S.push(X("inputSkipBiasSum",e[0].dataType,u,y));let A=Me(e[0].dataType),R=M=>`\n      const hiddenSize: f32 = ${a};\n      const hiddenSizeVectorized: u32 = ${a/y};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${M.declareVariables(...S)}\n\n      ${M.mainStart()}\n        ${M.guardAgainstOutOfBoundsWorkgroupSizes(d/a)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${qe("f32",y)};\n        var squareSum = ${qe("f32",y)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${x?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${v?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${At(A,y,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${ht("sum",y)} / hiddenSize;\n        let variance = sqrt(${ht("squareSum",y)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${A}(mean)) / ${A}(variance) * gamma[i]\n           + ${g?"beta[i]":"0.0"};\n        }\n      }`,W=[{dims:u,dataType:e[0].dataType}];return r>1&&W.push({dims:m,dataType:1}),r>2&&W.push({dims:m,dataType:1}),r>3&&W.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:R,getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(d/a/64)}})}},Rs=(e,t)=>{Gd(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Nd(e.inputs,t,e.outputCount,!1),{outputs:o})},Ps=e=>{let t=e.epsilon;return ie({epsilon:t})}});var Ud,Yr,Ld,Bs,Fd,Hd,ks,Ds,Ws=H(()=>{"use strict";De();ge();Pe();ve();Ud=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Yr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Ld=(e,t)=>{if(e.length>1){let r=Yr(e,1),o=Yr(e,2),n=Yr(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ie({starts:r,ends:o,axes:n})}else return t},Bs=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},Fd=(e,t,r,o)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Hd=(e,t)=>{let r=e[0].dims,o=k.size(r),n=t.axes.length>0?k.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=Yr(e,4);s.forEach(y=>y!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((y,S)=>Bs(y,S,r,n,s)),d=t.ends.map((y,S)=>Bs(y,S,r,n,s));if(n.length!==r.length)for(let y=0;y<r.length;++y)n.includes(y)||(u.splice(y,0,0),d.splice(y,0,r[y]),s.splice(y,0,1));let a=s.map(y=>Math.sign(y));s.forEach((y,S,A)=>{if(y<0){let R=(d[S]-u[S])/y,W=u[S],M=W+R*s[S];u[S]=M,d[S]=W,A[S]=-y}});let m=r.slice(0);n.forEach((y,S)=>{m[y]=Math.ceil((d[y]-u[y])/s[y])});let g={dims:m,dataType:e[0].dataType},x=X("output",e[0].dataType,m),b=L("input",e[0].dataType,r),w=k.size(m),v=y=>`\n      ${y.declareVariables(b,x)}\n        const signs = array<i32, ${a.length}>(${a.map(S=>`${S}i`).join(",")});\n        const starts = array<u32, ${u.length}>(${u.map(S=>`${S}u`).join(",")});\n        const ends = array<u32, ${d.length}>(${d.map(S=>`${S}u`).join(",")});\n        const steps = array<u32, ${s.length}>(${s.map(S=>`${S}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(S=>`${S}u`).join(",")});\n\n        ${Fd(b,x,r,m)}\n        ${y.mainStart()}\n          ${y.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${x.setByOffset("global_idx",b.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:v,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(o/64)}})}},ks=(e,t)=>{Ud(e.inputs,t);let r=Ld(e.inputs,t);e.compute(Hd(e.inputs,r),{inputs:[0]})},Ds=e=>{let t=e.starts,r=e.ends,o=e.axes;return ie({starts:t,ends:r,axes:o})}});var jd,Kd,zs,Vs,Gs=H(()=>{"use strict";ge();Pe();ve();jd=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Kd=(e,t)=>{let r=Me(e.dataType),o=e.dims,n=k.size(o),s=64,u=t.axis;if(u<0&&(u=o.length+u),u<o.length-1)throw new Error("softmax only supports last axis for now.");let d=o[u],a=n/d,m=lt(d),g=d/m,x=m===1?r:`vec${m}<${r}>`,b=(y,S)=>S===4?`max(max(${y}.x, ${y}.y), max(${y}.z, ${y}.w))`:S===2?`max(${y}.x, ${y}.y)`:S===3?`max(max(${y}.x, ${y}.y), ${y}.z)`:y,w=r==="f32"?`var threadMax = ${x}(-3.402823e+38f);`:`var threadMax = ${x}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:a}}),getShaderSource:y=>`\n      var<workgroup> rowMaxShared : ${x};\n      var<workgroup> rowSumShared : ${x};\n      var<workgroup> threadShared : array<${x}, ${s}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${x}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${x}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${x} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${x}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${s}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${s};\n        let row = gindex / wg;\n        let cols = ${g};\n        let row_stride : i32 = ${g};\n\n        // find the rows max\n        ${w}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${x}(${b("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${x}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${x}(${ht("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},zs=(e,t)=>{jd(e.inputs),e.compute(Kd(e.inputs[0],t))},Vs=e=>ie({axis:e.axis})});var qd,Yd,Xd,Jd,Zd,Ns,Us,Ls=H(()=>{"use strict";ge();Pe();ve();qd=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Yd=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),ie({numOutputs:o,axis:t.axis,splitSizes:r})},Xd=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Jd=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (outputNumber == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${o}) { ${n} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Zd=(e,t)=>{let r=e[0].dims,o=k.size(r),n=e[0].dataType,s=r.length,u=t.axis,d=u<0?r.length+u:u,a=new Array(t.numOutputs),m=L("input",n,r),g=new Array(t.numOutputs),x=[],b=[],w=0;for(let S=0;S<t.numOutputs;S++){w+=t.splitSizes[S],g[S]=w;let A=r.slice();A[t.axis]=t.splitSizes[S],b.push(A),a[S]=X(`output${S}`,n,b[S]),x.push({dims:b[S],dataType:e[0].dataType})}let v=s<2?"indices":`indices[${d}]`,y=S=>`\n  ${S.declareVariables(m,...a)}\n  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(A=>`${A}u`).join(",")});\n  ${Xd(g.length)}\n  ${Jd(a)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    var indices = ${m.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${v});\n    if (outputNumber != 0) {\n        ${v} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:y,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(o/64)}})}},Ns=(e,t)=>{qd(e.inputs);let r=e.inputs.length===1?t:Yd(e.inputs,t);e.compute(Zd(e.inputs,r),{inputs:[0]})},Us=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ie({axis:t,numOutputs:o,splitSizes:r})}});var Fs,Qd,ec,tc,Hs,js=H(()=>{"use strict";De();ge();ve();Fs=e=>Array.from(e.getBigInt64Array(),Number),Qd=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Fs(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ec=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},tc=e=>{let t=e[0].dims,r=Fs(e[1]),o=ec(t,r),n=k.size(o),s=e[0].dataType,u=L("input",s,t),d=X("output",s,o),a=m=>`\n      const inputShape = ${u.indices(...t)};\n      ${m.declareVariables(u,d)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      var inputIndices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${d.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};\n\n        ${u.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:a}},Hs=e=>{Qd(e.inputs),e.compute(tc(e.inputs),{inputs:[0]})}});var rc,nc,Ks,qs=H(()=>{"use strict";De();ge();ve();rc=(e,t,r,o,n)=>{let s=k.size(r),u=Math.ceil(s/4),d=X("outputData",n,r,4),a=L("aData",t[1].dataType,t[1].dims,4),m=L("bData",t[2].dataType,t[2].dims,4),g=L("cData",t[0].dataType,t[0].dims,4),x,b=(w,v,y)=>`select(${v}, ${w}, ${y})`;if(!o)x=d.setByOffset("global_idx",b(a.getByOffset("global_idx"),m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let w=(v,y,S="")=>{let A=`aData[indexA${y}][componentA${y}]`,R=`bData[indexB${y}][componentB${y}]`,W=`bool(cData[indexC${y}] & ${4278190080>>>(3-y)*8}u)`;return`\n            let outputIndices${y} = ${d.offsetToIndices(`global_idx * 4u + ${y}u`)};\n            let offsetA${y} = ${a.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let offsetB${y} = ${m.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let offsetC${y} = ${g.broadcastedIndicesToOffset(`outputIndices${y}`,d)};\n            let indexA${y} = offsetA${y} / 4u;\n            let indexB${y} = offsetB${y} / 4u;\n            let indexC${y} = offsetC${y} / 4u;\n            let componentA${y} = offsetA${y} % 4u;\n            let componentB${y} = offsetB${y} % 4u;\n            ${v}[${y}] = ${S}(${b(A,R,W)});\n          `};n===9?x=`\n            var data = vec4<u32>(0);\n            ${w("data",0,"u32")}\n            ${w("data",1,"u32")}\n            ${w("data",2,"u32")}\n            ${w("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:x=`\n            ${w("outputData[global_idx]",0)}\n            ${w("outputData[global_idx]",1)}\n            ${w("outputData[global_idx]",2)}\n            ${w("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(g,a,m,d)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        ${x}\n      }`},nc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(k.areEqual(t,r)&&k.areEqual(r,o)),u=t,d=k.size(t);if(s){let a=Qe.calcShape(Qe.calcShape(t,r,!1),o,!1);if(!a)throw new Error("Can\'t perform where op on the given tensors");u=a,d=k.size(u)}return{name:"Where",getShaderSource:a=>rc(a,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(d/64/4)}})}},Ks=e=>{e.compute(nc(e.inputs))}});var Ys,Xs=H(()=>{"use strict";ca();fa();ja();ni();ii();_n();wi();Si();Ii();Oi();Pi();ki();zi();Ni();Li();ji();ss();Es();Mr();_s();Ms();Ws();Gs();Ls();js();rr();In();qs();Ys=new Map([["Abs",[ma]],["Acos",[ha]],["Acosh",[ga]],["Add",[Ka]],["ArgMax",[da,Cn]],["ArgMin",[la,Cn]],["Asin",[ya]],["Asinh",[ba]],["Atan",[wa]],["Atanh",[va]],["AveragePool",[Zi,Ji]],["BiasAdd",[pa]],["BiasSplitGelu",[Ha]],["Cast",[xa,$a]],["Ceil",[Ca]],["ClipV10",[An]],["Clip",[Sa]],["Concat",[oi,ai]],["Conv",[Pn,Rn]],["ConvTranspose",[bi,yi]],["Cos",[Aa]],["Cosh",[Ia]],["Div",[qa]],["Einsum",[$i,xi]],["Elu",[Ea,kr]],["Equal",[Ya]],["Erf",[Ta]],["Exp",[Oa]],["Expand",[Ai]],["Floor",[_a]],["FusedConv",[Pn,Rn]],["Gather",[Ti,Ei]],["GatherElements",[Ri,_i]],["Gelu",[Ra]],["Gemm",[Mi,Bi]],["GlobalAveragePool",[ts,es]],["GlobalMaxPool",[is,as]],["Greater",[Qa]],["GreaterOrEqual",[ti]],["InstanceNormalization",[Wi,Di]],["LayerNormalization",[Gi,Vi]],["LeakyRelu",[Pa,kr]],["Less",[ei]],["LessOrEqual",[ri]],["Log",[Fa]],["MatMul",[Ui]],["MaxPool",[ns,os]],["Mul",[Xa]],["Neg",[Ba]],["Not",[Ma]],["Pad",[Fi,Hi]],["Pow",[Ja]],["Range",[Is]],["Reciprocal",[ka]],["ReduceMin",[ra,Ye]],["ReduceMean",[Jo,Ye]],["ReduceMax",[ta,Ye]],["ReduceSum",[oa,Ye]],["ReduceProd",[na,Ye]],["ReduceL1",[Zo,Ye]],["ReduceL2",[Qo,Ye]],["ReduceLogSum",[ia,Ye]],["ReduceLogSumExp",[ea,Ye]],["ReduceSumSquare",[aa,Ye]],["Relu",[Da]],["Resize",[Ts,Os]],["Sigmoid",[Wa]],["Sin",[za]],["Sinh",[Va]],["Slice",[ks,Ds]],["SkipLayerNormalization",[Rs,Ps]],["Split",[Ns,Us]],["Sqrt",[Ga]],["Softmax",[zs,Vs]],["Sub",[Za]],["Tan",[Na]],["Tanh",[Ua]],["ThresholdedRelu",[La,kr]],["Tile",[Hs]],["Transpose",[zo,Vo]],["Where",[Ks]]])});var Xr,Js=H(()=>{"use strict";De();mt();ve();Xr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s,u,d){let a=this.backend.device,m=this.backend.getComputePassEncoder();m.setPipeline(t.computePipeline);let g=[];for(let b of n)g.push({binding:g.length,resource:{buffer:b.buffer}});for(let b of s)g.push({binding:g.length,resource:{buffer:b.buffer}});d&&g.push({binding:g.length,resource:d});let x=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:g,label:t.programInfo.name});if(m.setBindGroup(0,x),m.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let b=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,b.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,v=this.backend.kernels.get(w),y=`[${v[0]}] ${v[1]}`;b.buffer.mapAsync(GPUMapMode.READ).then(()=>{let S=new BigUint64Array(b.buffer.getMappedRange()),A=S[0],R=S[1];b.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=A);let W=Number(A-this.backend.queryTimeBase),M=Number(R-this.backend.queryTimeBase);if(!Number.isSafeInteger(W)||!Number.isSafeInteger(M))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(b.id);let D="";r.forEach((z,F)=>{D+=`input[${F}]: [${z.dims}] | ${Qt(z.dataType)}, `});let _="";o.forEach((z,F)=>{_+=`output[${F}]: [${z.dims}] | ${Qt(z.dataType)}, `}),console.log(`[profiling] kernel "${w}|${y}" ${D}${_}execution time: ${M-W} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=ko(r),u=t.getShaderSource(s),d=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:d,label:t.name});Ee("verbose",()=>`[WebGPU] shader code: ${d}`);let m=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,d=Math.ceil(Math.sqrt(u));if(d>s){if(d=Math.ceil(Math.cbrt(u)),d>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var oc,ac,Jr,Zs=H(()=>{"use strict";mt();To();Po();Xs();Js();oc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},ac=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${oc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Jr=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Ro(this),this.programManager=new Xr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Io(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,o,n,s){let u=[];for(let A=0;A<r.length;++A){let R=this.gpuDataManager.get(r[A].data);if(!R)throw new Error(`no GPU data for input: ${r[A].data}`);u[A]=R}let d=ac(t,r),a=this.programManager.getArtifact(d),{outputs:m,dispatchGroup:g,programUniforms:x}=t.getRunData(r),b=o.length===0?m.map((A,R)=>R):o;if(b.length!==m.length)throw new Error(`Output size ${b.length} must be equal to ${m.length}.`);let w=[],v=[];for(let A=0;A<m.length;++A){if(!Number.isInteger(b[A])||b[A]<-3||b[A]>=m.length)throw new Error(`Invalid output index: ${b[A]}`);if(b[A]===-3)continue;let R=b[A]===-1,W=b[A]===-2,M=R||W?s(m[A].dataType,m[A].dims):n(b[A],m[A].dataType,m[A].dims),D=this.gpuDataManager.get(M.data);if(!D)throw new Error(`no GPU data for output: ${M.data}`);if(R&&this.temporaryData.push(D),W){let _=this.kernelPersistentData.get(this.currentKernelId);_||(_=[],this.kernelPersistentData.set(this.currentKernelId,_)),_.push(D)}w.push(M),v.push(D)}let y;if(x){let A=0,R=0,W=[],M=1;x.forEach(z=>{let F=typeof z.data=="number"?[z.data]:z.data,q;switch(F.length){case 1:q=4;break;case 2:q=8;break;case 3:q=16;break;case 4:q=16;break;case 5:q=16;break;case 6:q=16;break;default:throw new Error(`unsupported data length: ${F.length}`)}(R===5||R===6)&&(q=16),q>M&&(M=q),A=Math.ceil(A/q)*q,R=F.length,W.push(A),A+=F.length*4}),A=Math.ceil(A/M)*M;let D=new ArrayBuffer(A);x.forEach((z,F)=>{let q=W[F],le=typeof z.data=="number"?[z.data]:z.data;z.type==="int32"?new Int32Array(D,q,le.length).set(le):z.type==="uint32"?new Uint32Array(D,q,le.length).set(le):new Float32Array(D,q,le.length).set(le)});let _=this.gpuDataManager.create(A,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(_.buffer,0,D,0,A),this.gpuDataManager.release(_.id),y={offset:0,size:A,buffer:_.buffer}}let S=this.programManager.normalizeDispatchGroupSize(g);return a||(a=this.programManager.build(t,S),this.programManager.setArtifact(d,a)),Ee("info",()=>`[ProgramManager] run "${t.name}" (key=${d}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(a,r,w,u,v,S,y),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=Ys.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,d,a]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Ee("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),d(r,a[1]),0}catch(g){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${g}`)),1}finally{m&&o.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${s}] ${u}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),d=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await yn(this,t,r);return Eo(n.buffer,o)}}}});var Qs={};Ir(Qs,{init:()=>ic});var sr,zn,ic,eu=H(()=>{"use strict";De();Zs();mt();ge();sr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(k.size(t)!==k.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},zn=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let d=[];for(let a=0;a<u;a++){let m=n[s++],g=n[s++],x=n[s++],b=[];for(let w=0;w<x;w++)b.push(n[s++]);d.push(new sr(t,m,g,b))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,n=r?.outputs??[],s=(d,a,m)=>new sr(this.module,a,this.output(d,m),m),u=(d,a)=>{let m=er(d);if(!m)throw new Error(`Unsupported data type: ${d}`);let g=m*k.size(a);return new sr(this.module,d,this.backend.gpuDataManager.create(g).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},ic=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new Jr;await o.initialize(t),r(o,n=>o.alloc(n),n=>o.free(n),(n,s,u,d=!1)=>{if(d)Ee("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),o.memcpy(n,s);else{Ee("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let a=e.HEAPU8.subarray(n,n+u);o.upload(s,a)}},async(n,s,u)=>{Ee("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await o.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>o.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>o.releaseKernel(n),(n,s,u,d)=>{Ee("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let a=new zn(e,o,s);return o.computeKernel(n,a,d)})}}});var wo;wo=uo();var Ru=go(),pn,fn=!1,Er=!1,bo=!1,Pu=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Mu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Bu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",vo=async e=>{if(fn)return Promise.resolve();if(Er)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(bo)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Er=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=r>1&&Pu(),s=o&&Mu(),u=e.wasmPaths,d=typeof u=="string"?u:void 0,a=Bu(s,n),m=typeof u=="object"?u[a]:void 0,g=!1,x=[];if(t>0&&x.push(new Promise(b=>{setTimeout(()=>{g=!0,b()},t)})),x.push(new Promise((b,w)=>{let v=n?Ru:wo,y={locateFile:(S,A)=>{if(n&&S.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([yo()],{type:"text/javascript"}));if(S.endsWith(".wasm")){if(m)return m;let R=d??A;return a==="ort-wasm-simd.wasm"?R+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?R+"ort-wasm-simd-threaded.jsep.wasm":R+a}return A+S}};if(n)if(typeof Blob>"u")y.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let S=`var ortWasmThreaded=${v.toString()};`;y.mainScriptUrlOrBlob=new Blob([S],{type:"text/javascript"})}v(y).then(S=>{Er=!1,fn=!0,pn=S,b()},S=>{Er=!1,bo=!0,w(S)})})),await Promise.race(x),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(fn&&pn)return pn;throw new Error("WebAssembly is not initialized yet.")};var Be=(e,t)=>{let r=Re(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},Zt=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")Zt(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ae=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var $o=e=>{let t=Re(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Be(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&Zt(e.extra,"",new WeakSet,(u,d)=>{let a=Be(u,o),m=Be(d,o);t._OrtAddRunConfigEntry(r,a,m)!==0&&Ae(`Can\'t set a run config entry: ${u} - ${d}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var ku=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Du=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Wu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},zu=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let d=Be("deviceType",r),a=Be(u.deviceType,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.powerPreference){let d=Be("powerPreference",r),a=Be(u.powerPreference,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let d=Be("preferredLayout",r),a=Be(u.preferredLayout,r);Re()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Be(n,r);Re()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can\'t append execution provider: ${n}.`)}},xo=e=>{let t=Re(),r=0,o=[],n=e||{};Wu(n);try{let s=ku(n.graphOptimizationLevel??"all"),u=Du(n.executionMode??"sequential"),d=typeof n.logId=="string"?Be(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let m=n.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let g=typeof n.optimizedModelFilePath=="string"?Be(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,d,a,m,g),r===0&&Ae("Can\'t create session options."),n.executionProviders&&zu(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[x,b]of Object.entries(n.freeDimensionOverrides)){if(typeof x!="string")throw new Error(`free dimension override name must be a string: ${x}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let w=Be(x,o);t._OrtAddFreeDimensionOverride(r,w,b)!==0&&Ae(`Can\'t set a free dimension override: ${x} - ${b}.`)}return n.extra!==void 0&&Zt(n.extra,"",new WeakSet,(x,b)=>{let w=Be(x,o),v=Be(b,o);t._OrtAddSessionConfigEntry(r,w,v)!==0&&Ae(`Can\'t set a session config entry: ${x} - ${b}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};De();var ru=!1,sc=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},uc=(e,t)=>{Re()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},nu=async e=>{uc(e.wasm.numThreads,tr(e.logLevel));{let t=(eu(),Mt(Qs)).init;await t(Re(),e)}ru=!0},ur=new Map,ou=()=>ru,Vn=e=>{let t=Re(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Gn=(e,t)=>{let r=Re(),o=0,n=0,s=0,u=[],d=[],a=[];try{[n,u]=xo(t),o=r._OrtCreateSession(e[0],e[1],n),o===0&&Ae("Can\'t create a session.");let[m,g]=sc(o),x=[],b=[],w=[];for(let y=0;y<m;y++){let S=r._OrtGetInputName(o,y);S===0&&Ae("Can\'t get an input name."),d.push(S),x.push(r.UTF8ToString(S))}for(let y=0;y<g;y++){let S=r._OrtGetOutputName(o,y);S===0&&Ae("Can\'t get an output name."),a.push(S);let A=r.UTF8ToString(S);b.push(A);{let R=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[A]??"cpu";if(R!=="cpu"&&R!=="cpu-pinned"&&R!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${R}.`);w.push(R)}}let v=null;return w.some(y=>y==="gpu-buffer")&&(s=r._OrtCreateBinding(o),s===0&&Ae("Can\'t create IO binding."),v={handle:s,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(y=>hn(y))}),ur.set(o,[o,d,a,v]),[o,x,b]}catch(m){throw d.forEach(g=>r._OrtFree(g)),a.forEach(g=>r._OrtFree(g)),s!==0&&r._OrtReleaseBinding(s),o!==0&&r._OrtReleaseSession(o),m}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(m=>r._free(m))}},au=(e,t)=>{let r=Vn(e);return Gn(r,t)},iu=e=>{let t=Re(),r=ur.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),ur.delete(e)},tu=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=Re(),u=e[0],d=e[1],a=e[3],m,g;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let w=e[2].gpuBuffer,v=er(mn(u));g=d.reduce((y,S)=>y*S,1)*v,m=s.jsepRegisterBuffer(o,n,w,g)}else{let w=e[2];if(Array.isArray(w)){g=4*w.length,m=s._malloc(g),r.push(m);let v=m/4;for(let y=0;y<w.length;y++){if(typeof w[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);s.HEAPU32[v++]=Be(w[y],r)}}else g=w.byteLength,m=s._malloc(g),r.push(m),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,g),m)}let x=s.stackSave(),b=s.stackAlloc(4*d.length);try{let w=b/4;d.forEach(y=>s.HEAP32[w++]=y);let v=s._OrtCreateTensor(mn(u),m,g,b,d.length,hn(a));v===0&&Ae(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push(v)}finally{s.stackRestore(x)}},su=async(e,t,r,o,n,s)=>{let u=Re(),d=ur.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,m,g,x]=d,b=t.length,w=o.length,v=0,y=[],S=[],A=[],R=[],W=u.stackSave(),M=u.stackAlloc(b*4),D=u.stackAlloc(b*4),_=u.stackAlloc(w*4),z=u.stackAlloc(w*4);try{[v,y]=$o(s);for(let ae=0;ae<b;ae++)tu(r[ae],S,R,e,t[ae]);for(let ae=0;ae<w;ae++)tu(n[ae],A,R,e,b+o[ae]);let F=M/4,q=D/4,le=_/4,B=z/4;for(let ae=0;ae<b;ae++)u.HEAPU32[F++]=S[ae],u.HEAPU32[q++]=m[t[ae]];for(let ae=0;ae<w;ae++)u.HEAPU32[le++]=A[ae],u.HEAPU32[B++]=g[o[ae]];if(x){let{handle:ae,outputPreferredLocations:we,outputPreferredLocationsEncoded:j}=x;if(m.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${m.length}).`);for(let Se=0;Se<b;Se++){let Oe=t[Se];await u._OrtBindInput(ae,m[Oe],S[Se])!==0&&Ae(`Can\'t bind input[${Se}] for session=${e}.`)}for(let Se=0;Se<w;Se++){let Oe=o[Se];n[Se]?.[3]?u._OrtBindOutput(ae,g[Oe],A[Se],0)!==0&&Ae(`Can\'t bind pre-allocated output[${Se}] for session=${e}.`):u._OrtBindOutput(ae,g[Oe],0,j[Oe])!==0&&Ae(`Can\'t bind output[${Se}] to ${we[Se]} for session=${e}.`)}}let K;x?K=await u._OrtRunWithBinding(a,x.handle,w,_,v):K=await u._OrtRun(a,D,M,b,z,w,_,v),K!==0&&Ae("failed to call OrtRun().");let xe=[];for(let ae=0;ae<w;ae++){let we=u.HEAPU32[_/4+ae];if(we===A[ae]){xe.push(n[ae]);continue}let j=u.stackSave(),Se=u.stackAlloc(4*4),Oe=!1,Ie,Ce=0;try{u._OrtGetTensorData(we,Se,Se+4,Se+8,Se+12)!==0&&Ae(`Can\'t access output tensor data on index ${ae}.`);let Ne=Se/4,Le=u.HEAPU32[Ne++];Ce=u.HEAPU32[Ne++];let N=u.HEAPU32[Ne++],de=u.HEAPU32[Ne++],pe=[];for(let Te=0;Te<de;Te++)pe.push(u.HEAPU32[N/4+Te]);u._OrtFree(N);let ze=pe.reduce((Te,ke)=>Te*ke,1);Ie=Qt(Le);let Ue=x?.outputPreferredLocations[o[ae]];if(Ie==="string"){if(Ue==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Te=[],ke=Ce/4;for(let Ge=0;Ge<ze;Ge++){let Xe=u.HEAPU32[ke++],Fe=Ge===ze-1?void 0:u.HEAPU32[ke]-Xe;Te.push(u.UTF8ToString(Xe,Fe))}xe.push([Ie,pe,Te,"cpu"])}else if(Ue==="gpu-buffer"&&ze>0){let Te=u.jsepGetBuffer(Ce),ke=er(Le);if(ke===void 0||!So(Ie))throw new Error(`Unsupported data type: ${Ie}`);Oe=!0,xe.push([Ie,pe,{gpuBuffer:Te,download:u.jsepCreateDownloader(Te,ze*ke,Ie),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Te=Tr(Ie),ke=new Te(ze);new Uint8Array(ke.buffer,ke.byteOffset,ke.byteLength).set(u.HEAPU8.subarray(Ce,Ce+ke.byteLength)),xe.push([Ie,pe,ke,"cpu"])}}finally{u.stackRestore(j),Ie==="string"&&Ce&&u._free(Ce),Oe||u._OrtReleaseTensor(we)}}return x&&u._OrtClearBoundOutputs(x.handle),xe}finally{u.stackRestore(W),S.forEach(F=>u._OrtReleaseTensor(F)),A.forEach(F=>u._OrtReleaseTensor(F)),R.forEach(F=>u._free(F)),v!==0&&u._OrtReleaseRunOptions(v),y.forEach(F=>u._free(F))}},uu=e=>{let t=Re(),r=ur.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Ae("Can\'t get an profile file name."),t._OrtFree(n)},lu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{vo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{nu(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=Vn(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,o=Gn(t,r);postMessage({type:"create_finalize",out:o})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,o=au(t,r);postMessage({type:"create",out:o})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;iu(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:o,outputIndices:n,options:s}=e.data.in;su(t,r,o,n,s).then(u=>{postMessage({type:"run",out:u},lu(u))},u=>{postMessage({type:"run",err:u})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;uu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=ou();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'})),Nu=P((()=>{re(),zu(),Vo(),au=()=>!!c.wasm.proxy&&typeof document<"u",ou=!1,su=!1,uu=!1,cu=[],pu=[],fu=[],hu=[],mu=[],gu=[],yu=[],wu=()=>{if(ou||!su||uu||!iu)throw new Error("worker not ready")},$u=e=>{switch(e.data.type){case"init-wasm":ou=!1,e.data.err?(uu=!0,lu[1](e.data.err)):(su=!0,lu[0]());break;case"init-ort":e.data.err?du[1](e.data.err):du[0]();break;case"create_allocate":e.data.err?cu.shift()[1](e.data.err):cu.shift()[0](e.data.out);break;case"create_finalize":e.data.err?pu.shift()[1](e.data.err):pu.shift()[0](e.data.out);break;case"create":e.data.err?fu.shift()[1](e.data.err):fu.shift()[0](e.data.out);break;case"release":e.data.err?hu.shift()[1](e.data.err):hu.shift()[0]();break;case"run":e.data.err?mu.shift()[1](e.data.err):mu.shift()[0](e.data.out);break;case"end-profiling":e.data.err?gu.shift()[1](e.data.err):gu.shift()[0]();break;case"is-ort-env-initialized":e.data.err?yu.shift()[1](e.data.err):yu.shift()[0](e.data.out)}},vu=typeof document<"u"?document?.currentScript?.src:void 0,bu=async()=>{if(au()){if(su)return;if(ou)throw new Error("multiple calls to 'initWasm()' detected.");if(uu)throw new Error("previous call to 'initWasm()' failed.");return ou=!0,void 0===c.wasm.wasmPaths&&vu&&0!==vu.indexOf("blob:")&&(c.wasm.wasmPaths=vu.substr(0,+vu.lastIndexOf("/")+1)),new Promise(((e,t)=>{iu?.terminate();let n=URL.createObjectURL(new Blob([Wu()],{type:"text/javascript"}));(iu=new Worker(n,{name:"ort-wasm-proxy-worker"})).onerror=e=>t(e),iu.onmessage=$u,URL.revokeObjectURL(n),lu=[e,t];let r={type:"init-wasm",in:c.wasm};iu.postMessage(r)}))}return _e(c.wasm)},xu=async e=>{if(au())return wu(),new Promise(((t,n)=>{du=[t,n];let r={type:"init-ort",in:e};iu.postMessage(r)}));await qs(e)},Su=async e=>au()?(wu(),new Promise(((t,n)=>{cu.push([t,n]);let r={type:"create_allocate",in:{model:e}};iu.postMessage(r,[e.buffer])}))):Xs(e),_u=async(e,t)=>au()?(wu(),new Promise(((n,r)=>{pu.push([n,r]);let a={type:"create_finalize",in:{modeldata:e,options:t}};iu.postMessage(a)}))):Js(e,t),Cu=async(e,t)=>{if(au()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return wu(),new Promise(((n,r)=>{fu.push([n,r]);let a={type:"create",in:{model:e,options:t}};iu.postMessage(a,[e.buffer])}))}return Qs(e,t)},Eu=async e=>{if(au())return wu(),new Promise(((t,n)=>{hu.push([t,n]);let r={type:"release",in:e};iu.postMessage(r)}));Zs(e)},Iu=async(e,t,n,r,a,i)=>{if(au()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return wu(),new Promise(((a,o)=>{mu.push([a,o]);let s=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:s,outputIndices:r,options:i}};iu.postMessage(u,ru(s))}))}return tu(e,t,n,r,a,i)},Au=async e=>{if(au())return wu(),new Promise(((t,n)=>{gu.push([t,n]);let r={type:"end-profiling",in:e};iu.postMessage(r)}));nu(e)},Ou=async()=>au()?(wu(),new Promise(((e,t)=>{yu.push([e,t]),iu.postMessage({type:"is-ort-env-initialized"})}))):Ks()})),Gu=P((()=>{re(),Nu(),Lo(),Ru=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},ku=e=>{switch(e[3]){case"cpu":return new E(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Ge(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:a}=e[2];return E.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},Bu=class{async createSessionAllocate(e){let t=await fetch(e);if(200!==t.status)throw new Error(`failed to load model: ${e}`);let n=await t.arrayBuffer();return Su(new Uint8Array(n))}async loadModel(e,t){if(await Ou()||(Tu||(Tu=xu(c)),await Tu,Tu=void 0),"string"==typeof e)if(typeof process<"u"&&process.versions&&process.versions.node){let n=await(void 0)(e);[this.sessionId,this.inputNames,this.outputNames]=await Cu(n,t)}else{let n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await _u(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await Cu(e,t)}async dispose(){return Eu(this.sessionId)}async run(e,t,n){let r=[],a=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],i=this.inputNames.indexOf(t);if(-1===i)throw new Error(`invalid input '${t}'`);r.push(n),a.push(i)}));let i=[],o=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output '${t}'`);i.push(n),o.push(r)}));let s=r.map(((e,t)=>Ru(e,(()=>`input "${this.inputNames[a[t]]}"`)))),u=i.map(((e,t)=>e?Ru(e,(()=>`output "${this.outputNames[o[t]]}"`)):null)),l=await Iu(this.sessionId,a,s,o,u,n),d={};for(let e=0;e<l.length;e++)d[this.outputNames[o[e]]]=i[e]??ku(l[e]);return d}startProfiling(){}endProfiling(){Au(this.sessionId)}}})),Uu=P((()=>{re(),Nu(),Gu(),Mu=()=>{if(("number"!=typeof c.wasm.initTimeout||c.wasm.initTimeout<0)&&(c.wasm.initTimeout=0),"boolean"!=typeof c.wasm.simd&&(c.wasm.simd=!0),"boolean"!=typeof c.wasm.proxy&&(c.wasm.proxy=!1),"number"!=typeof c.wasm.numThreads||!Number.isInteger(c.wasm.numThreads)||c.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;c.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Du=class{async init(){Mu(),await bu()}async createInferenceSessionHandler(e,t){let n=new Bu;return await n.loadModel(e,t),Promise.resolve(n)}}})),Vu={};W(Vu,{wasmBackend:()=>ju});var ju,Fu=P((()=>{Uu(),ju=new Du})),Hu={};W(Hu,{InferenceSession:()=>A,Tensor:()=>E,TrainingSession:()=>T,default:()=>Lu,env:()=>c,registerBackend:()=>o}),e.exports=N(Hu),re(),re(),re();var Lu=ne;{let e=(Fu(),N(Vu)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&o("webgpu",e,5),o("cpu",e,10),o("wasm",e,10),o("xnnpack",e,9),o("webnn",e,9)}Object.defineProperty(c.versions,"web",{value:"1.17.0-dev.20231103-1439da36fe",enumerable:!0})}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}return n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{const e=n(122),t=28,r=28,a=28,i=28,o={mnist_model:["models/mnist_cnn.onnx"]},s=function(){var e={model:"mnist_model",provider:"webgpu",device:"gpu",threads:"1"};let t=window.location.search.substring(1).split("&");for(var n=0;n<t.length;n++){let r=t[n].split("=");if(r[0]in e)e[r[0]]=decodeURIComponent(r[1]);else if(r[0].length>0)throw new Error("unknown argument: "+r[0])}return e.threads=parseInt(e.threads),e}();let u;var l;e.env.wasm.numThreads=s.threads,e.env.wasm.proxy=!0;var d,c,p=[];function f(e){document.getElementById("status").innerHTML+=`<br>[${performance.now().toFixed(3)}] `+e,console.log(e)}async function h(t){return t=await e.Tensor.fromImage(t,options={resizedWidth:a,resizedHeight:i}),t=await async function(t){const n=t.data,r=new e.Tensor(n.slice(0,784),[1,1,28,28]);return f(`[resizeTensor] reshapedTensor is ${r.dims}`),r}(t),await async function(e){return isWhite=await async function(e,t=.3){var n=0;const r=e.data;for(let e=0;e<r.length;e++)1==r[e]&&(n+=1);var a=n/784;return f(`[ifWhiteBackground] percent whitenesss is ${a}; count is ${n}; ${e.dims}`),a>=t}(e),1==isWhite?(f("[invertWhiteBackground] yaay! image is white background; gotta invert!"),e=await async function(e){const t=e.data;for(let e=0;e<t.length;e++)t[e]=1-t[e];return e}(e),f("[invertWhiteBackground] yaay! image's white background inverted successfully!"),e):(f("[invertWhiteBackground] noo! img is NOT white background"),e)}(t)}async function m(e){const n=document.getElementById("prediction-element");n.innerHTML="?",u.disabled=!0;const a=document.createElement("canvas");a.style.cursor="wait",l=void 0;var i=e.width,o=e.height;i>o?i>t&&(o*=t/i,i=t):o>r&&(i*=r/o,o=r),i=Math.round(i),o=Math.round(o),a.width=i,a.height=o;var s=a.getContext("2d");f(`[modelForward] img.height: ${e.height}### img.width: ${e.width}`),s.drawImage(e,0,0,i,o),d=s.getImageData(0,0,i,o),f("[modelForward] before await imagePreprocessing...");const c=await h(d);f("[modelForward] after await imagePreprocessing..."),f(`[modelForward] ###imgTensor.dims is this: ${c.dims}###`),f(`[modelForward] ###imgTensor sample is this: ${c.data.slice(110,119)}###`);const m={"input.1":c},g=await p[0];performance.now(),f("[modelForward] s:"),f("[modelForward] forward passing image through the model"),l=await g.run(m),f("[modelForward] forward passing completed!");const y=await async function(e){for(key in e)f(`[getKeysAndValues] object[${key}]: ${e[key]}`);return e[key]}(l);probs=y.cpuData,max_prob=Math.max(...probs),maxInd=probs.indexOf(max_prob),probsArray=Array.from(probs),expProbNums=probsArray.map((function(e){return Number(Math.exp(e))})),totalProbNums=expProbNums.reduce(((e,t)=>e+t),0),expProbProbs=expProbNums.map((function(e){return Number((e/totalProbNums*100).toFixed(2))})),n.innerHTML=`<div class="tooltip_custom">${maxInd}<span class="tooltiptext_custom">Probabilities: ${expProbProbs.join("%, ")}%</span></div>`,f(`[modelForward] Class: ${maxInd} |  Probabilities: ${expProbProbs.join("%, ")}`),u.disabled=!1}function g(){var e=document.querySelector("video"),t=document.getElementById("original-image"),n=document.createElement("canvas");n.width=e.videoWidth,n.height=e.videoHeight,n.getContext("2d").drawImage(e,0,0,n.width,n.height),t.src=n.toDataURL("image/png"),console.log("[captureCameraImage] img.src rewritten!"),m(t),console.log("[captureCameraImage] model forward done!")}shouldCamOn=!1,document.addEventListener("DOMContentLoaded",(()=>{!async function(){const t=o[s.model];f(`[main] config.model: ${s.model}`),u=document.getElementById("file-in");let n=document.getElementById("original-image");f("[main] BEFORE model loading..."),async function(t,n){idx=0,f(`[load_model] idx: ${idx}`);let r=s.provider;switch(r){case"webnn":if(!("ml"in navigator))throw new Error("webnn is NOT supported");r={name:"webnn",deviceType:s.device,powerPreference:"default"},f("[load_model] webnn activated!");break;case"webgpu":if(!navigator.gpu)throw new Error("webgpu is NOT supported");f("[load_model] webgpu activated!")}const a={executionProviders:[r]};(async function(e){try{const t=await caches.open("onnx");s.clear_cache&&t.delete(e);let n=await t.match(e);return null==n?(await t.add(e),n=await t.match(e),f(`[fetchAndCache] ${e} loaded (from network)`)):f(`[fetchAndCache] ${e} loaded (from cache)`),await n.arrayBuffer()}catch(t){return f(`[fetchAndCache] ${e} (from network)`),await fetch(e).then((e=>e.arrayBuffer()))}})(t[idx]).then((r=>{p[idx]=e.InferenceSession.create(r,a),p[idx].then((()=>{f(`[load_model] [fetchAndCache.then] ${t[idx]} successfully loaded!`)}),(e=>{throw f(`[load_model] [fetchAndCache.then] ${t[idx]} load failed with ${e}.`),e})),f(void 0!==n?"[load_model] [fetchAndCache.then] img is defined!":"[load_model] [fetchAndCache.then] img is undefined!")}))}(t,n).then((()=>{}),(e=>{f(e)})),f("[main] model loaded; sess:"),f("[main] [special] before lone modelForward..."),await new Promise((e=>setTimeout(e,2e3))),m(n),f("[main] [special] after lone modelForward..."),n.onload=function(){f("[main] [img.onload] before model forwarding image..."),m(n),f("[main] [img.onload] after model forwarding image...")},u.onchange=function(e){f("[main] [filein.onchange] beginning of filein.onchange ...");let t=(e.target||window.event.src).files;if(FileReader&&t&&t.length){f("[main] [filein.onchange] [if (FileReader &&] before new filereader");let e=new FileReader;f("[main] [filein.onchange] [if (FileReader &&] after new filereader"),e.onload=()=>{f("[main] [filein.onchange] [if (FileReader &&] [fileReader.onload] before img.src = fileReader.result"),n.src=e.result,f("[main] [filein.onchange] [if (FileReader &&] [fileReader.onload] after img.src = fileReader.result")},e.readAsDataURL(t[0])}},cameraElement=document.getElementById("use_camera"),cameraElement.onchange=function(e){shouldCamOn=!shouldCamOn,1==shouldCamOn?function(){console.log(`[onCamera] button pressed... shouldCamOn: ${shouldCamOn}`);var e=document.getElementById("camera_div");document.getElementById("original-image").style.display="none",navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?navigator.mediaDevices.getUserMedia({video:!0}).then((function(t){var n=document.createElement("video");n.id="video-element",n.srcObject=t,n.autoplay=!0,n.style.width="100%",n.style.height="100%",e.appendChild(n),c=setInterval(g,3e3)})).catch((function(e){console.error("Error accessing the camera:",e)})):console.error("getUserMedia is not supported on this browser")}():function(){console.log(`[offCamera] button pressed... shouldCamOn: ${shouldCamOn}`);var e=document.getElementById("video-element");e.srcObject.getTracks().forEach((function(e){e.stop()})),e.remove(),console.log("[offCamera] camera_div removed..."),document.getElementById("original-image").style.display="inline",console.log("[offCamera] originalImage recovered..."),m(document.getElementById("original-image")),console.log("[offCamera] originalImage prediction complete..."),c&&clearInterval(c)}()}}()}))})(),{}})()));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLm1pbi5qcyIsIm1hcHBpbmdzIjoiO0NBQUEsU0FBMkNBLEVBQU1DLEdBQ2hELEdBQXNCLGlCQUFaQyxTQUEwQyxpQkFBWEMsT0FDeENBLE9BQU9ELFFBQVVELFNBQ2IsR0FBcUIsbUJBQVhHLFFBQXlCQSxPQUFPQyxJQUM5Q0QsT0FBTyxHQUFJSCxPQUNQLENBQ0osSUFBSUssRUFBSUwsSUFDUixJQUFJLElBQUlNLEtBQUtELEdBQXVCLGlCQUFaSixRQUF1QkEsUUFBVUYsR0FBTU8sR0FBS0QsRUFBRUMsRUFDdkUsQ0FDQSxDQVRELENBU0dDLE1BQU0sZ0RDVFQsRUFLeWhCQyxFQUFHQyxFQUFHQyxFQUFHQyxFQUEwK0JDLEVBQW9FQyxFQUFHQyxFQUFtV0MsRUFBMkNDLEVBQUdDLEVBQXl2RUMsRUFBR0MsRUFBR0MsRUFBR0MsRUFBR0MsRUFBc2hIQyxFQUFHQyxFQUFHQyxFQUFHQyxFQUEwdkJDLEVBQUdDLEVBQSt0QkMsRUFBdXBJQyxFQUEyQ0MsRUFBNHNHQyxFQUEyRUMsRUFBeStFQyxnQkFBcnBtQkMsRUFBR0MsT0FBT0MsZUFBbUJDLEVBQUdGLE9BQU9HLHlCQUE2QkMsRUFBR0osT0FBT0ssb0JBQXdCQyxFQUFHTixPQUFPTyxVQUFVQyxlQUFtQkMsRUFBRSxDQUFDQyxFQUFFQyxJQUFJLEtBQUtELElBQUlDLEVBQUVELEVBQUVBLEVBQUUsSUFBSUMsR0FBT0MsRUFBRyxDQUFDRixFQUFFQyxJQUFJLEtBQUtBLEdBQUdELEdBQUdDLEVBQUUsQ0FBQzlDLFFBQVEsQ0FBQyxJQUFJQSxRQUFROEMsR0FBR0EsRUFBRTlDLFNBQVNnRCxFQUFHLENBQUNILEVBQUVDLEtBQUssSUFBSSxJQUFJRyxLQUFLSCxFQUFFWixFQUFHVyxFQUFFSSxFQUFFLENBQUNDLElBQUlKLEVBQUVHLEdBQUdFLFlBQVcsR0FBRyxFQUFxTEMsRUFBR1AsR0FBbEwsRUFBQ0EsRUFBRUMsRUFBRUcsRUFBRTdDLEtBQUssR0FBRzBDLEdBQWEsaUJBQUhBLEdBQXVCLG1CQUFIQSxFQUFjLElBQUksSUFBSU8sS0FBS2QsRUFBR08sSUFBSUwsRUFBR2EsS0FBS1QsRUFBRVEsSUFBNEZFLFlBQXhGRixHQUFPbkIsRUFBR1csRUFBRVEsRUFBRSxDQUFDSCxJQUFJLElBQUlKLEVBQUVPLEdBQUdGLGFBQWEvQyxFQUFFaUMsRUFBR1MsRUFBRU8sS0FBS2pELEVBQUUrQyxhQUFhLE9BQU9OLEdBQWFVLENBQUdyQixFQUFHLENBQUMsRUFBRSxhQUFhLENBQUNzQixPQUFNLElBQUtYLEdBQW1CWSxFQUFHYixHQUFFLEtBQWtCckMsRUFBRyxJQUFJbUQsSUFBSWxELEVBQUcsR0FBR0MsRUFBRyxDQUFDb0MsRUFBRUMsRUFBRUcsS0FBSyxJQUFHSCxHQUFrQixtQkFBUkEsRUFBRWEsTUFBMEQsbUJBQWpDYixFQUFFYyw4QkFBcVksTUFBTSxJQUFJQyxVQUFVLHVCQUFuYyxDQUFxRixJQUFJekQsRUFBRUcsRUFBRzJDLElBQUlMLEdBQUcsUUFBTyxJQUFKekMsRUFBV0csRUFBR3VELElBQUlqQixFQUFFLENBQUNrQixRQUFRakIsRUFBRWtCLFNBQVNmLFFBQVEsQ0FBQyxHQUFHN0MsRUFBRTRELFNBQVNmLEVBQUUsT0FBTyxHQUFHN0MsRUFBRTRELFdBQVdmLEdBQUc3QyxFQUFFMkQsVUFBVWpCLEVBQUUsTUFBTSxJQUFJbUIsTUFBTSw0QkFBNEJwQixxQkFBcUJJLElBQUksQ0FBQyxHQUFHQSxHQUFHLEVBQUUsQ0FBQyxJQUFJSSxFQUFFN0MsRUFBRzBELFFBQVFyQixJQUFRLElBQUxRLEdBQVE3QyxFQUFHMkQsT0FBT2QsRUFBRSxHQUFHLElBQUksSUFBSWUsRUFBRSxFQUFFQSxFQUFFNUQsRUFBRzZELE9BQU9ELElBQUksR0FBRzdELEVBQUcyQyxJQUFJMUMsRUFBRzRELElBQUlKLFVBQVVmLEVBQW9CLFlBQWpCekMsRUFBRzJELE9BQU9DLEVBQUUsRUFBRXZCLEdBQVVyQyxFQUFHOEQsS0FBS3pCLEVBQUUsQ0FBTyxDQUEwQyxFQUFHbkMsRUFBRzZELFVBQVUsSUFBSXpCLEVBQWEsSUFBWEQsRUFBRXdCLE9BQVc3RCxFQUFHcUMsRUFBRUksRUFBRSxHQUFHLElBQUksSUFBSTdDLEtBQUswQyxFQUFFLENBQUMsSUFBSU8sRUFBRTlDLEVBQUcyQyxJQUFJOUMsR0FBRyxHQUFHaUQsRUFBRSxDQUFDLEdBQUdBLEVBQUVtQixZQUFZLE9BQU9uQixFQUFFVSxRQUFRLEdBQUdWLEVBQUVvQixRQUFRLFNBQVMsSUFBSUwsSUFBSWYsRUFBRXFCLFlBQVksSUFBSSxPQUFPTixJQUFJZixFQUFFcUIsWUFBWXJCLEVBQUVVLFFBQVFKLGNBQWNOLEVBQUVxQixZQUFZckIsRUFBRW1CLGFBQVksRUFBR25CLEVBQUVVLE9BQU8sQ0FBQyxNQUFNWSxHQUFHUCxHQUFHbkIsRUFBRXFCLEtBQUssQ0FBQ00sS0FBS3hFLEVBQUV5RSxJQUFJRixJQUFJdEIsRUFBRW9CLFNBQVEsQ0FBRSxDQUFDLGVBQWVwQixFQUFFcUIsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUlULE1BQU0sb0NBQW9DaEIsRUFBRTZCLEtBQUkxRSxHQUFHLElBQUlBLEVBQUV3RSxTQUFTeEUsRUFBRXlFLFFBQU9FLEtBQUssUUFBTyxDQUFDLElBQVFDLEVBQUdwQyxHQUFFLEtBQWtCYSxHQUFHLElBQVd3QixFQUFHckMsR0FBRSxLQUFrQmpDLEVBQUcsb0NBQTZDdUUsRUFBR3RDLEdBQUUsS0FBa0JxQyxJQUFLckUsRUFBRyxVQUFVQyxFQUFHLENBQUNzRSxLQUFLLENBQUMsRUFBRUMsTUFBTSxDQUFDLEVBQUVDLE9BQU8sQ0FBQyxFQUFFQyxTQUFTLENBQUNDLE9BQU81RSxHQUFJLFlBQUk2RSxDQUFTM0MsR0FBRyxRQUFPLElBQUpBLEVBQVcsQ0FBQyxHQUFhLGlCQUFIQSxJQUF3RSxJQUEzRCxDQUFDLFVBQVUsT0FBTyxVQUFVLFFBQVEsU0FBU3FCLFFBQVFyQixHQUFRLE1BQU0sSUFBSW9CLE1BQU0sOEJBQThCcEIsS0FBS2pDLEVBQUdpQyxDQUFDLENBQUMsRUFBRSxZQUFJMkMsR0FBVyxPQUFPNUUsQ0FBRSxHQUFHdUIsT0FBT0MsZUFBZXZCLEVBQUcsV0FBVyxDQUFDc0MsWUFBVyxHQUFHLElBQVdzQyxFQUFHN0MsR0FBRSxLQUFrQnNDLElBQUtwRSxFQUFHRCxLQUFlNkUsRUFBRzlDLEdBQUUsS0FBa0I3QixFQUFHLENBQUM4QixFQUFFQyxLQUFLLElBQUlHLEVBQUUwQyxTQUFTQyxjQUFjLFVBQVUzQyxFQUFFNEMsTUFBTWhELEVBQUVpRCxLQUFLLEdBQUc3QyxFQUFFOEMsT0FBT2xELEVBQUVpRCxLQUFLLEdBQUcsSUFBSTFGLEVBQUU2QyxFQUFFK0MsV0FBVyxNQUFNLEdBQU0sTUFBSDVGLEVBQVEsQ0FBQyxJQUFJaUQsRUFBRWUsT0FBb0IsSUFBbEJ0QixHQUFHbUQsY0FBd0MsU0FBakJuRCxFQUFFbUQsY0FBdUI1QyxFQUFFUixFQUFFaUQsS0FBSyxHQUFHMUIsRUFBRXZCLEVBQUVpRCxLQUFLLEtBQUt6QyxFQUFFUixFQUFFaUQsS0FBSyxHQUFHMUIsRUFBRXZCLEVBQUVpRCxLQUFLLElBQUksSUFBa0RJLEVBQUVDLEVBQWhEeEIsT0FBYyxJQUFaN0IsR0FBR3NELE9BQWdCdEQsRUFBRXNELE9BQU8sTUFBTUMsRUFBRXZELEdBQUd3RCxVQUFhLElBQUpELFFBQXFCLElBQVRBLEVBQUVFLEtBQWNMLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFvQixpQkFBUkcsRUFBRUUsS0FBZUwsRUFBRSxDQUFDRyxFQUFFRSxLQUFLRixFQUFFRSxLQUFLRixFQUFFRSxLQUFLRixFQUFFRSxPQUFPTCxFQUFFLENBQUNHLEVBQUVFLEtBQUssR0FBR0YsRUFBRUUsS0FBSyxHQUFHRixFQUFFRSxLQUFLLEdBQUcsUUFBZSxJQUFaRixFQUFFRSxLQUFLLEtBQWNMLEVBQUUsR0FBR0csRUFBRUUsS0FBSyxVQUFTLElBQUpGLFFBQXFCLElBQVRBLEVBQUVHLEtBQWNMLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFrQixpQkFBUkUsRUFBRUcsS0FBZUwsRUFBRSxDQUFDRSxFQUFFRyxLQUFLSCxFQUFFRyxLQUFLSCxFQUFFRyxLQUFLSCxFQUFFRyxPQUFPTCxFQUFFLENBQUNFLEVBQUVHLEtBQUssR0FBR0gsRUFBRUcsS0FBSyxHQUFHSCxFQUFFRyxLQUFLLEdBQUcsUUFBZSxJQUFaSCxFQUFFRyxLQUFLLEtBQWNMLEVBQUUsR0FBR0UsRUFBRUcsS0FBSyxLQUFLLElBQUlDLEVBQUVyQyxFQUFFZixFQUFFcUQsRUFBRSxFQUFFQyxFQUFFRixFQUFFRyxFQUFJLEVBQUZILEVBQUlJLEdBQUcsRUFBTSxTQUFKbEMsR0FBWStCLEVBQUUsRUFBRUMsRUFBRUYsRUFBRUcsRUFBSSxFQUFGSCxFQUFJSSxFQUFJLEVBQUZKLEdBQVMsUUFBSjlCLEdBQVcrQixFQUFFLEVBQUVDLEVBQUVGLEVBQUVHLEVBQUksRUFBRkgsR0FBUyxRQUFKOUIsSUFBWStCLEVBQUUsRUFBRUUsRUFBRUgsRUFBRUUsRUFBSSxFQUFGRixHQUFLLElBQUksSUFBSUssRUFBRSxFQUFFQSxFQUFFMUMsRUFBRTBDLElBQUksSUFBSSxJQUFJQyxFQUFFLEVBQUVBLEVBQUUxRCxFQUFFMEQsSUFBSSxDQUFDLElBQUlDLEdBQUduRSxFQUFFb0UsS0FBS1AsS0FBS1AsRUFBRSxJQUFJRCxFQUFFLEdBQUdnQixHQUFHckUsRUFBRW9FLEtBQUtOLEtBQUtSLEVBQUUsSUFBSUQsRUFBRSxHQUFHaUIsR0FBR3RFLEVBQUVvRSxLQUFLTCxLQUFLVCxFQUFFLElBQUlELEVBQUUsR0FBR2tCLEdBQU8sSUFBTFAsRUFBTyxLQUFLaEUsRUFBRW9FLEtBQUtKLEtBQUtWLEVBQUUsSUFBSUQsRUFBRSxHQUFHOUYsRUFBRWlILFVBQVUsUUFBUUwsRUFBRSxJQUFJRSxFQUFFLElBQUlDLEVBQUUsSUFBSUMsRUFBRSxJQUFJaEgsRUFBRWtILFNBQVNQLEVBQUVELEVBQUUsRUFBRSxFQUFFLENBQUMsT0FBTzdELEVBQUVzRSxXQUFXLENBQU0sTUFBTSxJQUFJdEQsTUFBTSw0QkFBMkIsRUFBR2pELEVBQUcsQ0FBQzZCLEVBQUVDLEtBQUssSUFBd0QxQyxFQUFwRDZDLEVBQUUwQyxTQUFTQyxjQUFjLFVBQVVJLFdBQVcsTUFBUSxHQUFNLE1BQUgvQyxFQUFpa0MsTUFBTSxJQUFJZ0IsTUFBTSw2QkFBemtDLENBQUMsSUFBSVosRUFBRWUsRUFBRU8sT0FBb0IsSUFBbEI3QixHQUFHbUQsY0FBd0MsU0FBakJuRCxFQUFFbUQsY0FBdUI1QyxFQUFFUixFQUFFaUQsS0FBSyxHQUFHMUIsRUFBRXZCLEVBQUVpRCxLQUFLLEdBQUduQixFQUFFOUIsRUFBRWlELEtBQUssS0FBS3pDLEVBQUVSLEVBQUVpRCxLQUFLLEdBQUcxQixFQUFFdkIsRUFBRWlELEtBQUssR0FBR25CLEVBQUU5QixFQUFFaUQsS0FBSyxJQUFJLElBQTZESyxFQUFFTSxFQUEzREosT0FBTSxJQUFKdkQsUUFBdUIsSUFBWEEsRUFBRXNELE9BQWdCdEQsRUFBRXNELE9BQU8sTUFBTUYsRUFBRXBELEdBQUd3RCxVQUFhLElBQUpKLFFBQXFCLElBQVRBLEVBQUVLLEtBQWNKLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFvQixpQkFBUkQsRUFBRUssS0FBZUosRUFBRSxDQUFDRCxFQUFFSyxLQUFLTCxFQUFFSyxLQUFLTCxFQUFFSyxLQUFLTCxFQUFFSyxPQUFPSixFQUFFLENBQUNELEVBQUVLLEtBQUssR0FBR0wsRUFBRUssS0FBSyxHQUFHTCxFQUFFSyxLQUFLLEdBQUcsVUFBaUIsSUFBWkwsRUFBRUssS0FBSyxLQUFjSixFQUFFLEdBQUdELEVBQUVLLEtBQUssVUFBUyxJQUFKTCxRQUFxQixJQUFUQSxFQUFFTSxLQUFjQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBa0IsaUJBQVJQLEVBQUVNLEtBQWVDLEVBQUUsQ0FBQ1AsRUFBRU0sS0FBS04sRUFBRU0sS0FBS04sRUFBRU0sS0FBS04sRUFBRU0sT0FBT0MsRUFBRSxDQUFDUCxFQUFFTSxLQUFLLEdBQUdOLEVBQUVNLEtBQUssR0FBR04sRUFBRU0sS0FBSyxHQUFHLFFBQWUsSUFBWk4sRUFBRU0sS0FBSyxLQUFjQyxFQUFFLEdBQUdQLEVBQUVNLEtBQUssS0FBSyxJQUFJRSxFQUFFdEMsRUFBRWYsRUFBRSxRQUFPLElBQUpQLFNBQXdCLElBQVhBLEVBQUVzRCxRQUFxQixJQUFKekIsR0FBa0IsU0FBWDdCLEVBQUVzRCxRQUFxQixJQUFKekIsR0FBa0IsUUFBWDdCLEVBQUVzRCxRQUEyQixRQUFYdEQsRUFBRXNELFFBQWdCLE1BQU0sSUFBSW5DLE1BQU0saURBQWlELElBQUkwQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFRSxFQUFFUixFQUFFUyxFQUFJLEVBQUZULEVBQUlVLEdBQUcsRUFBTSxTQUFKZixHQUFZVyxFQUFFLEVBQUVFLEVBQUVSLEVBQUVTLEVBQUksRUFBRlQsRUFBSVUsRUFBSSxFQUFGVixHQUFTLFFBQUpMLEdBQVdXLEVBQUUsRUFBRUUsRUFBRVIsRUFBRVMsRUFBSSxFQUFGVCxHQUFTLFFBQUpMLElBQVlXLEVBQUUsRUFBRUcsRUFBRVQsRUFBRVEsRUFBSSxFQUFGUixHQUFLdEcsRUFBRTZDLEVBQUV1RSxnQkFBZ0JuRSxFQUFFZSxHQUFHLElBQUksSUFBSXFELEVBQUUsRUFBRUEsRUFBRXJELEVBQUVmLEVBQUV1RCxHQUFHRCxFQUFFRSxHQUFHRixFQUFFRyxHQUFHSCxFQUFFSSxHQUFHSixFQUFFYyxJQUFJckgsRUFBRTZHLEtBQUtMLElBQUkvRCxFQUFFb0UsS0FBS0QsS0FBS1AsRUFBRSxJQUFJTixFQUFFLEdBQUcvRixFQUFFNkcsS0FBS0osSUFBSWhFLEVBQUVvRSxLQUFLQyxLQUFLVCxFQUFFLElBQUlOLEVBQUUsR0FBRy9GLEVBQUU2RyxLQUFLSCxJQUFJakUsRUFBRW9FLEtBQUtFLEtBQUtWLEVBQUUsSUFBSU4sRUFBRSxHQUFHL0YsRUFBRTZHLEtBQUtGLElBQVEsSUFBTEssRUFBTyxLQUFLdkUsRUFBRW9FLEtBQUtHLEtBQUtYLEVBQUUsSUFBSU4sRUFBRSxFQUFFLENBQW1ELE9BQU8vRixFQUFDLElBQXVCc0gsRUFBRzlFLEdBQUUsS0FBa0IrRSxJQUFLMUcsRUFBRyxDQUFDNEIsRUFBRUMsS0FBSyxRQUFPLElBQUpELEVBQVcsTUFBTSxJQUFJb0IsTUFBTSxnQ0FBZ0MsUUFBYyxJQUFYbkIsRUFBRWlELGFBQTJCLElBQVZqRCxFQUFFK0MsTUFBZSxNQUFNLElBQUk1QixNQUFNLDBDQUEwQyxHQUFvQixTQUFqQm5CLEVBQUVtRCxhQUFzQixNQUFNLElBQUloQyxNQUFNLDJDQUEyQyxJQUFvREcsRUFBRU8sR0FBbERvQixPQUFPOUMsRUFBRTRDLE1BQU16RixHQUFHMEMsRUFBRU8sRUFBRVAsRUFBRXdELE1BQU0sQ0FBQ0MsS0FBSyxJQUFJQyxLQUFLLEdBQStCcEMsRUFBVCxpQkFBUmYsRUFBRWtELEtBQWlCLENBQUNsRCxFQUFFa0QsS0FBS2xELEVBQUVrRCxLQUFLbEQsRUFBRWtELEtBQUtsRCxFQUFFa0QsTUFBUSxDQUFDbEQsRUFBRWtELEtBQUssR0FBR2xELEVBQUVrRCxLQUFLLEdBQUdsRCxFQUFFa0QsS0FBSyxHQUFHbEQsRUFBRWtELEtBQUssSUFBSSxLQUE2QjVCLEVBQVQsaUJBQVJ0QixFQUFFbUQsS0FBaUIsQ0FBQ25ELEVBQUVtRCxLQUFLbkQsRUFBRW1ELEtBQUtuRCxFQUFFbUQsS0FBS25ELEVBQUVtRCxNQUFRLENBQUNuRCxFQUFFbUQsS0FBSyxHQUFHbkQsRUFBRW1ELEtBQUssR0FBR25ELEVBQUVtRCxLQUFLLEdBQUduRCxFQUFFbUQsS0FBSyxJQUFJLEdBQUcsSUFBSUgsT0FBYSxJQUFYdkQsRUFBRXNELE9BQWdCdEQsRUFBRXNELE9BQU8sT0FBT0YsT0FBbUIsSUFBakJwRCxFQUFFOEUsbUJBQXdDLElBQWpCOUUsRUFBRThFLGFBQXNCOUUsRUFBRThFLGFBQWEsTUFBTXpCLEVBQUVsRCxFQUFFN0MsRUFBRXFHLEVBQU0sU0FBSlAsRUFBVyxJQUFJMkIsYUFBZSxFQUFGMUIsR0FBSyxJQUFJMEIsYUFBZSxFQUFGMUIsR0FBS08sRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRWIsRUFBRWUsRUFBSSxFQUFGZixFQUFJZ0IsR0FBRyxFQUFNLFFBQUpkLElBQVlLLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxHQUFPLFNBQUpaLEVBQVdpQixFQUFJLEVBQUZoQixFQUFRLFFBQUpELEdBQVdhLEVBQUUsRUFBRUcsRUFBRWYsRUFBRWEsRUFBSSxFQUFGYixHQUFTLFFBQUpELElBQVlnQixFQUFFLEVBQUVGLEVBQUViLEVBQUVZLEVBQUksRUFBRlosR0FBSyxJQUFJLElBQUlzQixFQUFFLEVBQUVBLEVBQUV0QixFQUFFc0IsSUFBSWQsR0FBR0QsRUFBRUcsR0FBR0gsRUFBRUUsR0FBR0YsRUFBRUksR0FBR0osRUFBRUQsRUFBRU0sTUFBTWxFLEVBQUU4RCxHQUFHaEMsRUFBRSxJQUFJUCxFQUFFLEdBQUdxQyxFQUFFTyxNQUFNbkUsRUFBRStELEdBQUdqQyxFQUFFLElBQUlQLEVBQUUsR0FBR3FDLEVBQUVTLE1BQU1yRSxFQUFFZ0UsR0FBR2xDLEVBQUUsSUFBSVAsRUFBRSxJQUFRLElBQUwrQyxJQUFhLElBQUxMLElBQVNMLEVBQUVVLE1BQU10RSxFQUFFaUUsR0FBR25DLEVBQUUsSUFBSVAsRUFBRSxJQUFJLE9BQWtCLElBQUl4QyxFQUFHLFVBQVU2RSxFQUF4QixTQUFKUCxFQUE4QixDQUFDLEVBQUUsRUFBRWpELEVBQUU3QyxHQUF1QixDQUFDLEVBQUUsRUFBRTZDLEVBQUU3QyxHQUFFLEVBQUdjLEVBQUdxRCxNQUFNMUIsRUFBRUMsS0FBSyxJQUF3TDZCLEVBQXBMMUIsU0FBUzZFLGlCQUFpQixLQUFLakYsYUFBYWlGLGlCQUFpQjFILFNBQVMySCxVQUFVLEtBQUtsRixhQUFha0YsVUFBVTFFLFNBQVMyRSxZQUFZLEtBQUtuRixhQUFhbUYsWUFBWTVELEVBQVksaUJBQUh2QixFQUFjd0QsRUFBRXZELEdBQUcsQ0FBQyxFQUFFLEdBQUdHLEVBQUUsQ0FBQyxJQUFJaUQsRUFBRVAsU0FBU0MsY0FBYyxVQUFVTSxFQUFFTCxNQUFNaEQsRUFBRWdELE1BQU1LLEVBQUVILE9BQU9sRCxFQUFFa0QsT0FBTyxJQUFJSSxFQUFFRCxFQUFFRixXQUFXLE1BQU0sR0FBTSxNQUFIRyxFQUFxWixNQUFNLElBQUlsQyxNQUFNLDZCQUE3WixDQUFDLElBQUl3QyxFQUFFNUQsRUFBRWtELE9BQU9XLEVBQUU3RCxFQUFFZ0QsTUFBTSxRQUFPLElBQUovQyxRQUE4QixJQUFsQkEsRUFBRW1GLG9CQUF5QyxJQUFqQm5GLEVBQUVvRixlQUF3QnpCLEVBQUUzRCxFQUFFbUYsY0FBY3ZCLEVBQUU1RCxFQUFFb0YsbUJBQWtCLElBQUpwRixFQUFXLENBQUMsR0FBR3VELEVBQUV2RCxPQUFtQixJQUFqQkEsRUFBRThFLGFBQXNCLE1BQU0sSUFBSTNELE1BQU0sK0RBQStEb0MsRUFBRXVCLGFBQWEsT0FBT3ZCLEVBQUVOLE9BQU9VLEVBQUVKLEVBQUVSLE1BQU1hLENBQUMsTUFBTUwsRUFBRXVCLGFBQWEsT0FBT3ZCLEVBQUVOLE9BQU9VLEVBQUVKLEVBQUVSLE1BQU1hLEVBQUVQLEVBQUVnQyxVQUFVdEYsRUFBRSxFQUFFLEdBQUc4QixFQUFFd0IsRUFBRWlDLGFBQWEsRUFBRSxFQUFFMUIsRUFBRUQsR0FBR1EsSUFBSSxDQUFrRCxLQUFNLEtBQUc3RyxFQUFxYSxJQUFHaUQsRUFBRSxDQUFDLFFBQU8sSUFBSlAsRUFBVyxNQUFNLElBQUltQixNQUFNLDJEQUEyRCxJQUFJaUMsRUFBRVAsU0FBU0MsY0FBYyxVQUFVTSxFQUFFTCxNQUFNaEQsRUFBRWdELE1BQU1LLEVBQUVILE9BQU9sRCxFQUFFa0QsT0FBTyxJQUFJSSxFQUFFRCxFQUFFRixXQUFXLE1BQU0sR0FBTSxNQUFIRyxFQUFRLENBQUMsSUFBSU0sRUFBRTVELEVBQUVrRCxPQUFPVyxFQUFFN0QsRUFBRWdELE1BQU0sT0FBT00sRUFBRWdDLFVBQVV0RixFQUFFLEVBQUUsRUFBRTZELEVBQUVELEdBQUc5QixFQUFFd0IsRUFBRWlDLGFBQWEsRUFBRSxFQUFFMUIsRUFBRUQsR0FBR1EsS0FBS1osRUFBRU4sT0FBT1UsRUFBRUosRUFBRVIsTUFBTWEsRUFBRXpGLEVBQUcwRCxFQUFFMEIsRUFBRSxDQUFNLE1BQU0sSUFBSXBDLE1BQU0sNEJBQTRCLENBQU0sR0FBR0csRUFBRSxPQUFPLElBQUlpRSxTQUFRLENBQUNuQyxFQUFFQyxLQUFLLElBQUlNLEVBQUVkLFNBQVNDLGNBQWMsVUFBVWMsRUFBRUQsRUFBRVQsV0FBVyxNQUFNLElBQUluRCxJQUFJNkQsRUFBRSxPQUFPUCxJQUFJLElBQUlRLEVBQUUsSUFBSTJCLE1BQU0zQixFQUFFNEIsWUFBWSxZQUFZNUIsRUFBRTZCLElBQUkzRixFQUFFOEQsRUFBRThCLE9BQU8sS0FBS2hDLEVBQUVaLE1BQU1jLEVBQUVkLE1BQU1ZLEVBQUVWLE9BQU9ZLEVBQUVaLE9BQU9XLEVBQUV5QixVQUFVeEIsRUFBRSxFQUFFLEVBQUVGLEVBQUVaLE1BQU1ZLEVBQUVWLFFBQVEsSUFBSWEsRUFBRUYsRUFBRTBCLGFBQWEsRUFBRSxFQUFFM0IsRUFBRVosTUFBTVksRUFBRVYsUUFBUU0sRUFBRU4sT0FBT1UsRUFBRVYsT0FBT00sRUFBRVIsTUFBTVksRUFBRVosTUFBTUssRUFBRWpGLEVBQUcyRixFQUFFSyxLQUFLWixHQUFFLENBQUMsSUFBSSxNQUFNLElBQUlwQyxNQUFNLGlFQUFpRSxDQUFsc0MsQ0FBQyxJQUFJaUMsRUFBRUMsRUFBRSxRQUFPLElBQUpyRCxRQUE2QixJQUFqQkEsRUFBRW9GLG1CQUF5QyxJQUFsQnBGLEVBQUVtRixlQUF3Qi9CLEVBQUVwRCxFQUFFbUYsY0FBYzlCLEVBQUVyRCxFQUFFb0YsZUFBZWhDLEVBQUVyRCxFQUFFa0QsT0FBT0ksRUFBRXRELEVBQUVnRCxZQUFXLElBQUovQyxJQUFhdUQsRUFBRXZELEdBQUd1RCxFQUFFRCxPQUFPLE9BQU9DLEVBQUVOLE9BQU9HLEVBQUVHLEVBQUVSLE1BQU1NLE9BQU0sSUFBSnJELEVBQVcsQ0FBQyxJQUFJMkQsRUFBRWQsU0FBU0MsY0FBYyxVQUFVYSxFQUFFWixNQUFNTSxFQUFFTSxFQUFFVixPQUFPRyxFQUFFLElBQUlRLEVBQUVELEVBQUVULFdBQVcsTUFBTSxHQUFNLE1BQUhVLEVBQWtFLE1BQU0sSUFBSXpDLE1BQU0sNkJBQTFFeUMsRUFBRWdDLGFBQWE3RixFQUFFLEVBQUUsR0FBRzhCLEVBQUUrQixFQUFFMEIsYUFBYSxFQUFFLEVBQUVqQyxFQUFFRCxHQUFHZSxJQUFzRCxNQUFNdEMsRUFBRTlCLEVBQUVvRSxJQUFJLENBQXF5QixDQUFDLFFBQU8sSUFBSnRDLEVBQVcsT0FBTzFELEVBQUcwRCxFQUFFMEIsR0FBRyxNQUFNLElBQUlwQyxNQUFNLGlFQUFnRSxFQUFHOUMsRUFBRyxDQUFDMEIsRUFBRUMsS0FBSyxJQUFJK0MsTUFBTTVDLEVBQUU4QyxPQUFPM0YsRUFBRXVJLFNBQVN0RixFQUFFdUYsUUFBUXhFLEdBQUd0QixFQUFjLE9BQU8sSUFBSWxCLEVBQUcsQ0FBQ2lILFNBQVMsVUFBVUMsS0FBSyxVQUFVQyxRQUFRbEcsRUFBRWlELEtBQXJFLENBQUMsRUFBRTFGLEVBQUU2QyxFQUFFLEdBQXFFMEYsU0FBU3RGLEVBQUV1RixRQUFReEUsR0FBRSxFQUFHaEQsRUFBRyxDQUFDeUIsRUFBRUMsS0FBSyxJQUFJa0csU0FBUy9GLEVBQUU2QyxLQUFLMUYsRUFBRXVJLFNBQVN0RixFQUFFdUYsUUFBUXhFLEdBQUd0QixFQUFFLE9BQU8sSUFBSWxCLEVBQUcsQ0FBQ2lILFNBQVMsYUFBYUMsS0FBSzdGLEdBQUcsVUFBVWdHLFVBQVVwRyxFQUFFaUQsS0FBSzFGLEVBQUV1SSxTQUFTdEYsRUFBRXVGLFFBQVF4RSxHQUFFLEVBQUcvQyxFQUFHLENBQUN3QixFQUFFQyxFQUFFRyxJQUFJLElBQUlyQixFQUFHLENBQUNpSCxTQUFTLGFBQWFDLEtBQUtqRyxFQUFFb0UsS0FBS25FLEVBQUVnRCxLQUFLN0MsR0FBRyxDQUFDSCxFQUFFdUIsU0FBUSxJQUFvQjZFLEVBQUd0RyxHQUFFLEtBQWtCdEIsRUFBRyxJQUFJb0MsSUFBSSxDQUFDLENBQUMsVUFBVW1FLGNBQWMsQ0FBQyxRQUFRc0IsWUFBWSxDQUFDLE9BQU9DLFdBQVcsQ0FBQyxTQUFTQyxhQUFhLENBQUMsVUFBVUEsYUFBYSxDQUFDLFFBQVFDLFlBQVksQ0FBQyxRQUFRQyxZQUFZLENBQUMsT0FBT0osWUFBWSxDQUFDLFVBQVVLLGNBQWMsQ0FBQyxTQUFTQyxlQUFlbEksRUFBRyxJQUFJbUMsSUFBSSxDQUFDLENBQUNtRSxhQUFhLFdBQVcsQ0FBQ3NCLFdBQVcsU0FBUyxDQUFDQyxVQUFVLFFBQVEsQ0FBQ0MsWUFBWSxVQUFVLENBQUNDLFdBQVcsU0FBUyxDQUFDQyxXQUFXLFNBQVMsQ0FBQ0MsYUFBYSxXQUFXLENBQUNDLFlBQVksWUFBWWpJLEdBQUcsRUFBR0MsRUFBRyxLQUFLLElBQUlELEVBQUcsQ0FBQ0EsR0FBRyxFQUFHLElBQUlxQixTQUFTNkcsY0FBYyxLQUFnQyxtQkFBcEJBLGNBQWNDLEtBQWlCN0csU0FBUzhHLGVBQWUsS0FBaUMsbUJBQXJCQSxlQUFlRCxLQUFpQjlHLElBQUl2QixFQUFHd0MsSUFBSSxRQUFRNEYsZUFBZW5JLEVBQUd1QyxJQUFJNEYsY0FBYyxVQUFVNUcsSUFBSXhCLEVBQUd3QyxJQUFJLFNBQVM4RixnQkFBZ0JySSxFQUFHdUMsSUFBSThGLGVBQWUsVUFBVSxFQUFDLElBQWNDLEVBQUdqSCxHQUFFLEtBQWtCK0UsSUFBS2pHLEVBQUdtQixJQUFJLElBQUlDLEVBQUUsRUFBRSxJQUFJLElBQUlHLEVBQUUsRUFBRUEsRUFBRUosRUFBRXdCLE9BQU9wQixJQUFJLENBQUMsSUFBSTdDLEVBQUV5QyxFQUFFSSxHQUFHLEdBQWEsaUJBQUg3QyxJQUFjMEosT0FBT0MsY0FBYzNKLEdBQUcsTUFBTSxJQUFJeUQsVUFBVSxRQUFRWiwrQkFBK0I3QyxLQUFLLEdBQUdBLEVBQUUsRUFBRSxNQUFNLElBQUk0SixXQUFXLFFBQVEvRywyQ0FBMkM3QyxLQUFLMEMsR0FBRzFDLENBQUMsQ0FBQyxPQUFPMEMsR0FBR25CLEVBQUcsQ0FBQ2tCLEVBQUVDLEtBQUssT0FBT0QsRUFBRWdHLFVBQVUsSUFBSSxNQUFNLE9BQU8sSUFBSWpILEVBQUdpQixFQUFFaUcsS0FBS2pHLEVBQUVvRSxLQUFLbkUsR0FBRyxJQUFJLGFBQWEsT0FBTyxJQUFJbEIsRUFBRyxDQUFDaUgsU0FBUyxhQUFhNUIsS0FBS3BFLEVBQUVvRSxLQUFLNkIsS0FBS2pHLEVBQUVpRyxLQUFLaEQsS0FBS2hELElBQUksSUFBSSxVQUFVLE9BQU8sSUFBSWxCLEVBQUcsQ0FBQ2lILFNBQVMsVUFBVUUsUUFBUWxHLEVBQUVrRyxRQUFRRCxLQUFLakcsRUFBRWlHLEtBQUtoRCxLQUFLaEQsSUFBSSxJQUFJLGFBQWEsT0FBTyxJQUFJbEIsRUFBRyxDQUFDaUgsU0FBUyxhQUFhSSxVQUFVcEcsRUFBRW9HLFVBQVVILEtBQUtqRyxFQUFFaUcsS0FBS2hELEtBQUtoRCxJQUFJLFFBQVEsTUFBTSxJQUFJbUIsTUFBTSxrQ0FBa0NwQixFQUFFZ0csNkJBQTRCLENBQUMsSUFBV2xCLEVBQUcvRSxHQUFFLEtBQWtCOEMsSUFBS2dDLElBQUt3QixJQUFLVyxJQUFLakksRUFBRyxNQUFNLFdBQUFxSSxDQUFZbkgsRUFBRUcsRUFBRTdDLEdBQVEsSUFBSWlELEVBQUVlLEVBQUUsR0FBYjNDLElBQTBCLGlCQUFIcUIsR0FBYSxhQUFhQSxFQUFFLE9BQU9vSCxLQUFLQyxhQUFhckgsRUFBRStGLFNBQVN4RixFQUFFUCxFQUFFZ0csS0FBSzFFLEVBQUV0QixFQUFFZ0QsS0FBS2hELEVBQUUrRixVQUFVLElBQUksYUFBYSxDQUFDLElBQUl4QyxFQUFFL0UsRUFBRzRCLElBQUlHLEdBQUcsSUFBSWdELEVBQUUsTUFBTSxJQUFJeEMsVUFBVSxxQkFBcUJSLDBDQUEwQyxLQUFLUCxFQUFFbUUsZ0JBQWdCWixHQUFHLE1BQU0sSUFBSXhDLFVBQVUsNEJBQTRCd0MsRUFBRXpCLFFBQVFzRixLQUFLRSxRQUFRdEgsRUFBRW1FLEtBQUssS0FBSyxDQUFDLElBQUksVUFBVyxHQUFPLFlBQUo1RCxFQUFjLE1BQU0sSUFBSVEsVUFBVSxxQkFBcUJSLG9DQUFvQzZHLEtBQUtHLGVBQWV2SCxFQUFFaUcsUUFBUW1CLEtBQUtJLFdBQVd4SCxFQUFFNkYsU0FBU3VCLEtBQUtLLFNBQVN6SCxFQUFFOEYsUUFBUSxNQUFNLElBQUksYUFBYyxHQUFPLFlBQUp2RixHQUFtQixZQUFKQSxHQUFtQixVQUFKQSxHQUFpQixVQUFKQSxHQUFpQixXQUFKQSxHQUFrQixTQUFKQSxFQUFXLE1BQU0sSUFBSVEsVUFBVSxxQkFBcUJSLHVDQUF1QzZHLEtBQUtNLGNBQWMxSCxFQUFFbUcsVUFBVWlCLEtBQUtJLFdBQVd4SCxFQUFFNkYsU0FBU3VCLEtBQUtLLFNBQVN6SCxFQUFFOEYsUUFBUSxNQUFNLFFBQVEsTUFBTSxJQUFJM0UsTUFBTSw2Q0FBNkNpRyxLQUFLQyxxQkFBcUIsQ0FBQyxJQUFJOUQsRUFBRUgsRUFBRSxHQUFhLGlCQUFIcEQsRUFBWSxHQUFHTyxFQUFFUCxFQUFFb0QsRUFBRTlGLEVBQU0sV0FBSjBDLEVBQWEsQ0FBQyxJQUFJMkgsTUFBTUMsUUFBUXpILEdBQUcsTUFBTSxJQUFJWSxVQUFVLGtEQUFrRHdDLEVBQUVwRCxDQUFDLEtBQUssQ0FBQyxJQUFJa0QsRUFBRTdFLEVBQUc0QixJQUFJSixHQUFHLFFBQU8sSUFBSnFELEVBQVcsTUFBTSxJQUFJdEMsVUFBVSw0QkFBNEJmLE1BQU0sR0FBRzJILE1BQU1DLFFBQVF6SCxHQUFHLENBQUMsR0FBTyxZQUFKSCxFQUFjLE1BQU0sSUFBSWUsVUFBVSxpR0FBMkh3QyxFQUF0QixXQUFKdkQsR0FBa0IsVUFBSkEsRUFBY3FELEVBQUV3RCxLQUFLMUcsRUFBRTBILFFBQVV4RSxFQUFFd0QsS0FBSzFHLEVBQUUsS0FBTSxNQUFHQSxhQUFha0QsR0FBVyxNQUFNLElBQUl0QyxVQUFVLEtBQUtSLG1DQUFtQzhDLEtBQXJFRSxFQUFFcEQsQ0FBc0UsQ0FBQyxNQUFNLEdBQUdpRCxFQUFFakQsRUFBRXdILE1BQU1DLFFBQVE1SCxHQUFHLENBQUMsR0FBYyxJQUFYQSxFQUFFdUIsT0FBVyxNQUFNLElBQUlSLFVBQVUsdURBQXVELElBQUlzQyxTQUFTckQsRUFBRSxHQUFHLEdBQU8sV0FBSnFELEVBQWE5QyxFQUFFLFNBQVNnRCxFQUFFdkQsTUFBTyxJQUFPLFlBQUpxRCxFQUFpRCxNQUFNLElBQUl0QyxVQUFVLHVDQUF1Q3NDLE1BQTlGOUMsRUFBRSxPQUFPZ0QsRUFBRThDLFdBQVdRLEtBQUs3RyxFQUF1RSxDQUFDLEtBQUssQ0FBQyxJQUFJcUQsRUFBRTVFLEVBQUcyQixJQUFJSixFQUFFbUgsYUFBYSxRQUFPLElBQUo5RCxFQUFXLE1BQU0sSUFBSXRDLFVBQVUscUNBQXFDZixFQUFFbUgsZ0JBQWdCNUcsRUFBRThDLEVBQUVFLEVBQUV2RCxDQUFDLENBQUMsUUFBTyxJQUFKb0QsRUFBV0EsRUFBRSxDQUFDRyxFQUFFaEMsYUFBYSxJQUFJb0csTUFBTUMsUUFBUXhFLEdBQUcsTUFBTSxJQUFJckMsVUFBVSwwQ0FBMENPLEVBQUU4QixFQUFFZ0UsS0FBS0UsUUFBUS9ELEVBQUU2RCxLQUFLQyxhQUFhLEtBQUssQ0FBQyxJQUFJeEYsRUFBRWpELEVBQUcwQyxHQUFHLEdBQUc4RixLQUFLRSxTQUFTekYsSUFBSXVGLEtBQUtFLFFBQVEvRixPQUFPLE1BQU0sSUFBSUosTUFBTSxpQkFBaUJVLGlDQUFpQ3VGLEtBQUtFLFFBQVEvRixZQUFZNkYsS0FBS3BCLEtBQUt6RixFQUFFNkcsS0FBS3BFLEtBQUsxQixFQUFFOEYsS0FBS1UsS0FBS2pHLENBQUMsQ0FBQyxzQkFBYWtHLENBQVUvSCxFQUFFRyxHQUFHLE9BQU8vQixFQUFHNEIsRUFBRUcsRUFBRSxDQUFDLGtCQUFPNkgsQ0FBWWhJLEVBQUVHLEdBQUcsT0FBTzlCLEVBQUcyQixFQUFFRyxFQUFFLENBQUMsb0JBQU84SCxDQUFjakksRUFBRUcsR0FBRyxPQUFPN0IsRUFBRzBCLEVBQUVHLEVBQUUsQ0FBQyx1QkFBTytILENBQWlCbEksRUFBRUcsRUFBRTdDLEdBQUcsT0FBT2lCLEVBQUd5QixFQUFFRyxFQUFFN0MsRUFBRSxDQUFDLFNBQUFtSCxDQUFVekUsR0FBRyxPQUFPL0IsRUFBR21KLEtBQUtwSCxFQUFFLENBQUMsV0FBQW1JLENBQVluSSxHQUFHLE9BQU85QixFQUFHa0osS0FBS3BILEVBQUUsQ0FBQyxRQUFJbUUsR0FBTyxHQUFHaUQsS0FBS2dCLGVBQWVoQixLQUFLRSxRQUFRLE1BQU0sSUFBSW5HLE1BQU0sa0pBQWtKLE9BQU9pRyxLQUFLRSxPQUFPLENBQUMsWUFBSXZCLEdBQVcsT0FBT3FCLEtBQUtDLFlBQVksQ0FBQyxXQUFJcEIsR0FBVSxHQUFHbUIsS0FBS2dCLGVBQWVoQixLQUFLRyxlQUFlLE1BQU0sSUFBSXBHLE1BQU0sOENBQThDLE9BQU9pRyxLQUFLRyxjQUFjLENBQUMsYUFBSXBCLEdBQVksR0FBR2lCLEtBQUtnQixlQUFlaEIsS0FBS00sY0FBYyxNQUFNLElBQUl2RyxNQUFNLDhDQUE4QyxPQUFPaUcsS0FBS00sYUFBYSxDQUFDLGFBQU1XLENBQVFySSxHQUFHLE9BQU9vSCxLQUFLZ0IsY0FBY2hCLEtBQUtDLGNBQWMsSUFBSSxNQUFNLElBQUksYUFBYSxPQUFPRCxLQUFLakQsS0FBSyxJQUFJLFVBQVUsSUFBSSxhQUFjLElBQUlpRCxLQUFLSSxXQUFXLE1BQU0sSUFBSXJHLE1BQU0sdUVBQXVFLEdBQUdpRyxLQUFLa0IsY0FBYyxNQUFNLElBQUluSCxNQUFNLDJDQUEyQyxJQUFJaUcsS0FBS2tCLGVBQWMsRUFBRyxJQUFJbkksUUFBUWlILEtBQUtJLGFBQWEsT0FBT0osS0FBS0ksZ0JBQVcsRUFBT0osS0FBS0MsYUFBYSxNQUFNRCxLQUFLRSxRQUFRbkgsRUFBRUgsR0FBR29ILEtBQUtLLFdBQVdMLEtBQUtLLFdBQVdMLEtBQUtLLGNBQVMsR0FBUXRILENBQUMsQ0FBQyxRQUFRaUgsS0FBS2tCLGVBQWMsQ0FBRSxDQUFFLFFBQVEsTUFBTSxJQUFJbkgsTUFBTSxrQ0FBa0NpRyxLQUFLQyxnQkFBZ0IsQ0FBQyxPQUFBdkIsR0FBVSxHQUFHc0IsS0FBS2tCLGNBQWMsTUFBTSxJQUFJbkgsTUFBTSwyQ0FBMkNpRyxLQUFLSyxXQUFXTCxLQUFLSyxXQUFXTCxLQUFLSyxjQUFTLEdBQVFMLEtBQUtFLGFBQVEsRUFBT0YsS0FBS0csb0JBQWUsRUFBT0gsS0FBS00sbUJBQWMsRUFBT04sS0FBS0ksZ0JBQVcsRUFBT0osS0FBS2tCLG1CQUFjLEVBQU9sQixLQUFLQyxhQUFhLE1BQU0sQ0FBQyxXQUFBZSxHQUFjLEdBQXVCLFNBQXBCaEIsS0FBS0MsYUFBc0IsTUFBTSxJQUFJbEcsTUFBTSwwQkFBMEIsQ0FBQyxPQUFBb0gsQ0FBUXZJLEdBQUcsR0FBR29ILEtBQUtnQixjQUFjaEIsS0FBS0ksWUFBWUosS0FBS0ssU0FBUyxNQUFNLElBQUl0RyxNQUFNLG1EQUFtRCxPQUFPdEMsRUFBR3VJLEtBQUtwSCxFQUFFLEVBQUMsSUFBV3dJLEVBQUcxSSxHQUFFLEtBQWtCK0UsSUFBSzlGLEVBQUdELEtBQVkySixFQUFHM0ksR0FBRSxLQUFrQmEsSUFBSzZILElBQUt4SixFQUFHLE1BQU1lLEVBQUUsV0FBQW9ILENBQVluSCxHQUFHb0gsS0FBS3NCLFFBQVExSSxDQUFDLENBQUMsU0FBTTJJLENBQUkzSSxFQUFFRyxFQUFFN0MsR0FBRyxJQUFJaUQsRUFBRSxDQUFDLEVBQUVlLEVBQUUsQ0FBQyxFQUFFLEdBQWEsaUJBQUh0QixHQUFpQixPQUFKQSxHQUFVQSxhQUFhakIsR0FBSTRJLE1BQU1DLFFBQVE1SCxHQUFHLE1BQU0sSUFBSWUsVUFBVSxpR0FBaUcsSUFBSWMsR0FBRSxFQUFHLEdBQWEsaUJBQUgxQixFQUFZLENBQUMsR0FBTyxPQUFKQSxFQUFTLE1BQU0sSUFBSVksVUFBVSwyQ0FBMkMsR0FBR1osYUFBYXBCLEVBQUcsTUFBTSxJQUFJZ0MsVUFBVSxnQ0FBZ0MsR0FBRzRHLE1BQU1DLFFBQVF6SCxHQUFHLENBQUMsR0FBYyxJQUFYQSxFQUFFb0IsT0FBVyxNQUFNLElBQUlSLFVBQVUsdUNBQXVDYyxHQUFFLEVBQUcsSUFBSSxJQUFJd0IsS0FBS2xELEVBQUUsQ0FBQyxHQUFhLGlCQUFIa0QsRUFBWSxNQUFNLElBQUl0QyxVQUFVLGtEQUFrRCxJQUFrQyxJQUEvQnFHLEtBQUt3QixZQUFZeEgsUUFBUWlDLEdBQVEsTUFBTSxJQUFJNkQsV0FBVywyQ0FBMkM3RCxNQUFNOUMsRUFBRThDLEdBQUcsSUFBSSxDQUFDLEdBQWEsaUJBQUgvRixHQUFpQixPQUFKQSxFQUFTZ0UsRUFBRWhFLE9BQU8sVUFBVUEsRUFBRSxJQUFJLE1BQU0sSUFBSXlELFVBQVUsK0JBQStCLEtBQUssQ0FBQyxJQUFJc0MsR0FBRSxFQUFHTSxFQUFFdEUsT0FBT0ssb0JBQW9CUyxHQUFHLElBQUksSUFBSXlELEtBQUt3RCxLQUFLd0IsWUFBWSxJQUFtQixJQUFoQmpGLEVBQUV2QyxRQUFRd0MsR0FBUSxDQUFDLElBQUlDLEVBQUUxRCxFQUFFeUQsSUFBUSxPQUFKQyxHQUFVQSxhQUFhOUUsS0FBTXNFLEdBQUUsRUFBR3hCLEdBQUUsRUFBR3RCLEVBQUVxRCxHQUFHQyxFQUFFLENBQUMsR0FBR1IsR0FBRyxHQUFhLGlCQUFIL0YsR0FBaUIsT0FBSkEsRUFBU2dFLEVBQUVoRSxPQUFPLFVBQVVBLEVBQUUsSUFBSSxNQUFNLElBQUl5RCxVQUFVLHFDQUFxQ08sRUFBRW5CLENBQUMsQ0FBQyxNQUFNLFVBQVVBLEVBQUUsSUFBSSxNQUFNLElBQUlZLFVBQVUsMkRBQTJELElBQUksSUFBSXNDLEtBQUsrRCxLQUFLeUIsV0FBVyxVQUFVN0ksRUFBRXFELEdBQUcsSUFBSSxNQUFNLElBQUlsQyxNQUFNLFVBQVVrQyw2QkFBNkIsR0FBR3hCLEVBQUUsSUFBSSxJQUFJd0IsS0FBSytELEtBQUt3QixZQUFZckksRUFBRThDLEdBQUcsS0FBSyxJQUFJRSxRQUFRNkQsS0FBS3NCLFFBQVFDLElBQUkzSSxFQUFFTyxFQUFFZSxHQUFHOEIsRUFBRSxDQUFDLEVBQUUsSUFBSSxJQUFJQyxLQUFLRSxFQUFFLEdBQUdsRSxPQUFPUSxlQUFlVyxLQUFLK0MsRUFBRUYsR0FBRyxDQUFDLElBQUlNLEVBQUVKLEVBQUVGLEdBQW1CRCxFQUFFQyxHQUFsQk0sYUFBYTVFLEVBQVE0RSxFQUFPLElBQUk1RSxFQUFHNEUsRUFBRXFDLEtBQUtyQyxFQUFFUSxLQUFLUixFQUFFWCxLQUFLLENBQUMsT0FBT0ksQ0FBQyxDQUFDLGFBQU0wRixHQUFVLE9BQU8xQixLQUFLc0IsUUFBUTVDLFNBQVMsQ0FBQyxtQkFBYWlELENBQU8vSSxFQUFFRyxFQUFFN0MsRUFBRWlELEdBQUcsSUFBSWUsRUFBRU8sRUFBRSxDQUFDLEVBQUUsR0FBYSxpQkFBSDdCLEdBQWEsR0FBR3NCLEVBQUV0QixFQUFZLGlCQUFIRyxHQUFpQixPQUFKQSxFQUFTMEIsRUFBRTFCLE9BQU8sVUFBVUEsRUFBRSxJQUFJLE1BQU0sSUFBSVksVUFBVSxxQ0FBcUMsR0FBR2YsYUFBYXFHLFlBQVksR0FBRy9FLEVBQUV0QixFQUFZLGlCQUFIRyxHQUFpQixPQUFKQSxFQUFTMEIsRUFBRTFCLE9BQU8sVUFBVUEsRUFBRSxJQUFJLE1BQU0sSUFBSVksVUFBVSxvQ0FBcUMsTUFBR2YsYUFBYWdKLG9CQUFvQkMsa0JBQWtCLEtBQUtqSixhQUFhaUosbUJBQWd6QixNQUFNLElBQUlsSSxVQUFVLHVEQUFsekIsQ0FBQyxJQUFJNkMsRUFBRTVELEVBQUU2RCxFQUFFLEVBQUVDLEVBQUU5RCxFQUFFa0osV0FBVyxHQUFhLGlCQUFIL0ksR0FBaUIsT0FBSkEsRUFBUzBCLEVBQUUxQixPQUFPLEdBQWEsaUJBQUhBLEVBQVksQ0FBQyxHQUFHMEQsRUFBRTFELEdBQUc2RyxPQUFPQyxjQUFjcEQsR0FBRyxNQUFNLElBQUlxRCxXQUFXLG9DQUFvQyxHQUFHckQsRUFBRSxHQUFHQSxHQUFHRCxFQUFFc0YsV0FBVyxNQUFNLElBQUloQyxXQUFXLG9DQUFvQ3RELEVBQUVzRixnQkFBZ0IsR0FBR3BGLEVBQUU5RCxFQUFFa0osV0FBV3JGLEVBQVksaUJBQUh2RyxFQUFZLENBQUMsR0FBR3dHLEVBQUV4RyxHQUFHMEosT0FBT0MsY0FBY25ELEdBQUcsTUFBTSxJQUFJb0QsV0FBVyxvQ0FBb0MsR0FBR3BELEdBQUcsR0FBR0QsRUFBRUMsRUFBRUYsRUFBRXNGLFdBQVcsTUFBTSxJQUFJaEMsV0FBVyxvQ0FBb0N0RCxFQUFFc0YsV0FBV3JGLE9BQU8sR0FBYSxpQkFBSHRELEdBQWlCLE9BQUpBLEVBQVNzQixFQUFFdEIsT0FBTyxVQUFVQSxFQUFFLElBQUksTUFBTSxJQUFJUSxVQUFVLCtCQUErQixNQUFNLFVBQVV6RCxFQUFFLElBQUksTUFBTSxJQUFJeUQsVUFBVSxpQ0FBaUMsTUFBTSxVQUFVWixFQUFFLElBQUksTUFBTSxJQUFJWSxVQUFVLGdDQUFnQ08sRUFBRSxJQUFJK0UsV0FBV3pDLEVBQUVDLEVBQUVDLEVBQUUsQ0FBZ0YsQ0FBQyxJQUFJVixHQUFHdkIsRUFBRXNILG9CQUFvQixJQUFJbkgsS0FBSTRCLEdBQWEsaUJBQUhBLEVBQVlBLEVBQUVBLEVBQUU5QixPQUFNNkIsY0FBYy9GLEVBQUd3RixJQUFJdEMsOEJBQThCUSxFQUFFTyxHQUFHLE9BQU8sSUFBSTlCLEVBQUU0RCxFQUFFLENBQUMsY0FBQXlGLEdBQWlCaEMsS0FBS3NCLFFBQVFVLGdCQUFnQixDQUFDLFlBQUFDLEdBQWVqQyxLQUFLc0IsUUFBUVcsY0FBYyxDQUFDLGNBQUlSLEdBQWEsT0FBT3pCLEtBQUtzQixRQUFRRyxVQUFVLENBQUMsZUFBSUQsR0FBYyxPQUFPeEIsS0FBS3NCLFFBQVFFLFdBQVcsRUFBQyxJQUFXVSxFQUFHeEosR0FBRSxLQUFrQjJJLElBQUt4SixFQUFHRCxLQUFTdUssRUFBR3pKLEdBQUUsS0FBSyxJQUF5QjBKLEdBQUcxSixHQUFFLEtBQWtCYSxJQUFLNkgsSUFBd0h0SixFQUFHLE1BQU1hLEVBQUUsV0FBQW9ILENBQVluSCxHQUFHb0gsS0FBS3NCLFFBQVExSSxDQUFDLENBQUMsY0FBSTZJLEdBQWEsT0FBT3pCLEtBQUtzQixRQUFRRyxVQUFVLENBQUMsZUFBSUQsR0FBYyxPQUFPeEIsS0FBS3NCLFFBQVFFLFdBQVcsQ0FBQyxtQkFBYUcsQ0FBTy9JLEVBQUVHLEdBQUcsSUFBSTdDLEVBQUUwQyxFQUFFeUosV0FBVyxHQUFHbEosRUFBRVAsRUFBRTBKLGdCQUFnQixHQUFHcEksRUFBRW5CLEdBQUcsQ0FBQyxFQUFFb0QsR0FBR2pDLEVBQUU2SCxvQkFBb0IsSUFBSW5ILEtBQUlxQixHQUFhLGlCQUFIQSxFQUFZQSxFQUFFQSxFQUFFdkIsT0FBTXNCLFFBQVF4RixFQUFHMkYsR0FBRyxHQUFHSCxFQUFFdUcsNkJBQTZCLENBQUMsSUFBSXRHLFFBQVFELEVBQUV1Ryw2QkFBNkIzSixFQUFFNEosZ0JBQWdCNUosRUFBRTZKLFdBQVd2TSxFQUFFaUQsRUFBRWUsR0FBRyxPQUFPLElBQUl2QixFQUFFc0QsRUFBRSxDQUFNLE1BQU0sSUFBSWxDLE1BQTNpQixnSEFBb2pCLENBQUMsdUJBQUEySSxDQUF3QjlKLEVBQUVHLEVBQUU3QyxHQUFHLElBQUlpRCxFQUFFLENBQUMsRUFBRWUsRUFBRSxDQUFDLEVBQUUsR0FBYSxpQkFBSHRCLEdBQWlCLE9BQUpBLEdBQVVBLGFBQWFqQixHQUFJNEksTUFBTUMsUUFBUTVILEdBQUcsTUFBTSxJQUFJZSxVQUFVLGlHQUFpRyxJQUFJYyxHQUFFLEVBQUcsR0FBYSxpQkFBSDFCLEVBQVksQ0FBQyxHQUFPLE9BQUpBLEVBQVMsTUFBTSxJQUFJWSxVQUFVLDJDQUEyQyxHQUFHWixhQUFhcEIsRUFBRyxNQUFNLElBQUlnQyxVQUFVLGdDQUFnQyxHQUFHNEcsTUFBTUMsUUFBUXpILEdBQUcsQ0FBQyxHQUFjLElBQVhBLEVBQUVvQixPQUFXLE1BQU0sSUFBSVIsVUFBVSx1Q0FBdUNjLEdBQUUsRUFBRyxJQUFJLElBQUkwQixLQUFLcEQsRUFBRSxDQUFDLEdBQWEsaUJBQUhvRCxFQUFZLE1BQU0sSUFBSXhDLFVBQVUsa0RBQWtELElBQWtDLElBQS9CcUcsS0FBS3dCLFlBQVl4SCxRQUFRbUMsR0FBUSxNQUFNLElBQUkyRCxXQUFXLDJDQUEyQzNELE1BQU1oRCxFQUFFZ0QsR0FBRyxJQUFJLENBQUMsR0FBYSxpQkFBSGpHLEdBQWlCLE9BQUpBLEVBQVNnRSxFQUFFaEUsT0FBTyxVQUFVQSxFQUFFLElBQUksTUFBTSxJQUFJeUQsVUFBVSwrQkFBK0IsS0FBSyxDQUFDLElBQUl3QyxHQUFFLEVBQUdILEVBQUUvRCxPQUFPSyxvQkFBb0JTLEdBQUcsSUFBSSxJQUFJa0QsS0FBSytELEtBQUt3QixZQUFZLElBQW1CLElBQWhCeEYsRUFBRWhDLFFBQVFpQyxHQUFRLENBQUMsSUFBSU0sRUFBRXhELEVBQUVrRCxJQUFRLE9BQUpNLEdBQVVBLGFBQWE1RSxLQUFNd0UsR0FBRSxFQUFHMUIsR0FBRSxFQUFHdEIsRUFBRThDLEdBQUdNLEVBQUUsQ0FBQyxHQUFHSixHQUFHLEdBQWEsaUJBQUhqRyxHQUFpQixPQUFKQSxFQUFTZ0UsRUFBRWhFLE9BQU8sVUFBVUEsRUFBRSxJQUFJLE1BQU0sSUFBSXlELFVBQVUscUNBQXFDTyxFQUFFbkIsQ0FBQyxDQUFDLE1BQU0sVUFBVUEsRUFBRSxJQUFJLE1BQU0sSUFBSVksVUFBVSwyREFBMkQsSUFBSSxJQUFJd0MsS0FBSzZELEtBQUt5QixXQUFXLFVBQVU3SSxFQUFFdUQsR0FBRyxJQUFJLE1BQU0sSUFBSXBDLE1BQU0sVUFBVW9DLDZCQUE2QixHQUFHMUIsRUFBRSxJQUFJLElBQUkwQixLQUFLNkQsS0FBS3dCLFlBQVlySSxFQUFFZ0QsR0FBRyxLQUFLLE1BQU0sQ0FBQ2hELEVBQUVlLEVBQUUsQ0FBQyxzQ0FBQXlJLENBQXVDL0osR0FBRyxJQUFJRyxFQUFFLENBQUMsRUFBRSxJQUFJLElBQUk3QyxLQUFLMEMsRUFBRSxHQUFHWCxPQUFPUSxlQUFlVyxLQUFLUixFQUFFMUMsR0FBRyxDQUFDLElBQUlpRCxFQUFFUCxFQUFFMUMsR0FBbUI2QyxFQUFFN0MsR0FBbEJpRCxhQUFheEIsRUFBUXdCLEVBQU8sSUFBSXhCLEVBQUd3QixFQUFFeUYsS0FBS3pGLEVBQUU0RCxLQUFLNUQsRUFBRXlDLEtBQUssQ0FBQyxPQUFPN0MsQ0FBQyxDQUFDLGtCQUFNNkosQ0FBYWhLLEVBQUVHLEVBQUU3QyxHQUFHLElBQUlpRCxFQUFFZSxHQUFHOEYsS0FBSzBDLHdCQUF3QjlKLEVBQUVHLEVBQUU3QyxHQUFHdUUsUUFBUXVGLEtBQUtzQixRQUFRc0IsYUFBYWhLLEVBQUVPLEVBQUVlLEdBQUcsT0FBTzhGLEtBQUsyQyx1Q0FBdUNsSSxFQUFFLENBQUMsMEJBQU1vSSxDQUFxQmpLLEVBQUVHLEdBQUcsTUFBTSxJQUFJZ0IsTUFBTSwwQkFBMEIsQ0FBQyw2QkFBTStJLENBQXdCbEssR0FBRyxNQUFNLElBQUltQixNQUFNLDBCQUEwQixDQUFDLGFBQU0ySCxHQUFVLE9BQU8xQixLQUFLc0IsUUFBUTVDLFNBQVMsRUFBQyxJQUFXcUUsR0FBR3JLLEdBQUUsS0FBa0IwSixLQUFLckssRUFBR0QsS0FBU2tMLEdBQUcsQ0FBQyxFQUFFbEssRUFBR2tLLEdBQUcsQ0FBQ0MsaUJBQWlCLElBQUlwTCxFQUFHcUwsT0FBTyxJQUFJdkwsRUFBR3dMLGdCQUFnQixJQUFJcEwsRUFBR3FMLElBQUksSUFBSXhNLEVBQUd5TSxnQkFBZ0IsSUFBSTlNLElBQUssSUFBSStNLEdBQUc1SyxHQUFFLEtBQWtCb0MsSUFBS1MsSUFBSzJHLElBQUtkLElBQUtlLElBQUtZLElBQUcsSUFBUVEsR0FBRyxDQUFDLEVBQUV6SyxFQUFHeUssR0FBRyxDQUFDQyxTQUFTLElBQUlDLEtBQUssSUFBSUEsR0FBR0MsR0FBR2hMLEdBQUUsS0FBSytLLFFBQUcsQ0FBSyxJQUFRRSxHQUFHLENBQUMsRUFBRTdLLEVBQUc2SyxHQUFHLENBQUM5SSxLQUFLLElBQUkrSSxLQUFLLElBQUlBLEdBQUdDLEdBQUduTCxHQUFFLEtBQUtrTCxRQUFHLENBQUssSUFBUUUsR0FBR2pMLEdBQUcsQ0FBQ2tMLEVBQUdDLEtBQW1CLElBQWlCckwsRUFBYnNMLEdBQTRIdEwsR0FBL0dBLFNBQVM4QyxTQUFTLEtBQUtBLFNBQVN5SSxjQUFjekksU0FBU3lJLGNBQWM1RixTQUFJLElBQTJDNkYsRUFBWSxTQUFTdkwsRUFBRSxDQUFDLEdBQUcsSUFBUTFDLEVBQUVpRCxFQUFOSixFQUFFSCxFQUFNRyxFQUFFcUwsTUFBTSxJQUFJakcsU0FBUSxDQUFDa0csRUFBRUMsS0FBS3BPLEVBQUVtTyxFQUFFbEwsRUFBRW1MLEtBQUl2TCxFQUFFd0wsU0FBUyxDQUFDRixFQUFFQyxFQUFFRSxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxFQUFFQyxLQUFNOUwsRUFBRS9CLEdBQUdxTixFQUFFdEwsRUFBRStMLEdBQUdSLEVBQUV2TCxFQUFFeUMsR0FBR2dKLEVBQUV6TCxFQUFFakMsR0FBRzJOLEVBQUUxTCxFQUFFZ00sR0FBR0wsRUFBRTNMLEVBQUVpTSxHQUFHTCxFQUFFNUwsRUFBRWtNLEdBQUdMLEVBQUU3TCxFQUFFbU0sR0FBR0wsRUFBR1AsRUFBRSxDQUFDYSxFQUFFQyxFQUFFQyxJQUFJLElBQUlDLEtBQU0sSUFBSUMsRUFBR0MsR0FBR0MsRUFBRUwsTUFBTUUsRUFBR0gsS0FBS0csR0FBSSxJQUFJSSxFQUFHTixNQUFNLE9BQU9LLElBQUlDLElBQUtQLEVBQUVPLEVBQUdMLEVBQUVJLEdBQUdMLEVBQUVDLEVBQUUsTUFBTUcsSUFBSUQsRUFFeHhsQixJQUFJcEgsU0FBUSxDQUFDa0csRUFBRUMsS0FBS3FCLEdBQUcsQ0FBQ0MsUUFBUXZCLEVBQUV3QixPQUFPdkIsRUFBQyxJQUZzdmxCZ0IsR0FBSWQsRUFBRVcsR0FBRzlLLFNBQVMrSyxLQUFLLElBQUksR0FBR3JNLEVBQUUrTSxHQUFHLE1BQU0vTCxNQUFNLDJCQUEyQixJQUFJc0wsRUFBRXRNLEVBQUUrTSxHQUFHLENBQUNDLEdBQUdYLEVBQUUsR0FBR1ksT0FBTyxJQUFJVixRQUFTSCxLQUFLQyxHQUFHLEdBQUdyTSxFQUFFK00sS0FBS1QsRUFBRSxNQUFNdEwsTUFBTSxvQkFBb0JzSyxFQUFFNEIsUUFBUSxJQUFJVixFQUFHRixFQUFFVyxPQUFPLEdBQUcsRUFBRVQsRUFBR3BMLE9BQU8sQ0FBQyxJQUFJc0wsUUFBUXRILFFBQVErSCxJQUFJWCxHQUFJLEdBQUdFLEVBQUVBLEVBQUVVLFFBQU9ULEdBQUlBLElBQUksRUFBRUQsRUFBRXRMLE9BQU8sTUFBTUosTUFBTTBMLEVBQUU1SyxLQUFLLE1BQy9zb0IsQ0FBQyxPQUFPeUssQ0FBRSxDQUFDLFFBQVF2TSxFQUFFK00sR0FBRyxJQUFJLEdBQUcvTSxFQUFFcU4sUUFBUTVCLEVBQUVGLEVBQUV2TCxFQUFFcU4sU0FBUSxJQUFJck4sRUFBRXFOLFVBQVFqQixHQUFHcE0sRUFBRXFOLFFBQVFqQixLQUFJcE0sRUFBRXNOLG1CQUFtQjdCLEVBQUVGLEVBQUV2TCxFQUFFc04sb0JBQW1CLElBQUl0TixFQUFFc04scUJBQW1CbEIsR0FBR3BNLEVBQUVzTixtQkFBbUJsQixLQUFJcE0sRUFBRXVOLGNBQWNoQyxFQUFFdkwsRUFBRXVOLGVBQWMsSUFBSXZOLEVBQUV1TixnQkFBY25CLEdBQUdwTSxFQUFFdU4sY0FBY25CLElBQUdwTSxFQUFFd04sbUJBQW1CLENBQUNwQixFQUFFQyxFQUFFQyxFQUFFQyxJQUFLakIsRUFBRW1DLGVBQWVyQixFQUFFQyxFQUFFQyxFQUFFQyxHQUFJdk0sRUFBRTBOLHNCQUFzQnRCLElBQUlkLEVBQUVxQyxrQkFBa0J2QixFQUFDLEVBQUdwTSxFQUFFNE4sY0FBY3hCLEdBQUdkLEVBQUV1QyxVQUFVekIsR0FBR3BNLEVBQUU4TixxQkFBcUIsQ0FBQzFCLEVBQUVDLEVBQUVDLElBQUloQixFQUFFeUMsaUJBQWlCM0IsRUFBRUMsRUFBRUMsRUFBQyxFQUFHLElBQXdPNUksRUFBRUMsRUFBRUMsRUFBeE96QyxFQUFFakMsT0FBTzhPLE9BQU8sQ0FBQyxFQUFFaE8sR0FBRzBCLEVBQUUsaUJBQWlCMEIsRUFBRSxDQUFDa0ksRUFBRUMsS0FBSyxNQUFNQSxHQUFHdEksRUFBaUIsaUJBQVJnTCxPQUFpQi9LLEVBQXdCLG1CQUFmZ0wsY0FBMEIxSyxFQUFrQixpQkFBVDJLLFNBQTRDLGlCQUFsQkEsUUFBUTlMLFVBQWtELGlCQUF2QjhMLFFBQVE5TCxTQUFTK0wsS0FBZTNLLEVBQUUsR0FBUyxHQUFHRCxFQUFFLENBQUMsSUFBSUssR0FBRzhHLEtBQUt4SyxFQUFHcUssS0FBSzFHLEdBQUdnSCxLQUFLM0ssRUFBR3lLLEtBQUtuSCxFQUFFUCxFQUFFWSxFQUFFdUssUUFBUTVLLEdBQUcsSUFBSTZLLEtBQWM1SyxFQUFFLENBQUM0SCxFQUFFQyxLQUFLRCxFQUFFQSxFQUFFaUQsV0FBVyxXQUFXLElBQUlDLElBQUlsRCxHQUFHeEgsRUFBRTJLLFVBQVVuRCxHQUFHekgsRUFBRTZLLGFBQWFwRCxFQUFFQyxPQUFFLEVBQU8sU0FBUzNILEVBQUUwSCxLQUFJQSxFQUFFNUgsRUFBRTRILEdBQUUsSUFBTXFELFNBQVNyRCxFQUFFLElBQUlwRixXQUFXb0YsSUFBSUEsR0FBRzNILEVBQUUsQ0FBQzJILEVBQUVDLEVBQUVFLEVBQUVDLEdBQUUsS0FBTUosRUFBRUEsRUFBRWlELFdBQVcsV0FBVyxJQUFJQyxJQUFJbEQsR0FBR3hILEVBQUUySyxVQUFVbkQsR0FBR3pILEVBQUU0RyxTQUFTYSxFQUFFSSxPQUFFLEVBQU8sUUFBTyxDQUFDQyxFQUFFQyxLQUFLRCxFQUFFRixFQUFFRSxHQUFHSixFQUFFRyxFQUFFRSxFQUFFK0MsT0FBTy9DLEVBQUMsR0FBRSxHQUFJNUwsRUFBRTRPLGFBQWEsRUFBRVQsUUFBUVUsS0FBS3pOLFNBQVNNLEVBQUV5TSxRQUFRVSxLQUFLLEdBQUdDLFFBQVEsTUFBTSxNQUFNWCxRQUFRVSxLQUFLRSxNQUFNLEdBQUczTCxFQUFFLENBQUNrSSxFQUFFQyxLQUFLLE1BQU00QyxRQUFRYSxTQUFTMUQsRUFBRUMsR0FBR3ZMLEVBQUVpUCxRQUFRLElBQUksNEJBQTRCLE1BQU1oTSxHQUFHQyxLQUFLQSxFQUFFTyxFQUFFcEcsS0FBS3VJLFNBQVNzSixZQUFZeE0sU0FBUyxLQUFLQSxTQUFTeUksZ0JBQWdCMUgsRUFBRWYsU0FBU3lJLGNBQWM1RixLQUFLM0YsSUFBSTZELEVBQUU3RCxHQUEwQjZELEVBQUYsSUFBckJBLEVBQUV4QyxRQUFRLFNBQWV3QyxFQUFFMEwsT0FBTyxFQUFFMUwsRUFBRXFMLFFBQVEsU0FBUyxJQUFJTSxZQUFZLEtBQUssR0FBSyxHQUFHMUwsRUFBRTRILElBQUksSUFBSUMsRUFBRSxJQUFJOEQsZUFBZSxPQUFPOUQsRUFBRStELEtBQUssTUFBTWhFLEdBQUUsR0FBSUMsRUFBRWdFLEtBQUssTUFBTWhFLEVBQUVpRSxjQUFjdE0sSUFBSVUsRUFBRTBILElBQUksSUFBSUMsRUFBRSxJQUFJOEQsZUFBZSxPQUFPOUQsRUFBRStELEtBQUssTUFBTWhFLEdBQUUsR0FBSUMsRUFBRWtFLGFBQWEsY0FBY2xFLEVBQUVnRSxLQUFLLE1BQU0sSUFBSXJKLFdBQVdxRixFQUFFbUUsU0FBUSxHQUFJL0wsRUFBRSxDQUFDMkgsRUFBRUMsRUFBRUUsS0FBSyxJQUFJQyxFQUFFLElBQUkyRCxlQUFlM0QsRUFBRTRELEtBQUssTUFBTWhFLEdBQUUsR0FBSUksRUFBRStELGFBQWEsY0FBYy9ELEVBQUVsRyxPQUFPLEtBQWUsS0FBVmtHLEVBQUVpRSxRQUF1QixHQUFWakUsRUFBRWlFLFFBQVdqRSxFQUFFZ0UsU0FBU25FLEVBQUVHLEVBQUVnRSxVQUFVakUsR0FBRSxFQUFHQyxFQUFFa0UsUUFBUW5FLEVBQUVDLEVBQUU2RCxLQUFLLEtBQUksR0FBSSxJQUFxS3JMLEVBQWpLSCxFQUFFL0QsRUFBRTZQLE9BQU9DLFFBQVFDLElBQUlDLEtBQUtGLFNBQVM3TCxFQUFFakUsRUFBRWlRLFVBQVVILFFBQVFJLE1BQU1GLEtBQUtGLFNBQVM1USxPQUFPOE8sT0FBT2hPLEVBQUVtQixHQUFHQSxFQUFFLEtBQUtuQixFQUFFNE8sY0FBY2xOLEVBQUUxQixFQUFFNE8sYUFBYTVPLEVBQUVtUSxPQUFPL00sRUFBRXBELEVBQUVtUSxNQUFZblEsRUFBRW9RLGFBQWFsTSxFQUFFbEUsRUFBRW9RLFlBQVksSUFBSWpNLEVBQUVuRSxFQUFFcVEsZ0JBQWUsRUFBdUIsaUJBQWJDLGFBQXVCQyxFQUFHLG1DQUFtQyxJQUFJL0wsRUFBRWdNLEVBQU9DLEVBQUVDLEVBQUVDLEVBQUdDLEVBQUVDLEVBQUVDLEVBQUdDLEVBQW5CQyxHQUFFLEVBQW9CLFNBQVNDLElBQUssSUFBSTNGLEVBQUU5RyxFQUFFbUssT0FBTzNPLEVBQUVrUixNQUFNUixFQUFFLElBQUl2SyxVQUFVbUYsR0FBR3RMLEVBQUVtUixPQUFPLElBQUk5SyxXQUFXaUYsR0FBR3RMLEVBQUVvUixPQUFPUixFQUFFLElBQUl0SyxXQUFXZ0YsR0FBR3RMLEVBQUVxUixPQUFPVixFQUFHLElBQUl6SyxXQUFXb0YsR0FBR3RMLEVBQUVzUixRQUFRLElBQUlsTCxZQUFZa0YsR0FBR3RMLEVBQUV1UixRQUFRVixFQUFFLElBQUlySyxZQUFZOEUsR0FBR3RMLEVBQUV3UixRQUFRVixFQUFHLElBQUlsTSxhQUFhMEcsR0FBR3RMLEVBQUV5UixRQUFRVixFQUFHLElBQUl4SyxhQUFhK0UsRUFBRSxDQUFDLElBQUlvRyxFQUFFLEdBQUdDLEVBQUcsR0FBR0MsRUFBRyxHQUFHLFNBQVNDLElBQUssSUFBSXZHLEVBQUV0TCxFQUFFOFIsT0FBT0MsUUFBUUwsRUFBRU0sUUFBUTFHLEVBQUUsQ0FBQyxJQUEwUTJHLEVBQXRRQyxFQUFHLEVBQUVDLEVBQUcsS0FBS0MsRUFBRyxLQUFLLFNBQVM3QixFQUFHakYsR0FBRyxNQUFNdEwsRUFBRXFTLFNBQVNyUyxFQUFFcVMsUUFBUS9HLEdBQXNCckgsRUFBbkJxSCxFQUFFLFdBQVdBLEVBQUUsS0FBUzBGLEdBQUUsRUFBR1AsRUFBRSxFQUFFbkYsRUFBRSxJQUFJZ0YsWUFBWWdDLGFBQWFoSCxFQUFFLDRDQUE0Q2xMLEVBQUVrTCxHQUFHQSxDQUFDLENBQUMsU0FBU2lILEVBQUVqSCxHQUFHLE9BQU9BLEVBQUVpRCxXQUFXLHdDQUF3QyxDQUFRLElBQTRCZ0UsRUFBekJOLEVBQUcsc0JBQTRCLENBQUMsSUFBSU8sRUFBR1AsRUFBR0EsRUFBR2pTLEVBQUV5UyxXQUFXelMsRUFBRXlTLFdBQVdELEVBQUcvTyxHQUFHQSxFQUFFK08sQ0FBRSxDQUFDLFNBQVNFLEVBQUdwSCxHQUFHLEdBQUdBLEdBQUcyRyxHQUFJL04sRUFBRSxPQUFPLElBQUlnQyxXQUFXaEMsR0FBRyxHQUFHTixFQUFFLE9BQU9BLEVBQUUwSCxHQUFHLEtBQUssaURBQWlELENBQXlWLFNBQVNxSCxFQUFHckgsRUFBRUMsRUFBRUUsR0FBRyxPQUEzVyxTQUFZSCxHQUFHLElBQUlwSCxJQUFJakIsR0FBR0MsR0FBRyxDQUFDLEdBQWlCLG1CQUFQMFAsUUFBb0J0SCxFQUFFaUQsV0FBVyxXQUFXLE9BQU9xRSxNQUFNdEgsRUFBRSxDQUFDdUgsWUFBWSxnQkFBZ0JDLE1BQUt2SCxJQUFJLElBQUlBLEVBQUV3SCxHQUFHLEtBQUssdUNBQXVDekgsRUFBRSxJQUFJLE9BQU9DLEVBQUV5SCxhQUFZLElBQUlDLE9BQU0sSUFBSVAsRUFBR3BILEtBQUksR0FBRzNILEVBQUUsT0FBTyxJQUFJeUIsU0FBUSxDQUFDbUcsRUFBRUUsS0FBSzlILEVBQUUySCxHQUFFSSxHQUFHSCxFQUFFLElBQUlyRixXQUFXd0YsS0FBSUQsRUFBQyxHQUFHLENBQUMsT0FBT3JHLFFBQVF5SCxVQUFVaUcsTUFBSyxJQUFJSixFQUFHcEgsSUFBRyxDQUEyQjRILENBQUc1SCxHQUFHd0gsTUFBS3BILEdBQUc0RSxZQUFZNkMsWUFBWXpILEVBQUVILEtBQUl1SCxNQUFLcEgsR0FBR0EsSUFBR29ILEtBQUtySCxHQUFFQyxJQUFJekgsRUFBRSwwQ0FBMEN5SCxHQUFHNkUsRUFBRzdFLEVBQUMsR0FBRyxDQUErVyxJQUFJMEgsRUFBR0MsRUFBRyxDQUFDLE9BQU8vSCxJQUFJdEwsRUFBRWlNLEdBQUcsTUFBTVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE1BQU1YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxRQUFRWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsT0FBT1gsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLGFBQWFYLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxPQUFPWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsTUFBTVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE1BQU1YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxVQUFVWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsTUFBTVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE1BQU1YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxNQUFNWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsTUFBTVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE9BQU9YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxPQUFPWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsT0FBT1gsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE9BQU9YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxPQUFPWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsUUFBUVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLFFBQVFYLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxRQUFRWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsT0FBT1gsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE1BQU1YLE9BQUUsRUFBTSxFQUFHLE9BQU8sQ0FBQ0EsRUFBRUMsRUFBRUUsS0FBS3pMLEVBQUVpTSxHQUFHLFVBQVVYLEVBQUUsQ0FBQ2dJLElBQUkvSCxFQUFFZ0ksSUFBSTlILEdBQUUsRUFBRyxPQUFPSCxJQUFJdEwsRUFBRWlNLEdBQUcsT0FBT1gsT0FBRSxFQUFNLEVBQUcsT0FBTyxDQUFDQSxFQUFFQyxLQUFLdkwsRUFBRWlNLEdBQUcsTUFBTVgsRUFBRSxDQUFDa0ksTUFBTWpJLEdBQUUsRUFBRyxPQUFPRCxJQUFJdEwsRUFBRWlNLEdBQUcsT0FBT1gsT0FBRSxFQUFNLEVBQUcsT0FBTyxDQUFDQSxFQUFFQyxLQUFLdkwsRUFBRWlNLEdBQUcsWUFBWVgsRUFBRSxDQUFDa0ksTUFBTWpJLEdBQUUsRUFBRyxPQUFPLENBQUNELEVBQUVDLEtBQUt2TCxFQUFFaU0sR0FBRyxrQkFBa0JYLEVBQUUsQ0FBQ2tJLE1BQU1qSSxHQUFFLEVBQUcsT0FBTyxDQUFDRCxFQUFFQyxLQUFLdkwsRUFBRWlNLEdBQUcsT0FBT1gsRUFBRSxDQUFDbk4sR0FBR29OLEdBQUUsRUFBRyxPQUFPRCxJQUFJdEwsRUFBRWlNLEdBQUcsTUFBTVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE1BQU1YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxNQUFNWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsTUFBTVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE1BQU1YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxRQUFRWCxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJdEwsRUFBRWlNLEdBQUcsVUFBVVgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLGlCQUFpQlgsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSXRMLEVBQUVpTSxHQUFHLE9BQU9YLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUl0TCxFQUFFaU0sR0FBRyxjQUFjWCxPQUFFLEVBQU0sRUFBRyxPQUFPLENBQUNBLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxhQUFhWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxhQUFhWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxZQUFZWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVDLEVBQUVFLEVBQUVDLEVBQUVDLEtBQUszTCxFQUFFaU0sR0FBRyxXQUFXWCxFQUFFLENBQUNtSSxXQUFXbEksRUFBRW1JLG9CQUFvQmpJLEVBQUVrSSxLQUFLakksRUFBRWxFLE1BQU1kLEtBQUtrSyxFQUFFZ0QsU0FBU2pJLElBQUksRUFBRUEsRUFBRUQsSUFBSSxJQUFJLElBQUcsRUFBRyxPQUFPLENBQUNKLEVBQUVD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QU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsYUFBYXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxVQUFVcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxNQUFNcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE1BQU1wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsT0FBT3BjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE9BQU9wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsT0FBT3BjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxPQUFPcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLFFBQVFwYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsUUFBUXBjLE9BQUUsRUFBTSxFQUFHLE9BQU9BLElBQUk2RixFQUFFdVcsR0FBRyxRQUFRcGMsT0FBRSxFQUFNLEVBQUcsT0FBT0EsSUFBSTZGLEVBQUV1VyxHQUFHLE9BQU9wYyxPQUFFLEVBQU0sRUFBRyxPQUFPQSxJQUFJNkYsRUFBRXVXLEdBQUcsTUFBTXBjLE9BQUUsRUFBTSxFQUFH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bS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vb3J0LXNhbS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9janMvb3J0LndlYmdwdS5taW4uanMiLCJ3ZWJwYWNrOi8vb3J0LXNhbS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9vcnQtc2FtL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vb3J0LXNhbS8uL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAiLCIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMTcuMC1kZXYuMjAyMzExMDMtMTQzOWRhMzZmZVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblwidXNlIHN0cmljdFwiO3ZhciBfbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIGtsPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIEJsPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBNbD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBMPShlLHQpPT4oKT0+KGUmJih0PWUoZT0wKSksdCk7dmFyIEx0PShlLHQpPT4oKT0+KHR8fGUoKHQ9e2V4cG9ydHM6e319KS5leHBvcnRzLHQpLHQuZXhwb3J0cyksa3Q9KGUsdCk9Pntmb3IodmFyIHIgaW4gdClfbihlLHIse2dldDp0W3JdLGVudW1lcmFibGU6ITB9KX0sRGw9KGUsdCxyLGEpPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBuIG9mIEJsKHQpKSFNbC5jYWxsKGUsbikmJm4hPT1yJiZfbihlLG4se2dldDooKT0+dFtuXSxlbnVtZXJhYmxlOiEoYT1rbCh0LG4pKXx8YS5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciB2dD1lPT5EbChfbih7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgV3IsQnQsZnQsTnIsVnI9TCgoKT0+e1widXNlIHN0cmljdFwiO1dyPW5ldyBNYXAsQnQ9W10sZnQ9KGUsdCxyKT0+e2lmKHQmJnR5cGVvZiB0LmluaXQ9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI9PVwiZnVuY3Rpb25cIil7bGV0IGE9V3IuZ2V0KGUpO2lmKGE9PT12b2lkIDApV3Iuc2V0KGUse2JhY2tlbmQ6dCxwcmlvcml0eTpyfSk7ZWxzZXtpZihhLnByaW9yaXR5PnIpcmV0dXJuO2lmKGEucHJpb3JpdHk9PT1yJiZhLmJhY2tlbmQhPT10KXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke2V9XCIgdXNpbmcgcHJpb3JpdHkgJHtyfWApfWlmKHI+PTApe2xldCBuPUJ0LmluZGV4T2YoZSk7biE9PS0xJiZCdC5zcGxpY2UobiwxKTtmb3IobGV0IHM9MDtzPEJ0Lmxlbmd0aDtzKyspaWYoV3IuZ2V0KEJ0W3NdKS5wcmlvcml0eTw9cil7QnQuc3BsaWNlKHMsMCxlKTtyZXR1cm59QnQucHVzaChlKX1yZXR1cm59dGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIHZhbGlkIGJhY2tlbmRcIil9LE5yPWFzeW5jIGU9PntsZXQgdD1lLmxlbmd0aD09PTA/QnQ6ZSxyPVtdO2ZvcihsZXQgYSBvZiB0KXtsZXQgbj1Xci5nZXQoYSk7aWYobil7aWYobi5pbml0aWFsaXplZClyZXR1cm4gbi5iYWNrZW5kO2lmKG4uYWJvcnRlZCljb250aW51ZTtsZXQgcz0hIW4uaW5pdFByb21pc2U7dHJ5e3JldHVybiBzfHwobi5pbml0UHJvbWlzZT1uLmJhY2tlbmQuaW5pdCgpKSxhd2FpdCBuLmluaXRQcm9taXNlLG4uaW5pdGlhbGl6ZWQ9ITAsbi5iYWNrZW5kfWNhdGNoKHUpe3N8fHIucHVzaCh7bmFtZTphLGVycjp1fSksbi5hYm9ydGVkPSEwfWZpbmFsbHl7ZGVsZXRlIG4uaW5pdFByb21pc2V9fX10aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ci5tYXAoYT0+YFske2EubmFtZX1dICR7YS5lcnJ9YCkuam9pbihcIiwgXCIpfWApfX0pO3ZhciBMYT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VnIoKX0pO3ZhciBIYSxqYT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SGE9XCIxLjE3LjAtZGV2LjIwMjMxMTAzLTE0MzlkYTM2ZmVcIn0pO3ZhciBxYSxPbixLYT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7amEoKTtxYT1cIndhcm5pbmdcIixPbj17d2FzbTp7fSx3ZWJnbDp7fSx3ZWJncHU6e30sdmVyc2lvbnM6e2NvbW1vbjpIYX0sc2V0IGxvZ0xldmVsKGUpe2lmKGUhPT12b2lkIDApe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wifHxbXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihlKT09PS0xKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApO3FhPWV9fSxnZXQgbG9nTGV2ZWwoKXtyZXR1cm4gcWF9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoT24sXCJsb2dMZXZlbFwiLHtlbnVtZXJhYmxlOiEwfSl9KTt2YXIgSWUsWWE9TCgoKT0+e1widXNlIHN0cmljdFwiO0thKCk7SWU9T259KTt2YXIgWGEsSmEsUWE9TCgoKT0+e1widXNlIHN0cmljdFwiO1hhPShlLHQpPT57bGV0IHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyLndpZHRoPWUuZGltc1szXSxyLmhlaWdodD1lLmRpbXNbMl07bGV0IGE9ci5nZXRDb250ZXh0KFwiMmRcIik7aWYoYSE9bnVsbCl7bGV0IG4sczt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG49ZS5kaW1zWzJdLHM9ZS5kaW1zWzNdKToobj1lLmRpbXNbM10scz1lLmRpbXNbMl0pO2xldCB1PXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGw9dD8ubm9ybSxvLHA7bD09PXZvaWQgMHx8bC5tZWFuPT09dm9pZCAwP289WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGwubWVhbj09XCJudW1iZXJcIj9vPVtsLm1lYW4sbC5tZWFuLGwubWVhbixsLm1lYW5dOihvPVtsLm1lYW5bMF0sbC5tZWFuWzFdLGwubWVhblsyXSwwXSxsLm1lYW5bM10hPT12b2lkIDAmJihvWzNdPWwubWVhblszXSkpLGw9PT12b2lkIDB8fGwuYmlhcz09PXZvaWQgMD9wPVswLDAsMCwwXTp0eXBlb2YgbC5iaWFzPT1cIm51bWJlclwiP3A9W2wuYmlhcyxsLmJpYXMsbC5iaWFzLGwuYmlhc106KHA9W2wuYmlhc1swXSxsLmJpYXNbMV0sbC5iaWFzWzJdLDBdLGwuYmlhc1szXSE9PXZvaWQgMCYmKHBbM109bC5iaWFzWzNdKSk7bGV0IG09cypuLHk9MCxnPW0sdj1tKjIsJD0tMTt1PT09XCJSR0JBXCI/KHk9MCxnPW0sdj1tKjIsJD1tKjMpOnU9PT1cIlJHQlwiPyh5PTAsZz1tLHY9bSoyKTp1PT09XCJSQkdcIiYmKHk9MCx2PW0sZz1tKjIpO2ZvcihsZXQgYj0wO2I8cztiKyspZm9yKGxldCBTPTA7UzxuO1MrKyl7bGV0IEk9KGUuZGF0YVt5KytdLXBbMF0pKm9bMF0sVD0oZS5kYXRhW2crK10tcFsxXSkqb1sxXSxCPShlLmRhdGFbdisrXS1wWzJdKSpvWzJdLFA9JD09PS0xPzI1NTooZS5kYXRhWyQrK10tcFszXSkqb1szXTthLmZpbGxTdHlsZT1cInJnYmEoXCIrSStcIixcIitUK1wiLFwiK0IrXCIsXCIrUCtcIilcIixhLmZpbGxSZWN0KFMsYiwxLDEpfXJldHVybiByLnRvRGF0YVVSTCgpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0sSmE9KGUsdCk9PntsZXQgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSxhO2lmKHIhPW51bGwpe2xldCBuLHMsdTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG49ZS5kaW1zWzJdLHM9ZS5kaW1zWzFdLHU9ZS5kaW1zWzNdKToobj1lLmRpbXNbM10scz1lLmRpbXNbMl0sdT1lLmRpbXNbMV0pO2xldCBsPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsbz10Py5ub3JtLHAsbTtvPT09dm9pZCAwfHxvLm1lYW49PT12b2lkIDA/cD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2Ygby5tZWFuPT1cIm51bWJlclwiP3A9W28ubWVhbixvLm1lYW4sby5tZWFuLG8ubWVhbl06KHA9W28ubWVhblswXSxvLm1lYW5bMV0sby5tZWFuWzJdLDI1NV0sby5tZWFuWzNdIT09dm9pZCAwJiYocFszXT1vLm1lYW5bM10pKSxvPT09dm9pZCAwfHxvLmJpYXM9PT12b2lkIDA/bT1bMCwwLDAsMF06dHlwZW9mIG8uYmlhcz09XCJudW1iZXJcIj9tPVtvLmJpYXMsby5iaWFzLG8uYmlhcyxvLmJpYXNdOihtPVtvLmJpYXNbMF0sby5iaWFzWzFdLG8uYmlhc1syXSwwXSxvLmJpYXNbM10hPT12b2lkIDAmJihtWzNdPW8uYmlhc1szXSkpO2xldCB5PXMqbjtpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJnU9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHx1PT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgZz00LHY9MCwkPTEsYj0yLFM9MyxJPTAsVD15LEI9eSoyLFA9LTE7bD09PVwiUkdCQVwiPyhJPTAsVD15LEI9eSoyLFA9eSozKTpsPT09XCJSR0JcIj8oST0wLFQ9eSxCPXkqMik6bD09PVwiUkJHXCImJihJPTAsQj15LFQ9eSoyKSxhPXIuY3JlYXRlSW1hZ2VEYXRhKG4scyk7Zm9yKGxldCBEPTA7RDxzKm47dis9ZywkKz1nLGIrPWcsUys9ZyxEKyspYS5kYXRhW3ZdPShlLmRhdGFbSSsrXS1tWzBdKSpwWzBdLGEuZGF0YVskXT0oZS5kYXRhW1QrK10tbVsxXSkqcFsxXSxhLmRhdGFbYl09KGUuZGF0YVtCKytdLW1bMl0pKnBbMl0sYS5kYXRhW1NdPVA9PT0tMT8yNTU6KGUuZGF0YVtQKytdLW1bM10pKnBbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiBhfX0pO3ZhciBUbixaYSxlbyx0byxybyxubz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VXIoKTtUbj0oZSx0KT0+e2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0OnIsd2lkdGg6YX09dCxuPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0scyx1O3R5cGVvZiBuLm1lYW49PVwibnVtYmVyXCI/cz1bbi5tZWFuLG4ubWVhbixuLm1lYW4sbi5tZWFuXTpzPVtuLm1lYW5bMF0sbi5tZWFuWzFdLG4ubWVhblsyXSxuLm1lYW5bM10/PzI1NV0sdHlwZW9mIG4uYmlhcz09XCJudW1iZXJcIj91PVtuLmJpYXMsbi5iaWFzLG4uYmlhcyxuLmJpYXNdOnU9W24uYmlhc1swXSxuLmJpYXNbMV0sbi5iaWFzWzJdLG4uYmlhc1szXT8/MF07bGV0IGw9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsbz10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixwPXIqYSxtPW89PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KHAqNCk6bmV3IEZsb2F0MzJBcnJheShwKjMpLHk9NCxnPTAsdj0xLCQ9MixiPTMsUz0wLEk9cCxUPXAqMixCPS0xO2w9PT1cIlJHQlwiJiYoeT0zLGc9MCx2PTEsJD0yLGI9LTEpLG89PT1cIlJHQkFcIj9CPXAqMzpvPT09XCJSQkdcIj8oUz0wLFQ9cCxJPXAqMik6bz09PVwiQkdSXCImJihUPTAsST1wLFM9cCoyKTtmb3IobGV0IEQ9MDtEPHA7RCsrLGcrPXksJCs9eSx2Kz15LGIrPXkpbVtTKytdPShlW2ddK3VbMF0pL3NbMF0sbVtJKytdPShlW3ZdK3VbMV0pL3NbMV0sbVtUKytdPShlWyRdK3VbMl0pL3NbMl0sQiE9PS0xJiZiIT09LTEmJihtW0IrK109KGVbYl0rdVszXSkvc1szXSk7cmV0dXJuIG89PT1cIlJHQkFcIj9uZXcgRmUoXCJmbG9hdDMyXCIsbSxbMSw0LHIsYV0pOm5ldyBGZShcImZsb2F0MzJcIixtLFsxLDMscixhXSl9LFphPWFzeW5jKGUsdCk9PntsZXQgcj10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsYT10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG49dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAscz10eXBlb2YgZT09XCJzdHJpbmdcIix1LGw9dD8/e307aWYocil7bGV0IG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtvLndpZHRoPWUud2lkdGgsby5oZWlnaHQ9ZS5oZWlnaHQ7bGV0IHA9by5nZXRDb250ZXh0KFwiMmRcIik7aWYocCE9bnVsbCl7bGV0IG09ZS5oZWlnaHQseT1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJihtPXQucmVzaXplZEhlaWdodCx5PXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihsPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7bC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsbC5oZWlnaHQ9bSxsLndpZHRoPXl9ZWxzZSBsLnRlbnNvckZvcm1hdD1cIlJHQkFcIixsLmhlaWdodD1tLGwud2lkdGg9eTtwLmRyYXdJbWFnZShlLDAsMCksdT1wLmdldEltYWdlRGF0YSgwLDAseSxtKS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKGEpe2xldCBvLHA7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8obz10LnJlc2l6ZWRIZWlnaHQscD10LnJlc2l6ZWRXaWR0aCk6KG89ZS5oZWlnaHQscD1lLndpZHRoKSx0IT09dm9pZCAwJiYobD10KSxsLmZvcm1hdD1cIlJHQkFcIixsLmhlaWdodD1vLGwud2lkdGg9cCx0IT09dm9pZCAwKXtsZXQgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO20ud2lkdGg9cCxtLmhlaWdodD1vO2xldCB5PW0uZ2V0Q29udGV4dChcIjJkXCIpO2lmKHkhPW51bGwpeS5wdXRJbWFnZURhdGEoZSwwLDApLHU9eS5nZXRJbWFnZURhdGEoMCwwLHAsbykuZGF0YTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSB1PWUuZGF0YX1lbHNlIGlmKG4pe2lmKHQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcFwiKTtsZXQgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO28ud2lkdGg9ZS53aWR0aCxvLmhlaWdodD1lLmhlaWdodDtsZXQgcD1vLmdldENvbnRleHQoXCIyZFwiKTtpZihwIT1udWxsKXtsZXQgbT1lLmhlaWdodCx5PWUud2lkdGg7cmV0dXJuIHAuZHJhd0ltYWdlKGUsMCwwLHksbSksdT1wLmdldEltYWdlRGF0YSgwLDAseSxtKS5kYXRhLGwuaGVpZ2h0PW0sbC53aWR0aD15LFRuKHUsbCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2V7aWYocylyZXR1cm4gbmV3IFByb21pc2UoKG8scCk9PntsZXQgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHk9bS5nZXRDb250ZXh0KFwiMmRcIik7aWYoIWV8fCF5KXJldHVybiBwKCk7bGV0IGc9bmV3IEltYWdlO2cuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIixnLnNyYz1lLGcub25sb2FkPSgpPT57bS53aWR0aD1nLndpZHRoLG0uaGVpZ2h0PWcuaGVpZ2h0LHkuZHJhd0ltYWdlKGcsMCwwLG0ud2lkdGgsbS5oZWlnaHQpO2xldCB2PXkuZ2V0SW1hZ2VEYXRhKDAsMCxtLndpZHRoLG0uaGVpZ2h0KTtsLmhlaWdodD1tLmhlaWdodCxsLndpZHRoPW0ud2lkdGgsbyhUbih2LmRhdGEsbCkpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKHUhPT12b2lkIDApcmV0dXJuIFRuKHUsbCk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LGVvPShlLHQpPT57bGV0e3dpZHRoOnIsaGVpZ2h0OmEsZG93bmxvYWQ6bixkaXNwb3NlOnN9PXQsdT1bMSxhLHIsNF07cmV0dXJuIG5ldyBGZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczp1LGRvd25sb2FkOm4sZGlzcG9zZTpzfSl9LHRvPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczphLGRvd25sb2FkOm4sZGlzcG9zZTpzfT10O3JldHVybiBuZXcgRmUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczphLGRvd25sb2FkOm4sZGlzcG9zZTpzfSl9LHJvPShlLHQscik9Pm5ldyBGZSh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsdHlwZTplLGRhdGE6dCxkaW1zOnI/P1t0Lmxlbmd0aF19KX0pO3ZhciBscixHcixhbyxvbyxpbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bHI9bmV3IE1hcChbW1wiZmxvYXQzMlwiLEZsb2F0MzJBcnJheV0sW1widWludDhcIixVaW50OEFycmF5XSxbXCJpbnQ4XCIsSW50OEFycmF5XSxbXCJ1aW50MTZcIixVaW50MTZBcnJheV0sW1wiZmxvYXQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XV0pLEdyPW5ldyBNYXAoW1tGbG9hdDMyQXJyYXksXCJmbG9hdDMyXCJdLFtVaW50OEFycmF5LFwidWludDhcIl0sW0ludDhBcnJheSxcImludDhcIl0sW1VpbnQxNkFycmF5LFwidWludDE2XCJdLFtJbnQxNkFycmF5LFwiaW50MTZcIl0sW0ludDMyQXJyYXksXCJpbnQzMlwiXSxbRmxvYXQ2NEFycmF5LFwiZmxvYXQ2NFwiXSxbVWludDMyQXJyYXksXCJ1aW50MzJcIl1dKSxhbz0hMSxvbz0oKT0+e2lmKCFhbyl7YW89ITA7bGV0IGU9dHlwZW9mIEJpZ0ludDY0QXJyYXk8XCJ1XCImJnR5cGVvZiBCaWdJbnQ2NEFycmF5LmZyb209PVwiZnVuY3Rpb25cIix0PXR5cGVvZiBCaWdVaW50NjRBcnJheTxcInVcIiYmdHlwZW9mIEJpZ1VpbnQ2NEFycmF5LmZyb209PVwiZnVuY3Rpb25cIjtlJiYobHIuc2V0KFwiaW50NjRcIixCaWdJbnQ2NEFycmF5KSxHci5zZXQoQmlnSW50NjRBcnJheSxcImludDY0XCIpKSx0JiYobHIuc2V0KFwidWludDY0XCIsQmlnVWludDY0QXJyYXkpLEdyLnNldChCaWdVaW50NjRBcnJheSxcInVpbnQ2NFwiKSl9fX0pO3ZhciBzbyx1byxsbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VXIoKTtzbz1lPT57bGV0IHQ9MTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IGE9ZVtyXTtpZih0eXBlb2YgYSE9XCJudW1iZXJcInx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKGEpKXRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtyfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7YX1gKTtpZihhPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtyfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7YX1gKTt0Kj1hfXJldHVybiB0fSx1bz0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IEZlKGUudHlwZSxlLmRhdGEsdCk7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiBuZXcgRmUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLGRhdGE6ZS5kYXRhLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gbmV3IEZlKHtsb2NhdGlvbjpcInRleHR1cmVcIix0ZXh0dXJlOmUudGV4dHVyZSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIG5ldyBGZSh7bG9jYXRpb246XCJncHUtYnVmZmVyXCIsZ3B1QnVmZmVyOmUuZ3B1QnVmZmVyLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHtlLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCl9fX0pO3ZhciBGZSxVcj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7UWEoKTtubygpO2lvKCk7bG8oKTtGZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsYSl7b28oKTtsZXQgbixzO2lmKHR5cGVvZiB0PT1cIm9iamVjdFwiJiZcImxvY2F0aW9uXCJpbiB0KXN3aXRjaCh0aGlzLmRhdGFMb2NhdGlvbj10LmxvY2F0aW9uLG49dC50eXBlLHM9dC5kaW1zLHQubG9jYXRpb24pe2Nhc2VcImNwdS1waW5uZWRcIjp7bGV0IGw9bHIuZ2V0KG4pO2lmKCFsKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke259XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHBpbm5lZCBidWZmZXJgKTtpZighKHQuZGF0YSBpbnN0YW5jZW9mIGwpKXRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2wubmFtZX1gKTt0aGlzLmNwdURhdGE9dC5kYXRhO2JyZWFrfWNhc2VcInRleHR1cmVcIjp7aWYobiE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke259XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTt0aGlzLmdwdVRleHR1cmVEYXRhPXQudGV4dHVyZSx0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJncHUtYnVmZmVyXCI6e2lmKG4hPT1cImZsb2F0MzJcIiYmbiE9PVwiZmxvYXQxNlwiJiZuIT09XCJpbnQzMlwiJiZuIT09XCJpbnQ2NFwiJiZuIT09XCJ1aW50MzJcIiYmbiE9PVwiYm9vbFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke259XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIGdwdSBidWZmZXJgKTt0aGlzLmdwdUJ1ZmZlckRhdGE9dC5ncHVCdWZmZXIsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApfWVsc2V7bGV0IGwsbztpZih0eXBlb2YgdD09XCJzdHJpbmdcIilpZihuPXQsbz1hLHQ9PT1cInN0cmluZ1wiKXtpZighQXJyYXkuaXNBcnJheShyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtsPXJ9ZWxzZXtsZXQgcD1sci5nZXQodCk7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHt0fS5gKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZih0PT09XCJmbG9hdDE2XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNyZWF0aW5nIGEgZmxvYXQxNiB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBVaW50MTZBcnJheSBhcyBkYXRhLlwiKTt0PT09XCJ1aW50NjRcInx8dD09PVwiaW50NjRcIj9sPXAuZnJvbShyLEJpZ0ludCk6bD1wLmZyb20ocil9ZWxzZSBpZihyIGluc3RhbmNlb2YgcClsPXI7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7bn0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtwfWApfWVsc2UgaWYobz1yLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBwPXR5cGVvZiB0WzBdO2lmKHA9PT1cInN0cmluZ1wiKW49XCJzdHJpbmdcIixsPXQ7ZWxzZSBpZihwPT09XCJib29sZWFuXCIpbj1cImJvb2xcIixsPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7cH0uYCl9ZWxzZXtsZXQgcD1Hci5nZXQodC5jb25zdHJ1Y3Rvcik7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtuPXAsbD10fWlmKG89PT12b2lkIDApbz1bbC5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkobykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO3M9byx0aGlzLmNwdURhdGE9bCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCB1PXNvKHMpO2lmKHRoaXMuY3B1RGF0YSYmdSE9PXRoaXMuY3B1RGF0YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7dX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1uLHRoaXMuZGltcz1zLHRoaXMuc2l6ZT11fXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxyKXtyZXR1cm4gWmEodCxyKX1zdGF0aWMgZnJvbVRleHR1cmUodCxyKXtyZXR1cm4gZW8odCxyKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LHIpe3JldHVybiB0byh0LHIpfXN0YXRpYyBmcm9tUGlubmVkQnVmZmVyKHQscixhKXtyZXR1cm4gcm8odCxyLGEpfXRvRGF0YVVSTCh0KXtyZXR1cm4gWGEodGhpcyx0KX10b0ltYWdlRGF0YSh0KXtyZXR1cm4gSmEodGhpcyx0KX1nZXQgZGF0YSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5jcHVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBvbiBDUFUuIFVzZSBgZ2V0RGF0YSgpYCB0byBkb3dubG9hZCBHUFUgZGF0YSB0byBDUFUsIG9yIHVzZSBgdGV4dHVyZWAgb3IgYGdwdUJ1ZmZlcmAgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBHUFUgZGF0YSBkaXJlY3RseS5cIik7cmV0dXJuIHRoaXMuY3B1RGF0YX1nZXQgbG9jYXRpb24oKXtyZXR1cm4gdGhpcy5kYXRhTG9jYXRpb259Z2V0IHRleHR1cmUoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1VGV4dHVyZURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuXCIpO3JldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhfWdldCBncHVCdWZmZXIoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1QnVmZmVyRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci5cIik7cmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IHI9YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9cix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxyfWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuaXNEb3dubG9hZGluZz12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJub25lXCJ9ZW5zdXJlVmFsaWQoKXtpZih0aGlzLmRhdGFMb2NhdGlvbj09PVwibm9uZVwiKXRocm93IG5ldyBFcnJvcihcIlRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXCIpfXJlc2hhcGUodCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZG93bmxvYWRlcnx8dGhpcy5kaXNwb3Nlcil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLlwiKTtyZXR1cm4gdW8odGhpcyx0KX19fSk7dmFyIFVlLEZyPUwoKCk9PntcInVzZSBzdHJpY3RcIjtVcigpO1VlPUZlfSk7dmFyIExyLGNvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtWcigpO0ZyKCk7THI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhhbmRsZXI9dH1hc3luYyBydW4odCxyLGEpe2xldCBuPXt9LHM9e307aWYodHlwZW9mIHQhPVwib2JqZWN0XCJ8fHQ9PT1udWxsfHx0IGluc3RhbmNlb2YgVWV8fEFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgdT0hMDtpZih0eXBlb2Ygcj09XCJvYmplY3RcIil7aWYocj09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZihyIGluc3RhbmNlb2YgVWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7aWYoQXJyYXkuaXNBcnJheShyKSl7aWYoci5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTt1PSExO2ZvcihsZXQgcCBvZiByKXtpZih0eXBlb2YgcCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtpZih0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YocCk9PT0tMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7cH0uYCk7bltwXT1udWxsfWlmKHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhIT09bnVsbClzPWE7ZWxzZSBpZih0eXBlb2YgYTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBwPSExLG09T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocik7Zm9yKGxldCB5IG9mIHRoaXMub3V0cHV0TmFtZXMpaWYobS5pbmRleE9mKHkpIT09LTEpe2xldCBnPXJbeV07KGc9PT1udWxsfHxnIGluc3RhbmNlb2YgVWUpJiYocD0hMCx1PSExLG5beV09Zyl9aWYocCl7aWYodHlwZW9mIGE9PVwib2JqZWN0XCImJmEhPT1udWxsKXM9YTtlbHNlIGlmKHR5cGVvZiBhPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2Ugcz1yfX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO2ZvcihsZXQgcCBvZiB0aGlzLmlucHV0TmFtZXMpaWYodHlwZW9mIHRbcF0+XCJ1XCIpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtwfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO2lmKHUpZm9yKGxldCBwIG9mIHRoaXMub3V0cHV0TmFtZXMpbltwXT1udWxsO2xldCBsPWF3YWl0IHRoaXMuaGFuZGxlci5ydW4odCxuLHMpLG89e307Zm9yKGxldCBwIGluIGwpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobCxwKSl7bGV0IG09bFtwXTttIGluc3RhbmNlb2YgVWU/b1twXT1tOm9bcF09bmV3IFVlKG0udHlwZSxtLmRhdGEsbS5kaW1zKX1yZXR1cm4gb31hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LHIsYSxuKXtsZXQgcyx1PXt9O2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKXtpZihzPXQsdHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKXU9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe2lmKHM9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpdT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcjxcInVcIiYmdCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKXtsZXQgeT10LGc9MCx2PXQuYnl0ZUxlbmd0aDtpZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpdT1yO2Vsc2UgaWYodHlwZW9mIHI9PVwibnVtYmVyXCIpe2lmKGc9ciwhTnVtYmVyLmlzU2FmZUludGVnZXIoZykpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihnPDB8fGc+PXkuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHt5LmJ5dGVMZW5ndGh9KS5gKTtpZih2PXQuYnl0ZUxlbmd0aC1nLHR5cGVvZiBhPT1cIm51bWJlclwiKXtpZih2PWEsIU51bWJlci5pc1NhZmVJbnRlZ2VyKHYpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYodjw9MHx8Zyt2PnkuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHt5LmJ5dGVMZW5ndGgtZ31dLmApO2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbCl1PW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHR5cGVvZiBhPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIil9ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtzPW5ldyBVaW50OEFycmF5KHksZyx2KX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7bGV0IG89KHUuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSkubWFwKHk9PnR5cGVvZiB5PT1cInN0cmluZ1wiP3k6eS5uYW1lKSxtPWF3YWl0KGF3YWl0IE5yKG8pKS5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihzLHUpO3JldHVybiBuZXcgZShtKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX19KTt2YXIgcG8sZm89TCgoKT0+e1widXNlIHN0cmljdFwiO2NvKCk7cG89THJ9KTt2YXIgbW89TCgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIHpsLEhyLGhvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtWcigpO0ZyKCk7emw9XCJUcmFpbmluZyBiYWNrZW5kIGNvdWxkIG5vdCBiZSByZXNvbHZlZC4gTWFrZSBzdXJlIHlvdSdyZSB1c2luZyB0aGUgY29ycmVjdCBjb25maWd1cmF0aW9uICYgV2ViQXNzZW1ibHkgZmlsZXMuXCIsSHI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhhbmRsZXI9dH1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfXN0YXRpYyBhc3luYyBjcmVhdGUodCxyKXtsZXQgYT10LmV2YWxNb2RlbHx8XCJcIixuPXQub3B0aW1pemVyTW9kZWx8fFwiXCIscz1yfHx7fSxsPShzLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10pLm1hcChwPT50eXBlb2YgcD09XCJzdHJpbmdcIj9wOnAubmFtZSksbz1hd2FpdCBOcihsKTtpZihvLmNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIpe2xldCBwPWF3YWl0IG8uY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcih0LmNoZWNrcG9pbnRTdGF0ZSx0LnRyYWluTW9kZWwsYSxuLHMpO3JldHVybiBuZXcgZShwKX1lbHNlIHRocm93IG5ldyBFcnJvcih6bCl9dHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAodCxyLGEpe2xldCBuPXt9LHM9e307aWYodHlwZW9mIHQhPVwib2JqZWN0XCJ8fHQ9PT1udWxsfHx0IGluc3RhbmNlb2YgVWV8fEFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgdT0hMDtpZih0eXBlb2Ygcj09XCJvYmplY3RcIil7aWYocj09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZihyIGluc3RhbmNlb2YgVWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7aWYoQXJyYXkuaXNBcnJheShyKSl7aWYoci5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTt1PSExO2ZvcihsZXQgbCBvZiByKXtpZih0eXBlb2YgbCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtpZih0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobCk9PT0tMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bH0uYCk7bltsXT1udWxsfWlmKHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhIT09bnVsbClzPWE7ZWxzZSBpZih0eXBlb2YgYTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBsPSExLG89T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocik7Zm9yKGxldCBwIG9mIHRoaXMub3V0cHV0TmFtZXMpaWYoby5pbmRleE9mKHApIT09LTEpe2xldCBtPXJbcF07KG09PT1udWxsfHxtIGluc3RhbmNlb2YgVWUpJiYobD0hMCx1PSExLG5bcF09bSl9aWYobCl7aWYodHlwZW9mIGE9PVwib2JqZWN0XCImJmEhPT1udWxsKXM9YTtlbHNlIGlmKHR5cGVvZiBhPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2Ugcz1yfX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO2ZvcihsZXQgbCBvZiB0aGlzLmlucHV0TmFtZXMpaWYodHlwZW9mIHRbbF0+XCJ1XCIpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtsfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO2lmKHUpZm9yKGxldCBsIG9mIHRoaXMub3V0cHV0TmFtZXMpbltsXT1udWxsO3JldHVybltuLHNdfWNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHQpe2xldCByPXt9O2ZvcihsZXQgYSBpbiB0KWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsYSkpe2xldCBuPXRbYV07biBpbnN0YW5jZW9mIFVlP3JbYV09bjpyW2FdPW5ldyBVZShuLnR5cGUsbi5kYXRhLG4uZGltcyl9cmV0dXJuIHJ9YXN5bmMgcnVuVHJhaW5TdGVwKHQscixhKXtsZXRbbixzXT10aGlzLnR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKHQscixhKSx1PWF3YWl0IHRoaXMuaGFuZGxlci5ydW5UcmFpblN0ZXAodCxuLHMpO3JldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHUpfWFzeW5jIGxvYWRQYXJhbWV0ZXJzQnVmZmVyKHQscil7dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIil9YXN5bmMgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModCl7dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIil9YXN5bmMgcmVsZWFzZSgpe3JldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpfX19KTt2YXIgZ28seW89TCgoKT0+e1widXNlIHN0cmljdFwiO2hvKCk7Z289SHJ9KTt2YXIgUm49e307a3QoUm4se0luZmVyZW5jZVNlc3Npb246KCk9PnBvLFRlbnNvcjooKT0+VWUsVHJhaW5pbmdTZXNzaW9uOigpPT5nbyxlbnY6KCk9PkllLHJlZ2lzdGVyQmFja2VuZDooKT0+ZnR9KTt2YXIgJHQ9TCgoKT0+e1widXNlIHN0cmljdFwiO0xhKCk7WWEoKTtmbygpO0ZyKCk7bW8oKTt5bygpfSk7dmFyIFBuPXt9O2t0KFBuLHtyZWFkRmlsZTooKT0+V2x9KTt2YXIgV2wsa249TCgoKT0+e1dsPXZvaWQgMH0pO3ZhciBCbj17fTtrdChCbix7am9pbjooKT0+Tmx9KTt2YXIgTmwsTW49TCgoKT0+e05sPXZvaWQgMH0pO3ZhciAkbz1MdCgodm8sRG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHdvPSgoKT0+e3ZhciBlPXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYoZT1lfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbih0PXt9KXt2YXIgcj10LGEsbjtyLnJlYWR5PW5ldyBQcm9taXNlKChkLGYpPT57YT1kLG49Zn0pLHIuanNlcEluaXQ9KGQsZix3LEMsXyxHLFYsdWUpPT57ci5aYT1kLHIuT2E9ZixyLlFhPXcsci5KYT1DLHIuUGE9XyxyLnJhPUcsci5SYT1WLHIuU2E9dWUsZj0oWSxaLEopPT4oLi4uY2UpPT57bGV0IG1lPVllLEU9Wj8uKCk7Y2U9WSguLi5jZSk7bGV0IHRlPVo/LigpO3JldHVybiBFIT09dGUmJihZPXRlLEooRSksWj1KPW51bGwpLFllIT1tZT9fcigpOmNlfSx3PVk9PmFzeW5jKC4uLlopPT57dHJ5e2lmKHIuRGEpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIGFscmVhZHkgc3RhcnRlZFwiKTtsZXQgSj1yLkRhPXtUYTpaWzBdLGVycm9yczpbXX0sY2U9YXdhaXQgWSguLi5aKTtpZihyLkRhIT09Sil0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7ZC5mbHVzaCgpO2xldCBtZT1KLmVycm9ycztpZigwPG1lLmxlbmd0aCl7bGV0IEU9YXdhaXQgUHJvbWlzZS5hbGwobWUpO2lmKEU9RS5maWx0ZXIodGU9PnRlKSwwPEUubGVuZ3RoKXRocm93IEVycm9yKEUuam9pbihgXG5gKSl9cmV0dXJuIGNlfWZpbmFsbHl7ci5EYT1udWxsfX0sci5fT3J0UnVuPXcoZihyLl9PcnRSdW4sKCk9PnIuX09ydFJ1bixZPT5yLl9PcnRSdW49WSkpLHIuX09ydFJ1bldpdGhCaW5kaW5nPXcoZihyLl9PcnRSdW5XaXRoQmluZGluZywoKT0+ci5fT3J0UnVuV2l0aEJpbmRpbmcsWT0+ci5fT3J0UnVuV2l0aEJpbmRpbmc9WSkpLHIuX09ydEJpbmRJbnB1dD1mKHIuX09ydEJpbmRJbnB1dCwoKT0+ci5fT3J0QmluZElucHV0LFk9PnIuX09ydEJpbmRJbnB1dD1ZKSxyLmpzZXBSZWdpc3RlckJ1ZmZlcj0oWSxaLEosY2UpPT5kLnJlZ2lzdGVyQnVmZmVyKFksWixKLGNlKSxyLmpzZXBVbnJlZ2lzdGVyQnVmZmVycz1ZPT57ZC51bnJlZ2lzdGVyQnVmZmVycyhZKX0sci5qc2VwR2V0QnVmZmVyPVk9PmQuZ2V0QnVmZmVyKFkpLHIuanNlcENyZWF0ZURvd25sb2FkZXI9KFksWixKKT0+ZC5jcmVhdGVEb3dubG9hZGVyKFksWixKKX07dmFyIHM9T2JqZWN0LmFzc2lnbih7fSxyKSx1PVwiLi90aGlzLnByb2dyYW1cIixsPShkLGYpPT57dGhyb3cgZn0sbz10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLHA9dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixtPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIix5PVwiXCIsZyx2LCQ7aWYobSl7dmFyIGI9KGtuKCksdnQoUG4pKSxTPShNbigpLHZ0KEJuKSk7eT1wP1MuZGlybmFtZSh5KStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsZz0oZCxmKT0+KGQ9ZC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGQpOlMubm9ybWFsaXplKGQpLGIucmVhZEZpbGVTeW5jKGQsZj92b2lkIDA6XCJ1dGY4XCIpKSwkPWQ9PihkPWcoZCwhMCksZC5idWZmZXJ8fChkPW5ldyBVaW50OEFycmF5KGQpKSxkKSx2PShkLGYsdyxDPSEwKT0+e2Q9ZC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGQpOlMubm9ybWFsaXplKGQpLGIucmVhZEZpbGUoZCxDP3ZvaWQgMDpcInV0ZjhcIiwoXyxHKT0+e18/dyhfKTpmKEM/Ry5idWZmZXI6Ryl9KX0sIXIudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHU9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxsPShkLGYpPT57dGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1kLGZ9LHIuaW5zcGVjdD0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifWVsc2Uob3x8cCkmJihwP3k9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKHk9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLGUmJih5PWUpLHkuaW5kZXhPZihcImJsb2I6XCIpIT09MD95PXkuc3Vic3RyKDAseS5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTp5PVwiXCIsZz1kPT57dmFyIGY9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBmLm9wZW4oXCJHRVRcIixkLCExKSxmLnNlbmQobnVsbCksZi5yZXNwb25zZVRleHR9LHAmJigkPWQ9Pnt2YXIgZj1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGYub3BlbihcIkdFVFwiLGQsITEpLGYucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixmLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZi5yZXNwb25zZSl9KSx2PShkLGYsdyk9Pnt2YXIgQz1uZXcgWE1MSHR0cFJlcXVlc3Q7Qy5vcGVuKFwiR0VUXCIsZCwhMCksQy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLEMub25sb2FkPSgpPT57Qy5zdGF0dXM9PTIwMHx8Qy5zdGF0dXM9PTAmJkMucmVzcG9uc2U/ZihDLnJlc3BvbnNlKTp3KCl9LEMub25lcnJvcj13LEMuc2VuZChudWxsKX0pO3ZhciBJPXIucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksVD1yLnByaW50RXJyfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihyLHMpLHM9bnVsbCxyLnRoaXNQcm9ncmFtJiYodT1yLnRoaXNQcm9ncmFtKSxyLnF1aXQmJihsPXIucXVpdCk7dmFyIEI7ci53YXNtQmluYXJ5JiYoQj1yLndhc21CaW5hcnkpO3ZhciBQPXIubm9FeGl0UnVudGltZXx8ITA7dHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZxZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIEQsUixXPSExLEgsSyxsZSxNLHEseGUsb2U7ZnVuY3Rpb24gd2UoKXt2YXIgZD1ELmJ1ZmZlcjtyLkhFQVA4PUs9bmV3IEludDhBcnJheShkKSxyLkhFQVAxNj1uZXcgSW50MTZBcnJheShkKSxyLkhFQVAzMj1NPW5ldyBJbnQzMkFycmF5KGQpLHIuSEVBUFU4PWxlPW5ldyBVaW50OEFycmF5KGQpLHIuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoZCksci5IRUFQVTMyPXE9bmV3IFVpbnQzMkFycmF5KGQpLHIuSEVBUEYzMj14ZT1uZXcgRmxvYXQzMkFycmF5KGQpLHIuSEVBUEY2ND1vZT1uZXcgRmxvYXQ2NEFycmF5KGQpfXZhciBqPVtdLFNlPVtdLFRlPVtdO2Z1bmN0aW9uIEVlKCl7dmFyIGQ9ci5wcmVSdW4uc2hpZnQoKTtqLnVuc2hpZnQoZCl9dmFyIENlPTAsZ3Q9bnVsbCxMZT1udWxsO2Z1bmN0aW9uIHFlKGQpe3Rocm93IHIub25BYm9ydCYmci5vbkFib3J0KGQpLGQ9XCJBYm9ydGVkKFwiK2QrXCIpXCIsVChkKSxXPSEwLEg9MSxkPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbihkKSxkfWZ1bmN0aW9uIFUoZCl7cmV0dXJuIGQuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9dmFyIGRlO2lmKGRlPVwib3J0LXdhc20tc2ltZC53YXNtXCIsIVUoZGUpKXt2YXIgcGU9ZGU7ZGU9ci5sb2NhdGVGaWxlP3IubG9jYXRlRmlsZShwZSx5KTp5K3BlfWZ1bmN0aW9uIE5lKGQpe2lmKGQ9PWRlJiZCKXJldHVybiBuZXcgVWludDhBcnJheShCKTtpZigkKXJldHVybiAkKGQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIEhlKGQpe2lmKCFCJiYob3x8cCkpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYhZC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goZCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihmPT57aWYoIWYub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2QrXCInXCI7cmV0dXJuIGYuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5OZShkKSk7aWYodilyZXR1cm4gbmV3IFByb21pc2UoKGYsdyk9Pnt2KGQsQz0+ZihuZXcgVWludDhBcnJheShDKSksdyl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+TmUoZCkpfWZ1bmN0aW9uIE9lKGQsZix3KXtyZXR1cm4gSGUoZCkudGhlbihDPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShDLGYpKS50aGVuKEM9PkMpLnRoZW4odyxDPT57VChcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK0MpLHFlKEMpfSl9ZnVuY3Rpb24gemUoZCxmKXt2YXIgdz1kZTtyZXR1cm4gQnx8dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT1cImZ1bmN0aW9uXCJ8fFUodyl8fHcuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fG18fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP09lKHcsZCxmKTpmZXRjaCh3LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKEM9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEMsZCkudGhlbihmLGZ1bmN0aW9uKF8pe3JldHVybiBUKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK18pLFQoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxPZSh3LGQsZil9KSl9dmFyIEdlLGV0PXs5MTM3OTI6ZD0+e3IucmEoXCJBYnNcIixkLHZvaWQgMCl9LDkxMzg0MzpkPT57ci5yYShcIk5lZ1wiLGQsdm9pZCAwKX0sOTEzODk0OmQ9PntyLnJhKFwiRmxvb3JcIixkLHZvaWQgMCl9LDkxMzk0NzpkPT57ci5yYShcIkNlaWxcIixkLHZvaWQgMCl9LDkxMzk5OTpkPT57ci5yYShcIlJlY2lwcm9jYWxcIixkLHZvaWQgMCl9LDkxNDA1NzpkPT57ci5yYShcIlNxcnRcIixkLHZvaWQgMCl9LDkxNDEwOTpkPT57ci5yYShcIkV4cFwiLGQsdm9pZCAwKX0sOTE0MTYwOmQ9PntyLnJhKFwiRXJmXCIsZCx2b2lkIDApfSw5MTQyMTE6ZD0+e3IucmEoXCJTaWdtb2lkXCIsZCx2b2lkIDApfSw5MTQyNjY6ZD0+e3IucmEoXCJMb2dcIixkLHZvaWQgMCl9LDkxNDMxNzpkPT57ci5yYShcIlNpblwiLGQsdm9pZCAwKX0sOTE0MzY4OmQ9PntyLnJhKFwiQ29zXCIsZCx2b2lkIDApfSw5MTQ0MTk6ZD0+e3IucmEoXCJUYW5cIixkLHZvaWQgMCl9LDkxNDQ3MDpkPT57ci5yYShcIkFzaW5cIixkLHZvaWQgMCl9LDkxNDUyMjpkPT57ci5yYShcIkFjb3NcIixkLHZvaWQgMCl9LDkxNDU3NDpkPT57ci5yYShcIkF0YW5cIixkLHZvaWQgMCl9LDkxNDYyNjpkPT57ci5yYShcIlNpbmhcIixkLHZvaWQgMCl9LDkxNDY3ODpkPT57ci5yYShcIkNvc2hcIixkLHZvaWQgMCl9LDkxNDczMDpkPT57ci5yYShcIkFzaW5oXCIsZCx2b2lkIDApfSw5MTQ3ODM6ZD0+e3IucmEoXCJBY29zaFwiLGQsdm9pZCAwKX0sOTE0ODM2OmQ9PntyLnJhKFwiQXRhbmhcIixkLHZvaWQgMCl9LDkxNDg4OTpkPT57ci5yYShcIlRhbmhcIixkLHZvaWQgMCl9LDkxNDk0MTpkPT57ci5yYShcIk5vdFwiLGQsdm9pZCAwKX0sOTE0OTkyOihkLGYsdyk9PntyLnJhKFwiQ2xpcFYxMFwiLGQse21pbjpmLG1heDp3fSl9LDkxNTA2NDpkPT57ci5yYShcIkNsaXBcIixkLHZvaWQgMCl9LDkxNTExNjooZCxmKT0+e3IucmEoXCJFbHVcIixkLHthbHBoYTpmfSl9LDkxNTE3NDpkPT57ci5yYShcIlJlbHVcIixkLHZvaWQgMCl9LDkxNTIyNjooZCxmKT0+e3IucmEoXCJMZWFreVJlbHVcIixkLHthbHBoYTpmfSl9LDkxNTI5MDooZCxmKT0+e3IucmEoXCJUaHJlc2hvbGRlZFJlbHVcIixkLHthbHBoYTpmfSl9LDkxNTM2MDooZCxmKT0+e3IucmEoXCJDYXN0XCIsZCx7dG86Zn0pfSw5MTU0MTg6ZD0+e3IucmEoXCJBZGRcIixkLHZvaWQgMCl9LDkxNTQ2OTpkPT57ci5yYShcIlN1YlwiLGQsdm9pZCAwKX0sOTE1NTIwOmQ9PntyLnJhKFwiTXVsXCIsZCx2b2lkIDApfSw5MTU1NzE6ZD0+e3IucmEoXCJEaXZcIixkLHZvaWQgMCl9LDkxNTYyMjpkPT57ci5yYShcIlBvd1wiLGQsdm9pZCAwKX0sOTE1NjczOmQ9PntyLnJhKFwiRXF1YWxcIixkLHZvaWQgMCl9LDkxNTcyNjpkPT57ci5yYShcIkdyZWF0ZXJcIixkLHZvaWQgMCl9LDkxNTc4MTpkPT57ci5yYShcIkdyZWF0ZXJPckVxdWFsXCIsZCx2b2lkIDApfSw5MTU4NDM6ZD0+e3IucmEoXCJMZXNzXCIsZCx2b2lkIDApfSw5MTU4OTU6ZD0+e3IucmEoXCJMZXNzT3JFcXVhbFwiLGQsdm9pZCAwKX0sOTE1OTU0OihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZU1lYW5cIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNjExODooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VNYXhcIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNjI4MTooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VNaW5cIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNjQ0NDooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VQcm9kXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTY2MDg6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlU3VtXCIsZCx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEhdyxheGVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MTY3NzE6KGQsZix3LEMsXyk9PntyLnJhKFwiUmVkdWNlTDFcIixkLHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF3LGF4ZXM6Qz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXytDPj4+MCkpOltdfSl9LDkxNjkzMzooZCxmLHcsQyxfKT0+e3IucmEoXCJSZWR1Y2VMMlwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE3MDk1OihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZUxvZ1N1bVwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE3MjYxOihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZVN1bVNxdWFyZVwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE3NDMwOihkLGYsdyxDLF8pPT57ci5yYShcIlJlZHVjZUxvZ1N1bUV4cFwiLGQse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXcsYXhlczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W119KX0sOTE3NTk5OmQ9PntyLnJhKFwiV2hlcmVcIixkLHZvaWQgMCl9LDkxNzY1MjooZCxmLHcpPT57ci5yYShcIlRyYW5zcG9zZVwiLGQse3Blcm06Zj9BcnJheS5mcm9tKE0uc3ViYXJyYXkodz4+PjAsdytmPj4+MCkpOltdfSl9LDkxNzc2NTooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFLHRlKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsZCx7Zm9ybWF0Olk/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpmLGRpbGF0aW9uczpbd10sZ3JvdXA6QyxrZXJuZWxfc2hhcGU6W19dLHBhZHM6W0csVl0sc3RyaWRlczpbdWVdLHdJc0NvbnN0OigpPT4hIUtbWj4+PjBdLG91dHB1dFBhZGRpbmc6Sj9BcnJheS5mcm9tKE0uc3ViYXJyYXkoY2U+Pj4wLGNlK0o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6bWU/QXJyYXkuZnJvbShNLnN1YmFycmF5KEU+Pj4wLEUrbWU+Pj4wKSk6W10sYWN0aXZhdGlvbjpSZSh0ZSl9KX0sOTE4MTc5OihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixkLHtmb3JtYXQ6dWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpmLGRpbGF0aW9uczpBcnJheS5mcm9tKE0uc3ViYXJyYXkodz4+PjAsdysyPj4+MCkpLGdyb3VwOkMsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rMj4+PjApKSxwYWRzOkFycmF5LmZyb20oTS5zdWJhcnJheShHPj4+MCxHKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKE0uc3ViYXJyYXkoVj4+PjAsVisyPj4+MCkpLHdJc0NvbnN0OigpPT4hIUtbWT4+PjBdLG91dHB1dFBhZGRpbmc6MDxaP0FycmF5LmZyb20oTS5zdWJhcnJheShKPj4+MCxKK1o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxjZT9BcnJheS5mcm9tKE0uc3ViYXJyYXkobWU+Pj4wLG1lK2NlPj4+MCkpOltdLGFjdGl2YXRpb246UmUoRSl9KX0sOTE4NzM2OihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUsdGUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixkLHtmb3JtYXQ6WT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmYsZGlsYXRpb25zOlt3XSxncm91cDpDLGtlcm5lbF9zaGFwZTpbX10scGFkczpbRyxWXSxzdHJpZGVzOlt1ZV0sd0lzQ29uc3Q6KCk9PiEhS1taPj4+MF0sb3V0cHV0UGFkZGluZzpKP0FycmF5LmZyb20oTS5zdWJhcnJheShjZT4+PjAsY2UrSj4+PjApKTpbXSxvdXRwdXRTaGFwZTptZT9BcnJheS5mcm9tKE0uc3ViYXJyYXkoRT4+PjAsRSttZT4+PjApKTpbXSxhY3RpdmF0aW9uOlJlKHRlKX0pfSw5MTkxNTA6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGQse2Zvcm1hdDp1ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmYsZGlsYXRpb25zOkFycmF5LmZyb20oTS5zdWJhcnJheSh3Pj4+MCx3KzI+Pj4wKSksZ3JvdXA6QyxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKE0uc3ViYXJyYXkoXz4+PjAsXysyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShNLnN1YmFycmF5KEc+Pj4wLEcrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oTS5zdWJhcnJheShWPj4+MCxWKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhS1tZPj4+MF0sb3V0cHV0UGFkZGluZzowPFo/QXJyYXkuZnJvbShNLnN1YmFycmF5KEo+Pj4wLEorWj4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGNlP0FycmF5LmZyb20oTS5zdWJhcnJheShtZT4+PjAsbWUrY2U+Pj4wKSk6W10sYWN0aXZhdGlvbjpSZShFKX0pfSw5MTk3MDc6KGQsZik9PntyLnJhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixkLHtmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MTk3OTg6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiQXZlcmFnZVBvb2xcIixkLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZixjZWlsX21vZGU6dyxjb3VudF9pbmNsdWRlX3BhZDpDLHN0b3JhZ2Vfb3JkZXI6XyxkaWxhdGlvbnM6W0csVl0sa2VybmVsX3NoYXBlOlt1ZSxZXSxwYWRzOltaLEosY2UsbWVdLHN0cmlkZXM6W0UsdGVdfSl9LDkyMDA4MjooZCxmKT0+e3IucmEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGQse2Zvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDE3MzooZCxmLHcsQyxfLEcsVix1ZSxZLFosSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJBdmVyYWdlUG9vbFwiLGQse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGNlaWxfbW9kZTp3LGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpfLGRpbGF0aW9uczpbRyxWXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1osSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIwNDU3OihkLGYpPT57ci5yYShcIkdsb2JhbE1heFBvb2xcIixkLHtmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjA1NDQ6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiTWF4UG9vbFwiLGQse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGNlaWxfbW9kZTp3LGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpfLGRpbGF0aW9uczpbRyxWXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1osSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIwODI0OihkLGYpPT57ci5yYShcIkdsb2JhbE1heFBvb2xcIixkLHtmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjA5MTE6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiTWF4UG9vbFwiLGQse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGNlaWxfbW9kZTp3LGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpfLGRpbGF0aW9uczpbRyxWXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1osSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIxMTkxOihkLGYsdyxDLF8pPT57ci5yYShcIkdlbW1cIixkLHthbHBoYTpmLGJldGE6dyx0cmFuc0E6Qyx0cmFuc0I6X30pfSw5MjEyOTU6ZD0+e3IucmEoXCJNYXRNdWxcIixkLHZvaWQgMCl9LDkyMTM0OTooZCxmLHcsQyk9PntyLnJhKFwiQXJnTWF4XCIsZCx7a2VlcERpbXM6ISFmLHNlbGVjdExhc3RJbmRleDohIXcsYXhpczpDfSl9LDkyMTQ1NzooZCxmLHcsQyk9PntyLnJhKFwiQXJnTWluXCIsZCx7a2VlcERpbXM6ISFmLHNlbGVjdExhc3RJbmRleDohIXcsYXhpczpDfSl9LDkyMTU2NTooZCxmKT0+e3IucmEoXCJTb2Z0bWF4XCIsZCx7YXhpczpmfSl9LDkyMTYyODooZCxmKT0+e3IucmEoXCJDb25jYXRcIixkLHtheGlzOmZ9KX0sOTIxNjg4OihkLGYsdyxDLF8pPT57ci5yYShcIlNwbGl0XCIsZCx7YXhpczpmLG51bU91dHB1dHM6dyxzcGxpdFNpemVzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MjE4MzM6ZD0+e3IucmEoXCJFeHBhbmRcIixkLHZvaWQgMCl9LDkyMTg4NzooZCxmKT0+e3IucmEoXCJHYXRoZXJcIixkLHtheGlzOk51bWJlcihmKX0pfSw5MjE5NTg6KGQsZik9PntyLnJhKFwiR2F0aGVyRWxlbWVudHNcIixkLHtheGlzOk51bWJlcihmKX0pfSw5MjIwMzc6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEopPT57ci5yYShcIlJlc2l6ZVwiLGQse2FudGlhbGlhczpmLGF4ZXM6dz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoQz4+PjAsQyt3Pj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOlJlKF8pLGN1YmljQ29lZmZBOkcsZXhjbHVkZU91dHNpZGU6VixleHRyYXBvbGF0aW9uVmFsdWU6dWUsa2VlcEFzcGVjdFJhdGlvUG9saWN5OlJlKFkpLG1vZGU6UmUoWiksbmVhcmVzdE1vZGU6UmUoSil9KX0sOTIyMzg4OihkLGYsdyxDLF8sRyxWKT0+e3IucmEoXCJTbGljZVwiLGQse3N0YXJ0czpmP0FycmF5LmZyb20oTS5zdWJhcnJheSh3Pj4+MCx3K2Y+Pj4wKSk6W10sZW5kczpDP0FycmF5LmZyb20oTS5zdWJhcnJheShfPj4+MCxfK0M+Pj4wKSk6W10sYXhlczpHP0FycmF5LmZyb20oTS5zdWJhcnJheShWPj4+MCxWK0c+Pj4wKSk6W119KX0sOTIyNjE5OmQ9PntyLnJhKFwiVGlsZVwiLGQsdm9pZCAwKX0sOTIyNjcxOihkLGYsdyk9PntyLnJhKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsZCx7YXhpczpOdW1iZXIoZiksZXBzaWxvbjpOdW1iZXIodyl9KX0sOTIyNzc4OihkLGYsdyk9PntyLnJhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsZCx7ZXBzaWxvbjpmLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMjg5MjooZCxmLHcpPT57ci5yYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGQse2Vwc2lsb246Zixmb3JtYXQ6dz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjMwMDY6ZD0+e3IucmEoXCJSYW5nZVwiLGQsdm9pZCAwKX0sOTIzMDU5OihkLGYpPT57ci5yYShcIkVpbnN1bVwiLGQse2VxdWF0aW9uOlJlKGYpfSl9LDkyMzE0MDooZCxmLHcsQyxfKT0+e3IucmEoXCJQYWRcIixkLHttb2RlOmYsdmFsdWU6dyxwYWRzOkM/QXJyYXkuZnJvbShNLnN1YmFycmF5KF8+Pj4wLF8rQz4+PjApKTpbXX0pfSw5MjMyNzI6ZD0+e3IucmEoXCJHZWx1XCIsZCx2b2lkIDApfSw5MjMzMjQ6ZD0+e3IucmEoXCJCaWFzQWRkXCIsZCx2b2lkIDApfSw5MjMzNzk6ZD0+e3IucmEoXCJCaWFzU3BsaXRHZWx1XCIsZCx2b2lkIDApfSw5MjM0NDA6KGQsZik9PntyLnJhKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLGQse2Vwc2lsb246Zn0pfSw5MjM1MjE6KGQsZix3LEMsXyxHLFYsdWUsWSxaLEosY2UsbWUpPT57ci5yYShcIkNvbnZcIixkLHtmb3JtYXQ6WT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGRpbGF0aW9uczpbd10sZ3JvdXA6QyxrZXJuZWxfc2hhcGU6W19dLHBhZHM6Rz9BcnJheS5mcm9tKE0uc3ViYXJyYXkoVj4+PjAsVitHPj4+MCkpOltdLHN0cmlkZXM6W3VlXSx3X2lzX2NvbnN0OigpPT4hIUtbWj4+PjBdLGFjdGl2YXRpb246UmUoSiksYWN0aXZhdGlvbl9wYXJhbXM6Y2U/QXJyYXkuZnJvbSh4ZS5zdWJhcnJheShtZT4+PjAsbWUrY2U+Pj4wKSk6W119KX0sOTIzOTAyOihkLGYsdyxDLF8sRyxWLHVlLFksWixKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIkNvbnZcIixkLHtmb3JtYXQ6Y2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZixkaWxhdGlvbnM6W3csQ10sZ3JvdXA6XyxrZXJuZWxfc2hhcGU6W0csVl0scGFkczp1ZT9BcnJheS5mcm9tKE0uc3ViYXJyYXkoWT4+PjAsWSt1ZT4+PjApKTpbXSxzdHJpZGVzOltaLEpdLHdfaXNfY29uc3Q6KCk9PiEhS1ttZT4+PjBdLGFjdGl2YXRpb246UmUoRSksYWN0aXZhdGlvbl9wYXJhbXM6dGU/QXJyYXkuZnJvbSh4ZS5zdWJhcnJheShmZT4+PjAsZmUrdGU+Pj4wKSk6W119KX0sOTI0MzA0OmQ9PntyLlJhKGQpfSw5MjQzMzg6KGQsZik9PnIuU2EoZCxmLHIuRGEuVGEsci5EYS5lcnJvcnMpLDkyNDQ1MDpkPT5yLk9hKGQpLDkyNDQ4MzpkPT5yLlFhKGQpLDkyNDUxNTooZCxmLHcpPT57ci5KYShkLGYsdywhMCl9LDkyNDU1NDooZCxmLHcpPT57ci5KYShkLGYsdyl9fTtmdW5jdGlvbiBLZShkKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7ZH0pYCx0aGlzLnN0YXR1cz1kfXZhciBBdD1kPT57Zm9yKDswPGQubGVuZ3RoOylkLnNoaWZ0KCkocil9O2Z1bmN0aW9uIEV0KGQpe3RoaXMuSGE9ZC0yNCx0aGlzLk1hPWZ1bmN0aW9uKGYpe3FbdGhpcy5IYSs0Pj4yPj4+MF09Zn0sdGhpcy5MYT1mdW5jdGlvbihmKXtxW3RoaXMuSGErOD4+Mj4+PjBdPWZ9LHRoaXMuWWE9ZnVuY3Rpb24oZix3KXt0aGlzLkthKCksdGhpcy5NYShmKSx0aGlzLkxhKHcpfSx0aGlzLkthPWZ1bmN0aW9uKCl7cVt0aGlzLkhhKzE2Pj4yPj4+MF09MH19dmFyIGp0PTAsJHI9MCxKZT10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAscXQ9KGQsZix3KT0+e2Y+Pj49MDt2YXIgQz1mK3c7Zm9yKHc9ZjtkW3ddJiYhKHc+PUMpOykrK3c7aWYoMTY8dy1mJiZkLmJ1ZmZlciYmSmUpcmV0dXJuIEplLmRlY29kZShkLnN1YmFycmF5KGYsdykpO2ZvcihDPVwiXCI7Zjx3Oyl7dmFyIF89ZFtmKytdO2lmKF8mMTI4KXt2YXIgRz1kW2YrK10mNjM7aWYoKF8mMjI0KT09MTkyKUMrPVN0cmluZy5mcm9tQ2hhckNvZGUoKF8mMzEpPDw2fEcpO2Vsc2V7dmFyIFY9ZFtmKytdJjYzO189KF8mMjQwKT09MjI0PyhfJjE1KTw8MTJ8Rzw8NnxWOihfJjcpPDwxOHxHPDwxMnxWPDw2fGRbZisrXSY2Myw2NTUzNj5fP0MrPVN0cmluZy5mcm9tQ2hhckNvZGUoXyk6KF8tPTY1NTM2LEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Xz4+MTAsNTYzMjB8XyYxMDIzKSl9fWVsc2UgQys9U3RyaW5nLmZyb21DaGFyQ29kZShfKX1yZXR1cm4gQ30sUmU9KGQsZik9PihkPj4+PTApP3F0KGxlLGQsZik6XCJcIix6dD1kPT57Zm9yKHZhciBmPTAsdz0wO3c8ZC5sZW5ndGg7Kyt3KXt2YXIgQz1kLmNoYXJDb2RlQXQodyk7MTI3Pj1DP2YrKzoyMDQ3Pj1DP2YrPTI6NTUyOTY8PUMmJjU3MzQzPj1DPyhmKz00LCsrdyk6Zis9M31yZXR1cm4gZn0sS3Q9KGQsZix3LEMpPT57aWYodz4+Pj0wLCEoMDxDKSlyZXR1cm4gMDt2YXIgXz13O0M9dytDLTE7Zm9yKHZhciBHPTA7RzxkLmxlbmd0aDsrK0cpe3ZhciBWPWQuY2hhckNvZGVBdChHKTtpZig1NTI5Njw9ViYmNTczNDM+PVYpe3ZhciB1ZT1kLmNoYXJDb2RlQXQoKytHKTtWPTY1NTM2KygoViYxMDIzKTw8MTApfHVlJjEwMjN9aWYoMTI3Pj1WKXtpZih3Pj1DKWJyZWFrO2ZbdysrPj4+MF09Vn1lbHNle2lmKDIwNDc+PVYpe2lmKHcrMT49QylicmVhaztmW3crKz4+PjBdPTE5MnxWPj42fWVsc2V7aWYoNjU1MzU+PVYpe2lmKHcrMj49QylicmVhaztmW3crKz4+PjBdPTIyNHxWPj4xMn1lbHNle2lmKHcrMz49QylicmVhaztmW3crKz4+PjBdPTI0MHxWPj4xOCxmW3crKz4+PjBdPTEyOHxWPj4xMiY2M31mW3crKz4+PjBdPTEyOHxWPj42JjYzfWZbdysrPj4+MF09MTI4fFYmNjN9fXJldHVybiBmW3c+Pj4wXT0wLHctX30sbHQ9ZD0+ZCU0PT09MCYmKGQlMTAwIT09MHx8ZCU0MDA9PT0wKSx4cj1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxkdD1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XSxXdD1kPT57dmFyIGY9enQoZCkrMSx3PUd0KGYpO3JldHVybiB3JiZLdChkLGxlLHcsZiksd30seXQ9W10sTnQ9KGQsZik9Pnt5dC5sZW5ndGg9MDt2YXIgdztmb3IoZj4+PTI7dz1sZVtkKys+Pj4wXTspZis9dyE9MTA1JmYseXQucHVzaCh3PT0xMDU/TVtmPj4+MF06b2VbZisrPj4+MV0pLCsrZjtyZXR1cm4geXR9LFZ0PXt9LFl0PSgpPT57aWYoIVV0KXt2YXIgZD17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzp1fHxcIi4vdGhpcy5wcm9ncmFtXCJ9LGY7Zm9yKGYgaW4gVnQpVnRbZl09PT12b2lkIDA/ZGVsZXRlIGRbZl06ZFtmXT1WdFtmXTt2YXIgdz1bXTtmb3IoZiBpbiBkKXcucHVzaChgJHtmfT0ke2RbZl19YCk7VXQ9d31yZXR1cm4gVXR9LFV0LFNyPVtudWxsLFtdLFtdXSxWZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLFh0PVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gSnQoZCl7dmFyIGY9QXJyYXkoenQoZCkrMSk7cmV0dXJuIEt0KGQsZiwwLGYubGVuZ3RoKSxmfWZ1bmN0aW9uIG5lKGQsZix3LEMpe2Z1bmN0aW9uIF8oRSx0ZSxmZSl7Zm9yKEU9dHlwZW9mIEU9PVwibnVtYmVyXCI/RS50b1N0cmluZygpOkV8fFwiXCI7RS5sZW5ndGg8dGU7KUU9ZmVbMF0rRTtyZXR1cm4gRX1mdW5jdGlvbiBHKEUsdGUpe3JldHVybiBfKEUsdGUsXCIwXCIpfWZ1bmN0aW9uIFYoRSx0ZSl7ZnVuY3Rpb24gZmUodXIpe3JldHVybiAwPnVyPy0xOjA8dXI/MTowfXZhciBwdDtyZXR1cm4ocHQ9ZmUoRS5nZXRGdWxsWWVhcigpLXRlLmdldEZ1bGxZZWFyKCkpKT09PTAmJihwdD1mZShFLmdldE1vbnRoKCktdGUuZ2V0TW9udGgoKSkpPT09MCYmKHB0PWZlKEUuZ2V0RGF0ZSgpLXRlLmdldERhdGUoKSkpLHB0fWZ1bmN0aW9uIHVlKEUpe3N3aXRjaChFLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIEU7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIFkoRSl7dmFyIHRlPUUuQmE7Zm9yKEU9bmV3IERhdGUobmV3IERhdGUoRS5DYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHRlOyl7dmFyIGZlPUUuZ2V0TW9udGgoKSxwdD0obHQoRS5nZXRGdWxsWWVhcigpKT9WZTpYdClbZmVdO2lmKHRlPnB0LUUuZ2V0RGF0ZSgpKXRlLT1wdC1FLmdldERhdGUoKSsxLEUuc2V0RGF0ZSgxKSwxMT5mZT9FLnNldE1vbnRoKGZlKzEpOihFLnNldE1vbnRoKDApLEUuc2V0RnVsbFllYXIoRS5nZXRGdWxsWWVhcigpKzEpKTtlbHNle0Uuc2V0RGF0ZShFLmdldERhdGUoKSt0ZSk7YnJlYWt9fXJldHVybiBmZT1uZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHRlPXVlKG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDQpKSxmZT11ZShmZSksMD49Vih0ZSxFKT8wPj1WKGZlLEUpP0UuZ2V0RnVsbFllYXIoKSsxOkUuZ2V0RnVsbFllYXIoKTpFLmdldEZ1bGxZZWFyKCktMX1kPj4+PTAsZj4+Pj0wLHc+Pj49MCxDPj4+PTA7dmFyIFo9TVtDKzQwPj4yPj4+MF07Qz17V2E6TVtDPj4yPj4+MF0sVmE6TVtDKzQ+PjI+Pj4wXSxFYTpNW0MrOD4+Mj4+PjBdLElhOk1bQysxMj4+Mj4+PjBdLEZhOk1bQysxNj4+Mj4+PjBdLENhOk1bQysyMD4+Mj4+PjBdLHdhOk1bQysyND4+Mj4+PjBdLEJhOk1bQysyOD4+Mj4+PjBdLCRhOk1bQyszMj4+Mj4+PjBdLFVhOk1bQyszNj4+Mj4+PjBdLFhhOlo/UmUoWik6XCJcIn0sdz1SZSh3KSxaPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciBKIGluIFopdz13LnJlcGxhY2UobmV3IFJlZ0V4cChKLFwiZ1wiKSxaW0pdKTt2YXIgY2U9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxtZT1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Wj17XCIlYVwiOkU9PmNlW0Uud2FdLnN1YnN0cmluZygwLDMpLFwiJUFcIjpFPT5jZVtFLndhXSxcIiViXCI6RT0+bWVbRS5GYV0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOkU9Pm1lW0UuRmFdLFwiJUNcIjpFPT5HKChFLkNhKzE5MDApLzEwMHwwLDIpLFwiJWRcIjpFPT5HKEUuSWEsMiksXCIlZVwiOkU9Pl8oRS5JYSwyLFwiIFwiKSxcIiVnXCI6RT0+WShFKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6RT0+WShFKSxcIiVIXCI6RT0+RyhFLkVhLDIpLFwiJUlcIjpFPT4oRT1FLkVhLEU9PTA/RT0xMjoxMjxFJiYoRS09MTIpLEcoRSwyKSksXCIlalwiOkU9Pntmb3IodmFyIHRlPTAsZmU9MDtmZTw9RS5GYS0xO3RlKz0obHQoRS5DYSsxOTAwKT9WZTpYdClbZmUrK10pO3JldHVybiBHKEUuSWErdGUsMyl9LFwiJW1cIjpFPT5HKEUuRmErMSwyKSxcIiVNXCI6RT0+RyhFLlZhLDIpLFwiJW5cIjooKT0+YFxuYCxcIiVwXCI6RT0+MDw9RS5FYSYmMTI+RS5FYT9cIkFNXCI6XCJQTVwiLFwiJVNcIjpFPT5HKEUuV2EsMiksXCIldFwiOigpPT5cIlx0XCIsXCIldVwiOkU9PkUud2F8fDcsXCIlVVwiOkU9PkcoTWF0aC5mbG9vcigoRS5CYSs3LUUud2EpLzcpLDIpLFwiJVZcIjpFPT57dmFyIHRlPU1hdGguZmxvb3IoKEUuQmErNy0oRS53YSs2KSU3KS83KTtpZigyPj0oRS53YSszNzEtRS5CYS0yKSU3JiZ0ZSsrLHRlKXRlPT01MyYmKGZlPShFLndhKzM3MS1FLkJhKSU3LGZlPT00fHxmZT09MyYmbHQoRS5DYSl8fCh0ZT0xKSk7ZWxzZXt0ZT01Mjt2YXIgZmU9KEUud2ErNy1FLkJhLTEpJTc7KGZlPT00fHxmZT09NSYmbHQoRS5DYSU0MDAtMSkpJiZ0ZSsrfXJldHVybiBHKHRlLDIpfSxcIiV3XCI6RT0+RS53YSxcIiVXXCI6RT0+RyhNYXRoLmZsb29yKChFLkJhKzctKEUud2ErNiklNykvNyksMiksXCIleVwiOkU9PihFLkNhKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjpFPT5FLkNhKzE5MDAsXCIlelwiOkU9PntFPUUuVWE7dmFyIHRlPTA8PUU7cmV0dXJuIEU9TWF0aC5hYnMoRSkvNjAsKHRlP1wiK1wiOlwiLVwiKSsoXCIwMDAwXCIrKEUvNjAqMTAwK0UlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpFPT5FLlhhLFwiJSVcIjooKT0+XCIlXCJ9LHc9dy5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpO2ZvcihKIGluIFopdy5pbmNsdWRlcyhKKSYmKHc9dy5yZXBsYWNlKG5ldyBSZWdFeHAoSixcImdcIiksWltKXShDKSkpO3JldHVybiB3PXcucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpLEo9SnQodyksSi5sZW5ndGg+Zj8wOihLLnNldChKLGQ+Pj4wKSxKLmxlbmd0aC0xKX1mdW5jdGlvbiBjdChkKXt0cnl7ZCgpfWNhdGNoKGYpe3FlKGYpfX1mdW5jdGlvbiBDcihkKXt2YXIgZj17fSx3O2Zvcih3IGluIGQpKGZ1bmN0aW9uKEMpe3ZhciBfPWRbQ107ZltDXT10eXBlb2YgXz09XCJmdW5jdGlvblwiP2Z1bmN0aW9uKCl7X3QucHVzaChDKTt0cnl7cmV0dXJuIF8uYXBwbHkobnVsbCxhcmd1bWVudHMpfWZpbmFsbHl7V3x8KF90LnBvcCgpPT09Q3x8cWUoKSxZZSYmdHQ9PT0xJiZfdC5sZW5ndGg9PT0wJiYodHQ9MCxjdChpciksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLmFiKCkpKX19Ol99KSh3KTtyZXR1cm4gZn12YXIgdHQ9MCxZZT1udWxsLElyPTAsX3Q9W10sUXQ9e30sWnQ9e30sQXI9MCxPdD1udWxsLEVyPVtdO2Z1bmN0aW9uIF9yKCl7cmV0dXJuIG5ldyBQcm9taXNlKChkLGYpPT57T3Q9e3Jlc29sdmU6ZCxyZWplY3Q6Zn19KX1mdW5jdGlvbiBPcigpe3ZhciBkPUd0KDY1NTQ4KSxmPWQrMTI7cVtkPj4yPj4+MF09ZixxW2QrND4+Mj4+PjBdPWYrNjU1MzYsZj1fdFswXTt2YXIgdz1RdFtmXTtyZXR1cm4gdz09PXZvaWQgMCYmKHc9QXIrKyxRdFtmXT13LFp0W3ddPWYpLE1bZCs4Pj4yPj4+MF09dyxkfWZ1bmN0aW9uIFRyKGQpe2lmKCFXKXtpZih0dD09PTApe3ZhciBmPSExLHc9ITE7ZCgoQz0wKT0+e2lmKCFXJiYoSXI9QyxmPSEwLHcpKXt0dD0yLGN0KCgpPT5GdChZZSkpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkdhLk5hJiZCcm93c2VyLkdhLnJlc3VtZSgpLEM9ITE7dHJ5e3ZhciBfPSgwLFJbWnRbTVtZZSs4Pj4yPj4+MF1dXSkoKX1jYXRjaCh1ZSl7Xz11ZSxDPSEwfXZhciBHPSExO2lmKCFZZSl7dmFyIFY9T3Q7ViYmKE90PW51bGwsKEM/Vi5yZWplY3Q6Vi5yZXNvbHZlKShfKSxHPSEwKX1pZihDJiYhRyl0aHJvdyBffX0pLHc9ITAsZnx8KHR0PTEsWWU9T3IoKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5HYS5OYSYmQnJvd3Nlci5HYS5wYXVzZSgpLGN0KCgpPT5vcihZZSkpKX1lbHNlIHR0PT09Mj8odHQ9MCxjdChUdCksZXIoWWUpLFllPW51bGwsRXIuZm9yRWFjaChDPT57aWYoIVcpdHJ5e2lmKEMoKSwhUCl0cnl7SD1IPUM9SCxQfHwoci5vbkV4aXQmJnIub25FeGl0KEMpLFc9ITApLGwoQyxuZXcgS2UoQykpfWNhdGNoKF8pe18gaW5zdGFuY2VvZiBLZXx8Xz09XCJ1bndpbmRcInx8bCgxLF8pfX1jYXRjaChfKXtfIGluc3RhbmNlb2YgS2V8fF89PVwidW53aW5kXCJ8fGwoMSxfKX19KSk6cWUoYGludmFsaWQgc3RhdGU6ICR7dHR9YCk7cmV0dXJuIElyfX1mdW5jdGlvbiBScihkKXtyZXR1cm4gVHIoZj0+e2QoKS50aGVuKGYpfSl9dmFyIFByPXtuOmZ1bmN0aW9uKGQsZix3KXtyZXR1cm4gUnIoYXN5bmMoKT0+e2F3YWl0IHIuUGEoZCxmLHcpfSl9LGE6ZnVuY3Rpb24oZCxmLHcpe3Rocm93IGQ+Pj49MCxuZXcgRXQoZCkuWWEoZj4+PjAsdz4+PjApLGp0PWQsJHIrKyxqdH0sZzpmdW5jdGlvbigpe3JldHVybiAwfSxKOmZ1bmN0aW9uKCl7fSx6OmZ1bmN0aW9uKCl7fSxCOmZ1bmN0aW9uKCl7fSxMOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEg6ZnVuY3Rpb24oKXt9LEM6ZnVuY3Rpb24oKXt9LEc6ZnVuY3Rpb24oKXt9LGw6ZnVuY3Rpb24oKXt9LEE6ZnVuY3Rpb24oKXt9LHg6ZnVuY3Rpb24oKXt9LEk6ZnVuY3Rpb24oKXt9LHk6ZnVuY3Rpb24oKXt9LG06KCk9PiEwLHE6ZnVuY3Rpb24oZCxmLHcpe2Q9ZisyMDk3MTUyPj4+MDw0MTk0MzA1LSEhZD8oZD4+PjApKzQyOTQ5NjcyOTYqZjpOYU4sdz4+Pj0wLGQ9bmV3IERhdGUoMWUzKmQpLE1bdz4+Mj4+PjBdPWQuZ2V0VVRDU2Vjb25kcygpLE1bdys0Pj4yPj4+MF09ZC5nZXRVVENNaW51dGVzKCksTVt3Kzg+PjI+Pj4wXT1kLmdldFVUQ0hvdXJzKCksTVt3KzEyPj4yPj4+MF09ZC5nZXRVVENEYXRlKCksTVt3KzE2Pj4yPj4+MF09ZC5nZXRVVENNb250aCgpLE1bdysyMD4+Mj4+PjBdPWQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLE1bdysyND4+Mj4+PjBdPWQuZ2V0VVRDRGF5KCksTVt3KzI4Pj4yPj4+MF09KGQuZ2V0VGltZSgpLURhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LHI6ZnVuY3Rpb24oZCxmLHcpe2Q9ZisyMDk3MTUyPj4+MDw0MTk0MzA1LSEhZD8oZD4+PjApKzQyOTQ5NjcyOTYqZjpOYU4sdz4+Pj0wLGQ9bmV3IERhdGUoMWUzKmQpLE1bdz4+Mj4+PjBdPWQuZ2V0U2Vjb25kcygpLE1bdys0Pj4yPj4+MF09ZC5nZXRNaW51dGVzKCksTVt3Kzg+PjI+Pj4wXT1kLmdldEhvdXJzKCksTVt3KzEyPj4yPj4+MF09ZC5nZXREYXRlKCksTVt3KzE2Pj4yPj4+MF09ZC5nZXRNb250aCgpLE1bdysyMD4+Mj4+PjBdPWQuZ2V0RnVsbFllYXIoKS0xOTAwLE1bdysyND4+Mj4+PjBdPWQuZ2V0RGF5KCksTVt3KzI4Pj4yPj4+MF09KGx0KGQuZ2V0RnVsbFllYXIoKSk/eHI6ZHQpW2QuZ2V0TW9udGgoKV0rZC5nZXREYXRlKCktMXwwLE1bdyszNj4+Mj4+PjBdPS0oNjAqZC5nZXRUaW1lem9uZU9mZnNldCgpKSxmPW5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEM9bmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtNW3crMzI+PjI+Pj4wXT0oZiE9QyYmZC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihDLGYpKXwwfSxzOmZ1bmN0aW9uKGQpe2Q+Pj49MDt2YXIgZj1uZXcgRGF0ZShNW2QrMjA+PjI+Pj4wXSsxOTAwLE1bZCsxNj4+Mj4+PjBdLE1bZCsxMj4+Mj4+PjBdLE1bZCs4Pj4yPj4+MF0sTVtkKzQ+PjI+Pj4wXSxNW2Q+PjI+Pj4wXSwwKSx3PU1bZCszMj4+Mj4+PjBdLEM9Zi5nZXRUaW1lem9uZU9mZnNldCgpLF89bmV3IERhdGUoZi5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxHPW5ldyBEYXRlKGYuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCksVj1NYXRoLm1pbihHLF8pO3JldHVybiAwPnc/TVtkKzMyPj4yPj4+MF09KyhfIT1HJiZWPT1DKTowPHchPShWPT1DKSYmKF89TWF0aC5tYXgoRyxfKSxmLnNldFRpbWUoZi5nZXRUaW1lKCkrNmU0KigoMDx3P1Y6XyktQykpKSxNW2QrMjQ+PjI+Pj4wXT1mLmdldERheSgpLE1bZCsyOD4+Mj4+PjBdPShsdChmLmdldEZ1bGxZZWFyKCkpP3hyOmR0KVtmLmdldE1vbnRoKCldK2YuZ2V0RGF0ZSgpLTF8MCxNW2Q+PjI+Pj4wXT1mLmdldFNlY29uZHMoKSxNW2QrND4+Mj4+PjBdPWYuZ2V0TWludXRlcygpLE1bZCs4Pj4yPj4+MF09Zi5nZXRIb3VycygpLE1bZCsxMj4+Mj4+PjBdPWYuZ2V0RGF0ZSgpLE1bZCsxNj4+Mj4+PjBdPWYuZ2V0TW9udGgoKSxNW2QrMjA+PjI+Pj4wXT1mLmdldFllYXIoKSxkPWYuZ2V0VGltZSgpLzFlMyx0cigoR2U9ZCwxPD0rTWF0aC5hYnMoR2UpPzA8R2U/K01hdGguZmxvb3IoR2UvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgoR2UtKyh+fkdlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKSksZD4+PjB9LG86ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHA6ZnVuY3Rpb24oKXt9LHY6ZnVuY3Rpb24oZCxmLHcpe2Z1bmN0aW9uIEMoWSl7cmV0dXJuKFk9WS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9ZWzFdOlwiR01UXCJ9dz4+Pj0wO3ZhciBfPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxHPW5ldyBEYXRlKF8sMCwxKSxWPW5ldyBEYXRlKF8sNiwxKTtfPUcuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgdWU9Vi5nZXRUaW1lem9uZU9mZnNldCgpO3FbZD4+PjA+PjI+Pj4wXT02MCpNYXRoLm1heChfLHVlKSxNW2Y+Pj4wPj4yPj4+MF09KyhfIT11ZSksZD1DKEcpLGY9QyhWKSxkPVd0KGQpLGY9V3QoZiksdWU8Xz8ocVt3Pj4yPj4+MF09ZCxxW3crND4+Mj4+PjBdPWYpOihxW3c+PjI+Pj4wXT1mLHFbdys0Pj4yPj4+MF09ZCl9LGU6KCk9PntxZShcIlwiKX0sYjpmdW5jdGlvbihkLGYsdyl7cmV0dXJuIGQ+Pj49MCxmPU50KGY+Pj4wLHc+Pj4wKSxldFtkXS5hcHBseShudWxsLGYpfSxpOmZ1bmN0aW9uKGQsZix3KXtyZXR1cm4gZD4+Pj0wLGY9TnQoZj4+PjAsdz4+PjApLGV0W2RdLmFwcGx5KG51bGwsZil9LGg6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sdzpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxjOigpPT5wZXJmb3JtYW5jZS5ub3coKSxLOmZ1bmN0aW9uKGQsZix3KXtyZXR1cm4gZj4+Pj0wLGxlLmNvcHlXaXRoaW4oZD4+PjA+Pj4wLGY+Pj4wLGYrKHc+Pj4wKT4+PjApfSx1OmZ1bmN0aW9uKGQpe2Q+Pj49MDt2YXIgZj1sZS5sZW5ndGg7aWYoNDI5NDkwMTc2MDxkKXJldHVybiExO2Zvcih2YXIgdz0xOzQ+PXc7dyo9Mil7dmFyIEM9ZiooMSsuMi93KTtDPU1hdGgubWluKEMsZCsxMDA2NjMyOTYpO3ZhciBfPU1hdGg7Qz1NYXRoLm1heChkLEMpO2U6e189Xy5taW4uY2FsbChfLDQyOTQ5MDE3NjAsQysoNjU1MzYtQyU2NTUzNiklNjU1MzYpLUQuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7RC5ncm93KF8pLHdlKCk7dmFyIEc9MTticmVhayBlfWNhdGNoe31HPXZvaWQgMH1pZihHKXJldHVybiEwfXJldHVybiExfSxEOmZ1bmN0aW9uKGQsZil7ZD4+Pj0wLGY+Pj49MDt2YXIgdz0wO3JldHVybiBZdCgpLmZvckVhY2goZnVuY3Rpb24oQyxfKXt2YXIgRz1mK3c7Zm9yKF89cVtkKzQqXz4+Mj4+PjBdPUcsRz0wO0c8Qy5sZW5ndGg7KytHKUtbXysrPj4wPj4+MF09Qy5jaGFyQ29kZUF0KEcpO0tbXz4+MD4+PjBdPTAsdys9Qy5sZW5ndGgrMX0pLDB9LEU6ZnVuY3Rpb24oZCxmKXtkPj4+PTAsZj4+Pj0wO3ZhciB3PVl0KCk7cVtkPj4yPj4+MF09dy5sZW5ndGg7dmFyIEM9MDtyZXR1cm4gdy5mb3JFYWNoKGZ1bmN0aW9uKF8pe0MrPV8ubGVuZ3RoKzF9KSxxW2Y+PjI+Pj4wXT1DLDB9LGY6KCk9PjUyLGs6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LHQ6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LGo6ZnVuY3Rpb24oZCxmLHcsQyl7Zj4+Pj0wLHc+Pj49MCxDPj4+PTA7Zm9yKHZhciBfPTAsRz0wO0c8dztHKyspe3ZhciBWPXFbZj4+Mj4+PjBdLHVlPXFbZis0Pj4yPj4+MF07Zis9ODtmb3IodmFyIFk9MDtZPHVlO1krKyl7dmFyIFo9bGVbVitZPj4+MF0sSj1TcltkXTtaPT09MHx8Wj09PTEwPygoZD09PTE/STpUKShxdChKLDApKSxKLmxlbmd0aD0wKTpKLnB1c2goWil9Xys9dWV9cmV0dXJuIHFbQz4+Mj4+PjBdPV8sMH0sRjpuZSxkOmZ1bmN0aW9uKGQsZix3LEMpe3JldHVybiBuZShkPj4+MCxmPj4+MCx3Pj4+MCxDPj4+MCl9fTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBkKHcpe2lmKHc9dy5leHBvcnRzLHc9Q3IodyksUj13PWJ0KHcpLEQ9Ui5NLHdlKCksU2UudW5zaGlmdChSLk4pLENlLS0sci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoQ2UpLENlPT0wJiYoZ3QhPT1udWxsJiYoY2xlYXJJbnRlcnZhbChndCksZ3Q9bnVsbCksTGUpKXt2YXIgQz1MZTtMZT1udWxsLEMoKX1yZXR1cm4gd312YXIgZj17YTpQcn07aWYoQ2UrKyxyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhDZSksci5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiByLmluc3RhbnRpYXRlV2FzbShmLGQpfWNhdGNoKHcpe1QoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit3KSxuKHcpfXJldHVybiB6ZShmLGZ1bmN0aW9uKHcpe2Qody5pbnN0YW5jZSl9KS5jYXRjaChuKSx7fX0pKCksci5fT3J0SW5pdD0oZCxmKT0+KHIuX09ydEluaXQ9Ui5PKShkLGYpLHIuX09ydEdldExhc3RFcnJvcj0oZCxmKT0+KHIuX09ydEdldExhc3RFcnJvcj1SLlApKGQsZiksci5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KGQsZix3LEMsXyxHLFYsdWUsWSxaKT0+KHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPVIuUSkoZCxmLHcsQyxfLEcsVix1ZSxZLFopLHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShkLGYpPT4oci5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9Ui5SKShkLGYpLHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0oZCxmLHcpPT4oci5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPVIuUykoZCxmLHcpLHIuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0oZCxmLHcpPT4oci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PVIuVCkoZCxmLHcpLHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1kPT4oci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPVIuVSkoZCksci5fT3J0Q3JlYXRlU2Vzc2lvbj0oZCxmLHcpPT4oci5fT3J0Q3JlYXRlU2Vzc2lvbj1SLlYpKGQsZix3KSxyLl9PcnRSZWxlYXNlU2Vzc2lvbj1kPT4oci5fT3J0UmVsZWFzZVNlc3Npb249Ui5XKShkKSxyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShkLGYsdyk9PihyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PVIuWCkoZCxmLHcpLHIuX09ydEdldElucHV0TmFtZT0oZCxmKT0+KHIuX09ydEdldElucHV0TmFtZT1SLlkpKGQsZiksci5fT3J0R2V0T3V0cHV0TmFtZT0oZCxmKT0+KHIuX09ydEdldE91dHB1dE5hbWU9Ui5aKShkLGYpLHIuX09ydEZyZWU9ZD0+KHIuX09ydEZyZWU9Ui5fKShkKSxyLl9PcnRDcmVhdGVUZW5zb3I9KGQsZix3LEMsXyxHKT0+KHIuX09ydENyZWF0ZVRlbnNvcj1SLiQpKGQsZix3LEMsXyxHKSxyLl9PcnRHZXRUZW5zb3JEYXRhPShkLGYsdyxDLF8pPT4oci5fT3J0R2V0VGVuc29yRGF0YT1SLmFhKShkLGYsdyxDLF8pLHIuX09ydFJlbGVhc2VUZW5zb3I9ZD0+KHIuX09ydFJlbGVhc2VUZW5zb3I9Ui5iYSkoZCksci5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0oZCxmLHcsQyk9PihyLl9PcnRDcmVhdGVSdW5PcHRpb25zPVIuY2EpKGQsZix3LEMpLHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShkLGYsdyk9PihyLl9PcnRBZGRSdW5Db25maWdFbnRyeT1SLmRhKShkLGYsdyksci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZD0+KHIuX09ydFJlbGVhc2VSdW5PcHRpb25zPVIuZWEpKGQpLHIuX09ydENyZWF0ZUJpbmRpbmc9ZD0+KHIuX09ydENyZWF0ZUJpbmRpbmc9Ui5mYSkoZCksci5fT3J0QmluZElucHV0PShkLGYsdyk9PihyLl9PcnRCaW5kSW5wdXQ9Ui5nYSkoZCxmLHcpLHIuX09ydEJpbmRPdXRwdXQ9KGQsZix3LEMpPT4oci5fT3J0QmluZE91dHB1dD1SLmhhKShkLGYsdyxDKSxyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1kPT4oci5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9Ui5pYSkoZCksci5fT3J0UmVsZWFzZUJpbmRpbmc9ZD0+KHIuX09ydFJlbGVhc2VCaW5kaW5nPVIuamEpKGQpLHIuX09ydFJ1bldpdGhCaW5kaW5nPShkLGYsdyxDLF8pPT4oci5fT3J0UnVuV2l0aEJpbmRpbmc9Ui5rYSkoZCxmLHcsQyxfKSxyLl9PcnRSdW49KGQsZix3LEMsXyxHLFYsdWUpPT4oci5fT3J0UnVuPVIubGEpKGQsZix3LEMsXyxHLFYsdWUpLHIuX09ydEVuZFByb2ZpbGluZz1kPT4oci5fT3J0RW5kUHJvZmlsaW5nPVIubWEpKGQpLHIuX0pzZXBPdXRwdXQ9KGQsZix3KT0+KHIuX0pzZXBPdXRwdXQ9Ui5uYSkoZCxmLHcpLHIuX0pzZXBHZXROb2RlTmFtZT1kPT4oci5fSnNlcEdldE5vZGVOYW1lPVIub2EpKGQpO3ZhciBHdD1yLl9tYWxsb2M9ZD0+KEd0PXIuX21hbGxvYz1SLnBhKShkKSxlcj1yLl9mcmVlPWQ9Pihlcj1yLl9mcmVlPVIucWEpKGQpLHRyPWQ9Pih0cj1SLnNhKShkKSxycj0oKT0+KHJyPVIudGEpKCksbnI9ZD0+KG5yPVIudWEpKGQpLGFyPWQ9Pihhcj1SLnZhKShkKSxvcj1kPT4ob3I9Ui54YSkoZCksaXI9KCk9Pihpcj1SLnlhKSgpLEZ0PWQ9PihGdD1SLnphKShkKSxUdD0oKT0+KFR0PVIuQWEpKCk7ci5fX19zdGFydF9lbV9qcz05MjQ1ODcsci5fX19zdG9wX2VtX2pzPTkyNDc0ODtmdW5jdGlvbiBidChkKXtkPU9iamVjdC5hc3NpZ24oe30sZCk7dmFyIGY9Qz0+KCk9PkMoKT4+PjAsdz1DPT5fPT5DKF8pPj4+MDtyZXR1cm4gZC5fX2Vycm5vX2xvY2F0aW9uPWYoZC5fX2Vycm5vX2xvY2F0aW9uKSxkLm1hbGxvYz13KGQubWFsbG9jKSxkLnN0YWNrU2F2ZT1mKGQuc3RhY2tTYXZlKSxkLnN0YWNrQWxsb2M9dyhkLnN0YWNrQWxsb2MpLGR9ci5zdGFja0FsbG9jPWFyLHIuc3RhY2tTYXZlPXJyLHIuc3RhY2tSZXN0b3JlPW5yLHIuVVRGOFRvU3RyaW5nPVJlLHIuc3RyaW5nVG9VVEY4PShkLGYsdyk9Pkt0KGQsbGUsZix3KSxyLmxlbmd0aEJ5dGVzVVRGOD16dDt2YXIgUnQ7TGU9ZnVuY3Rpb24gZCgpe1J0fHxzcigpLFJ0fHwoTGU9ZCl9O2Z1bmN0aW9uIHNyKCl7ZnVuY3Rpb24gZCgpe2lmKCFSdCYmKFJ0PSEwLHIuY2FsbGVkUnVuPSEwLCFXKSl7aWYoQXQoU2UpLGEociksci5vblJ1bnRpbWVJbml0aWFsaXplZCYmci5vblJ1bnRpbWVJbml0aWFsaXplZCgpLHIucG9zdFJ1bilmb3IodHlwZW9mIHIucG9zdFJ1bj09XCJmdW5jdGlvblwiJiYoci5wb3N0UnVuPVtyLnBvc3RSdW5dKTtyLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGY9ci5wb3N0UnVuLnNoaWZ0KCk7VGUudW5zaGlmdChmKX1BdChUZSl9fWlmKCEoMDxDZSkpe2lmKHIucHJlUnVuKWZvcih0eXBlb2Ygci5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKHIucHJlUnVuPVtyLnByZVJ1bl0pO3IucHJlUnVuLmxlbmd0aDspRWUoKTtBdChqKSwwPENlfHwoci5zZXRTdGF0dXM/KHIuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3Iuc2V0U3RhdHVzKFwiXCIpfSwxKSxkKCl9LDEpKTpkKCkpfX1pZihyLnByZUluaXQpZm9yKHR5cGVvZiByLnByZUluaXQ9PVwiZnVuY3Rpb25cIiYmKHIucHJlSW5pdD1bci5wcmVJbml0XSk7MDxyLnByZUluaXQubGVuZ3RoOylyLnByZUluaXQucG9wKCkoKTtyZXR1cm4gc3IoKSx0LnJlYWR5fX0pKCk7dHlwZW9mIHZvPT1cIm9iamVjdFwiJiZ0eXBlb2YgRG49PVwib2JqZWN0XCI/RG4uZXhwb3J0cz13bzp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQmJmRlZmluZShbXSwoKT0+d28pfSk7dmFyIHhvPUx0KCgpPT57fSk7dmFyIFNvPUx0KCgpPT57fSk7dmFyIENvPXt9O2t0KENvLHtjcHVzOigpPT5WbH0pO3ZhciBWbCxJbz1MKCgpPT57Vmw9dm9pZCAwfSk7dmFyIF9vPUx0KChFbyx6bik9PntcInVzZSBzdHJpY3RcIjt2YXIgQW89KCgpPT57dmFyIGU9dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMDtyZXR1cm4gdHlwZW9mIF9fZmlsZW5hbWU8XCJ1XCImJihlPWV8fF9fZmlsZW5hbWUpLGZ1bmN0aW9uKHQ9e30pe2Z1bmN0aW9uIHIoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksQ2V9ZnVuY3Rpb24gYSgpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxndH1mdW5jdGlvbiBuKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLExlfWZ1bmN0aW9uIHMoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCkscWV9ZnVuY3Rpb24gdSgpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxVfWZ1bmN0aW9uIGwoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksZGV9dmFyIG89dCxwLG07by5yZWFkeT1uZXcgUHJvbWlzZSgoaSxjKT0+e3A9aSxtPWN9KSxvLmpzZXBJbml0PShpLGMsaCx4LEEsayxOLGFlKT0+e28uUWI9aSxvLndiPWMsby55Yj1oLG8uamI9eCxvLnhiPUEsby5FYT1rLG8uemI9TixvLkFiPWFlLGM9KGVlLFEscmUpPT4oLi4uaGUpPT57bGV0IGJlPXJ0LE89UT8uKCk7aGU9ZWUoLi4uaGUpO2xldCBzZT1RPy4oKTtyZXR1cm4gTyE9PXNlJiYoZWU9c2UscmUoTyksUT1yZT1udWxsKSxydCE9YmU/SWwoKTpoZX0saD1lZT0+YXN5bmMoLi4uUSk9Pnt0cnl7aWYoby5iYil0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCByZT1vLmJiPXtGYjpRWzBdLGVycm9yczpbXX0saGU9YXdhaXQgZWUoLi4uUSk7aWYoby5iYiE9PXJlKXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTtpLmZsdXNoKCk7bGV0IGJlPXJlLmVycm9ycztpZigwPGJlLmxlbmd0aCl7bGV0IE89YXdhaXQgUHJvbWlzZS5hbGwoYmUpO2lmKE89Ty5maWx0ZXIoc2U9PnNlKSwwPE8ubGVuZ3RoKXRocm93IEVycm9yKE8uam9pbihgXG5gKSl9cmV0dXJuIGhlfWZpbmFsbHl7by5iYj1udWxsfX0sby5fT3J0UnVuPWgoYyhvLl9PcnRSdW4sKCk9Pm8uX09ydFJ1bixlZT0+by5fT3J0UnVuPWVlKSksby5fT3J0UnVuV2l0aEJpbmRpbmc9aChjKG8uX09ydFJ1bldpdGhCaW5kaW5nLCgpPT5vLl9PcnRSdW5XaXRoQmluZGluZyxlZT0+by5fT3J0UnVuV2l0aEJpbmRpbmc9ZWUpKSxvLl9PcnRCaW5kSW5wdXQ9YyhvLl9PcnRCaW5kSW5wdXQsKCk9Pm8uX09ydEJpbmRJbnB1dCxlZT0+by5fT3J0QmluZElucHV0PWVlKSxvLmpzZXBSZWdpc3RlckJ1ZmZlcj0oZWUsUSxyZSxoZSk9PmkucmVnaXN0ZXJCdWZmZXIoZWUsUSxyZSxoZSksby5qc2VwVW5yZWdpc3RlckJ1ZmZlcnM9ZWU9PntpLnVucmVnaXN0ZXJCdWZmZXJzKGVlKX0sby5qc2VwR2V0QnVmZmVyPWVlPT5pLmdldEJ1ZmZlcihlZSksby5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oZWUsUSxyZSk9PmkuY3JlYXRlRG93bmxvYWRlcihlZSxRLHJlKX07dmFyIHk9T2JqZWN0LmFzc2lnbih7fSxvKSxnPVwiLi90aGlzLnByb2dyYW1cIix2PShpLGMpPT57dGhyb3cgY30sJD10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLGI9dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixTPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIixJPW8uRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsVD1cIlwiO2Z1bmN0aW9uIEIoaSl7cmV0dXJuIG8ubG9jYXRlRmlsZT9vLmxvY2F0ZUZpbGUoaSxUKTpUK2l9dmFyIFAsRCxSO2lmKFMpe3ZhciBXPShrbigpLHZ0KFBuKSksSD0oTW4oKSx2dChCbikpO1Q9Yj9ILmRpcm5hbWUoVCkrXCIvXCI6X19kaXJuYW1lK1wiL1wiLFA9KGMsaCk9PihjPWMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChjKTpILm5vcm1hbGl6ZShjKSxXLnJlYWRGaWxlU3luYyhjLGg/dm9pZCAwOlwidXRmOFwiKSksUj1jPT4oYz1QKGMsITApLGMuYnVmZmVyfHwoYz1uZXcgVWludDhBcnJheShjKSksYyksRD0oYyxoLHgsQT0hMCk9PntjPWMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChjKTpILm5vcm1hbGl6ZShjKSxXLnJlYWRGaWxlKGMsQT92b2lkIDA6XCJ1dGY4XCIsKGssTik9PntrP3goayk6aChBP04uYnVmZmVyOk4pfSl9LCFvLnRoaXNQcm9ncmFtJiYxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihnPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMiksdj0oYyxoKT0+e3Rocm93IHByb2Nlc3MuZXhpdENvZGU9YyxofSxvLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIjtsZXQgaTt0cnl7aT14bygpfWNhdGNoKGMpe3Rocm93IGNvbnNvbGUuZXJyb3IoJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkPycpLGN9Z2xvYmFsLldvcmtlcj1pLldvcmtlcn1lbHNlKCR8fGIpJiYoYj9UPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihUPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSx0eXBlb2YgZTxcInVcIiYmZSYmKFQ9ZSksVC5pbmRleE9mKFwiYmxvYjpcIikhPT0wP1Q9VC5zdWJzdHIoMCxULnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlQ9XCJcIixTfHwoUD1pPT57dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBjLm9wZW4oXCJHRVRcIixpLCExKSxjLnNlbmQobnVsbCksYy5yZXNwb25zZVRleHR9LGImJihSPWk9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLGksITEpLGMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixjLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoYy5yZXNwb25zZSl9KSxEPShpLGMsaCk9Pnt2YXIgeD1uZXcgWE1MSHR0cFJlcXVlc3Q7eC5vcGVuKFwiR0VUXCIsaSwhMCkseC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHgub25sb2FkPSgpPT57eC5zdGF0dXM9PTIwMHx8eC5zdGF0dXM9PTAmJngucmVzcG9uc2U/Yyh4LnJlc3BvbnNlKTpoKCl9LHgub25lcnJvcj1oLHguc2VuZChudWxsKX0pKTtTJiZ0eXBlb2YgcGVyZm9ybWFuY2U+XCJ1XCImJihnbG9iYWwucGVyZm9ybWFuY2U9U28oKS5wZXJmb3JtYW5jZSk7dmFyIEs9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxsZT1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7UyYmKEs9KC4uLmkpPT5XLndyaXRlU3luYygxLGkuam9pbihcIiBcIikrYFxuYCksbGU9KC4uLmkpPT5XLndyaXRlU3luYygyLGkuam9pbihcIiBcIikrYFxuYCkpO3ZhciBNPW8ucHJpbnR8fEsscT1vLnByaW50RXJyfHxsZTtPYmplY3QuYXNzaWduKG8seSkseT1udWxsLG8udGhpc1Byb2dyYW0mJihnPW8udGhpc1Byb2dyYW0pLG8ucXVpdCYmKHY9by5xdWl0KTt2YXIgeGU7by53YXNtQmluYXJ5JiYoeGU9by53YXNtQmluYXJ5KTt2YXIgb2U9by5ub0V4aXRSdW50aW1lfHwhMDt0eXBlb2YgV2ViQXNzZW1ibHkhPVwib2JqZWN0XCImJkplKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgd2UsaixTZSxUZT0hMSxFZSxDZSxndCxMZSxxZSxVLGRlO2Z1bmN0aW9uIHBlKCl7dmFyIGk9d2UuYnVmZmVyO28uSEVBUDg9Q2U9bmV3IEludDhBcnJheShpKSxvLkhFQVAxNj1uZXcgSW50MTZBcnJheShpKSxvLkhFQVAzMj1MZT1uZXcgSW50MzJBcnJheShpKSxvLkhFQVBVOD1ndD1uZXcgVWludDhBcnJheShpKSxvLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGkpLG8uSEVBUFUzMj1xZT1uZXcgVWludDMyQXJyYXkoaSksby5IRUFQRjMyPVU9bmV3IEZsb2F0MzJBcnJheShpKSxvLkhFQVBGNjQ9ZGU9bmV3IEZsb2F0NjRBcnJheShpKX12YXIgTmU9by5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7aWYoNTI0Mjg4MDw9TmV8fEplKFwiSU5JVElBTF9NRU1PUlkgc2hvdWxkIGJlIGxhcmdlciB0aGFuIFNUQUNLX1NJWkUsIHdhcyBcIitOZStcIiEgKFNUQUNLX1NJWkU9NTI0Mjg4MClcIiksSSl3ZT1vLndhc21NZW1vcnk7ZWxzZSBpZihvLndhc21NZW1vcnkpd2U9by53YXNtTWVtb3J5O2Vsc2UgaWYod2U9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpOZS82NTUzNixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pLCEod2UuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IHEoXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksUyYmcShcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kL29yIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7cGUoKSxOZT13ZS5idWZmZXIuYnl0ZUxlbmd0aDt2YXIgSGU9W10sT2U9W10semU9W10sR2U9MDtmdW5jdGlvbiBldCgpe3JldHVybiBvZXx8MDxHZX12YXIgS2U9MCxBdD1udWxsLEV0PW51bGw7ZnVuY3Rpb24ganQoKXtLZSsrLG8ubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEtlKX1mdW5jdGlvbiAkcigpe2lmKEtlLS0sby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZvLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoS2UpLEtlPT0wJiYoQXQhPT1udWxsJiYoY2xlYXJJbnRlcnZhbChBdCksQXQ9bnVsbCksRXQpKXt2YXIgaT1FdDtFdD1udWxsLGkoKX19ZnVuY3Rpb24gSmUoaSl7dGhyb3cgby5vbkFib3J0JiZvLm9uQWJvcnQoaSksaT1cIkFib3J0ZWQoXCIraStcIilcIixxKGkpLFRlPSEwLEVlPTEsaT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGkrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLG0oaSksaX1mdW5jdGlvbiBxdChpKXtyZXR1cm4gaS5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX12YXIgUmU7UmU9XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIixxdChSZSl8fChSZT1CKFJlKSk7ZnVuY3Rpb24genQoaSl7aWYoaT09UmUmJnhlKXJldHVybiBuZXcgVWludDhBcnJheSh4ZSk7aWYoUilyZXR1cm4gUihpKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBLdChpKXtpZigheGUmJigkfHxiKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFpLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChpLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGM9PntpZighYy5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIraStcIidcIjtyZXR1cm4gYy5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9Pnp0KGkpKTtpZihEKXJldHVybiBuZXcgUHJvbWlzZSgoYyxoKT0+e0QoaSx4PT5jKG5ldyBVaW50OEFycmF5KHgpKSxoKX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT56dChpKSl9ZnVuY3Rpb24gbHQoaSxjLGgpe3JldHVybiBLdChpKS50aGVuKHg9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHgsYykpLnRoZW4oeD0+eCkudGhlbihoLHg9PntxKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIreCksSmUoeCl9KX1mdW5jdGlvbiB4cihpLGMpe3ZhciBoPVJlO3JldHVybiB4ZXx8dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT1cImZ1bmN0aW9uXCJ8fHF0KGgpfHxoLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxTfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9sdChoLGksYyk6ZmV0Y2goaCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbih4PT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh4LGkpLnRoZW4oYyxmdW5jdGlvbihBKXtyZXR1cm4gcShcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitBKSxxKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbHQoaCxpLGMpfSkpfXZhciBkdCxXdD17OTE0OTg4Omk9PntvLkVhKFwiQWJzXCIsaSx2b2lkIDApfSw5MTUwMzk6aT0+e28uRWEoXCJOZWdcIixpLHZvaWQgMCl9LDkxNTA5MDppPT57by5FYShcIkZsb29yXCIsaSx2b2lkIDApfSw5MTUxNDM6aT0+e28uRWEoXCJDZWlsXCIsaSx2b2lkIDApfSw5MTUxOTU6aT0+e28uRWEoXCJSZWNpcHJvY2FsXCIsaSx2b2lkIDApfSw5MTUyNTM6aT0+e28uRWEoXCJTcXJ0XCIsaSx2b2lkIDApfSw5MTUzMDU6aT0+e28uRWEoXCJFeHBcIixpLHZvaWQgMCl9LDkxNTM1NjppPT57by5FYShcIkVyZlwiLGksdm9pZCAwKX0sOTE1NDA3Omk9PntvLkVhKFwiU2lnbW9pZFwiLGksdm9pZCAwKX0sOTE1NDYyOmk9PntvLkVhKFwiTG9nXCIsaSx2b2lkIDApfSw5MTU1MTM6aT0+e28uRWEoXCJTaW5cIixpLHZvaWQgMCl9LDkxNTU2NDppPT57by5FYShcIkNvc1wiLGksdm9pZCAwKX0sOTE1NjE1Omk9PntvLkVhKFwiVGFuXCIsaSx2b2lkIDApfSw5MTU2NjY6aT0+e28uRWEoXCJBc2luXCIsaSx2b2lkIDApfSw5MTU3MTg6aT0+e28uRWEoXCJBY29zXCIsaSx2b2lkIDApfSw5MTU3NzA6aT0+e28uRWEoXCJBdGFuXCIsaSx2b2lkIDApfSw5MTU4MjI6aT0+e28uRWEoXCJTaW5oXCIsaSx2b2lkIDApfSw5MTU4NzQ6aT0+e28uRWEoXCJDb3NoXCIsaSx2b2lkIDApfSw5MTU5MjY6aT0+e28uRWEoXCJBc2luaFwiLGksdm9pZCAwKX0sOTE1OTc5Omk9PntvLkVhKFwiQWNvc2hcIixpLHZvaWQgMCl9LDkxNjAzMjppPT57by5FYShcIkF0YW5oXCIsaSx2b2lkIDApfSw5MTYwODU6aT0+e28uRWEoXCJUYW5oXCIsaSx2b2lkIDApfSw5MTYxMzc6aT0+e28uRWEoXCJOb3RcIixpLHZvaWQgMCl9LDkxNjE4ODooaSxjLGgpPT57by5FYShcIkNsaXBWMTBcIixpLHttaW46YyxtYXg6aH0pfSw5MTYyNjA6aT0+e28uRWEoXCJDbGlwXCIsaSx2b2lkIDApfSw5MTYzMTI6KGksYyk9PntvLkVhKFwiRWx1XCIsaSx7YWxwaGE6Y30pfSw5MTYzNzA6aT0+e28uRWEoXCJSZWx1XCIsaSx2b2lkIDApfSw5MTY0MjI6KGksYyk9PntvLkVhKFwiTGVha3lSZWx1XCIsaSx7YWxwaGE6Y30pfSw5MTY0ODY6KGksYyk9PntvLkVhKFwiVGhyZXNob2xkZWRSZWx1XCIsaSx7YWxwaGE6Y30pfSw5MTY1NTY6KGksYyk9PntvLkVhKFwiQ2FzdFwiLGkse3RvOmN9KX0sOTE2NjE0Omk9PntvLkVhKFwiQWRkXCIsaSx2b2lkIDApfSw5MTY2NjU6aT0+e28uRWEoXCJTdWJcIixpLHZvaWQgMCl9LDkxNjcxNjppPT57by5FYShcIk11bFwiLGksdm9pZCAwKX0sOTE2NzY3Omk9PntvLkVhKFwiRGl2XCIsaSx2b2lkIDApfSw5MTY4MTg6aT0+e28uRWEoXCJQb3dcIixpLHZvaWQgMCl9LDkxNjg2OTppPT57by5FYShcIkVxdWFsXCIsaSx2b2lkIDApfSw5MTY5MjI6aT0+e28uRWEoXCJHcmVhdGVyXCIsaSx2b2lkIDApfSw5MTY5Nzc6aT0+e28uRWEoXCJHcmVhdGVyT3JFcXVhbFwiLGksdm9pZCAwKX0sOTE3MDM5Omk9PntvLkVhKFwiTGVzc1wiLGksdm9pZCAwKX0sOTE3MDkxOmk9PntvLkVhKFwiTGVzc09yRXF1YWxcIixpLHZvaWQgMCl9LDkxNzE1MDooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VNZWFuXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxNzMxNDooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VNYXhcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE3NDc3OihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZU1pblwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTc2NDA6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlUHJvZFwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTc4MDQ6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlU3VtXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxNzk2NzooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VMMVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTgxMjk6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlTDJcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE4MjkxOihpLGMsaCx4LEEpPT57by5FYShcIlJlZHVjZUxvZ1N1bVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp4P0FycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEEreD4+PjApKTpbXX0pfSw5MTg0NTc6KGksYyxoLHgsQSk9PntvLkVhKFwiUmVkdWNlU3VtU3F1YXJlXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkxODYyNjooaSxjLGgseCxBKT0+e28uRWEoXCJSZWR1Y2VMb2dTdW1FeHBcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTE4Nzk1Omk9PntvLkVhKFwiV2hlcmVcIixpLHZvaWQgMCl9LDkxODg0ODooaSxjLGgpPT57by5FYShcIlRyYW5zcG9zZVwiLGkse3Blcm06Yz9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShoPj4+MCxoK2M+Pj4wKSk6W119KX0sOTE4OTYxOihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyxzZSk9PntvLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDplZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltoXSxncm91cDp4LGtlcm5lbF9zaGFwZTpbQV0scGFkczpbayxOXSxzdHJpZGVzOlthZV0sd0lzQ29uc3Q6KCk9PiEhcigpW1E+Pj4wXSxvdXRwdXRQYWRkaW5nOnJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGhlPj4+MCxoZStyZT4+PjApKTpbXSxvdXRwdXRTaGFwZTpiZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShPPj4+MCxPK2JlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoc2UpfSl9LDkxOTM3NTooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8pPT57by5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6YWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShoPj4+MCxoKzI+Pj4wKSksZ3JvdXA6eCxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShrPj4+MCxrKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShOPj4+MCxOKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcigpW2VlPj4+MF0sb3V0cHV0UGFkZGluZzowPFE/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkocmU+Pj4wLHJlK1E+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxoZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShiZT4+PjAsYmUraGU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShPKX0pfSw5MTk5MzI6KGksYyxoLHgsQSxrLE4sYWUsZWUsUSxyZSxoZSxiZSxPLHNlKT0+e28uRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OmVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6W2hdLGdyb3VwOngsa2VybmVsX3NoYXBlOltBXSxwYWRzOltrLE5dLHN0cmlkZXM6W2FlXSx3SXNDb25zdDooKT0+ISFyKClbUT4+PjBdLG91dHB1dFBhZGRpbmc6cmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaGU+Pj4wLGhlK3JlPj4+MCkpOltdLG91dHB1dFNoYXBlOmJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KE8+Pj4wLE8rYmU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShzZSl9KX0sOTIwMzQ2OihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyk9PntvLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDphZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20obigpLnN1YmFycmF5KGg+Pj4wLGgrMj4+PjApKSxncm91cDp4LGtlcm5lbFNoYXBlOkFycmF5LmZyb20obigpLnN1YmFycmF5KEE+Pj4wLEErMj4+PjApKSxwYWRzOkFycmF5LmZyb20obigpLnN1YmFycmF5KGs+Pj4wLGsrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20obigpLnN1YmFycmF5KE4+Pj4wLE4rMj4+PjApKSx3SXNDb25zdDooKT0+ISFyKClbZWU+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8UT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShyZT4+PjAscmUrUT4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGhlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGJlPj4+MCxiZStoZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKE8pfSl9LDkyMDkwMzooaSxjKT0+e28uRWEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDk5NDooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8sc2UseWUpPT57by5FYShcIkF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6eCxzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltrLE5dLGtlcm5lbF9zaGFwZTpbYWUsZWVdLHBhZHM6W1EscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMTI3ODooaSxjKT0+e28uRWEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMTM2OTooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8sc2UseWUpPT57by5FYShcIkF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6eCxzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltrLE5dLGtlcm5lbF9zaGFwZTpbYWUsZWVdLHBhZHM6W1EscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMTY1MzooaSxjKT0+e28uRWEoXCJHbG9iYWxNYXhQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIxNzQwOihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUsTyxzZSx5ZSk9PntvLkVhKFwiTWF4UG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOngsc3RvcmFnZV9vcmRlcjpBLGRpbGF0aW9uczpbayxOXSxrZXJuZWxfc2hhcGU6W2FlLGVlXSxwYWRzOltRLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjIwMjA6KGksYyk9PntvLkVhKFwiR2xvYmFsTWF4UG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMjEwNzooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8sc2UseWUpPT57by5FYShcIk1heFBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDp4LHN0b3JhZ2Vfb3JkZXI6QSxkaWxhdGlvbnM6W2ssTl0sa2VybmVsX3NoYXBlOlthZSxlZV0scGFkczpbUSxyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIyMzg3OihpLGMsaCx4LEEpPT57by5FYShcIkdlbW1cIixpLHthbHBoYTpjLGJldGE6aCx0cmFuc0E6eCx0cmFuc0I6QX0pfSw5MjI0OTE6aT0+e28uRWEoXCJNYXRNdWxcIixpLHZvaWQgMCl9LDkyMjU0NTooaSxjLGgseCk9PntvLkVhKFwiQXJnTWF4XCIsaSx7a2VlcERpbXM6ISFjLHNlbGVjdExhc3RJbmRleDohIWgsYXhpczp4fSl9LDkyMjY1MzooaSxjLGgseCk9PntvLkVhKFwiQXJnTWluXCIsaSx7a2VlcERpbXM6ISFjLHNlbGVjdExhc3RJbmRleDohIWgsYXhpczp4fSl9LDkyMjc2MTooaSxjKT0+e28uRWEoXCJTb2Z0bWF4XCIsaSx7YXhpczpjfSl9LDkyMjgyNDooaSxjKT0+e28uRWEoXCJDb25jYXRcIixpLHtheGlzOmN9KX0sOTIyODg0OihpLGMsaCx4LEEpPT57by5FYShcIlNwbGl0XCIsaSx7YXhpczpjLG51bU91dHB1dHM6aCxzcGxpdFNpemVzOng/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoQT4+PjAsQSt4Pj4+MCkpOltdfSl9LDkyMzAyOTppPT57by5FYShcIkV4cGFuZFwiLGksdm9pZCAwKX0sOTIzMDgzOihpLGMpPT57by5FYShcIkdhdGhlclwiLGkse2F4aXM6TnVtYmVyKGMpfSl9LDkyMzE1NDooaSxjKT0+e28uRWEoXCJHYXRoZXJFbGVtZW50c1wiLGkse2F4aXM6TnVtYmVyKGMpfSl9LDkyMzIzMzooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlKT0+e28uRWEoXCJSZXNpemVcIixpLHthbnRpYWxpYXM6YyxheGVzOmg/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoeD4+PjAseCtoPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOlZlKEEpLGN1YmljQ29lZmZBOmssZXhjbHVkZU91dHNpZGU6TixleHRyYXBvbGF0aW9uVmFsdWU6YWUsa2VlcEFzcGVjdFJhdGlvUG9saWN5OlZlKGVlKSxtb2RlOlZlKFEpLG5lYXJlc3RNb2RlOlZlKHJlKX0pfSw5MjM1ODQ6KGksYyxoLHgsQSxrLE4pPT57by5FYShcIlNsaWNlXCIsaSx7c3RhcnRzOmM/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaD4+PjAsaCtjPj4+MCkpOltdLGVuZHM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W10sYXhlczprP0FycmF5LmZyb20obigpLnN1YmFycmF5KE4+Pj4wLE4raz4+PjApKTpbXX0pfSw5MjM4MTU6aT0+e28uRWEoXCJUaWxlXCIsaSx2b2lkIDApfSw5MjM4Njc6KGksYyxoKT0+e28uRWEoXCJMYXllck5vcm1hbGl6YXRpb25cIixpLHtheGlzOk51bWJlcihjKSxlcHNpbG9uOk51bWJlcihoKX0pfSw5MjM5NzQ6KGksYyxoKT0+e28uRWEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOmMsZm9ybWF0Omg/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI0MDg4OihpLGMsaCk9PntvLkVhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjpjLGZvcm1hdDpoP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNDIwMjppPT57by5FYShcIlJhbmdlXCIsaSx2b2lkIDApfSw5MjQyNTU6KGksYyk9PntvLkVhKFwiRWluc3VtXCIsaSx7ZXF1YXRpb246VmUoYyl9KX0sOTI0MzM2OihpLGMsaCx4LEEpPT57by5FYShcIlBhZFwiLGkse21vZGU6Yyx2YWx1ZTpoLHBhZHM6eD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShBPj4+MCxBK3g+Pj4wKSk6W119KX0sOTI0NDY4Omk9PntvLkVhKFwiR2VsdVwiLGksdm9pZCAwKX0sOTI0NTIwOmk9PntvLkVhKFwiQmlhc0FkZFwiLGksdm9pZCAwKX0sOTI0NTc1Omk9PntvLkVhKFwiQmlhc1NwbGl0R2VsdVwiLGksdm9pZCAwKX0sOTI0NjM2OihpLGMpPT57by5FYShcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOmN9KX0sOTI0NzE3OihpLGMsaCx4LEEsayxOLGFlLGVlLFEscmUsaGUsYmUpPT57by5FYShcIkNvbnZcIixpLHtmb3JtYXQ6ZWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6W2hdLGdyb3VwOngsa2VybmVsX3NoYXBlOltBXSxwYWRzOms/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoTj4+PjAsTitrPj4+MCkpOltdLHN0cmlkZXM6W2FlXSx3X2lzX2NvbnN0OigpPT4hIXIoKVtRPj4+MF0sYWN0aXZhdGlvbjpWZShyZSksYWN0aXZhdGlvbl9wYXJhbXM6aGU/QXJyYXkuZnJvbSh1KCkuc3ViYXJyYXkoYmU+Pj4wLGJlK2hlPj4+MCkpOltdfSl9LDkyNTA5ODooaSxjLGgseCxBLGssTixhZSxlZSxRLHJlLGhlLGJlLE8sc2UseWUpPT57by5FYShcIkNvbnZcIixpLHtmb3JtYXQ6aGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6W2gseF0sZ3JvdXA6QSxrZXJuZWxfc2hhcGU6W2ssTl0scGFkczphZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShlZT4+PjAsZWUrYWU+Pj4wKSk6W10sc3RyaWRlczpbUSxyZV0sd19pc19jb25zdDooKT0+ISFyKClbYmU+Pj4wXSxhY3RpdmF0aW9uOlZlKE8pLGFjdGl2YXRpb25fcGFyYW1zOnNlP0FycmF5LmZyb20odSgpLnN1YmFycmF5KHllPj4+MCx5ZStzZT4+PjApKTpbXX0pfSw5MjU1MDA6aT0+e28uemIoaSl9LDkyNTUzNDooaSxjKT0+by5BYihpLGMsby5iYi5GYixvLmJiLmVycm9ycyksOTI1NjQ2Omk9Pm8ud2IoaSksOTI1Njc5Omk9Pm8ueWIoaSksOTI1NzExOihpLGMsaCk9PntvLmpiKGksYyxoLCEwKX0sOTI1NzUwOihpLGMsaCk9PntvLmpiKGksYyxoKX19O2Z1bmN0aW9uIHl0KGkpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtpfSlgLHRoaXMuc3RhdHVzPWl9ZnVuY3Rpb24gTnQoaSl7aS50ZXJtaW5hdGUoKSxpLm9ubWVzc2FnZT0oKT0+e319ZnVuY3Rpb24gVnQoaSl7KGk9bmUuUWFbaV0pfHxKZSgpLG5lLkViKGkpfWZ1bmN0aW9uIFl0KGkpe3ZhciBjPW5lLnRiKCk7aWYoIWMpcmV0dXJuIDY7bmUuWWEucHVzaChjKSxuZS5RYVtpLlhhXT1jLGMuWGE9aS5YYTt2YXIgaD17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTppLkdiLGFyZzppLnJiLHB0aHJlYWRfcHRyOmkuWGF9O3JldHVybiBTJiZjLnVucmVmKCksYy5wb3N0TWVzc2FnZShoLGkuTWIpLDB9dmFyIFV0PXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxTcj0oaSxjLGgpPT57Yz4+Pj0wO3ZhciB4PWMraDtmb3IoaD1jO2lbaF0mJiEoaD49eCk7KSsraDtpZigxNjxoLWMmJmkuYnVmZmVyJiZVdClyZXR1cm4gVXQuZGVjb2RlKGkuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/aS5zbGljZShjLGgpOmkuc3ViYXJyYXkoYyxoKSk7Zm9yKHg9XCJcIjtjPGg7KXt2YXIgQT1pW2MrK107aWYoQSYxMjgpe3ZhciBrPWlbYysrXSY2MztpZigoQSYyMjQpPT0xOTIpeCs9U3RyaW5nLmZyb21DaGFyQ29kZSgoQSYzMSk8PDZ8ayk7ZWxzZXt2YXIgTj1pW2MrK10mNjM7QT0oQSYyNDApPT0yMjQ/KEEmMTUpPDwxMnxrPDw2fE46KEEmNyk8PDE4fGs8PDEyfE48PDZ8aVtjKytdJjYzLDY1NTM2PkE/eCs9U3RyaW5nLmZyb21DaGFyQ29kZShBKTooQS09NjU1MzYseCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxBPj4xMCw1NjMyMHxBJjEwMjMpKX19ZWxzZSB4Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKEEpfXJldHVybiB4fSxWZT0oaSxjKT0+KGk+Pj49MCk/U3IoYSgpLGksYyk6XCJcIjtmdW5jdGlvbiBYdChpKXtpZihJKXJldHVybiBWKDEsMSxpKTtFZT1pLGV0KCl8fChuZS5IYigpLG8ub25FeGl0JiZvLm9uRXhpdChpKSxUZT0hMCksdihpLG5ldyB5dChpKSl9dmFyIEp0PWk9PntpZihFZT1pLEkpdGhyb3cgQ3IoaSksXCJ1bndpbmRcIjtYdChpKX0sbmU9e2FiOltdLFlhOltdLG1iOltdLFFhOnt9LGdiOmZ1bmN0aW9uKCl7ST9uZS52YigpOm5lLnViKCl9LHViOmZ1bmN0aW9uKCl7SGUudW5zaGlmdCgoKT0+e2p0KCksbmUuQmIoKCk9PiRyKCkpfSl9LHZiOmZ1bmN0aW9uKCl7bmUucmVjZWl2ZU9iamVjdFRyYW5zZmVyPW5lLkRiLG5lLnRocmVhZEluaXRUTFM9bmUubGIsbmUuc2V0RXhpdFN0YXR1cz1uZS5rYixvZT0hMX0sa2I6ZnVuY3Rpb24oaSl7RWU9aX0sU2I6W1wiJHRlcm1pbmF0ZVdvcmtlclwiXSxIYjpmdW5jdGlvbigpe2Zvcih2YXIgaSBvZiBuZS5ZYSlOdChpKTtmb3IoaSBvZiBuZS5hYilOdChpKTtuZS5hYj1bXSxuZS5ZYT1bXSxuZS5RYT1bXX0sRWI6ZnVuY3Rpb24oaSl7dmFyIGM9aS5YYTtkZWxldGUgbmUuUWFbY10sbmUuYWIucHVzaChpKSxuZS5ZYS5zcGxpY2UobmUuWWEuaW5kZXhPZihpKSwxKSxpLlhhPTAsQ24oYyl9LERiOmZ1bmN0aW9uKCl7fSxsYjpmdW5jdGlvbigpe25lLm1iLmZvckVhY2goaT0+aSgpKX0sQ2I6aT0+bmV3IFByb21pc2UoYz0+e2kub25tZXNzYWdlPWs9PntrPWsuZGF0YTt2YXIgTj1rLmNtZDtpZihrLnRhcmdldFRocmVhZCYmay50YXJnZXRUaHJlYWQhPU1yKCkpe3ZhciBhZT1uZS5RYVtrLlJiXTthZT9hZS5wb3N0TWVzc2FnZShrLGsudHJhbnNmZXJMaXN0KTpxKCdJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJytOKydcIiB0byB0YXJnZXQgcHRocmVhZCAnK2sudGFyZ2V0VGhyZWFkK1wiLCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFcIil9ZWxzZSBOPT09XCJjaGVja01haWxib3hcIj9UdCgpOk49PT1cInNwYXduVGhyZWFkXCI/WXQoayk6Tj09PVwiY2xlYW51cFRocmVhZFwiP1Z0KGsudGhyZWFkKTpOPT09XCJraWxsVGhyZWFkXCI/KGs9ay50aHJlYWQsTj1uZS5RYVtrXSxkZWxldGUgbmUuUWFba10sTnQoTiksQ24oayksbmUuWWEuc3BsaWNlKG5lLllhLmluZGV4T2YoTiksMSksTi5YYT0wKTpOPT09XCJjYW5jZWxUaHJlYWRcIj9uZS5RYVtrLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6Tj09PVwibG9hZGVkXCI/KGkubG9hZGVkPSEwLGMoaSkpOk49PT1cImFsZXJ0XCI/YWxlcnQoXCJUaHJlYWQgXCIray50aHJlYWRJZCtcIjogXCIray50ZXh0KTprLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/aS5wb3N0TWVzc2FnZShrKTpOPT09XCJjYWxsSGFuZGxlclwiP29bay5oYW5kbGVyXSguLi5rLmFyZ3MpOk4mJnEoXCJ3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgXCIrTil9LGkub25lcnJvcj1rPT57dGhyb3cgcShcIndvcmtlciBzZW50IGFuIGVycm9yISBcIitrLmZpbGVuYW1lK1wiOlwiK2subGluZW5vK1wiOiBcIitrLm1lc3NhZ2UpLGt9LFMmJihpLm9uKFwibWVzc2FnZVwiLGZ1bmN0aW9uKGspe2kub25tZXNzYWdlKHtkYXRhOmt9KX0pLGkub24oXCJlcnJvclwiLGZ1bmN0aW9uKGspe2kub25lcnJvcihrKX0pKTt2YXIgaD1bXSx4PVtcIm9uRXhpdFwiLFwib25BYm9ydFwiLFwicHJpbnRcIixcInByaW50RXJyXCJdLEE7Zm9yKEEgb2YgeClvLmhhc093blByb3BlcnR5KEEpJiZoLnB1c2goQSk7aS5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmgsdXJsT3JCbG9iOm8ubWFpblNjcmlwdFVybE9yQmxvYnx8ZSx3YXNtTWVtb3J5OndlLHdhc21Nb2R1bGU6U2V9KX0pLEJiOmZ1bmN0aW9uKGkpe2koKX0scWI6ZnVuY3Rpb24oKXt2YXIgaT1CKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53b3JrZXIuanNcIik7aT1uZXcgV29ya2VyKGkpLG5lLmFiLnB1c2goaSl9LHRiOmZ1bmN0aW9uKCl7cmV0dXJuIG5lLmFiLmxlbmd0aD09MCYmKG5lLnFiKCksbmUuQ2IobmUuYWJbMF0pKSxuZS5hYi5wb3AoKX19O28uUFRocmVhZD1uZTt2YXIgY3Q9aT0+e2Zvcig7MDxpLmxlbmd0aDspaS5zaGlmdCgpKG8pfTtvLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgaT1NcigpLGM9bigpW2krNTI+PjI+Pj4wXTtpPW4oKVtpKzU2Pj4yPj4+MF0sRGEoYyxjLWkpLERyKGMpfTtmdW5jdGlvbiBDcihpKXtpZihJKXJldHVybiBWKDIsMCxpKTtKdChpKX1vLmludm9rZUVudHJ5UG9pbnQ9ZnVuY3Rpb24oaSxjKXtpPXphLmFwcGx5KG51bGwsW2ksY10pLGV0KCk/bmUua2IoaSk6SW4oaSl9O2Z1bmN0aW9uIHR0KGkpe3RoaXMuZmI9aS0yNCx0aGlzLnBiPWZ1bmN0aW9uKGMpe3MoKVt0aGlzLmZiKzQ+PjI+Pj4wXT1jfSx0aGlzLm9iPWZ1bmN0aW9uKGMpe3MoKVt0aGlzLmZiKzg+PjI+Pj4wXT1jfSx0aGlzLmdiPWZ1bmN0aW9uKGMsaCl7dGhpcy5uYigpLHRoaXMucGIoYyksdGhpcy5vYihoKX0sdGhpcy5uYj1mdW5jdGlvbigpe3MoKVt0aGlzLmZiKzE2Pj4yPj4+MF09MH19dmFyIFllPTAsSXI9MDtmdW5jdGlvbiBfdChpLGMsaCx4KXtyZXR1cm4gST9WKDMsMSxpLGMsaCx4KTpRdChpLGMsaCx4KX1mdW5jdGlvbiBRdChpLGMsaCx4KXtpZihpPj4+PTAsYz4+Pj0wLGg+Pj49MCx4Pj4+PTAsdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiBxKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgQT1bXTtyZXR1cm4gSSYmQS5sZW5ndGg9PT0wP190KGksYyxoLHgpOihpPXtHYjpoLFhhOmkscmI6eCxNYjpBfSxJPyhpLk9iPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShpLEEpLDApOll0KGkpKX1mdW5jdGlvbiBadChpLGMsaCl7cmV0dXJuIEk/Vig0LDEsaSxjLGgpOjB9ZnVuY3Rpb24gQXIoaSxjKXtpZihJKXJldHVybiBWKDUsMSxpLGMpfXZhciBPdD1pPT57Zm9yKHZhciBjPTAsaD0wO2g8aS5sZW5ndGg7KytoKXt2YXIgeD1pLmNoYXJDb2RlQXQoaCk7MTI3Pj14P2MrKzoyMDQ3Pj14P2MrPTI6NTUyOTY8PXgmJjU3MzQzPj14PyhjKz00LCsraCk6Yys9M31yZXR1cm4gY30sRXI9KGksYyxoLHgpPT57aWYoaD4+Pj0wLCEoMDx4KSlyZXR1cm4gMDt2YXIgQT1oO3g9aCt4LTE7Zm9yKHZhciBrPTA7azxpLmxlbmd0aDsrK2spe3ZhciBOPWkuY2hhckNvZGVBdChrKTtpZig1NTI5Njw9TiYmNTczNDM+PU4pe3ZhciBhZT1pLmNoYXJDb2RlQXQoKytrKTtOPTY1NTM2KygoTiYxMDIzKTw8MTApfGFlJjEwMjN9aWYoMTI3Pj1OKXtpZihoPj14KWJyZWFrO2NbaCsrPj4+MF09Tn1lbHNle2lmKDIwNDc+PU4pe2lmKGgrMT49eClicmVhaztjW2grKz4+PjBdPTE5MnxOPj42fWVsc2V7aWYoNjU1MzU+PU4pe2lmKGgrMj49eClicmVhaztjW2grKz4+PjBdPTIyNHxOPj4xMn1lbHNle2lmKGgrMz49eClicmVhaztjW2grKz4+PjBdPTI0MHxOPj4xOCxjW2grKz4+PjBdPTEyOHxOPj4xMiY2M31jW2grKz4+PjBdPTEyOHxOPj42JjYzfWNbaCsrPj4+MF09MTI4fE4mNjN9fXJldHVybiBjW2g+Pj4wXT0wLGgtQX0sX3I9KGksYyxoKT0+RXIoaSxhKCksYyxoKTtmdW5jdGlvbiBPcihpLGMpe2lmKEkpcmV0dXJuIFYoNiwxLGksYyl9ZnVuY3Rpb24gVHIoaSxjLGgpe2lmKEkpcmV0dXJuIFYoNywxLGksYyxoKX1mdW5jdGlvbiBScihpLGMsaCl7cmV0dXJuIEk/Vig4LDEsaSxjLGgpOjB9ZnVuY3Rpb24gUHIoaSxjKXtpZihJKXJldHVybiBWKDksMSxpLGMpfWZ1bmN0aW9uIEd0KGksYyxoKXtpZihJKXJldHVybiBWKDEwLDEsaSxjLGgpfWZ1bmN0aW9uIGVyKGksYyxoLHgpe2lmKEkpcmV0dXJuIFYoMTEsMSxpLGMsaCx4KX1mdW5jdGlvbiB0cihpLGMsaCx4KXtpZihJKXJldHVybiBWKDEyLDEsaSxjLGgseCl9ZnVuY3Rpb24gcnIoaSxjLGgseCl7aWYoSSlyZXR1cm4gVigxMywxLGksYyxoLHgpfWZ1bmN0aW9uIG5yKGkpe2lmKEkpcmV0dXJuIFYoMTQsMSxpKX1mdW5jdGlvbiBhcihpLGMpe2lmKEkpcmV0dXJuIFYoMTUsMSxpLGMpfWZ1bmN0aW9uIG9yKGksYyxoKXtpZihJKXJldHVybiBWKDE2LDEsaSxjLGgpfXZhciBpcj1pPT57aWYoIVRlKXRyeXtpZihpKCksIWV0KCkpdHJ5e0k/SW4oRWUpOkp0KEVlKX1jYXRjaChjKXtjIGluc3RhbmNlb2YgeXR8fGM9PVwidW53aW5kXCJ8fHYoMSxjKX19Y2F0Y2goYyl7YyBpbnN0YW5jZW9mIHl0fHxjPT1cInVud2luZFwifHx2KDEsYyl9fTtmdW5jdGlvbiBGdChpKXtpPj4+PTAsdHlwZW9mIEF0b21pY3MuTmI9PVwiZnVuY3Rpb25cIiYmKEF0b21pY3MuTmIobigpLGk+PjIsaSkudmFsdWUudGhlbihUdCksaSs9MTI4LEF0b21pY3Muc3RvcmUobigpLGk+PjIsMSkpfW8uX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0PUZ0O2Z1bmN0aW9uIFR0KCl7dmFyIGk9TXIoKTtpJiYoRnQoaSksaXIoKCk9PkJhKCkpKX1vLmNoZWNrTWFpbGJveD1UdDt2YXIgYnQ9aT0+aSU0PT09MCYmKGklMTAwIT09MHx8aSU0MDA9PT0wKSxSdD1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxzcj1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiBkKGksYyxoLHgsQSxrLE4sYWUpe3JldHVybiBJP1YoMTcsMSxpLGMsaCx4LEEsayxOLGFlKTotNTJ9ZnVuY3Rpb24gZihpLGMsaCx4LEEsayxOKXtpZihJKXJldHVybiBWKDE4LDEsaSxjLGgseCxBLGssTil9dmFyIHc9aT0+e3ZhciBjPU90KGkpKzEsaD1TbihjKTtyZXR1cm4gaCYmX3IoaSxoLGMpLGh9LEM9W10sXz0oaSxjKT0+e0MubGVuZ3RoPTA7dmFyIGg7Zm9yKGM+Pj0yO2g9YSgpW2krKz4+PjBdOyljKz1oIT0xMDUmYyxDLnB1c2goaD09MTA1P24oKVtjPj4+MF06bCgpW2MrKz4+PjFdKSwrK2M7cmV0dXJuIEN9LEc9aT0+e3ZhciBjPUFuKCk7cmV0dXJuIGk9aSgpLERyKGMpLGl9O2Z1bmN0aW9uIFYoaSxjKXt2YXIgaD1hcmd1bWVudHMubGVuZ3RoLTIseD1hcmd1bWVudHM7cmV0dXJuIEcoKCk9Pntmb3IodmFyIEE9RW4oOCpoKSxrPUE+PjMsTj0wO048aDtOKyspe3ZhciBhZT14WzIrTl07bCgpW2srTj4+PjBdPWFlfXJldHVybiBrYShpLGgsQSxjKX0pfXZhciB1ZT1bXSxZPXt9LFo9KCk9PntpZighSil7dmFyIGk9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86Z3x8XCIuL3RoaXMucHJvZ3JhbVwifSxjO2ZvcihjIGluIFkpWVtjXT09PXZvaWQgMD9kZWxldGUgaVtjXTppW2NdPVlbY107dmFyIGg9W107Zm9yKGMgaW4gaSloLnB1c2goYCR7Y309JHtpW2NdfWApO0o9aH1yZXR1cm4gSn0sSjtmdW5jdGlvbiBjZShpLGMpe2lmKEkpcmV0dXJuIFYoMTksMSxpLGMpO2k+Pj49MCxjPj4+PTA7dmFyIGg9MDtyZXR1cm4gWigpLmZvckVhY2goZnVuY3Rpb24oeCxBKXt2YXIgaz1jK2g7Zm9yKEE9cygpW2krNCpBPj4yPj4+MF09ayxrPTA7azx4Lmxlbmd0aDsrK2spcigpW0ErKz4+MD4+PjBdPXguY2hhckNvZGVBdChrKTtyKClbQT4+MD4+PjBdPTAsaCs9eC5sZW5ndGgrMX0pLDB9ZnVuY3Rpb24gbWUoaSxjKXtpZihJKXJldHVybiBWKDIwLDEsaSxjKTtpPj4+PTAsYz4+Pj0wO3ZhciBoPVooKTtzKClbaT4+Mj4+PjBdPWgubGVuZ3RoO3ZhciB4PTA7cmV0dXJuIGguZm9yRWFjaChmdW5jdGlvbihBKXt4Kz1BLmxlbmd0aCsxfSkscygpW2M+PjI+Pj4wXT14LDB9ZnVuY3Rpb24gRShpKXtyZXR1cm4gST9WKDIxLDEsaSk6NTJ9ZnVuY3Rpb24gdGUoaSxjLGgseCl7cmV0dXJuIEk/VigyMiwxLGksYyxoLHgpOjUyfWZ1bmN0aW9uIGZlKGksYyxoLHgsQSl7cmV0dXJuIEk/VigyMywxLGksYyxoLHgsQSk6NzB9dmFyIHB0PVtudWxsLFtdLFtdXTtmdW5jdGlvbiB1cihpLGMsaCx4KXtpZihJKXJldHVybiBWKDI0LDEsaSxjLGgseCk7Yz4+Pj0wLGg+Pj49MCx4Pj4+PTA7Zm9yKHZhciBBPTAsaz0wO2s8aDtrKyspe3ZhciBOPXMoKVtjPj4yPj4+MF0sYWU9cygpW2MrND4+Mj4+PjBdO2MrPTg7Zm9yKHZhciBlZT0wO2VlPGFlO2VlKyspe3ZhciBRPWEoKVtOK2VlPj4+MF0scmU9cHRbaV07UT09PTB8fFE9PT0xMD8oKGk9PT0xP006cSkoU3IocmUsMCkpLHJlLmxlbmd0aD0wKTpyZS5wdXNoKFEpfUErPWFlfXJldHVybiBzKClbeD4+Mj4+PjBdPUEsMH12YXIgSWE9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxBYT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIHZsKGkpe3ZhciBjPUFycmF5KE90KGkpKzEpO3JldHVybiBFcihpLGMsMCxjLmxlbmd0aCksY312YXIgJGw9KGksYyk9PntyKCkuc2V0KGksYz4+PjApfTtmdW5jdGlvbiBFYShpLGMsaCx4KXtmdW5jdGlvbiBBKE8sc2UseWUpe2ZvcihPPXR5cGVvZiBPPT1cIm51bWJlclwiP08udG9TdHJpbmcoKTpPfHxcIlwiO08ubGVuZ3RoPHNlOylPPXllWzBdK087cmV0dXJuIE99ZnVuY3Rpb24gayhPLHNlKXtyZXR1cm4gQShPLHNlLFwiMFwiKX1mdW5jdGlvbiBOKE8sc2Upe2Z1bmN0aW9uIHllKEZhKXtyZXR1cm4gMD5GYT8tMTowPEZhPzE6MH12YXIgUHQ7cmV0dXJuKFB0PXllKE8uZ2V0RnVsbFllYXIoKS1zZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYoUHQ9eWUoTy5nZXRNb250aCgpLXNlLmdldE1vbnRoKCkpKT09PTAmJihQdD15ZShPLmdldERhdGUoKS1zZS5nZXREYXRlKCkpKSxQdH1mdW5jdGlvbiBhZShPKXtzd2l0Y2goTy5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBPO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBlZShPKXt2YXIgc2U9Ty5aYTtmb3IoTz1uZXcgRGF0ZShuZXcgRGF0ZShPLiRhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8c2U7KXt2YXIgeWU9Ty5nZXRNb250aCgpLFB0PShidChPLmdldEZ1bGxZZWFyKCkpP0lhOkFhKVt5ZV07aWYoc2U+UHQtTy5nZXREYXRlKCkpc2UtPVB0LU8uZ2V0RGF0ZSgpKzEsTy5zZXREYXRlKDEpLDExPnllP08uc2V0TW9udGgoeWUrMSk6KE8uc2V0TW9udGgoMCksTy5zZXRGdWxsWWVhcihPLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7Ty5zZXREYXRlKE8uZ2V0RGF0ZSgpK3NlKTticmVha319cmV0dXJuIHllPW5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSsxLDAsNCksc2U9YWUobmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsNCkpLHllPWFlKHllKSwwPj1OKHNlLE8pPzA+PU4oeWUsTyk/Ty5nZXRGdWxsWWVhcigpKzE6Ty5nZXRGdWxsWWVhcigpOk8uZ2V0RnVsbFllYXIoKS0xfWk+Pj49MCxjPj4+PTAsaD4+Pj0wLHg+Pj49MDt2YXIgUT1uKClbeCs0MD4+Mj4+PjBdO3g9e0tiOm4oKVt4Pj4yPj4+MF0sSmI6bigpW3grND4+Mj4+PjBdLGNiOm4oKVt4Kzg+PjI+Pj4wXSxpYjpuKClbeCsxMj4+Mj4+PjBdLGViOm4oKVt4KzE2Pj4yPj4+MF0sJGE6bigpW3grMjA+PjI+Pj4wXSxXYTpuKClbeCsyND4+Mj4+PjBdLFphOm4oKVt4KzI4Pj4yPj4+MF0sVGI6bigpW3grMzI+PjI+Pj4wXSxJYjpuKClbeCszNj4+Mj4+PjBdLExiOlE/VmUoUSk6XCJcIn0saD1WZShoKSxRPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciByZSBpbiBRKWg9aC5yZXBsYWNlKG5ldyBSZWdFeHAocmUsXCJnXCIpLFFbcmVdKTt2YXIgaGU9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxiZT1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7UT17XCIlYVwiOk89PmhlW08uV2FdLnN1YnN0cmluZygwLDMpLFwiJUFcIjpPPT5oZVtPLldhXSxcIiViXCI6Tz0+YmVbTy5lYl0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOk89PmJlW08uZWJdLFwiJUNcIjpPPT5rKChPLiRhKzE5MDApLzEwMHwwLDIpLFwiJWRcIjpPPT5rKE8uaWIsMiksXCIlZVwiOk89PkEoTy5pYiwyLFwiIFwiKSxcIiVnXCI6Tz0+ZWUoTykudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOk89PmVlKE8pLFwiJUhcIjpPPT5rKE8uY2IsMiksXCIlSVwiOk89PihPPU8uY2IsTz09MD9PPTEyOjEyPE8mJihPLT0xMiksayhPLDIpKSxcIiVqXCI6Tz0+e2Zvcih2YXIgc2U9MCx5ZT0wO3llPD1PLmViLTE7c2UrPShidChPLiRhKzE5MDApP0lhOkFhKVt5ZSsrXSk7cmV0dXJuIGsoTy5pYitzZSwzKX0sXCIlbVwiOk89PmsoTy5lYisxLDIpLFwiJU1cIjpPPT5rKE8uSmIsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjpPPT4wPD1PLmNiJiYxMj5PLmNiP1wiQU1cIjpcIlBNXCIsXCIlU1wiOk89PmsoTy5LYiwyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6Tz0+Ty5XYXx8NyxcIiVVXCI6Tz0+ayhNYXRoLmZsb29yKChPLlphKzctTy5XYSkvNyksMiksXCIlVlwiOk89Pnt2YXIgc2U9TWF0aC5mbG9vcigoTy5aYSs3LShPLldhKzYpJTcpLzcpO2lmKDI+PShPLldhKzM3MS1PLlphLTIpJTcmJnNlKyssc2Upc2U9PTUzJiYoeWU9KE8uV2ErMzcxLU8uWmEpJTcseWU9PTR8fHllPT0zJiZidChPLiRhKXx8KHNlPTEpKTtlbHNle3NlPTUyO3ZhciB5ZT0oTy5XYSs3LU8uWmEtMSklNzsoeWU9PTR8fHllPT01JiZidChPLiRhJTQwMC0xKSkmJnNlKyt9cmV0dXJuIGsoc2UsMil9LFwiJXdcIjpPPT5PLldhLFwiJVdcIjpPPT5rKE1hdGguZmxvb3IoKE8uWmErNy0oTy5XYSs2KSU3KS83KSwyKSxcIiV5XCI6Tz0+KE8uJGErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOk89Pk8uJGErMTkwMCxcIiV6XCI6Tz0+e089Ty5JYjt2YXIgc2U9MDw9TztyZXR1cm4gTz1NYXRoLmFicyhPKS82MCwoc2U/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoTy82MCoxMDArTyU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOk89Pk8uTGIsXCIlJVwiOigpPT5cIiVcIn0saD1oLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIik7Zm9yKHJlIGluIFEpaC5pbmNsdWRlcyhyZSkmJihoPWgucmVwbGFjZShuZXcgUmVnRXhwKHJlLFwiZ1wiKSxRW3JlXSh4KSkpO3JldHVybiBoPWgucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpLHJlPXZsKGgpLHJlLmxlbmd0aD5jPzA6KCRsKHJlLGkpLHJlLmxlbmd0aC0xKX1mdW5jdGlvbiBrcihpKXt0cnl7aSgpfWNhdGNoKGMpe0plKGMpfX1mdW5jdGlvbiB4bChpKXt2YXIgYz17fSxoO2ZvcihoIGluIGkpKGZ1bmN0aW9uKHgpe3ZhciBBPWlbeF07Y1t4XT10eXBlb2YgQT09XCJmdW5jdGlvblwiP2Z1bmN0aW9uKCl7QnIucHVzaCh4KTt0cnl7cmV0dXJuIEEuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZpbmFsbHl7VGV8fChCci5wb3AoKT09PXh8fEplKCkscnQmJnd0PT09MSYmQnIubGVuZ3RoPT09MCYmKHd0PTAsR2UrPTEsa3IoTmEpLHR5cGVvZiBGaWJlcnM8XCJ1XCImJkZpYmVycy5VYigpKSl9fTpBfSkoaCk7cmV0dXJuIGN9dmFyIHd0PTAscnQ9bnVsbCxfYT0wLEJyPVtdLE9hPXt9LFRhPXt9LFNsPTAseG49bnVsbCxDbD1bXTtmdW5jdGlvbiBJbCgpe3JldHVybiBuZXcgUHJvbWlzZSgoaSxjKT0+e3huPXtyZXNvbHZlOmkscmVqZWN0OmN9fSl9ZnVuY3Rpb24gQWwoKXt2YXIgaT1Tbig2NTU0OCksYz1pKzEyO3MoKVtpPj4yPj4+MF09YyxzKClbaSs0Pj4yPj4+MF09Yys2NTUzNixjPUJyWzBdO3ZhciBoPU9hW2NdO3JldHVybiBoPT09dm9pZCAwJiYoaD1TbCsrLE9hW2NdPWgsVGFbaF09YyksYz1oLG4oKVtpKzg+PjI+Pj4wXT1jLGl9ZnVuY3Rpb24gRWwoKXt2YXIgaT1uKClbcnQrOD4+Mj4+PjBdO3JldHVybiBpPWpbVGFbaV1dLC0tR2UsaSgpfWZ1bmN0aW9uIF9sKGkpe2lmKCFUZSl7aWYod3Q9PT0wKXt2YXIgYz0hMSxoPSExO2koKHg9MCk9PntpZighVGUmJihfYT14LGM9ITAsaCkpe3d0PTIsa3IoKCk9PlZhKHJ0KSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuaGIuc2ImJkJyb3dzZXIuaGIucmVzdW1lKCkseD0hMTt0cnl7dmFyIEE9RWwoKX1jYXRjaChhZSl7QT1hZSx4PSEwfXZhciBrPSExO2lmKCFydCl7dmFyIE49eG47TiYmKHhuPW51bGwsKHg/Ti5yZWplY3Q6Ti5yZXNvbHZlKShBKSxrPSEwKX1pZih4JiYhayl0aHJvdyBBfX0pLGg9ITAsY3x8KHd0PTEscnQ9QWwoKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5oYi5zYiYmQnJvd3Nlci5oYi5wYXVzZSgpLGtyKCgpPT5XYShydCkpKX1lbHNlIHd0PT09Mj8od3Q9MCxrcihVYSksUmEocnQpLHJ0PW51bGwsQ2wuZm9yRWFjaCh4PT5pcih4KSkpOkplKGBpbnZhbGlkIHN0YXRlOiAke3d0fWApO3JldHVybiBfYX19ZnVuY3Rpb24gT2woaSl7cmV0dXJuIF9sKGM9PntpKCkudGhlbihjKX0pfW5lLmdiKCk7dmFyIFRsPVtudWxsLFh0LENyLF90LFp0LEFyLE9yLFRyLFJyLFByLEd0LGVyLHRyLHJyLG5yLGFyLG9yLGQsZixjZSxtZSxFLHRlLGZlLHVyXSxSbD17cjpmdW5jdGlvbihpLGMsaCl7cmV0dXJuIE9sKGFzeW5jKCk9Pnthd2FpdCBvLnhiKGksYyxoKX0pfSxiOmZ1bmN0aW9uKGksYyxoKXt0aHJvdyBpPj4+PTAsbmV3IHR0KGkpLmdiKGM+Pj4wLGg+Pj4wKSxZZT1pLElyKyssWWV9LE86ZnVuY3Rpb24oaSl7UGEoaT4+PjAsIWIsMSwhJCwxMzEwNzIsITEpLG5lLmxiKCl9LGw6ZnVuY3Rpb24oaSl7aT4+Pj0wLEk/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6aX0pOlZ0KGkpfSxJOlF0LGk6WnQsVTpBcixFOk9yLEc6VHIsVjpScixTOlByLEs6R3QsUjplcixwOnRyLEY6cnIsQzpucixUOmFyLEQ6b3IscTooKT0+ITAsQTpmdW5jdGlvbihpLGMpe2k+Pj49MCxpPT1jPj4+MD9zZXRUaW1lb3V0KCgpPT5UdCgpKTpJP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6aSxjbWQ6XCJjaGVja01haWxib3hcIn0pOihpPW5lLlFhW2ldKSYmaS5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX0sTTpmdW5jdGlvbigpe3JldHVybi0xfSxOOkZ0LFg6ZnVuY3Rpb24oaSl7UyYmbmUuUWFbaT4+PjBdLnJlZigpfSx1OmZ1bmN0aW9uKGksYyxoKXtpPWMrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWk/KGk+Pj4wKSs0Mjk0OTY3Mjk2KmM6TmFOLGg+Pj49MCxpPW5ldyBEYXRlKDFlMyppKSxuKClbaD4+Mj4+PjBdPWkuZ2V0VVRDU2Vjb25kcygpLG4oKVtoKzQ+PjI+Pj4wXT1pLmdldFVUQ01pbnV0ZXMoKSxuKClbaCs4Pj4yPj4+MF09aS5nZXRVVENIb3VycygpLG4oKVtoKzEyPj4yPj4+MF09aS5nZXRVVENEYXRlKCksbigpW2grMTY+PjI+Pj4wXT1pLmdldFVUQ01vbnRoKCksbigpW2grMjA+PjI+Pj4wXT1pLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxuKClbaCsyND4+Mj4+PjBdPWkuZ2V0VVRDRGF5KCksaT0oaS5nZXRUaW1lKCktRGF0ZS5VVEMoaS5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MCxuKClbaCsyOD4+Mj4+PjBdPWl9LHY6ZnVuY3Rpb24oaSxjLGgpe2k9YysyMDk3MTUyPj4+MDw0MTk0MzA1LSEhaT8oaT4+PjApKzQyOTQ5NjcyOTYqYzpOYU4saD4+Pj0wLGk9bmV3IERhdGUoMWUzKmkpLG4oKVtoPj4yPj4+MF09aS5nZXRTZWNvbmRzKCksbigpW2grND4+Mj4+PjBdPWkuZ2V0TWludXRlcygpLG4oKVtoKzg+PjI+Pj4wXT1pLmdldEhvdXJzKCksbigpW2grMTI+PjI+Pj4wXT1pLmdldERhdGUoKSxuKClbaCsxNj4+Mj4+PjBdPWkuZ2V0TW9udGgoKSxuKClbaCsyMD4+Mj4+PjBdPWkuZ2V0RnVsbFllYXIoKS0xOTAwLG4oKVtoKzI0Pj4yPj4+MF09aS5nZXREYXkoKSxjPShidChpLmdldEZ1bGxZZWFyKCkpP1J0OnNyKVtpLmdldE1vbnRoKCldK2kuZ2V0RGF0ZSgpLTF8MCxuKClbaCsyOD4+Mj4+PjBdPWMsbigpW2grMzY+PjI+Pj4wXT0tKDYwKmkuZ2V0VGltZXpvbmVPZmZzZXQoKSksYz1uZXcgRGF0ZShpLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB4PW5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7aT0oYyE9eCYmaS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbih4LGMpKXwwLG4oKVtoKzMyPj4yPj4+MF09aX0sdzpmdW5jdGlvbihpKXtpPj4+PTA7dmFyIGM9bmV3IERhdGUobigpW2krMjA+PjI+Pj4wXSsxOTAwLG4oKVtpKzE2Pj4yPj4+MF0sbigpW2krMTI+PjI+Pj4wXSxuKClbaSs4Pj4yPj4+MF0sbigpW2krND4+Mj4+PjBdLG4oKVtpPj4yPj4+MF0sMCksaD1uKClbaSszMj4+Mj4+PjBdLHg9Yy5nZXRUaW1lem9uZU9mZnNldCgpLEE9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxrPW5ldyBEYXRlKGMuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCksTj1NYXRoLm1pbihrLEEpO3JldHVybiAwPmg/bigpW2krMzI+PjI+Pj4wXT0rKEEhPWsmJk49PXgpOjA8aCE9KE49PXgpJiYoQT1NYXRoLm1heChrLEEpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGg/TjpBKS14KSkpLG4oKVtpKzI0Pj4yPj4+MF09Yy5nZXREYXkoKSxoPShidChjLmdldEZ1bGxZZWFyKCkpP1J0OnNyKVtjLmdldE1vbnRoKCldK2MuZ2V0RGF0ZSgpLTF8MCxuKClbaSsyOD4+Mj4+PjBdPWgsbigpW2k+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxuKClbaSs0Pj4yPj4+MF09Yy5nZXRNaW51dGVzKCksbigpW2krOD4+Mj4+PjBdPWMuZ2V0SG91cnMoKSxuKClbaSsxMj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLG4oKVtpKzE2Pj4yPj4+MF09Yy5nZXRNb250aCgpLG4oKVtpKzIwPj4yPj4+MF09Yy5nZXRZZWFyKCksaT1jLmdldFRpbWUoKS8xZTMsTWEoKGR0PWksMTw9K01hdGguYWJzKGR0KT8wPGR0PytNYXRoLmZsb29yKGR0LzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKGR0LSsofn5kdD4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCkpLGk+Pj4wfSxzOmQsdDpmLHo6ZnVuY3Rpb24oaSxjLGgpe2Z1bmN0aW9uIHgoUSl7cmV0dXJuKFE9US50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9RWzFdOlwiR01UXCJ9aT4+Pj0wLGM+Pj49MCxoPj4+PTA7dmFyIEE9bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLGs9bmV3IERhdGUoQSwwLDEpLE49bmV3IERhdGUoQSw2LDEpO0E9ay5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBhZT1OLmdldFRpbWV6b25lT2Zmc2V0KCksZWU9TWF0aC5tYXgoQSxhZSk7cygpW2k+PjI+Pj4wXT02MCplZSxuKClbYz4+Mj4+PjBdPSsoQSE9YWUpLGk9eChrKSxjPXgoTiksaT13KGkpLGM9dyhjKSxhZTxBPyhzKClbaD4+Mj4+PjBdPWkscygpW2grND4+Mj4+PjBdPWMpOihzKClbaD4+Mj4+PjBdPWMscygpW2grND4+Mj4+PjBdPWkpfSxkOigpPT57SmUoXCJcIil9LGM6ZnVuY3Rpb24oaSxjLGgpe3JldHVybiBpPj4+PTAsYz1fKGM+Pj4wLGg+Pj4wKSxXdFtpXS5hcHBseShudWxsLGMpfSxrOmZ1bmN0aW9uKGksYyxoKXtyZXR1cm4gaT4+Pj0wLGM9XyhjPj4+MCxoPj4+MCksV3RbaV0uYXBwbHkobnVsbCxjKX0sbTpmdW5jdGlvbigpe30sajpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxXOigpPT57dGhyb3cgR2UrPTEsXCJ1bndpbmRcIn0sQjpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxmOigpPT5wZXJmb3JtYW5jZS50aW1lT3JpZ2luK3BlcmZvcm1hbmNlLm5vdygpLGc6ZnVuY3Rpb24oKXtyZXR1cm4gUz8oSW8oKSx2dChDbykpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LEw6ZnVuY3Rpb24oaSxjLGgseCl7Zm9yKG5lLlBiPWM+Pj4wLHVlLmxlbmd0aD1oLGM9eD4+PjA+PjMseD0wO3g8aDt4KyspdWVbeF09bCgpW2MreD4+PjBdO3JldHVybigwPmk/V3RbLWktMV06VGxbaV0pLmFwcGx5KG51bGwsdWUpfSx5OmZ1bmN0aW9uKGkpe2k+Pj49MDt2YXIgYz1hKCkubGVuZ3RoO2lmKGk8PWN8fDQyOTQ5MDE3NjA8aSlyZXR1cm4hMTtmb3IodmFyIGg9MTs0Pj1oO2gqPTIpe3ZhciB4PWMqKDErLjIvaCk7eD1NYXRoLm1pbih4LGkrMTAwNjYzMjk2KTt2YXIgQT1NYXRoO3g9TWF0aC5tYXgoaSx4KTtlOntBPUEubWluLmNhbGwoQSw0Mjk0OTAxNzYwLHgrKDY1NTM2LXglNjU1MzYpJTY1NTM2KS13ZS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2O3RyeXt3ZS5ncm93KEEpLHBlKCk7dmFyIGs9MTticmVhayBlfWNhdGNoe31rPXZvaWQgMH1pZihrKXJldHVybiEwfXJldHVybiExfSxQOmNlLFE6bWUsSDpKdCxoOkUsbzp0ZSx4OmZlLG46dXIsYTp3ZXx8by53YXNtTWVtb3J5LEo6RWEsZTpmdW5jdGlvbihpLGMsaCx4KXtyZXR1cm4gRWEoaT4+PjAsYz4+PjAsaD4+PjAseD4+PjApfX07KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gaShoLHgpe3JldHVybiBoPWguZXhwb3J0cyxoPXhsKGgpLGo9aD1QbChoKSxuZS5tYi5wdXNoKGouRGEpLE9lLnVuc2hpZnQoai5ZKSxTZT14LCRyKCksaH12YXIgYz17YTpSbH07aWYoanQoKSxvLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIG8uaW5zdGFudGlhdGVXYXNtKGMsaSl9Y2F0Y2goaCl7cShcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2gpLG0oaCl9cmV0dXJuIHhyKGMsZnVuY3Rpb24oaCl7aShoLmluc3RhbmNlLGgubW9kdWxlKX0pLmNhdGNoKG0pLHt9fSkoKSxvLl9PcnRJbml0PShpLGMpPT4oby5fT3J0SW5pdD1qLlopKGksYyksby5fT3J0R2V0TGFzdEVycm9yPShpLGMpPT4oby5fT3J0R2V0TGFzdEVycm9yPWouXykoaSxjKSxvLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oaSxjLGgseCxBLGssTixhZSxlZSxRKT0+KG8uX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWouJCkoaSxjLGgseCxBLGssTixhZSxlZSxRKSxvLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0oaSxjKT0+KG8uX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWouYWEpKGksYyksby5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShpLGMsaCk9PihvLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9ai5iYSkoaSxjLGgpLG8uX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0oaSxjLGgpPT4oby5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWouY2EpKGksYyxoKSxvLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9aT0+KG8uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1qLmRhKShpKSxvLl9PcnRDcmVhdGVTZXNzaW9uPShpLGMsaCk9PihvLl9PcnRDcmVhdGVTZXNzaW9uPWouZWEpKGksYyxoKSxvLl9PcnRSZWxlYXNlU2Vzc2lvbj1pPT4oby5fT3J0UmVsZWFzZVNlc3Npb249ai5mYSkoaSksby5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0oaSxjLGgpPT4oby5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1qLmdhKShpLGMsaCksby5fT3J0R2V0SW5wdXROYW1lPShpLGMpPT4oby5fT3J0R2V0SW5wdXROYW1lPWouaGEpKGksYyksby5fT3J0R2V0T3V0cHV0TmFtZT0oaSxjKT0+KG8uX09ydEdldE91dHB1dE5hbWU9ai5pYSkoaSxjKSxvLl9PcnRGcmVlPWk9PihvLl9PcnRGcmVlPWouamEpKGkpLG8uX09ydENyZWF0ZVRlbnNvcj0oaSxjLGgseCxBLGspPT4oby5fT3J0Q3JlYXRlVGVuc29yPWoua2EpKGksYyxoLHgsQSxrKSxvLl9PcnRHZXRUZW5zb3JEYXRhPShpLGMsaCx4LEEpPT4oby5fT3J0R2V0VGVuc29yRGF0YT1qLmxhKShpLGMsaCx4LEEpLG8uX09ydFJlbGVhc2VUZW5zb3I9aT0+KG8uX09ydFJlbGVhc2VUZW5zb3I9ai5tYSkoaSksby5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0oaSxjLGgseCk9PihvLl9PcnRDcmVhdGVSdW5PcHRpb25zPWoubmEpKGksYyxoLHgpLG8uX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShpLGMsaCk9PihvLl9PcnRBZGRSdW5Db25maWdFbnRyeT1qLm9hKShpLGMsaCksby5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9aT0+KG8uX09ydFJlbGVhc2VSdW5PcHRpb25zPWoucGEpKGkpLG8uX09ydENyZWF0ZUJpbmRpbmc9aT0+KG8uX09ydENyZWF0ZUJpbmRpbmc9ai5xYSkoaSksby5fT3J0QmluZElucHV0PShpLGMsaCk9PihvLl9PcnRCaW5kSW5wdXQ9ai5yYSkoaSxjLGgpLG8uX09ydEJpbmRPdXRwdXQ9KGksYyxoLHgpPT4oby5fT3J0QmluZE91dHB1dD1qLnNhKShpLGMsaCx4KSxvLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1pPT4oby5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9ai50YSkoaSksby5fT3J0UmVsZWFzZUJpbmRpbmc9aT0+KG8uX09ydFJlbGVhc2VCaW5kaW5nPWoudWEpKGkpLG8uX09ydFJ1bldpdGhCaW5kaW5nPShpLGMsaCx4LEEpPT4oby5fT3J0UnVuV2l0aEJpbmRpbmc9ai52YSkoaSxjLGgseCxBKSxvLl9PcnRSdW49KGksYyxoLHgsQSxrLE4sYWUpPT4oby5fT3J0UnVuPWoud2EpKGksYyxoLHgsQSxrLE4sYWUpLG8uX09ydEVuZFByb2ZpbGluZz1pPT4oby5fT3J0RW5kUHJvZmlsaW5nPWoueGEpKGkpLG8uX0pzZXBPdXRwdXQ9KGksYyxoKT0+KG8uX0pzZXBPdXRwdXQ9ai55YSkoaSxjLGgpLG8uX0pzZXBHZXROb2RlTmFtZT1pPT4oby5fSnNlcEdldE5vZGVOYW1lPWouemEpKGkpO3ZhciBNcj1vLl9wdGhyZWFkX3NlbGY9KCk9PihNcj1vLl9wdGhyZWFkX3NlbGY9ai5BYSkoKSxTbj1vLl9tYWxsb2M9aT0+KFNuPW8uX21hbGxvYz1qLkJhKShpKSxSYT1vLl9mcmVlPWk9PihSYT1vLl9mcmVlPWouQ2EpKGkpO28uX19lbXNjcmlwdGVuX3Rsc19pbml0PSgpPT4oby5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9ai5EYSkoKTt2YXIgUGE9by5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9KGksYyxoLHgsQSxrKT0+KFBhPW8uX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWouRmEpKGksYyxoLHgsQSxrKTtvLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD0oKT0+KG8uX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWouR2EpKCk7dmFyIGthPShpLGMsaCx4KT0+KGthPWouSGEpKGksYyxoLHgpLENuPWk9PihDbj1qLklhKShpKSxJbj1vLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1pPT4oSW49by5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ai5KYSkoaSksQmE9by5fX2Vtc2NyaXB0ZW5fY2hlY2tfbWFpbGJveD0oKT0+KEJhPW8uX19lbXNjcmlwdGVuX2NoZWNrX21haWxib3g9ai5LYSkoKSxNYT1pPT4oTWE9ai5MYSkoaSksRGE9KGksYyk9PihEYT1qLk1hKShpLGMpLEFuPSgpPT4oQW49ai5OYSkoKSxEcj1pPT4oRHI9ai5PYSkoaSksRW49aT0+KEVuPWouUGEpKGkpLHphPW8uZHluQ2FsbF9paT0oaSxjKT0+KHphPW8uZHluQ2FsbF9paT1qLlJhKShpLGMpLFdhPWk9PihXYT1qLlNhKShpKSxOYT0oKT0+KE5hPWouVGEpKCksVmE9aT0+KFZhPWouVWEpKGkpLFVhPSgpPT4oVWE9ai5WYSkoKTtvLl9fX3N0YXJ0X2VtX2pzPTkyNTc4MyxvLl9fX3N0b3BfZW1fanM9OTI1OTQ0O2Z1bmN0aW9uIFBsKGkpe2k9T2JqZWN0LmFzc2lnbih7fSxpKTt2YXIgYz14PT4oKT0+eCgpPj4+MCxoPXg9PkE9PngoQSk+Pj4wO3JldHVybiBpLl9fZXJybm9fbG9jYXRpb249YyhpLl9fZXJybm9fbG9jYXRpb24pLGkucHRocmVhZF9zZWxmPWMoaS5wdGhyZWFkX3NlbGYpLGkubWFsbG9jPWgoaS5tYWxsb2MpLGkuc3RhY2tTYXZlPWMoaS5zdGFja1NhdmUpLGkuc3RhY2tBbGxvYz1oKGkuc3RhY2tBbGxvYyksaX1vLmtlZXBSdW50aW1lQWxpdmU9ZXQsby53YXNtTWVtb3J5PXdlLG8uc3RhY2tBbGxvYz1FbixvLnN0YWNrU2F2ZT1BbixvLnN0YWNrUmVzdG9yZT1EcixvLlVURjhUb1N0cmluZz1WZSxvLnN0cmluZ1RvVVRGOD1fcixvLmxlbmd0aEJ5dGVzVVRGOD1PdCxvLkV4aXRTdGF0dXM9eXQsby5QVGhyZWFkPW5lO3ZhciB6cjtFdD1mdW5jdGlvbiBpKCl7enJ8fEdhKCksenJ8fChFdD1pKX07ZnVuY3Rpb24gR2EoKXtmdW5jdGlvbiBpKCl7aWYoIXpyJiYoenI9ITAsby5jYWxsZWRSdW49ITAsIVRlKSYmKEl8fGN0KE9lKSxwKG8pLG8ub25SdW50aW1lSW5pdGlhbGl6ZWQmJm8ub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwhSSkpe2lmKG8ucG9zdFJ1bilmb3IodHlwZW9mIG8ucG9zdFJ1bj09XCJmdW5jdGlvblwiJiYoby5wb3N0UnVuPVtvLnBvc3RSdW5dKTtvLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGM9by5wb3N0UnVuLnNoaWZ0KCk7emUudW5zaGlmdChjKX1jdCh6ZSl9fWlmKCEoMDxLZSkpaWYoSSlwKG8pLEl8fGN0KE9lKSxzdGFydFdvcmtlcihvKTtlbHNle2lmKG8ucHJlUnVuKWZvcih0eXBlb2Ygby5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKG8ucHJlUnVuPVtvLnByZVJ1bl0pO28ucHJlUnVuLmxlbmd0aDspSGUudW5zaGlmdChvLnByZVJ1bi5zaGlmdCgpKTtjdChIZSksMDxLZXx8KG8uc2V0U3RhdHVzPyhvLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dChmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtvLnNldFN0YXR1cyhcIlwiKX0sMSksaSgpfSwxKSk6aSgpKX19aWYoby5wcmVJbml0KWZvcih0eXBlb2Ygby5wcmVJbml0PT1cImZ1bmN0aW9uXCImJihvLnByZUluaXQ9W28ucHJlSW5pdF0pOzA8by5wcmVJbml0Lmxlbmd0aDspby5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIEdhKCksdC5yZWFkeX19KSgpO3R5cGVvZiBFbz09XCJvYmplY3RcIiYmdHlwZW9mIHpuPT1cIm9iamVjdFwiP3puLmV4cG9ydHM9QW86dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9PkFvKX0pO3ZhciBPbz1MdCgoZ2YsVWwpPT57VWwuZXhwb3J0cz0nXCJ1c2Ugc3RyaWN0XCI7dmFyIE1vZHVsZT17fSxFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIjtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXt2YXIgbm9kZVdvcmtlclRocmVhZHM9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLHBhcmVudFBvcnQ9bm9kZVdvcmtlclRocmVhZHMucGFyZW50UG9ydDtwYXJlbnRQb3J0Lm9uKFwibWVzc2FnZVwiLGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpO3ZhciBmcz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmUsTW9kdWxlLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpub2RlV29ya2VyVGhyZWFkcy5Xb3JrZXIsaW1wb3J0U2NyaXB0czplPT4oMCxldmFsKShmcy5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikrXCIvLyMgc291cmNlVVJMPVwiK2UpLHBvc3RNZXNzYWdlOmU9PnBhcmVudFBvcnQucG9zdE1lc3NhZ2UoZSkscGVyZm9ybWFuY2U6Z2xvYmFsLnBlcmZvcm1hbmNlfHx7bm93OkRhdGUubm93fX0pfXZhciBpbml0aWFsaXplZEpTPSExO2Z1bmN0aW9uIHRocmVhZFByaW50RXJyKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtmcy53cml0ZVN5bmMoMixlK2BcXG5gKTtyZXR1cm59Y29uc29sZS5lcnJvcihlKX1mdW5jdGlvbiB0aHJlYWRBbGVydCgpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7cG9zdE1lc3NhZ2Uoe2NtZDpcImFsZXJ0XCIsdGV4dDplLHRocmVhZElkOk1vZHVsZS5fcHRocmVhZF9zZWxmKCl9KX12YXIgZXJyPXRocmVhZFByaW50RXJyO3NlbGYuYWxlcnQ9dGhyZWFkQWxlcnQsTW9kdWxlLmluc3RhbnRpYXRlV2FzbT0oZSx0KT0+e3ZhciBhPU1vZHVsZS53YXNtTW9kdWxlO01vZHVsZS53YXNtTW9kdWxlPW51bGw7dmFyIHI9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGEsZSk7cmV0dXJuIHQocil9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29uPz9lfTtmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGUpe3RyeXtpZihlLmRhdGEuY21kPT09XCJsb2FkXCIpe2xldCBhPVtdO3NlbGYub25tZXNzYWdlPXI9PmEucHVzaChyKSxzZWxmLnN0YXJ0V29ya2VyPXI9PntNb2R1bGU9cixwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtmb3IobGV0IHMgb2YgYSloYW5kbGVNZXNzYWdlKHMpO3NlbGYub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2V9LE1vZHVsZS53YXNtTW9kdWxlPWUuZGF0YS53YXNtTW9kdWxlO2Zvcihjb25zdCByIG9mIGUuZGF0YS5oYW5kbGVycylNb2R1bGVbcl09KC4uLnMpPT57cG9zdE1lc3NhZ2Uoe2NtZDpcImNhbGxIYW5kbGVyXCIsaGFuZGxlcjpyLGFyZ3M6c30pfTtpZihNb2R1bGUud2FzbU1lbW9yeT1lLmRhdGEud2FzbU1lbW9yeSxNb2R1bGUuYnVmZmVyPU1vZHVsZS53YXNtTWVtb3J5LmJ1ZmZlcixNb2R1bGUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD0hMCx0eXBlb2YgZS5kYXRhLnVybE9yQmxvYj09XCJzdHJpbmdcIilpbXBvcnRTY3JpcHRzKGUuZGF0YS51cmxPckJsb2IpO2Vsc2V7dmFyIHQ9VVJMLmNyZWF0ZU9iamVjdFVSTChlLmRhdGEudXJsT3JCbG9iKTtpbXBvcnRTY3JpcHRzKHQpLFVSTC5yZXZva2VPYmplY3RVUkwodCl9b3J0V2FzbVRocmVhZGVkKE1vZHVsZSl9ZWxzZSBpZihlLmRhdGEuY21kPT09XCJydW5cIil7TW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdChlLmRhdGEucHRocmVhZF9wdHIsMCwwLDEpLE1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQoZS5kYXRhLnB0aHJlYWRfcHRyKSxNb2R1bGUuZXN0YWJsaXNoU3RhY2tTcGFjZSgpLE1vZHVsZS5QVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2ZlcihlLmRhdGEpLE1vZHVsZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxpbml0aWFsaXplZEpTfHwoaW5pdGlhbGl6ZWRKUz0hMCk7dHJ5e01vZHVsZS5pbnZva2VFbnRyeVBvaW50KGUuZGF0YS5zdGFydF9yb3V0aW5lLGUuZGF0YS5hcmcpfWNhdGNoKGEpe2lmKGEhPVwidW53aW5kXCIpdGhyb3cgYX19ZWxzZSBlLmRhdGEuY21kPT09XCJjYW5jZWxcIj9Nb2R1bGUuX3B0aHJlYWRfc2VsZigpJiZNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KC0xKTplLmRhdGEudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcInx8KGUuZGF0YS5jbWQ9PT1cImNoZWNrTWFpbGJveFwiP2luaXRpYWxpemVkSlMmJk1vZHVsZS5jaGVja01haWxib3goKTplLmRhdGEuY21kJiYoZXJyKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIitlLmRhdGEuY21kKSxlcnIoZS5kYXRhKSkpfWNhdGNoKGEpe3Rocm93IE1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQmJk1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSxhfX1zZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlO1xcbid9KTt2YXIgUm8sR2wsV24sTm4sanIsVG8sRmwsTGwsSGwsUG8sUGUsSHQ9TCgoKT0+e1widXNlIHN0cmljdFwiO1JvPSRvKCk7R2w9X28oKSxObj0hMSxqcj0hMSxUbz0hMSxGbD0oKT0+e3RyeXtyZXR1cm4gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiPyExOih0eXBlb2YgTWVzc2FnZUNoYW5uZWw8XCJ1XCImJm5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKSl9Y2F0Y2h7cmV0dXJuITF9fSxMbD0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxIbD0oZSx0KT0+ZT90P1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS1zaW1kLndhc21cIjp0P1wib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiLFBvPWFzeW5jIGU9PntpZihObilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoanIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoVG8pdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7anI9ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcyxhPWUuc2ltZCxuPXI+MSYmRmwoKSxzPWEmJkxsKCksdT1lLndhc21QYXRocyxsPXR5cGVvZiB1PT1cInN0cmluZ1wiP3U6dm9pZCAwLG89SGwocyxuKSxwPXR5cGVvZiB1PT1cIm9iamVjdFwiP3Vbb106dm9pZCAwLG09ITEseT1bXTtpZih0PjAmJnkucHVzaChuZXcgUHJvbWlzZShnPT57c2V0VGltZW91dCgoKT0+e209ITAsZygpfSx0KX0pKSx5LnB1c2gobmV3IFByb21pc2UoKGcsdik9PntsZXQgJD1uP0dsOlJvLGI9e2xvY2F0ZUZpbGU6KFMsSSk9PntpZihuJiZTLmVuZHNXaXRoKFwiLndvcmtlci5qc1wiKSYmdHlwZW9mIEJsb2I8XCJ1XCIpcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW09vKCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk7aWYoUy5lbmRzV2l0aChcIi53YXNtXCIpKXtpZihwKXJldHVybiBwO2xldCBUPWw/P0k7cmV0dXJuIG89PT1cIm9ydC13YXNtLXNpbWQud2FzbVwiP1QrXCJvcnQtd2FzbS1zaW1kLmpzZXAud2FzbVwiOm89PT1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiP1QrXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiOlQrb31yZXR1cm4gSStTfX07aWYobilpZih0eXBlb2YgQmxvYj5cInVcIiliLm1haW5TY3JpcHRVcmxPckJsb2I9KHZvaWQgMCkoX19kaXJuYW1lLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtsZXQgUz1gdmFyIG9ydFdhc21UaHJlYWRlZD0keyQudG9TdHJpbmcoKX07YDtiLm1haW5TY3JpcHRVcmxPckJsb2I9bmV3IEJsb2IoW1NdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KX0kKGIpLnRoZW4oUz0+e2pyPSExLE5uPSEwLFduPVMsZygpfSxTPT57anI9ITEsVG89ITAsdihTKX0pfSkpLGF3YWl0IFByb21pc2UucmFjZSh5KSxtKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sUGU9KCk9PntpZihObiYmV24pcmV0dXJuIFduO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfX0pO3ZhciBNZSxkcixBZSxxcj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SHQoKTtNZT0oZSx0KT0+e2xldCByPVBlKCksYT1yLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG49ci5fbWFsbG9jKGEpO3JldHVybiByLnN0cmluZ1RvVVRGOChlLG4sYSksdC5wdXNoKG4pLG59LGRyPShlLHQscixhKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYoci5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW24sc10pPT57bGV0IHU9dD90K246bjtpZih0eXBlb2Ygcz09XCJvYmplY3RcIilkcihzLHUrXCIuXCIscixhKTtlbHNlIGlmKHR5cGVvZiBzPT1cInN0cmluZ1wifHx0eXBlb2Ygcz09XCJudW1iZXJcIilhKHUscy50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiBzPT1cImJvb2xlYW5cIilhKHUscz9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2Ygc31gKX0pfSxBZT1lPT57bGV0IHQ9UGUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBhPXQuc3RhY2tBbGxvYyg4KTt0Ll9PcnRHZXRMYXN0RXJyb3IoYSxhKzQpO2xldCBuPXQuSEVBUDMyW2EvNF0scz10LkhFQVBVMzJbYS80KzFdLHU9cz90LlVURjhUb1N0cmluZyhzKTpcIlwiO3Rocm93IG5ldyBFcnJvcihgJHtlfSBFUlJPUl9DT0RFOiAke259LCBFUlJPUl9NRVNTQUdFOiAke3V9YCl9ZmluYWxseXt0LnN0YWNrUmVzdG9yZShyKX19fSk7dmFyIGtvLEJvPUwoKCk9PntcInVzZSBzdHJpY3RcIjtIdCgpO3FyKCk7a289ZT0+e2xldCB0PVBlKCkscj0wLGE9W10sbj1lfHx7fTt0cnl7aWYoZT8ubG9nU2V2ZXJpdHlMZXZlbD09PXZvaWQgMCluLmxvZ1NldmVyaXR5TGV2ZWw9MjtlbHNlIGlmKHR5cGVvZiBlLmxvZ1NldmVyaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nU2V2ZXJpdHlMZXZlbCl8fGUubG9nU2V2ZXJpdHlMZXZlbDwwfHxlLmxvZ1NldmVyaXR5TGV2ZWw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZihlPy5sb2dWZXJib3NpdHlMZXZlbD09PXZvaWQgMCluLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZih0eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO2U/LnRlcm1pbmF0ZT09PXZvaWQgMCYmKG4udGVybWluYXRlPSExKTtsZXQgcz0wO3JldHVybiBlPy50YWchPT12b2lkIDAmJihzPU1lKGUudGFnLGEpKSxyPXQuX09ydENyZWF0ZVJ1bk9wdGlvbnMobi5sb2dTZXZlcml0eUxldmVsLG4ubG9nVmVyYm9zaXR5TGV2ZWwsISFuLnRlcm1pbmF0ZSxzKSxyPT09MCYmQWUoXCJDYW4ndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZkcihlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHUsbCk9PntsZXQgbz1NZSh1LGEpLHA9TWUobCxhKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShyLG8scCkhPT0wJiZBZShgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHt1fSAtICR7bH0uYCl9KSxbcixhXX1jYXRjaChzKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMociksYS5mb3JFYWNoKHU9PnQuX2ZyZWUodSkpLHN9fX0pO3ZhciBqbCxxbCxLbCxZbCxNbyxEbz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SHQoKTtxcigpO2psPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7ZX1gKX19LHFsPWU9Pntzd2l0Y2goZSl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke2V9YCl9fSxLbD1lPT57ZS5leHRyYXx8KGUuZXh0cmE9e30pLGUuZXh0cmEuc2Vzc2lvbnx8KGUuZXh0cmEuc2Vzc2lvbj17fSk7bGV0IHQ9ZS5leHRyYS5zZXNzaW9uO3QudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseXx8KHQudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseT1cIjFcIiksZS5leGVjdXRpb25Qcm92aWRlcnMmJmUuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUocj0+KHR5cGVvZiByPT1cInN0cmluZ1wiP3I6ci5uYW1lKT09PVwid2ViZ3B1XCIpJiYoZS5lbmFibGVNZW1QYXR0ZXJuPSExKX0sWWw9KGUsdCxyKT0+e2ZvcihsZXQgYSBvZiB0KXtsZXQgbj10eXBlb2YgYT09XCJzdHJpbmdcIj9hOmEubmFtZTtzd2l0Y2gobil7Y2FzZVwieG5ucGFja1wiOm49XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2Vibm5cIjppZihuPVwiV0VCTk5cIix0eXBlb2YgYSE9XCJzdHJpbmdcIil7bGV0IHU9YTtpZih1Py5kZXZpY2VUeXBlKXtsZXQgbD1NZShcImRldmljZVR5cGVcIixyKSxvPU1lKHUuZGV2aWNlVHlwZSxyKTtQZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxsLG8pIT09MCYmQWUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke3UuZGV2aWNlVHlwZX0uYCl9aWYodT8ucG93ZXJQcmVmZXJlbmNlKXtsZXQgbD1NZShcInBvd2VyUHJlZmVyZW5jZVwiLHIpLG89TWUodS5wb3dlclByZWZlcmVuY2Uscik7UGUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsbCxvKSE9PTAmJkFlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3Bvd2VyUHJlZmVyZW5jZScgLSAke3UucG93ZXJQcmVmZXJlbmNlfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYobj1cIkpTXCIsdHlwZW9mIGEhPVwic3RyaW5nXCIpe2xldCB1PWE7aWYodT8ucHJlZmVycmVkTGF5b3V0KXtpZih1LnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZ1LnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7dS5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGw9TWUoXCJwcmVmZXJyZWRMYXlvdXRcIixyKSxvPU1lKHUucHJlZmVycmVkTGF5b3V0LHIpO1BlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGwsbykhPT0wJiZBZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHt1LnByZWZlcnJlZExheW91dH0uYCl9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7bn1gKX1sZXQgcz1NZShuLHIpO1BlKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUscykhPT0wJiZBZShgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtufS5gKX19LE1vPWU9PntsZXQgdD1QZSgpLHI9MCxhPVtdLG49ZXx8e307S2wobik7dHJ5e2xldCBzPWpsKG4uZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIiksdT1xbChuLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxsPXR5cGVvZiBuLmxvZ0lkPT1cInN0cmluZ1wiP01lKG4ubG9nSWQsYSk6MCxvPW4ubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcihvKXx8bzwwfHxvPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvfWApO2xldCBwPW4ubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIocCl8fHA8MHx8cD40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7cH1gKTtsZXQgbT10eXBlb2Ygbi5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP01lKG4ub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxhKTowO2lmKHI9dC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMocywhIW4uZW5hYmxlQ3B1TWVtQXJlbmEsISFuLmVuYWJsZU1lbVBhdHRlcm4sdSwhIW4uZW5hYmxlUHJvZmlsaW5nLDAsbCxvLHAsbSkscj09PTAmJkFlKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksbi5leGVjdXRpb25Qcm92aWRlcnMmJllsKHIsbi5leGVjdXRpb25Qcm92aWRlcnMsYSksbi5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbeSxnXW9mIE9iamVjdC5lbnRyaWVzKG4uZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiB5IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke3l9YCk7aWYodHlwZW9mIGchPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGcpfHxnPDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7Z31gKTtsZXQgdj1NZSh5LGEpO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShyLHYsZykhPT0wJiZBZShgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7eX0gLSAke2d9LmApfXJldHVybiBuLmV4dHJhIT09dm9pZCAwJiZkcihuLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHksZyk9PntsZXQgdj1NZSh5LGEpLCQ9TWUoZyxhKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocix2LCQpIT09MCYmQWUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3l9IC0gJHtnfS5gKX0pLFtyLGFdfWNhdGNoKHMpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMociksYS5mb3JFYWNoKHU9PnQuX2ZyZWUodSkpLHN9fX0pO3ZhciBWbixjcixwcixLcixmcixZcixVbixEZT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Vm49ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LGNyPWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxwcj1lPT5bdm9pZCAwLDQsMSwxLDIsMiw0LDgsdm9pZCAwLDEsMiw4LDQsOCx2b2lkIDAsdm9pZCAwLHZvaWQgMF1bZV0sS3I9ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxmcj1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sWXI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJib29sXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwidWludDMyXCIsVW49ZT0+e3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7ZX1gKX19fSk7dmFyIFhsLEpsLHpvLFdvLE5vLFFsLF9lLHh0PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO1hsPVtcIlZcIixcIklcIixcIldcIixcIkVcIixcIkZcIl0sSmw9KGUsdCk9Pntjb25zb2xlLmxvZyhgWyR7WGxbZV19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke3R9YCl9LE5vPShlLHQpPT57em89ZSxXbz10fSxRbD0oZSx0KT0+e2xldCByPWZyKGUpLGE9ZnIoem8pO3I+PWEmJkpsKHIsdHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj90KCk6dCl9LF9lPSguLi5lKT0+e1dvJiZRbCguLi5lKX19KTt2YXIgVm8sVW89TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Vm89KGUsdCk9Pm5ldyhLcih0KSkoZSl9KTt2YXIgR289TCgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFhyLFpsLEZvLEZuLEduLExvLEhvPUwoKCk9PntcInVzZSBzdHJpY3RcIjt4dCgpO0dvKCk7WHI9ZT0+TWF0aC5jZWlsKGUvMTYpKjE2LFpsPTEsRm89KCk9PlpsKyssRm49YXN5bmMoZSx0LHIsYSk9PntsZXQgbj1YcihyKSxzPWUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7dHJ5e2xldCB1PWUuZ2V0Q29tbWFuZEVuY29kZXIoKTtlLmVuZENvbXB1dGVQYXNzKCksdS5jb3B5QnVmZmVyVG9CdWZmZXIodCwwLHMsMCxuKSxlLmZsdXNoKCksYXdhaXQgcy5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2xldCBsPXMuZ2V0TWFwcGVkUmFuZ2UoKTtpZihhKXtsZXQgbz1hKCk7cmV0dXJuIG8uc2V0KG5ldyBVaW50OEFycmF5KGwsMCxyKSksb31lbHNlIHJldHVybiBuZXcgVWludDhBcnJheShsLnNsaWNlKDAscikpfWZpbmFsbHl7cy5kZXN0cm95KCl9fSxHbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc9W10sdGhpcy5idWZmZXJzUGVuZGluZz1bXSx0aGlzLmV4dGVybmFsQnVmZmVycz1uZXcgTWFwfXVwbG9hZCh0LHIpe2xldCBhPXIuYnVmZmVyLG49ci5ieXRlT2Zmc2V0LHM9ci5ieXRlTGVuZ3RoLHU9WHIocyksbD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihsLm9yaWdpbmFsU2l6ZSE9PXMpdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7bC5vcmlnaW5hbFNpemV9LCBkYXRhIHNpemU9JHtzfWApO2xldCBvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHttYXBwZWRBdENyZWF0aW9uOiEwLHNpemU6dSx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEV8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KSxwPW8uZ2V0TWFwcGVkUmFuZ2UoKTtuZXcgVWludDhBcnJheShwKS5zZXQobmV3IFVpbnQ4QXJyYXkoYSxuLHMpKSxvLnVubWFwKCk7bGV0IG09dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksbS5jb3B5QnVmZmVyVG9CdWZmZXIobywwLGwuZ3B1RGF0YS5idWZmZXIsMCx1KSxfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke3R9KWApLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcucHVzaChvKX1tZW1jcHkodCxyKXtsZXQgYT10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHIpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYoYS5vcmlnaW5hbFNpemUhPT1uLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2xldCBzPVhyKGEub3JpZ2luYWxTaXplKSx1PXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHUuY29weUJ1ZmZlclRvQnVmZmVyKGEuZ3B1RGF0YS5idWZmZXIsMCxuLmdwdURhdGEuYnVmZmVyLDAscyl9cmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0LHIsYSl7bGV0IG47aWYoYSl7aWYobj10aGlzLmV4dGVybmFsQnVmZmVycy5nZXQoYSksbj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBidWZmZXIgaXMgbm90IHJlZ2lzdGVyZWRcIik7aWYodD09PWEpcmV0dXJuIF9lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7bn0sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKSxuO3RoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZShhKX1lbHNlIG49Rm8oKTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KG4se2dwdURhdGE6e2lkOm4sdHlwZTowLGJ1ZmZlcjp0fSxvcmlnaW5hbFNpemU6cn0pLHRoaXMuZXh0ZXJuYWxCdWZmZXJzLnNldCh0LG4pLF9lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7bn0sIHJlZ2lzdGVyZWQuYCksbn11bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCl7bGV0IHI9dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KHQpO3IhPT12b2lkIDAmJih0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUociksdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKHQpLF9lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHtyfWApKX1jcmVhdGUodCxyPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1Qpe2xldCBhPVhyKHQpLG4scz0ociZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UsdT0ociZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07aWYoc3x8dSl7bGV0IG89cz90aGlzLmZyZWVCdWZmZXJzOnRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLHA9by5nZXQoYSk7cHx8KHA9W10sby5zZXQoYSxwKSkscC5sZW5ndGg+MD9uPXAucG9wKCk6bj10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTphLHVzYWdlOnJ9KX1lbHNlIG49dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6YSx1c2FnZTpyfSk7bGV0IGw9e2lkOkZvKCksdHlwZTowLGJ1ZmZlcjpufTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGwuaWQse2dwdURhdGE6bCxvcmlnaW5hbFNpemU6dH0pLF9lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHt0fSkgPT4gaWQ9JHtsLmlkfWApLGx9Z2V0KHQpe3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk/LmdwdURhdGF9cmVsZWFzZSh0KXtsZXQgcj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwicmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3RcIik7cmV0dXJuIF9lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke3R9KSwgZ3B1RGF0YUlkPSR7ci5ncHVEYXRhLmlkfWApLHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZSh0KSx0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goci5ncHVEYXRhLmJ1ZmZlciksci5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQodCxyKXtsZXQgYT10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCBGbih0aGlzLmJhY2tlbmQsYS5ncHVEYXRhLmJ1ZmZlcixhLm9yaWdpbmFsU2l6ZSxyKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyl0LmRlc3Ryb3koKTt0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nPVtdO2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRT90aGlzLmZyZWVCdWZmZXJzLmdldCh0LnNpemUpLnB1c2godCk6KHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNP3RoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldCh0LnNpemUpLnB1c2godCk6dC5kZXN0cm95KCk7dGhpcy5idWZmZXJzUGVuZGluZz1bXX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXB9fSxMbz0oLi4uZSk9Pm5ldyBHbiguLi5lKX0pO3ZhciBMbixpZSxrZT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TG49Y2xhc3N7Y29uc3RydWN0b3IodCl7T2JqZWN0LmFzc2lnbih0aGlzLHQpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLl9jYWNoZUtleXx8KHRoaXMuX2NhY2hlS2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAodD0+YCR7dGhpc1t0XX1gKS5qb2luKFwiO1wiKSksdGhpcy5fY2FjaGVLZXl9fSxpZT1lPT5uZXcgTG4oZSl9KTt2YXIgSG4sbnQseixNdCxKcixRcixacixnZT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SG49Y2xhc3N7c3RhdGljIGNhbGNNYXRNdWxTaGFwZSh0LHIpe3JldHVybiB0WzFdIT09clswXT92b2lkIDA6W3RbMF0sclsxXV19fSxudD1jbGFzc3tzdGF0aWMgY2FsY1NoYXBlKHQscixhPSExKXtsZXQgbj10Lmxlbmd0aCxzPXIubGVuZ3RoO2lmKG49PT0wKXJldHVybiByO2lmKHM9PT0wKXJldHVybiB0O2xldCB1PU1hdGgubWF4KHQubGVuZ3RoLHIubGVuZ3RoKSxsPW5ldyBBcnJheSh1KTtpZihhKXtpZihuPDJ8fHM8MilyZXR1cm47bGV0IG89SG4uY2FsY01hdE11bFNoYXBlKFt0W24tMl0sdFtuLTFdXSxbcltzLTJdLHJbcy0xXV0pO2lmKG89PT12b2lkIDApcmV0dXJuO1tsW3UtMl0sbFt1LTFdXT1vfWZvcihsZXQgbz1hPzM6MTtvPD11O28rKyl7bGV0IHA9bi1vPDA/MTp0W24tb10sbT1zLW88MD8xOnJbcy1vXTtpZihwIT09bSYmcD4xJiZtPjEpcmV0dXJuO2xbdS1vXT1NYXRoLm1heChwLG0pfXJldHVybiBsfXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHQscil7bGV0IGE9dC5sZW5ndGgsbj1yLmxlbmd0aDtpZihhPm4pcmV0dXJuITE7Zm9yKGxldCBzPTE7czw9YTtzKyspaWYodFthLXNdIT09MSYmdFthLXNdIT09cltuLXNdKXJldHVybiExO3JldHVybiEwfX0sej1jbGFzcyBle3N0YXRpYyBzaXplKHQpe3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHIpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscixhKXtsZXQgbj0xO2ZvcihsZXQgcz1yO3M8YTtzKyspe2lmKHRbc108MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO24qPXRbc119cmV0dXJuIG59c3RhdGljIGNvbXB1dGVTdHJpZGVzKHQpe2xldCByPXQubGVuZ3RoO2lmKHI9PT0wKXJldHVybltdO2lmKHI9PT0xKXJldHVyblsxXTtsZXQgYT1uZXcgQXJyYXkocik7YVtyLTFdPTEsYVtyLTJdPXRbci0xXTtmb3IobGV0IG49ci0zO24+PTA7LS1uKWFbbl09YVtuKzFdKnRbbisxXTtyZXR1cm4gYX1zdGF0aWMgbm9ybWFsaXplQXhpcyh0LHIpe2lmKHQ8LXImJnQ+PXIpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiB0PDA/dCtyOnR9c3RhdGljIG5vcm1hbGl6ZUF4ZXModCxyKXtyZXR1cm4gdC5tYXAoYT0+dGhpcy5ub3JtYWxpemVBeGlzKGEscj8/dC5sZW5ndGgpKX1zdGF0aWMgc29ydEJhc2VkT25QZXJtKHQscil7cmV0dXJuIHI/ci5tYXAoYT0+dFthXSk6dC5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUodCxyKXtsZXQgYT10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKG4scyk9Pm4rcltzXStyW3MrYV0pfXN0YXRpYyBhcmVFcXVhbCh0LHIpe3JldHVybiB0Lmxlbmd0aCE9PXIubGVuZ3RoPyExOnQuZXZlcnkoKGEsbik9PmE9PT1yW25dKX19LE10PWNsYXNzIGV7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQscixhLG4scyx1KXtpZighdCYmYS5sZW5ndGghPT1yLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IGw9MDtsPHIubGVuZ3RoLTI7bCsrKWw+PWEubGVuZ3RoP2EucHVzaChyW2wrMl0pOmFbbF09cltsKzJdO2ZvcihsZXQgbD0wO2w8YS5sZW5ndGg7bCsrKWlmKGw8bi5sZW5ndGgpe2lmKG5bbF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIG4ucHVzaCgxKTtmb3IobGV0IGw9MDtsPGEubGVuZ3RoO2wrKylpZihsPHMubGVuZ3RoKXtpZihzW2xdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHMucHVzaCgxKTtmb3IobGV0IGw9MDtsPGEubGVuZ3RoKjI7bCsrKWlmKGw8dS5sZW5ndGgpe2lmKHVbbF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgdS5wdXNoKDApO2ZvcihsZXQgbD0wO2w8YS5sZW5ndGg7bCsrKXtpZihhW2xdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZih1W2xdPj1hW2xdfHx1W2wrYS5sZW5ndGhdPj1hW2xdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxyLGEsbixzLHUsbCl7aWYobCl7aWYocy5sZW5ndGghPT0yKih0Lmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihuLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgbz0wO288dC5sZW5ndGgtMjtvKyspZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W28rKHU/MToyKV0scltvXSxhW29dLG5bb10scyxvLG8rdC5sZW5ndGgtMixsKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUodCxyLGEsbixzLHUsbCl7aWYoci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2xldCBvPVtyWzBdLHJbMV1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcih0LHIsbyxhLG4scyx1LGwpLG99c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxyLGEsbixzLHUsbCl7aWYodC5sZW5ndGg8PTB8fHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7bGV0IG89W3RbMF0sclswXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKCExLHQsbyxhLG4scyx1LGwpLG99c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcih0LHIsYSxuLHMsdSxsLG8pe2lmKHQpZm9yKGxldCBwPTA7cDxyLmxlbmd0aC0yO3ArKylhLnB1c2goMSk7ZWxzZSBmb3IobGV0IHA9MDtwPHIubGVuZ3RoLTI7cCsrKWEucHVzaChlLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHJbcCsyXSxuW3BdLHNbcF0sdVtwXSxsLHAscCtyLmxlbmd0aC0yLG8pKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodCxyLGEsbixzLHUsbCxvKXtsZXQgcD1hKihuLTEpKzE7aWYobyYmbyE9PVwiTk9UU0VUXCIpc3dpdGNoKG8pe2Nhc2VcIlZBTElEXCI6cmV0dXJuIHNbdV09MCxzW2xdPTAsTWF0aC5mbG9vcigodC1wKS9yKzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYoYSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tsZXQgeT0oKHQrci0xKS9yLTEpKnIrbi10O3JldHVybiBzW3VdPU1hdGguZmxvb3Iobz09PVwiU0FNRV9MT1dFUlwiPyh5KzEpLzI6eS8yKSxzW2xdPXktc1t1XSxNYXRoLmZsb29yKCh0K3ktbikvcisxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX1lbHNlIHJldHVybiBNYXRoLmZsb29yKCh0K3NbdV0rc1tsXS1wKS9yKzEpfX0sSnI9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQscixhLG4scyl7aWYodC5sZW5ndGghPT0yfHxhLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IHUsbCxvO3I/KHU9dFsxXSxsPXRbMF0pOih1PXRbMF0sbD10WzFdKTtsZXQgcD0tMTtpZihuPyhvPWFbMF0scD0xKToobz1hWzFdLHA9MCksYVtwXSE9PWwpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKHU8PTB8fG88PTB8fGw8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYocyYmIW50LmlzVmFsaWRCcm9hZGNhc3QocyxbdSxvXSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW3UsbyxsXX19LFFyPS0zNDAyODIzNDY2Mzg1Mjg4NmUyMixacj0zNDAyODIzNDY2Mzg1Mjg4NmUyMn0pO3ZhciBlZCxqbyxCZSxxbixtdCxRZSxEdCxTdCxxbyxGLFgsam4sS28sS24sWW8sdmU9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtlZD02NCxqbz0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKGUpe2Nhc2UgMTA6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMTY+YDpcImYxNlwiO2Nhc2UgMTpyZXR1cm4gdD4xP2B2ZWMke3R9PGYzMj5gOlwiZjMyXCI7Y2FzZSA2OnJldHVybiB0PjE/YHZlYyR7dH08aTMyPmA6XCJpMzJcIjtjYXNlIDEyOnJldHVybiB0PjE/YHZlYyR7dH08dTMyPmA6XCJ1MzJcIjtjYXNlIDc6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcImkzMlwiXTtjYXNlIDEzOmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJ1MzJcIl07Y2FzZSA5OmlmKHQhPT00KXRocm93IG5ldyBFcnJvcihcImJvb2wgbXVzdCBiZSB2ZWM0XCIpO3JldHVybltcInUzMlwiLFwidmVjNDxib29sPlwiXTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7ZX1gKX19LEJlPShlLHQ9MSk9PntsZXQgcj1qbyhlLHQpO3JldHVybiB0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnJbMF19LHFuPWU9Plt7dHlwZTpcInVpbnQzMlwiLGRhdGE6ZX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnouY29tcHV0ZVN0cmlkZXMoZSl9XSxtdD1lPT5lJTQ9PT0wPzQ6ZSUyPT09MD8yOjEsUWU9KGU9XCJmMzJcIix0LHI9XCIwXCIpPT4hdHx8dD09PTE/YCR7ZX0oJHtyfSlgOmB2ZWMke3R9PCR7ZX0+KCR7cn0pYCxEdD0oZSx0LHIpPT5lPT09XCJmMzJcIj9yOnQ9PT0xP2BmMzIoJHtyfSlgOmB2ZWMke3R9Zigke3J9KWAsU3Q9KGUsdCk9PnQ9PT00P2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56ICsgJHtlfS53KWA6dD09PTI/YCgke2V9LnggKyAke2V9LnkpYDp0PT09Mz9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueilgOmUscW89KGUsdCxyLGEsbik9PntsZXQgcz10eXBlb2Ygcj09XCJudW1iZXJcIix1PXM/cjpyLmxlbmd0aCxsPVsuLi5uZXcgQXJyYXkodSkua2V5cygpXSxvPXU8Mj9cInUzMlwiOnU8PTQ/YHZlYyR7dX08dTMyPmA6YGFycmF5PHUzMiwgJHt1fT5gLHA9am8odCxuKSxtPXR5cGVvZiBwPT1cInN0cmluZ1wiP3A6cFsxXSx5PXR5cGVvZiBwPT1cInN0cmluZ1wiP3A6cFswXSxnPXtpbmRpY2VzOm8sdmFsdWU6bSxzdG9yYWdlOnksdGVuc29yOnR9LHY9VT0+dHlwZW9mIFU9PVwic3RyaW5nXCI/VTpgJHtVfXVgLCQ9e29mZnNldFRvSW5kaWNlczohMSxpbmRpY2VzVG9PZmZzZXQ6ITEsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ITEsc2V0OiExLHNldEJ5SW5kaWNlczohMSxnZXQ6ITEsZ2V0QnlJbmRpY2VzOiExfSxiPXM/XCJ1bmlmb3Jtcy5cIjpcIlwiLFM9YCR7Yn0ke2V9X3NoYXBlYCxJPWAke2J9JHtlfV9zdHJpZGVzYCxUPVwiXCI7Zm9yKGxldCBVPTA7VTx1LTE7VSsrKVQrPWBcbiAgICBsZXQgZGltJHtVfSA9IGN1cnJlbnQgLyAke0l9WyR7VX1dO1xuICAgIGxldCByZXN0JHtVfSA9IGN1cnJlbnQgJSAke0l9WyR7VX1dO1xuICAgIGluZGljZXNbJHtVfV0gPSBkaW0ke1V9O1xuICAgIGN1cnJlbnQgPSByZXN0JHtVfTtcbiAgICBgO1QrPWBpbmRpY2VzWyR7dS0xfV0gPSBjdXJyZW50O2A7bGV0IEI9dTwyP1wiXCI6YFxuICBmbiBvMmlfJHtlfShvZmZzZXQ6IHUzMikgLT4gJHtnLmluZGljZXN9IHtcbiAgICB2YXIgaW5kaWNlczogJHtnLmluZGljZXN9O1xuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xuICAgICR7VH1cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfWAsUD1VPT4oJC5vZmZzZXRUb0luZGljZXM9ITAsdTwyP1U6YG8yaV8ke2V9KCR7VX0pYCksRD1bXTtpZih1Pj0yKWZvcihsZXQgVT11LTE7VT49MDtVLS0pRC5wdXNoKGAke0l9WyR7VX1dICogKGluZGljZXNbJHtVfV0pYCk7bGV0IFI9dTwyP1wiXCI6YFxuICBmbiBpMm9fJHtlfShpbmRpY2VzOiAke2cuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgcmV0dXJuICR7RC5qb2luKFwiK1wiKX07XG4gIH1gLFc9VT0+KCQuaW5kaWNlc1RvT2Zmc2V0PSEwLHU8Mj9VOmBpMm9fJHtlfSgke1V9KWApLEg9KC4uLlUpPT51PT09MD9cIjB1XCI6YCR7Zy5pbmRpY2VzfSgke1UubWFwKHYpLmpvaW4oXCIsXCIpfSlgLEs9KFUsZGUpPT51PDI/YCR7VX1gOmAke1V9WyR7ZGV9XWAsbGU9KFUsZGUscGUpPT51PDI/YCR7VX09JHtwZX07YDpgJHtVfVske2RlfV09JHtwZX07YCxNPXt9LHE9KFUsZGUpPT57JC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgcGU9YCR7ZGUubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKHBlIGluIE0pcmV0dXJuYCR7cGV9KCR7VX0pYDtsZXQgTmU9W107Zm9yKGxldCBIZT11LTE7SGU+PTA7SGUtLSl7bGV0IE9lPWRlLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsSGUrZGUucmFuay11KTtOZS5wdXNoKGAke0soSSxIZSl9ICogKCR7T2V9ICUgJHtLKFMsSGUpfSlgKX1yZXR1cm4gTVtwZV09YGZuICR7cGV9KG91dHB1dEluZGljZXM6ICR7ZGUudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgICByZXR1cm4gJHtOZS5sZW5ndGg+MD9OZS5qb2luKFwiK1wiKTpcIjB1XCJ9O1xuICAgICAgICAgICB9YCxgJHtwZX0oJHtVfSlgfSx4ZT0oVSxkZSk9PigoKT0+e2lmKGcuc3RvcmFnZT09PWcudmFsdWUpcmV0dXJuYCR7ZX1bJHtVfV09JHtkZX07YDtpZihnLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZnLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gJHtlfVske1V9XT12ZWMyPHUzMj4odTMyKCR7ZGV9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHtkZX0gPCAwKSk7YDtpZihnLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZnLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gJHtlfVske1V9XT12ZWMyPHUzMj4odTMyKCR7ZGV9KSwgMHUpO2A7aWYoZy5zdG9yYWdlPT09XCJ1MzJcIiYmZy52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmAke2V9WyR7VX1dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7ZGV9KSk7YDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7Zy5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2cudmFsdWV9IHlldGApfSkoKSxvZT1VPT4oKCk9PntpZihnLnN0b3JhZ2U9PT1nLnZhbHVlKXJldHVybmAke2V9WyR7VX1dYDtpZihnLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZnLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gaTMyKCR7ZX1bJHtVfV0ueClgO2lmKGcuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmcudmFsdWU9PT1cInUzMlwiKXJldHVybmB1MzIoJHtlfVske1V9XS54KWA7aWYoZy5zdG9yYWdlPT09XCJ1MzJcIiYmZy52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmB2ZWM0PGJvb2w+KGJvb2woJHtlfVske1V9XSAmIDB4RkZ1KSwgYm9vbCgke2V9WyR7VX1dICYgMHhGRjAwdSksIGJvb2woJHtlfVske1V9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtlfVske1V9XSAmIDB4RkYwMDAwMDB1KSlgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtnLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7Zy52YWx1ZX0geWV0YCl9KSgpLHdlPXU8Mj9cIlwiOmBcbiAgZm4gZ2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtnLmluZGljZXN9KSAtPiAke219IHtcbiAgICByZXR1cm4gJHtvZShgaTJvXyR7ZX0oaW5kaWNlcylgKX07XG4gIH1gLGo9dTwyP1wiXCI6KCgpPT57bGV0IFU9bC5tYXAocGU9PmBkJHtwZX06IHUzMmApLmpvaW4oXCIsIFwiKSxkZT1sLm1hcChwZT0+YGQke3BlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIGdldF8ke2V9KCR7VX0pIC0+ICR7bX0ge1xuICAgIHJldHVybiBnZXRfJHtlfUJ5SW5kaWNlcygke0goZGUpfSk7XG4gIH1gfSkoKSxTZT0oLi4uVSk9PntpZihVLmxlbmd0aCE9PXUpdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7dX1gKTtsZXQgZGU9VS5tYXAodikuam9pbihcIixcIik7cmV0dXJuIHU9PT0wP29lKFwiMHVcIik6dT09PTE/b2UoZGVbMF0pOigkLmdldD0hMCwkLmdldEJ5SW5kaWNlcz0hMCwkLmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtkZX0pYCl9LFRlPVU9PnU8Mj9vZShVKTooJC5nZXRCeUluZGljZXM9ITAsJC5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9QnlJbmRpY2VzKCR7VX0pYCksRWU9dTwyP1wiXCI6YFxuICBmbiBzZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2cuaW5kaWNlc30sIHZhbHVlOiAke219KSB7XG4gICAgJHt4ZShgaTJvXyR7ZX0oaW5kaWNlcylgLFwidmFsdWVcIil9XG4gIH1gLENlPXU8Mj9cIlwiOigoKT0+e2xldCBVPWwubWFwKHBlPT5gZCR7cGV9OiB1MzJgKS5qb2luKFwiLCBcIiksZGU9bC5tYXAocGU9PmBkJHtwZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBzZXRfJHtlfSgke1V9LCB2YWx1ZTogJHttfSkge1xuICAgIHNldF8ke2V9QnlJbmRpY2VzKCR7SChkZSl9LCB2YWx1ZSk7XG4gIH1gfSkoKTtyZXR1cm57aW1wbDooKT0+e2xldCBVPVtdO3JldHVybiBzfHwoVS5wdXNoKGBjb25zdCAke1N9ID0gJHtnLmluZGljZXN9KCR7ci5qb2luKFwiLFwiKX0pO2ApLFUucHVzaChgY29uc3QgJHtJfSA9ICR7Zy5pbmRpY2VzfSgke3ouY29tcHV0ZVN0cmlkZXMocikuam9pbihcIixcIil9KTtgKSksJC5vZmZzZXRUb0luZGljZXMmJlUucHVzaChCKSwkLmluZGljZXNUb09mZnNldCYmVS5wdXNoKFIpLCQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQmJk9iamVjdC52YWx1ZXMoTSkuZm9yRWFjaChkZT0+VS5wdXNoKGRlKSksJC5zZXQmJlUucHVzaChDZSksJC5zZXRCeUluZGljZXMmJlUucHVzaChFZSksJC5nZXQmJlUucHVzaChqKSwkLmdldEJ5SW5kaWNlcyYmVS5wdXNoKHdlKSxVLmpvaW4oYFxuYCl9LHR5cGU6ZyxvZmZzZXRUb0luZGljZXM6UCxpbmRpY2VzVG9PZmZzZXQ6Vyxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDpxLGluZGljZXM6SCxpbmRpY2VzR2V0OkssaW5kaWNlc1NldDpsZSxzZXQ6KC4uLlUpPT57aWYoVS5sZW5ndGghPT11KzEpdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7dX1gKTtsZXQgZGU9VVt1XTtpZih0eXBlb2YgZGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IHBlPVUuc2xpY2UoMCx1KS5tYXAodikuam9pbihcIixcIik7cmV0dXJuIHU9PT0wP3hlKFwiMHVcIixkZSk6dT09PTE/eGUocGVbMF0sZGUpOigkLnNldD0hMCwkLnNldEJ5SW5kaWNlcz0hMCwkLmluZGljZXNUb09mZnNldD0hMCxgc2V0XyR7ZX0oJHtwZX0sICR7ZGV9KWApfSxzZXRCeU9mZnNldDp4ZSxzZXRCeUluZGljZXM6KFUsZGUpPT51PDI/eGUoVSxkZSk6KCQuc2V0QnlJbmRpY2VzPSEwLCQuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke1V9LCAke2RlfSk7YCksZ2V0OlNlLGdldEJ5T2Zmc2V0Om9lLGdldEJ5SW5kaWNlczpUZSx1c2FnZTphP1wiaW5wdXRcIjpcIm91dHB1dFwiLG5hbWU6ZSxzdHJpZGVzOkksc2hhcGU6UyxyYW5rOnV9fSxGPShlLHQscixhPTEpPT5xbyhlLHQsciwhMCxhKSxYPShlLHQscixhPTEpPT5xbyhlLHQsciwhMSxhKSxqbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPXQ7dGhpcy5pbmRpY2VzSGVscGVycz1bXTt0aGlzLnVuaWZvcm1zPVtdO3RoaXMudmFyaWFibGVJbmRleD0wfWd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModCl7cmV0dXJuYGlmIChnbG9iYWxfaWR4ID49ICR7dHlwZW9mIHQ9PVwibnVtYmVyXCI/YCR7dH11YDp0fSkgeyByZXR1cm47IH1gfW1haW5TdGFydCh0PWVkKXtsZXQgcj10eXBlb2YgdD09XCJudW1iZXJcIj90OnRbMF0sYT10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMV0sbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMl0scz10aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdPT09MSYmdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXT09PTEsdT1zP2BAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YDpgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaW5kZXggOiB1MzIsXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj5gLGw9cz9cImxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7XCI6YGxldCBnbG9iYWxfaWR4ID0gKHdvcmtncm91cF9pZC56ICogJHt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzBdKnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV19dSArXG4gICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiAke3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF19dSArIHdvcmtncm91cF9pZC54KSAqICR7ciphKm59dSArIGxvY2FsX2luZGV4O2A7cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3J9LCAke2F9LCAke259KVxuICBmbiBtYWluKCR7dX0pIHtcbiAgICAke2x9XG4gIGB9ZGVjbGFyZVZhcmlhYmxlKHQscil7dGhpcy5pbmRpY2VzSGVscGVycy5wdXNoKHQpLHQuc2hhcGUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc2hhcGUucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6dC50eXBlLmluZGljZXN9KSx0LnN0cmlkZXMuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc3RyaWRlcy5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTp0LnR5cGUuaW5kaWNlc30pO2xldCBhPXQudXNhZ2U9PT1cImlucHV0XCI/XCJyZWFkXCI6XCJyZWFkX3dyaXRlXCIsbj10LnR5cGUuc3RvcmFnZTtyZXR1cm5gQGdyb3VwKDApIEBiaW5kaW5nKCR7cn0pIHZhcjxzdG9yYWdlLCAke2F9PiAke3QubmFtZX06IGFycmF5PCR7bn0+O2B9ZGVjbGFyZVZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5tYXAocj0+dGhpcy5kZWNsYXJlVmFyaWFibGUocix0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oYFxuYCl9cmVnaXN0ZXJVbmlmb3JtKHQscil7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LHR5cGU6cn0pLHRoaXN9dW5pZm9ybURlY2xhcmF0aW9uKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IHQ9W107Zm9yKGxldHtuYW1lOnIsdHlwZTphfW9mIHRoaXMudW5pZm9ybXMpdC5wdXNoKGAke3J9OiR7YX1gKTtyZXR1cm5gXG4gICAgICBzdHJ1Y3QgVW5pZm9ybXMgeyAke3Quam9pbihcIiwgXCIpfSB9O1xuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7dGhpcy52YXJpYWJsZUluZGV4fSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztgfWdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCl7cmV0dXJuIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkrdGhpcy5pbmRpY2VzSGVscGVycy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxuYCl9fSxLbz1lPT5uZXcgam4oZSksS249KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxhPVtdO2ZvcihsZXQgbj0wO248cjtuKyspe2xldCBzPXItMS1uLHU9ZVtzXXx8MTsodFt0Lmxlbmd0aC0xLW5dfHwxKT4xJiZ1PT09MSYmYS51bnNoaWZ0KHMpfXJldHVybiBhfSxZbz1lPT5lPD00fSk7dmFyIHRkLFhvLHJkLG5kLEN0LEpvLFFvLG1yPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTt0ZD1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIil9LFhvPShlLHQpPT50JiZ0Lmxlbmd0aCE9PWU/Wy4uLm5ldyBBcnJheShlKS5rZXlzKCldLnJldmVyc2UoKTp0LHJkPShlLHQpPT56LnNvcnRCYXNlZE9uUGVybShlLFhvKGUubGVuZ3RoLHQpKSxuZD0oZSx0LHIsYSk9PntsZXQgbj1bXTtuLnB1c2goYGZuIHBlcm0oaTogJHthLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtyLnR5cGUuaW5kaWNlc307YCk7Zm9yKGxldCBzPTA7czx0OysrcyluLnB1c2goci5pbmRpY2VzU2V0KFwiYVwiLGVbc10sYGlbJHtzfV1gKSk7cmV0dXJuIG4ucHVzaChcInJldHVybiBhO31cIiksbi5qb2luKGBcbmApfSxDdD0oZSx0KT0+e2xldCByPWUuZGF0YVR5cGUsYT1lLmRpbXMubGVuZ3RoLG49WG8oYSx0KSxzPVlvKGEpLHU9cmQoZS5kaW1zLG4pLGw9cz91Lmxlbmd0aDp1LG89cz9hOmUuZGltcyxwPVgoXCJvdXRwdXRcIixyLGwpLG09RihcImFcIixyLG8pLHk9Zz0+YFxuICAke2cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0scCl9XG5cbiAgJHtuZChuLGEsbSxwKX1cblxuICAke2cubWFpblN0YXJ0KCl9XG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHtwLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke3Auc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbS5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XG4gIH1gO3JldHVybntuYW1lOlwiVHJhbnNwb3NlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOnM/W1wicmFua1wiXTpbXCJkaW1zXCJdfSxnZXRSdW5EYXRhOmc9PntsZXQgdj16LnNpemUodSk7cmV0dXJue291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6Z1swXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHYvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cz9be3R5cGU6XCJ1aW50MzJcIixkYXRhOnZ9LC4uLnFuKGdbMF0uZGltcyksLi4ucW4odSldOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6dn1dfX0sZ2V0U2hhZGVyU291cmNlOnl9fSxKbz0oZSx0KT0+e3RkKGUuaW5wdXRzKSxlLmNvbXB1dGUoQ3QoZS5pbnB1dHNbMF0sdC5wZXJtKSl9LFFvPWU9PmllKHtwZXJtOmUucGVybX0pfSk7dmFyIGFkLG9kLGlkLHNkLHVkLGxkLGRkLGNkLHBkLGZkLGF0LFpvLGVpLHRpLHJpLG5pLGFpLG9pLGlpLHNpLHVpLGxpPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7ZW4oKTttcigpO2FkPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGV4cChjYW5kaWRhdGUpXCIsbDE6XCJiZXN0VmFsdWUgKyBhYnMoY2FuZGlkYXRlKVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LG9kPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwxOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0saWQ9e21heDpcIl9BW29mZnNldF1cIixtaW46XCJfQVtvZmZzZXRdXCIsbWVhbjpcIjBcIixzdW06XCIwXCIscHJvZDpcIjFcIixzdW1TcXVhcmU6XCIwXCIsbG9nU3VtRXhwOlwiMFwiLGwxOlwiMFwiLGwyOlwiMFwiLGxvZ1N1bTpcIjBcIn0sc2Q9e21heDpcImJlc3RWYWx1ZVwiLG1pbjpcImJlc3RWYWx1ZVwiLHN1bTpcImJlc3RWYWx1ZVwiLHByb2Q6XCJiZXN0VmFsdWVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWVcIixsb2dTdW1FeHA6XCJsb2coYmVzdFZhbHVlKVwiLGwxOlwiYmVzdFZhbHVlXCIsbDI6XCJzcXJ0KGJlc3RWYWx1ZSlcIixsb2dTdW06XCJsb2coYmVzdFZhbHVlKVwifSx1ZD0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgYT10LWU7YTx0OysrYSlyLnB1c2goYSk7cmV0dXJuIHJ9LGxkPShlLHQpPT57bGV0IHI9W10sYT1lLmxlbmd0aDtmb3IobGV0IHM9MDtzPGE7cysrKXQuaW5kZXhPZihzKT09PS0xJiZyLnB1c2goZVtzXSk7bGV0IG49dC5tYXAocz0+ZVtzXSk7cmV0dXJuW3Isbl19LGRkPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgrdC5sZW5ndGgsYT1bXSxuPTA7Zm9yKGxldCBzPTA7czxyO3MrKyl0LmluZGV4T2Yocyk9PT0tMT9hLnB1c2goZVtuKytdKTphLnB1c2goMSk7cmV0dXJuIGF9LGNkPShlLHQpPT57Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpaWYoZVtlLmxlbmd0aC1yLTFdIT09dC0xLXIpcmV0dXJuITE7cmV0dXJuITB9LHBkPShlLHQpPT57bGV0IHI9W107aWYoIWNkKGUsdCkpe2ZvcihsZXQgYT0wO2E8dDsrK2EpZS5pbmRleE9mKGEpPT09LTEmJnIucHVzaChhKTtlLmZvckVhY2goYT0+ci5wdXNoKGEpKX1yZXR1cm4gcn0sZmQ9KGUsdCxyLGEsbixzLHUpPT57bGV0IGw9clswXS5kaW1zLG89ei5zaXplKHMpLHA9ei5zaXplKHUpLG09RihcIl9BXCIsclswXS5kYXRhVHlwZSxsKSx5PVgoXCJvdXRwdXRcIixuLHMpLGc9MzIsdj1gXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTwke3kudHlwZS5zdG9yYWdlfSwgJHtnfT47XG4gICAgICAgYDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOmI9PmBcbiAgICAgICAgJHtiLnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0seSl9XG4gICAgICAgICR7dn1cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7Yi5tYWluU3RhcnQoZyl9XG4gICAgICAgICAgbGV0IGxvY2FsX2lkeCA9IGxvY2FsX2lkLng7XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtnfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9ICR7eS50eXBlLnN0b3JhZ2V9KCR7aWRbYV19KTtcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gbG9jYWxfaWR4OyBrIDwgTGVuZ3RoOyBrID0gayArICR7Z30pIHtcbiAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9ICR7eS50eXBlLnN0b3JhZ2V9KCR7bS5nZXRCeU9mZnNldChcIm9mZnNldCArIGtcIil9KTtcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHthZFthXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7Z311KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke29kW2FdfTtcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcbiAgICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJvdXRwdXRJbmRleFwiLGAke2E9PT1cIm1lYW5cIj9gYmVzdFZhbHVlIC8gJHt5LnR5cGUuc3RvcmFnZX0odW5pZm9ybXMucmVkdWNlU2l6ZSlgOmAke3NkW2FdfWB9YCl9O1xuICAgICAgICAgfVxuICAgICAgICB9YCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6b30scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH1dfSl9fSxhdD0oZSx0LHIsYSk9PntsZXQgbj1lLmlucHV0cy5sZW5ndGg9PT0xP3I6WW4oZS5pbnB1dHMscikscz1uLmF4ZXM7cy5sZW5ndGg9PT0wJiYhbi5ub29wV2l0aEVtcHR5QXhlcyYmKHM9ZS5pbnB1dHNbMF0uZGltcy5tYXAoKHYsJCk9PiQpKTtsZXQgdT16Lm5vcm1hbGl6ZUF4ZXMocyxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCksbD11LG89ZS5pbnB1dHNbMF0scD1wZChsLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtwLmxlbmd0aD4wJiYobz1lLmNvbXB1dGUoQ3QoZS5pbnB1dHNbMF0scCkse2lucHV0czpbMF0sb3V0cHV0czpbLTFdfSlbMF0sbD11ZChsLmxlbmd0aCxvLmRpbXMubGVuZ3RoKSk7bGV0W20seV09bGQoby5kaW1zLGwpLGc9bTtuLmtlZXBEaW1zJiYoZz1kZChtLHUpKSxlLmNvbXB1dGUoZmQodCx7aGludDpuLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LFtvXSxhLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGcseSkse2lucHV0czpbb119KX0sWm89KGUsdCk9PnthdChlLFwiUmVkdWNlTWVhblNoYXJlZFwiLHQsXCJtZWFuXCIpfSxlaT0oZSx0KT0+e2F0KGUsXCJSZWR1Y2VMMVNoYXJlZFwiLHQsXCJsMVwiKX0sdGk9KGUsdCk9PnthdChlLFwiUmVkdWNlTDJTaGFyZWRcIix0LFwibDJcIil9LHJpPShlLHQpPT57YXQoZSxcIlJlZHVjZUxvZ1N1bUV4cFNoYXJlZFwiLHQsXCJsb2dTdW1FeHBcIil9LG5pPShlLHQpPT57YXQoZSxcIlJlZHVjZU1heFNoYXJlZFwiLHQsXCJtYXhcIil9LGFpPShlLHQpPT57YXQoZSxcIlJlZHVjZU1pblNoYXJlZFwiLHQsXCJtaW5cIil9LG9pPShlLHQpPT57YXQoZSxcIlJlZHVjZVByb2RTaGFyZWRcIix0LFwicHJvZFwiKX0saWk9KGUsdCk9PnthdChlLFwiUmVkdWNlU3VtU2hhcmVkXCIsdCxcInN1bVwiKX0sc2k9KGUsdCk9PnthdChlLFwiUmVkdWNlU3VtU3F1YXJlU2hhcmVkXCIsdCxcInN1bVNxdWFyZVwiKX0sdWk9KGUsdCk9PnthdChlLFwiUmVkdWNlTG9nU3VtU2hhcmVkXCIsdCxcImxvZ1N1bVwiKX19KTt2YXIgb3QsbWQsdG4sWW4saXQsaGQsZ2QseWQsYmQsd2QsdmQsJGQseGQsU2QsQ2Qsc3QsZGksY2kscGksZmksbWksaGksZ2kseWksYmksd2ksWmUsZW49TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO2xpKCk7b3Q9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MiYmZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGVzIGlucHV0IGRpbXMuXCIpfSxtZD1lPT5bXCJcIixcIlwiLGB2YXIgdmFsdWUgPSAke2UuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcIlwiXSx0bj0oZSx0LHIsYSxuLHMsdT0hMSxsPSExKT0+e2xldCBvPVtdLHA9clswXS5kaW1zLG09ei5ub3JtYWxpemVBeGVzKG4sclswXS5kaW1zLmxlbmd0aCkseT0hbCYmbS5sZW5ndGg9PT0wO3AuZm9yRWFjaCgoVyxIKT0+e3l8fG0uaW5kZXhPZihIKT49MD91JiZvLnB1c2goMSk6by5wdXNoKFcpfSk7bGV0IGc9W10sdj1GKFwiX0FcIixyWzBdLmRhdGFUeXBlLHApLCQ9WChcIm91dHB1dFwiLHMsbyksYj1hKHYsJCxtKSxTPWBpbnB1dE9mZnNldCA9ICR7di5pbmRpY2VzVG9PZmZzZXQoXCJpbnB1dEluZGljZXNcIil9O2AsST1gbGV0ICR7U307YCxUPWB2YXIgJHtTfTtgLEI9YlsxXT09PVwiXCI/XCJcIjpULFA9KGJbMV09PT1cIlwiP0k6UykrYFxuYCtiWzJdO2ZvcihsZXQgVz0wLEg9MDtXPHJbMF0uZGltcy5sZW5ndGg7VysrKXl8fG0uaW5kZXhPZihXKT49MD8odSYmSCsrLFA9YGZvcih2YXIgaiR7V306IHUzMiA9IDA7IGoke1d9IDwgJHtyWzBdLmRpbXNbV119OyBqJHtXfSsrKSB7XG4gICAgICAgICAgICAgICAgJHtiWzJdLmluY2x1ZGVzKFwibGFzdEluZGV4XCIpP2BsZXQgbGFzdEluZGV4ID0gaiR7V307YDpcIlwifVxuICAgICAgICAgICAgICAgICR7di5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsVyxgaiR7V31gKX1cbiAgICAgICAgICAgICAgICAke1B9XG4gICAgICAgICAgICAgIH1gKTooZy5wdXNoKGAke3YuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFcsJC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEgpKX07YCksSCsrKTtsZXQgRD16LnNpemUobyk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTpXPT5gXG4gICAgICAgICR7Vy5kZWNsYXJlVmFyaWFibGVzKHYsJCl9XG5cbiAgICAgICAgJHtXLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7Vy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKEQpfVxuICAgICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7di50eXBlLmluZGljZXN9O1xuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHskLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgJHtnLmpvaW4oYFxuYCl9XG4gICAgICAgICAgJHtiWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke0J9XG4gICAgICAgICAgJHtiWzFdfVxuICAgICAgICAgICR7UH1cbiAgICAgICAgICAke2JbM119XG4gICAgICAgICAgJHtiLmxlbmd0aD09PTQ/JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpOmIuc2xpY2UoNCkuam9pbihgXG5gKX1cbiAgICAgICAgfWAsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChELzY0KX19KX19LFluPShlLHQpPT57bGV0IHI9W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKGE9PnIucHVzaChOdW1iZXIoYSkpKSxpZSh7YXhlczpyLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxpdD0oZSx0LHIsYSk9PntsZXQgbj1lLmlucHV0cyxzPW4ubGVuZ3RoPT09MT9yOlluKG4scik7ZS5jb21wdXRlKHRuKHQse2hpbnQ6cy5jYWNoZUtleX0sW25bMF1dLHMubm9vcFdpdGhFbXB0eUF4ZXMmJnMuYXhlcy5sZW5ndGg9PT0wP21kOmEscy5heGVzLG5bMF0uZGF0YVR5cGUscy5rZWVwRGltcyxzLm5vb3BXaXRoRW1wdHlBeGVzKSx7aW5wdXRzOlswXX0pfSxoZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTG9nU3VtXCIsdCwoYSxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LGdkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMMVwiLHQsKGEsbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBhYnMoJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwiXCJdKX0seWQ9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUwyXCIsdCwoYSxuKT0+W2B2YXIgdCA9ICR7bi50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtuLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFwidmFsdWUgPSBzcXJ0KHZhbHVlKTtcIl0pfSxiZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTG9nU3VtRXhwXCIsdCwoYSxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGV4cCgke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sd2Q9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZU1heFwiLHQsKGEsbixzKT0+e2xldCB1PVtdO2ZvcihsZXQgbD0wO2w8YS5yYW5rO2wrKykocy5pbmRleE9mKGwpPj0wfHxzLmxlbmd0aD09PTApJiZ1LnB1c2goYS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsbCwwKSk7cmV0dXJuW2Ake3Uuam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcIlwiXX0pfSx2ZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTWVhblwiLHQsKGEsbixzKT0+e2xldCB1PTE7Zm9yKGxldCBsPTA7bDxhLnJhbms7bCsrKShzLmluZGV4T2YobCk+PTB8fHMubGVuZ3RoPT09MCkmJih1Kj1lLmlucHV0c1swXS5kaW1zW2xdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLGBsZXQgdmFsdWUgPSAke24udHlwZS52YWx1ZX0oc3VtIC8gJHt1fSk7YF19KX0sJGQ9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZU1pblwiLHQsKGEsbixzKT0+e2xldCB1PVtdO2ZvcihsZXQgbD0wO2w8YS5yYW5rO2wrKykocy5pbmRleE9mKGwpPj0wfHxzLmxlbmd0aD09PTApJiZ1LnB1c2goYGlucHV0SW5kaWNlc1ske2x9XSA9IDA7YCk7cmV0dXJuW2Ake3Uuam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxgdmFsdWUgPSBtaW4odmFsdWUsICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxcIlwiXX0pfSx4ZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlUHJvZFwiLHQsKGEsbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMSk7YCxcIlwiLGB2YWx1ZSAqPSAke2EuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcIlwiXSl9LFNkPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VTdW1cIix0LChhLG4pPT5bYHZhciB2YWx1ZSA9ICR7bi50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHthLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsXCJcIl0pfSxDZD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlU3VtU3F1YXJlXCIsdCwoYSxuKT0+W2B2YXIgdCA9ICR7bi50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtuLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7YS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcIlwiXSl9LHN0PShlLHQscik9PntpZih0Lmxlbmd0aD09PTApcmV0dXJuISFyO2xldCBhPTEsbj0xO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKXQuaW5kZXhPZihzKT09PS0xP2EqPWVbc106bio9ZVtzXTtyZXR1cm4gbjwzMiYmYT4xMDI0fSxkaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3ZkKGUsdCk6Wm8oZSx0KX0sY2k9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9nZChlLHQpOmVpKGUsdCl9LHBpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/eWQoZSx0KTp0aShlLHQpfSxmaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2JkKGUsdCk6cmkoZSx0KX0sbWk9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT93ZChlLHQpOm5pKGUsdCl9LGhpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/JGQoZSx0KTphaShlLHQpfSxnaT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3hkKGUsdCk6b2koZSx0KX0seWk9KGUsdCk9PntzdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9TZChlLHQpOmlpKGUsdCl9LGJpPShlLHQpPT57c3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q2QoZSx0KTpzaShlLHQpfSx3aT0oZSx0KT0+e3N0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2hkKGUsdCk6dWkoZSx0KX0sWmU9ZT0+aWUoZSl9KTt2YXIgdmksJGkseGksU2ksWG4sQ2k9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7a2UoKTtlbigpO3ZpPWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkFyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LCRpPShlLHQpPT5pZSh7YXhpczp0LmF4aXMsa2VlcERpbXM6dC5rZWVwRGltcyxzZWxlY3RMYXN0SW5kZXg6dC5zZWxlY3RMYXN0SW5kZXh9KSx4aT0oZSx0KT0+e3ZpKGUuaW5wdXRzKTtsZXQgcj0obixzLHUpPT57bGV0IGw9W107Zm9yKGxldCBvPTA7bzxuLnJhbms7bysrKSh1LmluZGV4T2Yobyk+PTB8fHUubGVuZ3RoPT09MCkmJmwucHVzaChgaW5wdXRJbmRpY2VzWyR7b31dID0gMDtgKTtyZXR1cm5bYCR7bC5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcbnZhciBiZXN0SW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPD1cIjpcIjxcIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O1xuICAgICAgICAgYmVzdEluZGV4ID0gaTMyKGxhc3RJbmRleCk7XG4gICAgICAgfWAsXCJcIixzLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdEluZGV4XCIpXX0sYT1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6JGkoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHRuKFwiQXJnTWluXCIse2hpbnQ6YS5jYWNoZUtleX0sW2UuaW5wdXRzWzBdXSxyLFthLmF4aXNdLDcsYS5rZWVwRGltcykse2lucHV0czpbMF19KX0sU2k9KGUsdCk9Pnt2aShlLmlucHV0cyk7bGV0IHI9KG4scyx1KT0+e2xldCBsPVtdO2ZvcihsZXQgbz0wO288bi5yYW5rO28rKykodS5pbmRleE9mKG8pPj0wfHx1Lmxlbmd0aD09PTApJiZsLnB1c2goYGlucHV0SW5kaWNlc1ske299XSA9IDA7YCk7cmV0dXJuW2Ake2wuam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XG52YXIgYmVzdEluZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIj49XCI6XCI+XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcbiAgICAgICAgIGJlc3RJbmRleCA9IGkzMihsYXN0SW5kZXgpO1xuICAgICAgIH1gLFwiXCIscy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RJbmRleFwiKV19LGE9ZS5pbnB1dHMubGVuZ3RoPT09MT90OiRpKGUuaW5wdXRzLHQpO2UuY29tcHV0ZSh0bihcImFyZ01heFwiLHtoaW50OmEuY2FjaGVLZXl9LFtlLmlucHV0c1swXV0scixbYS5heGlzXSw3LGEua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LFhuPWU9PmllKGUpfSk7dmFyIElkLEFkLElpLEFpPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7SWQ9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sQWQ9ZT0+e2xldCB0PWVbMF0uZGltcyxyPWVbMF0uZGltc1syXSxhPXouc2l6ZSh0KS80LG49ZVswXS5kYXRhVHlwZSxzPUYoXCJpbnB1dFwiLG4sdCw0KSx1PUYoXCJiaWFzXCIsbixbcl0sNCksbD1GKFwicmVzaWR1YWxcIixuLHQsNCksbz1YKFwib3V0cHV0XCIsbix0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSksZ2V0U2hhZGVyU291cmNlOm09PmBcbiAgY29uc3QgY2hhbm5lbHMgPSAke3J9dSAvIDQ7XG4gICR7bS5kZWNsYXJlVmFyaWFibGVzKHMsdSxsLG8pfVxuXG4gICR7bS5tYWluU3RhcnQoKX1cbiAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhhKX1cbiAgICBsZXQgdmFsdWUgPSAke3MuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxuICAgICAgKyAke3UuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHtsLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfX0sSWk9ZT0+e0lkKGUuaW5wdXRzKSxlLmNvbXB1dGUoQWQoZS5pbnB1dHMpKX19KTt2YXIgRWQsJGUsRWksX2ksT2ksVGksUmksUGksa2ksQmksTWksSm4sX2QsRGksemksV2ksTmkscm4sVmksbm4sVWksR2ksRmksTGksSGksamkscWksS2ksWWksWGksSmksUWksWmksZXMsdHMscnMsbnMsUW49TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtrZSgpO3ZlKCk7RWQ9KGUsdCxyLGEsbixzKT0+e2xldCB1PU1hdGguY2VpbCh0LzQpLGw9XCJcIjt0eXBlb2Ygbj09XCJzdHJpbmdcIj9sPWAke259KGEpYDpsPW4oXCJhXCIpO2xldCBvPUYoXCJpbnB1dERhdGFcIixyLFt1XSw0KSxwPVgoXCJvdXRwdXREYXRhXCIsYSxbdV0sNCk7cmV0dXJuYFxuICAke2UuZGVjbGFyZVZhcmlhYmxlcyhvLHApfVxuXG4gICR7cz8/XCJcIn1cblxuICAke2UubWFpblN0YXJ0KCl9XG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XG5cbiAgICBsZXQgYSA9ICR7by5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICR7cC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixsKX1cbiAgfWB9LCRlPShlLHQscixhLG4scz1lLmRhdGFUeXBlKT0+KHtuYW1lOnQsc2hhZGVyQ2FjaGU6e2hpbnQ6bn0sZ2V0U2hhZGVyU291cmNlOnU9PkVkKHUsei5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxzLHIsYSksZ2V0UnVuRGF0YTp1PT4oe291dHB1dHM6W3tkaW1zOmUuZGltcyxkYXRhVHlwZTpzfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoei5zaXplKHVbMF0uZGltcykvNjQvNCl9fSl9KSxFaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQWJzXCIsXCJhYnNcIikpfSxfaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQWNvc1wiLFwiYWNvc1wiKSl9LE9pPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBY29zaFwiLFwiYWNvc2hcIikpfSxUaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXNpblwiLFwiYXNpblwiKSl9LFJpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBc2luaFwiLFwiYXNpbmhcIikpfSxQaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXRhblwiLFwiYXRhblwiKSl9LGtpPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJBdGFuaFwiLFwiYXRhbmhcIikpfSxCaT1lPT5pZShlKSxNaT0oZSx0KT0+e2xldCByO3N3aXRjaCh0LnRvKXtjYXNlIDEwOnI9XCJ2ZWM0PGYxNj5cIjticmVhaztjYXNlIDE6cj1cInZlYzQ8ZjMyPlwiO2JyZWFrO2Nhc2UgMTI6cj1cInZlYzQ8dTMyPlwiO2JyZWFrO2Nhc2UgNjpyPVwidmVjNDxpMzI+XCI7YnJlYWs7Y2FzZSA5OnI9XCJ2ZWM0PGJvb2w+XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlICd0bycgZnJvbSAnQ2FzdCcgb3BlcmF0b3IpOiAke3QudG99YCl9ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ2FzdFwiLHIsdm9pZCAwLHQuY2FjaGVLZXksdC50bykpfSxKbj0oZSx0KT0+e2xldCByPUJlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsYT0+YGNsYW1wKCR7YX0sIGNsaXBfbWluXywgY2xpcF9tYXhfKWAsYFxuICAgIGNvbnN0IGNsaXBfbWluXzogdmVjNDwke3J9PiA9IHZlYzQoJHtyfSgke3QubWlufSkpO1xuICAgIGNvbnN0IGNsaXBfbWF4XzogdmVjNDwke3J9PiA9IHZlYzQoJHtyfSgke3QubWF4fSkpO1xuYCx0LmNhY2hlS2V5KSx7aW5wdXRzOlswXX0pfSxfZD1lPT57bGV0IHQ9ZS5sZW5ndGg+PTI/ZVsxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTpRcixyPWUubGVuZ3RoPj0zP2VbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06WnI7cmV0dXJuIGllKHttaW46dCxtYXg6cn0pfSxEaT1lPT57bGV0IHQ9X2QoZS5pbnB1dHMpO0puKGUsdCl9LHppPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDZWlsXCIsXCJjZWlsXCIpKX0sV2k9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNvc1wiLFwiY29zXCIpKX0sTmk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNvc2hcIixcImNvc2hcIikpfSxybj1lPT5pZShlKSxWaT0oZSx0KT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkVsdVwiLHI9PmBlbHVfdmYzMigke3J9KWAsYFxuICBjb25zdCBlbHVfYWxwaGFfOiBmMzIgPSBmMzIoJHt0LmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiBmMzIpIC0+IGYzMiB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPiB7XG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XG4gIH1gLHQuY2FjaGVLZXkpKX0sbm49KGUsdD1cImYzMlwiKT0+YFxuY29uc3QgcjA6ICR7dH0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHt0fSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7dH0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHt0fSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7dH0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHt0fSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiAke2V9KSAtPiAke2V9IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWAsVWk9ZT0+e2xldCB0PUJlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJFcmZcIixyPT5gZXJmX3ZmMzIoJHtyfSlgLG5uKGB2ZWM0PCR7dH0+YCx0KSkpfSxHaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRXhwXCIsXCJleHBcIikpfSxGaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRmxvb3JcIixcImZsb29yXCIpKX0sTGk9ZT0+e2xldCB0PUJlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJHZWx1XCIscj0+YDAuNSAqICR7cn0gKiAoMS4wICsgZXJmX3ZmMzIoJHtyfSAqIDAuNzA3MTA2NzgxMTg2NTQ3NSkpYCxubihgdmVjNDwke3R9PmAsdCkpKX0sSGk9KGUsdCk9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJMZWFreVJlbHVcIixyPT5gc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHtyfSwgJHtyfSwgJHtyfSA+PSB2ZWM0PGYzMj4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXzogZjMyID0gZjMyKCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpfSxqaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTm90XCIsdD0+YCEke3R9YCkpfSxxaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTmVnXCIsdD0+YC0ke3R9YCkpfSxLaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiUmVjaXByb2NhbFwiLHQ9PmAxLjAvJHt0fWApKX0sWWk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlJlbHVcIix0PT5gc2VsZWN0KHZlYzQ8ZjMyPigwLjApLCAke3R9LCAke3R9ID4gdmVjNDxmMzI+KDAuMCkpYCkpfSxYaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU2lnbW9pZFwiLHQ9PmAoMS4wIC8gKDEuMCArIGV4cCgtJHt0fSkpKWApKX0sSmk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNpblwiLFwic2luXCIpKX0sUWk9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNpbmhcIixcInNpbmhcIikpfSxaaT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU3FydFwiLFwic3FydFwiKSl9LGVzPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJUYW5cIixcInRhblwiKSl9LHRzPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJUYW5oXCIsXCJ0YW5oXCIpKX0scnM9KGUsdCk9PihlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJUaHJlc2hvbGRlZFJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8ZjMyPigwLjApLCAke3J9LCAke3J9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV86IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKSwwKSxucz1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTG9nXCIsXCJsb2dcIikpfX0pO3ZhciBUZCxSZCxhcyxvcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO1FuKCk7VGQ9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzI1NjAsNTEyMCwxMDI0MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sUmQ9ZT0+e2xldCB0PWVbMF0uZGltcy5zbGljZSgpO3RbMl09dFsyXS8yO2xldCByPUYoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLDQpLGE9RihcImJpYXNcIixlWzBdLmRhdGFUeXBlLFtlWzBdLmRpbXNbMl1dLDQpLG49WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdCw0KSxzPXouc2l6ZSh0KS80O3JldHVybntuYW1lOlwiQmlhc1NwbGl0R2VsdVwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9fSksZ2V0U2hhZGVyU291cmNlOmw9PmBcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtlWzBdLmRpbXNbMl0vNC8yfXU7XG5cbiAgJHtsLmRlY2xhcmVWYXJpYWJsZXMocixhLG4pfVxuXG4gICR7bm4oXCJ2ZWM0ZlwiKX1cblxuICAke2wubWFpblN0YXJ0KCl9XG4gICAgJHtsLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocyl9XG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xuXG4gICAgJHtuLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVMZWZ0ICogZ2VsdVJpZ2h0XCIpfVxuICB9YH19LGFzPWU9PntUZChlLmlucHV0cyksZS5jb21wdXRlKFJkKGUuaW5wdXRzKSl9fSk7dmFyIFBkLGtkLHV0LGlzLHNzLHVzLGxzLGRzLGNzLHBzLGZzLG1zLGhzLGdzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7dmUoKTtQZD0oZSx0LHIsYSxuLHMsdSxsLG8scCxtKT0+e2xldCB5PXouc2l6ZShhKSxnPU1hdGguY2VpbCh5LzQpLHYsJDt0eXBlb2YgdT09XCJzdHJpbmdcIj92PSQ9KFAsRCk9PmAke3V9KCgke1B9KSwoJHtEfSkpYDp0eXBlb2YgdT09XCJmdW5jdGlvblwiP3Y9JD11Oih2PXUuc2NhbGFyLCQ9dS52ZWN0b3IpO2xldCBiPVwiXCIsUz1YKFwib3V0cHV0RGF0YVwiLHAsYSw0KSxJPUYoXCJhRGF0YVwiLGwsdCw0KSxUPUYoXCJiRGF0YVwiLG8sciw0KTtpZihzKXtsZXQgUD1EPT57bGV0IFI9ei5jb21wdXRlU3RyaWRlcyhEKSxXPVtdO2ZvcihsZXQgSD1ELmxlbmd0aC0xO0g+PTA7SC0tKXtsZXQgSz1TLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsSCthLmxlbmd0aC1ELmxlbmd0aCk7Vy5wdXNoKGAke1JbSF19dSAqICgke0t9ICUgJHtEW0hdfXUpYCl9cmV0dXJuIFcubGVuZ3RoPjA/Vy5qb2luKFwiK1wiKTpcIjB1XCJ9O2I9YFxuICAgICAgICAgIGZuIGNhbGNPZmZzZXRBKG91dHB1dEluZGljZXM6ICR7Uy50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgcmV0dXJuICR7UCh0KX07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm4gY2FsY09mZnNldEIob3V0cHV0SW5kaWNlczogJHtTLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICByZXR1cm4gJHtQKHIpfTtcbiAgICAgICAgICB9XG4gICAgICAgIGB9bGV0IEI7aWYobilpZihzKXtsZXQgUD16LnNpemUodCk9PT0xLEQ9ei5zaXplKHIpPT09MTtQfHxEP0I9Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiwkKFA/YCR7SS50eXBlLnZhbHVlfSgke0kuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6SS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksRD9gJHtULnR5cGUudmFsdWV9KCR7VC5nZXRCeU9mZnNldChcIjBcIil9LngpYDpULmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpOkI9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeCAqIDR1XCIpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBID0gY2FsY09mZnNldEEob3V0cHV0SW5kaWNlcyk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9IGNhbGNPZmZzZXRCKG91dHB1dEluZGljZXMpO1xuICAgICAgICAgICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLCQoSS5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKSxULmdldEJ5T2Zmc2V0KFwib2Zmc2V0QiAvIDR1XCIpKSl9XG4gICAgICAgICAgYH1lbHNlIEI9Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiwkKEkuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJubyBuZWNlc3NhcnkgdG8gdXNlIHNjYWxhciBpbXBsZW1lbnRhdGlvbiBmb3IgZWxlbWVudC13aXNlIGJpbmFyeSBvcCBpbXBsZW1lbnRhdGlvbi5cIik7bGV0IFA9KEQsUixXPVwiXCIpPT57bGV0IEg9YGFEYXRhW2luZGV4QSR7Un1dW2NvbXBvbmVudEEke1J9XWAsSz1gYkRhdGFbaW5kZXhCJHtSfV1bY29tcG9uZW50QiR7Un1dYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7Un0gPSAke1Mub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke1J9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHtSfSA9IGNhbGNPZmZzZXRBKG91dHB1dEluZGljZXMke1J9KTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHtSfSA9IGNhbGNPZmZzZXRCKG91dHB1dEluZGljZXMke1J9KTtcbiAgICAgICAgICAgIGxldCBpbmRleEEke1J9ID0gb2Zmc2V0QSR7Un0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleEIke1J9ID0gb2Zmc2V0QiR7Un0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHtSfSA9IG9mZnNldEEke1J9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7Un0gPSBvZmZzZXRCJHtSfSAlIDR1O1xuICAgICAgICAgICAgJHtEfVske1J9XSA9ICR7V30oJHt2KEgsSyl9KTtcbiAgICAgICAgICBgfTtwPT09OT9CPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtQKFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke1AoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7UChcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtQKFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6Qj1gXG4gICAgICAgICAgICAke1AoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke1AoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke1AoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMil9XG4gICAgICAgICAgICAke1AoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKEksVCxTKX1cblxuICAgICAgICAke20/P1wiXCJ9XG4gICAgICAgICR7Yn1cblxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGcpfVxuICAgICAgICAke0J9XG4gICAgICB9YH0sa2Q9KGUsdCxyLGEsbixzLHU9ci5kYXRhVHlwZSk9PntsZXQgbD0hei5hcmVFcXVhbChyLmRpbXMsYS5kaW1zKSxvPXIuZGltcyxwPXouc2l6ZShyLmRpbXMpLG09ITE7aWYobCl7bGV0IHk9bnQuY2FsY1NoYXBlKHIuZGltcyxhLmRpbXMsITEpO2lmKCF5KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO289eSxwPXouc2l6ZShvKTtsZXQgZz16LnNpemUoci5kaW1zKT09PTEsdj16LnNpemUoYS5kaW1zKT09PTEsJD0xO2ZvcihsZXQgYj0xO2I8by5sZW5ndGg7YisrKXtsZXQgUz1yLmRpbXNbci5kaW1zLmxlbmd0aC1iXT8/MSxJPWEuZGltc1thLmRpbXMubGVuZ3RoLWJdPz8xO2lmKFM9PT1JKSQqPVM7ZWxzZSBicmVha30oJCU0PT09MHx8Z3x8dikmJihtPSEwKX1lbHNlIG09ITA7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0fSxnZXRTaGFkZXJTb3VyY2U6eT0+UGQoeSxyLmRpbXMsYS5kaW1zLG8sbSxsLG4sci5kYXRhVHlwZSxhLmRhdGFUeXBlLHUscyksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0LzQpfX0pfX0sdXQ9KGUsdCxyLGEsbixzKT0+e2UuY29tcHV0ZShrZCh0LG4/P1wiXCIsZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0scixhLHMpKX0saXM9ZT0+e3V0KGUsXCJBZGRcIiwodCxyKT0+YCR7dH0rJHtyfWApfSxzcz1lPT57dXQoZSxcIkRpdlwiLCh0LHIpPT5gJHt0fS8ke3J9YCl9LHVzPWU9Pnt1dChlLFwiRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH09PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT09JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxscz1lPT57dXQoZSxcIk11bFwiLCh0LHIpPT5gJHt0fSoke3J9YCl9LGRzPWU9PntsZXQgdD1GKFwiaW5wdXRcIixlLmlucHV0c1swXS5kYXRhVHlwZSxlLmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO3V0KGUsXCJQb3dcIix7c2NhbGFyOihhLG4pPT5gcG93X2N1c3RvbSgke2F9LCR7bn0pYCx2ZWN0b3I6KGEsbik9PmBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7bn0pYH0sYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dH0sIGIgOiAke3R9KSAtPiAke3R9IHtcbiAgICAgIGlmIChiID09ICR7dH0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0fSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0fSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0fSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0fSgyLjApKSkgIT0gMS4wKSAqICR7dH0oJHt0PT09XCJpMzJcIj9cInJvdW5kXCI6XCJcIn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dH0+LCBiIDogdmVjNDwke3R9PikgLT4gdmVjNDwke3R9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dH0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKX0sY3M9ZT0+e3V0KGUsXCJTdWJcIiwodCxyKT0+YCR7dH0tJHtyfWApfSxwcz1lPT57dXQoZSxcIkdyZWF0ZXJcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PiR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sZnM9ZT0+e3V0KGUsXCJMZXNzXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PCR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fTwke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LG1zPWU9Pnt1dChlLFwiR3JlYXRlck9yRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT49JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxocz1lPT57dXQoZSxcIkxlc3NPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PD0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX19KTt2YXIgTWQsRGQsemQsV2QseXMsYnMsd3M9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO01kPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtsZXQgdD1lWzBdLmRhdGFUeXBlLHI9ZVswXS5kaW1zLmxlbmd0aDtmb3IobGV0IGEgb2YgZSl7aWYoYS5kYXRhVHlwZSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoYS5kaW1zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX19LERkPWU9PmBcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG4gIH1gLHpkPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgsYT1bXTtmb3IobGV0IG49MDtuPHI7KytuKXtsZXQgcz10LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGVbbl0uZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKSk7cj09PTE/YS5wdXNoKHMpOm49PT0wP2EucHVzaChgaWYgKGlucHV0SW5kZXggPT0gJHtufXUpIHsgJHtzfSB9YCk6bj09PXItMT9hLnB1c2goYGVsc2UgeyAke3N9IH1gKTphLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtufSkgeyAke3N9IH1gKX1yZXR1cm4gYS5qb2luKGBcbmApfSxXZD0oZSx0KT0+e2xldCByPWVbMF0uZGltcy5zbGljZSgpO2lmKHQ+PXIubGVuZ3RofHx0PC0xKnIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc24ndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtsZXQgYT10PDA/ci5sZW5ndGgrdDp0LG49ci5zbGljZSgwKTtmb3IobGV0IHY9MTt2PGUubGVuZ3RoO3YrKyl7bGV0ICQ9ZVt2XS5kaW1zLnNsaWNlKCk7Zm9yKGxldCBiPTA7YjxyLmxlbmd0aDtiKyspaWYoYj09PWEpblthXSs9JFtiXTtlbHNlIGlmKHJbYl0hPT0kW2JdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWxldCBzPXouc2l6ZShuKSx1PW5ldyBBcnJheShlLmxlbmd0aCksbD1uZXcgQXJyYXkoZS5sZW5ndGgpLG89ZVswXS5kYXRhVHlwZSxwPTA7Zm9yKGxldCB2PTA7djxlLmxlbmd0aDsrK3YpcCs9ZVt2XS5kaW1zW2FdLHVbdl09cCxsW3ZdPUYoYGlucHV0JHt2fWAsbyxlW3ZdLmRpbXMpO2xldCBtPVgoXCJvdXRwdXRcIixvLG4pLHk9bS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGEpLGc9dj0+YFxuICAke3YuZGVjbGFyZVZhcmlhYmxlcyguLi5sLG0pfVxuXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7dS5sZW5ndGh9Pigke3UubWFwKCQ9PmAkeyR9dWApLmpvaW4oXCIsXCIpfSk7XG4gICR7RGQodS5sZW5ndGgpfVxuXG4gICR7di5tYWluU3RhcnQoKX1cbiAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7eX0pO1xuICAgIGlmIChpbnB1dEluZGV4ICE9IDB1KSB7XG4gICAgICAke3l9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcbiAgICB9XG5cbiAgICAke3pkKGwsbSl9XG4gIH1gO3JldHVybntuYW1lOlwiQ29uY2F0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpnfX0seXM9KGUsdCk9PntNZChlLmlucHV0cyksZS5jb21wdXRlKFdkKGUuaW5wdXRzLHQuYXhpcykpfSxicz1lPT5pZSh7YXhpczplLmF4aXN9KX0pO3ZhciBXZSxhbixvbixzbj1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2U9KGUsdCk9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm5gdmVjMjwke3R9PmA7Y2FzZSAzOnJldHVybmB2ZWMzPCR7dH0+YDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt0fT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2V9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0sYW49KGUsdD0hMSxyPSExLGE9Myk9PlwiXCIsb249KGUsdCk9PmBcbiAgICAgICR7ZT9cInZhbHVlID0gdmFsdWUgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKTtcIjpcIlwifVxuICAgICAgLy8gVE9ETyB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lIHdoZW4gYWN0aXZhdGlvbiBpcyBzdXBwb3J0ZWQgYWJvdmUuXG4gICAgICAvLyAke3Q/XCJ2YWx1ZSA9IGFjdGl2YXRpb24odmFsdWUsIGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgdW4sWm49TCgoKT0+e1widXNlIHN0cmljdFwiO3VuPWBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIG91dFNoYXBlU3RyaWRlcy54LCBvdXRTaGFwZVN0cmlkZXMueSwgb3V0U2hhcGVTdHJpZGVzLnosIDEpKTtcbn1cbmB9KTt2YXIgbG4sZG4saHI9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7bG49KGUsdD0hMSk9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcInZhbHVlID0gbWF4KHZhbHVlLCAwLjApO1wifTtjYXNlXCJTaWdtb2lkXCI6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcInZhbHVlID0gKDEuMCAvICgxLjAgKyBleHAoLXZhbHVlKSkpO1wifTtjYXNlXCJDbGlwXCI6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpgY29uc3QgY2xpcF9taW5fPWYzMigke2UuY2xpcE1pbn0pO2NvbnN0IGNsaXBfbWF4Xz1mMzIoJHtlLmNsaXBNYXh9KTtgLGFwcGx5QWN0aXZhdGlvbjp0P1widmFsdWUgPSBjbGFtcCh2YWx1ZSwgdmVjNChjbGlwX21pbl8pLCB2ZWM0KGNsaXBfbWF4XykpO1wiOlwidmFsdWUgPSBjbGFtcCh2YWx1ZSwgY2xpcF9taW5fLCBjbGlwX21heF8pO1wifTtkZWZhdWx0OnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJcIn19fSxkbj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJDbGlwXCIpe2xldFtyLGFdPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbUXIsWnJdO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDphLGNsaXBNaW46cixhY3RpdmF0aW9uQ2FjaGVLZXk6YCR7dH06JHtyfSwke2F9YH19cmV0dXJue2FjdGl2YXRpb246dCxhY3RpdmF0aW9uQ2FjaGVLZXk6dH19fSk7dmFyIE5kLFZkLGdyLHZzLFVkLHlyLEdkLGNuLGJyPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7aHIoKTtzbigpO05kPShlLHQpPT5lP2BcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYDpgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgLFZkPShlLHQpPT5lP2BcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke3Q9PT0zP1wiXCI6XCJsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddO1wifVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTtcIn1cbiAgICAgICAgfWA6YFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTtcIn1cbiAgICAgICAgfWAsZ3I9KGUsdCxyPVwiZjMyXCIsYSxuPSExLHM9MzIsdT0hMSxsPTMyKT0+e2xldCBvPXRbMV0qZVsxXSxwPXRbMF0qZVswXSxtPW4/bzpzLHk9bj9zOm8sZz1tL3RbMF0sdj1zL3RbMV07aWYoISgobiYmZz09PTQmJmVbMV09PT00fHwhbiYmKGc9PT0zfHxnPT09NCkpJiZtJXRbMF09PT0wJiZzJXRbMV09PT0wJiZlWzBdPT09NCkpdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7bn0gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke2d9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7Z30gbXVzdCBiZSAzIG9yIDQuXG4gIHRpbGVBV2lkdGggJHttfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfS4gdGlsZUlubmVyICR7c30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3RbMV19LiBjb2xQZXJUaHJlYWQgJHtlWzBdfSBtdXN0IGJlIDQuYCk7cmV0dXJuYFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHtnfTwke3J9PiwgJHttL2d9PiwgJHt5fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7cn0+LCAke3AvZVswXX0+LCAke3N9PjtcblxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHtnfTtcbmNvbnN0IHRpbGVJbm5lciA9ICR7c307XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3U/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICR7YT9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7b307XG5cbiAgbGV0IG51bVRpbGVzID0gJHt1P2Ake01hdGguY2VpbChsL3MpfWA6XCIoZGltSW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gIHZhciBrU3RhcnQgPSAke3U/YGkzMihnbG9iYWxJZC56KSAqICR7bH1gOlwiMFwifTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7cn0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7dn07XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICAke05kKG4sYSl9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Z9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7YT9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke2c9PT0zP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XG5cbiAgICAgICAgICAke1ZkKG4sZyl9XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgfVxuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XG4gIH1cbn1gfSx2cz0oZSx0KT0+ZT9gXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGA6YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgLFVkPWU9PmU/XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTtcIjpcImxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdO1wiLHlyPShlLHQscj1cImYzMlwiLGEsbj0hMSxzPTMyLHU9ITEsbD0zMixvPSExKT0+e2xldCBwPWVbMV0qdFsxXSxtPWVbMF0qdFswXSx5PW4/cDpzLGc9bj9zOnA7aWYoIShnJXRbMV09PT0wJiZ5JXRbMF09PT0wJiZzJXRbMV09PT0wKSl0aHJvdyBuZXcgRXJyb3IoYHRpbGVBSGlnaHQgJHtnfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfSwgdGlsZUFXaWR0aCAke3l9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LCB0aWxlSW5uZXIgJHtzfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfWApO2xldCB2PWcvdFsxXSwkPXkvdFswXSxiPXMvdFsxXSxTPW8/YFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHttfTtcblxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2d9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7eX07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgJHt2cyhuLGEpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7c307IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7bX07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke2E/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7dFswXX1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke24/YG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dO2A6YG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dW2tdO2B9XG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfTtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt0WzBdfTtcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYDpgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7dn07XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7JH07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7Yn07XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Z9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAkeyR9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XG4gICAgICAke3ZzKG4sYSl9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtifTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke2E/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICB9XG4gIH1cbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgJHtVZChuKX1cbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya2dyb3VwQmFycmllcigpO1xufVxuXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgfVxufVxuYDtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke3l9PiwgJHtnfT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke219PiwgJHtzfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7c307XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke3U/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICAgJHthP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgICBsZXQgbnVtVGlsZXMgPSAke3U/YCR7TWF0aC5jZWlsKGwvcyl9YDpcIihkaW1Jbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgICB2YXIga1N0YXJ0ID0gJHt1P2BpMzIoZ2xvYmFsSWQueikgKiAke2x9YDpcIjBcIn07XG5cbiAgICB2YXIgYWNjIDogYXJyYXk8YXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcblxuICAgIC8vIFdpdGhvdXQgdGhpcyBpbml0aWFsaXphdGlvbiBzdHJhbmdlIHZhbHVlcyBzaG93IHVwIGluIGFjYy5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSAwLjA7XG4gICAgICB9XG4gICAgfVxuICAgICR7U31cbiAgfVxuYH0sR2Q9KGUsdCxyLGEsbixzPSExKT0+e2xldCB1PW5bMF0sbD1uWzFdLG89blsyXSxwPWFbMF0sbT1hWzFdLHk9YVsyXSxnPWFbM10sdj1Lbih1LG8pLCQ9S24obCxvKSxiPUJlKGFbMF0udHlwZS50ZW5zb3IpLFM9KCk9PntsZXQgQj1tLnJhbmssUD1wLnJhbmssRD1gdmFyIGFJbmRpY2VzOiAke20udHlwZS5pbmRpY2VzfTtgO2ZvcihsZXQgUj1CLTItMSxXPVAtMTtSPj0wO1ItLSxXLS0pRCs9YFxuYUluZGljZXNbJHtSfV0gPSAke1A+MT9gYmF0Y2hJbmRpY2VzWyR7V31dYDpcImJhdGNoSW5kaWNlc1wifTtgO3JldHVybiB2LmZvckVhY2goUj0+e0QrPWBcbmFJbmRpY2VzWyR7Un1dID0gMDtgfSksRCs9YFxuYUluZGljZXNbJHtCLTJ9XSA9IHUzMihyb3cpO1xuICAgICAgICAgICAgICAgICAgIGFJbmRpY2VzWyR7Qi0xfV0gPSB1MzIoY29sSW4pO2AsRH0sST0oKT0+e2xldCBCPXkucmFuayxQPXAucmFuayxEPWB2YXIgYkluZGljZXM6ICR7eS50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBSPUItMi0xLFc9UC0xO1I+PTA7Ui0tLFctLSlEKz1gXG5iSW5kaWNlc1ske1J9XSA9ICR7UD4xP2BiYXRjaEluZGljZXNbJHtXfV1gOlwiYmF0Y2hJbmRpY2VzXCJ9O2A7cmV0dXJuICQuZm9yRWFjaChSPT57RCs9YFxuYkluZGljZXNbJHtSfV0gPSAwO2B9KSxEKz1gXG5iSW5kaWNlc1ske0ItMn1dID0gdTMyKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgYkluZGljZXNbJHtCLTF9XSA9IHUzMihjb2xJbik7YCxEfTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtwLnR5cGUuaW5kaWNlc30pIC0+ICR7V2UoZSxiKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtXZShlLGIpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1Jbm5lcilcbiAgICAgIHtcbiAgICAgICAgJHtTKCl9XG4gICAgICAgIHZhbHVlID0gJHttLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke3AudHlwZS5pbmRpY2VzfSkgLT4gJHtXZShlLGIpfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke1dlKGUsYil9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyKVxuICAgICAge1xuICAgICAgICAke0koKX1cbiAgICAgICAgdmFsdWUgPSAke3kuZ2V0QnlJbmRpY2VzKFwiYkluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke1dlKGUsYil9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7dD9gdmFsdWUgPSB2YWx1ZSArICR7cz9cImJpYXNbY29sSW5dXCI6YCR7V2UoZSxiKX0oYmlhc1tyb3ddKWB9O2A6XCJcIn1cbiAgICAgICAgJHtyfVxuICAgICAgICAke2cuc2V0QnlJbmRpY2VzKFwidmVjMzx1MzI+KGNvb3JkcylcIixcInZhbHVlXCIpfVxuICAgICAgfVxuICAgIH1cbiAgICBgfSxjbj0oZSx0LHIsYSxuPSExKT0+e2xldCBzPWVbMF0uZGltcyx1PWVbMV0uZGltcyxsPXMuc2xpY2UoMCwtMiksbz11LnNsaWNlKDAsLTIpLHA9YT9hLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksbT1GKFwiYmF0Y2hEaW1zXCIsZVswXS5kYXRhVHlwZSxwKSx5PVttXSxnPVtsLG8scF0sdj16LnNpemUocCksJD1zW3MubGVuZ3RoLTJdLGI9c1tzLmxlbmd0aC0xXSxTPXVbdS5sZW5ndGgtMV0sST1iJTQ9PT0wJiZTJTQ9PT0wLHthY3RpdmF0aW9uRnVuY3Rpb246VCxhcHBseUFjdGl2YXRpb246Qn09bG4odCxJKSxQPSQ8PTg/WzQsMSwxXTpbNCw0LDFdLEQ9WzgsOCwxXSxSPVtNYXRoLmNlaWwoUy9EWzBdL1BbMF0pLE1hdGguY2VpbCgkL0RbMV0vUFsxXSksTWF0aC5jZWlsKHYvRFsyXS9QWzJdKV0sVz1CZShlWzBdLmRhdGFUeXBlKSxIPUk/NDoxLEs9RihcImFcIixlWzBdLmRhdGFUeXBlLFsuLi5sLCQsYi9IXSxIKSxsZT1GKFwiYlwiLGVbMV0uZGF0YVR5cGUsWy4uLm8sYixTL0hdLEgpLE09WChcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsW3YsJCxTL0hdLEgpO3kucHVzaChLKSx5LnB1c2gobGUpLHkucHVzaChNKTtsZXQgcT1bSyxsZV0seGU9ZS5sZW5ndGg+MixvZT1HZChILHhlLEIseSxnLG4pO2lmKHhlKXtsZXQgaj1uP0g6MTtxLnB1c2goRihcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxqKSl9bGV0IHdlPWo9PmBcbiAgY29uc3QgZGltQU91dGVyOiBpMzIgPSAkeyR9O1xuICBjb25zdCBkaW1CT3V0ZXI6IGkzMiA9ICR7U307XG4gIGNvbnN0IGRpbUlubmVyOiBpMzIgPSAke2J9O1xuICAke2ouZGVjbGFyZVZhcmlhYmxlcyguLi5xLE0pfVxuICAke1R9XG4gICR7b2V9XG4gICR7ST9ncihQLEQsVyxtKTp5cihQLEQsVyxtKX1cbiAgICAgICAgICAgICAgICAgICAke20uaW1wbCgpfWA7cmV0dXJue25hbWU6XCJNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDp0LmFjdGl2YXRpb25DYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OlJbMF0seTpSWzFdLHo6UlsyXX19KSxnZXRTaGFkZXJTb3VyY2U6d2V9fX0pO3ZhciBGZCwkcyx4cz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHQoKTtnZSgpO3ZlKCk7c24oKTtabigpO2JyKCk7RmQ9KGUsdCxyLGEsbj0hMSxzLHU9ITEsbD00LG89NCxwPTQsbT1cImYzMlwiKT0+e2xldCB5PWxlPT57c3dpdGNoKGxlKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHttfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7bGV9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxnPWxlPT57c3dpdGNoKGxlKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiB3U2hhcGVbM10gKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogd1NoYXBlWzNdIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2xlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sdj1lP2BcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGAsJD1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLGI9ZT9cInhTaGFwZVsxXVwiOlwieFNoYXBlWzJdXCIsUz1lP1wieFNoYXBlWzJdXCI6XCJ4U2hhcGVbM11cIixJPWU/XCJyb3dcIjpcImNvbFwiLFQ9ZT9cImNvbFwiOlwicm93XCIsQj1gXG4gICAgbGV0IGluQ2hhbm5lbHMgPSB3U2hhcGVbMl07XG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xuICAgIGxldCBvdXRSb3cgPSAke0l9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7SX0gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHtUfSAvIChmaWx0ZXJEaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgbGV0IFdDb2wgPSAke1R9IC8gaW5DaGFubmVscyAlIGZpbHRlckRpbXNbMV07XG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiBzdHJpZGVbMF0gKyBkaWxhdGlvblswXSAqIFdSb3cgLSBwYWRbMF07XG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiBzdHJpZGVbMV0gKyBkaWxhdGlvblsxXSAqIFdDb2wgLSBwYWRbMV07XG4gICAgbGV0IHhDaCA9ICR7VH0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHtXZShsLG0pfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHtifSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7U30pIHtcbiAgICAgICR7dn1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgeFNoYXBlKTtcbiAgICAgICR7eShsKX1cbiAgICB9XG4gICAgcmV0dXJuIHJlc0RhdGE7YCxQPWU/dCYmYT9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtsfTtcbiAgICAke0J9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtsfTtcbiAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUlubmVyKSB7XG4gICAgICAke0J9XG4gICAgfVxuICAgIHJldHVybiAke1dlKGwsbSl9KDAuMCk7YDphJiZyP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2x9O1xuICAgICR7Qn1gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2x9O1xuICAgIGlmIChyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcbiAgICAgICR7Qn1cbiAgICB9XG4gICAgcmV0dXJuICR7V2UobCxtKX0oMC4wKTtgLEQ9YCR7ZyhvKX1gLFI9V2UocCxtKSxXPWU/V2UobCxtKTpXZShvLG0pLEg9ZT9XZShvLG0pOldlKGwsbSk7cmV0dXJuYFxuICAgICR7YW4ocyx1LHA9PT00LDQpfVxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7V30ge1xuICAgICAgJHtlP1A6RH1cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke0h9IHtcbiAgICAgICR7ZT9EOlB9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7Un0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7cH07XG4gICAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUJPdXRlcilcbiAgICAgIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XG4gICAgICAkeyR9XG4gICAgICAke29uKG4scyl9XG4gICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9YH0sJHM9KGUsdCxyLGEsbixzLHUsbCk9PntsZXQgbz10LmZvcm1hdD09PVwiTkhXQ1wiLHA9bz9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLG09clswXSx5PW8/clsyXTpyWzNdLGc9bz9yWzFdOnJbMl0sdj1vP3JbM106clsxXSwkPW8mJihwJTQ9PT0wfHxwJTM9PT0wKSYmdiU0PT09MCxiPW8/djp5KmcsUz1vP3kqZzp2LEk9WzgsOCwxXSxUPWE8PTg/WzQsMSwxXTpbNCw0LDFdLEI9W01hdGguY2VpbChiL0lbMF0vVFswXSksTWF0aC5jZWlsKFMvSVsxXS9UWzFdKSxNYXRoLmNlaWwobS9JWzJdL1RbMl0pXTtfZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7Qn1gKTtsZXQgUD0kP28mJnAlNCE9PTA/Mzo0OlRbMF0sRD1JWzFdKlRbMV0sUj1JWzBdKlRbMF0sVz1NYXRoLm1heChJWzBdKlAsSVsxXSksSD1hJUQ9PT0wLEs9biVSPT09MCxsZT1zJVc9PT0wLE09JD9bUCw0LDRdOlsxLDEsMV0scT1CZShlWzBdLmRhdGFUeXBlKSx4ZT1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geDogYXJyYXk8JHskJiZQPT09ND9gdmVjNDwke3F9PmA6cX0+O2AsYEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gdzogYXJyYXk8JHskP2B2ZWM0PCR7cX0+YDpxfT47YF0sb2U9YFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHskP2B2ZWM0PCR7cX0+YDpxfSkge1xuICAgICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7JD9gdmVjNDwke3F9PmA6cX0odmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHskP2B2ZWM0PCR7cX0+YDpxfSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAkeyQ/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xuICAgICAgfWA7cmV0dXJuIHUmJih4ZS5wdXNoKGBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJpYXM6IGFycmF5PCR7JD9gdmVjNDwke3F9PmA6cX0+O2ApLG9lKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7JD9gdmVjNDwke3F9PmA6cX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke28/XCJ3XCI6XCJ5XCJ9JHskP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YCkse25hbWU6XCJDb252MkRNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6QlswXSx5OkJbMV0sejpCWzJdfX0pLGdldFNoYWRlclNvdXJjZTooKT0+YFxuICAgICAgICAke3VufVxuICAgICAgICAvL3N0cnVjdCBVbmlmb3JtcyB7IHhTaGFwZSA6IHZlYzQ8aTMyPiwgd1NoYXBlIDogdmVjNDxpMzI+LCBvdXRTaGFwZSA6IHZlYzQ8aTMyPixcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcbiAgICAgICAgLy8gIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIgfTtcbiAgICAgICAgJHt4ZS5qb2luKFwiXCIpfVxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt4ZS5sZW5ndGh9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0OiBhcnJheTwkeyQ/YHZlYzQ8JHtxfT5gOnF9PjtcbiAgICAgICAgLy9AZ3JvdXAoMCkgQGJpbmRpbmcoJHt4ZS5sZW5ndGgrMX0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgICAgICAgY29uc3QgeFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IHdTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMV0uZGltcy5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBvdXRTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke3Iuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgb3V0U2hhcGVTdHJpZGVzIDogdmVjMzxpMzI+ID0gdmVjMzxpMzI+KCR7ei5jb21wdXRlU3RyaWRlcyhyKS5zbGljZSgwLDMpLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0Lmtlcm5lbFNoYXBlWzBdfSwgJHt0Lmtlcm5lbFNoYXBlWzFdfSk7XG4gICAgICAgIGNvbnN0IHBhZCA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3QucGFkc1swXX0sICR7dC5wYWRzWzFdfSk7XG4gICAgICAgIGNvbnN0IHN0cmlkZSA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Quc3RyaWRlc1swXX0sICR7dC5zdHJpZGVzWzFdfSk7XG4gICAgICAgIGNvbnN0IGRpbGF0aW9uIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5kaWxhdGlvbnNbMF19LCAke3QuZGlsYXRpb25zWzFdfSk7XG4gICAgICAgIGNvbnN0IGRpbUFPdXRlciA6IGkzMiA9ICR7YX07XG4gICAgICAgIGNvbnN0IGRpbUJPdXRlciA6IGkzMiA9ICR7bn07XG4gICAgICAgIGNvbnN0IGRpbUlubmVyIDogaTMyID0gJHtzfTtcbiAgICAgICAgJHtvZX1cbiAgICAgICAgJHtGZChvLEgsSyxsZSx1LHQuYWN0aXZhdGlvbi50b0xvd2VyQ2FzZSgpLCExLE1bMF0sTVsxXSxNWzJdLHEpfVxuICAgICAgICAgICAgJHskP2dyKFQsSSxxLHZvaWQgMCwhbyxXKTp5cihULEkscSx2b2lkIDAsIW8sVywhMSx2b2lkIDAsbCl9YH19fSk7dmFyIGVhLFNzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7cmEoKTtocigpO2VhPShlLHQscik9PntsZXQgYT1lLmxlbmd0aD4yLG49YT9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIscz1lWzBdLmRpbXMsdT1lWzFdLmRpbXMsbD11WzBdL3QuZ3JvdXAse2FjdGl2YXRpb25GdW5jdGlvbjpvLGFwcGx5QWN0aXZhdGlvbjpwfT1sbih0KSxtPXQuZm9ybWF0PT09XCJOSFdDXCIseT10YShzLHUsdC5kaWxhdGlvbnMsdC5wYWRzLHQuc3RyaWRlcyxtKSxnPXouc2l6ZSh5KSx2PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHkpLCQ9RihcInhcIixlWzBdLmRhdGFUeXBlLHMpLGI9RihcIndcIixlWzFdLmRhdGFUeXBlLHUpLFM9WyQsYl07YSYmUy5wdXNoKEYoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMpKTtsZXQgST1UPT5gXG4gIGNvbnN0IHN0cmlkZXM6IHZlYzI8dTMyPiA9IHZlYzIoJHt0LnN0cmlkZXNbMF19dSwgJHt0LnN0cmlkZXNbMV19dSk7XG4gIGNvbnN0IHBhZHM6IHZlYzI8dTMyPiA9IHZlYzIoJHt0LnBhZHNbMF19dSwgJHt0LnBhZHNbMV19dSk7XG5cbiAgJHtULmRlY2xhcmVWYXJpYWJsZXMoLi4uUyx2KX1cblxuICAke299XG5cbiAgJHtULm1haW5TdGFydCgpfVxuICAgICR7VC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGcpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske20/MzoxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHttPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7bT8yOjN9XSkgKiBzdHJpZGVzIC0gcGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsIC8gJHtsfXU7XG5cbiAgICB2YXIgdmFsdWU6ICR7di50eXBlLnZhbHVlfSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8ICR7dVsxXX11OyB3SW5DaGFubmVsKyspIHtcbiAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3VbMV19dSArIHdJbkNoYW5uZWw7XG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8ICR7dVsyXX11OyB3SGVpZ2h0KyspIHtcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3QuZGlsYXRpb25zWzBdfXU7XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49ICR7c1ttPzE6Ml19dSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgJHt1WzNdfXU7IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHt0LmRpbGF0aW9uc1sxXX11O1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gJHtzW20/MjozXX11KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgeFZhbCA9ICR7bT8kLmdldChcImJhdGNoXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIixcImlucHV0X2NoYW5uZWxcIik6JC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIpfTtcbiAgICAgICAgICBsZXQgd1ZhbCA9ICR7Yi5nZXQoXCJvdXRwdXRfY2hhbm5lbFwiLFwid0luQ2hhbm5lbFwiLFwid0hlaWdodFwiLFwid1dpZHRoXCIpfTtcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgJHtufVxuICAgICR7cH1cbiAgICAke3Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWA7cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cj9yKHkpOnksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGcvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpJfX19KTt2YXIgdGEsQ3MsTGQsSXMsbmEsSGQsamQsYWEscmE9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt4cygpO2JyKCk7U3MoKTtocigpO21yKCk7dGE9KGUsdCxyLGEsbixzKT0+e2xldCB1PWVbMF0sbD1lLnNsaWNlKHM/MToyLHM/Mzo0KSxvPWwubGVuZ3RoLHA9dFswXSx5PXQuc2xpY2UoMikubWFwKCgkLGIpPT4kKygkLTEpKihyW2JdLTEpKSx2PWwubWFwKCgkLGIpPT4kK2FbYl0rYVtiK29dKS5tYXAoKCQsYik9Pk1hdGguZmxvb3IoKCQteVtiXStuW2JdKS9uW2JdKSk7cmV0dXJuIHYuc3BsaWNlKDAsMCx1KSx2LnNwbGljZShzPzM6MSwwLHApLHZ9LENzPVsyLDMsMSwwXSxMZD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgY29udiAxRCBhbmQgMkRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLGE9ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYociE9PWEpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IG49ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke259RGApO2lmKHQucGFkcy5sZW5ndGghPT1uKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke24qMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKX0sSXM9KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7Zm9yKGxldCBzPTI7czx0WzFdLmRpbXMubGVuZ3RoOysrcylyW3MtMl09PT0wJiYocltzLTJdPXRbMV0uZGltc1tzXSk7bGV0IGE9ZS5wYWRzLnNsaWNlKCk7TXQuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHRbMF0uZGltcyxlLnN0cmlkZXMsZS5kaWxhdGlvbnMscixhLGUuZm9ybWF0PT09XCJOSFdDXCIsZS5hdXRvUGFkKTtsZXQgbj1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKG4se2tlcm5lbFNoYXBlOnIscGFkczphLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxufSxuYT1lPT57bGV0IHQ9ZG4oZSkscj1lLmZvcm1hdCxhPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sbj1lLmRpbGF0aW9ucyxzPWUuZ3JvdXAsdT1lLmtlcm5lbF9zaGFwZSxsPWUucGFkcyxvPWUuc3RyaWRlcyxwPWUud19pc19jb25zdCgpO3JldHVybiBpZSh7YXV0b1BhZDphLGZvcm1hdDpyLGRpbGF0aW9uczpuLGdyb3VwOnMsa2VybmVsU2hhcGU6dSxwYWRzOmwsc3RyaWRlczpvLHdJc0NvbnN0OnAsLi4udH0pfSxIZD0oZSx0LHIpPT57bGV0IGE9SXMocix0KTtpZihyLmdyb3VwIT09MSl7ZS5jb21wdXRlKGVhKHQsYSkpO3JldHVybn1sZXQgbj1yLmZvcm1hdD09PVwiTkhXQ1wiLHM9dC5sZW5ndGg9PT0zLHU9dFswXS5kaW1zW24/MToyXSxsPXRbMF0uZGltc1tuPzI6M10sbz10WzBdLmRpbXNbbj8zOjFdLHA9dFsxXS5kaW1zWzJdLG09dFsxXS5kaW1zWzNdLHk9dGEodFswXS5kaW1zLHRbMV0uZGltcyxyLmRpbGF0aW9ucyxhLnBhZHMsci5zdHJpZGVzLG4pLGc9eVtuPzE6Ml0sdj15W24/MjozXSwkPXlbbj8zOjFdLGI9biYmcD09PXUmJm09PT1sJiZyLnBhZHNbMF09PT0wJiZyLnBhZHNbMV09PT0wO2lmKGJ8fHA9PT0xJiZtPT09MSYmci5kaWxhdGlvbnNbMF09PT0xJiZyLmRpbGF0aW9uc1sxXT09PTEmJnIuc3RyaWRlc1swXT09PTEmJnIuc3RyaWRlc1sxXT09PTEmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTApe2xldCBSPXlbMF0sVyxILEssbGU9W107aWYobil7bGV0IE09ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoQ3QodFsxXSxDcykse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtpZihyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPU0pLGIpe2xldCBxPXUqbCpvO1c9dFswXS5yZXNoYXBlKFsxLFIscV0pLEg9TS5yZXNoYXBlKFsxLHEsJF0pLEs9WzEsUiwkXX1lbHNlIFc9dFswXS5yZXNoYXBlKFtSLHUqbCxvXSksSD1NLnJlc2hhcGUoWzEsbywkXSksSz1bUixnKnYsJF07bGUucHVzaChXKSxsZS5wdXNoKEgpfWVsc2UgVz10WzBdLnJlc2hhcGUoW1Isbyx1KmxdKSxIPXRbMV0ucmVzaGFwZShbMSwkLG9dKSxLPVtSLCQsZyp2XSxsZS5wdXNoKEgpLGxlLnB1c2goVyk7cyYmbGUucHVzaCh0WzJdKSxlLmNvbXB1dGUoY24obGUsYSx5LEssbikse2lucHV0czpsZX0pO3JldHVybn1sZXQgUz0hMCxJPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKEN0KHRbMV0sQ3MpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1JKTtsZXQgVD1bdFswXSxJXTtzJiZULnB1c2godFsyXSk7bGV0IEI9bj9nKnY6JCxQPW4/JDpnKnYsRD1wKm0qbztlLmNvbXB1dGUoJHMoVCxhLHksQixQLEQscyxTKSx7aW5wdXRzOlR9KX0samQ9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLGE9W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJmEucHVzaChlLmlucHV0c1syXSk7bGV0IG49WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSxzPVsxXS5jb25jYXQodC5zdHJpZGVzKSx1PVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLGw9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSxvPUlzKHsuLi50LHBhZHM6bixzdHJpZGVzOnMsZGlsYXRpb25zOnUsa2VybmVsU2hhcGU6bH0sYSk7ZS5jb21wdXRlKGVhKGEsbyxwPT5yP1twWzBdLHBbMl0scFszXV06W10pKX0sYWE9KGUsdCk9PntMZChlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTM/amQoZSx0KTpIZChlLGUuaW5wdXRzLHQpfX0pO3ZhciBxZCxBcyxFcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHQoKTtnZSgpO3NuKCk7Wm4oKTticigpO3FkPShlLHQ9ITEscixhPSExLG49NCk9PntsZXQgcz1XZShuLFwiZjMyXCIpLHU9ST0+e3N3aXRjaChJKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgd1NoYXBlKV07XCI7Y2FzZSA0OnJldHVybmBcbiAgICAgICAgICAgIGxldCBjb29yZDEgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDEsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCBjb29yZDIgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDIsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCBjb29yZDMgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDMsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCB2MCA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHdTaGFwZSldO1xuICAgICAgICAgICAgbGV0IHYxID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDEsIHdTaGFwZSldO1xuICAgICAgICAgICAgbGV0IHYyID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDIsIHdTaGFwZSldO1xuICAgICAgICAgICAgbGV0IHYzID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDMsIHdTaGFwZSldO1xuICAgICAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPih2MCwgdjEsIHYyLCB2Myk7XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7SX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGw9ZT9gXG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIGlYUiwgaVhDLCB4Q2gpO1xuICAgICAgYDpgXG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgaVhSLCBpWEMpO1xuICAgICAgYCxvPWU/YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGAscD1lP1wib3V0QmFja3Byb3BbMV1cIjpcIm91dEJhY2twcm9wWzJdXCIsbT1lP1wib3V0QmFja3Byb3BbMl1cIjpcIm91dEJhY2twcm9wWzNdXCIseT1lP1wicm93XCI6XCJjb2xcIixnPWU/XCJjb2xcIjpcInJvd1wiLHY9YFxuICAgICAgbGV0IGluQ2hhbm5lbHMgPSAke2U/XCJvdXRCYWNrcHJvcFszXVwiOlwib3V0QmFja3Byb3BbMV1cIn07XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XG4gICAgICBsZXQgb3V0Um93ID0gJHt5fSAvIG91dFdpZHRoO1xuICAgICAgbGV0IG91dENvbCA9ICR7eX0gJSBvdXRXaWR0aDtcblxuICAgICAgbGV0IFdSb3cgPSAke2d9IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICAgIGxldCBXQ29sID0gJHtnfSAvIGluQ2hhbm5lbHMgJSBmaWx0ZXJEaW1zWzFdO1xuICAgICAgbGV0IHhSID0gZjMyKG91dFJvdyAtIHBhZHNbMF0gKyBkaWxhdGlvblswXSAqIFdSb3cpIC8gZjMyKHN0cmlkZXNbMF0pO1xuICAgICAgbGV0IHhDID0gZjMyKG91dENvbCAtIHBhZHNbMV0gKyBkaWxhdGlvblsxXSAqIFdDb2wpIC8gZjMyKHN0cmlkZXNbMV0pO1xuICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49IGYzMigke3B9KSB8fCBmcmFjdCh4UikgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7c30oMC4wKTtcbiAgICAgIH1cbiAgICAgIGlmICh4QyA8IDAuMCB8fCB4QyA+PSBmMzIoJHttfSkgfHwgZnJhY3QoeEMpID4gMC4wKSB7XG4gICAgICAgIHJldHVybiAke3N9KDAuMCk7XG4gICAgICB9XG4gICAgICBsZXQgaVhSID0gaTMyKHhSKTtcbiAgICAgIGxldCBpWEMgPSBpMzIoeEMpO1xuICAgICAgbGV0IHhDaCA9ICR7Z30gJSBpbkNoYW5uZWxzO1xuICAgICAgJHtsfVxuICAgICAgcmV0dXJuIHhbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHhTaGFwZSkvJHtufV07YCwkPWU/YFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcbiAgICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltSW5uZXIpIHtcbiAgICAgICAgJHt2fVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7c30oMC4wKTtgOmBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XG4gICAgICBpZiAocm93IDwgZGltSW5uZXIgJiYgY29sIDwgZGltQk91dGVyKSB7XG4gICAgICAgICR7dn1cbiAgICAgIH1cbiAgICAgIHJldHVybiAke3N9KDAuMCk7YCxiPWBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7ZT9cIm91dEJhY2twcm9wWzNdXCI6XCJvdXRCYWNrcHJvcFsxXVwifTtcbiAgICAgIGxldCBjb29yZFggPSBmaWx0ZXJEaW1zLnggLSAxIC0gcm93IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICAgIGxldCBjb29yZFkgPSBmaWx0ZXJEaW1zLnkgLSAxIC0gKHJvdyAvIGluQ2hhbm5lbHMpICUgZmlsdGVyRGltc1sxXTtcbiAgICAgIGlmICgke2U/XCJyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXJcIjpcInJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUFPdXRlclwifSAgJiYgY29vcmRYID49IDAgJiYgY29vcmRZID49IDApIHtcbiAgICAgICAgbGV0IHJvd0lubmVyID0gcm93ICUgaW5DaGFubmVscztcbiAgICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wsIHJvd0lubmVyKTtcbiAgICAgICAgJHt1KG4pfVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7c30oMC4wKTtcbiAgICAgIGA7cmV0dXJuYFxuICAke2FuKHIsYSxuPT09NCw0KX1cbiAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtzfSB7XG4gICAgJHtlPyQ6Yn1cbiAgfVxuXG4gIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7c30ge1xuICAgICR7ZT9iOiR9XG4gIH1cblxuICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUlucHV0IDogJHtzfSkge1xuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XG4gICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW5wdXQ7XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XG4gICAgICAke299XG4gICAgICAke29uKHQscil9XG4gICAgICByZXN1bHRbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzLCBvdXRTaGFwZSkvJHtufV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1gfSxBcz0oZSx0LHIsYSxuLHMsdSxsKT0+e2xldCBvPXQuZm9ybWF0PT09XCJOSFdDXCIscD1vP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sbT1yWzBdLHk9bz9yWzJdOnJbM10sZz1vP3JbMV06clsyXSx2PW8/clszXTpyWzFdLCQ9bz9wJTQ9PT0wJiZ2JTQ9PT0wOnklND09PTAmJnYlND09PTAsYj1vP3Y6eSpnLFM9bz95Kmc6dixJPSQ/WzgsOCwxXTpbYjw9NHx8Uzw9ND80OjE2LGI+NCYmUzw9ND80OjE2LDFdLFQ9JD9bNCw0LDFdOltiPD00PzE6NCxiPjQmJlM8PTQ/MTo0LDFdLEI9W01hdGguY2VpbChiL0lbMF0vVFswXSksTWF0aC5jZWlsKFMvSVsxXS9UWzFdKSxNYXRoLmNlaWwobS9JWzJdL1RbMl0pXTtfZShcInZlcmJvc2VcIiwoKT0+YFtjb252X2JhY2twcm9wX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke0J9YCk7bGV0IFA9JD80OjEsRD1NYXRoLm1heChJWzBdKlAsSVsxXSksUj1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geDogYXJyYXk8JHskP1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O2AsXCJAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IFc6IGFycmF5PGYzMj47XCJdLFc9XCJcIjtyZXR1cm4gdSYmKFIucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzOiBhcnJheTwkeyQ/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifT47YCksVys9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAkeyQ/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7bz9cIndcIjpcInlcIn0keyQ/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gKSx7bmFtZTpcIkNvbnYyRFRyYW5zcG9zZU1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpCWzBdLHk6QlsxXSx6OkJbMl19fSksZ2V0U2hhZGVyU291cmNlOigpPT5gXG4gICAgICAgICR7dW59XG4gICAgICAgICR7Ui5qb2luKGBcbmApfVxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtSLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PCR7JD9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtcbiAgICAgICAgY29uc3Qgb3V0QmFja3Byb3AgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzBdLmRpbXMuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3QgeFNoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IHdTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMV0uZGltcy5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBvdXRTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke3Iuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgb3V0U2hhcGVTdHJpZGVzIDogdmVjMzxpMzI+ID0gdmVjMzxpMzI+KCR7ei5jb21wdXRlU3RyaWRlcyhyKS5zbGljZSgwLDMpLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0Lmtlcm5lbFNoYXBlW28/MToyXX0sICR7dC5rZXJuZWxTaGFwZVtvPzI6M119KTtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA6IHZlYzI8aTMyPiA9IGZpbHRlckRpbXMgKyB2ZWMyPGkzMj4oXG4gICAgICAgICAgICAgICR7dC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVtvPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpfSxcbiAgICAgICAgICAgICAgJHt0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW28/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSl9KTtcbiAgICAgICAgY29uc3QgcGFkcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPihpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1swXSkgLSAxIC0gKCR7dC5wYWRzWzBdK3QucGFkc1syXX0pLzIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdKSAtIDEgLSAoJHt0LnBhZHNbMV0rdC5wYWRzWzNdfSkvMik7XG4gICAgICAgIGNvbnN0IHN0cmlkZXMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LnN0cmlkZXNbMF19LCAke3Quc3RyaWRlc1sxXX0pO1xuICAgICAgICBjb25zdCBkaWxhdGlvbiA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3QuZGlsYXRpb25zWzBdfSwgJHt0LmRpbGF0aW9uc1sxXX0pO1xuICAgICAgICBjb25zdCBkaW1BT3V0ZXIgOiBpMzIgPSAke2F9O1xuICAgICAgICBjb25zdCBkaW1CT3V0ZXIgOiBpMzIgPSAke259O1xuICAgICAgICBjb25zdCBkaW1Jbm5lciA6IGkzMiA9ICR7c307XG4gICAgICAgICR7V31cbiAgICAgICAgJHtxZChvLHUsdC5hY3RpdmF0aW9uLnRvTG93ZXJDYXNlKCksITEsUCl9XG4gICAgICAgICR7JD9ncihULEksXCJmMzJcIix2b2lkIDAsIW8sRCk6eXIoVCxJLFwiZjMyXCIsdm9pZCAwLCFvLEQsITEsdm9pZCAwLGwpfWB9fX0pO3ZhciBLZCxvYSxfcz1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHQoKTtnZSgpO3ZlKCk7S2Q9KGUsdCxyLGEsbixzLHU9ITEsbCk9PntsZXQgbz1yLmZvcm1hdD09PVwiTkhXQ1wiLHA9bz8xOjIsbT1vPzI6Myx5PW8/MzoxLGc9ei5zaXplKGEpLHY9dT8yOjEsJD1yLmdyb3VwLGI9dFsxXS5kaW1zLFM9YlswXS8kLEk9YlsxXSxUPWBcbiAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiB1MzIsIHZhbHVlIDogJHt1P2B2ZWM0PCR7bH0+YDpsfSkge1xuICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt1P2B2ZWM0PCR7bH0+YDpsfSh2YWx1ZSk7XG4gIH1gO24mJihUKz1gXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHt1P2B2ZWM0PCR7bH0+YDpsfSB7XG4gICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtvP1wid1wiOlwieVwifSR7dT9cIi8gNFwiOlwiXCJ9XTtcbiAgICB9YCk7bGV0IEI9dT80OjEsUD1GKFwiV1wiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLEIpLEQ9RihcIkR5XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsQiksUj1bRCxQXTtuJiZSLnB1c2goRihcImJpYXNcIix0WzJdLmRhdGFUeXBlLFthW3ldXSxCKSk7bGV0IFc9WChcInJlc3VsdFwiLHRbMF0uZGF0YVR5cGUsYSxCKSxIPWB7XG4gICAgICAgIGxldCBiYXRjaDogdTMyID0gJHtzP1wiZ2xvYmFsX2lkLnpcIjpcIndvcmtncm91cF9pZC56XCJ9IC8gb3V0U2hhcGVbMV07XG4gICAgICAgIGxldCByID0gJHtzP1wiZ2xvYmFsX2lkLnpcIjpcIndvcmtncm91cF9pZC56XCJ9ICUgb3V0U2hhcGVbMV07XG4gICAgICAgIGxldCBjID0gJHtzP1wiZ2xvYmFsX2lkLnlcIjpcIndvcmtncm91cF9pZC55XCJ9ICogJHt2fTtcbiAgICAgICAgbGV0IGQxOiB1MzIgPSAke3M/XCJnbG9iYWxfaWQueFwiOlwid29ya2dyb3VwX2lkLnhcIn0gKiA0O1xuXG4gICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB2ZWMyPGkzMj4ocGFkcyk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICB2YXIgZG90UHJvZDogYXJyYXk8dmVjNDwke2x9PiwgJHt2fT47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt2fTsgaSsrKSB7XG4gICAgICAgICAgZG90UHJvZFtpXSA9IHZlYzQ8JHtsfT4oMC4wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCBmaWx0ZXJEaW1zWzBdOyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgIHZhciBkeVIgPSAoJHtsfShkeUNvcm5lci54KSArICR7bH0od1IpKSAvICR7bH0oc3RyaWRlcy54KTtcbiAgICAgICAgICBsZXQgd1JQZXJtID0gZmlsdGVyRGltc1swXSAtIDEgLSB3UjtcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2x9KG91dEJhY2twcm9wWzFdKSB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wIHx8IHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCBmaWx0ZXJEaW1zWzFdOyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgbGV0IGR5QyA9ICgke2x9KGR5Q29ybmVyLnkpICsgJHtsfSh3QykpIC8gJHtsfShzdHJpZGVzLnkpO1xuICAgICAgICAgICAgbGV0IGR5QzIgPSAoJHtsfShkeUNvcm5lci55KSArIDEuMCArICR7bH0od0MpKSAvICR7bH0oc3RyaWRlcy55KTtcbiAgICAgICAgICAgIGxldCB3Q1Blcm0gPSBmaWx0ZXJEaW1zWzFdIC0gMSAtIHdDO1xuICAgICAgICAgICAgaWYgKHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbDIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtsfShvdXRCYWNrcHJvcFsyXSkgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGJEeUNWYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeUMyIDwgMC4wIHx8IGR5QzIgPj0gJHtsfShvdXRCYWNrcHJvcFsyXSkgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMyKSA+IDAuMCkge1xuICAgICAgICAgICAgICBiRHlDVmFsMiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XG4gICAgICAgICAgICBsZXQgaWR5QzI6IHUzMiA9IHUzMihkeUMyKTtcbiAgICAgICAgICAgIGlmIChiRHlDVmFsICYmIGJEeUNWYWwyKSB7XG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IG91dEJhY2twcm9wWzNdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMiA6dTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMlwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtsfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMF0gPSBkb3RQcm9kWzBdICsgdG1wdmFsO1xuXG4gICAgICAgICAgICAgICAgeFZhbHVlID0gICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5QzJcIixcImQyXCIpfTtcblxuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdmVjNDwke2x9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbCkge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSBvdXRCYWNrcHJvcFske3l9XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDJcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5Q1wiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7bH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSBvdXRCYWNrcHJvcFszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHtQLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke1AuZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDJcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7UC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7RC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5QzJcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2x9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFsxXSA9IGRvdFByb2RbMV0gKyB0bXB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHt2fTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZFtpXSArICR7bj9cImJpYXNbYytpXVwiOlwiMC4wXCJ9O1xuICAgICAgICAgICR7Vy5zZXQoXCJiYXRjaFwiLFwiclwiLFwiYyArIGlcIixcImQxXCIsXCJ2YWx1ZVwiKX07XG4gICAgICAgIH1cbiAgICAgIH1gLEs9YFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtXLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgIGxldCBiYXRjaCA9ICR7Vy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLDApfTtcbiAgICAgICAgICBsZXQgZDEgPSAke1cuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgbGV0IHIgPSAke1cuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixwKX07XG4gICAgICAgICAgbGV0IGMgPSAke1cuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixtKX07XG4gICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHBhZHM7XG4gICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG4gICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvICR7SX07XG4gICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogJHtJfTtcbiAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICB2YXIgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCBlZmZlY3RpdmVGaWx0ZXJEaW1zLng7IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgICBpZiAod1IgJSBkaWxhdGlvbnMueCAhPSAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGR5UiA9ICgke2x9KGR5UkNvcm5lcikgKyAke2x9KHdSKSkgLyAke2x9KHN0cmlkZXNbMF0pO1xuICAgICAgICAgICAgbGV0IHdSUGVybSA9IGZpbHRlckRpbXMueCAtIDEgLSB3UiAvIGRpbGF0aW9ucy54O1xuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtsfShvdXRCYWNrcHJvcFske3B9XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgIHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IGVmZmVjdGl2ZUZpbHRlckRpbXMueTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdDICUgZGlsYXRpb25zLnkgIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtsfShkeUNDb3JuZXIpICsgJHtsfSh3QykpIC8gJHtsfShzdHJpZGVzLnkpO1xuICAgICAgICAgICAgICBsZXQgd0NQZXJtID0gZmlsdGVyRGltcy55IC0gMSAtIHdDIC8gZGlsYXRpb25zLnk7XG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7bH0ob3V0QmFja3Byb3BbJHttfV0pIHx8XG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wIHx8IHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XG4gICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogJHtTfTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgJHtTfTsgZDIgPSBkMiArIDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtvP0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImlucHV0Q2hhbm5lbFwiKTpELmdldChcImJhdGNoXCIsXCJpbnB1dENoYW5uZWxcIixcImlkeVJcIixcImlkeUNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUgPSAke1AuZ2V0KFwiaW5wdXRDaGFubmVsXCIsXCJ3T3V0Q2hhbm5lbFwiLFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIpfTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2QgKyAke24/XCJiaWFzW2QxXVwiOlwiMC4wXCJ9O1xuICAgICAgICAgICR7Vy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgICAgYDtyZXR1cm5gXG4gICR7ZS5kZWNsYXJlVmFyaWFibGVzKC4uLlIsVyl9XG4gICR7VH1cbiAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PHUzMj4gPSB2ZWM0PHUzMj4oJHthLmpvaW4oXCIsXCIpfSk7XG4gIGNvbnN0IG91dEJhY2twcm9wIDogdmVjNDx1MzI+ID0gdmVjNDx1MzI+KCR7dFswXS5kaW1zLmpvaW4oXCIsXCIpfSk7XG4gIGNvbnN0IHN0cmlkZXMgOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4oJHtyLnN0cmlkZXNbMF19LCAke3Iuc3RyaWRlc1sxXX0pO1xuICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KCR7ci5rZXJuZWxTaGFwZVtvPzE6Ml19LCAke3Iua2VybmVsU2hhcGVbbz8yOjNdfSk7XG4gIGNvbnN0IGRpbGF0aW9ucyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke3IuZGlsYXRpb25zWzBdfSwgJHtyLmRpbGF0aW9uc1sxXX0pO1xuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zIDogdmVjMjx1MzI+ID0gZmlsdGVyRGltcyArIHZlYzI8dTMyPihcbiAgICAgICAgICAke3IuZGlsYXRpb25zWzBdPD0xPzA6KHIua2VybmVsU2hhcGVbbz8xOjJdLTEpKihyLmRpbGF0aW9uc1swXS0xKX0sXG4gICAgICAgICAgJHtyLmRpbGF0aW9uc1sxXTw9MT8wOihyLmtlcm5lbFNoYXBlW28/MjozXS0xKSooci5kaWxhdGlvbnNbMV0tMSl9KTtcbiAgY29uc3QgcGFkcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPihpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1swXSkgLSAxIC0gKCR7ci5wYWRzWzBdK3IucGFkc1syXX0pLzIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTMyKGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0pIC0gMSAtICgke3IucGFkc1sxXStyLnBhZHNbM119KS8yKTtcbiAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZyl9O1xuICAke3U/SDpLfX1gfSxvYT0oZSx0LHIpPT57bGV0IGE9ZS5sZW5ndGg+MixuPXQub3V0cHV0U2hhcGUscz16LnNpemUobiksdT1bTWF0aC5jZWlsKHMvNjQpLDEsMV07X2UoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX2JhY2twcm9wX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3V9YCk7bGV0IGw9QmUoZVswXS5kYXRhVHlwZSk7cmV0dXJue25hbWU6XCJDb252VHJhbnNwb3NlMkRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6dVswXSx5OnVbMV0sejp1WzJdfSxvdXRwdXRzOlt7ZGltczpyP3Iobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV19KSxnZXRTaGFkZXJTb3VyY2U6bz0+S2QobyxlLHQsbixhLHVbMV09PT0xJiZ1WzJdPT09MSwhMSxsKX19fSk7dmFyIFlkLFhkLEpkLE9zLFRzLFFkLFpkLGVjLHRjLFJzLFBzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtrZSgpO0VzKCk7X3MoKTtocigpO21yKCk7WWQ9KGUsdCxyLGEsbixzKT0+KGUtMSkqdCtyKyhhLTEpKm4rMS1zLFhkPShlLHQscixhLG4pPT57bGV0IHM9TWF0aC5mbG9vcihlLzIpO3Q9PT1cIlNBTUVfVVBQRVJcIj8oclthXT1zLHJbbl09ZS1zKTp0PT09XCJTQU1FX0xPV0VSXCImJihyW2FdPWUtcyxyW25dPXMpfSxKZD0oZSx0LHIsYSxuLHMsdSxsLG8scCk9PntsZXQgbT1lLmxlbmd0aC0yLHk9cC5sZW5ndGg9PT0wO2lmKG8ubGVuZ3RoPT09MClmb3IobGV0ICQ9MDskPG07KyskKW8ucHVzaCgwKTtsZXQgZz1lWzBdLHY9dFtsPzM6MV0qbjtmb3IobGV0ICQ9MCxiPWUubGVuZ3RoLW0tKGw/MTowKTskPG07KyskLCsrYil7bGV0IFM9ZVtiXSxJPXk/Uyp1WyRdOnBbJF0sVD1ZZChTLHVbJF0sc1skXSx0W2JdLHJbJF0sSSk7WGQoVCxhLHMsJCwkK20pLHkmJnAucHVzaCh1WyRdKihTLTEpK29bJF0rKHRbYl0tMSkqclskXSsxLXNbJF0tc1skK21dKX1wLnNwbGljZSgwLDAsZykscC5zcGxpY2UobD8zOjEsMCx2KX0sT3M9KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7aWYoZS5rZXJuZWxTaGFwZS5sZW5ndGg9PT0wfHxlLmtlcm5lbFNoYXBlLnJlZHVjZSgoZyx2KT0+Zyp2LDEpPT09MCl7ci5sZW5ndGg9MDtmb3IobGV0IGc9MjtnPHRbMV0uZGltcy5sZW5ndGg7KytnKXIucHVzaCh0WzFdLmRpbXNbZ10pfWxldCBhPWUuZm9ybWF0PT09XCJOSFdDXCI7ci5zcGxpY2UoMCwwLHRbMV0uZGltc1swXSksci5zcGxpY2UoYT8zOjEsMCx0WzFdLmRpbXNbMV0pO2xldCBuPWUucGFkcy5zbGljZSgpLHM9ZS5vdXRwdXRTaGFwZS5zbGljZSgpLHU9ZS5vdXRwdXRQYWRkaW5nLnNsaWNlKCksbD10WzBdLmRpbXMsbz1lLmRpbGF0aW9ucy5zbGljZSgpO2lmKG8ucmVkdWNlKChnLHYpPT5nK3YsMCk9PT0wKXtsZXQgZz10WzBdLmRpbXMubGVuZ3RoLTI7bz1uZXcgQXJyYXkoZykuZmlsbCgxKX1sZXQgcD1lLnN0cmlkZXMuc2xpY2UoKTtpZihwLnJlZHVjZSgoZyx2KT0+Zyt2LDApPT09MCl7bGV0IGc9dFswXS5kaW1zLmxlbmd0aC0yO3A9bmV3IEFycmF5KGcpLmZpbGwoMSl9SmQobCxyLG8sZS5hdXRvUGFkLGUuZ3JvdXAsbixwLGEsdSxzKTtsZXQgbT1PYmplY3QuYXNzaWduKHt9LGUpLHk9ZS5jYWNoZUtleStbci5qb2luKFwibixcIiksbi5qb2luKFwiLFwiKSxwLmpvaW4oXCIsXCIpLHUuam9pbihcIixcIikscy5qb2luKFwiLFwiKSxvLmpvaW4oXCIsXCIpXS5qb2luKFwiX1wiKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihtLHtrZXJuZWxTaGFwZTpyLHBhZHM6bixvdXRwdXRQYWRkaW5nOnUsb3V0cHV0U2hhcGU6cyxkaWxhdGlvbnM6byxzdHJpZGVzOnAsY2FjaGVLZXk6eX0pLG19LFRzPWU9PntsZXQgdD1kbihlKSxyPWUuZm9ybWF0LGE9W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVt0eXBlb2YgZS5hdXRvUGFkPlwidVwiPzA6ZS5hdXRvUGFkXSxuPWUuZGlsYXRpb25zLHM9ZS5ncm91cCx1PWUua2VybmVsU2hhcGUsbD1lLnBhZHMsbz1lLnN0cmlkZXMscD1lLndJc0NvbnN0KCksbT1lLm91dHB1dFBhZGRpbmcseT1lLm91dHB1dFNoYXBlO3JldHVybiBpZSh7YXV0b1BhZDphLGZvcm1hdDpyLGRpbGF0aW9uczpuLGdyb3VwOnMsa2VybmVsU2hhcGU6dSxvdXRwdXRQYWRkaW5nOm0sb3V0cHV0U2hhcGU6eSxwYWRzOmwsc3RyaWRlczpvLHdJc0NvbnN0OnAsLi4udH0pfSxRZD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCByPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxhPWVbMV0uZGltc1swXTtpZihyIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2xldCBuPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzJdLmRpbXNbMF0hPT1uKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IHM9ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLnJlZHVjZSgobSx5KT0+bSt5LDApPjAmJnQuZGlsYXRpb25zLmxlbmd0aCE9PXMpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c31EYCk7aWYodC5zdHJpZGVzLnJlZHVjZSgobSx5KT0+bSt5LDApPjAmJnQuc3RyaWRlcy5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzfURgKTtpZih0LnBhZHMucmVkdWNlKChtLHkpPT5tK3ksMCk+MCYmdC5wYWRzLmxlbmd0aCE9PXMqMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7cyoyfURgKTtpZih0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09cyYmdC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtzfURgKTtpZih0Lmtlcm5lbFNoYXBlLnJlZHVjZSgobSx5KT0+bSt5LDApPjAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYodC5vdXRwdXRTaGFwZS5sZW5ndGghPT0wJiZ0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG91dHB1dCBzaGFwZVwiKX0sWmQ9WzIsMywxLDBdLGVjPShlLHQscik9PntsZXQgYT1PcyhyLHQpLG49ci5mb3JtYXQ9PT1cIk5IV0NcIixzPXQubGVuZ3RoPT09MztpZihhLmdyb3VwIT09MSl7ZS5jb21wdXRlKG9hKHQsYSkpO3JldHVybn1sZXQgdT1hLm91dHB1dFNoYXBlLGw9dVtuPzE6Ml0sbz11W24/MjozXSxwPXVbbj8zOjFdLG09dFsxXS5kaW1zWzJdLHk9dFsxXS5kaW1zWzNdLGc9dFswXS5kaW1zW24/MzoxXSx2PW4/bCpvOnAsJD1uP3A6bCpvLGI9bSp5KmcsUz0hMCxJPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKEN0KHRbMV0sWmQpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1JKTtsZXQgVD1bdFswXSxJXTtzJiYoIW4mJnRbMl0uZGltcy5sZW5ndGg9PT0xP1QucHVzaCh0WzJdLnJlc2hhcGUoW3RbMl0uZGltc1swXSwxLDFdKSk6VC5wdXNoKHRbMl0pKSxlLmNvbXB1dGUoQXMoVCxhLHUsdiwkLGIscyxTKSx7aW5wdXRzOlR9KX0sdGM9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLGE9W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2EubGVuZ3RoPT09MyYmYS5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbj10Lmtlcm5lbFNoYXBlOyhuLmxlbmd0aD09PTB8fG5bMF09PT0wKSYmKG49W2UuaW5wdXRzWzFdLmRpbXNbMl1dKTtsZXQgcz10LmRpbGF0aW9uczsocy5sZW5ndGg9PT0wfHxzWzBdPT09MCkmJihzPVsxXSk7bGV0IHU9dC5zdHJpZGVzOyh1Lmxlbmd0aD09PTB8fHVbMF09PT0wKSYmKHU9WzFdKTtsZXQgbD10LnBhZHM7bC5sZW5ndGg9PT0wJiYobD1bMCwwXSksbD1bMCxsWzBdLDAsbFsxXV0sdT1bMV0uY29uY2F0KHUpLHM9WzFdLmNvbmNhdChzKSxuPVsxXS5jb25jYXQobik7bGV0IG89T3Moey4uLnQscGFkczpsLHN0cmlkZXM6dSxkaWxhdGlvbnM6cyxrZXJuZWxTaGFwZTpufSxhKTtlLmNvbXB1dGUob2EoYSxvLHA9PnI/W3BbMF0scFsyXSxwWzNdXTpbcFswXSxwWzFdLHBbM11dKSl9LFJzPShlLHQpPT57UWQoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zP3RjKGUsdCk6ZWMoZSxlLmlucHV0cyx0KX19KTt2YXIgaWEscG4sa3MscmMsbmMsc2EsdWEsYWMsQnMsTXMsRHM9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO2lhPVwiW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuXCIscG49XCIoXCIraWErXCIpK1wiLGtzPVwiXlwiK3BuK1wiJFwiLHJjPVwiKFwiK3BuK1wiLCkqXCIrcG4sbmM9XCJeXCIrcmMrXCIkXCIsc2E9Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxyKXtsZXQgYT10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7YT09PXZvaWQgMD9hPVtyXTphLnB1c2gociksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQsYSl9fSx1YT1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMuZXF1YXRpb249cjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbYSxuXT1yLmluY2x1ZGVzKFwiLT5cIik/ci5zcGxpdChcIi0+XCIsMik6W3IsXCJcIl07aWYoIWEubWF0Y2goUmVnRXhwKG5jKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihhLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChsLG8pPT57bGV0IHA9dFtvXS5kaW1zLnNsaWNlKCk7aWYoIWwubWF0Y2goUmVnRXhwKGtzKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgbT10aGlzLnByb2Nlc3NUZXJtKGwsITAscCxvKTt0aGlzLmxocy5wdXNoKG0pfSksbj09PVwiXCIpbis9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbbCxvXSk9Pm8uY291bnQ9PT0xfHxsPT09XCIuLi5cIikubWFwKChbbF0pPT5sKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW4ubWF0Y2goUmVnRXhwKHBuKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7bi5tYXRjaChSZWdFeHAoaWEsXCJnXCIpKT8uZm9yRWFjaChsPT57aWYobD09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IG89dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGwpO2lmKG89PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKG8uZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obiwhMCx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LHIsYSl7bGV0IG49dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG4hPT12b2lkIDApe2lmKG4uZGltVmFsdWUhPT1yJiZuLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7bi5jb3VudCsrLG4uaW5wdXRJbmRpY2VzLnB1c2goYSl9ZWxzZSBuPXtjb3VudDoxLGRpbVZhbHVlOnIsaW5wdXRJbmRpY2VzOlthXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbil9cHJvY2Vzc1Rlcm0odCxyLGEsbj0tMSl7bGV0IHM9YS5sZW5ndGgsdT0hMSxsPVtdLG89MDtpZighdC5tYXRjaChSZWdFeHAoa3MpKSYmIXImJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IHA9dC5tYXRjaChSZWdFeHAoaWEsXCJnXCIpKSxtPW5ldyBzYShuKTtyZXR1cm4gcD8uZm9yRWFjaCgoeSxnKT0+e2lmKHk9PT1cIi4uLlwiKXtpZih1KXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7dT0hMDtsZXQgdj1zLXAubGVuZ3RoKzE7aWYodjwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYobD1hLnNsaWNlKG8sbyt2KSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1sLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWwudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYocil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWw7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgJD0wOyQ8bC5sZW5ndGg7JCsrKXtsZXQgYj1TdHJpbmcuZnJvbUNoYXJDb2RlKFwiMFwiLmNoYXJDb2RlQXQoMCkrZyk7bS5hZGRTeW1ib2woYixnKyQpLHRoaXMuYWRkU3ltYm9sKGIsYVtvKytdLG4pfX1lbHNlIG0uYWRkU3ltYm9sKHksZyksdGhpcy5hZGRTeW1ib2woeSxhW28rK10sbil9KSxtfX0sYWM9KGUsdCk9PntsZXQgcj1lWzBdLmRhdGFUeXBlLGE9bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IEI9MDtCPGUubGVuZ3RoOysrQilhW0JdPUYoYGlucHV0JHtCfWAscixlW0JdLmRpbXMpO2xldCBuPXQub3V0cHV0RGltcyxzPXouc2l6ZShuKSx1PVgoXCJvdXRwdXRcIixyLG4pLGw9W10sbz1BcnJheS5mcm9tKHQucmhzLnN5bWJvbFRvSW5kaWNlcy5rZXlzKCkpLHA9XCJ2YXIgcHJvZCA9IDEuMDtcIixtPVwidmFyIHN1bSA9IDAuMDtcIix5PVwic3VtICs9IHByb2Q7XCIsZz1bXSx2PVtdLCQ9W10sYj1bXSxTPXQuc3ltYm9sVG9JbmZvLnNpemU9PT1vLmxlbmd0aDt0LnN5bWJvbFRvSW5mby5mb3JFYWNoKChCLFApPT57aWYoby5pbmNsdWRlcyhQKSl7bGV0IEQ9by5pbmRleE9mKFApO3QubGhzLmZvckVhY2goKFIsVyk9PntpZihCLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhXKSl7bGV0IEg9Ui5zeW1ib2xUb0luZGljZXMuZ2V0KFApO2lmKEg9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7SC5mb3JFYWNoKEs9PntsLnB1c2goYCR7YVtXXS5pbmRpY2VzU2V0KGBpbnB1dCR7V31JbmRpY2VzYCxLLHUuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixEKSl9YCl9KX19KX1lbHNlIHQubGhzLmZvckVhY2goKEQsUik9PntsZXQgVz10LnN5bWJvbFRvSW5mby5nZXQoUCk7aWYoVz09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtpZihXLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhSKSl7bGV0IEg9RC5zeW1ib2xUb0luZGljZXMuZ2V0KFApO2lmKEg9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7SC5mb3JFYWNoKEs9PntnLnB1c2goYCR7YVtSXS5pbmRpY2VzU2V0KGBpbnB1dCR7Un1JbmRpY2VzYCxLLGAke1B9YCl9YCl9KSxiLnB1c2goYHByb2QgKj0gJHthW1JdLmdldEJ5SW5kaWNlcyhgaW5wdXQke1J9SW5kaWNlc2ApfTtgKX19KSx2LnB1c2goYGZvcih2YXIgJHtQfTogdTMyID0gMDsgJHtQfSA8ICR7dC5zeW1ib2xUb0luZm8uZ2V0KFApPy5kaW1WYWx1ZX07ICR7UH0rKykge2ApLCQucHVzaChcIn1cIil9KTtsZXQgST1TP1suLi5sLGBsZXQgc3VtID0gJHthLm1hcCgoQixQKT0+Qi5nZXRCeUluZGljZXMoYGlucHV0JHtQfUluZGljZXNgKSkuam9pbihcIiAqIFwiKX07YF06Wy4uLmwsbSwuLi52LC4uLmcscCwuLi5iLHksLi4uJF0sVD1CPT5gXG4gICAgICAke0IuZGVjbGFyZVZhcmlhYmxlcyguLi5hLHUpfVxuXG4gICAgICAke0IubWFpblN0YXJ0KCl9XG4gICAgICAgICR7Qi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHMpfVxuICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgJHthLm1hcCgoUCxEKT0+YHZhciBpbnB1dCR7RH1JbmRpY2VzOiAke2FbRF0udHlwZS5pbmRpY2VzfTtgKS5qb2luKGBcbmApfVxuICAgICAgICAke0kuam9pbihgXG5gKX07XG4gICAgICAgICR7dS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInN1bVwiKX07XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIkVpbnN1bVwiLHNoYWRlckNhY2hlOntoaW50OnQuZXF1YXRpb259LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9fSksZ2V0U2hhZGVyU291cmNlOlR9fSxCcz0oZSx0KT0+e2xldCByPW5ldyB1YShlLmlucHV0cyx0LmVxdWF0aW9uKTtlLmNvbXB1dGUoYWMoZS5pbnB1dHMscikpfSxNcz1lPT57bGV0IHQ9ZS5lcXVhdGlvbi5yZXBsYWNlKC9cXHMrL2csXCJcIik7cmV0dXJuIGllKHtlcXVhdGlvbjp0fSl9fSk7dmFyIG9jLHpzLGljLHNjLFdzLE5zPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7b2M9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuXCIpO2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxhPXIubGVuZ3RoPHQubGVuZ3RoPzA6ci5sZW5ndGgtdC5sZW5ndGgsbj10Lmxlbmd0aDxyLmxlbmd0aD8wOnQubGVuZ3RoLXIubGVuZ3RoO2Zvcig7YTxyLmxlbmd0aCYmbjx0Lmxlbmd0aDsrK2EsKytuKWlmKHJbYV0hPT10W25dJiZyW2FdIT09MSYmdFtuXSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIHNoYXBlIHRvIGJlIGJyb2FkY2FzdGFibGUgdG8gaW5wdXRcIil9LHpzPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgtdC5sZW5ndGgsYT1bXTtmb3IobGV0IG49MDtuPHI7KytuKWEucHVzaChlW25dKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbilhLnB1c2godFtuXT09PTE/ZVtuK3JdOnRbbl0pO3JldHVybiBhfSxpYz0oZSx0KT0+ZS5sZW5ndGg+dC5sZW5ndGg/enMoZSx0KTp6cyh0LGUpLHNjPWU9PntsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksYT1pYyh0LHIpLG49ei5zaXplKGEpLHM9ZVswXS5kYXRhVHlwZSx1PUYoXCJpbnB1dFwiLHMsdCksbD1YKFwib3V0cHV0XCIscyxhKSxvPXA9PmBcbiAgY29uc3QgaW5wdXRTaGFwZSA9ICR7dS5pbmRpY2VzKC4uLnQpfTtcbiAgJHtwLmRlY2xhcmVWYXJpYWJsZXModSxsKX1cbiAgJHtwLm1haW5TdGFydCgpfVxuICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhuKX1cbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7bC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3UudHlwZS5pbmRpY2VzfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgIGlmICgke3UuaW5kaWNlc0dldChcImlucHV0U2hhcGVcIixcImlcIil9ID09IDEpIHtcbiAgICAgICAgJHt1LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIiwwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7dS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsbC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGBpICsgJHthLmxlbmd0aC10Lmxlbmd0aH1gKSl9XG4gICAgICB9XG4gICAgfVxuICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKSl9XG4gIH1gO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7YX1gfSxnZXRTaGFkZXJTb3VyY2U6byxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfX0pfX0sV3M9ZT0+e29jKGUuaW5wdXRzKSxlLmNvbXB1dGUoc2MoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHVjLGxjLFZzLFVzLEdzPUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTt1Yz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpfSxsYz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxhPWVbMV0uZGltcyxuPXIubGVuZ3RoLHM9ei5ub3JtYWxpemVBeGlzKHQuYXhpcyxuKSx1PXIuc2xpY2UoMCk7dS5zcGxpY2UocywxLC4uLmEpO2xldCBsPXJbc10sbz16LnNpemUodSkscD1GKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxtPUYoXCJpbnB1dEluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcykseT1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx1KSxnPSgpPT57bGV0ICQ9YS5sZW5ndGgsYj1gdmFyIGluZGljZXNJbmRpY2VzICA9ICR7bS50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBTPTA7UzwkO1MrKyliKz1gJHskPjE/YGluZGljZXNJbmRpY2VzWyR7U31dYDpcImluZGljZXNJbmRpY2VzXCJ9ID0gJHt1Lmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzWyR7cytTfV1gOlwib3V0cHV0SW5kaWNlc1wifTtgO2IrPWBcbiAgICAgICAgdmFyIGlkeCA9ICR7bS5nZXRCeUluZGljZXMoXCJpbmRpY2VzSW5kaWNlc1wiKX07XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgaWR4ID0gaWR4ICsgJHtsfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUluZGljZXMgPSAke3AudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgIGA7Zm9yKGxldCBTPTAsST0wO1M8bjtTKyspUz09PXM/KGIrPWAke24+MT9gZGF0YUluZGljZXNbJHtTfV1gOlwiZGF0YUluZGljZXNcIn0gPSB1MzIoaWR4KTtgLEkrPSQpOihiKz1gJHtuPjE/YGRhdGFJbmRpY2VzWyR7U31dYDpcImRhdGFJbmRpY2VzXCJ9ID0gJHt1Lmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzWyR7SX1dYDpcIm91dHB1dEluZGljZXNcIn07YCxJKyspO3JldHVybiBifSx2PSQ9PmBcbiAgICAgICR7JC5kZWNsYXJlVmFyaWFibGVzKHAsbSx5KX1cbiAgICAgICR7JC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobyl9XG4gICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAke2coKX07XG4gICAgICAgIGxldCB2YWx1ZSA9ICR7cC5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAgICR7eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgIH1gO3JldHVybntuYW1lOlwiR2F0aGVyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6dn19LFZzPWU9PmllKHtheGlzOmUuYXhpc30pLFVzPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7dWMociksZS5jb21wdXRlKGxjKGUuaW5wdXRzLHQpKX19KTt2YXIgZGMsY2MsRnMsTHMsSHM9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO2RjPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBiZSByYW5rID49IDEuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgaW5wdXQgdGVuc29ycyBiZSBvZiBzYW1lIHJhbmsuYCl9LGNjPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9ZVswXS5kYXRhVHlwZSxuPXIubGVuZ3RoLHM9ei5jb21wdXRlU3RyaWRlcyhyKSx1PXouc2l6ZShyKSxsPWVbMV0uZGltcyxvPWVbMV0uZGF0YVR5cGUscD16LnNpemUobCksbT16Lm5vcm1hbGl6ZUF4aXModC5heGlzLG4pLHk9clttXSxnPWwuc2xpY2UoMCksdj16LnNpemUoZyksJD1GKFwiaW5wdXRcIixhLHIpLGI9RihcImluZGljZXNcIixvLFtwXSksUz1YKFwib3V0cHV0XCIsYSxnKSxJPVQ9PmBcbiAgICAgIGNvbnN0IGlucHV0U3RyaWRlcyA9IGFycmF5PHUzMiwgJHtzLmxlbmd0aH0+KCR7cy5tYXAoQj0+YCR7Qn11YCkuam9pbihcIixcIil9KTtcbiAgICAgICR7VC5kZWNsYXJlVmFyaWFibGVzKCQsYixTKX1cbiAgICAgICR7VC5tYWluU3RhcnQoKX1cbiAgICAgICR7VC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHYpfVxuXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgdmFyIGlkeCA9ICR7Yi5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgaWR4ID0gaWR4ICsgJHt5fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNyY09mZnNldCA9IHUzMigwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIGlmIChpID09ICR7bX0pIHtcbiAgICAgICAgICBzcmNPZmZzZXQgKz0gIHUzMihpZHgpICogaW5wdXRTdHJpZGVzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNyY09mZnNldCArPSAke1MuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixcImlcIil9ICogaW5wdXRTdHJpZGVzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBuZXZlciBoaXQgdGhpcyB3aXRoIHZhbGlkIHZhbHVlcyBpbiBpbmRpY2VzXG4gICAgICAvLyBUaGlzIGlzIGEgZ3VhcmQgYWdhaW5zdCBtYWxpY2lvdXMgZGF0YSBpbiB0aGUgaW5kaWNlcyBpbnB1dFxuICAgICAgaWYgKHNyY09mZnNldCA8IDAgfHwgc3JjT2Zmc2V0ID49ICR7dX0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtzcmNPZmZzZXRdO1xuICB9YDtyZXR1cm57bmFtZTpcIkdhdGhlckVsZW1lbnRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpnLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh2LzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6SX19LEZzPWU9PmllKHtheGlzOmUuYXhpc30pLExzPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7ZGMociksZS5jb21wdXRlKGNjKGUuaW5wdXRzLHQpKX19KTt2YXIgcGMsZmMsbWMsanMscXMsS3M9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO3BjPWU9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IG51bWJlci5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzJdLmRpbXMubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT1lWzFdLmRhdGFUeXBlfHxlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfSxmYz0oZSx0LHIpPT57aWYoci5sZW5ndGg9PT0wKXJldHVyblwiMHVcIjtsZXQgYT1yLmxlbmd0aD09PTEmJmUhPT0xfHxyLmxlbmd0aD09PTImJnJbMF0hPT1lLG49cltyLmxlbmd0aC0xXSE9PXQscz1cIjB1XCI7cmV0dXJuIGF8fChzKz1gKyBtICogJHtyW3IubGVuZ3RoLTFdfXVgKSxufHwocys9XCIrblwiKSxzfSxtYz0oZSx0KT0+e2xldCByPWVbMF0uZGltcy5zbGljZSgpLGE9ZVsxXS5kaW1zLnNsaWNlKCksW24scyx1XT1Kci5nZXRTaGFwZU9mR2VtbVJlc3VsdChyLHQudHJhbnNBLGEsdC50cmFuc0IsZS5sZW5ndGg9PT0zP2VbMl0uZGltczp2b2lkIDApLGw9W24sc107aWYoIWwpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IG89ei5zaXplKGwpLHA9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/cD1cInZhbHVlICs9IGFbayAqIE0gKyBtXSAqIGJbbiAqIEsgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP3A9XCJ2YWx1ZSArPSBhW2sgKiBNICsgbV0gKiBiW2sgKiBOICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj9wPVwidmFsdWUgKz0gYVttICogSyArIGtdICogYltuICogSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYocD1cInZhbHVlICs9IGFbbSAqIEsgKyBrXSAqIGJbayAqIE4gKyBuXTtcIik7bGV0IG09QmUoZVswXS5kYXRhVHlwZSkseT10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gYWxwaGE7XCIsZz1lLmxlbmd0aD09PTM/YHZhbHVlICs9IGJldGEgKiBjWyR7ZmMobixzLGVbMl0uZGltcyl9XTtgOlwiXCIsdj1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gYSA6IGFycmF5PCR7bX0+O2AsYEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gYiA6IGFycmF5PCR7bX0+O2BdO2UubGVuZ3RoPT09MyYmdi5wdXNoKGBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGMgOiBhcnJheTwke219PjtgKTtsZXQgJD1iPT5gXG4gIGNvbnN0IE06IHUzMiA9ICR7bn11O1xuICBjb25zdCBOOiB1MzIgPSAke3N9dTtcbiAgY29uc3QgSzogdTMyID0gJHt1fXU7XG4gIGNvbnN0IGFscGhhID0gJHttfSgke3QuYWxwaGF9KTtcbiAgY29uc3QgYmV0YSA9ICR7bX0oJHt0LmJldGF9KTtcblxuICAke3Yuam9pbihgXG5gKX1cbiAgQGdyb3VwKDApIEBiaW5kaW5nKCR7ZS5sZW5ndGh9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHttfT47XG5cbiAgJHtiLm1haW5TdGFydCgpfVxuICAgICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG8pfVxuXG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueCAvIE47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWQueCAlIE47XG5cbiAgICB2YXIgdmFsdWUgPSAke219KDApO1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPCR7dX11OyBrKyspIHtcbiAgICAgICR7cH1cbiAgICB9XG5cbiAgICAke3l9XG4gICAgJHtnfVxuICAgIG91dHB1dFtnbG9iYWxfaWQueF0gPSB2YWx1ZTtcblxuICB9YDtyZXR1cm57bmFtZTpcIkdlbW1cIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfX0pLGdldFNoYWRlclNvdXJjZTokfX0sanM9KGUsdCk9PntwYyhlLmlucHV0cyksZS5jb21wdXRlKG1jKGUuaW5wdXRzLHQpKX0scXM9ZT0+aWUoZSl9KTt2YXIgaGMsZ2MseWMsYmMsWXMsWHMsSnM9TCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtrZSgpO3ZlKCk7aGM9e25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIn0sZ2M9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsYT1yLG49MixzPXouc2l6ZVRvRGltZW5zaW9uKHIsbiksdT16LnNpemVGcm9tRGltZW5zaW9uKHIsbiksbD1yWzFdLG89RihcInhcIixlWzBdLmRhdGFUeXBlLFtyWzBdLHJbMV0sdV0pLHA9RihcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLG09RihcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcykseT1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxbclswXSxyWzFdLHVdKSxnPVtvLHAsbSx5XSx2PW8udHlwZS52YWx1ZSwkPTY0LGI9Uz0+YFxuXG4gIGNvbnN0IEM6IHUzMiA9ICR7bH07XG4gIGNvbnN0IG5vcm1TaXplOiB1MzIgPSAke3V9O1xuICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke3QuZXBzaWxvbn07XG4gIHZhcjx3b3JrZ3JvdXA+IG1lYW5TaGFyZWQgOiAke3Z9O1xuICB2YXI8d29ya2dyb3VwPiBzcXVhcmVkTm9ybVNoYXJlZCA6ICR7dn07XG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cFNoYXJlZCA6IGFycmF5PCR7dn0sICR7JH0+O1xuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gJHskfXU7XG4gICR7Uy5kZWNsYXJlVmFyaWFibGVzKC4uLmcpfVxuICAke1MubWFpblN0YXJ0KCQpfVxuICAgIGxldCBub3JtID0gZ2xvYmFsX2lkeCAvIHdvcmtncm91cFNpemU7XG4gICAgbGV0IGJhdGNoID0gbm9ybSAvIEM7XG4gICAgbGV0IGNoYW5uZWwgPSBub3JtICUgQztcbiAgICBsZXQgbG9jYWxJbmRleCA9IGxvY2FsX2lkLng7XG5cbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgaW5pdGlhbDogJHt2fSA9IDA7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCBub3JtU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArICR7by5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX07XG4gICAgfVxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtZWFuIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbEluZGV4ID09IDApIHtcbiAgICAgIG1lYW5TaGFyZWQgPSB3b3JrZ3JvdXBTaGFyZWRbMF0gLyAke3Z9KG5vcm1TaXplKTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gcmVpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnkuXG4gICAgaW5pdGlhbCA9IDA7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCBub3JtU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBsZXQgZGV2aWF0aW9uID0gICR7by5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0gLSBtZWFuU2hhcmVkO1xuICAgICAgaW5pdGlhbCA9IGluaXRpYWwgKyBkZXZpYXRpb24gKiBkZXZpYXRpb247XG4gICAgfVxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2Ygc3F1YXJlIG9mIGRldmlhdGlvbiBvZiBjdXJyZW50IGNoYW5uZWwgZGF0YS5cbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cFNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxJbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSArIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4ICsgY3VyclNpemVdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBpZiAobG9jYWxJbmRleCA9PSAwKSB7XG4gICAgICBzcXVhcmVkTm9ybVNoYXJlZCA9IHdvcmtncm91cFNoYXJlZFswXTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgbGV0IGludlN0ZERldiA9IDEgLyBzcXJ0KHNxdWFyZWROb3JtU2hhcmVkIC8gJHt2fShub3JtU2l6ZSkgKyBlcHNpbG9uKTtcbiAgICBsZXQgY2hhbm5lbFNjYWxlID0gaW52U3RkRGV2ICogJHtwLmdldEJ5T2Zmc2V0KFwiY2hhbm5lbFwiKX07XG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9ICR7bS5nZXRCeU9mZnNldChcImNoYW5uZWxcIil9IC0gbWVhblNoYXJlZCAqIGNoYW5uZWxTY2FsZTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IG5vcm1TaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7by5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0gKiBjaGFubmVsU2NhbGUgKyBjaGFubmVsU2hpZnQ7XG4gICAgICAke3kuc2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIixcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1gO3JldHVybnsuLi5oYyxzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6c319KSxnZXRTaGFkZXJTb3VyY2U6Yn19LHljPShlLHQscixhLG4scyx1LGwpPT57bGV0IG89bXQodSkscD1GKFwiaW5wdXRcIix0LmRhdGFUeXBlLHQuZGltcyxvKSxtPUYoXCJzY2FsZVwiLHIuZGF0YVR5cGUsci5kaW1zLG8pLHk9RihcImJpYXNcIixhLmRhdGFUeXBlLGEuZGltcyxvKSxnPTY0LHY9bz09PTE/XCJ2ZWMyZlwiOmBtYXQyeCR7b31mYCwkPW89PT0xP1wiZjMyXCI6YHZlYyR7b31mYCxiPShELFIpPT5gJHt2fSgke0R9LCAke1J9KWAsUz1uKnUvbyxJPU1hdGguY2VpbChzL2cpLFQ9RD0+YFxuICBjb25zdCBIOiB1MzIgPSAke3N9O1xuICBjb25zdCBDOiB1MzIgPSAke3Uvb307XG4gIGNvbnN0IGltYWdlU2l6ZTogdTMyID0gJHtzKnUvb307XG5cbiAgJHtELmRlY2xhcmVWYXJpYWJsZXMocCl9XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHt2fT47XG5cbiAgJHtELm1haW5TdGFydChnKX1cbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvICR7Z30gLyBDO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IChnbG9iYWxfaWR4IC8gJHtnfSkgJSBDO1xuICAgIGxldCB3Z0lkID0gZ2xvYmFsX2lkeCAlICR7Z307XG4gICAgbGV0IHdnT2Zmc2V0ID0gd2dJZCAqICR7SX07XG4gICAgaWYgKHdnT2Zmc2V0ID49IEgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgd2dNYXggPSBtaW4od2dPZmZzZXQgKyAke0l9LCBIKTtcblxuICAgIGxldCBvZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiBpbWFnZVNpemUgKyBjdXJyZW50Q2hhbm5lbE51bWJlcjtcbiAgICB2YXIgc3VtID0gJHtRZShcImYzMlwiLG8pfTtcbiAgICB2YXIgc3F1YXJlZFN1bSA9ICR7UWUoXCJmMzJcIixvKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gd2dPZmZzZXQ7IGkgPCB3Z01heDsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICR7JH0oaW5wdXRbb2Zmc2V0ICsgaSAqIENdKTtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YihcInN1bVwiLFwic3F1YXJlZFN1bVwiKX07XG4gIH1gLEI9ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtQ29tcHV0ZU1lYW5cIixzaGFkZXJDYWNoZTp7aGludDpKU09OLnN0cmluZ2lmeSh7Y29tcG9uZW50czpvLG4saDpzLGM6dX0pfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOltuLHUsZywyXSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpuKnUvb319KSxnZXRTaGFkZXJTb3VyY2U6VH0se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF0sUD1EPT5gXG4gIGNvbnN0IEg6IHUzMiA9ICR7c307XG4gIGNvbnN0IEM6IHUzMiA9ICR7dS9vfTtcbiAgY29uc3QgaW1hZ2VTaXplOiB1MzIgPSAke2cqdS9vfTtcbiAgY29uc3QgZXBzaWxvbjogZjMyID0gJHtsfTtcblxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHt2fT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGUgOiBhcnJheTwke20udHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhcyA6IGFycmF5PCR7eS50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3Z9PjtcblxuICAke0QubWFpblN0YXJ0KCl9XG4gICAgJHtELmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoUyl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyBDO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSBDO1xuXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIGltYWdlU2l6ZTtcbiAgICB2YXIgc3VtID0gJHtRZShcImYzMlwiLG8pfTtcbiAgICB2YXIgc3F1YXJlZFN1bSA9ICR7UWUoXCJmMzJcIixvKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7Z307IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dFtvZmZzZXQgKyBpICsgY3VycmVudENoYW5uZWxOdW1iZXIgKiAke2d9XTtcbiAgICAgICAgc3VtICs9IHZhbHVlWzBdO1xuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlWzFdO1xuICAgIH1cbiAgICBzdW0gPSBzdW0gLyBmMzIoSCk7XG4gICAgc3F1YXJlZFN1bSA9IHNxdWFyZWRTdW0gLyBmMzIoSCk7XG4gICAgbGV0IGludlN0ZERldiA9IDEgLyBzcXJ0KHNxdWFyZWRTdW0gLSBzdW0gKiBzdW0gKyBlcHNpbG9uKTtcbiAgICBsZXQgY2hhbm5lbFNjYWxlID0gaW52U3RkRGV2ICogJHskfShzY2FsZVtjdXJyZW50Q2hhbm5lbE51bWJlcl0pO1xuICAgIGxldCBjaGFubmVsU2hpZnQgPSAkeyR9KGJpYXNbY3VycmVudENoYW5uZWxOdW1iZXJdKSAtIHN1bSAqIGNoYW5uZWxTY2FsZTtcblxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YihcImNoYW5uZWxTY2FsZVwiLFwiY2hhbm5lbFNoaWZ0XCIpfTtcbiAgfWA7cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OkpTT04uc3RyaW5naWZ5KHtjb21wb25lbnRzOm8sbixoOnMsYzp1LGVwc2lsb246bH0pfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOltuLHUsMl0sZGF0YVR5cGU6MX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKFMvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpQfSx7aW5wdXRzOltCLHIsYV0sb3V0cHV0czpbLTFdfSlbMF19LGJjPShlLHQscik9PntsZXQgYT10WzBdLmRpbXMsbj1hLHM9YVswXSx1PWFbYS5sZW5ndGgtMV0sbD16LnNpemVGcm9tRGltZW5zaW9uKGEsMSkvdSxvPW10KHUpLHA9ei5zaXplKG4pL28sbT1GKFwiaW5wdXRcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyxvKSx5PVgoXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLG4sbyksZz1CZSh0WzBdLmRhdGFUeXBlKSx2PW89PT0xP1widmVjMmZcIjpgbWF0Mngke299ZmAsJD1vPT09MT9nOmB2ZWMke299PCR7Z30+YCxiPXljKGUsdFswXSx0WzFdLHRbMl0scyxsLHUsci5lcHNpbG9uKSxTPUk9PmBcbiAgY29uc3QgSDogdTMyID0gJHtsfTtcbiAgY29uc3QgQzogdTMyID0gJHt1L299O1xuXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke20udHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVJbnB1dCA6IGFycmF5PCR7dn0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7eS50eXBlLnN0b3JhZ2V9PjtcblxuICAke0kubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAoQyAqIEgpO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSBDO1xuXG4gICAgbGV0IHNjYWxlT2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogQyArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlSW5wdXRbc2NhbGVPZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHskfShzY2FsZVswXSksICR7JH0oc2NhbGVbMV0pKTtcbiAgfWA7ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ci5jYWNoZUtleX1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpTfSx7aW5wdXRzOlt0WzBdLGJdfSl9LFlzPWU9PmllKHtlcHNpbG9uOmUuZXBzaWxvbixmb3JtYXQ6ZS5mb3JtYXR9KSxYcz0oZSx0KT0+e3QuZm9ybWF0PT09XCJOSFdDXCI/YmMoZSxlLmlucHV0cyx0KTplLmNvbXB1dGUoZ2MoZS5pbnB1dHMsdCkpfX0pO3ZhciB3Yyx2YyxRcyxacyxldT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO2tlKCk7dmUoKTt3Yz1lPT57aWYoIWV8fGUubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLlwiKX0sdmM9KGUsdCxyKT0+e2xldCBhPWVbMF0uZGltcyxuPWVbMV0scz1lWzJdLHU9YSxsPXoubm9ybWFsaXplQXhpcyh0LmF4aXMsYS5sZW5ndGgpLG89ei5zaXplVG9EaW1lbnNpb24oYSxsKSxwPXouc2l6ZUZyb21EaW1lbnNpb24oYSxsKSxtPXouc2l6ZShuLmRpbXMpLHk9cz96LnNpemUocy5kaW1zKTowO2lmKG0hPT1wfHxzJiZ5IT09cCl0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke3B9LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHttfSBhbmQgYmlhcyBzaXplIG9mICR7eX1gKTtsZXQgZz1bXTtmb3IobGV0IFA9MDtQPGEubGVuZ3RoOysrUClQPGw/Zy5wdXNoKGFbUF0pOmcucHVzaCgxKTtsZXQgdj1tdChwKSwkPUJlKGVbMF0uZGF0YVR5cGUpLGI9W0YoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsdiksRihcInNjYWxlXCIsbi5kYXRhVHlwZSxuLmRpbXMsdildO3MmJmIucHVzaChGKFwiYmlhc1wiLHMuZGF0YVR5cGUscy5kaW1zLHYpKSxiLnB1c2goWChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdSx2KSk7bGV0IFM9cj4xLEk9cj4yO1MmJmIucHVzaChYKFwibWVhbkRhdGFPdXRwdXRcIiwxLGcpKSxJJiZiLnB1c2goWChcImludlN0ZE91dHB1dFwiLDEsZykpO2xldCBUPVA9PmBcbiAgY29uc3Qgbm9ybVNpemU6IGYzMiA9ICR7cH07XG4gIGNvbnN0IG5vcm1TaXplVmVjdG9yaXplZDogdTMyID0gJHtwL3Z9O1xuICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke3QuZXBzaWxvbn07XG5cbiAgJHtQLmRlY2xhcmVWYXJpYWJsZXMoLi4uYil9XG4gICR7UC5tYWluU3RhcnQoKX1cbiAgICAke1AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvKX1cbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIG5vcm1TaXplVmVjdG9yaXplZDtcbiAgICB2YXIgbWVhblZlY3RvciA9ICR7UWUoXCJmMzJcIix2KX07XG4gICAgdmFyIG1lYW5TcXVhcmVWZWN0b3IgPSAke1FlKFwiZjMyXCIsdil9O1xuXG4gICAgZm9yICh2YXIgaDogdTMyID0gMHU7IGggPCBub3JtU2l6ZVZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtEdCgkLHYsXCJ4W2ggKyBvZmZzZXRdXCIpfTtcbiAgICAgIG1lYW5WZWN0b3IgKz0gdmFsdWU7XG4gICAgICBtZWFuU3F1YXJlVmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtTdChcIm1lYW5WZWN0b3JcIix2KX0gLyBub3JtU2l6ZTtcbiAgICBsZXQgbWVhblNxdWFyZSA9IHNxcnQoJHtTdChcIm1lYW5TcXVhcmVWZWN0b3JcIix2KX0gXG4gICAgICAvIG5vcm1TaXplIC0gbWVhbiAqIG1lYW4gKyBlcHNpbG9uKTtcblxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCBub3JtU2l6ZVZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtEdCgkLHYsXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7RHQoJCx2LFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtiWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAtIG1lYW4pIC8gbWVhblNxdWFyZSAqIGYzMnNjYWxlXG4gICAgICAgICR7cz9gKyAke0R0KCQsdixcImJpYXNbal1cIil9YDpcIlwifVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAke1M/XCJtZWFuRGF0YU91dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW5cIjpcIlwifTtcbiAgICAke0k/XCJpbnZTdGRPdXRwdXRbZ2xvYmFsX2lkeF0gPSAxIC8gbWVhblNxdWFyZVwiOlwiXCJ9O1xuICB9YCxCPVt7ZGltczp1LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gUyYmQi5wdXNoKHtkaW1zOmcsZGF0YVR5cGU6MX0pLEkmJkIucHVzaCh7ZGltczpnLGRhdGFUeXBlOjF9KSx7bmFtZTpcIkxheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7cn18JHtlLmxlbmd0aH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6QixkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6VH19LFFzPWU9PmllKHtheGlzOmUuYXhpcyxlcHNpbG9uOmUuZXBzaWxvbn0pLFpzPShlLHQpPT57d2MoZS5pbnB1dHMpLGUuY29tcHV0ZSh2YyhlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgJGMsdHUscnU9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7YnIoKTskYz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltc1tlWzBdLmRpbXMubGVuZ3RoLTFdIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMl0pdGhyb3cgbmV3IEVycm9yKFwic2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC5cIil9LHR1PWU9PnskYyhlLmlucHV0cyk7bGV0IHQ9bnQuY2FsY1NoYXBlKGUuaW5wdXRzWzBdLmRpbXMsZS5pbnB1dHNbMV0uZGltcywhMCk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtlLmNvbXB1dGUoY24oZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIixhY3RpdmF0aW9uQ2FjaGVLZXk6XCJcIn0sdCkpfX0pO3ZhciB4YyxTYyxDYyxJYyxBYyxFYyxfYyxPYyxUYyxudSxhdSxvdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO2tlKCk7dmUoKTt4Yz1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZSBtdXN0IGJlIGZsb2F0LlwiKTtpZihlLmxlbmd0aD49Mil7bGV0IHQ9ZVswXS5kaW1zLmxlbmd0aCoyPT09ZVsxXS5kaW1zWzBdO2lmKGUubGVuZ3RoPT09NCYmKHQ9ZVszXS5kaW1zWzBdKjI9PT1lWzFdLmRpbXNbMF0pLCF0KXRocm93IG5ldyBFcnJvcihcIlRoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLlwiKX19LFNjPShlLHQscixhLG4scyx1KT0+e2xldCBsPXIubGVuZ3RoLG89XCJcIjtmb3IobGV0IHA9bC0xO3A+PTA7LS1wKW8rPWBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIscCl9KSAtICR7bltwXX07XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA+PSAke3JbcF19KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke2FbcF19O1xuICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICB2YWx1ZSA9ICR7c30oJHt1fSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtvfVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYH0sQ2M9KGUsdCxyLGEsbik9PntsZXQgcz1yLmxlbmd0aCx1PVwiXCI7Zm9yKGxldCBsPXMtMTtsPj0wOy0tbCl1Kz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixsKX0pIC0gJHtuW2xdfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAtaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbGV0IF8ybl8xID0gJHsyKihyW2xdLTEpfTtcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XG4gICAgICAgICAgICAgICAgICBpZihrID49ICR7cltsXX0pIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IF8ybl8xIC0gaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke2FbbF19O1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7dX1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sSWM9KGUsdCxyLGEsbik9PntsZXQgcz1yLmxlbmd0aCx1PVwiXCI7Zm9yKGxldCBsPXMtMTtsPj0wOy0tbCl1Kz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixsKX0pIC0gJHtuW2xdfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSAke3JbbF19KSB7XG4gICAgICAgICAgICAgICAgICBrID0gJHtyW2xdLTF9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7YVtsXX07XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHt1fVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxBYz0oZSx0LHIsYSxuKT0+e2xldCBzPXIubGVuZ3RoLHU9XCJcIjtmb3IobGV0IGw9cy0xO2w+PTA7LS1sKXUrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGwpfSkgLSAke25bbF19O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gJHtyW2xdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gJHtyW2xdfSkge1xuICAgICAgICAgICAgICAgICAgayAtPSAke3JbbF19O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqICR7YVtsXX07XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHt1fVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxFYz0oZSx0LHIsYSxuLHMpPT57c3dpdGNoKG4ubW9kZSl7Y2FzZSAwOnJldHVybiBTYyhlLHQscixhLG4ucGFkcyxzLG4udmFsdWUpO2Nhc2UgMTpyZXR1cm4gQ2MoZSx0LHIsYSxuLnBhZHMpO2Nhc2UgMjpyZXR1cm4gSWMoZSx0LHIsYSxuLnBhZHMpO2Nhc2UgMzpyZXR1cm4gQWMoZSx0LHIsYSxuLnBhZHMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sX2M9KGUsdCxyLGEpPT57bGV0IG49dFswXS5kaW1zLHM9ei5wYWRTaGFwZShuLnNsaWNlKCksci5wYWRzKSx1PXouc2l6ZShzKSxsPXouY29tcHV0ZVN0cmlkZXMobiksbz1YKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxzKSxwPUYoXCJ4XCIsdFswXS5kYXRhVHlwZSxuKSxtPUVjKG8scyxuLGwscixhKTtyZXR1cm5gXG4gICAgICAgICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKHAsbyl9XG4gICAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke28ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHthfSgwKTtcbiAgICAgICAgICAgICAgJHttfVxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICB9YH0sT2M9KGUsdCk9PntsZXQgcj16LnBhZFNoYXBlKGVbMF0uZGltcy5zbGljZSgpLHQucGFkcyk7cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHouc2l6ZShyKS82NCl9fSksZ2V0U2hhZGVyU291cmNlOmE9Pl9jKGEsZSx0LFwiZjMyXCIpfX0sVGM9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxhPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTowLG49ZVswXS5kaW1zLmxlbmd0aCxzPW5ldyBJbnQzMkFycmF5KDIqbikuZmlsbCgwKTtpZihlLmxlbmd0aD49NCl7bGV0IGw9ZVszXS5nZXRCaWdJbnQ2NEFycmF5KCk7Zm9yKGxldCBvPTA7bzxsLmxlbmd0aDtvKyspc1tOdW1iZXIobFtvXSldPU51bWJlcihyW29dKSxzW051bWJlcihsW29dKStuXT1OdW1iZXIocltvK2wubGVuZ3RoXSl9ZWxzZSByLmZvckVhY2goKGwsbyk9PnNbTnVtYmVyKG8pXT1OdW1iZXIobCkpO2xldCB1PVtdO3JldHVybiBzLmZvckVhY2gobD0+dS5wdXNoKGwpKSxpZSh7bW9kZTp0Lm1vZGUsdmFsdWU6YSxwYWRzOnV9KX1lbHNlIHJldHVybiB0fSxudT0oZSx0KT0+e3hjKGUuaW5wdXRzKTtsZXQgcj1UYyhlLmlucHV0cyx0KTtlLmNvbXB1dGUoT2MoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sYXU9ZT0+e2xldCB0PWUubW9kZSxyPWUudmFsdWUsYT1lLnBhZHM7cmV0dXJuIGllKHttb2RlOnQsdmFsdWU6cixwYWRzOmF9KX19KTt2YXIgZm4saXUsc3UsdXUsbHUsZHUsY3UscHUsZnUsbXUsaHUsZ3UseXUsYnUsd3UsdnU9TCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7a2UoKTt2ZSgpO2ZuPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyBzdXBwb3J0cyAxLUQgb3IgMi1EIGlucHV0cyBvbmx5IGZvciBub3cuXCIpfSxpdT0oZSx0LHIpPT57bGV0IGE9dC5mb3JtYXQ9PT1cIk5IV0NcIixuPWUuZGltcy5zbGljZSgpO2EmJm4uc3BsaWNlKDEsMCxuLnBvcCgpKTtsZXQgcz1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGlsYXRpb25zXCIpLHU9dC5rZXJuZWxTaGFwZS5zbGljZSgpLGw9dC5zdHJpZGVzLnNsaWNlKCksbz1zP3QuZGlsYXRpb25zLnNsaWNlKCk6W10scD10LnBhZHMuc2xpY2UoKTtNdC5hZGp1c3RQb29sQXR0cmlidXRlcyhyLG4sdSxsLG8scCk7bGV0IG09TXQuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShyLG4sbCxvLHUscCx0LmF1dG9QYWQpLHk9T2JqZWN0LmFzc2lnbih7fSx0KTtzP09iamVjdC5hc3NpZ24oeSx7a2VybmVsU2hhcGU6dSxzdHJpZGVzOmwscGFkczpwLGRpbGF0aW9uczpvLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKHkse2tlcm5lbFNoYXBlOnUsc3RyaWRlczpsLHBhZHM6cCxjYWNoZUtleTp0LmNhY2hlS2V5fSk7bGV0IGc9bS5zbGljZSgpO3JldHVybiBnLnB1c2goZy5zcGxpY2UoMSwxKVswXSksW3ksYT9nOm1dfSxzdT0oZSx0LHIsYSxuLHMsdSxsKT0+e2xldCBvPW4uZm9ybWF0PT09XCJOSFdDXCIscD1yLG09dC50eXBlLnZhbHVlLHk9cC5sZW5ndGgsZz16LnNpemUoYSksdj1YKFwib3V0cHV0XCIsdC50eXBlLnRlbnNvcixhKTtpZihuLmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0ICQ9bi5rZXJuZWxTaGFwZVtuLmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxiPW4uc3RyaWRlc1tuLnN0cmlkZXMubGVuZ3RoLTFdLFM9bi5wYWRzW24ucGFkcy5sZW5ndGgvMi0xXSxJPW4ucGFkc1tuLnBhZHMubGVuZ3RoLTFdLFQ9eS0obz8yOjEpLEI9XCJcIixQPVwiXCIsRD1cIlwiO2lmKFMrSSE9PTA/Qj1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAkeyR9dTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske1R9XSA9IGluZGljZXNbJHtUfV0gKiAke2J9IC0gJHtTfSArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtUfV0gPCAwIHx8IHhJbmRpY2VzWyR7VH1dID49ICR7cFtUXX0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7c31cbiAgICAgICAgICAgICAgICB9YDpCPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7JH11OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7VH1dID0gaW5kaWNlc1ske1R9XSAqICR7Yn0gLSAke1N9ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke3N9XG4gICAgICAgICAgICAgICAgfWAsbi5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgVz1uLmtlcm5lbFNoYXBlW24ua2VybmVsU2hhcGUubGVuZ3RoLTJdLEg9bi5zdHJpZGVzW24uc3RyaWRlcy5sZW5ndGgtMl0sSz1uLnBhZHNbbi5wYWRzLmxlbmd0aC8yLTJdLGxlPW4ucGFkc1tuLnBhZHMubGVuZ3RoLTJdLE09eS0obz8zOjIpLHE9cFtNXTtLK2xlIT09MD9QPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8ICR7V311OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7TX1dID0gaW5kaWNlc1ske019XSAqICR7SH0gLSAke0t9ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske019XSA8IDAgfHwgeEluZGljZXNbJHtNfV0gPj0gJHtxfSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrPSAkeyR9O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYDpQPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8ICR7V311OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7TX1dID0gaW5kaWNlc1ske019XSAqICR7SH0gLSAke0t9ICsgajtcbiAgICAgICAgICAgICAgICBgLEQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKHQsdil9XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZyl9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7di5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWU6ICR7bX0gPSAke219KCR7bH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtQfVxuICAgICAgICAgICAgICAke0J9XG4gICAgICAgICAgICAgICR7RH1cbiAgICAgICAgICAgICAgJHt1fVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9ZWxzZXtpZihvKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgJD16LnNpemUobi5rZXJuZWxTaGFwZSksYj16LmNvbXB1dGVTdHJpZGVzKG4ua2VybmVsU2hhcGUpLFM9Yi5sZW5ndGgsST1uLnBhZHMubGVuZ3RoLFQ9bi5wYWRzLnJlZHVjZSgoRCxSKT0+RCtSKSxCPVwiXCI7cmV0dXJuIFQ/Qj1gXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IGlucHV0RGltc1tqXSkge1xuICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgJHtzfVxuICAgICAgICAgICAgICB9YDpCPWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAke3N9XG4gICAgICAgICAgICBgLGBcbiAgICAgICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKHQsdil9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhZHMgPSBhcnJheTx1MzIsICR7SX0+KCR7bi5wYWRzLm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICAgICAgY29uc3QgaW5wdXREaW1zID0gYXJyYXk8dTMyLCAke3l9Pigke3AubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgICAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gYXJyYXk8dTMyLCAke1N9Pigke2IubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgICAgICBjb25zdCBzdHJpZGVzID0gYXJyYXk8dTMyLCAke1N9Pigke24uc3RyaWRlcy5tYXAoRD0+YCR7RH11YCkuam9pbihcIixcIil9KTtcblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhnKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7di5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgbGV0IHhJbmRpY2VzID0gJHt2Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7U30+O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7di50eXBlLnZhbHVlfSgke2x9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHskfXU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7Uy0xfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvIGtlcm5lbFN0cmlkZXNbal07XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqIGtlcm5lbFN0cmlkZXNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtTLTF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7eS1TfXU7IGogPCAke3l9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke3ktU311XVxuICAgICAgICAgICAgICAgICAgICArIG9mZnNldHNbaiAtICR7eS1TfXVdIC0gcGFkc1tqIC0gMnVdO1xuICAgICAgICAgICAgICAgICAgJHtCfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7dX1cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gfX0sdXU9ZT0+KHtmb3JtYXQ6ZS5mb3JtYXQsYXV0b1BhZDpbXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLGNlaWxNb2RlOmUuY2VpbF9tb2RlLGtlcm5lbFNoYXBlOmUua2VybmVsX3NoYXBlLHN0cmlkZXM6ZS5zdHJpZGVzLHBhZHM6ZS5wYWRzfSksbHU9KGUsdCxyLGEpPT57bGV0W24sc109aXUodCxhLHIpLHU9ei5zaXplKG4ua2VybmVsU2hhcGUpLGw9RihcInhcIix0LmRhdGFUeXBlLHQuZGltcyksbz1sLnR5cGUudmFsdWUscD1cInZhbHVlICs9IHhfdmFsO1wiLG09XCJcIjtyZXR1cm4gbi5jb3VudEluY2x1ZGVQYWQ/bSs9YHZhbHVlIC89ICR7b30oJHt1fSk7YDptKz1gdmFsdWUgLz0gJHtvfSgke3V9IC0gcGFkKTtgLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YS5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh6LnNpemUocykvNjQpfX0pLGdldFNoYWRlclNvdXJjZTp5PT5zdSh5LGwsdC5kaW1zLHMsbixwLG0sXCIwLjBcIil9fSxkdT1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAscj11dShlKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO3JldHVybiBpZSh7Y291bnRJbmNsdWRlUGFkOnQsLi4ucn0pfSxjdT0oZSx0KT0+e2ZuKGUuaW5wdXRzKSxlLmNvbXB1dGUobHUoXCJBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0scHU9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdLGNhY2hlS2V5OlwiXCJ9LGZ1PWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4ucHUsY2FjaGVLZXk6dH19LG11PShlLHQpPT57Zm4oZS5pbnB1dHMpLGUuY29tcHV0ZShsdShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfSxodT0oZSx0LHIsYSk9PntsZXRbbixzXT1pdSh0LGEsciksdT1gXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xuICAgIGAsbD1cIlwiLG89RihcInhcIix0LmRhdGFUeXBlLHQuZGltcyk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDphLmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHouc2l6ZShzKS82NCl9fSksZ2V0U2hhZGVyU291cmNlOnA9PnN1KHAsbyx0LmRpbXMscyxuLHUsbCxcIi0xZTVcIil9fSxndT0oZSx0KT0+e2ZuKGUuaW5wdXRzKSxlLmNvbXB1dGUoaHUoXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSx5dT1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLHI9ZS5kaWxhdGlvbnMsYT11dShlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihhLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7cmV0dXJuIGllKHtzdG9yYWdlT3JkZXI6dCxkaWxhdGlvbnM6ciwuLi5hfSl9LGJ1PWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4ucHUsY2FjaGVLZXk6dH19LHd1PShlLHQpPT57Zm4oZS5pbnB1dHMpLGUuY29tcHV0ZShodShcIkdsb2JhbE1heFBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9fSk7dmFyIFBjLGtjLCR1LHh1PUwoKCk9PntcInVzZSBzdHJpY3RcIjskdCgpO0RlKCk7dmUoKTtQYz0oZSx0LHIpPT57bGV0IGE9ZT09PXQsbj1lPHQmJnI8MCxzPWU+dCYmcj4wO2lmKGF8fG58fHMpdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LGtjPShlLHQscixhKT0+e2xldCBuPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9yKSkscz1bbl0sdT1uLGw9WChcIm91dHB1dFwiLGEscyksbz1sLnR5cGUuc3RvcmFnZSxwPW09PmBcbiAgICAgICAgJHttLmRlY2xhcmVWYXJpYWJsZXMobCl9XG4gICAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XG4gICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7b30oJHtlfSkgKyAke299KGdsb2JhbF9pZHgpICogJHtvfSgke3J9KTtcbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmFuZ2VcIixzaGFkZXJDYWNoZTp7aGludDpbZSx0LHJdLm1hcChtPT5tLnRvU3RyaW5nKCkpLmpvaW4oXCJfXCIpfSxnZXRTaGFkZXJTb3VyY2U6cCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfX0pfX0sJHU9ZT0+e2xldCB0PTAscj0wLGE9MDtlLmlucHV0c1swXS5kYXRhVHlwZT09PTY/KHQ9ZS5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdLGE9ZS5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdKTplLmlucHV0c1swXS5kYXRhVHlwZT09PTEmJih0PWUuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0sYT1lLmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSksSWUud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZQYyh0LHIsYSksZS5jb21wdXRlKGtjKHQscixhLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSx7aW5wdXRzOltdfSl9fSk7dmFyIEJjLE1jLERjLHpjLFdjLE5jLFZjLFVjLEdjLEZjLExjLEhjLGpjLHFjLEtjLFN1LEN1LEl1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTtCYz0oZSx0KT0+e2lmKGUuZXZlcnkocj0+cj4wfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZVwiKX0pKSxlLmxlbmd0aD4wKXtpZih0Lm1vZGU9PT1cImxpbmVhclwiKXtpZighKGUubGVuZ3RoPT09Mnx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBsaW5lYXIgbW9kZVwiKX1lbHNlIGlmKHQubW9kZT09PVwiY3ViaWNcIiYmIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZVwiKX19LE1jPShlLHQscik9Pnt0LmV2ZXJ5KG49Pm4+PTAmJm48cnx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFua1wiKX0pKTtsZXQgYT1uZXcgQXJyYXkocikuZmlsbCgxKTtyZXR1cm4gdC5mb3JFYWNoKChuLHMpPT5hW25dPWVbc10pLGF9LERjPShlLHQscixhLG4scyk9PntsZXRbdSxsLG9dPXI+MTA/WzEsMiwzXTpbLTEsZS5sZW5ndGg+MT8xOi0xLC0xXSxwPWVbMF0uZGltcy5sZW5ndGg7aWYodT4wJiZlLmxlbmd0aD51JiZlW3VdLmRpbXMubGVuZ3RoPjApZVt1XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKG09PnMucHVzaChtKSk7ZWxzZSBpZih0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIil0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZVwiKTtpZihsPjAmJmUubGVuZ3RoPmwmJmVbbF0uZGltcy5sZW5ndGg+MCl7aWYoZVtsXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKG09PmEucHVzaChtKSksYS5sZW5ndGghPT0wJiZhLmxlbmd0aCE9PXAmJnI+PTE4JiZhLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtCYyhhLHQpLHQuYXhlcy5sZW5ndGg+MCYmTWMoYSx0LmF4ZXMscCkuZm9yRWFjaCgobSx5KT0+YVt5XT1tKX1pZihvPjAmJmUubGVuZ3RoPm8mJihlW29dLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG09Pm4ucHVzaChOdW1iZXIobSkpKSxuLmxlbmd0aCE9PXB8fHI+PTE4JiZuLmxlbmd0aD09PXQuYXhlcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzaXplcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtpZih0LmF4ZXMubGVuZ3RoPjApe2lmKGEubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO2lmKG4ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKX1pZih0eXBlb2YgYTxcInVcIiYmdHlwZW9mIG48XCJ1XCImJmEubGVuZ3RoPjAmJm4ubGVuZ3RoPnApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0semM9ZT0+XCJmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IGYzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IGYzMiwgICAgbGVuZ3RoT3JpZ2luYWw6IGYzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+IGYzMiB7IFwiKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuXCJyZXR1cm4geFJlc2l6ZWQgLyB4U2NhbGU7XCI7Y2FzZVwicHl0b3JjaF9oYWxmX3BpeGVsXCI6cmV0dXJuXCJpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZSAtIDAuNTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5cInJldHVybiAoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlO1wiO2Nhc2VcImFsaWduX2Nvcm5lcnNcIjpyZXR1cm5cImlmIChsZW5ndGhSZXNpemVkID09IDEpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVyblwiaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvaVN0YXJ0ICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgKyAgICAgICAgICAgICAgICAgICAgICAgICAgICh4UmVzaXplZCAqIChyb2lFbmQgLSByb2lTdGFydCkgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAocm9pU3RhcnQgKyByb2lFbmQpICogZjMyKGxlbmd0aE9yaWdpbmFsIC0gMSk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJoYWxmX3BpeGVsX3N5bW1ldHJpY1wiOnJldHVybltcImNvbnN0IG91dHB1dFdpZHRoID0geFNjYWxlICogbGVuZ3RoUmVzaXplZDtcIixcImNvbnN0IGFkanVzdG1lbnQgPSBsZW5ndGhSZXNpemVkIC8gb3V0cHV0V2lkdGg7XCIsXCJjb25zdCBjZW50ZXIgPSBsZW5ndGhPcmlnaW5hbCAvIDI7XCIsXCJjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1wiLFwicmV0dXJuIG9mZnNldCArICgoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlKSAtIDAuNTtcIl0uam9pbihgXG5gKTtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuXCJyZXR1cm4gKCh4UmVzaXplZCArIDAuNSkgLyB4U2NhbGUpIC0gMC41O1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsV2M9KGUsdCk9PlwiZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogZjMyLCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+IGYzMiB7XCIrKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsTmM9KGUsdCxyKT0+e2xldCBhPW5ldyBBcnJheShyKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkocikuZmlsbCgxKSksbj1lLmxlbmd0aD09PTA/YTplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgocyx1KT0+e2Fbc109blt1XSxhW3Urcl09blt0Lmxlbmd0aCt1XX0pLGEpOm59LFZjPShlLHQscixhKT0+e2xldCBuPVtdO2lmKHIubGVuZ3RoPjApaWYoYS5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKHM9Pm4ucHVzaChzKSksTWF0aC5tYXgoLi4uYSk+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7YS5mb3JFYWNoKChzLHUpPT5uW3NdPXJbdV0pfWVsc2Ugci5mb3JFYWNoKHM9Pm4ucHVzaChzKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO249ZS5tYXAoKHMsdSk9Pk1hdGgucm91bmQocyp0W3VdKSl9cmV0dXJuIG59LFVjPShlLHQscixhKT0+e2xldCBuPSgoKT0+e3N3aXRjaChhLmtlZXBBc3BlY3RSYXRpb1BvbGljeSl7Y2FzZVwibm90X2xhcmdlclwiOnJldHVybiBhLmF4ZXMubGVuZ3RoPjA/TWF0aC5taW4oLi4uYS5heGVzLm1hcCh1PT5yW3VdKSxOdW1iZXIuTUFYX1ZBTFVFKTpNYXRoLm1pbiguLi5yLE51bWJlci5NQVhfVkFMVUUpO2Nhc2VcIm5vdF9zbWFsbGVyXCI6cmV0dXJuIGEuYXhlcy5sZW5ndGg+MD9NYXRoLm1heCguLi5hLmF4ZXMubWFwKHU9PnJbdV0pLE51bWJlci5NSU5fVkFMVUUpOk1hdGgubWF4KC4uLnIsTnVtYmVyLk1JTl9WQUxVRSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke2Eua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKTtyLmZpbGwoMSwwLHIubGVuZ3RoKTtsZXQgcz1lLnNsaWNlKCk7cmV0dXJuIGEuYXhlcy5sZW5ndGg+MD8oYS5heGVzLmZvckVhY2godT0+clt1XT1uKSxhLmF4ZXMuZm9yRWFjaCh1PT5zW3VdPU1hdGgucm91bmQoZVt1XSpyW3VdKSkpOihyLmZpbGwobiwwLHIubGVuZ3RoKSxzLmZvckVhY2goKHUsbCk9PnNbbF09TWF0aC5yb3VuZCh1KnJbbF0pKSksc30sR2M9KGUsdCxyLGEsbik9PmBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8ZjMyLCAke3IubGVuZ3RofT4ge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHt0Lmxlbmd0aH0+KCR7dC5tYXAocz0+YCR7c311YCkuam9pbihcIixcIil9KTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3IubGVuZ3RofT4oJHtyLm1hcChzPT5gJHtzfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgY29uc3Qgc2NhbGVzID0gYXJyYXk8ZjMyLCAke2EubGVuZ3RofT4oJHthLm1hcChzPT5gJHtzfWZgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgY29uc3Qgcm9pID0gYXJyYXk8ZjMyLCAke24ubGVuZ3RofT4oJHtuLm1hcChzPT5gJHtzfWZgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlczogYXJyYXk8ZjMyLCAke3IubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7ci5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOlwib3V0cHV0SW5kaWNlc1tpXVwifTtcbiAgICAgICAgaWYgKHNjYWxlc1tpXSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbEluZGljZXNbaV0gPSBmMzIob3V0cHV0SW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9yaWdpbmFsSW5kaWNlc1tpXSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShmMzIob3V0cHV0SW5kZXgpLCBzY2FsZXNbaV0sXG4gICAgICAgICAgICAgICAgZjMyKG91dHB1dFNoYXBlW2ldKSwgZjMyKGlucHV0U2hhcGVbaV0pLCByb2lbaV0sIHJvaVtpICsgJHt0Lmxlbmd0aH1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsSW5kaWNlcztcbiAgICB9YCxGYz0oZSx0LHIsYSxuLHMsdSk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3IubGVuZ3RofT4oJHtyLm1hcChsPT5gJHtsfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGFycmF5PHUzMiwgJHthLmxlbmd0aH0+KCR7YS5tYXAobD0+YCR7bH11YCkuam9pbihcIixcIil9KTtcbiAgICAgICAgY29uc3Qgc2NhbGVzID0gYXJyYXk8ZjMyLCAke24ubGVuZ3RofT4oJHtuLm1hcChsPT5gJHtsfWZgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCByb2kgPSBhcnJheTxmMzIsICR7cy5sZW5ndGh9Pigke3MubWFwKGw9PmAke2x9ZmApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke2EubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHthLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6XCJvdXRwdXRJbmRpY2VzW2ldXCJ9O1xuICAgICAgICAgIHZhciBpbnB1dEluZGV4OiB1MzI7XG4gICAgICAgICAgaWYgKHNjYWxlc1tpXSA9PSAxLjApIHtcbiAgICAgICAgICAgIGlucHV0SW5kZXggPSBvdXRwdXRJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsX2lkeCA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShmMzIob3V0cHV0SW5kZXgpLCBzY2FsZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGYzMihvdXRwdXRTaGFwZVtpXSksIGYzMihpbnB1dFNoYXBlW2ldKSwgcm9pW2ldLCByb2lbaSArICR7ci5sZW5ndGh9XSk7XG4gICAgICAgICAgICBpZiAoISR7dX0gfHwgKG9yaWdpbmFsX2lkeCA+PSAwICYmIG9yaWdpbmFsX2lkeCA8IGYzMihpbnB1dFNoYXBlW2ldKSkpIHtcbiAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAoZjMyKGlucHV0U2hhcGVbaV0pIC0gMSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gaW5wdXRTaGFwZVtpXSAtIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZXNbaV0gPCAxKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0SW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIixcImlucHV0SW5kZXhcIil9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0SW5kaWNlcztcbiAgICB9YCxMYz0oZSx0KT0+YFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHt0Lmxlbmd0aH0+KCR7dC5tYXAocj0+YCR7cn11YCkuam9pbihcIixcIil9KTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0SW5kZXggPSAke3QubGVuZ3RoPT09MT9cImlucHV0SW5kaWNlc1wiOlwiaW5wdXRJbmRpY2VzW2ldXCJ9O1xuICAgICAgICBpZiAoaW5wdXRJbmRleCA8IDAgfHwgaW5wdXRJbmRleCA+PSBpbnB1dFNoYXBlW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9YCxIYz0oZSx0LHIsYSxuLHMsdSk9PntsZXRbbCxvLHAsbV09ci5sZW5ndGg9PT0yP1stMSwwLDEsLTFdOm5bMV09PT0xP1swLDIsMywxXTpbMCwxLDIsM107cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+IGYzMiB7XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGlucHV0SW5kaWNlc1ske299XSA9IG1heCgwLCBtaW4ocm93LCAke3Jbb119IC0gMSkpO1xuICAgICAgaW5wdXRJbmRpY2VzWyR7cH1dID0gbWF4KDAsIG1pbihjb2wsICR7cltwXX0gLSAxKSk7XG4gICAgICBpZiAoJHtyLmxlbmd0aH0gPiAyKSB7XG4gICAgICAgIGlucHV0SW5kaWNlc1ske219XSA9IGNoYW5uZWw7XG4gICAgICAgIGlucHV0SW5kaWNlc1ske2x9XSA9IGJhdGNoO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBpbnB1dFske2UuaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzXCIpfV07XG4gICAgfVxuXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiBmMzIge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXMpO1xuICAgICAgdmFyIHJvdzpmMzIgPSBvcmlnaW5hbEluZGljZXNbJHtvfV07XG4gICAgICB2YXIgY29sOmYzMiA9IG9yaWdpbmFsSW5kaWNlc1ske3B9XTtcbiAgICAgIGlmICgke3N9ICYmIChyb3cgPCAwIHx8IHJvdyA+ICgke3Jbb119IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAke3JbcF19IC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICR7dX07XG4gICAgICB9XG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtyW29dfSAtIDEpKTtcbiAgICAgIGNvbCA9IG1heCgwLCBtaW4oY29sLCAke3JbcF19IC0gMSkpO1xuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gMDtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gMDtcbiAgICAgIGlmICgke3IubGVuZ3RoPjJ9KSB7XG4gICAgICAgIGNoYW5uZWwgPSB1MzIob3JpZ2luYWxJbmRpY2VzWyR7bX1dKTtcbiAgICAgICAgYmF0Y2ggPSB1MzIob3JpZ2luYWxJbmRpY2VzWyR7bH1dKTtcbiAgICAgIH1cbiAgICAgIHZhciB4MTE6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xuICAgICAgdmFyIHgxMjogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiBmMzIgPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcbiAgICAgIHZhciB4MjI6IGYzMiA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xuICAgICAgdmFyIGR4MTogZjMyID0gcm93IC0gZjMyKHJvdzEpO1xuICAgICAgdmFyIGR4MjogZjMyID0gZjMyKHJvdzIgKSAtIHJvdztcbiAgICAgIHZhciBkeTEgPSBjb2wgLSBmMzIoY29sMSk7XG4gICAgICB2YXIgZHkyID0gZjMyKGNvbDIpIC0gY29sO1xuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xuICAgIH1gfSxqYz0oZSx0LHIsYSxuLHMsdSxsLG8scCk9PntsZXRbbSx5XT1yLmxlbmd0aD09PTI/WzAsMV06blsxXT09PTE/WzIsM106WzEsMl0sZz12PT57bGV0ICQ9dj09PW0/XCJyb3dcIjpcImNvbFwiO3JldHVybmBcbiAgICAgIGZuICR7JH1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSwgb3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+IGYzMiB7XG4gICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7YS5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOmBvdXRwdXRJbmRpY2VzWyR7dn1dYH07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogZjMyID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGYzMihvdXRwdXRJbmRleCksICR7blt2XX0sXG4gICAgICAgIGYzMigke2Fbdl19KSwgZjMyKCR7clt2XX0pLCAke3Nbdl19LCAke3Nbdl19ICsgJHtyLmxlbmd0aH0pO1xuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogZjMyID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xuXG4gICAgICAgIGlmICgke2x9ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtyW3ZdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke299O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTxmMzIsIDQ+ID0gYXJyYXk8ZjMyLCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciAkeyR9OiBmMzIgPSBvcmlnaW5hbElkeCArIGYzMihpKTtcbiAgICAgICAgICBpZiAoJHskfSA8IDAgfHwgJHskfSA+PSAke3Jbdl19KSB7XG4gICAgICAgICAgICBpZiAoJHtwfSkge1xuICAgICAgICAgICAgICBjb2Vmc1tpICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgke2x9KSB7XG4gICAgICAgICAgICAgIHJldHVybiAke299O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHskfSA9IG1heCgwLCBtaW4oJHskfSwgJHtyW3ZdfSAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlc0NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRJbmRpY2VzO1xuICAgICAgICAgIGlucHV0SW5kaWNlc0NvcHlbJHt2fV0gPSB1MzIoJHskfSk7XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke3Y9PT1tP2BpbnB1dFske2UuaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzQ29weVwiKX1dO2A6YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRJbmRpY2VzQ29weSwgb3V0cHV0SW5kaWNlcyk7YH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xuICAgICAgfWB9O3JldHVybmBcbiAgICAke2cobSl9O1xuICAgICR7Zyh5KX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6IGYzMikgLT4gYXJyYXk8ZjMyLCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8ZjMyLCA0PiA9IGFycmF5PGYzMiwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICB2YXIgb25lTWludXNBYnNTOiBmMzIgPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6IGYzMiA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiBmMzIgPSAxLjAgKyBhYnNTO1xuICAgIGNvZWZmc1swXSA9ICgoJHt1fSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7dX0pICogb25lUGx1c0Fic1MgKyA4ICogJHt1fSkgKiBvbmVQbHVzQWJzUyAtIDQgKiAke3V9O1xuICAgIGNvZWZmc1sxXSA9ICgoJHt1fSArIDIpICogYWJzUyAtICgke3V9ICsgMykpICogYWJzUyAqIGFic1MgKyAxO1xuICAgIGNvZWZmc1syXSA9ICgoJHt1fSArIDIpICogb25lTWludXNBYnNTIC0gKCR7dX0gKyAzKSkgKiBvbmVNaW51c0Fic1MgKiBvbmVNaW51c0Fic1MgKyAxO1xuICAgIGNvZWZmc1szXSA9ICgoJHt1fSAqIHR3b01pbnVzQWJzUyAtIDUgKiAke3V9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke3V9KSAqIHR3b01pbnVzQWJzUyAtIDQgKiAke3V9O1xuICAgIHJldHVybiBjb2VmZnM7XG4gIH1cblxuICBmbiBjdWJpY0ludGVycG9sYXRpb24xRCh4OiBhcnJheTxmMzIsIDQ+LCBjb2VmczogYXJyYXk8ZjMyLCA0PikgLT4gZjMyIHtcbiAgICB2YXIgY29lZnNTdW06IGYzMiA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiBmMzIge1xuICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0SW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0SW5kaWNlcywgb3V0cHV0SW5kaWNlcyk7XG4gIH1cbiAgICBgfSxxYz0oZSx0LHIsYSxuLHMpPT57bGV0IHU9ZS5kaW1zLGw9TmMocyx0LmF4ZXMsdS5sZW5ndGgpLG89VmModSxhLG4sdC5heGVzKSxwPWEuc2xpY2UoKTthLmxlbmd0aD09PTAmJihwPXUubWFwKChTLEkpPT5TPT09MD8xOm9bSV0vUyksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKG89VWModSxvLHAsdCkpKTtsZXQgbT1YKFwib3V0cHV0XCIsZS5kYXRhVHlwZSxvKSx5PUYoXCJpbnB1dFwiLGUuZGF0YVR5cGUsdSksZz16LnNpemUobyksdj11Lmxlbmd0aD09PW8ubGVuZ3RoJiZ1LmV2ZXJ5KChTLEkpPT5TPT09b1tJXSksJD10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixiPVM9PmBcbiAgICAgICR7emModC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSl9O1xuICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke0xjKHksdSl9O1xuICAgICAgICAgICAgICAke1djKHQubmVhcmVzdE1vZGUscil9O1xuICAgICAgICAgICAgICAke0ZjKHksbSx1LG8scCxsLCQpfTtcbiAgICAgICAgICAgICAgYDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgICAgICR7R2MobSx1LG8scCxsKX07XG4gICAgICAgICAgICAgICR7SGMoeSxtLHUsbyxwLCQsdC5leHRyYXBvbGF0aW9uVmFsdWUpfTtcbiAgICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcbiAgICAgICAgICAgICR7amMoeSxtLHUsbyxwLGwsdC5jdWJpY0NvZWZmQSwkLHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfTtcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIkludmFsaWQgcmVzaXplIG1vZGVcIil9fSkoKX07XG4gICAgICAke1MuZGVjbGFyZVZhcmlhYmxlcyh5LG0pfVxuICAgICAgJHtTLm1haW5TdGFydCgpfVxuICAgICAgICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhnKX1cbiAgICAgICAgaWYgKCR7dn0pIHtcbiAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke3kudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gaW5wdXRJbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRJbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFske3kuaW5kaWNlc1RvT2Zmc2V0KFwiaW5wdXRJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3QuZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVyblwib3V0cHV0W2dsb2JhbF9pZHhdID0gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dEluZGljZXMpO1wiO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzKTtcIjtkZWZhdWx0OnRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHt0Lm1vZGV9YCl9fSkoKX07XG4gICAgICAgIH1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke3AubGVuZ3RoPjA/cDpcIlwifXwke24ubGVuZ3RoPjA/bjpcIlwifWB9LGdldFNoYWRlclNvdXJjZTpiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZy82NCl9fSl9fSxLYz1lPT57bGV0IHQ9ZS5jdXN0b21EYXRhQnVmZmVyO3JldHVybiBuZXcgVWludDMyQXJyYXkodCx0LmJ5dGVPZmZzZXQsMSlbMF19LFN1PShlLHQpPT57bGV0IHI9W10sYT1bXSxuPVtdLHM9S2MoZSk7RGMoZS5pbnB1dHMsdCxzLHIsYSxuKSxlLmNvbXB1dGUocWMoZS5pbnB1dHNbMF0sdCxzLHIsYSxuKSx7aW5wdXRzOlswXX0pfSxDdT1lPT57bGV0IHQ9ZS5hbnRpYWxpYXMscj1lLmF4ZXMsYT1lLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLG49ZS5jdWJpY0NvZWZmQSxzPWUuZXhjbHVkZU91dHNpZGUhPT0wLHU9ZS5leHRyYXBvbGF0aW9uVmFsdWUsbD1lLmtlZXBBc3BlY3RSYXRpb1BvbGljeSxvPWUubW9kZSxwPWUubmVhcmVzdE1vZGU9PT1cIlwiP1wic2ltcGxlXCI6ZS5uZWFyZXN0TW9kZTtyZXR1cm4gaWUoe2FudGlhbGlhczp0LGF4ZXM6cixjb29yZGluYXRlVHJhbnNmb3JtTW9kZTphLGN1YmljQ29lZmZBOm4sZXhjbHVkZU91dHNpZGU6cyxleHRyYXBvbGF0aW9uVmFsdWU6dSxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6bCxtb2RlOm8sbmVhcmVzdE1vZGU6cH0pfX0pO3ZhciBZYyxYYyxBdSxFdSxfdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO2tlKCk7dmUoKTtZYz1lPT57aWYoIWV8fGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLlwiKTtsZXQgdD1lWzBdLHI9ZVsxXSxhPWVbMl07aWYodC5kYXRhVHlwZSE9PXIuZGF0YVR5cGV8fHQuZGF0YVR5cGUhPT1hLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZVwiKTtpZih0LmRpbXMubGVuZ3RoIT09MyYmdC5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSAyRCBvciAzRFwiKTtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGJlIDJEIG9yIDNEXCIpO2xldCBuPXQuZGltc1t0LmRpbXMubGVuZ3RoLTFdLHM9dC5kaW1zW3QuZGltcy5sZW5ndGgtMl07aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTJdIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXRcIik7aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBiZSAxRFwiKTtpZihhLmRpbXNbYS5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKGUubGVuZ3RoPjMpe2xldCB1PWVbM107aWYodS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGJlIDFEXCIpO2lmKHUuZGltc1t1LmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX1pZihlLmxlbmd0aD40KXtsZXQgdT1lWzRdO2lmKHUuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBiZSAxRFwiKTtpZih1LmRpbXNbdS5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9fSxYYz0oZSx0LHIsYSk9PntsZXQgbj1lWzBdLmRpbXMscz16LnNpemUobiksdT1uLGw9cyxvPW4uc2xpY2UoLTEpWzBdLHA9YT9uLnNsaWNlKDAsLTEpLmNvbmNhdCgxKTpbXSxtPWUubGVuZ3RoPjMseT1lLmxlbmd0aD40LGc9YSYmcj4xLHY9YSYmcj4yLCQ9cj4zLGI9bXQobyksUz1bRihcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxiKSxGKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLGIpLEYoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGIpXTttJiZTLnB1c2goRihcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyxiKSkseSYmUy5wdXNoKEYoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsYikpLFMucHVzaChYKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx1LGIpKSxnJiZTLnB1c2goWChcIm1lYW5PdXRwdXRcIiwxLHApKSx2JiZTLnB1c2goWChcImludlN0ZE91dHB1dFwiLDEscCkpLCQmJlMucHVzaChYKFwiaW5wdXRTa2lwQmlhc1N1bVwiLGVbMF0uZGF0YVR5cGUsdSxiKSk7bGV0IEk9QmUoZVswXS5kYXRhVHlwZSksVD1QPT5gXG4gICAgICBjb25zdCBoaWRkZW5TaXplOiBmMzIgPSAke299O1xuICAgICAgY29uc3QgaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ6IHUzMiA9ICR7by9ifTtcbiAgICAgIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7dC5lcHNpbG9ufTtcblxuICAgICAgJHtQLmRlY2xhcmVWYXJpYWJsZXMoLi4uUyl9XG5cbiAgICAgICR7UC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtQLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobC9vKX1cbiAgICAgICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiBoaWRkZW5TaXplVmVjdG9yaXplZDtcbiAgICAgICAgdmFyIHN1bSA9ICR7UWUoXCJmMzJcIixiKX07XG4gICAgICAgIHZhciBzcXVhcmVTdW0gPSAke1FlKFwiZjMyXCIsYil9O1xuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwVmFsdWUgPSBza2lwW29mZnNldCArIGldO1xuICAgICAgICAgIGxldCBiaWFzVmFsdWUgPSAke3k/XCJiaWFzW2ldXCI6XCIwLjBcIn07XG4gICAgICAgICAgbGV0IGlucHV0VmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0VmFsdWUgKyBza2lwVmFsdWUgKyBiaWFzVmFsdWU7XG4gICAgICAgICAgJHskP1wiaW5wdXRTa2lwQmlhc1N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMlZhbHVlID0gJHtEdChJLGIsXCJ2YWx1ZVwiKX07XG4gICAgICAgICAgc3VtICs9IGYzMlZhbHVlO1xuICAgICAgICAgIHNxdWFyZVN1bSArPSBmMzJWYWx1ZSAqIGYzMlZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZWFuID0gJHtTdChcInN1bVwiLGIpfSAvIGhpZGRlblNpemU7XG4gICAgICAgIGxldCB2YXJpYW5jZSA9IHNxcnQoJHtTdChcInNxdWFyZVN1bVwiLGIpfSAvIGhpZGRlblNpemUgLSBtZWFuICogbWVhbiArIGVwc2lsb24pO1xuICAgICAgICAke2c/XCJtZWFuT3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjtcIjpcIlwifVxuICAgICAgICAke3Y/XCJpbnZTdGRPdXRwdXRbZ2xvYmFsX2lkeF0gPSAxLjAgLyB2YXJpYW5jZTtcIjpcIlwifVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gLSAke0l9KG1lYW4pKSAvICR7SX0odmFyaWFuY2UpICogZ2FtbWFbaV1cbiAgICAgICAgICAgKyAke20/XCJiZXRhW2ldXCI6XCIwLjBcIn07XG4gICAgICAgIH1cbiAgICAgIH1gLEI9W3tkaW1zOnUsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiByPjEmJkIucHVzaCh7ZGltczpwLGRhdGFUeXBlOjF9KSxyPjImJkIucHVzaCh7ZGltczpwLGRhdGFUeXBlOjF9KSxyPjMmJkIucHVzaCh7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KSx7bmFtZTpcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRTaGFkZXJTb3VyY2U6VCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6QixkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsL28vNjQpfX0pfX0sQXU9KGUsdCk9PntZYyhlLmlucHV0cyk7bGV0IGE9WzBdO2Uub3V0cHV0Q291bnQ+MSYmYS5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJmEucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZhLnB1c2goMyksZS5jb21wdXRlKFhjKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6YX0pfSxFdT1lPT57bGV0IHQ9ZS5lcHNpbG9uO3JldHVybiBpZSh7ZXBzaWxvbjp0fSl9fSk7dmFyIEpjLG1uLFFjLE91LFpjLGVwLFR1LFJ1LFB1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7a2UoKTt2ZSgpO0pjPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7aWYodC5heGVzLmxlbmd0aCE9PTApe2lmKHQuYXhlcy5sZW5ndGghPT10LnN0YXJ0cy5sZW5ndGh8fHQuYXhlcy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpfWVsc2UgaWYodC5zdGFydHMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtlLnNsaWNlKDEpLmZvckVhY2goKHIsYSk9PntpZihlW2ErMV0uZGF0YVR5cGUhPT02JiZlW2ErMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHthfSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCl9KX0sbW49KGUsdCk9PntsZXQgcj1bXTtpZihlLmxlbmd0aD50KWlmKGVbdF0uZGF0YVR5cGU9PT03KWVbdF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goYT0+ci5wdXNoKE51bWJlcihhKSkpO2Vsc2UgaWYoZVt0XS5kYXRhVHlwZT09PTYpZVt0XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaChhPT5yLnB1c2goTnVtYmVyKGEpKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO3JldHVybiByfSxRYz0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPW1uKGUsMSksYT1tbihlLDIpLG49bW4oZSwzKTtyZXR1cm4gbi5sZW5ndGg9PT0wJiYobj1bLi4uQXJyYXkoZVswXS5kaW1zLmxlbmd0aCkua2V5cygpXSksaWUoe3N0YXJ0czpyLGVuZHM6YSxheGVzOm59KX1lbHNlIHJldHVybiB0fSxPdT0oZSx0LHIsYSxuKT0+e2xldCBzPWU7cmV0dXJuIGU8MCYmKHMrPXJbYVt0XV0pLG5bdF08MD9NYXRoLm1heCgwLE1hdGgubWluKHMsclthW3RdXS0xKSk6TWF0aC5tYXgoMCxNYXRoLm1pbihzLHJbYVt0XV0pKX0sWmM9KGUsdCxyLGEpPT5gZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dEluZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMHU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7ci5sZW5ndGh9OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gJHthLmxlbmd0aD09PTE/XCJvdXRwdXRJbmRpY2VzXCI6XCJvdXRwdXRJbmRpY2VzW2ldXCJ9O1xuICAgICAgICAgICAgdmFyIGlucHV0SW5kZXggPSBvdXRwdXRJbmRleCAqIHN0ZXBzW2ldICsgc3RhcnRzW2ldICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0SW5kZXggLyBpbnB1dFNoYXBlW2ldO1xuICAgICAgICAgICAgaW5wdXRJbmRleCA9IGlucHV0SW5kZXggJSBpbnB1dFNoYXBlW2ldO1xuICAgICAgICAgICAgaWYgKHNpZ25zW2ldIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dEluZGV4ID0gaW5wdXRTaGFwZVtpXSAtIGlucHV0SW5kZXggLSAxdSArIHN0YXJ0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7ci5sZW5ndGg9PT0xP1wiaW5wdXRJbmRpY2VzXCI6XCJpbnB1dEluZGljZXNbaV1cIn0gPSBpbnB1dEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5wdXRJbmRpY2VzO1xuICAgICAgfWAsZXA9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsYT16LnNpemUociksbj10LmF4ZXMubGVuZ3RoPjA/ei5ub3JtYWxpemVBeGVzKHQuYXhlcyxyLmxlbmd0aCk6Wy4uLkFycmF5KHIubGVuZ3RoKS5rZXlzKCldLHM9bW4oZSw0KTtzLmZvckVhY2goYj0+YiE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSkscy5sZW5ndGg9PT0wJiYocz1BcnJheShuLmxlbmd0aCkuZmlsbCgxKSk7bGV0IHU9dC5zdGFydHMubWFwKChiLFMpPT5PdShiLFMscixuLHMpKSxsPXQuZW5kcy5tYXAoKGIsUyk9Pk91KGIsUyxyLG4scykpO2lmKG4ubGVuZ3RoIT09ci5sZW5ndGgpZm9yKGxldCBiPTA7YjxyLmxlbmd0aDsrK2Ipbi5pbmNsdWRlcyhiKXx8KHUuc3BsaWNlKGIsMCwwKSxsLnNwbGljZShiLDAscltiXSkscy5zcGxpY2UoYiwwLDEpKTtsZXQgbz1zLm1hcChiPT5NYXRoLnNpZ24oYikpO3MuZm9yRWFjaCgoYixTLEkpPT57aWYoYjwwKXtsZXQgVD0obFtTXS11W1NdKS9iLEI9dVtTXSxQPUIrVCpzW1NdO3VbU109UCxsW1NdPUIsSVtTXT0tYn19KTtsZXQgcD1yLnNsaWNlKDApO24uZm9yRWFjaCgoYixTKT0+e3BbYl09TWF0aC5jZWlsKChsW2JdLXVbYl0pL3NbYl0pfSk7bGV0IG09e2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSx5PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHApLGc9RihcImlucHV0XCIsZVswXS5kYXRhVHlwZSxyKSx2PXouc2l6ZShwKSwkPWI9PmBcbiAgICAgICR7Yi5kZWNsYXJlVmFyaWFibGVzKGcseSl9XG4gICAgICAgIGNvbnN0IHNpZ25zID0gYXJyYXk8aTMyLCAke28ubGVuZ3RofT4oJHtvLm1hcChTPT5gJHtTfWlgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBzdGFydHMgPSBhcnJheTx1MzIsICR7dS5sZW5ndGh9Pigke3UubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IGVuZHMgPSBhcnJheTx1MzIsICR7bC5sZW5ndGh9Pigke2wubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gYXJyYXk8dTMyLCAke3MubGVuZ3RofT4oJHtzLm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xuICAgICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3IubGVuZ3RofT4oJHtyLm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xuXG4gICAgICAgICR7WmMoZyx5LHIscCl9XG4gICAgICAgICR7Yi5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh2KX1cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgaW5wdXRJbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dEluZGljZXMpO1xuICAgICAgICAgICR7eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixnLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKSl9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtlWzRdPy5kaW1zPz9cIlwifWB9LGdldFNoYWRlclNvdXJjZTokLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbbV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSl9fSxUdT0oZSx0KT0+e0pjKGUuaW5wdXRzLHQpO2xldCByPVFjKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShlcChlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxSdT1lPT57bGV0IHQ9ZS5zdGFydHMscj1lLmVuZHMsYT1lLmF4ZXM7cmV0dXJuIGllKHtzdGFydHM6dCxlbmRzOnIsYXhlczphfSl9fSk7dmFyIHRwLHJwLGt1LEJ1LE11PUwoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO2tlKCk7dmUoKTt0cD1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IG9wIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxycD0oZSx0KT0+e2xldCByPUJlKGUuZGF0YVR5cGUpLGE9ZS5kaW1zLG49ei5zaXplKGEpLHM9NjQsdT10LmF4aXM7aWYodTwwJiYodT1hLmxlbmd0aCt1KSx1PGEubGVuZ3RoLTEpdGhyb3cgbmV3IEVycm9yKFwic29mdG1heCBvbmx5IHN1cHBvcnRzIGxhc3QgYXhpcyBmb3Igbm93LlwiKTtsZXQgbD1hW3VdLG89bi9sLHA9bXQobCksbT1sL3AseT1wPT09MT9yOmB2ZWMke3B9PCR7cn0+YCxnPShiLFMpPT5TPT09ND9gbWF4KG1heCgke2J9LngsICR7Yn0ueSksIG1heCgke2J9LnosICR7Yn0udykpYDpTPT09Mj9gbWF4KCR7Yn0ueCwgJHtifS55KWA6Uz09PTM/YG1heChtYXgoJHtifS54LCAke2J9LnkpLCAke2J9LnopYDpiLHY9cj09PVwiZjMyXCI/YHZhciB0aHJlYWRNYXggPSAke3l9KC0zLjQwMjgyM2UrMzhmKTtgOmB2YXIgdGhyZWFkTWF4ID0gJHt5fSgtNjU1MDQuMGgpO2A7cmV0dXJue25hbWU6XCJTb2Z0bWF4XCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Om99fSksZ2V0U2hhZGVyU291cmNlOmI9PmBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7eX07XG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dTdW1TaGFyZWQgOiAke3l9O1xuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHt5fSwgJHtzfT47XG5cbiAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geCA6IGFycmF5PCR7eX0+O1xuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQgOiBhcnJheTwke3l9PjtcblxuICAgICAgZm4gZ2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIpIC0+ICR7eX0ge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXR1cm4geFtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGZuIHNldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyLCB2YWx1ZTogJHt5fSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3N9LCAxLCAxKVxuICAgICAgZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPiwgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzN1KSB7XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkLngpO1xuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkLngpO1xuICAgICAgICBjb25zdCB3ZyA9ICR7c307XG4gICAgICAgIGxldCByb3cgPSBnaW5kZXggLyB3ZztcbiAgICAgICAgbGV0IGNvbHMgPSAke219O1xuICAgICAgICBsZXQgcm93X3N0cmlkZSA6IGkzMiA9ICR7bX07XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcbiAgICAgICAgJHt2fVxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcbiAgICAgICAgICB0aHJlYWRNYXggPSBtYXgodGhyZWFkTWF4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcbiAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZE1heDtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oY29scywgd2cpO1xuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2VTaXplID0gY3VyclNpemUgKyAocmVkdWNlU2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dNYXhTaGFyZWQgPSAke3l9KCR7ZyhcInRocmVhZFNoYXJlZFswXVwiLHApfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXG4gICAgICAgIHZhciB0aHJlYWRTdW0gPSAke3l9KDAuMCk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke3l9KCR7U3QoXCJ0aHJlYWRTaGFyZWRbMF1cIixwKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWB9fSxrdT0oZSx0KT0+e3RwKGUuaW5wdXRzKSxlLmNvbXB1dGUocnAoZS5pbnB1dHNbMF0sdCkpfSxCdT1lPT5pZSh7YXhpczplLmF4aXN9KX0pO3ZhciBucCxhcCxvcCxpcCxzcCxEdSx6dSxXdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtrZSgpO3ZlKCk7bnA9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpfSxhcD0oZSx0KT0+e2xldCByPVtdLGE9dC5udW1PdXRwdXRzO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpLGE9ci5sZW5ndGgpLGllKHtudW1PdXRwdXRzOmEsYXhpczp0LmF4aXMsc3BsaXRTaXplczpyfSl9LG9wPWU9PmBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcbiAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xufWAsaXA9ZT0+e2xldCB0PWUubGVuZ3RoLHI9W107Zm9yKGxldCBhPTA7YTx0OysrYSl7bGV0IG49ZVthXS5zZXRCeUluZGljZXMoXCJpbmRpY2VzXCIsXCJpbnB1dFtnbG9iYWxfaWR4XVwiKTt0PT09MT9yLnB1c2gobik6YT09PTA/ci5wdXNoKGBpZiAob3V0cHV0TnVtYmVyID09ICR7YX11KSB7ICR7bn0gfWApOmE9PT10LTE/ci5wdXNoKGBlbHNlIHsgJHtufSB9YCk6ci5wdXNoKGBlbHNlIGlmIChvdXRwdXROdW1iZXIgPT0gJHthfSkgeyAke259IH1gKX1yZXR1cm5gXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0TnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtyLmpvaW4oYFxuYCl9XG4gICAgICB9YH0sc3A9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsYT16LnNpemUociksbj1lWzBdLmRhdGFUeXBlLHM9ci5sZW5ndGgsdT10LmF4aXMsbD11PDA/ci5sZW5ndGgrdTp1LG89bmV3IEFycmF5KHQubnVtT3V0cHV0cykscD1GKFwiaW5wdXRcIixuLHIpLG09bmV3IEFycmF5KHQubnVtT3V0cHV0cykseT1bXSxnPVtdLHY9MDtmb3IobGV0IFM9MDtTPHQubnVtT3V0cHV0cztTKyspe3YrPXQuc3BsaXRTaXplc1tTXSxtW1NdPXY7bGV0IEk9ci5zbGljZSgpO0lbdC5heGlzXT10LnNwbGl0U2l6ZXNbU10sZy5wdXNoKEkpLG9bU109WChgb3V0cHV0JHtTfWAsbixnW1NdKSx5LnB1c2goe2RpbXM6Z1tTXSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSl9bGV0ICQ9czwyP1wiaW5kaWNlc1wiOmBpbmRpY2VzWyR7bH1dYCxiPVM9PmBcbiAgJHtTLmRlY2xhcmVWYXJpYWJsZXMocCwuLi5vKX1cbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHttLmxlbmd0aH0+KCR7bS5tYXAoST0+YCR7SX11YCkuam9pbihcIixcIil9KTtcbiAgJHtvcChtLmxlbmd0aCl9XG4gICR7aXAobyl9XG5cbiAgJHtTLm1haW5TdGFydCgpfVxuICAgICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGEpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke3Aub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IG91dHB1dE51bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KCR7JH0pO1xuICAgIGlmIChvdXRwdXROdW1iZXIgIT0gMCkge1xuICAgICAgICAkeyR9IC09IHNpemVJbkNvbmNhdEF4aXNbb3V0cHV0TnVtYmVyIC0gMXVdO1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0TnVtYmVyLCBpbmRpY2VzLCBnbG9iYWxfaWR4KTtcbiAgfWA7cmV0dXJue25hbWU6XCJTcGxpdFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFNoYWRlclNvdXJjZTpiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czp5LGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfX0pfX0sRHU9KGUsdCk9PntucChlLmlucHV0cyk7bGV0IHI9ZS5pbnB1dHMubGVuZ3RoPT09MT90OmFwKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShzcChlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSx6dT1lPT57bGV0IHQ9ZS5heGlzLHI9ZS5zcGxpdFNpemVzLGE9ZS5udW1PdXRwdXRzPDA/ci5sZW5ndGg6ZS5udW1PdXRwdXRzO2lmKGEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmdoIG11c3QgYmUgZXF1YWxcIik7cmV0dXJuIGllKHtheGlzOnQsbnVtT3V0cHV0czphLHNwbGl0U2l6ZXM6cn0pfX0pO3ZhciBOdSx1cCxscCxkcCxWdSxVdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO3ZlKCk7TnU9ZT0+QXJyYXkuZnJvbShlLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLHVwPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlRpbGUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihOdShlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LGxwPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDsrK2Epci5wdXNoKGVbYV0qdFthXSk7cmV0dXJuIHJ9LGRwPWU9PntsZXQgdD1lWzBdLmRpbXMscj1OdShlWzFdKSxhPWxwKHQsciksbj16LnNpemUoYSkscz1lWzBdLmRhdGFUeXBlLHU9RihcImlucHV0XCIscyx0KSxsPVgoXCJvdXRwdXRcIixzLGEpLG89cD0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7dS5pbmRpY2VzKC4uLnQpfTtcbiAgICAgICR7cC5kZWNsYXJlVmFyaWFibGVzKHUsbCl9XG4gICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhuKX1cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtsLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgdmFyIGlucHV0SW5kaWNlczogJHt1LnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0RGltVmFsdWUgPSAke2wuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixcImlcIil9ICAlICR7dS5pbmRpY2VzR2V0KFwiaW5wdXRTaGFwZVwiLFwiaVwiKX07XG5cbiAgICAgICAgJHt1LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIixcImlucHV0RGltVmFsdWVcIil9XG4gICAgICB9XG4gICAgICAke2wuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3J9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6b319LFZ1PWU9Pnt1cChlLmlucHV0cyksZS5jb21wdXRlKGRwKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBjcCxwcCxHdSxGdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO3ZlKCk7Y3A9KGUsdCxyLGEsbik9PntsZXQgcz16LnNpemUociksdT1NYXRoLmNlaWwocy80KSxsPVgoXCJvdXRwdXREYXRhXCIsbixyLDQpLG89RihcImFEYXRhXCIsdFsxXS5kYXRhVHlwZSx0WzFdLmRpbXMsNCkscD1GKFwiYkRhdGFcIix0WzJdLmRhdGFUeXBlLHRbMl0uZGltcyw0KSxtPUYoXCJjRGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLDQpLHksZz0odiwkLGIpPT5gc2VsZWN0KCR7JH0sICR7dn0sICR7Yn0pYDtpZighYSl5PWwuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZyhvLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxwLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxtLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7bGV0IHY9KCQsYixTPVwiXCIpPT57bGV0IEk9YGFEYXRhW2luZGV4QSR7Yn1dW2NvbXBvbmVudEEke2J9XWAsVD1gYkRhdGFbaW5kZXhCJHtifV1bY29tcG9uZW50QiR7Yn1dYCxCPWBib29sKGNEYXRhW2luZGV4QyR7Yn1dICYgJHs0Mjc4MTkwMDgwPj4+KDMtYikqOH11KWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke2J9ID0gJHtsLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtifXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7Yn0gPSAke28uYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke2J9YCxsKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7Yn0gPSAke3AuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke2J9YCxsKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QyR7Yn0gPSAke20uYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke2J9YCxsKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtifSA9IG9mZnNldEEke2J9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtifSA9IG9mZnNldEIke2J9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhDJHtifSA9IG9mZnNldEMke2J9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7Yn0gPSBvZmZzZXRBJHtifSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke2J9ID0gb2Zmc2V0QiR7Yn0gJSA0dTtcbiAgICAgICAgICAgICR7JH1bJHtifV0gPSAke1N9KCR7ZyhJLFQsQil9KTtcbiAgICAgICAgICBgfTtuPT09OT95PWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6eT1gXG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMil9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKG0sbyxwLGwpfVxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxuICAgICAgICAke3l9XG4gICAgICB9YH0scHA9ZT0+e2xldCB0PWVbMV0uZGltcyxyPWVbMl0uZGltcyxhPWVbMF0uZGltcyxuPWVbMV0uZGF0YVR5cGUscz0hKHouYXJlRXF1YWwodCxyKSYmei5hcmVFcXVhbChyLGEpKSx1PXQsbD16LnNpemUodCk7aWYocyl7bGV0IG89bnQuY2FsY1NoYXBlKG50LmNhbGNTaGFwZSh0LHIsITEpLGEsITEpO2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7dT1vLGw9ei5zaXplKHUpfXJldHVybntuYW1lOlwiV2hlcmVcIixnZXRTaGFkZXJTb3VyY2U6bz0+Y3AobyxlLHUscyxuKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQvNCl9fSl9fSxHdT1lPT57ZS5jb21wdXRlKHBwKGUuaW5wdXRzKSl9fSk7dmFyIEx1LEh1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtDaSgpO0FpKCk7b3MoKTtncygpO3dzKCk7cmEoKTtQcygpO0RzKCk7TnMoKTtHcygpO0hzKCk7S3MoKTtKcygpO2V1KCk7cnUoKTtvdSgpO3Z1KCk7eHUoKTtlbigpO0l1KCk7X3UoKTtQdSgpO011KCk7V3UoKTtVdSgpO21yKCk7UW4oKTtGdSgpO0x1PW5ldyBNYXAoW1tcIkFic1wiLFtFaV1dLFtcIkFjb3NcIixbX2ldXSxbXCJBY29zaFwiLFtPaV1dLFtcIkFkZFwiLFtpc11dLFtcIkFyZ01heFwiLFtTaSxYbl1dLFtcIkFyZ01pblwiLFt4aSxYbl1dLFtcIkFzaW5cIixbVGldXSxbXCJBc2luaFwiLFtSaV1dLFtcIkF0YW5cIixbUGldXSxbXCJBdGFuaFwiLFtraV1dLFtcIkF2ZXJhZ2VQb29sXCIsW2N1LGR1XV0sW1wiQmlhc0FkZFwiLFtJaV1dLFtcIkJpYXNTcGxpdEdlbHVcIixbYXNdXSxbXCJDYXN0XCIsW01pLEJpXV0sW1wiQ2VpbFwiLFt6aV1dLFtcIkNsaXBWMTBcIixbSm5dXSxbXCJDbGlwXCIsW0RpXV0sW1wiQ29uY2F0XCIsW3lzLGJzXV0sW1wiQ29udlwiLFthYSxuYV1dLFtcIkNvbnZUcmFuc3Bvc2VcIixbUnMsVHNdXSxbXCJDb3NcIixbV2ldXSxbXCJDb3NoXCIsW05pXV0sW1wiRGl2XCIsW3NzXV0sW1wiRWluc3VtXCIsW0JzLE1zXV0sW1wiRWx1XCIsW1ZpLHJuXV0sW1wiRXF1YWxcIixbdXNdXSxbXCJFcmZcIixbVWldXSxbXCJFeHBcIixbR2ldXSxbXCJFeHBhbmRcIixbV3NdXSxbXCJGbG9vclwiLFtGaV1dLFtcIkZ1c2VkQ29udlwiLFthYSxuYV1dLFtcIkdhdGhlclwiLFtVcyxWc11dLFtcIkdhdGhlckVsZW1lbnRzXCIsW0xzLEZzXV0sW1wiR2VsdVwiLFtMaV1dLFtcIkdlbW1cIixbanMscXNdXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFttdSxmdV1dLFtcIkdsb2JhbE1heFBvb2xcIixbd3UsYnVdXSxbXCJHcmVhdGVyXCIsW3BzXV0sW1wiR3JlYXRlck9yRXF1YWxcIixbbXNdXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixbWHMsWXNdXSxbXCJMYXllck5vcm1hbGl6YXRpb25cIixbWnMsUXNdXSxbXCJMZWFreVJlbHVcIixbSGkscm5dXSxbXCJMZXNzXCIsW2ZzXV0sW1wiTGVzc09yRXF1YWxcIixbaHNdXSxbXCJMb2dcIixbbnNdXSxbXCJNYXRNdWxcIixbdHVdXSxbXCJNYXhQb29sXCIsW2d1LHl1XV0sW1wiTXVsXCIsW2xzXV0sW1wiTmVnXCIsW3FpXV0sW1wiTm90XCIsW2ppXV0sW1wiUGFkXCIsW251LGF1XV0sW1wiUG93XCIsW2RzXV0sW1wiUmFuZ2VcIixbJHVdXSxbXCJSZWNpcHJvY2FsXCIsW0tpXV0sW1wiUmVkdWNlTWluXCIsW2hpLFplXV0sW1wiUmVkdWNlTWVhblwiLFtkaSxaZV1dLFtcIlJlZHVjZU1heFwiLFttaSxaZV1dLFtcIlJlZHVjZVN1bVwiLFt5aSxaZV1dLFtcIlJlZHVjZVByb2RcIixbZ2ksWmVdXSxbXCJSZWR1Y2VMMVwiLFtjaSxaZV1dLFtcIlJlZHVjZUwyXCIsW3BpLFplXV0sW1wiUmVkdWNlTG9nU3VtXCIsW3dpLFplXV0sW1wiUmVkdWNlTG9nU3VtRXhwXCIsW2ZpLFplXV0sW1wiUmVkdWNlU3VtU3F1YXJlXCIsW2JpLFplXV0sW1wiUmVsdVwiLFtZaV1dLFtcIlJlc2l6ZVwiLFtTdSxDdV1dLFtcIlNpZ21vaWRcIixbWGldXSxbXCJTaW5cIixbSmldXSxbXCJTaW5oXCIsW1FpXV0sW1wiU2xpY2VcIixbVHUsUnVdXSxbXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsW0F1LEV1XV0sW1wiU3BsaXRcIixbRHUsenVdXSxbXCJTcXJ0XCIsW1ppXV0sW1wiU29mdG1heFwiLFtrdSxCdV1dLFtcIlN1YlwiLFtjc11dLFtcIlRhblwiLFtlc11dLFtcIlRhbmhcIixbdHNdXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbcnMscm5dXSxbXCJUaWxlXCIsW1Z1XV0sW1wiVHJhbnNwb3NlXCIsW0pvLFFvXV0sW1wiV2hlcmVcIixbR3VdXV0pfSk7dmFyIGhuLGp1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO3h0KCk7dmUoKTtobj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdCh0KXtyZXR1cm4gdGhpcy5yZXBvLmdldCh0KX1zZXRBcnRpZmFjdCh0LHIpe3RoaXMucmVwby5zZXQodCxyKX1ydW4odCxyLGEsbixzLHUsbCl7bGV0IG89dGhpcy5iYWNrZW5kLmRldmljZSxwPXRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtwLnNldFBpcGVsaW5lKHQuY29tcHV0ZVBpcGVsaW5lKTtsZXQgbT1bXTtmb3IobGV0IGcgb2YgbiltLnB1c2goe2JpbmRpbmc6bS5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpnLmJ1ZmZlcn19KTtmb3IobGV0IGcgb2YgcyltLnB1c2goe2JpbmRpbmc6bS5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpnLmJ1ZmZlcn19KTtsJiZtLnB1c2goe2JpbmRpbmc6bS5sZW5ndGgscmVzb3VyY2U6bH0pO2xldCB5PW8uY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6dC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6bSxsYWJlbDp0LnByb2dyYW1JbmZvLm5hbWV9KTtpZihwLnNldEJpbmRHcm91cCgwLHkpLHAuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLnUpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKyx0aGlzLmJhY2tlbmQuaXNRdWVyeUVuYWJsZWQoKSl7dHlwZW9mIHRoaXMuYmFja2VuZC5xdWVyeURhdGE+XCJ1XCImJih0aGlzLmJhY2tlbmQucXVlcnlEYXRhPXRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUodGhpcy5iYWNrZW5kLnF1ZXJ5U2V0Q291bnQqOCxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFKSk7bGV0IGc9dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0aGlzLmJhY2tlbmQucXVlcnlTZXRDb3VudCo4LEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKS5yZXNvbHZlUXVlcnlTZXQodGhpcy5iYWNrZW5kLnF1ZXJ5U2V0LDAsMix0aGlzLmJhY2tlbmQucXVlcnlEYXRhLmJ1ZmZlciwwKSx0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKS5jb3B5QnVmZmVyVG9CdWZmZXIodGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YS5idWZmZXIsMCxnLmJ1ZmZlciwwLHRoaXMuYmFja2VuZC5xdWVyeVNldENvdW50KjgpLHRoaXMuYmFja2VuZC5mbHVzaCgpO2xldCB2PXRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQsJD10aGlzLmJhY2tlbmQua2VybmVscy5nZXQodiksYj1gWyR7JFswXX1dICR7JFsxXX1gO2cuYnVmZmVyLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKT0+e2xldCBTPW5ldyBCaWdVaW50NjRBcnJheShnLmJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpKSxJPVNbMF0sVD1TWzFdO2cuYnVmZmVyLnVubWFwKCksdHlwZW9mIHRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlPlwidVwiJiYodGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2U9SSk7bGV0IEI9TnVtYmVyKEktdGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2UpLFA9TnVtYmVyKFQtdGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2UpO2lmKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihCKXx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKFApKXRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZVwiKTt0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShnLmlkKTtsZXQgRD1cIlwiO3IuZm9yRWFjaCgoVyxIKT0+e0QrPWBpbnB1dFske0h9XTogWyR7Vy5kaW1zfV0gfCAke2NyKFcuZGF0YVR5cGUpfSwgYH0pO2xldCBSPVwiXCI7YS5mb3JFYWNoKChXLEgpPT57Uis9YG91dHB1dFske0h9XTogWyR7Vy5kaW1zfV0gfCAke2NyKFcuZGF0YVR5cGUpfSwgYH0pLGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke3Z9fCR7Yn1cIiAke0R9JHtSfWV4ZWN1dGlvbiB0aW1lOiAke1AtQn0gbnNgKX0pfXRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PTE2JiZ0aGlzLmJhY2tlbmQuZmx1c2goKX1kaXNwb3NlKCl7fWJ1aWxkKHQscil7bGV0IGE9dGhpcy5iYWNrZW5kLmRldmljZSxuPVtdO2EuZmVhdHVyZXMuaGFzKFwic2hhZGVyLWYxNlwiKSYmbi5wdXNoKFwiZW5hYmxlIGYxNjtcIik7bGV0IHM9S28ociksdT10LmdldFNoYWRlclNvdXJjZShzKSxsPWAke24uam9pbihgXG5gKX1cbiR7cy5hZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zfVxuJHt1fWAsbz1hLmNyZWF0ZVNoYWRlck1vZHVsZSh7Y29kZTpsLGxhYmVsOnQubmFtZX0pO19lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gc2hhZGVyIGNvZGU6ICR7bH1gKTtsZXQgcD1hLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOm8sZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybntwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTpwfX1ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSh0KXtsZXQgcj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQueCxhPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC55fHwxLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnp8fDEscz10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZihyPD1zJiZhPD1zJiZuPD1zKXJldHVybltyLGEsbl07bGV0IHU9ciphKm4sbD1NYXRoLmNlaWwoTWF0aC5zcXJ0KHUpKTtpZihsPnMpe2lmKGw9TWF0aC5jZWlsKE1hdGguY2JydCh1KSksbD5zKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW2wsbCxsXX1lbHNlIHJldHVybltsLGwsMV19fX0pO3ZhciBmcCxtcCxnbixxdT1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHQoKTtVbygpO0hvKCk7SHUoKTtqdSgpO2ZwPShlLHQpPT57aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke3QubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke2UubGVuZ3RofS5gKTtsZXQgcj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoOysrYSl7bGV0IG49ZVthXS5kYXRhVHlwZTtzd2l0Y2godFthXSl7Y2FzZVwibm9uZVwiOntyLnB1c2goXCJcIik7YnJlYWt9Y2FzZVwidHlwZVwiOntyLnB1c2goYCR7bn1gKTticmVha31jYXNlXCJyYW5rXCI6e2xldCBzPWVbYV0uZGltcy5sZW5ndGg7ci5wdXNoKGAke259OyR7c31gKTticmVha31jYXNlXCJkaW1zXCI6e2xldCBzPWVbYV0uZGltcy5qb2luKFwiLFwiKTtyLnB1c2goYCR7bn07JHtzfWApO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke3RbYV19YCl9fXJldHVybiByLmpvaW4oXCJ8XCIpfSxtcD0oZSx0KT0+e2xldCByPWUubmFtZTtyZXR1cm4gZS5zaGFkZXJDYWNoZT8uaGludCYmKHIrPVwiW1wiK2Uuc2hhZGVyQ2FjaGUuaGludCtcIl1cIikscis9YDoke2ZwKHQsZS5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXM/P25ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChcImRpbXNcIikpfWAscn0sZ249Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsO3RoaXMuY29tbWFuZEVuY29kZXI9bnVsbDt0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsO3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5xdWVyeVNldENvdW50PTI7dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZz1uZXcgTWFwfWdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpe2lmKHRoaXMuY3VycmVudEtlcm5lbElkPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKVwiKTtsZXQgdD10aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtyZXR1cm4gdHx8KHQ9e30sdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCx0KSksdH1hc3luYyBpbml0aWFsaXplKHQpe2lmKCFuYXZpZ2F0b3IuZ3B1KXRocm93IG5ldyBFcnJvcihcIldlYkdwdUJhY2tlbmQ6IFdlYkdQVSBpcyBub3QgYXZhaWxhYmxlLlwiKTtsZXQgcj1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiV2ViR3B1QmFja2VuZDogRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci5cIik7dGhpcy5lbnY9dDtsZXQgYT1bXSxuPXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6ci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLG1heEJ1ZmZlclNpemU6ci5saW1pdHMubWF4QnVmZmVyU2l6ZSxtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6ci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafSxyZXF1aXJlZEZlYXR1cmVzOmF9O3IuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiZhLnB1c2goXCJ0aW1lc3RhbXAtcXVlcnlcIiksci5mZWF0dXJlcy5oYXMoXCJzaGFkZXItZjE2XCIpJiZhLnB1c2goXCJzaGFkZXItZjE2XCIpLHRoaXMuZGV2aWNlPWF3YWl0IHIucmVxdWVzdERldmljZShuKSx0aGlzLmdwdURhdGFNYW5hZ2VyPUxvKHRoaXMpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IGhuKHRoaXMpLHRoaXMua2VybmVscz1uZXcgTWFwLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGE9bmV3IE1hcCx0aGlzLmtlcm5lbEN1c3RvbURhdGE9bmV3IE1hcCxObyh0LmxvZ0xldmVsLCEhdC5kZWJ1ZyksdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3I9cz0+e3MuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3ImJmNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7cy5lcnJvci5tZXNzYWdlfWApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiZGV2aWNlXCIse3ZhbHVlOnRoaXMuZGV2aWNlfSl9ZGlzcG9zZSgpe3R5cGVvZiB0aGlzLnF1ZXJ5U2V0PFwidVwiJiZ0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKSx0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKX1nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe2lmKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcil7bGV0IHQ9e307dGhpcy5pc1F1ZXJ5RW5hYmxlZCgpJiYodHlwZW9mIHRoaXMucXVlcnlTZXQ+XCJ1XCImJih0aGlzLnF1ZXJ5U2V0PXRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHt0eXBlOlwidGltZXN0YW1wXCIsY291bnQ6dGhpcy5xdWVyeVNldENvdW50fSkpLHQudGltZXN0YW1wV3JpdGVzPXtxdWVyeVNldDp0aGlzLnF1ZXJ5U2V0LGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6MCxlbmRPZlBhc3NXcml0ZUluZGV4OjF9KSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj10aGlzLmdldENvbW1hbmRFbmNvZGVyKCkuYmVnaW5Db21wdXRlUGFzcyh0KX1yZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXJ9ZW5kQ29tcHV0ZVBhc3MoKXt0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciYmKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGwpfWZsdXNoKCl7dGhpcy5jb21tYW5kRW5jb2RlciYmKHRoaXMuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKS5maW5pc2goKV0pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCksdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTApfWlzUXVlcnlFbmFibGVkKCl7cmV0dXJuISEodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiZ0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nTW9kZT09PVwiZGVmYXVsdFwiKX1ydW4odCxyLGEsbixzKXtsZXQgdT1bXTtmb3IobGV0IEk9MDtJPHIubGVuZ3RoOysrSSl7bGV0IFQ9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQocltJXS5kYXRhKTtpZighVCl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHtyW0ldLmRhdGF9YCk7dVtJXT1UfWxldCBsPW1wKHQsciksbz10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGwpLHtvdXRwdXRzOnAsZGlzcGF0Y2hHcm91cDptLHByb2dyYW1Vbmlmb3Jtczp5fT10LmdldFJ1bkRhdGEociksZz1hLmxlbmd0aD09PTA/cC5tYXAoKEksVCk9PlQpOmE7aWYoZy5sZW5ndGghPT1wLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7Zy5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtwLmxlbmd0aH0uYCk7bGV0IHY9W10sJD1bXTtmb3IobGV0IEk9MDtJPHAubGVuZ3RoOysrSSl7aWYoIU51bWJlci5pc0ludGVnZXIoZ1tJXSl8fGdbSV08LTN8fGdbSV0+PXAubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7Z1tJXX1gKTtpZihnW0ldPT09LTMpY29udGludWU7bGV0IFQ9Z1tJXT09PS0xLEI9Z1tJXT09PS0yLFA9VHx8Qj9zKHBbSV0uZGF0YVR5cGUscFtJXS5kaW1zKTpuKGdbSV0scFtJXS5kYXRhVHlwZSxwW0ldLmRpbXMpLEQ9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoUC5kYXRhKTtpZighRCl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7UC5kYXRhfWApO2lmKFQmJnRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKEQpLEIpe2xldCBSPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtSfHwoUj1bXSx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCxSKSksUi5wdXNoKEQpfXYucHVzaChQKSwkLnB1c2goRCl9bGV0IGI7aWYoeSl7bGV0IEk9MCxUPTAsQj1bXSxQPTE7eS5mb3JFYWNoKFc9PntsZXQgSD10eXBlb2YgVy5kYXRhPT1cIm51bWJlclwiP1tXLmRhdGFdOlcuZGF0YSxLO3N3aXRjaChILmxlbmd0aCl7Y2FzZSAxOks9NDticmVhaztjYXNlIDI6Sz04O2JyZWFrO2Nhc2UgMzpLPTE2O2JyZWFrO2Nhc2UgNDpLPTE2O2JyZWFrO2Nhc2UgNTpLPTE2O2JyZWFrO2Nhc2UgNjpLPTE2O2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxlbmd0aDogJHtILmxlbmd0aH1gKX0oVD09PTV8fFQ9PT02KSYmKEs9MTYpLEs+UCYmKFA9SyksST1NYXRoLmNlaWwoSS9LKSpLLFQ9SC5sZW5ndGgsQi5wdXNoKEkpLEkrPUgubGVuZ3RoKjR9KSxJPU1hdGguY2VpbChJL1ApKlA7bGV0IEQ9bmV3IEFycmF5QnVmZmVyKEkpO3kuZm9yRWFjaCgoVyxIKT0+e2xldCBLPUJbSF0sbGU9dHlwZW9mIFcuZGF0YT09XCJudW1iZXJcIj9bVy5kYXRhXTpXLmRhdGE7Vy50eXBlPT09XCJpbnQzMlwiP25ldyBJbnQzMkFycmF5KEQsSyxsZS5sZW5ndGgpLnNldChsZSk6Vy50eXBlPT09XCJ1aW50MzJcIj9uZXcgVWludDMyQXJyYXkoRCxLLGxlLmxlbmd0aCkuc2V0KGxlKTpuZXcgRmxvYXQzMkFycmF5KEQsSyxsZS5sZW5ndGgpLnNldChsZSl9KTtsZXQgUj10aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShJLEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO3RoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFIuYnVmZmVyLDAsRCwwLEkpLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShSLmlkKSxiPXtvZmZzZXQ6MCxzaXplOkksYnVmZmVyOlIuYnVmZmVyfX1sZXQgUz10aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKG0pO3JldHVybiBvfHwobz10aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHQsUyksdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChsLG8pKSxfZShcImluZm9cIiwoKT0+YFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHt0Lm5hbWV9XCIgKGtleT0ke2x9KSB3aXRoICR7U1swXX14JHtTWzFdfXgke1NbMl19YCksdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4obyxyLHYsdSwkLFMsYiksdn11cGxvYWQodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZCh0LHIpfW1lbWNweSh0LHIpe3RoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHQscil9YXN5bmMgZG93bmxvYWQodCxyKXthd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKHQscil9YWxsb2ModCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHQpLmlkfWZyZWUodCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh0KX1jcmVhdGVLZXJuZWwodCxyLGEsbil7bGV0IHM9THUuZ2V0KHQpO2lmKCFzKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHt0fWApO3RoaXMua2VybmVscy5zZXQocixbdCxuLHNbMF0sW3NbMV0sYV1dKX1yZWxlYXNlS2VybmVsKHQpe2xldCByPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKHIpe2ZvcihsZXQgYSBvZiByKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShhLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LHIsYSl7bGV0IG49dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldFtzLHUsbCxvXT1uO2lmKHRoaXMuY3VycmVudEtlcm5lbElkIT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske3N9XSAke3V9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7dGhpcy5jdXJyZW50S2VybmVsSWQ9dCxvWzBdJiYob1sxXT1vWzBdKG9bMV0pLG9bMF09dm9pZCAwKSxfZShcImluZm9cIiwoKT0+YFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtzfV0gJHt1fVwiLi4uYCk7bGV0IHA9dGhpcy5lbnYuZGVidWc7dGhpcy50ZW1wb3JhcnlEYXRhPVtdO3RyeXtyZXR1cm4gcCYmdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoXCJ2YWxpZGF0aW9uXCIpLGwocixvWzFdKSwwfWNhdGNoKG0pe3JldHVybiBhLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHtzfV0gJHt1fVwiIGZhaWxlZC4gJHttfWApKSwxfWZpbmFsbHl7cCYmYS5wdXNoKHRoaXMuZGV2aWNlLnBvcEVycm9yU2NvcGUoKS50aGVuKG09Pm0/YEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtzfV0gJHt1fVwiOiAke20ubWVzc2FnZX1gOm51bGwpKTtmb3IobGV0IG0gb2YgdGhpcy50ZW1wb3JhcnlEYXRhKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShtLmlkKTt0aGlzLnRlbXBvcmFyeURhdGE9W10sdGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbH19cmVnaXN0ZXJCdWZmZXIodCxyLGEsbil7bGV0IHM9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7c3x8KHM9bmV3IE1hcCx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLnNldCh0LHMpKTtsZXQgdT1zLmdldChyKSxsPXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihhLG4sdT8uWzFdKTtyZXR1cm4gcy5zZXQocixbbCxhXSksbH11bnJlZ2lzdGVyQnVmZmVycyh0KXtsZXQgcj10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtyJiYoci5mb3JFYWNoKGE9PnRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGFbMV0pKSx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZSh0KSl9Z2V0QnVmZmVyKHQpe2xldCByPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHt0fWApO3JldHVybiByLmJ1ZmZlcn1jcmVhdGVEb3dubG9hZGVyKHQscixhKXtyZXR1cm4gYXN5bmMoKT0+e2xldCBuPWF3YWl0IEZuKHRoaXMsdCxyKTtyZXR1cm4gVm8obi5idWZmZXIsYSl9fX19KTt2YXIgS3U9e307a3QoS3Use2luaXQ6KCk9PmhwfSk7dmFyIHdyLGxhLGhwLFl1PUwoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO3F1KCk7eHQoKTtnZSgpO3dyPWNsYXNzIGV7Y29uc3RydWN0b3IodCxyLGEsbil7dGhpcy5tb2R1bGU9dDt0aGlzLmRhdGFUeXBlPXI7dGhpcy5kYXRhPWE7dGhpcy5kaW1zPW59Z2V0RmxvYXQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ei5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBGbG9hdDMyQXJyYXk6bmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEJpZ0ludDY0QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD16LnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEJpZ0ludDY0QXJyYXk6bmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRJbnQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTYpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ei5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBJbnQzMkFycmF5Om5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9cmVzaGFwZSh0KXtpZih6LnNpemUodCkhPT16LnNpemUodGhpcy5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5ldyBzaGFwZVwiKTtyZXR1cm4gbmV3IGUodGhpcy5tb2R1bGUsdGhpcy5kYXRhVHlwZSx0aGlzLmRhdGEsdCl9fSxsYT1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsYSl7dGhpcy5tb2R1bGU9dDt0aGlzLmJhY2tlbmQ9cjt0aGlzLmN1c3RvbURhdGFPZmZzZXQ9MDt0aGlzLmN1c3RvbURhdGFTaXplPTA7bGV0IG49dC5IRUFQVTMyLHM9YT4+Mjt0aGlzLm9wS2VybmVsQ29udGV4dD1uW3MrK107bGV0IHU9bltzKytdO3RoaXMub3V0cHV0Q291bnQ9bltzKytdLHRoaXMuY3VzdG9tRGF0YU9mZnNldD1uW3MrK10sdGhpcy5jdXN0b21EYXRhU2l6ZT1uW3MrK107bGV0IGw9W107Zm9yKGxldCBvPTA7bzx1O28rKyl7bGV0IHA9bltzKytdLG09bltzKytdLHk9bltzKytdLGc9W107Zm9yKGxldCB2PTA7djx5O3YrKylnLnB1c2gobltzKytdKTtsLnB1c2gobmV3IHdyKHQscCxtLGcpKX10aGlzLmlucHV0cz1sfWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQscil7bGV0IGE9cj8uaW5wdXRzPy5tYXAobD0+dHlwZW9mIGw9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbbF06bCk/P3RoaXMuaW5wdXRzLG49cj8ub3V0cHV0cz8/W10scz0obCxvLHApPT5uZXcgd3IodGhpcy5tb2R1bGUsbyx0aGlzLm91dHB1dChsLHApLHApLHU9KGwsbyk9PntsZXQgcD1wcihsKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtsfWApO2xldCBtPXAqei5zaXplKG8pO3JldHVybiBuZXcgd3IodGhpcy5tb2R1bGUsbCx0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKG0pLmlkLG8pfTtyZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bih0LGEsbixzLHUpfW91dHB1dCh0LHIpe2xldCBhPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgbj10aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxK3IubGVuZ3RoKSo0KSxzPW4+PjI7dGhpcy5tb2R1bGUuSEVBUFUzMltzKytdPXIubGVuZ3RoO2ZvcihsZXQgdT0wO3U8ci5sZW5ndGg7dSsrKXRoaXMubW9kdWxlLkhFQVBVMzJbcysrXT1yW3VdO3JldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCx0LG4pfWNhdGNoKG4pe3Rocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske3R9XSB3aXRoIGRpbXMgWyR7cn1dLiBJZiB5b3UgYXJlIHJ1bm5pbmcgd2l0aCBwcmUtYWxsb2NhdGVkIG91dHB1dCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3V0cHV0IHR5cGUvZGltcyBhcmUgY29ycmVjdC4gRXJyb3I6ICR7bn1gKX1maW5hbGx5e3RoaXMubW9kdWxlLnN0YWNrUmVzdG9yZShhKX19fSxocD1hc3luYyhlLHQpPT57bGV0IHI9ZS5qc2VwSW5pdDtpZihyJiZuYXZpZ2F0b3IuZ3B1KXtpZighdC53YXNtLnNpbWQpdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCBmb3IgV2ViR1BVPU9OIGFuZCBTSU1EPU9GRi4gUGxlYXNlIHNldCBgZW52Lndhc20uc2ltZGAgdG8gdHJ1ZSB3aGVuIHVzaW5nIFdlYkdQVSBFUFwiKTtsZXQgYT1uZXcgZ247YXdhaXQgYS5pbml0aWFsaXplKHQpLHIoYSxuPT5hLmFsbG9jKG4pLG49PmEuZnJlZShuKSwobixzLHUsbD0hMSk9PntpZihsKV9lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7bn0sIGRzdD0ke3N9LCBzaXplPSR7dX1gKSxhLm1lbWNweShuLHMpO2Vsc2V7X2UoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7bn0sIGdwdURhdGFJZD0ke3N9LCBzaXplPSR7dX1gKTtsZXQgbz1lLkhFQVBVOC5zdWJhcnJheShuLG4rdSk7YS51cGxvYWQocyxvKX19LGFzeW5jKG4scyx1KT0+e19lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0NwdTogZ3B1RGF0YUlkPSR7bn0sIGRhdGFPZmZzZXQ9JHtzfSwgc2l6ZT0ke3V9YCksYXdhaXQgYS5kb3dubG9hZChuLCgpPT5lLkhFQVBVOC5zdWJhcnJheShzLHMrdSkpfSwobixzLHUpPT5hLmNyZWF0ZUtlcm5lbChuLHMsdSx0LmRlYnVnfHx0LndlYmdwdS5wcm9maWxpbmdNb2RlPT09XCJkZWZhdWx0XCI/ZS5VVEY4VG9TdHJpbmcoZS5fSnNlcEdldE5vZGVOYW1lKHMpKTpgJHtzfWApLG49PmEucmVsZWFzZUtlcm5lbChuKSwobixzLHUsbCk9PntfZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHt1fSwga2VybmVsPSR7bn0sIGNvbnRleHREYXRhT2Zmc2V0PSR7c31gKTtsZXQgbz1uZXcgbGEoZSxhLHMpO3JldHVybiBhLmNvbXB1dGVLZXJuZWwobixvLGwpfSl9fX0pO3ZhciBKdSxncCx5cCxRdSx2cixadSxkYSxjYSxlbCx0bCxYdSxybCxubCxhbCxvbD1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Qm8oKTtEbygpO0RlKCk7SHQoKTtxcigpO0p1PSExLGdwPWU9PntsZXQgdD1QZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IGE9dC5zdGFja0FsbG9jKDgpO3JldHVybiB0Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50KGUsYSxhKzQpIT09MCYmQWUoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpLFt0LkhFQVAzMlthLzRdLHQuSEVBUDMyW2EvNCsxXV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShyKX19LHlwPShlLHQpPT57UGUoKS5fT3J0SW5pdChlLHQpIT09MCYmQWUoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sUXU9YXN5bmMgZT0+e3lwKGUud2FzbS5udW1UaHJlYWRzLGZyKGUubG9nTGV2ZWwpKTt7bGV0IHQ9KFl1KCksdnQoS3UpKS5pbml0O2F3YWl0IHQoUGUoKSxlKX1KdT0hMH0sdnI9bmV3IE1hcCxadT0oKT0+SnUsZGE9ZT0+e2xldCB0PVBlKCkscj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihyPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsciksW3IsZS5ieXRlTGVuZ3RoXX0sY2E9KGUsdCk9PntsZXQgcj1QZSgpLGE9MCxuPTAscz0wLHU9W10sbD1bXSxvPVtdO3RyeXtbbix1XT1Nbyh0KSxhPXIuX09ydENyZWF0ZVNlc3Npb24oZVswXSxlWzFdLG4pLGE9PT0wJiZBZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpO2xldFtwLG1dPWdwKGEpLHk9W10sZz1bXSx2PVtdO2ZvcihsZXQgYj0wO2I8cDtiKyspe2xldCBTPXIuX09ydEdldElucHV0TmFtZShhLGIpO1M9PT0wJiZBZShcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxsLnB1c2goUykseS5wdXNoKHIuVVRGOFRvU3RyaW5nKFMpKX1mb3IobGV0IGI9MDtiPG07YisrKXtsZXQgUz1yLl9PcnRHZXRPdXRwdXROYW1lKGEsYik7Uz09PTAmJkFlKFwiQ2FuJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxvLnB1c2goUyk7bGV0IEk9ci5VVEY4VG9TdHJpbmcoUyk7Zy5wdXNoKEkpO3tsZXQgVD10eXBlb2YgdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PVwic3RyaW5nXCI/dC5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbjp0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW0ldPz9cImNwdVwiO2lmKFQhPT1cImNwdVwiJiZUIT09XCJjcHUtcGlubmVkXCImJlQhPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtUfS5gKTt2LnB1c2goVCl9fWxldCAkPW51bGw7cmV0dXJuIHYuc29tZShiPT5iPT09XCJncHUtYnVmZmVyXCIpJiYocz1yLl9PcnRDcmVhdGVCaW5kaW5nKGEpLHM9PT0wJiZBZShcIkNhbid0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSwkPXtoYW5kbGU6cyxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6dixvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOnYubWFwKGI9PlVuKGIpKX0pLHZyLnNldChhLFthLGwsbywkXSksW2EseSxnXX1jYXRjaChwKXt0aHJvdyBsLmZvckVhY2gobT0+ci5fT3J0RnJlZShtKSksby5mb3JFYWNoKG09PnIuX09ydEZyZWUobSkpLHMhPT0wJiZyLl9PcnRSZWxlYXNlQmluZGluZyhzKSxhIT09MCYmci5fT3J0UmVsZWFzZVNlc3Npb24oYSkscH1maW5hbGx5e3IuX2ZyZWUoZVswXSksbiE9PTAmJnIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSx1LmZvckVhY2gocD0+ci5fZnJlZShwKSl9fSxlbD0oZSx0KT0+e2xldCByPWRhKGUpO3JldHVybiBjYShyLHQpfSx0bD1lPT57bGV0IHQ9UGUoKSxyPXZyLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFthLG4scyx1XT1yO3UmJnQuX09ydFJlbGVhc2VCaW5kaW5nKHUuaGFuZGxlKSx0LmpzZXBVbnJlZ2lzdGVyQnVmZmVycz8uKGUpLG4uZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSxzLmZvckVhY2gobD0+dC5fT3J0RnJlZShsKSksdC5fT3J0UmVsZWFzZVNlc3Npb24oYSksdnIuZGVsZXRlKGUpfSxYdT0oZSx0LHIsYSxuKT0+e2lmKCFlKXt0LnB1c2goMCk7cmV0dXJufWxldCBzPVBlKCksdT1lWzBdLGw9ZVsxXSxvPWVbM10scCxtO2lmKHU9PT1cInN0cmluZ1wiJiZvPT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7aWYobz09PVwiZ3B1LWJ1ZmZlclwiKXtsZXQgdj1lWzJdLmdwdUJ1ZmZlciwkPXByKFZuKHUpKTttPWwucmVkdWNlKChiLFMpPT5iKlMsMSkqJCxwPXMuanNlcFJlZ2lzdGVyQnVmZmVyKGEsbix2LG0pfWVsc2V7bGV0IHY9ZVsyXTtpZihBcnJheS5pc0FycmF5KHYpKXttPTQqdi5sZW5ndGgscD1zLl9tYWxsb2MobSksci5wdXNoKHApO2xldCAkPXAvNDtmb3IobGV0IGI9MDtiPHYubGVuZ3RoO2IrKyl7aWYodHlwZW9mIHZbYl0hPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtifSBpcyBub3QgYSBzdHJpbmdgKTtzLkhFQVBVMzJbJCsrXT1NZSh2W2JdLHIpfX1lbHNlIG09di5ieXRlTGVuZ3RoLHA9cy5fbWFsbG9jKG0pLHIucHVzaChwKSxzLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkodi5idWZmZXIsdi5ieXRlT2Zmc2V0LG0pLHApfWxldCB5PXMuc3RhY2tTYXZlKCksZz1zLnN0YWNrQWxsb2MoNCpsLmxlbmd0aCk7dHJ5e2xldCB2PWcvNDtsLmZvckVhY2goYj0+cy5IRUFQMzJbdisrXT1iKTtsZXQgJD1zLl9PcnRDcmVhdGVUZW5zb3IoVm4odSkscCxtLGcsbC5sZW5ndGgsVW4obykpOyQ9PT0wJiZBZShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7YX0sIGluZGV4PSR7bn0uYCksdC5wdXNoKCQpfWZpbmFsbHl7cy5zdGFja1Jlc3RvcmUoeSl9fSxybD1hc3luYyhlLHQscixhLG4scyk9PntsZXQgdT1QZSgpLGw9dnIuZ2V0KGUpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFtvLHAsbSx5XT1sLGc9dC5sZW5ndGgsdj1hLmxlbmd0aCwkPTAsYj1bXSxTPVtdLEk9W10sVD1bXSxCPXUuc3RhY2tTYXZlKCksUD11LnN0YWNrQWxsb2MoZyo0KSxEPXUuc3RhY2tBbGxvYyhnKjQpLFI9dS5zdGFja0FsbG9jKHYqNCksVz11LnN0YWNrQWxsb2Modio0KTt0cnl7WyQsYl09a28ocyk7Zm9yKGxldCBvZT0wO29lPGc7b2UrKylYdShyW29lXSxTLFQsZSx0W29lXSk7Zm9yKGxldCBvZT0wO29lPHY7b2UrKylYdShuW29lXSxJLFQsZSxnK2Fbb2VdKTtsZXQgSD1QLzQsSz1ELzQsbGU9Ui80LE09Vy80O2ZvcihsZXQgb2U9MDtvZTxnO29lKyspdS5IRUFQVTMyW0grK109U1tvZV0sdS5IRUFQVTMyW0srK109cFt0W29lXV07Zm9yKGxldCBvZT0wO29lPHY7b2UrKyl1LkhFQVBVMzJbbGUrK109SVtvZV0sdS5IRUFQVTMyW00rK109bVthW29lXV07aWYoeSl7bGV0e2hhbmRsZTpvZSxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6d2Usb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDpqfT15O2lmKHAubGVuZ3RoIT09Zyl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7Z30pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbCdzIGlucHV0IGNvdW50ICgke3AubGVuZ3RofSkuYCk7Zm9yKGxldCBTZT0wO1NlPGc7U2UrKyl7bGV0IFRlPXRbU2VdO2F3YWl0IHUuX09ydEJpbmRJbnB1dChvZSxwW1RlXSxTW1NlXSkhPT0wJiZBZShgQ2FuJ3QgYmluZCBpbnB1dFske1NlfV0gZm9yIHNlc3Npb249JHtlfS5gKX1mb3IobGV0IFNlPTA7U2U8djtTZSsrKXtsZXQgVGU9YVtTZV07bltTZV0/LlszXT91Ll9PcnRCaW5kT3V0cHV0KG9lLG1bVGVdLElbU2VdLDApIT09MCYmQWUoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtTZX1dIGZvciBzZXNzaW9uPSR7ZX0uYCk6dS5fT3J0QmluZE91dHB1dChvZSxtW1RlXSwwLGpbVGVdKSE9PTAmJkFlKGBDYW4ndCBiaW5kIG91dHB1dFske1NlfV0gdG8gJHt3ZVtTZV19IGZvciBzZXNzaW9uPSR7ZX0uYCl9fWxldCBxO3k/cT1hd2FpdCB1Ll9PcnRSdW5XaXRoQmluZGluZyhvLHkuaGFuZGxlLHYsUiwkKTpxPWF3YWl0IHUuX09ydFJ1bihvLEQsUCxnLFcsdixSLCQpLHEhPT0wJiZBZShcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgeGU9W107Zm9yKGxldCBvZT0wO29lPHY7b2UrKyl7bGV0IHdlPXUuSEVBUFUzMltSLzQrb2VdO2lmKHdlPT09SVtvZV0pe3hlLnB1c2gobltvZV0pO2NvbnRpbnVlfWxldCBqPXUuc3RhY2tTYXZlKCksU2U9dS5zdGFja0FsbG9jKDQqNCksVGU9ITEsRWUsQ2U9MDt0cnl7dS5fT3J0R2V0VGVuc29yRGF0YSh3ZSxTZSxTZSs0LFNlKzgsU2UrMTIpIT09MCYmQWUoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtvZX0uYCk7bGV0IExlPVNlLzQscWU9dS5IRUFQVTMyW0xlKytdO0NlPXUuSEVBUFUzMltMZSsrXTtsZXQgVT11LkhFQVBVMzJbTGUrK10sZGU9dS5IRUFQVTMyW0xlKytdLHBlPVtdO2ZvcihsZXQgT2U9MDtPZTxkZTtPZSsrKXBlLnB1c2godS5IRUFQVTMyW1UvNCtPZV0pO3UuX09ydEZyZWUoVSk7bGV0IE5lPXBlLnJlZHVjZSgoT2UsemUpPT5PZSp6ZSwxKTtFZT1jcihxZSk7bGV0IEhlPXk/Lm91dHB1dFByZWZlcnJlZExvY2F0aW9uc1thW29lXV07aWYoRWU9PT1cInN0cmluZ1wiKXtpZihIZT09PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2xldCBPZT1bXSx6ZT1DZS80O2ZvcihsZXQgR2U9MDtHZTxOZTtHZSsrKXtsZXQgZXQ9dS5IRUFQVTMyW3plKytdLEtlPUdlPT09TmUtMT92b2lkIDA6dS5IRUFQVTMyW3plXS1ldDtPZS5wdXNoKHUuVVRGOFRvU3RyaW5nKGV0LEtlKSl9eGUucHVzaChbRWUscGUsT2UsXCJjcHVcIl0pfWVsc2UgaWYoSGU9PT1cImdwdS1idWZmZXJcIiYmTmU+MCl7bGV0IE9lPXUuanNlcEdldEJ1ZmZlcihDZSksemU9cHIocWUpO2lmKHplPT09dm9pZCAwfHwhWXIoRWUpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke0VlfWApO1RlPSEwLHhlLnB1c2goW0VlLHBlLHtncHVCdWZmZXI6T2UsZG93bmxvYWQ6dS5qc2VwQ3JlYXRlRG93bmxvYWRlcihPZSxOZSp6ZSxFZSksZGlzcG9zZTooKT0+e3UuX09ydFJlbGVhc2VUZW5zb3Iod2UpfX0sXCJncHUtYnVmZmVyXCJdKX1lbHNle2xldCBPZT1LcihFZSksemU9bmV3IE9lKE5lKTtuZXcgVWludDhBcnJheSh6ZS5idWZmZXIsemUuYnl0ZU9mZnNldCx6ZS5ieXRlTGVuZ3RoKS5zZXQodS5IRUFQVTguc3ViYXJyYXkoQ2UsQ2UremUuYnl0ZUxlbmd0aCkpLHhlLnB1c2goW0VlLHBlLHplLFwiY3B1XCJdKX19ZmluYWxseXt1LnN0YWNrUmVzdG9yZShqKSxFZT09PVwic3RyaW5nXCImJkNlJiZ1Ll9mcmVlKENlKSxUZXx8dS5fT3J0UmVsZWFzZVRlbnNvcih3ZSl9fXJldHVybiB5JiZ1Ll9PcnRDbGVhckJvdW5kT3V0cHV0cyh5LmhhbmRsZSkseGV9ZmluYWxseXt1LnN0YWNrUmVzdG9yZShCKSxTLmZvckVhY2goSD0+dS5fT3J0UmVsZWFzZVRlbnNvcihIKSksSS5mb3JFYWNoKEg9PnUuX09ydFJlbGVhc2VUZW5zb3IoSCkpLFQuZm9yRWFjaChIPT51Ll9mcmVlKEgpKSwkIT09MCYmdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoJCksYi5mb3JFYWNoKEg9PnUuX2ZyZWUoSCkpfX0sbmw9ZT0+e2xldCB0PVBlKCkscj12ci5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBhPXJbMF0sbj10Ll9PcnRFbmRQcm9maWxpbmcoYSk7bj09PTAmJkFlKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG4pfSxhbD1lPT57bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpe2xldCBhPXJbMl07IUFycmF5LmlzQXJyYXkoYSkmJlwiYnVmZmVyXCJpbiBhJiZ0LnB1c2goYS5idWZmZXIpfXJldHVybiB0fX0pO3ZhciBpbD1MdCgoVXksd3ApPT57d3AuZXhwb3J0cz0nLyohXFxuICogT05OWCBSdW50aW1lIFdlYiB2MS4xNy4wLWRldi4yMDIzMTEwMy0xNDM5ZGEzNmZlXFxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcbiAqL1xcblwidXNlIHN0cmljdFwiOygoKT0+e3ZhciBvbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIFN1PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIEN1PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBBdT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBIPShlLHQpPT4oKT0+KGUmJih0PWUoZT0wKSksdCk7dmFyIEp0PShlLHQpPT4oKT0+KHR8fGUoKHQ9e2V4cG9ydHM6e319KS5leHBvcnRzLHQpLHQuZXhwb3J0cyksSXI9KGUsdCk9Pntmb3IodmFyIHIgaW4gdClvbihlLHIse2dldDp0W3JdLGVudW1lcmFibGU6ITB9KX0sSXU9KGUsdCxyLG8pPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBuIG9mIEN1KHQpKSFBdS5jYWxsKGUsbikmJm4hPT1yJiZvbihlLG4se2dldDooKT0+dFtuXSxlbnVtZXJhYmxlOiEobz1TdSh0LG4pKXx8by5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciBNdD1lPT5JdShvbih7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgYW49e307SXIoYW4se3JlYWRGaWxlOigpPT5FdX0pO3ZhciBFdSxzbj1IKCgpPT57RXU9dm9pZCAwfSk7dmFyIHVuPXt9O0lyKHVuLHtqb2luOigpPT5UdX0pO3ZhciBUdSxsbj1IKCgpPT57VHU9dm9pZCAwfSk7dmFyIHVvPUp0KChzbyxkbik9PntcInVzZSBzdHJpY3RcIjt2YXIgaW89KCgpPT57dmFyIGU9dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMDtyZXR1cm4gdHlwZW9mIF9fZmlsZW5hbWU8XCJ1XCImJihlPWV8fF9fZmlsZW5hbWUpLGZ1bmN0aW9uKHQ9e30pe3ZhciByPXQsbyxuO3IucmVhZHk9bmV3IFByb21pc2UoKGwscCk9PntvPWwsbj1wfSksci5qc2VwSW5pdD0obCxwLGgsQyxULFUsRyx1ZSk9PntyLlphPWwsci5PYT1wLHIuUWE9aCxyLkphPUMsci5QYT1ULHIucmE9VSxyLlJhPUcsci5TYT11ZSxwPShZLFEsSik9PiguLi5jZSk9PntsZXQgbWU9SGUsRT1RPy4oKTtjZT1ZKC4uLmNlKTtsZXQgdGU9UT8uKCk7cmV0dXJuIEUhPT10ZSYmKFk9dGUsSihFKSxRPUo9bnVsbCksSGUhPW1lP2dyKCk6Y2V9LGg9WT0+YXN5bmMoLi4uUSk9Pnt0cnl7aWYoci5EYSl0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCBKPXIuRGE9e1RhOlFbMF0sZXJyb3JzOltdfSxjZT1hd2FpdCBZKC4uLlEpO2lmKHIuRGEhPT1KKXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTtsLmZsdXNoKCk7bGV0IG1lPUouZXJyb3JzO2lmKDA8bWUubGVuZ3RoKXtsZXQgRT1hd2FpdCBQcm9taXNlLmFsbChtZSk7aWYoRT1FLmZpbHRlcih0ZT0+dGUpLDA8RS5sZW5ndGgpdGhyb3cgRXJyb3IoRS5qb2luKGBcXG5gKSl9cmV0dXJuIGNlfWZpbmFsbHl7ci5EYT1udWxsfX0sci5fT3J0UnVuPWgocChyLl9PcnRSdW4sKCk9PnIuX09ydFJ1bixZPT5yLl9PcnRSdW49WSkpLHIuX09ydFJ1bldpdGhCaW5kaW5nPWgocChyLl9PcnRSdW5XaXRoQmluZGluZywoKT0+ci5fT3J0UnVuV2l0aEJpbmRpbmcsWT0+ci5fT3J0UnVuV2l0aEJpbmRpbmc9WSkpLHIuX09ydEJpbmRJbnB1dD1wKHIuX09ydEJpbmRJbnB1dCwoKT0+ci5fT3J0QmluZElucHV0LFk9PnIuX09ydEJpbmRJbnB1dD1ZKSxyLmpzZXBSZWdpc3RlckJ1ZmZlcj0oWSxRLEosY2UpPT5sLnJlZ2lzdGVyQnVmZmVyKFksUSxKLGNlKSxyLmpzZXBVbnJlZ2lzdGVyQnVmZmVycz1ZPT57bC51bnJlZ2lzdGVyQnVmZmVycyhZKX0sci5qc2VwR2V0QnVmZmVyPVk9PmwuZ2V0QnVmZmVyKFkpLHIuanNlcENyZWF0ZURvd25sb2FkZXI9KFksUSxKKT0+bC5jcmVhdGVEb3dubG9hZGVyKFksUSxKKX07dmFyIHM9T2JqZWN0LmFzc2lnbih7fSxyKSx1PVwiLi90aGlzLnByb2dyYW1cIixkPShsLHApPT57dGhyb3cgcH0sYT10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLG09dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixnPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIix4PVwiXCIsYix3LHY7aWYoZyl7dmFyIHk9KHNuKCksTXQoYW4pKSxTPShsbigpLE10KHVuKSk7eD1tP1MuZGlybmFtZSh4KStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsYj0obCxwKT0+KGw9bC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGwpOlMubm9ybWFsaXplKGwpLHkucmVhZEZpbGVTeW5jKGwscD92b2lkIDA6XCJ1dGY4XCIpKSx2PWw9PihsPWIobCwhMCksbC5idWZmZXJ8fChsPW5ldyBVaW50OEFycmF5KGwpKSxsKSx3PShsLHAsaCxDPSEwKT0+e2w9bC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGwpOlMubm9ybWFsaXplKGwpLHkucmVhZEZpbGUobCxDP3ZvaWQgMDpcInV0ZjhcIiwoVCxVKT0+e1Q/aChUKTpwKEM/VS5idWZmZXI6VSl9KX0sIXIudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHU9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMiksZD0obCxwKT0+e3Rocm93IHByb2Nlc3MuZXhpdENvZGU9bCxwfSxyLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn1lbHNlKGF8fG0pJiYobT94PXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJih4PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxlJiYoeD1lKSx4LmluZGV4T2YoXCJibG9iOlwiKSE9PTA/eD14LnN1YnN0cigwLHgucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6eD1cIlwiLGI9bD0+e3ZhciBwPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gcC5vcGVuKFwiR0VUXCIsbCwhMSkscC5zZW5kKG51bGwpLHAucmVzcG9uc2VUZXh0fSxtJiYodj1sPT57dmFyIHA9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBwLm9wZW4oXCJHRVRcIixsLCExKSxwLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIscC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHAucmVzcG9uc2UpfSksdz0obCxwLGgpPT57dmFyIEM9bmV3IFhNTEh0dHBSZXF1ZXN0O0Mub3BlbihcIkdFVFwiLGwsITApLEMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixDLm9ubG9hZD0oKT0+e0Muc3RhdHVzPT0yMDB8fEMuc3RhdHVzPT0wJiZDLnJlc3BvbnNlP3AoQy5yZXNwb25zZSk6aCgpfSxDLm9uZXJyb3I9aCxDLnNlbmQobnVsbCl9KTt2YXIgQT1yLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFI9ci5wcmludEVycnx8Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24ocixzKSxzPW51bGwsci50aGlzUHJvZ3JhbSYmKHU9ci50aGlzUHJvZ3JhbSksci5xdWl0JiYoZD1yLnF1aXQpO3ZhciBXO3Iud2FzbUJpbmFyeSYmKFc9ci53YXNtQmluYXJ5KTt2YXIgTT1yLm5vRXhpdFJ1bnRpbWV8fCEwO3R5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIiYmTGUoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBELF8sej0hMSxGLHEsbGUsQixLLHhlLGFlO2Z1bmN0aW9uIHdlKCl7dmFyIGw9RC5idWZmZXI7ci5IRUFQOD1xPW5ldyBJbnQ4QXJyYXkobCksci5IRUFQMTY9bmV3IEludDE2QXJyYXkobCksci5IRUFQMzI9Qj1uZXcgSW50MzJBcnJheShsKSxyLkhFQVBVOD1sZT1uZXcgVWludDhBcnJheShsKSxyLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGwpLHIuSEVBUFUzMj1LPW5ldyBVaW50MzJBcnJheShsKSxyLkhFQVBGMzI9eGU9bmV3IEZsb2F0MzJBcnJheShsKSxyLkhFQVBGNjQ9YWU9bmV3IEZsb2F0NjRBcnJheShsKX12YXIgaj1bXSxTZT1bXSxPZT1bXTtmdW5jdGlvbiBJZSgpe3ZhciBsPXIucHJlUnVuLnNoaWZ0KCk7ai51bnNoaWZ0KGwpfXZhciBDZT0wLGR0PW51bGwsTmU9bnVsbDtmdW5jdGlvbiBMZShsKXt0aHJvdyByLm9uQWJvcnQmJnIub25BYm9ydChsKSxsPVwiQWJvcnRlZChcIitsK1wiKVwiLFIobCksej0hMCxGPTEsbD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGwrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLG4obCksbH1mdW5jdGlvbiBOKGwpe3JldHVybiBsLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfXZhciBkZTtpZihkZT1cIm9ydC13YXNtLXNpbWQud2FzbVwiLCFOKGRlKSl7dmFyIHBlPWRlO2RlPXIubG9jYXRlRmlsZT9yLmxvY2F0ZUZpbGUocGUseCk6eCtwZX1mdW5jdGlvbiB6ZShsKXtpZihsPT1kZSYmVylyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoVyk7aWYodilyZXR1cm4gdihsKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBVZShsKXtpZighVyYmKGF8fG0pKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIWwuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKGwse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4ocD0+e2lmKCFwLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK2wrXCJcXCdcIjtyZXR1cm4gcC5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9PnplKGwpKTtpZih3KXJldHVybiBuZXcgUHJvbWlzZSgocCxoKT0+e3cobCxDPT5wKG5ldyBVaW50OEFycmF5KEMpKSxoKX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT56ZShsKSl9ZnVuY3Rpb24gVGUobCxwLGgpe3JldHVybiBVZShsKS50aGVuKEM9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEMscCkpLnRoZW4oQz0+QykudGhlbihoLEM9PntSKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrQyksTGUoQyl9KX1mdW5jdGlvbiBrZShsLHApe3ZhciBoPWRlO3JldHVybiBXfHx0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8TihoKXx8aC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Z3x8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/VGUoaCxsLHApOmZldGNoKGgse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oQz0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoQyxsKS50aGVuKHAsZnVuY3Rpb24oVCl7cmV0dXJuIFIoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrVCksUihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLFRlKGgsbCxwKX0pKX12YXIgR2UsWGU9ezkxMzc5MjpsPT57ci5yYShcIkFic1wiLGwsdm9pZCAwKX0sOTEzODQzOmw9PntyLnJhKFwiTmVnXCIsbCx2b2lkIDApfSw5MTM4OTQ6bD0+e3IucmEoXCJGbG9vclwiLGwsdm9pZCAwKX0sOTEzOTQ3Omw9PntyLnJhKFwiQ2VpbFwiLGwsdm9pZCAwKX0sOTEzOTk5Omw9PntyLnJhKFwiUmVjaXByb2NhbFwiLGwsdm9pZCAwKX0sOTE0MDU3Omw9PntyLnJhKFwiU3FydFwiLGwsdm9pZCAwKX0sOTE0MTA5Omw9PntyLnJhKFwiRXhwXCIsbCx2b2lkIDApfSw5MTQxNjA6bD0+e3IucmEoXCJFcmZcIixsLHZvaWQgMCl9LDkxNDIxMTpsPT57ci5yYShcIlNpZ21vaWRcIixsLHZvaWQgMCl9LDkxNDI2NjpsPT57ci5yYShcIkxvZ1wiLGwsdm9pZCAwKX0sOTE0MzE3Omw9PntyLnJhKFwiU2luXCIsbCx2b2lkIDApfSw5MTQzNjg6bD0+e3IucmEoXCJDb3NcIixsLHZvaWQgMCl9LDkxNDQxOTpsPT57ci5yYShcIlRhblwiLGwsdm9pZCAwKX0sOTE0NDcwOmw9PntyLnJhKFwiQXNpblwiLGwsdm9pZCAwKX0sOTE0NTIyOmw9PntyLnJhKFwiQWNvc1wiLGwsdm9pZCAwKX0sOTE0NTc0Omw9PntyLnJhKFwiQXRhblwiLGwsdm9pZCAwKX0sOTE0NjI2Omw9PntyLnJhKFwiU2luaFwiLGwsdm9pZCAwKX0sOTE0Njc4Omw9PntyLnJhKFwiQ29zaFwiLGwsdm9pZCAwKX0sOTE0NzMwOmw9PntyLnJhKFwiQXNpbmhcIixsLHZvaWQgMCl9LDkxNDc4MzpsPT57ci5yYShcIkFjb3NoXCIsbCx2b2lkIDApfSw5MTQ4MzY6bD0+e3IucmEoXCJBdGFuaFwiLGwsdm9pZCAwKX0sOTE0ODg5Omw9PntyLnJhKFwiVGFuaFwiLGwsdm9pZCAwKX0sOTE0OTQxOmw9PntyLnJhKFwiTm90XCIsbCx2b2lkIDApfSw5MTQ5OTI6KGwscCxoKT0+e3IucmEoXCJDbGlwVjEwXCIsbCx7bWluOnAsbWF4Omh9KX0sOTE1MDY0Omw9PntyLnJhKFwiQ2xpcFwiLGwsdm9pZCAwKX0sOTE1MTE2OihsLHApPT57ci5yYShcIkVsdVwiLGwse2FscGhhOnB9KX0sOTE1MTc0Omw9PntyLnJhKFwiUmVsdVwiLGwsdm9pZCAwKX0sOTE1MjI2OihsLHApPT57ci5yYShcIkxlYWt5UmVsdVwiLGwse2FscGhhOnB9KX0sOTE1MjkwOihsLHApPT57ci5yYShcIlRocmVzaG9sZGVkUmVsdVwiLGwse2FscGhhOnB9KX0sOTE1MzYwOihsLHApPT57ci5yYShcIkNhc3RcIixsLHt0bzpwfSl9LDkxNTQxODpsPT57ci5yYShcIkFkZFwiLGwsdm9pZCAwKX0sOTE1NDY5Omw9PntyLnJhKFwiU3ViXCIsbCx2b2lkIDApfSw5MTU1MjA6bD0+e3IucmEoXCJNdWxcIixsLHZvaWQgMCl9LDkxNTU3MTpsPT57ci5yYShcIkRpdlwiLGwsdm9pZCAwKX0sOTE1NjIyOmw9PntyLnJhKFwiUG93XCIsbCx2b2lkIDApfSw5MTU2NzM6bD0+e3IucmEoXCJFcXVhbFwiLGwsdm9pZCAwKX0sOTE1NzI2Omw9PntyLnJhKFwiR3JlYXRlclwiLGwsdm9pZCAwKX0sOTE1NzgxOmw9PntyLnJhKFwiR3JlYXRlck9yRXF1YWxcIixsLHZvaWQgMCl9LDkxNTg0MzpsPT57ci5yYShcIkxlc3NcIixsLHZvaWQgMCl9LDkxNTg5NTpsPT57ci5yYShcIkxlc3NPckVxdWFsXCIsbCx2b2lkIDApfSw5MTU5NTQ6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlTWVhblwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE2MTE4OihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZU1heFwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE2MjgxOihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZU1pblwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE2NDQ0OihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZVByb2RcIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNjYwODoobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VTdW1cIixsLHtrZWVwRGltczohIXAsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkxNjc3MToobCxwLGgsQyxUKT0+e3IucmEoXCJSZWR1Y2VMMVwiLGwse2tlZXBEaW1zOiEhcCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczpDP0FycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUK0M+Pj4wKSk6W119KX0sOTE2OTMzOihsLHAsaCxDLFQpPT57ci5yYShcIlJlZHVjZUwyXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTcwOTU6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlTG9nU3VtXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTcyNjE6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlU3VtU3F1YXJlXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTc0MzA6KGwscCxoLEMsVCk9PntyLnJhKFwiUmVkdWNlTG9nU3VtRXhwXCIsbCx7a2VlcERpbXM6ISFwLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXX0pfSw5MTc1OTk6bD0+e3IucmEoXCJXaGVyZVwiLGwsdm9pZCAwKX0sOTE3NjUyOihsLHAsaCk9PntyLnJhKFwiVHJhbnNwb3NlXCIsbCx7cGVybTpwP0FycmF5LmZyb20oQi5zdWJhcnJheShoPj4+MCxoK3A+Pj4wKSk6W119KX0sOTE3NzY1OihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUsdGUpPT57ci5yYShcIkNvbnZUcmFuc3Bvc2VcIixsLHtmb3JtYXQ6WT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnAsZGlsYXRpb25zOltoXSxncm91cDpDLGtlcm5lbF9zaGFwZTpbVF0scGFkczpbVSxHXSxzdHJpZGVzOlt1ZV0sd0lzQ29uc3Q6KCk9PiEhcVtRPj4+MF0sb3V0cHV0UGFkZGluZzpKP0FycmF5LmZyb20oQi5zdWJhcnJheShjZT4+PjAsY2UrSj4+PjApKTpbXSxvdXRwdXRTaGFwZTptZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoRT4+PjAsRSttZT4+PjApKTpbXSxhY3RpdmF0aW9uOl9lKHRlKX0pfSw5MTgxNzk6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGwse2Zvcm1hdDp1ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnAsZGlsYXRpb25zOkFycmF5LmZyb20oQi5zdWJhcnJheShoPj4+MCxoKzI+Pj4wKSksZ3JvdXA6QyxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShCLnN1YmFycmF5KFU+Pj4wLFUrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oQi5zdWJhcnJheShHPj4+MCxHKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcVtZPj4+MF0sb3V0cHV0UGFkZGluZzowPFE/QXJyYXkuZnJvbShCLnN1YmFycmF5KEo+Pj4wLEorUT4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGNlP0FycmF5LmZyb20oQi5zdWJhcnJheShtZT4+PjAsbWUrY2U+Pj4wKSk6W10sYWN0aXZhdGlvbjpfZShFKX0pfSw5MTg3MzY6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSx0ZSk9PntyLnJhKFwiQ29udlRyYW5zcG9zZVwiLGwse2Zvcm1hdDpZP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6cCxkaWxhdGlvbnM6W2hdLGdyb3VwOkMsa2VybmVsX3NoYXBlOltUXSxwYWRzOltVLEddLHN0cmlkZXM6W3VlXSx3SXNDb25zdDooKT0+ISFxW1E+Pj4wXSxvdXRwdXRQYWRkaW5nOko/QXJyYXkuZnJvbShCLnN1YmFycmF5KGNlPj4+MCxjZStKPj4+MCkpOltdLG91dHB1dFNoYXBlOm1lP0FycmF5LmZyb20oQi5zdWJhcnJheShFPj4+MCxFK21lPj4+MCkpOltdLGFjdGl2YXRpb246X2UodGUpfSl9LDkxOTE1MDoobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFKT0+e3IucmEoXCJDb252VHJhbnNwb3NlXCIsbCx7Zm9ybWF0OnVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6cCxkaWxhdGlvbnM6QXJyYXkuZnJvbShCLnN1YmFycmF5KGg+Pj4wLGgrMj4+PjApKSxncm91cDpDLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oQi5zdWJhcnJheShUPj4+MCxUKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoVT4+PjAsVSs0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShCLnN1YmFycmF5KEc+Pj4wLEcrMj4+PjApKSx3SXNDb25zdDooKT0+ISFxW1k+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8UT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoSj4+PjAsSitRPj4+MCkpOltdLG91dHB1dFNoYXBlOjA8Y2U/QXJyYXkuZnJvbShCLnN1YmFycmF5KG1lPj4+MCxtZStjZT4+PjApKTpbXSxhY3RpdmF0aW9uOl9lKEUpfSl9LDkxOTcwNzoobCxwKT0+e3IucmEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGwse2Zvcm1hdDpwP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkxOTc5ODoobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJBdmVyYWdlUG9vbFwiLGwse2Zvcm1hdDpmZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpwLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOkMsc3RvcmFnZV9vcmRlcjpULGRpbGF0aW9uczpbVSxHXSxrZXJuZWxfc2hhcGU6W3VlLFldLHBhZHM6W1EsSixjZSxtZV0sc3RyaWRlczpbRSx0ZV19KX0sOTIwMDgyOihsLHApPT57ci5yYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsbCx7Zm9ybWF0OnA/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIwMTczOihsLHAsaCxDLFQsVSxHLHVlLFksUSxKLGNlLG1lLEUsdGUsZmUpPT57ci5yYShcIkF2ZXJhZ2VQb29sXCIsbCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnAsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOlQsZGlsYXRpb25zOltVLEddLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbUSxKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjA0NTc6KGwscCk9PntyLnJhKFwiR2xvYmFsTWF4UG9vbFwiLGwse2Zvcm1hdDpwP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDU0NDoobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJNYXhQb29sXCIsbCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnAsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOlQsZGlsYXRpb25zOltVLEddLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbUSxKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjA4MjQ6KGwscCk9PntyLnJhKFwiR2xvYmFsTWF4UG9vbFwiLGwse2Zvcm1hdDpwP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDkxMToobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSxFLHRlLGZlKT0+e3IucmEoXCJNYXhQb29sXCIsbCx7Zm9ybWF0OmZlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnAsY2VpbF9tb2RlOmgsY291bnRfaW5jbHVkZV9wYWQ6QyxzdG9yYWdlX29yZGVyOlQsZGlsYXRpb25zOltVLEddLGtlcm5lbF9zaGFwZTpbdWUsWV0scGFkczpbUSxKLGNlLG1lXSxzdHJpZGVzOltFLHRlXX0pfSw5MjExOTE6KGwscCxoLEMsVCk9PntyLnJhKFwiR2VtbVwiLGwse2FscGhhOnAsYmV0YTpoLHRyYW5zQTpDLHRyYW5zQjpUfSl9LDkyMTI5NTpsPT57ci5yYShcIk1hdE11bFwiLGwsdm9pZCAwKX0sOTIxMzQ5OihsLHAsaCxDKT0+e3IucmEoXCJBcmdNYXhcIixsLHtrZWVwRGltczohIXAsc2VsZWN0TGFzdEluZGV4OiEhaCxheGlzOkN9KX0sOTIxNDU3OihsLHAsaCxDKT0+e3IucmEoXCJBcmdNaW5cIixsLHtrZWVwRGltczohIXAsc2VsZWN0TGFzdEluZGV4OiEhaCxheGlzOkN9KX0sOTIxNTY1OihsLHApPT57ci5yYShcIlNvZnRtYXhcIixsLHtheGlzOnB9KX0sOTIxNjI4OihsLHApPT57ci5yYShcIkNvbmNhdFwiLGwse2F4aXM6cH0pfSw5MjE2ODg6KGwscCxoLEMsVCk9PntyLnJhKFwiU3BsaXRcIixsLHtheGlzOnAsbnVtT3V0cHV0czpoLHNwbGl0U2l6ZXM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkyMTgzMzpsPT57ci5yYShcIkV4cGFuZFwiLGwsdm9pZCAwKX0sOTIxODg3OihsLHApPT57ci5yYShcIkdhdGhlclwiLGwse2F4aXM6TnVtYmVyKHApfSl9LDkyMTk1ODoobCxwKT0+e3IucmEoXCJHYXRoZXJFbGVtZW50c1wiLGwse2F4aXM6TnVtYmVyKHApfSl9LDkyMjAzNzoobCxwLGgsQyxULFUsRyx1ZSxZLFEsSik9PntyLnJhKFwiUmVzaXplXCIsbCx7YW50aWFsaWFzOnAsYXhlczpoP0FycmF5LmZyb20oQi5zdWJhcnJheShDPj4+MCxDK2g+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6X2UoVCksY3ViaWNDb2VmZkE6VSxleGNsdWRlT3V0c2lkZTpHLGV4dHJhcG9sYXRpb25WYWx1ZTp1ZSxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6X2UoWSksbW9kZTpfZShRKSxuZWFyZXN0TW9kZTpfZShKKX0pfSw5MjIzODg6KGwscCxoLEMsVCxVLEcpPT57ci5yYShcIlNsaWNlXCIsbCx7c3RhcnRzOnA/QXJyYXkuZnJvbShCLnN1YmFycmF5KGg+Pj4wLGgrcD4+PjApKTpbXSxlbmRzOkM/QXJyYXkuZnJvbShCLnN1YmFycmF5KFQ+Pj4wLFQrQz4+PjApKTpbXSxheGVzOlU/QXJyYXkuZnJvbShCLnN1YmFycmF5KEc+Pj4wLEcrVT4+PjApKTpbXX0pfSw5MjI2MTk6bD0+e3IucmEoXCJUaWxlXCIsbCx2b2lkIDApfSw5MjI2NzE6KGwscCxoKT0+e3IucmEoXCJMYXllck5vcm1hbGl6YXRpb25cIixsLHtheGlzOk51bWJlcihwKSxlcHNpbG9uOk51bWJlcihoKX0pfSw5MjI3Nzg6KGwscCxoKT0+e3IucmEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixsLHtlcHNpbG9uOnAsZm9ybWF0Omg/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyODkyOihsLHAsaCk9PntyLnJhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsbCx7ZXBzaWxvbjpwLGZvcm1hdDpoP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMzAwNjpsPT57ci5yYShcIlJhbmdlXCIsbCx2b2lkIDApfSw5MjMwNTk6KGwscCk9PntyLnJhKFwiRWluc3VtXCIsbCx7ZXF1YXRpb246X2UocCl9KX0sOTIzMTQwOihsLHAsaCxDLFQpPT57ci5yYShcIlBhZFwiLGwse21vZGU6cCx2YWx1ZTpoLHBhZHM6Qz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoVD4+PjAsVCtDPj4+MCkpOltdfSl9LDkyMzI3MjpsPT57ci5yYShcIkdlbHVcIixsLHZvaWQgMCl9LDkyMzMyNDpsPT57ci5yYShcIkJpYXNBZGRcIixsLHZvaWQgMCl9LDkyMzM3OTpsPT57ci5yYShcIkJpYXNTcGxpdEdlbHVcIixsLHZvaWQgMCl9LDkyMzQ0MDoobCxwKT0+e3IucmEoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsbCx7ZXBzaWxvbjpwfSl9LDkyMzUyMToobCxwLGgsQyxULFUsRyx1ZSxZLFEsSixjZSxtZSk9PntyLnJhKFwiQ29udlwiLGwse2Zvcm1hdDpZP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnAsZGlsYXRpb25zOltoXSxncm91cDpDLGtlcm5lbF9zaGFwZTpbVF0scGFkczpVP0FycmF5LmZyb20oQi5zdWJhcnJheShHPj4+MCxHK1U+Pj4wKSk6W10sc3RyaWRlczpbdWVdLHdfaXNfY29uc3Q6KCk9PiEhcVtRPj4+MF0sYWN0aXZhdGlvbjpfZShKKSxhY3RpdmF0aW9uX3BhcmFtczpjZT9BcnJheS5mcm9tKHhlLnN1YmFycmF5KG1lPj4+MCxtZStjZT4+PjApKTpbXX0pfSw5MjM5MDI6KGwscCxoLEMsVCxVLEcsdWUsWSxRLEosY2UsbWUsRSx0ZSxmZSk9PntyLnJhKFwiQ29udlwiLGwse2Zvcm1hdDpjZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpwLGRpbGF0aW9uczpbaCxDXSxncm91cDpULGtlcm5lbF9zaGFwZTpbVSxHXSxwYWRzOnVlP0FycmF5LmZyb20oQi5zdWJhcnJheShZPj4+MCxZK3VlPj4+MCkpOltdLHN0cmlkZXM6W1EsSl0sd19pc19jb25zdDooKT0+ISFxW21lPj4+MF0sYWN0aXZhdGlvbjpfZShFKSxhY3RpdmF0aW9uX3BhcmFtczp0ZT9BcnJheS5mcm9tKHhlLnN1YmFycmF5KGZlPj4+MCxmZSt0ZT4+PjApKTpbXX0pfSw5MjQzMDQ6bD0+e3IuUmEobCl9LDkyNDMzODoobCxwKT0+ci5TYShsLHAsci5EYS5UYSxyLkRhLmVycm9ycyksOTI0NDUwOmw9PnIuT2EobCksOTI0NDgzOmw9PnIuUWEobCksOTI0NTE1OihsLHAsaCk9PntyLkphKGwscCxoLCEwKX0sOTI0NTU0OihsLHAsaCk9PntyLkphKGwscCxoKX19O2Z1bmN0aW9uIEZlKGwpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtsfSlgLHRoaXMuc3RhdHVzPWx9dmFyIHl0PWw9Pntmb3IoOzA8bC5sZW5ndGg7KWwuc2hpZnQoKShyKX07ZnVuY3Rpb24gYnQobCl7dGhpcy5IYT1sLTI0LHRoaXMuTWE9ZnVuY3Rpb24ocCl7S1t0aGlzLkhhKzQ+PjI+Pj4wXT1wfSx0aGlzLkxhPWZ1bmN0aW9uKHApe0tbdGhpcy5IYSs4Pj4yPj4+MF09cH0sdGhpcy5ZYT1mdW5jdGlvbihwLGgpe3RoaXMuS2EoKSx0aGlzLk1hKHApLHRoaXMuTGEoaCl9LHRoaXMuS2E9ZnVuY3Rpb24oKXtLW3RoaXMuSGErMTY+PjI+Pj4wXT0wfX12YXIgQnQ9MCxscj0wLEtlPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxrdD0obCxwLGgpPT57cD4+Pj0wO3ZhciBDPXAraDtmb3IoaD1wO2xbaF0mJiEoaD49Qyk7KSsraDtpZigxNjxoLXAmJmwuYnVmZmVyJiZLZSlyZXR1cm4gS2UuZGVjb2RlKGwuc3ViYXJyYXkocCxoKSk7Zm9yKEM9XCJcIjtwPGg7KXt2YXIgVD1sW3ArK107aWYoVCYxMjgpe3ZhciBVPWxbcCsrXSY2MztpZigoVCYyMjQpPT0xOTIpQys9U3RyaW5nLmZyb21DaGFyQ29kZSgoVCYzMSk8PDZ8VSk7ZWxzZXt2YXIgRz1sW3ArK10mNjM7VD0oVCYyNDApPT0yMjQ/KFQmMTUpPDwxMnxVPDw2fEc6KFQmNyk8PDE4fFU8PDEyfEc8PDZ8bFtwKytdJjYzLDY1NTM2PlQ/Qys9U3RyaW5nLmZyb21DaGFyQ29kZShUKTooVC09NjU1MzYsQys9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxUPj4xMCw1NjMyMHxUJjEwMjMpKX19ZWxzZSBDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFQpfXJldHVybiBDfSxfZT0obCxwKT0+KGw+Pj49MCk/a3QobGUsbCxwKTpcIlwiLEl0PWw9Pntmb3IodmFyIHA9MCxoPTA7aDxsLmxlbmd0aDsrK2gpe3ZhciBDPWwuY2hhckNvZGVBdChoKTsxMjc+PUM/cCsrOjIwNDc+PUM/cCs9Mjo1NTI5Njw9QyYmNTczNDM+PUM/KHArPTQsKytoKTpwKz0zfXJldHVybiBwfSxEdD0obCxwLGgsQyk9PntpZihoPj4+PTAsISgwPEMpKXJldHVybiAwO3ZhciBUPWg7Qz1oK0MtMTtmb3IodmFyIFU9MDtVPGwubGVuZ3RoOysrVSl7dmFyIEc9bC5jaGFyQ29kZUF0KFUpO2lmKDU1Mjk2PD1HJiY1NzM0Mz49Ryl7dmFyIHVlPWwuY2hhckNvZGVBdCgrK1UpO0c9NjU1MzYrKChHJjEwMjMpPDwxMCl8dWUmMTAyM31pZigxMjc+PUcpe2lmKGg+PUMpYnJlYWs7cFtoKys+Pj4wXT1HfWVsc2V7aWYoMjA0Nz49Ryl7aWYoaCsxPj1DKWJyZWFrO3BbaCsrPj4+MF09MTkyfEc+PjZ9ZWxzZXtpZig2NTUzNT49Ryl7aWYoaCsyPj1DKWJyZWFrO3BbaCsrPj4+MF09MjI0fEc+PjEyfWVsc2V7aWYoaCszPj1DKWJyZWFrO3BbaCsrPj4+MF09MjQwfEc+PjE4LHBbaCsrPj4+MF09MTI4fEc+PjEyJjYzfXBbaCsrPj4+MF09MTI4fEc+PjYmNjN9cFtoKys+Pj4wXT0xMjh8RyY2M319cmV0dXJuIHBbaD4+PjBdPTAsaC1UfSxhdD1sPT5sJTQ9PT0wJiYobCUxMDAhPT0wfHxsJTQwMD09PTApLGRyPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLGl0PVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdLEV0PWw9Pnt2YXIgcD1JdChsKSsxLGg9UnQocCk7cmV0dXJuIGgmJkR0KGwsbGUsaCxwKSxofSxjdD1bXSxUdD0obCxwKT0+e2N0Lmxlbmd0aD0wO3ZhciBoO2ZvcihwPj49MjtoPWxlW2wrKz4+PjBdOylwKz1oIT0xMDUmcCxjdC5wdXNoKGg9PTEwNT9CW3A+Pj4wXTphZVtwKys+Pj4xXSksKytwO3JldHVybiBjdH0sT3Q9e30sV3Q9KCk9PntpZighX3Qpe3ZhciBsPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOnV8fFwiLi90aGlzLnByb2dyYW1cIn0scDtmb3IocCBpbiBPdClPdFtwXT09PXZvaWQgMD9kZWxldGUgbFtwXTpsW3BdPU90W3BdO3ZhciBoPVtdO2ZvcihwIGluIGwpaC5wdXNoKGAke3B9PSR7bFtwXX1gKTtfdD1ofXJldHVybiBfdH0sX3QsY3I9W251bGwsW10sW11dLFZlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0senQ9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBWdChsKXt2YXIgcD1BcnJheShJdChsKSsxKTtyZXR1cm4gRHQobCxwLDAscC5sZW5ndGgpLHB9ZnVuY3Rpb24gbmUobCxwLGgsQyl7ZnVuY3Rpb24gVChFLHRlLGZlKXtmb3IoRT10eXBlb2YgRT09XCJudW1iZXJcIj9FLnRvU3RyaW5nKCk6RXx8XCJcIjtFLmxlbmd0aDx0ZTspRT1mZVswXStFO3JldHVybiBFfWZ1bmN0aW9uIFUoRSx0ZSl7cmV0dXJuIFQoRSx0ZSxcIjBcIil9ZnVuY3Rpb24gRyhFLHRlKXtmdW5jdGlvbiBmZShYdCl7cmV0dXJuIDA+WHQ/LTE6MDxYdD8xOjB9dmFyIHV0O3JldHVybih1dD1mZShFLmdldEZ1bGxZZWFyKCktdGUuZ2V0RnVsbFllYXIoKSkpPT09MCYmKHV0PWZlKEUuZ2V0TW9udGgoKS10ZS5nZXRNb250aCgpKSk9PT0wJiYodXQ9ZmUoRS5nZXREYXRlKCktdGUuZ2V0RGF0ZSgpKSksdXR9ZnVuY3Rpb24gdWUoRSl7c3dpdGNoKEUuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gRTtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShFLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gWShFKXt2YXIgdGU9RS5CYTtmb3IoRT1uZXcgRGF0ZShuZXcgRGF0ZShFLkNhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8dGU7KXt2YXIgZmU9RS5nZXRNb250aCgpLHV0PShhdChFLmdldEZ1bGxZZWFyKCkpP1ZlOnp0KVtmZV07aWYodGU+dXQtRS5nZXREYXRlKCkpdGUtPXV0LUUuZ2V0RGF0ZSgpKzEsRS5zZXREYXRlKDEpLDExPmZlP0Uuc2V0TW9udGgoZmUrMSk6KEUuc2V0TW9udGgoMCksRS5zZXRGdWxsWWVhcihFLmdldEZ1bGxZZWFyKCkrMSkpO2Vsc2V7RS5zZXREYXRlKEUuZ2V0RGF0ZSgpK3RlKTticmVha319cmV0dXJuIGZlPW5ldyBEYXRlKEUuZ2V0RnVsbFllYXIoKSsxLDAsNCksdGU9dWUobmV3IERhdGUoRS5nZXRGdWxsWWVhcigpLDAsNCkpLGZlPXVlKGZlKSwwPj1HKHRlLEUpPzA+PUcoZmUsRSk/RS5nZXRGdWxsWWVhcigpKzE6RS5nZXRGdWxsWWVhcigpOkUuZ2V0RnVsbFllYXIoKS0xfWw+Pj49MCxwPj4+PTAsaD4+Pj0wLEM+Pj49MDt2YXIgUT1CW0MrNDA+PjI+Pj4wXTtDPXtXYTpCW0M+PjI+Pj4wXSxWYTpCW0MrND4+Mj4+PjBdLEVhOkJbQys4Pj4yPj4+MF0sSWE6QltDKzEyPj4yPj4+MF0sRmE6QltDKzE2Pj4yPj4+MF0sQ2E6QltDKzIwPj4yPj4+MF0sd2E6QltDKzI0Pj4yPj4+MF0sQmE6QltDKzI4Pj4yPj4+MF0sJGE6QltDKzMyPj4yPj4+MF0sVWE6QltDKzM2Pj4yPj4+MF0sWGE6UT9fZShRKTpcIlwifSxoPV9lKGgpLFE9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIEogaW4gUSloPWgucmVwbGFjZShuZXcgUmVnRXhwKEosXCJnXCIpLFFbSl0pO3ZhciBjZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLG1lPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtRPXtcIiVhXCI6RT0+Y2VbRS53YV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOkU9PmNlW0Uud2FdLFwiJWJcIjpFPT5tZVtFLkZhXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6RT0+bWVbRS5GYV0sXCIlQ1wiOkU9PlUoKEUuQ2ErMTkwMCkvMTAwfDAsMiksXCIlZFwiOkU9PlUoRS5JYSwyKSxcIiVlXCI6RT0+VChFLklhLDIsXCIgXCIpLFwiJWdcIjpFPT5ZKEUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpFPT5ZKEUpLFwiJUhcIjpFPT5VKEUuRWEsMiksXCIlSVwiOkU9PihFPUUuRWEsRT09MD9FPTEyOjEyPEUmJihFLT0xMiksVShFLDIpKSxcIiVqXCI6RT0+e2Zvcih2YXIgdGU9MCxmZT0wO2ZlPD1FLkZhLTE7dGUrPShhdChFLkNhKzE5MDApP1ZlOnp0KVtmZSsrXSk7cmV0dXJuIFUoRS5JYSt0ZSwzKX0sXCIlbVwiOkU9PlUoRS5GYSsxLDIpLFwiJU1cIjpFPT5VKEUuVmEsMiksXCIlblwiOigpPT5gXFxuYCxcIiVwXCI6RT0+MDw9RS5FYSYmMTI+RS5FYT9cIkFNXCI6XCJQTVwiLFwiJVNcIjpFPT5VKEUuV2EsMiksXCIldFwiOigpPT5cIlx0XCIsXCIldVwiOkU9PkUud2F8fDcsXCIlVVwiOkU9PlUoTWF0aC5mbG9vcigoRS5CYSs3LUUud2EpLzcpLDIpLFwiJVZcIjpFPT57dmFyIHRlPU1hdGguZmxvb3IoKEUuQmErNy0oRS53YSs2KSU3KS83KTtpZigyPj0oRS53YSszNzEtRS5CYS0yKSU3JiZ0ZSsrLHRlKXRlPT01MyYmKGZlPShFLndhKzM3MS1FLkJhKSU3LGZlPT00fHxmZT09MyYmYXQoRS5DYSl8fCh0ZT0xKSk7ZWxzZXt0ZT01Mjt2YXIgZmU9KEUud2ErNy1FLkJhLTEpJTc7KGZlPT00fHxmZT09NSYmYXQoRS5DYSU0MDAtMSkpJiZ0ZSsrfXJldHVybiBVKHRlLDIpfSxcIiV3XCI6RT0+RS53YSxcIiVXXCI6RT0+VShNYXRoLmZsb29yKChFLkJhKzctKEUud2ErNiklNykvNyksMiksXCIleVwiOkU9PihFLkNhKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjpFPT5FLkNhKzE5MDAsXCIlelwiOkU9PntFPUUuVWE7dmFyIHRlPTA8PUU7cmV0dXJuIEU9TWF0aC5hYnMoRSkvNjAsKHRlP1wiK1wiOlwiLVwiKSsoXCIwMDAwXCIrKEUvNjAqMTAwK0UlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpFPT5FLlhhLFwiJSVcIjooKT0+XCIlXCJ9LGg9aC5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKTtmb3IoSiBpbiBRKWguaW5jbHVkZXMoSikmJihoPWgucmVwbGFjZShuZXcgUmVnRXhwKEosXCJnXCIpLFFbSl0oQykpKTtyZXR1cm4gaD1oLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIiksSj1WdChoKSxKLmxlbmd0aD5wPzA6KHEuc2V0KEosbD4+PjApLEoubGVuZ3RoLTEpfWZ1bmN0aW9uIHN0KGwpe3RyeXtsKCl9Y2F0Y2gocCl7TGUocCl9fWZ1bmN0aW9uIHByKGwpe3ZhciBwPXt9LGg7Zm9yKGggaW4gbCkoZnVuY3Rpb24oQyl7dmFyIFQ9bFtDXTtwW0NdPXR5cGVvZiBUPT1cImZ1bmN0aW9uXCI/ZnVuY3Rpb24oKXt3dC5wdXNoKEMpO3RyeXtyZXR1cm4gVC5hcHBseShudWxsLGFyZ3VtZW50cyl9ZmluYWxseXt6fHwod3QucG9wKCk9PT1DfHxMZSgpLEhlJiZKZT09PTEmJnd0Lmxlbmd0aD09PTAmJihKZT0wLHN0KHF0KSx0eXBlb2YgRmliZXJzPFwidVwiJiZGaWJlcnMuYWIoKSkpfX06VH0pKGgpO3JldHVybiBwfXZhciBKZT0wLEhlPW51bGwsZnI9MCx3dD1bXSxHdD17fSxOdD17fSxtcj0wLHZ0PW51bGwsaHI9W107ZnVuY3Rpb24gZ3IoKXtyZXR1cm4gbmV3IFByb21pc2UoKGwscCk9Pnt2dD17cmVzb2x2ZTpsLHJlamVjdDpwfX0pfWZ1bmN0aW9uIHlyKCl7dmFyIGw9UnQoNjU1NDgpLHA9bCsxMjtLW2w+PjI+Pj4wXT1wLEtbbCs0Pj4yPj4+MF09cCs2NTUzNixwPXd0WzBdO3ZhciBoPUd0W3BdO3JldHVybiBoPT09dm9pZCAwJiYoaD1tcisrLEd0W3BdPWgsTnRbaF09cCksQltsKzg+PjI+Pj4wXT1oLGx9ZnVuY3Rpb24gYnIobCl7aWYoIXope2lmKEplPT09MCl7dmFyIHA9ITEsaD0hMTtsKChDPTApPT57aWYoIXomJihmcj1DLHA9ITAsaCkpe0plPTIsc3QoKCk9PlB0KEhlKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuR2EuTmEmJkJyb3dzZXIuR2EucmVzdW1lKCksQz0hMTt0cnl7dmFyIFQ9KDAsX1tOdFtCW0hlKzg+PjI+Pj4wXV1dKSgpfWNhdGNoKHVlKXtUPXVlLEM9ITB9dmFyIFU9ITE7aWYoIUhlKXt2YXIgRz12dDtHJiYodnQ9bnVsbCwoQz9HLnJlamVjdDpHLnJlc29sdmUpKFQpLFU9ITApfWlmKEMmJiFVKXRocm93IFR9fSksaD0hMCxwfHwoSmU9MSxIZT15cigpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkdhLk5hJiZCcm93c2VyLkdhLnBhdXNlKCksc3QoKCk9Pkt0KEhlKSkpfWVsc2UgSmU9PT0yPyhKZT0wLHN0KCR0KSxVdChIZSksSGU9bnVsbCxoci5mb3JFYWNoKEM9PntpZigheil0cnl7aWYoQygpLCFNKXRyeXtGPUY9Qz1GLE18fChyLm9uRXhpdCYmci5vbkV4aXQoQyksej0hMCksZChDLG5ldyBGZShDKSl9Y2F0Y2goVCl7VCBpbnN0YW5jZW9mIEZlfHxUPT1cInVud2luZFwifHxkKDEsVCl9fWNhdGNoKFQpe1QgaW5zdGFuY2VvZiBGZXx8VD09XCJ1bndpbmRcInx8ZCgxLFQpfX0pKTpMZShgaW52YWxpZCBzdGF0ZTogJHtKZX1gKTtyZXR1cm4gZnJ9fWZ1bmN0aW9uIHdyKGwpe3JldHVybiBicihwPT57bCgpLnRoZW4ocCl9KX12YXIgdnI9e246ZnVuY3Rpb24obCxwLGgpe3JldHVybiB3cihhc3luYygpPT57YXdhaXQgci5QYShsLHAsaCl9KX0sYTpmdW5jdGlvbihsLHAsaCl7dGhyb3cgbD4+Pj0wLG5ldyBidChsKS5ZYShwPj4+MCxoPj4+MCksQnQ9bCxscisrLEJ0fSxnOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEo6ZnVuY3Rpb24oKXt9LHo6ZnVuY3Rpb24oKXt9LEI6ZnVuY3Rpb24oKXt9LEw6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sSDpmdW5jdGlvbigpe30sQzpmdW5jdGlvbigpe30sRzpmdW5jdGlvbigpe30sbDpmdW5jdGlvbigpe30sQTpmdW5jdGlvbigpe30seDpmdW5jdGlvbigpe30sSTpmdW5jdGlvbigpe30seTpmdW5jdGlvbigpe30sbTooKT0+ITAscTpmdW5jdGlvbihsLHAsaCl7bD1wKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFsPyhsPj4+MCkrNDI5NDk2NzI5NipwOk5hTixoPj4+PTAsbD1uZXcgRGF0ZSgxZTMqbCksQltoPj4yPj4+MF09bC5nZXRVVENTZWNvbmRzKCksQltoKzQ+PjI+Pj4wXT1sLmdldFVUQ01pbnV0ZXMoKSxCW2grOD4+Mj4+PjBdPWwuZ2V0VVRDSG91cnMoKSxCW2grMTI+PjI+Pj4wXT1sLmdldFVUQ0RhdGUoKSxCW2grMTY+PjI+Pj4wXT1sLmdldFVUQ01vbnRoKCksQltoKzIwPj4yPj4+MF09bC5nZXRVVENGdWxsWWVhcigpLTE5MDAsQltoKzI0Pj4yPj4+MF09bC5nZXRVVENEYXkoKSxCW2grMjg+PjI+Pj4wXT0obC5nZXRUaW1lKCktRGF0ZS5VVEMobC5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MH0scjpmdW5jdGlvbihsLHAsaCl7bD1wKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFsPyhsPj4+MCkrNDI5NDk2NzI5NipwOk5hTixoPj4+PTAsbD1uZXcgRGF0ZSgxZTMqbCksQltoPj4yPj4+MF09bC5nZXRTZWNvbmRzKCksQltoKzQ+PjI+Pj4wXT1sLmdldE1pbnV0ZXMoKSxCW2grOD4+Mj4+PjBdPWwuZ2V0SG91cnMoKSxCW2grMTI+PjI+Pj4wXT1sLmdldERhdGUoKSxCW2grMTY+PjI+Pj4wXT1sLmdldE1vbnRoKCksQltoKzIwPj4yPj4+MF09bC5nZXRGdWxsWWVhcigpLTE5MDAsQltoKzI0Pj4yPj4+MF09bC5nZXREYXkoKSxCW2grMjg+PjI+Pj4wXT0oYXQobC5nZXRGdWxsWWVhcigpKT9kcjppdClbbC5nZXRNb250aCgpXStsLmdldERhdGUoKS0xfDAsQltoKzM2Pj4yPj4+MF09LSg2MCpsLmdldFRpbWV6b25lT2Zmc2V0KCkpLHA9bmV3IERhdGUobC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgQz1uZXcgRGF0ZShsLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO0JbaCszMj4+Mj4+PjBdPShwIT1DJiZsLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKEMscCkpfDB9LHM6ZnVuY3Rpb24obCl7bD4+Pj0wO3ZhciBwPW5ldyBEYXRlKEJbbCsyMD4+Mj4+PjBdKzE5MDAsQltsKzE2Pj4yPj4+MF0sQltsKzEyPj4yPj4+MF0sQltsKzg+PjI+Pj4wXSxCW2wrND4+Mj4+PjBdLEJbbD4+Mj4+PjBdLDApLGg9QltsKzMyPj4yPj4+MF0sQz1wLmdldFRpbWV6b25lT2Zmc2V0KCksVD1uZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLFU9bmV3IERhdGUocC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxHPU1hdGgubWluKFUsVCk7cmV0dXJuIDA+aD9CW2wrMzI+PjI+Pj4wXT0rKFQhPVUmJkc9PUMpOjA8aCE9KEc9PUMpJiYoVD1NYXRoLm1heChVLFQpLHAuc2V0VGltZShwLmdldFRpbWUoKSs2ZTQqKCgwPGg/RzpUKS1DKSkpLEJbbCsyND4+Mj4+PjBdPXAuZ2V0RGF5KCksQltsKzI4Pj4yPj4+MF09KGF0KHAuZ2V0RnVsbFllYXIoKSk/ZHI6aXQpW3AuZ2V0TW9udGgoKV0rcC5nZXREYXRlKCktMXwwLEJbbD4+Mj4+PjBdPXAuZ2V0U2Vjb25kcygpLEJbbCs0Pj4yPj4+MF09cC5nZXRNaW51dGVzKCksQltsKzg+PjI+Pj4wXT1wLmdldEhvdXJzKCksQltsKzEyPj4yPj4+MF09cC5nZXREYXRlKCksQltsKzE2Pj4yPj4+MF09cC5nZXRNb250aCgpLEJbbCsyMD4+Mj4+PjBdPXAuZ2V0WWVhcigpLGw9cC5nZXRUaW1lKCkvMWUzLEx0KChHZT1sLDE8PStNYXRoLmFicyhHZSk/MDxHZT8rTWF0aC5mbG9vcihHZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChHZS0rKH5+R2U+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxsPj4+MH0sbzpmdW5jdGlvbigpe3JldHVybi01Mn0scDpmdW5jdGlvbigpe30sdjpmdW5jdGlvbihsLHAsaCl7ZnVuY3Rpb24gQyhZKXtyZXR1cm4oWT1ZLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT9ZWzFdOlwiR01UXCJ9aD4+Pj0wO3ZhciBUPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxVPW5ldyBEYXRlKFQsMCwxKSxHPW5ldyBEYXRlKFQsNiwxKTtUPVUuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgdWU9Ry5nZXRUaW1lem9uZU9mZnNldCgpO0tbbD4+PjA+PjI+Pj4wXT02MCpNYXRoLm1heChULHVlKSxCW3A+Pj4wPj4yPj4+MF09KyhUIT11ZSksbD1DKFUpLHA9QyhHKSxsPUV0KGwpLHA9RXQocCksdWU8VD8oS1toPj4yPj4+MF09bCxLW2grND4+Mj4+PjBdPXApOihLW2g+PjI+Pj4wXT1wLEtbaCs0Pj4yPj4+MF09bCl9LGU6KCk9PntMZShcIlwiKX0sYjpmdW5jdGlvbihsLHAsaCl7cmV0dXJuIGw+Pj49MCxwPVR0KHA+Pj4wLGg+Pj4wKSxYZVtsXS5hcHBseShudWxsLHApfSxpOmZ1bmN0aW9uKGwscCxoKXtyZXR1cm4gbD4+Pj0wLHA9VHQocD4+PjAsaD4+PjApLFhlW2xdLmFwcGx5KG51bGwscCl9LGg6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sdzpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxjOigpPT5wZXJmb3JtYW5jZS5ub3coKSxLOmZ1bmN0aW9uKGwscCxoKXtyZXR1cm4gcD4+Pj0wLGxlLmNvcHlXaXRoaW4obD4+PjA+Pj4wLHA+Pj4wLHArKGg+Pj4wKT4+PjApfSx1OmZ1bmN0aW9uKGwpe2w+Pj49MDt2YXIgcD1sZS5sZW5ndGg7aWYoNDI5NDkwMTc2MDxsKXJldHVybiExO2Zvcih2YXIgaD0xOzQ+PWg7aCo9Mil7dmFyIEM9cCooMSsuMi9oKTtDPU1hdGgubWluKEMsbCsxMDA2NjMyOTYpO3ZhciBUPU1hdGg7Qz1NYXRoLm1heChsLEMpO2U6e1Q9VC5taW4uY2FsbChULDQyOTQ5MDE3NjAsQysoNjU1MzYtQyU2NTUzNiklNjU1MzYpLUQuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7RC5ncm93KFQpLHdlKCk7dmFyIFU9MTticmVhayBlfWNhdGNoe31VPXZvaWQgMH1pZihVKXJldHVybiEwfXJldHVybiExfSxEOmZ1bmN0aW9uKGwscCl7bD4+Pj0wLHA+Pj49MDt2YXIgaD0wO3JldHVybiBXdCgpLmZvckVhY2goZnVuY3Rpb24oQyxUKXt2YXIgVT1wK2g7Zm9yKFQ9S1tsKzQqVD4+Mj4+PjBdPVUsVT0wO1U8Qy5sZW5ndGg7KytVKXFbVCsrPj4wPj4+MF09Qy5jaGFyQ29kZUF0KFUpO3FbVD4+MD4+PjBdPTAsaCs9Qy5sZW5ndGgrMX0pLDB9LEU6ZnVuY3Rpb24obCxwKXtsPj4+PTAscD4+Pj0wO3ZhciBoPVd0KCk7S1tsPj4yPj4+MF09aC5sZW5ndGg7dmFyIEM9MDtyZXR1cm4gaC5mb3JFYWNoKGZ1bmN0aW9uKFQpe0MrPVQubGVuZ3RoKzF9KSxLW3A+PjI+Pj4wXT1DLDB9LGY6KCk9PjUyLGs6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LHQ6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LGo6ZnVuY3Rpb24obCxwLGgsQyl7cD4+Pj0wLGg+Pj49MCxDPj4+PTA7Zm9yKHZhciBUPTAsVT0wO1U8aDtVKyspe3ZhciBHPUtbcD4+Mj4+PjBdLHVlPUtbcCs0Pj4yPj4+MF07cCs9ODtmb3IodmFyIFk9MDtZPHVlO1krKyl7dmFyIFE9bGVbRytZPj4+MF0sSj1jcltsXTtRPT09MHx8UT09PTEwPygobD09PTE/QTpSKShrdChKLDApKSxKLmxlbmd0aD0wKTpKLnB1c2goUSl9VCs9dWV9cmV0dXJuIEtbQz4+Mj4+PjBdPVQsMH0sRjpuZSxkOmZ1bmN0aW9uKGwscCxoLEMpe3JldHVybiBuZShsPj4+MCxwPj4+MCxoPj4+MCxDPj4+MCl9fTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBsKGgpe2lmKGg9aC5leHBvcnRzLGg9cHIoaCksXz1oPXB0KGgpLEQ9Xy5NLHdlKCksU2UudW5zaGlmdChfLk4pLENlLS0sci5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoQ2UpLENlPT0wJiYoZHQhPT1udWxsJiYoY2xlYXJJbnRlcnZhbChkdCksZHQ9bnVsbCksTmUpKXt2YXIgQz1OZTtOZT1udWxsLEMoKX1yZXR1cm4gaH12YXIgcD17YTp2cn07aWYoQ2UrKyxyLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnIubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhDZSksci5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiByLmluc3RhbnRpYXRlV2FzbShwLGwpfWNhdGNoKGgpe1IoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitoKSxuKGgpfXJldHVybiBrZShwLGZ1bmN0aW9uKGgpe2woaC5pbnN0YW5jZSl9KS5jYXRjaChuKSx7fX0pKCksci5fT3J0SW5pdD0obCxwKT0+KHIuX09ydEluaXQ9Xy5PKShsLHApLHIuX09ydEdldExhc3RFcnJvcj0obCxwKT0+KHIuX09ydEdldExhc3RFcnJvcj1fLlApKGwscCksci5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KGwscCxoLEMsVCxVLEcsdWUsWSxRKT0+KHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPV8uUSkobCxwLGgsQyxULFUsRyx1ZSxZLFEpLHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShsLHApPT4oci5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9Xy5SKShsLHApLHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0obCxwLGgpPT4oci5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPV8uUykobCxwLGgpLHIuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0obCxwLGgpPT4oci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PV8uVCkobCxwLGgpLHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1sPT4oci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPV8uVSkobCksci5fT3J0Q3JlYXRlU2Vzc2lvbj0obCxwLGgpPT4oci5fT3J0Q3JlYXRlU2Vzc2lvbj1fLlYpKGwscCxoKSxyLl9PcnRSZWxlYXNlU2Vzc2lvbj1sPT4oci5fT3J0UmVsZWFzZVNlc3Npb249Xy5XKShsKSxyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShsLHAsaCk9PihyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PV8uWCkobCxwLGgpLHIuX09ydEdldElucHV0TmFtZT0obCxwKT0+KHIuX09ydEdldElucHV0TmFtZT1fLlkpKGwscCksci5fT3J0R2V0T3V0cHV0TmFtZT0obCxwKT0+KHIuX09ydEdldE91dHB1dE5hbWU9Xy5aKShsLHApLHIuX09ydEZyZWU9bD0+KHIuX09ydEZyZWU9Xy5fKShsKSxyLl9PcnRDcmVhdGVUZW5zb3I9KGwscCxoLEMsVCxVKT0+KHIuX09ydENyZWF0ZVRlbnNvcj1fLiQpKGwscCxoLEMsVCxVKSxyLl9PcnRHZXRUZW5zb3JEYXRhPShsLHAsaCxDLFQpPT4oci5fT3J0R2V0VGVuc29yRGF0YT1fLmFhKShsLHAsaCxDLFQpLHIuX09ydFJlbGVhc2VUZW5zb3I9bD0+KHIuX09ydFJlbGVhc2VUZW5zb3I9Xy5iYSkobCksci5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0obCxwLGgsQyk9PihyLl9PcnRDcmVhdGVSdW5PcHRpb25zPV8uY2EpKGwscCxoLEMpLHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShsLHAsaCk9PihyLl9PcnRBZGRSdW5Db25maWdFbnRyeT1fLmRhKShsLHAsaCksci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9bD0+KHIuX09ydFJlbGVhc2VSdW5PcHRpb25zPV8uZWEpKGwpLHIuX09ydENyZWF0ZUJpbmRpbmc9bD0+KHIuX09ydENyZWF0ZUJpbmRpbmc9Xy5mYSkobCksci5fT3J0QmluZElucHV0PShsLHAsaCk9PihyLl9PcnRCaW5kSW5wdXQ9Xy5nYSkobCxwLGgpLHIuX09ydEJpbmRPdXRwdXQ9KGwscCxoLEMpPT4oci5fT3J0QmluZE91dHB1dD1fLmhhKShsLHAsaCxDKSxyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1sPT4oci5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9Xy5pYSkobCksci5fT3J0UmVsZWFzZUJpbmRpbmc9bD0+KHIuX09ydFJlbGVhc2VCaW5kaW5nPV8uamEpKGwpLHIuX09ydFJ1bldpdGhCaW5kaW5nPShsLHAsaCxDLFQpPT4oci5fT3J0UnVuV2l0aEJpbmRpbmc9Xy5rYSkobCxwLGgsQyxUKSxyLl9PcnRSdW49KGwscCxoLEMsVCxVLEcsdWUpPT4oci5fT3J0UnVuPV8ubGEpKGwscCxoLEMsVCxVLEcsdWUpLHIuX09ydEVuZFByb2ZpbGluZz1sPT4oci5fT3J0RW5kUHJvZmlsaW5nPV8ubWEpKGwpLHIuX0pzZXBPdXRwdXQ9KGwscCxoKT0+KHIuX0pzZXBPdXRwdXQ9Xy5uYSkobCxwLGgpLHIuX0pzZXBHZXROb2RlTmFtZT1sPT4oci5fSnNlcEdldE5vZGVOYW1lPV8ub2EpKGwpO3ZhciBSdD1yLl9tYWxsb2M9bD0+KFJ0PXIuX21hbGxvYz1fLnBhKShsKSxVdD1yLl9mcmVlPWw9PihVdD1yLl9mcmVlPV8ucWEpKGwpLEx0PWw9PihMdD1fLnNhKShsKSxGdD0oKT0+KEZ0PV8udGEpKCksSHQ9bD0+KEh0PV8udWEpKGwpLGp0PWw9PihqdD1fLnZhKShsKSxLdD1sPT4oS3Q9Xy54YSkobCkscXQ9KCk9PihxdD1fLnlhKSgpLFB0PWw9PihQdD1fLnphKShsKSwkdD0oKT0+KCR0PV8uQWEpKCk7ci5fX19zdGFydF9lbV9qcz05MjQ1ODcsci5fX19zdG9wX2VtX2pzPTkyNDc0ODtmdW5jdGlvbiBwdChsKXtsPU9iamVjdC5hc3NpZ24oe30sbCk7dmFyIHA9Qz0+KCk9PkMoKT4+PjAsaD1DPT5UPT5DKFQpPj4+MDtyZXR1cm4gbC5fX2Vycm5vX2xvY2F0aW9uPXAobC5fX2Vycm5vX2xvY2F0aW9uKSxsLm1hbGxvYz1oKGwubWFsbG9jKSxsLnN0YWNrU2F2ZT1wKGwuc3RhY2tTYXZlKSxsLnN0YWNrQWxsb2M9aChsLnN0YWNrQWxsb2MpLGx9ci5zdGFja0FsbG9jPWp0LHIuc3RhY2tTYXZlPUZ0LHIuc3RhY2tSZXN0b3JlPUh0LHIuVVRGOFRvU3RyaW5nPV9lLHIuc3RyaW5nVG9VVEY4PShsLHAsaCk9PkR0KGwsbGUscCxoKSxyLmxlbmd0aEJ5dGVzVVRGOD1JdDt2YXIgeHQ7TmU9ZnVuY3Rpb24gbCgpe3h0fHxZdCgpLHh0fHwoTmU9bCl9O2Z1bmN0aW9uIFl0KCl7ZnVuY3Rpb24gbCgpe2lmKCF4dCYmKHh0PSEwLHIuY2FsbGVkUnVuPSEwLCF6KSl7aWYoeXQoU2UpLG8ociksci5vblJ1bnRpbWVJbml0aWFsaXplZCYmci5vblJ1bnRpbWVJbml0aWFsaXplZCgpLHIucG9zdFJ1bilmb3IodHlwZW9mIHIucG9zdFJ1bj09XCJmdW5jdGlvblwiJiYoci5wb3N0UnVuPVtyLnBvc3RSdW5dKTtyLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHA9ci5wb3N0UnVuLnNoaWZ0KCk7T2UudW5zaGlmdChwKX15dChPZSl9fWlmKCEoMDxDZSkpe2lmKHIucHJlUnVuKWZvcih0eXBlb2Ygci5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKHIucHJlUnVuPVtyLnByZVJ1bl0pO3IucHJlUnVuLmxlbmd0aDspSWUoKTt5dChqKSwwPENlfHwoci5zZXRTdGF0dXM/KHIuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3Iuc2V0U3RhdHVzKFwiXCIpfSwxKSxsKCl9LDEpKTpsKCkpfX1pZihyLnByZUluaXQpZm9yKHR5cGVvZiByLnByZUluaXQ9PVwiZnVuY3Rpb25cIiYmKHIucHJlSW5pdD1bci5wcmVJbml0XSk7MDxyLnByZUluaXQubGVuZ3RoOylyLnByZUluaXQucG9wKCkoKTtyZXR1cm4gWXQoKSx0LnJlYWR5fX0pKCk7dHlwZW9mIHNvPT1cIm9iamVjdFwiJiZ0eXBlb2YgZG49PVwib2JqZWN0XCI/ZG4uZXhwb3J0cz1pbzp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQmJmRlZmluZShbXSwoKT0+aW8pfSk7dmFyIGxvPUp0KCgpPT57fSk7dmFyIGNvPUp0KCgpPT57fSk7dmFyIHBvPXt9O0lyKHBvLHtjcHVzOigpPT5PdX0pO3ZhciBPdSxmbz1IKCgpPT57T3U9dm9pZCAwfSk7dmFyIGdvPUp0KChobyxjbik9PntcInVzZSBzdHJpY3RcIjt2YXIgbW89KCgpPT57dmFyIGU9dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMDtyZXR1cm4gdHlwZW9mIF9fZmlsZW5hbWU8XCJ1XCImJihlPWV8fF9fZmlsZW5hbWUpLGZ1bmN0aW9uKHQ9e30pe2Z1bmN0aW9uIHIoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksQ2V9ZnVuY3Rpb24gbygpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxkdH1mdW5jdGlvbiBuKCl7cmV0dXJuIHdlLmJ1ZmZlciE9Q2UuYnVmZmVyJiZwZSgpLE5lfWZ1bmN0aW9uIHMoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksTGV9ZnVuY3Rpb24gdSgpe3JldHVybiB3ZS5idWZmZXIhPUNlLmJ1ZmZlciYmcGUoKSxOfWZ1bmN0aW9uIGQoKXtyZXR1cm4gd2UuYnVmZmVyIT1DZS5idWZmZXImJnBlKCksZGV9dmFyIGE9dCxtLGc7YS5yZWFkeT1uZXcgUHJvbWlzZSgoaSxjKT0+e209aSxnPWN9KSxhLmpzZXBJbml0PShpLGMsZiwkLEksUCxWLG9lKT0+e2EuUWI9aSxhLndiPWMsYS55Yj1mLGEuamI9JCxhLnhiPUksYS5FYT1QLGEuemI9VixhLkFiPW9lLGM9KGVlLFoscmUpPT4oLi4uaGUpPT57bGV0IGJlPVplLE89Wj8uKCk7aGU9ZWUoLi4uaGUpO2xldCBzZT1aPy4oKTtyZXR1cm4gTyE9PXNlJiYoZWU9c2UscmUoTyksWj1yZT1udWxsKSxaZSE9YmU/aHUoKTpoZX0sZj1lZT0+YXN5bmMoLi4uWik9Pnt0cnl7aWYoYS5iYil0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCByZT1hLmJiPXtGYjpaWzBdLGVycm9yczpbXX0saGU9YXdhaXQgZWUoLi4uWik7aWYoYS5iYiE9PXJlKXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTtpLmZsdXNoKCk7bGV0IGJlPXJlLmVycm9ycztpZigwPGJlLmxlbmd0aCl7bGV0IE89YXdhaXQgUHJvbWlzZS5hbGwoYmUpO2lmKE89Ty5maWx0ZXIoc2U9PnNlKSwwPE8ubGVuZ3RoKXRocm93IEVycm9yKE8uam9pbihgXFxuYCkpfXJldHVybiBoZX1maW5hbGx5e2EuYmI9bnVsbH19LGEuX09ydFJ1bj1mKGMoYS5fT3J0UnVuLCgpPT5hLl9PcnRSdW4sZWU9PmEuX09ydFJ1bj1lZSkpLGEuX09ydFJ1bldpdGhCaW5kaW5nPWYoYyhhLl9PcnRSdW5XaXRoQmluZGluZywoKT0+YS5fT3J0UnVuV2l0aEJpbmRpbmcsZWU9PmEuX09ydFJ1bldpdGhCaW5kaW5nPWVlKSksYS5fT3J0QmluZElucHV0PWMoYS5fT3J0QmluZElucHV0LCgpPT5hLl9PcnRCaW5kSW5wdXQsZWU9PmEuX09ydEJpbmRJbnB1dD1lZSksYS5qc2VwUmVnaXN0ZXJCdWZmZXI9KGVlLFoscmUsaGUpPT5pLnJlZ2lzdGVyQnVmZmVyKGVlLFoscmUsaGUpLGEuanNlcFVucmVnaXN0ZXJCdWZmZXJzPWVlPT57aS51bnJlZ2lzdGVyQnVmZmVycyhlZSl9LGEuanNlcEdldEJ1ZmZlcj1lZT0+aS5nZXRCdWZmZXIoZWUpLGEuanNlcENyZWF0ZURvd25sb2FkZXI9KGVlLFoscmUpPT5pLmNyZWF0ZURvd25sb2FkZXIoZWUsWixyZSl9O3ZhciB4PU9iamVjdC5hc3NpZ24oe30sYSksYj1cIi4vdGhpcy5wcm9ncmFtXCIsdz0oaSxjKT0+e3Rocm93IGN9LHY9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIix5PXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsUz10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIsQT1hLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLFI9XCJcIjtmdW5jdGlvbiBXKGkpe3JldHVybiBhLmxvY2F0ZUZpbGU/YS5sb2NhdGVGaWxlKGksUik6UitpfXZhciBNLEQsXztpZihTKXt2YXIgej0oc24oKSxNdChhbikpLEY9KGxuKCksTXQodW4pKTtSPXk/Ri5kaXJuYW1lKFIpK1wiL1wiOl9fZGlybmFtZStcIi9cIixNPShjLGYpPT4oYz1jLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwoYyk6Ri5ub3JtYWxpemUoYyksei5yZWFkRmlsZVN5bmMoYyxmP3ZvaWQgMDpcInV0ZjhcIikpLF89Yz0+KGM9TShjLCEwKSxjLmJ1ZmZlcnx8KGM9bmV3IFVpbnQ4QXJyYXkoYykpLGMpLEQ9KGMsZiwkLEk9ITApPT57Yz1jLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpP25ldyBVUkwoYyk6Ri5ub3JtYWxpemUoYyksei5yZWFkRmlsZShjLEk/dm9pZCAwOlwidXRmOFwiLChQLFYpPT57UD8kKFApOmYoST9WLmJ1ZmZlcjpWKX0pfSwhYS50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoYj1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSx3PShjLGYpPT57dGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1jLGZ9LGEuaW5zcGVjdD0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwiO2xldCBpO3RyeXtpPWxvKCl9Y2F0Y2goYyl7dGhyb3cgY29uc29sZS5lcnJvcihcXCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD9cXCcpLGN9Z2xvYmFsLldvcmtlcj1pLldvcmtlcn1lbHNlKHZ8fHkpJiYoeT9SPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihSPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSx0eXBlb2YgZTxcInVcIiYmZSYmKFI9ZSksUi5pbmRleE9mKFwiYmxvYjpcIikhPT0wP1I9Ui5zdWJzdHIoMCxSLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlI9XCJcIixTfHwoTT1pPT57dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBjLm9wZW4oXCJHRVRcIixpLCExKSxjLnNlbmQobnVsbCksYy5yZXNwb25zZVRleHR9LHkmJihfPWk9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLGksITEpLGMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixjLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoYy5yZXNwb25zZSl9KSxEPShpLGMsZik9Pnt2YXIgJD1uZXcgWE1MSHR0cFJlcXVlc3Q7JC5vcGVuKFwiR0VUXCIsaSwhMCksJC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLCQub25sb2FkPSgpPT57JC5zdGF0dXM9PTIwMHx8JC5zdGF0dXM9PTAmJiQucmVzcG9uc2U/YygkLnJlc3BvbnNlKTpmKCl9LCQub25lcnJvcj1mLCQuc2VuZChudWxsKX0pKTtTJiZ0eXBlb2YgcGVyZm9ybWFuY2U+XCJ1XCImJihnbG9iYWwucGVyZm9ybWFuY2U9Y28oKS5wZXJmb3JtYW5jZSk7dmFyIHE9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxsZT1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7UyYmKHE9KC4uLmkpPT56LndyaXRlU3luYygxLGkuam9pbihcIiBcIikrYFxcbmApLGxlPSguLi5pKT0+ei53cml0ZVN5bmMoMixpLmpvaW4oXCIgXCIpK2BcXG5gKSk7dmFyIEI9YS5wcmludHx8cSxLPWEucHJpbnRFcnJ8fGxlO09iamVjdC5hc3NpZ24oYSx4KSx4PW51bGwsYS50aGlzUHJvZ3JhbSYmKGI9YS50aGlzUHJvZ3JhbSksYS5xdWl0JiYodz1hLnF1aXQpO3ZhciB4ZTthLndhc21CaW5hcnkmJih4ZT1hLndhc21CaW5hcnkpO3ZhciBhZT1hLm5vRXhpdFJ1bnRpbWV8fCEwO3R5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIiYmS2UoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciB3ZSxqLFNlLE9lPSExLEllLENlLGR0LE5lLExlLE4sZGU7ZnVuY3Rpb24gcGUoKXt2YXIgaT13ZS5idWZmZXI7YS5IRUFQOD1DZT1uZXcgSW50OEFycmF5KGkpLGEuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGkpLGEuSEVBUDMyPU5lPW5ldyBJbnQzMkFycmF5KGkpLGEuSEVBUFU4PWR0PW5ldyBVaW50OEFycmF5KGkpLGEuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoaSksYS5IRUFQVTMyPUxlPW5ldyBVaW50MzJBcnJheShpKSxhLkhFQVBGMzI9Tj1uZXcgRmxvYXQzMkFycmF5KGkpLGEuSEVBUEY2ND1kZT1uZXcgRmxvYXQ2NEFycmF5KGkpfXZhciB6ZT1hLklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZig1MjQyODgwPD16ZXx8S2UoXCJJTklUSUFMX01FTU9SWSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gU1RBQ0tfU0laRSwgd2FzIFwiK3plK1wiISAoU1RBQ0tfU0laRT01MjQyODgwKVwiKSxBKXdlPWEud2FzbU1lbW9yeTtlbHNlIGlmKGEud2FzbU1lbW9yeSl3ZT1hLndhc21NZW1vcnk7ZWxzZSBpZih3ZT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOnplLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSksISh3ZS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgSyhcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxTJiZLKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQvb3IgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTtwZSgpLHplPXdlLmJ1ZmZlci5ieXRlTGVuZ3RoO3ZhciBVZT1bXSxUZT1bXSxrZT1bXSxHZT0wO2Z1bmN0aW9uIFhlKCl7cmV0dXJuIGFlfHwwPEdlfXZhciBGZT0wLHl0PW51bGwsYnQ9bnVsbDtmdW5jdGlvbiBCdCgpe0ZlKyssYS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZhLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoRmUpfWZ1bmN0aW9uIGxyKCl7aWYoRmUtLSxhLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhGZSksRmU9PTAmJih5dCE9PW51bGwmJihjbGVhckludGVydmFsKHl0KSx5dD1udWxsKSxidCkpe3ZhciBpPWJ0O2J0PW51bGwsaSgpfX1mdW5jdGlvbiBLZShpKXt0aHJvdyBhLm9uQWJvcnQmJmEub25BYm9ydChpKSxpPVwiQWJvcnRlZChcIitpK1wiKVwiLEsoaSksT2U9ITAsSWU9MSxpPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoaStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksZyhpKSxpfWZ1bmN0aW9uIGt0KGkpe3JldHVybiBpLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfXZhciBfZTtfZT1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiLGt0KF9lKXx8KF9lPVcoX2UpKTtmdW5jdGlvbiBJdChpKXtpZihpPT1fZSYmeGUpcmV0dXJuIG5ldyBVaW50OEFycmF5KHhlKTtpZihfKXJldHVybiBfKGkpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIER0KGkpe2lmKCF4ZSYmKHZ8fHkpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIWkuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKGkse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oYz0+e2lmKCFjLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK2krXCJcXCdcIjtyZXR1cm4gYy5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9Pkl0KGkpKTtpZihEKXJldHVybiBuZXcgUHJvbWlzZSgoYyxmKT0+e0QoaSwkPT5jKG5ldyBVaW50OEFycmF5KCQpKSxmKX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5JdChpKSl9ZnVuY3Rpb24gYXQoaSxjLGYpe3JldHVybiBEdChpKS50aGVuKCQ9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKCQsYykpLnRoZW4oJD0+JCkudGhlbihmLCQ9PntLKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrJCksS2UoJCl9KX1mdW5jdGlvbiBkcihpLGMpe3ZhciBmPV9lO3JldHVybiB4ZXx8dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT1cImZ1bmN0aW9uXCJ8fGt0KGYpfHxmLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxTfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9hdChmLGksYyk6ZmV0Y2goZix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigkPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZygkLGkpLnRoZW4oYyxmdW5jdGlvbihJKXtyZXR1cm4gSyhcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitJKSxLKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksYXQoZixpLGMpfSkpfXZhciBpdCxFdD17OTE0OTg4Omk9PnthLkVhKFwiQWJzXCIsaSx2b2lkIDApfSw5MTUwMzk6aT0+e2EuRWEoXCJOZWdcIixpLHZvaWQgMCl9LDkxNTA5MDppPT57YS5FYShcIkZsb29yXCIsaSx2b2lkIDApfSw5MTUxNDM6aT0+e2EuRWEoXCJDZWlsXCIsaSx2b2lkIDApfSw5MTUxOTU6aT0+e2EuRWEoXCJSZWNpcHJvY2FsXCIsaSx2b2lkIDApfSw5MTUyNTM6aT0+e2EuRWEoXCJTcXJ0XCIsaSx2b2lkIDApfSw5MTUzMDU6aT0+e2EuRWEoXCJFeHBcIixpLHZvaWQgMCl9LDkxNTM1NjppPT57YS5FYShcIkVyZlwiLGksdm9pZCAwKX0sOTE1NDA3Omk9PnthLkVhKFwiU2lnbW9pZFwiLGksdm9pZCAwKX0sOTE1NDYyOmk9PnthLkVhKFwiTG9nXCIsaSx2b2lkIDApfSw5MTU1MTM6aT0+e2EuRWEoXCJTaW5cIixpLHZvaWQgMCl9LDkxNTU2NDppPT57YS5FYShcIkNvc1wiLGksdm9pZCAwKX0sOTE1NjE1Omk9PnthLkVhKFwiVGFuXCIsaSx2b2lkIDApfSw5MTU2NjY6aT0+e2EuRWEoXCJBc2luXCIsaSx2b2lkIDApfSw5MTU3MTg6aT0+e2EuRWEoXCJBY29zXCIsaSx2b2lkIDApfSw5MTU3NzA6aT0+e2EuRWEoXCJBdGFuXCIsaSx2b2lkIDApfSw5MTU4MjI6aT0+e2EuRWEoXCJTaW5oXCIsaSx2b2lkIDApfSw5MTU4NzQ6aT0+e2EuRWEoXCJDb3NoXCIsaSx2b2lkIDApfSw5MTU5MjY6aT0+e2EuRWEoXCJBc2luaFwiLGksdm9pZCAwKX0sOTE1OTc5Omk9PnthLkVhKFwiQWNvc2hcIixpLHZvaWQgMCl9LDkxNjAzMjppPT57YS5FYShcIkF0YW5oXCIsaSx2b2lkIDApfSw5MTYwODU6aT0+e2EuRWEoXCJUYW5oXCIsaSx2b2lkIDApfSw5MTYxMzc6aT0+e2EuRWEoXCJOb3RcIixpLHZvaWQgMCl9LDkxNjE4ODooaSxjLGYpPT57YS5FYShcIkNsaXBWMTBcIixpLHttaW46YyxtYXg6Zn0pfSw5MTYyNjA6aT0+e2EuRWEoXCJDbGlwXCIsaSx2b2lkIDApfSw5MTYzMTI6KGksYyk9PnthLkVhKFwiRWx1XCIsaSx7YWxwaGE6Y30pfSw5MTYzNzA6aT0+e2EuRWEoXCJSZWx1XCIsaSx2b2lkIDApfSw5MTY0MjI6KGksYyk9PnthLkVhKFwiTGVha3lSZWx1XCIsaSx7YWxwaGE6Y30pfSw5MTY0ODY6KGksYyk9PnthLkVhKFwiVGhyZXNob2xkZWRSZWx1XCIsaSx7YWxwaGE6Y30pfSw5MTY1NTY6KGksYyk9PnthLkVhKFwiQ2FzdFwiLGkse3RvOmN9KX0sOTE2NjE0Omk9PnthLkVhKFwiQWRkXCIsaSx2b2lkIDApfSw5MTY2NjU6aT0+e2EuRWEoXCJTdWJcIixpLHZvaWQgMCl9LDkxNjcxNjppPT57YS5FYShcIk11bFwiLGksdm9pZCAwKX0sOTE2NzY3Omk9PnthLkVhKFwiRGl2XCIsaSx2b2lkIDApfSw5MTY4MTg6aT0+e2EuRWEoXCJQb3dcIixpLHZvaWQgMCl9LDkxNjg2OTppPT57YS5FYShcIkVxdWFsXCIsaSx2b2lkIDApfSw5MTY5MjI6aT0+e2EuRWEoXCJHcmVhdGVyXCIsaSx2b2lkIDApfSw5MTY5Nzc6aT0+e2EuRWEoXCJHcmVhdGVyT3JFcXVhbFwiLGksdm9pZCAwKX0sOTE3MDM5Omk9PnthLkVhKFwiTGVzc1wiLGksdm9pZCAwKX0sOTE3MDkxOmk9PnthLkVhKFwiTGVzc09yRXF1YWxcIixpLHZvaWQgMCl9LDkxNzE1MDooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VNZWFuXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxNzMxNDooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VNYXhcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE3NDc3OihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZU1pblwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTc2NDA6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlUHJvZFwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTc4MDQ6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlU3VtXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxNzk2NzooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VMMVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTgxMjk6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlTDJcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE4MjkxOihpLGMsZiwkLEkpPT57YS5FYShcIlJlZHVjZUxvZ1N1bVwiLGkse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczokP0FycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrJD4+PjApKTpbXX0pfSw5MTg0NTc6KGksYyxmLCQsSSk9PnthLkVhKFwiUmVkdWNlU3VtU3F1YXJlXCIsaSx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkxODYyNjooaSxjLGYsJCxJKT0+e2EuRWEoXCJSZWR1Y2VMb2dTdW1FeHBcIixpLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTE4Nzk1Omk9PnthLkVhKFwiV2hlcmVcIixpLHZvaWQgMCl9LDkxODg0ODooaSxjLGYpPT57YS5FYShcIlRyYW5zcG9zZVwiLGkse3Blcm06Yz9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShmPj4+MCxmK2M+Pj4wKSk6W119KX0sOTE4OTYxOihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyxzZSk9PnthLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDplZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltmXSxncm91cDokLGtlcm5lbF9zaGFwZTpbSV0scGFkczpbUCxWXSxzdHJpZGVzOltvZV0sd0lzQ29uc3Q6KCk9PiEhcigpW1o+Pj4wXSxvdXRwdXRQYWRkaW5nOnJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGhlPj4+MCxoZStyZT4+PjApKTpbXSxvdXRwdXRTaGFwZTpiZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShPPj4+MCxPK2JlPj4+MCkpOltdLGFjdGl2YXRpb246VmUoc2UpfSl9LDkxOTM3NTooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8pPT57YS5FYShcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6b2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShmPj4+MCxmKzI+Pj4wKSksZ3JvdXA6JCxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShQPj4+MCxQKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKG4oKS5zdWJhcnJheShWPj4+MCxWKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcigpW2VlPj4+MF0sb3V0cHV0UGFkZGluZzowPFo/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkocmU+Pj4wLHJlK1o+Pj4wKSk6W10sb3V0cHV0U2hhcGU6MDxoZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShiZT4+PjAsYmUraGU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShPKX0pfSw5MTk5MzI6KGksYyxmLCQsSSxQLFYsb2UsZWUsWixyZSxoZSxiZSxPLHNlKT0+e2EuRWEoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OmVlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6W2ZdLGdyb3VwOiQsa2VybmVsX3NoYXBlOltJXSxwYWRzOltQLFZdLHN0cmlkZXM6W29lXSx3SXNDb25zdDooKT0+ISFyKClbWj4+PjBdLG91dHB1dFBhZGRpbmc6cmU/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoaGU+Pj4wLGhlK3JlPj4+MCkpOltdLG91dHB1dFNoYXBlOmJlP0FycmF5LmZyb20obigpLnN1YmFycmF5KE8+Pj4wLE8rYmU+Pj4wKSk6W10sYWN0aXZhdGlvbjpWZShzZSl9KX0sOTIwMzQ2OihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyk9PnthLkVhKFwiQ29udlRyYW5zcG9zZVwiLGkse2Zvcm1hdDpvZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20obigpLnN1YmFycmF5KGY+Pj4wLGYrMj4+PjApKSxncm91cDokLGtlcm5lbFNoYXBlOkFycmF5LmZyb20obigpLnN1YmFycmF5KEk+Pj4wLEkrMj4+PjApKSxwYWRzOkFycmF5LmZyb20obigpLnN1YmFycmF5KFA+Pj4wLFArND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20obigpLnN1YmFycmF5KFY+Pj4wLFYrMj4+PjApKSx3SXNDb25zdDooKT0+ISFyKClbZWU+Pj4wXSxvdXRwdXRQYWRkaW5nOjA8Wj9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShyZT4+PjAscmUrWj4+PjApKTpbXSxvdXRwdXRTaGFwZTowPGhlP0FycmF5LmZyb20obigpLnN1YmFycmF5KGJlPj4+MCxiZStoZT4+PjApKTpbXSxhY3RpdmF0aW9uOlZlKE8pfSl9LDkyMDkwMzooaSxjKT0+e2EuRWEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMDk5NDooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8sc2UseWUpPT57YS5FYShcIkF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6JCxzdG9yYWdlX29yZGVyOkksZGlsYXRpb25zOltQLFZdLGtlcm5lbF9zaGFwZTpbb2UsZWVdLHBhZHM6W1oscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMTI3ODooaSxjKT0+e2EuRWEoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMTM2OTooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8sc2UseWUpPT57YS5FYShcIkF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OnllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6JCxzdG9yYWdlX29yZGVyOkksZGlsYXRpb25zOltQLFZdLGtlcm5lbF9zaGFwZTpbb2UsZWVdLHBhZHM6W1oscmUsaGUsYmVdLHN0cmlkZXM6W08sc2VdfSl9LDkyMTY1MzooaSxjKT0+e2EuRWEoXCJHbG9iYWxNYXhQb29sXCIsaSx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIxNzQwOihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUsTyxzZSx5ZSk9PnthLkVhKFwiTWF4UG9vbFwiLGkse2Zvcm1hdDp5ZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOiQsc3RvcmFnZV9vcmRlcjpJLGRpbGF0aW9uczpbUCxWXSxrZXJuZWxfc2hhcGU6W29lLGVlXSxwYWRzOltaLHJlLGhlLGJlXSxzdHJpZGVzOltPLHNlXX0pfSw5MjIwMjA6KGksYyk9PnthLkVhKFwiR2xvYmFsTWF4UG9vbFwiLGkse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMjEwNzooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8sc2UseWUpPT57YS5FYShcIk1heFBvb2xcIixpLHtmb3JtYXQ6eWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDokLHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W1AsVl0sa2VybmVsX3NoYXBlOltvZSxlZV0scGFkczpbWixyZSxoZSxiZV0sc3RyaWRlczpbTyxzZV19KX0sOTIyMzg3OihpLGMsZiwkLEkpPT57YS5FYShcIkdlbW1cIixpLHthbHBoYTpjLGJldGE6Zix0cmFuc0E6JCx0cmFuc0I6SX0pfSw5MjI0OTE6aT0+e2EuRWEoXCJNYXRNdWxcIixpLHZvaWQgMCl9LDkyMjU0NTooaSxjLGYsJCk9PnthLkVhKFwiQXJnTWF4XCIsaSx7a2VlcERpbXM6ISFjLHNlbGVjdExhc3RJbmRleDohIWYsYXhpczokfSl9LDkyMjY1MzooaSxjLGYsJCk9PnthLkVhKFwiQXJnTWluXCIsaSx7a2VlcERpbXM6ISFjLHNlbGVjdExhc3RJbmRleDohIWYsYXhpczokfSl9LDkyMjc2MTooaSxjKT0+e2EuRWEoXCJTb2Z0bWF4XCIsaSx7YXhpczpjfSl9LDkyMjgyNDooaSxjKT0+e2EuRWEoXCJDb25jYXRcIixpLHtheGlzOmN9KX0sOTIyODg0OihpLGMsZiwkLEkpPT57YS5FYShcIlNwbGl0XCIsaSx7YXhpczpjLG51bU91dHB1dHM6ZixzcGxpdFNpemVzOiQ/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoST4+PjAsSSskPj4+MCkpOltdfSl9LDkyMzAyOTppPT57YS5FYShcIkV4cGFuZFwiLGksdm9pZCAwKX0sOTIzMDgzOihpLGMpPT57YS5FYShcIkdhdGhlclwiLGkse2F4aXM6TnVtYmVyKGMpfSl9LDkyMzE1NDooaSxjKT0+e2EuRWEoXCJHYXRoZXJFbGVtZW50c1wiLGkse2F4aXM6TnVtYmVyKGMpfSl9LDkyMzIzMzooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlKT0+e2EuRWEoXCJSZXNpemVcIixpLHthbnRpYWxpYXM6YyxheGVzOmY/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoJD4+PjAsJCtmPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOlZlKEkpLGN1YmljQ29lZmZBOlAsZXhjbHVkZU91dHNpZGU6VixleHRyYXBvbGF0aW9uVmFsdWU6b2Usa2VlcEFzcGVjdFJhdGlvUG9saWN5OlZlKGVlKSxtb2RlOlZlKFopLG5lYXJlc3RNb2RlOlZlKHJlKX0pfSw5MjM1ODQ6KGksYyxmLCQsSSxQLFYpPT57YS5FYShcIlNsaWNlXCIsaSx7c3RhcnRzOmM/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoZj4+PjAsZitjPj4+MCkpOltdLGVuZHM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W10sYXhlczpQP0FycmF5LmZyb20obigpLnN1YmFycmF5KFY+Pj4wLFYrUD4+PjApKTpbXX0pfSw5MjM4MTU6aT0+e2EuRWEoXCJUaWxlXCIsaSx2b2lkIDApfSw5MjM4Njc6KGksYyxmKT0+e2EuRWEoXCJMYXllck5vcm1hbGl6YXRpb25cIixpLHtheGlzOk51bWJlcihjKSxlcHNpbG9uOk51bWJlcihmKX0pfSw5MjM5NzQ6KGksYyxmKT0+e2EuRWEoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOmMsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI0MDg4OihpLGMsZik9PnthLkVhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjpjLGZvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNDIwMjppPT57YS5FYShcIlJhbmdlXCIsaSx2b2lkIDApfSw5MjQyNTU6KGksYyk9PnthLkVhKFwiRWluc3VtXCIsaSx7ZXF1YXRpb246VmUoYyl9KX0sOTI0MzM2OihpLGMsZiwkLEkpPT57YS5FYShcIlBhZFwiLGkse21vZGU6Yyx2YWx1ZTpmLHBhZHM6JD9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShJPj4+MCxJKyQ+Pj4wKSk6W119KX0sOTI0NDY4Omk9PnthLkVhKFwiR2VsdVwiLGksdm9pZCAwKX0sOTI0NTIwOmk9PnthLkVhKFwiQmlhc0FkZFwiLGksdm9pZCAwKX0sOTI0NTc1Omk9PnthLkVhKFwiQmlhc1NwbGl0R2VsdVwiLGksdm9pZCAwKX0sOTI0NjM2OihpLGMpPT57YS5FYShcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOmN9KX0sOTI0NzE3OihpLGMsZiwkLEksUCxWLG9lLGVlLFoscmUsaGUsYmUpPT57YS5FYShcIkNvbnZcIixpLHtmb3JtYXQ6ZWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6W2ZdLGdyb3VwOiQsa2VybmVsX3NoYXBlOltJXSxwYWRzOlA/QXJyYXkuZnJvbShuKCkuc3ViYXJyYXkoVj4+PjAsVitQPj4+MCkpOltdLHN0cmlkZXM6W29lXSx3X2lzX2NvbnN0OigpPT4hIXIoKVtaPj4+MF0sYWN0aXZhdGlvbjpWZShyZSksYWN0aXZhdGlvbl9wYXJhbXM6aGU/QXJyYXkuZnJvbSh1KCkuc3ViYXJyYXkoYmU+Pj4wLGJlK2hlPj4+MCkpOltdfSl9LDkyNTA5ODooaSxjLGYsJCxJLFAsVixvZSxlZSxaLHJlLGhlLGJlLE8sc2UseWUpPT57YS5FYShcIkNvbnZcIixpLHtmb3JtYXQ6aGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6W2YsJF0sZ3JvdXA6SSxrZXJuZWxfc2hhcGU6W1AsVl0scGFkczpvZT9BcnJheS5mcm9tKG4oKS5zdWJhcnJheShlZT4+PjAsZWUrb2U+Pj4wKSk6W10sc3RyaWRlczpbWixyZV0sd19pc19jb25zdDooKT0+ISFyKClbYmU+Pj4wXSxhY3RpdmF0aW9uOlZlKE8pLGFjdGl2YXRpb25fcGFyYW1zOnNlP0FycmF5LmZyb20odSgpLnN1YmFycmF5KHllPj4+MCx5ZStzZT4+PjApKTpbXX0pfSw5MjU1MDA6aT0+e2EuemIoaSl9LDkyNTUzNDooaSxjKT0+YS5BYihpLGMsYS5iYi5GYixhLmJiLmVycm9ycyksOTI1NjQ2Omk9PmEud2IoaSksOTI1Njc5Omk9PmEueWIoaSksOTI1NzExOihpLGMsZik9PnthLmpiKGksYyxmLCEwKX0sOTI1NzUwOihpLGMsZik9PnthLmpiKGksYyxmKX19O2Z1bmN0aW9uIGN0KGkpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtpfSlgLHRoaXMuc3RhdHVzPWl9ZnVuY3Rpb24gVHQoaSl7aS50ZXJtaW5hdGUoKSxpLm9ubWVzc2FnZT0oKT0+e319ZnVuY3Rpb24gT3QoaSl7KGk9bmUuUWFbaV0pfHxLZSgpLG5lLkViKGkpfWZ1bmN0aW9uIFd0KGkpe3ZhciBjPW5lLnRiKCk7aWYoIWMpcmV0dXJuIDY7bmUuWWEucHVzaChjKSxuZS5RYVtpLlhhXT1jLGMuWGE9aS5YYTt2YXIgZj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTppLkdiLGFyZzppLnJiLHB0aHJlYWRfcHRyOmkuWGF9O3JldHVybiBTJiZjLnVucmVmKCksYy5wb3N0TWVzc2FnZShmLGkuTWIpLDB9dmFyIF90PXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxjcj0oaSxjLGYpPT57Yz4+Pj0wO3ZhciAkPWMrZjtmb3IoZj1jO2lbZl0mJiEoZj49JCk7KSsrZjtpZigxNjxmLWMmJmkuYnVmZmVyJiZfdClyZXR1cm4gX3QuZGVjb2RlKGkuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/aS5zbGljZShjLGYpOmkuc3ViYXJyYXkoYyxmKSk7Zm9yKCQ9XCJcIjtjPGY7KXt2YXIgST1pW2MrK107aWYoSSYxMjgpe3ZhciBQPWlbYysrXSY2MztpZigoSSYyMjQpPT0xOTIpJCs9U3RyaW5nLmZyb21DaGFyQ29kZSgoSSYzMSk8PDZ8UCk7ZWxzZXt2YXIgVj1pW2MrK10mNjM7ST0oSSYyNDApPT0yMjQ/KEkmMTUpPDwxMnxQPDw2fFY6KEkmNyk8PDE4fFA8PDEyfFY8PDZ8aVtjKytdJjYzLDY1NTM2Pkk/JCs9U3RyaW5nLmZyb21DaGFyQ29kZShJKTooSS09NjU1MzYsJCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxJPj4xMCw1NjMyMHxJJjEwMjMpKX19ZWxzZSAkKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEkpfXJldHVybiAkfSxWZT0oaSxjKT0+KGk+Pj49MCk/Y3IobygpLGksYyk6XCJcIjtmdW5jdGlvbiB6dChpKXtpZihBKXJldHVybiBHKDEsMSxpKTtJZT1pLFhlKCl8fChuZS5IYigpLGEub25FeGl0JiZhLm9uRXhpdChpKSxPZT0hMCksdyhpLG5ldyBjdChpKSl9dmFyIFZ0PWk9PntpZihJZT1pLEEpdGhyb3cgcHIoaSksXCJ1bndpbmRcIjt6dChpKX0sbmU9e2FiOltdLFlhOltdLG1iOltdLFFhOnt9LGdiOmZ1bmN0aW9uKCl7QT9uZS52YigpOm5lLnViKCl9LHViOmZ1bmN0aW9uKCl7VWUudW5zaGlmdCgoKT0+e0J0KCksbmUuQmIoKCk9PmxyKCkpfSl9LHZiOmZ1bmN0aW9uKCl7bmUucmVjZWl2ZU9iamVjdFRyYW5zZmVyPW5lLkRiLG5lLnRocmVhZEluaXRUTFM9bmUubGIsbmUuc2V0RXhpdFN0YXR1cz1uZS5rYixhZT0hMX0sa2I6ZnVuY3Rpb24oaSl7SWU9aX0sU2I6W1wiJHRlcm1pbmF0ZVdvcmtlclwiXSxIYjpmdW5jdGlvbigpe2Zvcih2YXIgaSBvZiBuZS5ZYSlUdChpKTtmb3IoaSBvZiBuZS5hYilUdChpKTtuZS5hYj1bXSxuZS5ZYT1bXSxuZS5RYT1bXX0sRWI6ZnVuY3Rpb24oaSl7dmFyIGM9aS5YYTtkZWxldGUgbmUuUWFbY10sbmUuYWIucHVzaChpKSxuZS5ZYS5zcGxpY2UobmUuWWEuaW5kZXhPZihpKSwxKSxpLlhhPTAsZW4oYyl9LERiOmZ1bmN0aW9uKCl7fSxsYjpmdW5jdGlvbigpe25lLm1iLmZvckVhY2goaT0+aSgpKX0sQ2I6aT0+bmV3IFByb21pc2UoYz0+e2kub25tZXNzYWdlPVA9PntQPVAuZGF0YTt2YXIgVj1QLmNtZDtpZihQLnRhcmdldFRocmVhZCYmUC50YXJnZXRUaHJlYWQhPVNyKCkpe3ZhciBvZT1uZS5RYVtQLlJiXTtvZT9vZS5wb3N0TWVzc2FnZShQLFAudHJhbnNmZXJMaXN0KTpLKFxcJ0ludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCJcXCcrVitcXCdcIiB0byB0YXJnZXQgcHRocmVhZCBcXCcrUC50YXJnZXRUaHJlYWQrXCIsIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIVwiKX1lbHNlIFY9PT1cImNoZWNrTWFpbGJveFwiPyR0KCk6Vj09PVwic3Bhd25UaHJlYWRcIj9XdChQKTpWPT09XCJjbGVhbnVwVGhyZWFkXCI/T3QoUC50aHJlYWQpOlY9PT1cImtpbGxUaHJlYWRcIj8oUD1QLnRocmVhZCxWPW5lLlFhW1BdLGRlbGV0ZSBuZS5RYVtQXSxUdChWKSxlbihQKSxuZS5ZYS5zcGxpY2UobmUuWWEuaW5kZXhPZihWKSwxKSxWLlhhPTApOlY9PT1cImNhbmNlbFRocmVhZFwiP25lLlFhW1AudGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpWPT09XCJsb2FkZWRcIj8oaS5sb2FkZWQ9ITAsYyhpKSk6Vj09PVwiYWxlcnRcIj9hbGVydChcIlRocmVhZCBcIitQLnRocmVhZElkK1wiOiBcIitQLnRleHQpOlAudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIj9pLnBvc3RNZXNzYWdlKFApOlY9PT1cImNhbGxIYW5kbGVyXCI/YVtQLmhhbmRsZXJdKC4uLlAuYXJncyk6ViYmSyhcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIitWKX0saS5vbmVycm9yPVA9Pnt0aHJvdyBLKFwid29ya2VyIHNlbnQgYW4gZXJyb3IhIFwiK1AuZmlsZW5hbWUrXCI6XCIrUC5saW5lbm8rXCI6IFwiK1AubWVzc2FnZSksUH0sUyYmKGkub24oXCJtZXNzYWdlXCIsZnVuY3Rpb24oUCl7aS5vbm1lc3NhZ2Uoe2RhdGE6UH0pfSksaS5vbihcImVycm9yXCIsZnVuY3Rpb24oUCl7aS5vbmVycm9yKFApfSkpO3ZhciBmPVtdLCQ9W1wib25FeGl0XCIsXCJvbkFib3J0XCIsXCJwcmludFwiLFwicHJpbnRFcnJcIl0sSTtmb3IoSSBvZiAkKWEuaGFzT3duUHJvcGVydHkoSSkmJmYucHVzaChJKTtpLnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsaGFuZGxlcnM6Zix1cmxPckJsb2I6YS5tYWluU2NyaXB0VXJsT3JCbG9ifHxlLHdhc21NZW1vcnk6d2Usd2FzbU1vZHVsZTpTZX0pfSksQmI6ZnVuY3Rpb24oaSl7aSgpfSxxYjpmdW5jdGlvbigpe3ZhciBpPVcoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndvcmtlci5qc1wiKTtpPW5ldyBXb3JrZXIoaSksbmUuYWIucHVzaChpKX0sdGI6ZnVuY3Rpb24oKXtyZXR1cm4gbmUuYWIubGVuZ3RoPT0wJiYobmUucWIoKSxuZS5DYihuZS5hYlswXSkpLG5lLmFiLnBvcCgpfX07YS5QVGhyZWFkPW5lO3ZhciBzdD1pPT57Zm9yKDswPGkubGVuZ3RoOylpLnNoaWZ0KCkoYSl9O2EuZXN0YWJsaXNoU3RhY2tTcGFjZT1mdW5jdGlvbigpe3ZhciBpPVNyKCksYz1uKClbaSs1Mj4+Mj4+PjBdO2k9bigpW2krNTY+PjI+Pj4wXSxabihjLGMtaSksQ3IoYyl9O2Z1bmN0aW9uIHByKGkpe2lmKEEpcmV0dXJuIEcoMiwwLGkpO1Z0KGkpfWEuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbihpLGMpe2k9UW4uYXBwbHkobnVsbCxbaSxjXSksWGUoKT9uZS5rYihpKTp0bihpKX07ZnVuY3Rpb24gSmUoaSl7dGhpcy5mYj1pLTI0LHRoaXMucGI9ZnVuY3Rpb24oYyl7cygpW3RoaXMuZmIrND4+Mj4+PjBdPWN9LHRoaXMub2I9ZnVuY3Rpb24oYyl7cygpW3RoaXMuZmIrOD4+Mj4+PjBdPWN9LHRoaXMuZ2I9ZnVuY3Rpb24oYyxmKXt0aGlzLm5iKCksdGhpcy5wYihjKSx0aGlzLm9iKGYpfSx0aGlzLm5iPWZ1bmN0aW9uKCl7cygpW3RoaXMuZmIrMTY+PjI+Pj4wXT0wfX12YXIgSGU9MCxmcj0wO2Z1bmN0aW9uIHd0KGksYyxmLCQpe3JldHVybiBBP0coMywxLGksYyxmLCQpOkd0KGksYyxmLCQpfWZ1bmN0aW9uIEd0KGksYyxmLCQpe2lmKGk+Pj49MCxjPj4+PTAsZj4+Pj0wLCQ+Pj49MCx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuIEsoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBJPVtdO3JldHVybiBBJiZJLmxlbmd0aD09PTA/d3QoaSxjLGYsJCk6KGk9e0diOmYsWGE6aSxyYjokLE1iOkl9LEE/KGkuT2I9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKGksSSksMCk6V3QoaSkpfWZ1bmN0aW9uIE50KGksYyxmKXtyZXR1cm4gQT9HKDQsMSxpLGMsZik6MH1mdW5jdGlvbiBtcihpLGMpe2lmKEEpcmV0dXJuIEcoNSwxLGksYyl9dmFyIHZ0PWk9Pntmb3IodmFyIGM9MCxmPTA7ZjxpLmxlbmd0aDsrK2Ype3ZhciAkPWkuY2hhckNvZGVBdChmKTsxMjc+PSQ/YysrOjIwNDc+PSQ/Yys9Mjo1NTI5Njw9JCYmNTczNDM+PSQ/KGMrPTQsKytmKTpjKz0zfXJldHVybiBjfSxocj0oaSxjLGYsJCk9PntpZihmPj4+PTAsISgwPCQpKXJldHVybiAwO3ZhciBJPWY7JD1mKyQtMTtmb3IodmFyIFA9MDtQPGkubGVuZ3RoOysrUCl7dmFyIFY9aS5jaGFyQ29kZUF0KFApO2lmKDU1Mjk2PD1WJiY1NzM0Mz49Vil7dmFyIG9lPWkuY2hhckNvZGVBdCgrK1ApO1Y9NjU1MzYrKChWJjEwMjMpPDwxMCl8b2UmMTAyM31pZigxMjc+PVYpe2lmKGY+PSQpYnJlYWs7Y1tmKys+Pj4wXT1WfWVsc2V7aWYoMjA0Nz49Vil7aWYoZisxPj0kKWJyZWFrO2NbZisrPj4+MF09MTkyfFY+PjZ9ZWxzZXtpZig2NTUzNT49Vil7aWYoZisyPj0kKWJyZWFrO2NbZisrPj4+MF09MjI0fFY+PjEyfWVsc2V7aWYoZiszPj0kKWJyZWFrO2NbZisrPj4+MF09MjQwfFY+PjE4LGNbZisrPj4+MF09MTI4fFY+PjEyJjYzfWNbZisrPj4+MF09MTI4fFY+PjYmNjN9Y1tmKys+Pj4wXT0xMjh8ViY2M319cmV0dXJuIGNbZj4+PjBdPTAsZi1JfSxncj0oaSxjLGYpPT5ocihpLG8oKSxjLGYpO2Z1bmN0aW9uIHlyKGksYyl7aWYoQSlyZXR1cm4gRyg2LDEsaSxjKX1mdW5jdGlvbiBicihpLGMsZil7aWYoQSlyZXR1cm4gRyg3LDEsaSxjLGYpfWZ1bmN0aW9uIHdyKGksYyxmKXtyZXR1cm4gQT9HKDgsMSxpLGMsZik6MH1mdW5jdGlvbiB2cihpLGMpe2lmKEEpcmV0dXJuIEcoOSwxLGksYyl9ZnVuY3Rpb24gUnQoaSxjLGYpe2lmKEEpcmV0dXJuIEcoMTAsMSxpLGMsZil9ZnVuY3Rpb24gVXQoaSxjLGYsJCl7aWYoQSlyZXR1cm4gRygxMSwxLGksYyxmLCQpfWZ1bmN0aW9uIEx0KGksYyxmLCQpe2lmKEEpcmV0dXJuIEcoMTIsMSxpLGMsZiwkKX1mdW5jdGlvbiBGdChpLGMsZiwkKXtpZihBKXJldHVybiBHKDEzLDEsaSxjLGYsJCl9ZnVuY3Rpb24gSHQoaSl7aWYoQSlyZXR1cm4gRygxNCwxLGkpfWZ1bmN0aW9uIGp0KGksYyl7aWYoQSlyZXR1cm4gRygxNSwxLGksYyl9ZnVuY3Rpb24gS3QoaSxjLGYpe2lmKEEpcmV0dXJuIEcoMTYsMSxpLGMsZil9dmFyIHF0PWk9PntpZighT2UpdHJ5e2lmKGkoKSwhWGUoKSl0cnl7QT90bihJZSk6VnQoSWUpfWNhdGNoKGMpe2MgaW5zdGFuY2VvZiBjdHx8Yz09XCJ1bndpbmRcInx8dygxLGMpfX1jYXRjaChjKXtjIGluc3RhbmNlb2YgY3R8fGM9PVwidW53aW5kXCJ8fHcoMSxjKX19O2Z1bmN0aW9uIFB0KGkpe2k+Pj49MCx0eXBlb2YgQXRvbWljcy5OYj09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5OYihuKCksaT4+MixpKS52YWx1ZS50aGVuKCR0KSxpKz0xMjgsQXRvbWljcy5zdG9yZShuKCksaT4+MiwxKSl9YS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQ9UHQ7ZnVuY3Rpb24gJHQoKXt2YXIgaT1TcigpO2kmJihQdChpKSxxdCgoKT0+WG4oKSkpfWEuY2hlY2tNYWlsYm94PSR0O3ZhciBwdD1pPT5pJTQ9PT0wJiYoaSUxMDAhPT0wfHxpJTQwMD09PTApLHh0PVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLFl0PVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO2Z1bmN0aW9uIGwoaSxjLGYsJCxJLFAsVixvZSl7cmV0dXJuIEE/RygxNywxLGksYyxmLCQsSSxQLFYsb2UpOi01Mn1mdW5jdGlvbiBwKGksYyxmLCQsSSxQLFYpe2lmKEEpcmV0dXJuIEcoMTgsMSxpLGMsZiwkLEksUCxWKX12YXIgaD1pPT57dmFyIGM9dnQoaSkrMSxmPVFyKGMpO3JldHVybiBmJiZncihpLGYsYyksZn0sQz1bXSxUPShpLGMpPT57Qy5sZW5ndGg9MDt2YXIgZjtmb3IoYz4+PTI7Zj1vKClbaSsrPj4+MF07KWMrPWYhPTEwNSZjLEMucHVzaChmPT0xMDU/bigpW2M+Pj4wXTpkKClbYysrPj4+MV0pLCsrYztyZXR1cm4gQ30sVT1pPT57dmFyIGM9cm4oKTtyZXR1cm4gaT1pKCksQ3IoYyksaX07ZnVuY3Rpb24gRyhpLGMpe3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMiwkPWFyZ3VtZW50cztyZXR1cm4gVSgoKT0+e2Zvcih2YXIgST1ubig4KmYpLFA9ST4+MyxWPTA7VjxmO1YrKyl7dmFyIG9lPSRbMitWXTtkKClbUCtWPj4+MF09b2V9cmV0dXJuIFluKGksZixJLGMpfSl9dmFyIHVlPVtdLFk9e30sUT0oKT0+e2lmKCFKKXt2YXIgaT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpifHxcIi4vdGhpcy5wcm9ncmFtXCJ9LGM7Zm9yKGMgaW4gWSlZW2NdPT09dm9pZCAwP2RlbGV0ZSBpW2NdOmlbY109WVtjXTt2YXIgZj1bXTtmb3IoYyBpbiBpKWYucHVzaChgJHtjfT0ke2lbY119YCk7Sj1mfXJldHVybiBKfSxKO2Z1bmN0aW9uIGNlKGksYyl7aWYoQSlyZXR1cm4gRygxOSwxLGksYyk7aT4+Pj0wLGM+Pj49MDt2YXIgZj0wO3JldHVybiBRKCkuZm9yRWFjaChmdW5jdGlvbigkLEkpe3ZhciBQPWMrZjtmb3IoST1zKClbaSs0Kkk+PjI+Pj4wXT1QLFA9MDtQPCQubGVuZ3RoOysrUClyKClbSSsrPj4wPj4+MF09JC5jaGFyQ29kZUF0KFApO3IoKVtJPj4wPj4+MF09MCxmKz0kLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBtZShpLGMpe2lmKEEpcmV0dXJuIEcoMjAsMSxpLGMpO2k+Pj49MCxjPj4+PTA7dmFyIGY9USgpO3MoKVtpPj4yPj4+MF09Zi5sZW5ndGg7dmFyICQ9MDtyZXR1cm4gZi5mb3JFYWNoKGZ1bmN0aW9uKEkpeyQrPUkubGVuZ3RoKzF9KSxzKClbYz4+Mj4+PjBdPSQsMH1mdW5jdGlvbiBFKGkpe3JldHVybiBBP0coMjEsMSxpKTo1Mn1mdW5jdGlvbiB0ZShpLGMsZiwkKXtyZXR1cm4gQT9HKDIyLDEsaSxjLGYsJCk6NTJ9ZnVuY3Rpb24gZmUoaSxjLGYsJCxJKXtyZXR1cm4gQT9HKDIzLDEsaSxjLGYsJCxJKTo3MH12YXIgdXQ9W251bGwsW10sW11dO2Z1bmN0aW9uIFh0KGksYyxmLCQpe2lmKEEpcmV0dXJuIEcoMjQsMSxpLGMsZiwkKTtjPj4+PTAsZj4+Pj0wLCQ+Pj49MDtmb3IodmFyIEk9MCxQPTA7UDxmO1ArKyl7dmFyIFY9cygpW2M+PjI+Pj4wXSxvZT1zKClbYys0Pj4yPj4+MF07Yys9ODtmb3IodmFyIGVlPTA7ZWU8b2U7ZWUrKyl7dmFyIFo9bygpW1YrZWU+Pj4wXSxyZT11dFtpXTtaPT09MHx8Wj09PTEwPygoaT09PTE/QjpLKShjcihyZSwwKSkscmUubGVuZ3RoPTApOnJlLnB1c2goWil9SSs9b2V9cmV0dXJuIHMoKVskPj4yPj4+MF09SSwwfXZhciBObj1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLFVuPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gZHUoaSl7dmFyIGM9QXJyYXkodnQoaSkrMSk7cmV0dXJuIGhyKGksYywwLGMubGVuZ3RoKSxjfXZhciBjdT0oaSxjKT0+e3IoKS5zZXQoaSxjPj4+MCl9O2Z1bmN0aW9uIExuKGksYyxmLCQpe2Z1bmN0aW9uIEkoTyxzZSx5ZSl7Zm9yKE89dHlwZW9mIE89PVwibnVtYmVyXCI/Ty50b1N0cmluZygpOk98fFwiXCI7Ty5sZW5ndGg8c2U7KU89eWVbMF0rTztyZXR1cm4gT31mdW5jdGlvbiBQKE8sc2Upe3JldHVybiBJKE8sc2UsXCIwXCIpfWZ1bmN0aW9uIFYoTyxzZSl7ZnVuY3Rpb24geWUoYW8pe3JldHVybiAwPmFvPy0xOjA8YW8/MTowfXZhciBTdDtyZXR1cm4oU3Q9eWUoTy5nZXRGdWxsWWVhcigpLXNlLmdldEZ1bGxZZWFyKCkpKT09PTAmJihTdD15ZShPLmdldE1vbnRoKCktc2UuZ2V0TW9udGgoKSkpPT09MCYmKFN0PXllKE8uZ2V0RGF0ZSgpLXNlLmdldERhdGUoKSkpLFN0fWZ1bmN0aW9uIG9lKE8pe3N3aXRjaChPLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIE87Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKE8uZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoTy5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGVlKE8pe3ZhciBzZT1PLlphO2ZvcihPPW5ldyBEYXRlKG5ldyBEYXRlKE8uJGErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxzZTspe3ZhciB5ZT1PLmdldE1vbnRoKCksU3Q9KHB0KE8uZ2V0RnVsbFllYXIoKSk/Tm46VW4pW3llXTtpZihzZT5TdC1PLmdldERhdGUoKSlzZS09U3QtTy5nZXREYXRlKCkrMSxPLnNldERhdGUoMSksMTE+eWU/Ty5zZXRNb250aCh5ZSsxKTooTy5zZXRNb250aCgwKSxPLnNldEZ1bGxZZWFyKE8uZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtPLnNldERhdGUoTy5nZXREYXRlKCkrc2UpO2JyZWFrfX1yZXR1cm4geWU9bmV3IERhdGUoTy5nZXRGdWxsWWVhcigpKzEsMCw0KSxzZT1vZShuZXcgRGF0ZShPLmdldEZ1bGxZZWFyKCksMCw0KSkseWU9b2UoeWUpLDA+PVYoc2UsTyk/MD49Vih5ZSxPKT9PLmdldEZ1bGxZZWFyKCkrMTpPLmdldEZ1bGxZZWFyKCk6Ty5nZXRGdWxsWWVhcigpLTF9aT4+Pj0wLGM+Pj49MCxmPj4+PTAsJD4+Pj0wO3ZhciBaPW4oKVskKzQwPj4yPj4+MF07JD17S2I6bigpWyQ+PjI+Pj4wXSxKYjpuKClbJCs0Pj4yPj4+MF0sY2I6bigpWyQrOD4+Mj4+PjBdLGliOm4oKVskKzEyPj4yPj4+MF0sZWI6bigpWyQrMTY+PjI+Pj4wXSwkYTpuKClbJCsyMD4+Mj4+PjBdLFdhOm4oKVskKzI0Pj4yPj4+MF0sWmE6bigpWyQrMjg+PjI+Pj4wXSxUYjpuKClbJCszMj4+Mj4+PjBdLEliOm4oKVskKzM2Pj4yPj4+MF0sTGI6Wj9WZShaKTpcIlwifSxmPVZlKGYpLFo9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIHJlIGluIFopZj1mLnJlcGxhY2UobmV3IFJlZ0V4cChyZSxcImdcIiksWltyZV0pO3ZhciBoZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGJlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtaPXtcIiVhXCI6Tz0+aGVbTy5XYV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOk89PmhlW08uV2FdLFwiJWJcIjpPPT5iZVtPLmViXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6Tz0+YmVbTy5lYl0sXCIlQ1wiOk89PlAoKE8uJGErMTkwMCkvMTAwfDAsMiksXCIlZFwiOk89PlAoTy5pYiwyKSxcIiVlXCI6Tz0+SShPLmliLDIsXCIgXCIpLFwiJWdcIjpPPT5lZShPKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6Tz0+ZWUoTyksXCIlSFwiOk89PlAoTy5jYiwyKSxcIiVJXCI6Tz0+KE89Ty5jYixPPT0wP089MTI6MTI8TyYmKE8tPTEyKSxQKE8sMikpLFwiJWpcIjpPPT57Zm9yKHZhciBzZT0wLHllPTA7eWU8PU8uZWItMTtzZSs9KHB0KE8uJGErMTkwMCk/Tm46VW4pW3llKytdKTtyZXR1cm4gUChPLmliK3NlLDMpfSxcIiVtXCI6Tz0+UChPLmViKzEsMiksXCIlTVwiOk89PlAoTy5KYiwyKSxcIiVuXCI6KCk9PmBcXG5gLFwiJXBcIjpPPT4wPD1PLmNiJiYxMj5PLmNiP1wiQU1cIjpcIlBNXCIsXCIlU1wiOk89PlAoTy5LYiwyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6Tz0+Ty5XYXx8NyxcIiVVXCI6Tz0+UChNYXRoLmZsb29yKChPLlphKzctTy5XYSkvNyksMiksXCIlVlwiOk89Pnt2YXIgc2U9TWF0aC5mbG9vcigoTy5aYSs3LShPLldhKzYpJTcpLzcpO2lmKDI+PShPLldhKzM3MS1PLlphLTIpJTcmJnNlKyssc2Upc2U9PTUzJiYoeWU9KE8uV2ErMzcxLU8uWmEpJTcseWU9PTR8fHllPT0zJiZwdChPLiRhKXx8KHNlPTEpKTtlbHNle3NlPTUyO3ZhciB5ZT0oTy5XYSs3LU8uWmEtMSklNzsoeWU9PTR8fHllPT01JiZwdChPLiRhJTQwMC0xKSkmJnNlKyt9cmV0dXJuIFAoc2UsMil9LFwiJXdcIjpPPT5PLldhLFwiJVdcIjpPPT5QKE1hdGguZmxvb3IoKE8uWmErNy0oTy5XYSs2KSU3KS83KSwyKSxcIiV5XCI6Tz0+KE8uJGErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOk89Pk8uJGErMTkwMCxcIiV6XCI6Tz0+e089Ty5JYjt2YXIgc2U9MDw9TztyZXR1cm4gTz1NYXRoLmFicyhPKS82MCwoc2U/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoTy82MCoxMDArTyU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOk89Pk8uTGIsXCIlJVwiOigpPT5cIiVcIn0sZj1mLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpO2ZvcihyZSBpbiBaKWYuaW5jbHVkZXMocmUpJiYoZj1mLnJlcGxhY2UobmV3IFJlZ0V4cChyZSxcImdcIiksWltyZV0oJCkpKTtyZXR1cm4gZj1mLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIikscmU9ZHUoZikscmUubGVuZ3RoPmM/MDooY3UocmUsaSkscmUubGVuZ3RoLTEpfWZ1bmN0aW9uICRyKGkpe3RyeXtpKCl9Y2F0Y2goYyl7S2UoYyl9fWZ1bmN0aW9uIHB1KGkpe3ZhciBjPXt9LGY7Zm9yKGYgaW4gaSkoZnVuY3Rpb24oJCl7dmFyIEk9aVskXTtjWyRdPXR5cGVvZiBJPT1cImZ1bmN0aW9uXCI/ZnVuY3Rpb24oKXt4ci5wdXNoKCQpO3RyeXtyZXR1cm4gSS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZmluYWxseXtPZXx8KHhyLnBvcCgpPT09JHx8S2UoKSxaZSYmZnQ9PT0xJiZ4ci5sZW5ndGg9PT0wJiYoZnQ9MCxHZSs9MSwkcih0byksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLlViKCkpKX19Okl9KShmKTtyZXR1cm4gY312YXIgZnQ9MCxaZT1udWxsLEZuPTAseHI9W10sSG49e30sam49e30sZnU9MCxacj1udWxsLG11PVtdO2Z1bmN0aW9uIGh1KCl7cmV0dXJuIG5ldyBQcm9taXNlKChpLGMpPT57WnI9e3Jlc29sdmU6aSxyZWplY3Q6Y319KX1mdW5jdGlvbiBndSgpe3ZhciBpPVFyKDY1NTQ4KSxjPWkrMTI7cygpW2k+PjI+Pj4wXT1jLHMoKVtpKzQ+PjI+Pj4wXT1jKzY1NTM2LGM9eHJbMF07dmFyIGY9SG5bY107cmV0dXJuIGY9PT12b2lkIDAmJihmPWZ1KyssSG5bY109ZixqbltmXT1jKSxjPWYsbigpW2krOD4+Mj4+PjBdPWMsaX1mdW5jdGlvbiB5dSgpe3ZhciBpPW4oKVtaZSs4Pj4yPj4+MF07cmV0dXJuIGk9altqbltpXV0sLS1HZSxpKCl9ZnVuY3Rpb24gYnUoaSl7aWYoIU9lKXtpZihmdD09PTApe3ZhciBjPSExLGY9ITE7aSgoJD0wKT0+e2lmKCFPZSYmKEZuPSQsYz0hMCxmKSl7ZnQ9MiwkcigoKT0+cm8oWmUpKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5oYi5zYiYmQnJvd3Nlci5oYi5yZXN1bWUoKSwkPSExO3RyeXt2YXIgST15dSgpfWNhdGNoKG9lKXtJPW9lLCQ9ITB9dmFyIFA9ITE7aWYoIVplKXt2YXIgVj1acjtWJiYoWnI9bnVsbCwoJD9WLnJlamVjdDpWLnJlc29sdmUpKEkpLFA9ITApfWlmKCQmJiFQKXRocm93IEl9fSksZj0hMCxjfHwoZnQ9MSxaZT1ndSgpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLmhiLnNiJiZCcm93c2VyLmhiLnBhdXNlKCksJHIoKCk9PmVvKFplKSkpfWVsc2UgZnQ9PT0yPyhmdD0wLCRyKG5vKSxLbihaZSksWmU9bnVsbCxtdS5mb3JFYWNoKCQ9PnF0KCQpKSk6S2UoYGludmFsaWQgc3RhdGU6ICR7ZnR9YCk7cmV0dXJuIEZufX1mdW5jdGlvbiB3dShpKXtyZXR1cm4gYnUoYz0+e2koKS50aGVuKGMpfSl9bmUuZ2IoKTt2YXIgdnU9W251bGwsenQscHIsd3QsTnQsbXIseXIsYnIsd3IsdnIsUnQsVXQsTHQsRnQsSHQsanQsS3QsbCxwLGNlLG1lLEUsdGUsZmUsWHRdLCR1PXtyOmZ1bmN0aW9uKGksYyxmKXtyZXR1cm4gd3UoYXN5bmMoKT0+e2F3YWl0IGEueGIoaSxjLGYpfSl9LGI6ZnVuY3Rpb24oaSxjLGYpe3Rocm93IGk+Pj49MCxuZXcgSmUoaSkuZ2IoYz4+PjAsZj4+PjApLEhlPWksZnIrKyxIZX0sTzpmdW5jdGlvbihpKXtxbihpPj4+MCwheSwxLCF2LDEzMTA3MiwhMSksbmUubGIoKX0sbDpmdW5jdGlvbihpKXtpPj4+PTAsQT9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDppfSk6T3QoaSl9LEk6R3QsaTpOdCxVOm1yLEU6eXIsRzpicixWOndyLFM6dnIsSzpSdCxSOlV0LHA6THQsRjpGdCxDOkh0LFQ6anQsRDpLdCxxOigpPT4hMCxBOmZ1bmN0aW9uKGksYyl7aT4+Pj0wLGk9PWM+Pj4wP3NldFRpbWVvdXQoKCk9PiR0KCkpOkE/cG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDppLGNtZDpcImNoZWNrTWFpbGJveFwifSk6KGk9bmUuUWFbaV0pJiZpLnBvc3RNZXNzYWdlKHtjbWQ6XCJjaGVja01haWxib3hcIn0pfSxNOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LE46UHQsWDpmdW5jdGlvbihpKXtTJiZuZS5RYVtpPj4+MF0ucmVmKCl9LHU6ZnVuY3Rpb24oaSxjLGYpe2k9YysyMDk3MTUyPj4+MDw0MTk0MzA1LSEhaT8oaT4+PjApKzQyOTQ5NjcyOTYqYzpOYU4sZj4+Pj0wLGk9bmV3IERhdGUoMWUzKmkpLG4oKVtmPj4yPj4+MF09aS5nZXRVVENTZWNvbmRzKCksbigpW2YrND4+Mj4+PjBdPWkuZ2V0VVRDTWludXRlcygpLG4oKVtmKzg+PjI+Pj4wXT1pLmdldFVUQ0hvdXJzKCksbigpW2YrMTI+PjI+Pj4wXT1pLmdldFVUQ0RhdGUoKSxuKClbZisxNj4+Mj4+PjBdPWkuZ2V0VVRDTW9udGgoKSxuKClbZisyMD4+Mj4+PjBdPWkuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLG4oKVtmKzI0Pj4yPj4+MF09aS5nZXRVVENEYXkoKSxpPShpLmdldFRpbWUoKS1EYXRlLlVUQyhpLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLG4oKVtmKzI4Pj4yPj4+MF09aX0sdjpmdW5jdGlvbihpLGMsZil7aT1jKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFpPyhpPj4+MCkrNDI5NDk2NzI5NipjOk5hTixmPj4+PTAsaT1uZXcgRGF0ZSgxZTMqaSksbigpW2Y+PjI+Pj4wXT1pLmdldFNlY29uZHMoKSxuKClbZis0Pj4yPj4+MF09aS5nZXRNaW51dGVzKCksbigpW2YrOD4+Mj4+PjBdPWkuZ2V0SG91cnMoKSxuKClbZisxMj4+Mj4+PjBdPWkuZ2V0RGF0ZSgpLG4oKVtmKzE2Pj4yPj4+MF09aS5nZXRNb250aCgpLG4oKVtmKzIwPj4yPj4+MF09aS5nZXRGdWxsWWVhcigpLTE5MDAsbigpW2YrMjQ+PjI+Pj4wXT1pLmdldERheSgpLGM9KHB0KGkuZ2V0RnVsbFllYXIoKSk/eHQ6WXQpW2kuZ2V0TW9udGgoKV0raS5nZXREYXRlKCktMXwwLG4oKVtmKzI4Pj4yPj4+MF09YyxuKClbZiszNj4+Mj4+PjBdPS0oNjAqaS5nZXRUaW1lem9uZU9mZnNldCgpKSxjPW5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyICQ9bmV3IERhdGUoaS5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtpPShjIT0kJiZpLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKCQsYykpfDAsbigpW2YrMzI+PjI+Pj4wXT1pfSx3OmZ1bmN0aW9uKGkpe2k+Pj49MDt2YXIgYz1uZXcgRGF0ZShuKClbaSsyMD4+Mj4+PjBdKzE5MDAsbigpW2krMTY+PjI+Pj4wXSxuKClbaSsxMj4+Mj4+PjBdLG4oKVtpKzg+PjI+Pj4wXSxuKClbaSs0Pj4yPj4+MF0sbigpW2k+PjI+Pj4wXSwwKSxmPW4oKVtpKzMyPj4yPj4+MF0sJD1jLmdldFRpbWV6b25lT2Zmc2V0KCksST1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLFA9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxWPU1hdGgubWluKFAsSSk7cmV0dXJuIDA+Zj9uKClbaSszMj4+Mj4+PjBdPSsoSSE9UCYmVj09JCk6MDxmIT0oVj09JCkmJihJPU1hdGgubWF4KFAsSSksYy5zZXRUaW1lKGMuZ2V0VGltZSgpKzZlNCooKDA8Zj9WOkkpLSQpKSksbigpW2krMjQ+PjI+Pj4wXT1jLmdldERheSgpLGY9KHB0KGMuZ2V0RnVsbFllYXIoKSk/eHQ6WXQpW2MuZ2V0TW9udGgoKV0rYy5nZXREYXRlKCktMXwwLG4oKVtpKzI4Pj4yPj4+MF09ZixuKClbaT4+Mj4+PjBdPWMuZ2V0U2Vjb25kcygpLG4oKVtpKzQ+PjI+Pj4wXT1jLmdldE1pbnV0ZXMoKSxuKClbaSs4Pj4yPj4+MF09Yy5nZXRIb3VycygpLG4oKVtpKzEyPj4yPj4+MF09Yy5nZXREYXRlKCksbigpW2krMTY+PjI+Pj4wXT1jLmdldE1vbnRoKCksbigpW2krMjA+PjI+Pj4wXT1jLmdldFllYXIoKSxpPWMuZ2V0VGltZSgpLzFlMyxKbigoaXQ9aSwxPD0rTWF0aC5hYnMoaXQpPzA8aXQ/K01hdGguZmxvb3IoaXQvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgoaXQtKyh+fml0Pj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKSksaT4+PjB9LHM6bCx0OnAsejpmdW5jdGlvbihpLGMsZil7ZnVuY3Rpb24gJChaKXtyZXR1cm4oWj1aLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT9aWzFdOlwiR01UXCJ9aT4+Pj0wLGM+Pj49MCxmPj4+PTA7dmFyIEk9bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLFA9bmV3IERhdGUoSSwwLDEpLFY9bmV3IERhdGUoSSw2LDEpO0k9UC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBvZT1WLmdldFRpbWV6b25lT2Zmc2V0KCksZWU9TWF0aC5tYXgoSSxvZSk7cygpW2k+PjI+Pj4wXT02MCplZSxuKClbYz4+Mj4+PjBdPSsoSSE9b2UpLGk9JChQKSxjPSQoViksaT1oKGkpLGM9aChjKSxvZTxJPyhzKClbZj4+Mj4+PjBdPWkscygpW2YrND4+Mj4+PjBdPWMpOihzKClbZj4+Mj4+PjBdPWMscygpW2YrND4+Mj4+PjBdPWkpfSxkOigpPT57S2UoXCJcIil9LGM6ZnVuY3Rpb24oaSxjLGYpe3JldHVybiBpPj4+PTAsYz1UKGM+Pj4wLGY+Pj4wKSxFdFtpXS5hcHBseShudWxsLGMpfSxrOmZ1bmN0aW9uKGksYyxmKXtyZXR1cm4gaT4+Pj0wLGM9VChjPj4+MCxmPj4+MCksRXRbaV0uYXBwbHkobnVsbCxjKX0sbTpmdW5jdGlvbigpe30sajpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxXOigpPT57dGhyb3cgR2UrPTEsXCJ1bndpbmRcIn0sQjpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxmOigpPT5wZXJmb3JtYW5jZS50aW1lT3JpZ2luK3BlcmZvcm1hbmNlLm5vdygpLGc6ZnVuY3Rpb24oKXtyZXR1cm4gUz8oZm8oKSxNdChwbykpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LEw6ZnVuY3Rpb24oaSxjLGYsJCl7Zm9yKG5lLlBiPWM+Pj4wLHVlLmxlbmd0aD1mLGM9JD4+PjA+PjMsJD0wOyQ8ZjskKyspdWVbJF09ZCgpW2MrJD4+PjBdO3JldHVybigwPmk/RXRbLWktMV06dnVbaV0pLmFwcGx5KG51bGwsdWUpfSx5OmZ1bmN0aW9uKGkpe2k+Pj49MDt2YXIgYz1vKCkubGVuZ3RoO2lmKGk8PWN8fDQyOTQ5MDE3NjA8aSlyZXR1cm4hMTtmb3IodmFyIGY9MTs0Pj1mO2YqPTIpe3ZhciAkPWMqKDErLjIvZik7JD1NYXRoLm1pbigkLGkrMTAwNjYzMjk2KTt2YXIgST1NYXRoOyQ9TWF0aC5tYXgoaSwkKTtlOntJPUkubWluLmNhbGwoSSw0Mjk0OTAxNzYwLCQrKDY1NTM2LSQlNjU1MzYpJTY1NTM2KS13ZS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2O3RyeXt3ZS5ncm93KEkpLHBlKCk7dmFyIFA9MTticmVhayBlfWNhdGNoe31QPXZvaWQgMH1pZihQKXJldHVybiEwfXJldHVybiExfSxQOmNlLFE6bWUsSDpWdCxoOkUsbzp0ZSx4OmZlLG46WHQsYTp3ZXx8YS53YXNtTWVtb3J5LEo6TG4sZTpmdW5jdGlvbihpLGMsZiwkKXtyZXR1cm4gTG4oaT4+PjAsYz4+PjAsZj4+PjAsJD4+PjApfX07KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gaShmLCQpe3JldHVybiBmPWYuZXhwb3J0cyxmPXB1KGYpLGo9Zj14dShmKSxuZS5tYi5wdXNoKGouRGEpLFRlLnVuc2hpZnQoai5ZKSxTZT0kLGxyKCksZn12YXIgYz17YTokdX07aWYoQnQoKSxhLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGEuaW5zdGFudGlhdGVXYXNtKGMsaSl9Y2F0Y2goZil7SyhcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2YpLGcoZil9cmV0dXJuIGRyKGMsZnVuY3Rpb24oZil7aShmLmluc3RhbmNlLGYubW9kdWxlKX0pLmNhdGNoKGcpLHt9fSkoKSxhLl9PcnRJbml0PShpLGMpPT4oYS5fT3J0SW5pdD1qLlopKGksYyksYS5fT3J0R2V0TGFzdEVycm9yPShpLGMpPT4oYS5fT3J0R2V0TGFzdEVycm9yPWouXykoaSxjKSxhLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oaSxjLGYsJCxJLFAsVixvZSxlZSxaKT0+KGEuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWouJCkoaSxjLGYsJCxJLFAsVixvZSxlZSxaKSxhLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0oaSxjKT0+KGEuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWouYWEpKGksYyksYS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShpLGMsZik9PihhLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9ai5iYSkoaSxjLGYpLGEuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0oaSxjLGYpPT4oYS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWouY2EpKGksYyxmKSxhLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9aT0+KGEuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1qLmRhKShpKSxhLl9PcnRDcmVhdGVTZXNzaW9uPShpLGMsZik9PihhLl9PcnRDcmVhdGVTZXNzaW9uPWouZWEpKGksYyxmKSxhLl9PcnRSZWxlYXNlU2Vzc2lvbj1pPT4oYS5fT3J0UmVsZWFzZVNlc3Npb249ai5mYSkoaSksYS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0oaSxjLGYpPT4oYS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1qLmdhKShpLGMsZiksYS5fT3J0R2V0SW5wdXROYW1lPShpLGMpPT4oYS5fT3J0R2V0SW5wdXROYW1lPWouaGEpKGksYyksYS5fT3J0R2V0T3V0cHV0TmFtZT0oaSxjKT0+KGEuX09ydEdldE91dHB1dE5hbWU9ai5pYSkoaSxjKSxhLl9PcnRGcmVlPWk9PihhLl9PcnRGcmVlPWouamEpKGkpLGEuX09ydENyZWF0ZVRlbnNvcj0oaSxjLGYsJCxJLFApPT4oYS5fT3J0Q3JlYXRlVGVuc29yPWoua2EpKGksYyxmLCQsSSxQKSxhLl9PcnRHZXRUZW5zb3JEYXRhPShpLGMsZiwkLEkpPT4oYS5fT3J0R2V0VGVuc29yRGF0YT1qLmxhKShpLGMsZiwkLEkpLGEuX09ydFJlbGVhc2VUZW5zb3I9aT0+KGEuX09ydFJlbGVhc2VUZW5zb3I9ai5tYSkoaSksYS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0oaSxjLGYsJCk9PihhLl9PcnRDcmVhdGVSdW5PcHRpb25zPWoubmEpKGksYyxmLCQpLGEuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShpLGMsZik9PihhLl9PcnRBZGRSdW5Db25maWdFbnRyeT1qLm9hKShpLGMsZiksYS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9aT0+KGEuX09ydFJlbGVhc2VSdW5PcHRpb25zPWoucGEpKGkpLGEuX09ydENyZWF0ZUJpbmRpbmc9aT0+KGEuX09ydENyZWF0ZUJpbmRpbmc9ai5xYSkoaSksYS5fT3J0QmluZElucHV0PShpLGMsZik9PihhLl9PcnRCaW5kSW5wdXQ9ai5yYSkoaSxjLGYpLGEuX09ydEJpbmRPdXRwdXQ9KGksYyxmLCQpPT4oYS5fT3J0QmluZE91dHB1dD1qLnNhKShpLGMsZiwkKSxhLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1pPT4oYS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9ai50YSkoaSksYS5fT3J0UmVsZWFzZUJpbmRpbmc9aT0+KGEuX09ydFJlbGVhc2VCaW5kaW5nPWoudWEpKGkpLGEuX09ydFJ1bldpdGhCaW5kaW5nPShpLGMsZiwkLEkpPT4oYS5fT3J0UnVuV2l0aEJpbmRpbmc9ai52YSkoaSxjLGYsJCxJKSxhLl9PcnRSdW49KGksYyxmLCQsSSxQLFYsb2UpPT4oYS5fT3J0UnVuPWoud2EpKGksYyxmLCQsSSxQLFYsb2UpLGEuX09ydEVuZFByb2ZpbGluZz1pPT4oYS5fT3J0RW5kUHJvZmlsaW5nPWoueGEpKGkpLGEuX0pzZXBPdXRwdXQ9KGksYyxmKT0+KGEuX0pzZXBPdXRwdXQ9ai55YSkoaSxjLGYpLGEuX0pzZXBHZXROb2RlTmFtZT1pPT4oYS5fSnNlcEdldE5vZGVOYW1lPWouemEpKGkpO3ZhciBTcj1hLl9wdGhyZWFkX3NlbGY9KCk9PihTcj1hLl9wdGhyZWFkX3NlbGY9ai5BYSkoKSxRcj1hLl9tYWxsb2M9aT0+KFFyPWEuX21hbGxvYz1qLkJhKShpKSxLbj1hLl9mcmVlPWk9PihLbj1hLl9mcmVlPWouQ2EpKGkpO2EuX19lbXNjcmlwdGVuX3Rsc19pbml0PSgpPT4oYS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9ai5EYSkoKTt2YXIgcW49YS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9KGksYyxmLCQsSSxQKT0+KHFuPWEuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWouRmEpKGksYyxmLCQsSSxQKTthLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD0oKT0+KGEuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWouR2EpKCk7dmFyIFluPShpLGMsZiwkKT0+KFluPWouSGEpKGksYyxmLCQpLGVuPWk9Pihlbj1qLklhKShpKSx0bj1hLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1pPT4odG49YS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ai5KYSkoaSksWG49YS5fX2Vtc2NyaXB0ZW5fY2hlY2tfbWFpbGJveD0oKT0+KFhuPWEuX19lbXNjcmlwdGVuX2NoZWNrX21haWxib3g9ai5LYSkoKSxKbj1pPT4oSm49ai5MYSkoaSksWm49KGksYyk9Pihabj1qLk1hKShpLGMpLHJuPSgpPT4ocm49ai5OYSkoKSxDcj1pPT4oQ3I9ai5PYSkoaSksbm49aT0+KG5uPWouUGEpKGkpLFFuPWEuZHluQ2FsbF9paT0oaSxjKT0+KFFuPWEuZHluQ2FsbF9paT1qLlJhKShpLGMpLGVvPWk9Pihlbz1qLlNhKShpKSx0bz0oKT0+KHRvPWouVGEpKCkscm89aT0+KHJvPWouVWEpKGkpLG5vPSgpPT4obm89ai5WYSkoKTthLl9fX3N0YXJ0X2VtX2pzPTkyNTc4MyxhLl9fX3N0b3BfZW1fanM9OTI1OTQ0O2Z1bmN0aW9uIHh1KGkpe2k9T2JqZWN0LmFzc2lnbih7fSxpKTt2YXIgYz0kPT4oKT0+JCgpPj4+MCxmPSQ9Pkk9PiQoSSk+Pj4wO3JldHVybiBpLl9fZXJybm9fbG9jYXRpb249YyhpLl9fZXJybm9fbG9jYXRpb24pLGkucHRocmVhZF9zZWxmPWMoaS5wdGhyZWFkX3NlbGYpLGkubWFsbG9jPWYoaS5tYWxsb2MpLGkuc3RhY2tTYXZlPWMoaS5zdGFja1NhdmUpLGkuc3RhY2tBbGxvYz1mKGkuc3RhY2tBbGxvYyksaX1hLmtlZXBSdW50aW1lQWxpdmU9WGUsYS53YXNtTWVtb3J5PXdlLGEuc3RhY2tBbGxvYz1ubixhLnN0YWNrU2F2ZT1ybixhLnN0YWNrUmVzdG9yZT1DcixhLlVURjhUb1N0cmluZz1WZSxhLnN0cmluZ1RvVVRGOD1ncixhLmxlbmd0aEJ5dGVzVVRGOD12dCxhLkV4aXRTdGF0dXM9Y3QsYS5QVGhyZWFkPW5lO3ZhciBBcjtidD1mdW5jdGlvbiBpKCl7QXJ8fG9vKCksQXJ8fChidD1pKX07ZnVuY3Rpb24gb28oKXtmdW5jdGlvbiBpKCl7aWYoIUFyJiYoQXI9ITAsYS5jYWxsZWRSdW49ITAsIU9lKSYmKEF8fHN0KFRlKSxtKGEpLGEub25SdW50aW1lSW5pdGlhbGl6ZWQmJmEub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwhQSkpe2lmKGEucG9zdFJ1bilmb3IodHlwZW9mIGEucG9zdFJ1bj09XCJmdW5jdGlvblwiJiYoYS5wb3N0UnVuPVthLnBvc3RSdW5dKTthLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGM9YS5wb3N0UnVuLnNoaWZ0KCk7a2UudW5zaGlmdChjKX1zdChrZSl9fWlmKCEoMDxGZSkpaWYoQSltKGEpLEF8fHN0KFRlKSxzdGFydFdvcmtlcihhKTtlbHNle2lmKGEucHJlUnVuKWZvcih0eXBlb2YgYS5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKGEucHJlUnVuPVthLnByZVJ1bl0pO2EucHJlUnVuLmxlbmd0aDspVWUudW5zaGlmdChhLnByZVJ1bi5zaGlmdCgpKTtzdChVZSksMDxGZXx8KGEuc2V0U3RhdHVzPyhhLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dChmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLnNldFN0YXR1cyhcIlwiKX0sMSksaSgpfSwxKSk6aSgpKX19aWYoYS5wcmVJbml0KWZvcih0eXBlb2YgYS5wcmVJbml0PT1cImZ1bmN0aW9uXCImJihhLnByZUluaXQ9W2EucHJlSW5pdF0pOzA8YS5wcmVJbml0Lmxlbmd0aDspYS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIG9vKCksdC5yZWFkeX19KSgpO3R5cGVvZiBobz09XCJvYmplY3RcIiYmdHlwZW9mIGNuPT1cIm9iamVjdFwiP2NuLmV4cG9ydHM9bW86dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9Pm1vKX0pO3ZhciB5bz1KdCgobWMsX3UpPT57X3UuZXhwb3J0cz1cXCdcInVzZSBzdHJpY3RcIjt2YXIgTW9kdWxlPXt9LEVOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBub2RlV29ya2VyVGhyZWFkcz1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIikscGFyZW50UG9ydD1ub2RlV29ya2VyVGhyZWFkcy5wYXJlbnRQb3J0O3BhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsZT0+b25tZXNzYWdlKHtkYXRhOmV9KSk7dmFyIGZzPXJlcXVpcmUoXCJmc1wiKTtPYmplY3QuYXNzaWduKGdsb2JhbCx7c2VsZjpnbG9iYWwscmVxdWlyZSxNb2R1bGUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOm5vZGVXb3JrZXJUaHJlYWRzLldvcmtlcixpbXBvcnRTY3JpcHRzOmU9PigwLGV2YWwpKGZzLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKStcIi8vIyBzb3VyY2VVUkw9XCIrZSkscG9zdE1lc3NhZ2U6ZT0+cGFyZW50UG9ydC5wb3N0TWVzc2FnZShlKSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6RGF0ZS5ub3d9fSl9dmFyIGluaXRpYWxpemVkSlM9ITE7ZnVuY3Rpb24gdGhyZWFkUHJpbnRFcnIoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO2lmKEVOVklST05NRU5UX0lTX05PREUpe2ZzLndyaXRlU3luYygyLGUrYFxcXFxuYCk7cmV0dXJufWNvbnNvbGUuZXJyb3IoZSl9ZnVuY3Rpb24gdGhyZWFkQWxlcnQoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6ZSx0aHJlYWRJZDpNb2R1bGUuX3B0aHJlYWRfc2VsZigpfSl9dmFyIGVycj10aHJlYWRQcmludEVycjtzZWxmLmFsZXJ0PXRocmVhZEFsZXJ0LE1vZHVsZS5pbnN0YW50aWF0ZVdhc209KGUsdCk9Pnt2YXIgYT1Nb2R1bGUud2FzbU1vZHVsZTtNb2R1bGUud2FzbU1vZHVsZT1udWxsO3ZhciByPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShhLGUpO3JldHVybiB0KHIpfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbj8/ZX07ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShlKXt0cnl7aWYoZS5kYXRhLmNtZD09PVwibG9hZFwiKXtsZXQgYT1bXTtzZWxmLm9ubWVzc2FnZT1yPT5hLnB1c2gociksc2VsZi5zdGFydFdvcmtlcj1yPT57TW9kdWxlPXIscG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRlZFwifSk7Zm9yKGxldCBzIG9mIGEpaGFuZGxlTWVzc2FnZShzKTtzZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlfSxNb2R1bGUud2FzbU1vZHVsZT1lLmRhdGEud2FzbU1vZHVsZTtmb3IoY29uc3QgciBvZiBlLmRhdGEuaGFuZGxlcnMpTW9kdWxlW3JdPSguLi5zKT0+e3Bvc3RNZXNzYWdlKHtjbWQ6XCJjYWxsSGFuZGxlclwiLGhhbmRsZXI6cixhcmdzOnN9KX07aWYoTW9kdWxlLndhc21NZW1vcnk9ZS5kYXRhLndhc21NZW1vcnksTW9kdWxlLmJ1ZmZlcj1Nb2R1bGUud2FzbU1lbW9yeS5idWZmZXIsTW9kdWxlLkVOVklST05NRU5UX0lTX1BUSFJFQUQ9ITAsdHlwZW9mIGUuZGF0YS51cmxPckJsb2I9PVwic3RyaW5nXCIpaW1wb3J0U2NyaXB0cyhlLmRhdGEudXJsT3JCbG9iKTtlbHNle3ZhciB0PVVSTC5jcmVhdGVPYmplY3RVUkwoZS5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyh0KSxVUkwucmV2b2tlT2JqZWN0VVJMKHQpfW9ydFdhc21UaHJlYWRlZChNb2R1bGUpfWVsc2UgaWYoZS5kYXRhLmNtZD09PVwicnVuXCIpe01vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQoZS5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0KGUuZGF0YS5wdGhyZWFkX3B0ciksTW9kdWxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxNb2R1bGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIoZS5kYXRhKSxNb2R1bGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksaW5pdGlhbGl6ZWRKU3x8KGluaXRpYWxpemVkSlM9ITApO3RyeXtNb2R1bGUuaW52b2tlRW50cnlQb2ludChlLmRhdGEuc3RhcnRfcm91dGluZSxlLmRhdGEuYXJnKX1jYXRjaChhKXtpZihhIT1cInVud2luZFwiKXRocm93IGF9fWVsc2UgZS5kYXRhLmNtZD09PVwiY2FuY2VsXCI/TW9kdWxlLl9wdGhyZWFkX3NlbGYoKSYmTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6ZS5kYXRhLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCJ8fChlLmRhdGEuY21kPT09XCJjaGVja01haWxib3hcIj9pbml0aWFsaXplZEpTJiZNb2R1bGUuY2hlY2tNYWlsYm94KCk6ZS5kYXRhLmNtZCYmKGVycihcIndvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgXCIrZS5kYXRhLmNtZCksZXJyKGUuZGF0YSkpKX1jYXRjaChhKXt0aHJvdyBNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkJiZNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkKCksYX19c2VsZi5vbm1lc3NhZ2U9aGFuZGxlTWVzc2FnZTtcXFxcblxcJ30pO3ZhciBtbixRdCxlcixUcix0cixTbyxobixEZT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bW49ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LFF0PWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxlcj1lPT5bdm9pZCAwLDQsMSwxLDIsMiw0LDgsdm9pZCAwLDEsMiw4LDQsOCx2b2lkIDAsdm9pZCAwLHZvaWQgMF1bZV0sVHI9ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSx0cj1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sU289ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJib29sXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwidWludDMyXCIsaG49ZT0+e3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7ZX1gKX19fSk7dmFyIFZ1LEd1LENvLEFvLElvLE51LEVlLG10PUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO1Z1PVtcIlZcIixcIklcIixcIldcIixcIkVcIixcIkZcIl0sR3U9KGUsdCk9Pntjb25zb2xlLmxvZyhgWyR7VnVbZV19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke3R9YCl9LElvPShlLHQpPT57Q289ZSxBbz10fSxOdT0oZSx0KT0+e2xldCByPXRyKGUpLG89dHIoQ28pO3I+PW8mJkd1KHIsdHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj90KCk6dCl9LEVlPSguLi5lKT0+e0FvJiZOdSguLi5lKX19KTt2YXIgRW8sVG89SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7RW89KGUsdCk9Pm5ldyhUcih0KSkoZSl9KTt2YXIgT289SCgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIE9yLFV1LF9vLHluLGduLFJvLFBvPUgoKCk9PntcInVzZSBzdHJpY3RcIjttdCgpO09vKCk7T3I9ZT0+TWF0aC5jZWlsKGUvMTYpKjE2LFV1PTEsX289KCk9PlV1KysseW49YXN5bmMoZSx0LHIsbyk9PntsZXQgbj1PcihyKSxzPWUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7dHJ5e2xldCB1PWUuZ2V0Q29tbWFuZEVuY29kZXIoKTtlLmVuZENvbXB1dGVQYXNzKCksdS5jb3B5QnVmZmVyVG9CdWZmZXIodCwwLHMsMCxuKSxlLmZsdXNoKCksYXdhaXQgcy5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2xldCBkPXMuZ2V0TWFwcGVkUmFuZ2UoKTtpZihvKXtsZXQgYT1vKCk7cmV0dXJuIGEuc2V0KG5ldyBVaW50OEFycmF5KGQsMCxyKSksYX1lbHNlIHJldHVybiBuZXcgVWludDhBcnJheShkLnNsaWNlKDAscikpfWZpbmFsbHl7cy5kZXN0cm95KCl9fSxnbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc9W10sdGhpcy5idWZmZXJzUGVuZGluZz1bXSx0aGlzLmV4dGVybmFsQnVmZmVycz1uZXcgTWFwfXVwbG9hZCh0LHIpe2xldCBvPXIuYnVmZmVyLG49ci5ieXRlT2Zmc2V0LHM9ci5ieXRlTGVuZ3RoLHU9T3IocyksZD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihkLm9yaWdpbmFsU2l6ZSE9PXMpdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7ZC5vcmlnaW5hbFNpemV9LCBkYXRhIHNpemU9JHtzfWApO2xldCBhPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHttYXBwZWRBdENyZWF0aW9uOiEwLHNpemU6dSx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEV8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KSxtPWEuZ2V0TWFwcGVkUmFuZ2UoKTtuZXcgVWludDhBcnJheShtKS5zZXQobmV3IFVpbnQ4QXJyYXkobyxuLHMpKSxhLnVubWFwKCk7bGV0IGc9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksZy5jb3B5QnVmZmVyVG9CdWZmZXIoYSwwLGQuZ3B1RGF0YS5idWZmZXIsMCx1KSxFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke3R9KWApLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcucHVzaChhKX1tZW1jcHkodCxyKXtsZXQgbz10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHIpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYoby5vcmlnaW5hbFNpemUhPT1uLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2xldCBzPU9yKG8ub3JpZ2luYWxTaXplKSx1PXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHUuY29weUJ1ZmZlclRvQnVmZmVyKG8uZ3B1RGF0YS5idWZmZXIsMCxuLmdwdURhdGEuYnVmZmVyLDAscyl9cmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0LHIsbyl7bGV0IG47aWYobyl7aWYobj10aGlzLmV4dGVybmFsQnVmZmVycy5nZXQobyksbj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBidWZmZXIgaXMgbm90IHJlZ2lzdGVyZWRcIik7aWYodD09PW8pcmV0dXJuIEVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7bn0sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKSxuO3RoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZShvKX1lbHNlIG49X28oKTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KG4se2dwdURhdGE6e2lkOm4sdHlwZTowLGJ1ZmZlcjp0fSxvcmlnaW5hbFNpemU6cn0pLHRoaXMuZXh0ZXJuYWxCdWZmZXJzLnNldCh0LG4pLEVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7bn0sIHJlZ2lzdGVyZWQuYCksbn11bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCl7bGV0IHI9dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KHQpO3IhPT12b2lkIDAmJih0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUociksdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKHQpLEVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHtyfWApKX1jcmVhdGUodCxyPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1Qpe2xldCBvPU9yKHQpLG4scz0ociZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UsdT0ociZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07aWYoc3x8dSl7bGV0IGE9cz90aGlzLmZyZWVCdWZmZXJzOnRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLG09YS5nZXQobyk7bXx8KG09W10sYS5zZXQobyxtKSksbS5sZW5ndGg+MD9uPW0ucG9wKCk6bj10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpvLHVzYWdlOnJ9KX1lbHNlIG49dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpyfSk7bGV0IGQ9e2lkOl9vKCksdHlwZTowLGJ1ZmZlcjpufTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGQuaWQse2dwdURhdGE6ZCxvcmlnaW5hbFNpemU6dH0pLEVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHt0fSkgPT4gaWQ9JHtkLmlkfWApLGR9Z2V0KHQpe3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk/LmdwdURhdGF9cmVsZWFzZSh0KXtsZXQgcj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwicmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3RcIik7cmV0dXJuIEVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke3R9KSwgZ3B1RGF0YUlkPSR7ci5ncHVEYXRhLmlkfWApLHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZSh0KSx0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goci5ncHVEYXRhLmJ1ZmZlciksci5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQodCxyKXtsZXQgbz10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCB5bih0aGlzLmJhY2tlbmQsby5ncHVEYXRhLmJ1ZmZlcixvLm9yaWdpbmFsU2l6ZSxyKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyl0LmRlc3Ryb3koKTt0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nPVtdO2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRT90aGlzLmZyZWVCdWZmZXJzLmdldCh0LnNpemUpLnB1c2godCk6KHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNP3RoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldCh0LnNpemUpLnB1c2godCk6dC5kZXN0cm95KCk7dGhpcy5idWZmZXJzUGVuZGluZz1bXX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXB9fSxSbz0oLi4uZSk9Pm5ldyBnbiguLi5lKX0pO3ZhciBibixpZSxQZT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Ym49Y2xhc3N7Y29uc3RydWN0b3IodCl7T2JqZWN0LmFzc2lnbih0aGlzLHQpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLl9jYWNoZUtleXx8KHRoaXMuX2NhY2hlS2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAodD0+YCR7dGhpc1t0XX1gKS5qb2luKFwiO1wiKSksdGhpcy5fY2FjaGVLZXl9fSxpZT1lPT5uZXcgYm4oZSl9KTt2YXIgd24sUWUsayxDdCxfcixScixQcixnZT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d249Y2xhc3N7c3RhdGljIGNhbGNNYXRNdWxTaGFwZSh0LHIpe3JldHVybiB0WzFdIT09clswXT92b2lkIDA6W3RbMF0sclsxXV19fSxRZT1jbGFzc3tzdGF0aWMgY2FsY1NoYXBlKHQscixvPSExKXtsZXQgbj10Lmxlbmd0aCxzPXIubGVuZ3RoO2lmKG49PT0wKXJldHVybiByO2lmKHM9PT0wKXJldHVybiB0O2xldCB1PU1hdGgubWF4KHQubGVuZ3RoLHIubGVuZ3RoKSxkPW5ldyBBcnJheSh1KTtpZihvKXtpZihuPDJ8fHM8MilyZXR1cm47bGV0IGE9d24uY2FsY01hdE11bFNoYXBlKFt0W24tMl0sdFtuLTFdXSxbcltzLTJdLHJbcy0xXV0pO2lmKGE9PT12b2lkIDApcmV0dXJuO1tkW3UtMl0sZFt1LTFdXT1hfWZvcihsZXQgYT1vPzM6MTthPD11O2ErKyl7bGV0IG09bi1hPDA/MTp0W24tYV0sZz1zLWE8MD8xOnJbcy1hXTtpZihtIT09ZyYmbT4xJiZnPjEpcmV0dXJuO2RbdS1hXT1NYXRoLm1heChtLGcpfXJldHVybiBkfXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHQscil7bGV0IG89dC5sZW5ndGgsbj1yLmxlbmd0aDtpZihvPm4pcmV0dXJuITE7Zm9yKGxldCBzPTE7czw9bztzKyspaWYodFtvLXNdIT09MSYmdFtvLXNdIT09cltuLXNdKXJldHVybiExO3JldHVybiEwfX0saz1jbGFzcyBle3N0YXRpYyBzaXplKHQpe3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHIpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscixvKXtsZXQgbj0xO2ZvcihsZXQgcz1yO3M8bztzKyspe2lmKHRbc108MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO24qPXRbc119cmV0dXJuIG59c3RhdGljIGNvbXB1dGVTdHJpZGVzKHQpe2xldCByPXQubGVuZ3RoO2lmKHI9PT0wKXJldHVybltdO2lmKHI9PT0xKXJldHVyblsxXTtsZXQgbz1uZXcgQXJyYXkocik7b1tyLTFdPTEsb1tyLTJdPXRbci0xXTtmb3IobGV0IG49ci0zO24+PTA7LS1uKW9bbl09b1tuKzFdKnRbbisxXTtyZXR1cm4gb31zdGF0aWMgbm9ybWFsaXplQXhpcyh0LHIpe2lmKHQ8LXImJnQ+PXIpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiB0PDA/dCtyOnR9c3RhdGljIG5vcm1hbGl6ZUF4ZXModCxyKXtyZXR1cm4gdC5tYXAobz0+dGhpcy5ub3JtYWxpemVBeGlzKG8scj8/dC5sZW5ndGgpKX1zdGF0aWMgc29ydEJhc2VkT25QZXJtKHQscil7cmV0dXJuIHI/ci5tYXAobz0+dFtvXSk6dC5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUodCxyKXtsZXQgbz10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKG4scyk9Pm4rcltzXStyW3Mrb10pfXN0YXRpYyBhcmVFcXVhbCh0LHIpe3JldHVybiB0Lmxlbmd0aCE9PXIubGVuZ3RoPyExOnQuZXZlcnkoKG8sbik9Pm89PT1yW25dKX19LEN0PWNsYXNzIGV7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQscixvLG4scyx1KXtpZighdCYmby5sZW5ndGghPT1yLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IGQ9MDtkPHIubGVuZ3RoLTI7ZCsrKWQ+PW8ubGVuZ3RoP28ucHVzaChyW2QrMl0pOm9bZF09cltkKzJdO2ZvcihsZXQgZD0wO2Q8by5sZW5ndGg7ZCsrKWlmKGQ8bi5sZW5ndGgpe2lmKG5bZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIG4ucHVzaCgxKTtmb3IobGV0IGQ9MDtkPG8ubGVuZ3RoO2QrKylpZihkPHMubGVuZ3RoKXtpZihzW2RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHMucHVzaCgxKTtmb3IobGV0IGQ9MDtkPG8ubGVuZ3RoKjI7ZCsrKWlmKGQ8dS5sZW5ndGgpe2lmKHVbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgdS5wdXNoKDApO2ZvcihsZXQgZD0wO2Q8by5sZW5ndGg7ZCsrKXtpZihvW2RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZih1W2RdPj1vW2RdfHx1W2Qrby5sZW5ndGhdPj1vW2RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxyLG8sbixzLHUsZCl7aWYoZCl7aWYocy5sZW5ndGghPT0yKih0Lmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihuLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGgtMjthKyspZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W2ErKHU/MToyKV0sclthXSxvW2FdLG5bYV0scyxhLGErdC5sZW5ndGgtMixkKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUodCxyLG8sbixzLHUsZCl7aWYoci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2xldCBhPVtyWzBdLHJbMV1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcih0LHIsYSxvLG4scyx1LGQpLGF9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxyLG8sbixzLHUsZCl7aWYodC5sZW5ndGg8PTB8fHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7bGV0IGE9W3RbMF0sclswXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKCExLHQsYSxvLG4scyx1LGQpLGF9c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcih0LHIsbyxuLHMsdSxkLGEpe2lmKHQpZm9yKGxldCBtPTA7bTxyLmxlbmd0aC0yO20rKylvLnB1c2goMSk7ZWxzZSBmb3IobGV0IG09MDttPHIubGVuZ3RoLTI7bSsrKW8ucHVzaChlLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHJbbSsyXSxuW21dLHNbbV0sdVttXSxkLG0sbStyLmxlbmd0aC0yLGEpKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodCxyLG8sbixzLHUsZCxhKXtsZXQgbT1vKihuLTEpKzE7aWYoYSYmYSE9PVwiTk9UU0VUXCIpc3dpdGNoKGEpe2Nhc2VcIlZBTElEXCI6cmV0dXJuIHNbdV09MCxzW2RdPTAsTWF0aC5mbG9vcigodC1tKS9yKzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYobyE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tsZXQgeD0oKHQrci0xKS9yLTEpKnIrbi10O3JldHVybiBzW3VdPU1hdGguZmxvb3IoYT09PVwiU0FNRV9MT1dFUlwiPyh4KzEpLzI6eC8yKSxzW2RdPXgtc1t1XSxNYXRoLmZsb29yKCh0K3gtbikvcisxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX1lbHNlIHJldHVybiBNYXRoLmZsb29yKCh0K3NbdV0rc1tkXS1tKS9yKzEpfX0sX3I9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQscixvLG4scyl7aWYodC5sZW5ndGghPT0yfHxvLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IHUsZCxhO3I/KHU9dFsxXSxkPXRbMF0pOih1PXRbMF0sZD10WzFdKTtsZXQgbT0tMTtpZihuPyhhPW9bMF0sbT0xKTooYT1vWzFdLG09MCksb1ttXSE9PWQpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKHU8PTB8fGE8PTB8fGQ8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYocyYmIVFlLmlzVmFsaWRCcm9hZGNhc3QocyxbdSxhXSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW3UsYSxkXX19LFJyPS0zNDAyODIzNDY2Mzg1Mjg4NmUyMixQcj0zNDAyODIzNDY2Mzg1Mjg4NmUyMn0pO3ZhciBMdSxNbyxNZSwkbixsdCxxZSxBdCxodCxCbyxMLFgsdm4sa28seG4sRG8sdmU9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtMdT02NCxNbz0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKGUpe2Nhc2UgMTA6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMTY+YDpcImYxNlwiO2Nhc2UgMTpyZXR1cm4gdD4xP2B2ZWMke3R9PGYzMj5gOlwiZjMyXCI7Y2FzZSA2OnJldHVybiB0PjE/YHZlYyR7dH08aTMyPmA6XCJpMzJcIjtjYXNlIDEyOnJldHVybiB0PjE/YHZlYyR7dH08dTMyPmA6XCJ1MzJcIjtjYXNlIDc6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcImkzMlwiXTtjYXNlIDEzOmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJ1MzJcIl07Y2FzZSA5OmlmKHQhPT00KXRocm93IG5ldyBFcnJvcihcImJvb2wgbXVzdCBiZSB2ZWM0XCIpO3JldHVybltcInUzMlwiLFwidmVjNDxib29sPlwiXTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7ZX1gKX19LE1lPShlLHQ9MSk9PntsZXQgcj1NbyhlLHQpO3JldHVybiB0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnJbMF19LCRuPWU9Plt7dHlwZTpcInVpbnQzMlwiLGRhdGE6ZX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOmsuY29tcHV0ZVN0cmlkZXMoZSl9XSxsdD1lPT5lJTQ9PT0wPzQ6ZSUyPT09MD8yOjEscWU9KGU9XCJmMzJcIix0LHI9XCIwXCIpPT4hdHx8dD09PTE/YCR7ZX0oJHtyfSlgOmB2ZWMke3R9PCR7ZX0+KCR7cn0pYCxBdD0oZSx0LHIpPT5lPT09XCJmMzJcIj9yOnQ9PT0xP2BmMzIoJHtyfSlgOmB2ZWMke3R9Zigke3J9KWAsaHQ9KGUsdCk9PnQ9PT00P2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56ICsgJHtlfS53KWA6dD09PTI/YCgke2V9LnggKyAke2V9LnkpYDp0PT09Mz9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueilgOmUsQm89KGUsdCxyLG8sbik9PntsZXQgcz10eXBlb2Ygcj09XCJudW1iZXJcIix1PXM/cjpyLmxlbmd0aCxkPVsuLi5uZXcgQXJyYXkodSkua2V5cygpXSxhPXU8Mj9cInUzMlwiOnU8PTQ/YHZlYyR7dX08dTMyPmA6YGFycmF5PHUzMiwgJHt1fT5gLG09TW8odCxuKSxnPXR5cGVvZiBtPT1cInN0cmluZ1wiP206bVsxXSx4PXR5cGVvZiBtPT1cInN0cmluZ1wiP206bVswXSxiPXtpbmRpY2VzOmEsdmFsdWU6ZyxzdG9yYWdlOngsdGVuc29yOnR9LHc9Tj0+dHlwZW9mIE49PVwic3RyaW5nXCI/TjpgJHtOfXVgLHY9e29mZnNldFRvSW5kaWNlczohMSxpbmRpY2VzVG9PZmZzZXQ6ITEsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ITEsc2V0OiExLHNldEJ5SW5kaWNlczohMSxnZXQ6ITEsZ2V0QnlJbmRpY2VzOiExfSx5PXM/XCJ1bmlmb3Jtcy5cIjpcIlwiLFM9YCR7eX0ke2V9X3NoYXBlYCxBPWAke3l9JHtlfV9zdHJpZGVzYCxSPVwiXCI7Zm9yKGxldCBOPTA7Tjx1LTE7TisrKVIrPWBcXG4gICAgbGV0IGRpbSR7Tn0gPSBjdXJyZW50IC8gJHtBfVske059XTtcXG4gICAgbGV0IHJlc3Qke059ID0gY3VycmVudCAlICR7QX1bJHtOfV07XFxuICAgIGluZGljZXNbJHtOfV0gPSBkaW0ke059O1xcbiAgICBjdXJyZW50ID0gcmVzdCR7Tn07XFxuICAgIGA7Uis9YGluZGljZXNbJHt1LTF9XSA9IGN1cnJlbnQ7YDtsZXQgVz11PDI/XCJcIjpgXFxuICBmbiBvMmlfJHtlfShvZmZzZXQ6IHUzMikgLT4gJHtiLmluZGljZXN9IHtcXG4gICAgdmFyIGluZGljZXM6ICR7Yi5pbmRpY2VzfTtcXG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XFxuICAgICR7Un1cXG4gICAgcmV0dXJuIGluZGljZXM7XFxuICB9YCxNPU49Pih2Lm9mZnNldFRvSW5kaWNlcz0hMCx1PDI/TjpgbzJpXyR7ZX0oJHtOfSlgKSxEPVtdO2lmKHU+PTIpZm9yKGxldCBOPXUtMTtOPj0wO04tLSlELnB1c2goYCR7QX1bJHtOfV0gKiAoaW5kaWNlc1ske059XSlgKTtsZXQgXz11PDI/XCJcIjpgXFxuICBmbiBpMm9fJHtlfShpbmRpY2VzOiAke2IuaW5kaWNlc30pIC0+IHUzMiB7XFxuICAgIHJldHVybiAke0Quam9pbihcIitcIil9O1xcbiAgfWAsej1OPT4odi5pbmRpY2VzVG9PZmZzZXQ9ITAsdTwyP046YGkyb18ke2V9KCR7Tn0pYCksRj0oLi4uTik9PnU9PT0wP1wiMHVcIjpgJHtiLmluZGljZXN9KCR7Ti5tYXAodykuam9pbihcIixcIil9KWAscT0oTixkZSk9PnU8Mj9gJHtOfWA6YCR7Tn1bJHtkZX1dYCxsZT0oTixkZSxwZSk9PnU8Mj9gJHtOfT0ke3BlfTtgOmAke059WyR7ZGV9XT0ke3BlfTtgLEI9e30sSz0oTixkZSk9Pnt2LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0PSEwO2xldCBwZT1gJHtkZS5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtlfU9mZnNldGA7aWYocGUgaW4gQilyZXR1cm5gJHtwZX0oJHtOfSlgO2xldCB6ZT1bXTtmb3IobGV0IFVlPXUtMTtVZT49MDtVZS0tKXtsZXQgVGU9ZGUuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixVZStkZS5yYW5rLXUpO3plLnB1c2goYCR7cShBLFVlKX0gKiAoJHtUZX0gJSAke3EoUyxVZSl9KWApfXJldHVybiBCW3BlXT1gZm4gJHtwZX0ob3V0cHV0SW5kaWNlczogJHtkZS50eXBlLmluZGljZXN9KSAtPiB1MzIge1xcbiAgICAgICAgICAgICByZXR1cm4gJHt6ZS5sZW5ndGg+MD96ZS5qb2luKFwiK1wiKTpcIjB1XCJ9O1xcbiAgICAgICAgICAgfWAsYCR7cGV9KCR7Tn0pYH0seGU9KE4sZGUpPT4oKCk9PntpZihiLnN0b3JhZ2U9PT1iLnZhbHVlKXJldHVybmAke2V9WyR7Tn1dPSR7ZGV9O2A7aWYoYi5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmYi52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYCR7ZX1bJHtOfV09dmVjMjx1MzI+KHUzMigke2RlfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7ZGV9IDwgMCkpO2A7aWYoYi5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmYi52YWx1ZT09PVwidTMyXCIpcmV0dXJuYCR7ZX1bJHtOfV09dmVjMjx1MzI+KHUzMigke2RlfSksIDB1KTtgO2lmKGIuc3RvcmFnZT09PVwidTMyXCImJmIudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gJHtlfVske059XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke2RlfSkpO2A7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2Iuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtiLnZhbHVlfSB5ZXRgKX0pKCksYWU9Tj0+KCgpPT57aWYoYi5zdG9yYWdlPT09Yi52YWx1ZSlyZXR1cm5gJHtlfVske059XWA7aWYoYi5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmYi52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYGkzMigke2V9WyR7Tn1dLngpYDtpZihiLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZiLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gdTMyKCR7ZX1bJHtOfV0ueClgO2lmKGIuc3RvcmFnZT09PVwidTMyXCImJmIudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gdmVjNDxib29sPihib29sKCR7ZX1bJHtOfV0gJiAweEZGdSksIGJvb2woJHtlfVske059XSAmIDB4RkYwMHUpLCBib29sKCR7ZX1bJHtOfV0gJiAweEZGMDAwMHUpLCBib29sKCR7ZX1bJHtOfV0gJiAweEZGMDAwMDAwdSkpYDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7Yi5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2IudmFsdWV9IHlldGApfSkoKSx3ZT11PDI/XCJcIjpgXFxuICBmbiBnZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2IuaW5kaWNlc30pIC0+ICR7Z30ge1xcbiAgICByZXR1cm4gJHthZShgaTJvXyR7ZX0oaW5kaWNlcylgKX07XFxuICB9YCxqPXU8Mj9cIlwiOigoKT0+e2xldCBOPWQubWFwKHBlPT5gZCR7cGV9OiB1MzJgKS5qb2luKFwiLCBcIiksZGU9ZC5tYXAocGU9PmBkJHtwZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxcbiAgZm4gZ2V0XyR7ZX0oJHtOfSkgLT4gJHtnfSB7XFxuICAgIHJldHVybiBnZXRfJHtlfUJ5SW5kaWNlcygke0YoZGUpfSk7XFxuICB9YH0pKCksU2U9KC4uLk4pPT57aWYoTi5sZW5ndGghPT11KXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3V9YCk7bGV0IGRlPU4ubWFwKHcpLmpvaW4oXCIsXCIpO3JldHVybiB1PT09MD9hZShcIjB1XCIpOnU9PT0xP2FlKGRlWzBdKToodi5nZXQ9ITAsdi5nZXRCeUluZGljZXM9ITAsdi5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9KCR7ZGV9KWApfSxPZT1OPT51PDI/YWUoTik6KHYuZ2V0QnlJbmRpY2VzPSEwLHYuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfUJ5SW5kaWNlcygke059KWApLEllPXU8Mj9cIlwiOmBcXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7Yi5pbmRpY2VzfSwgdmFsdWU6ICR7Z30pIHtcXG4gICAgJHt4ZShgaTJvXyR7ZX0oaW5kaWNlcylgLFwidmFsdWVcIil9XFxuICB9YCxDZT11PDI/XCJcIjooKCk9PntsZXQgTj1kLm1hcChwZT0+YGQke3BlfTogdTMyYCkuam9pbihcIiwgXCIpLGRlPWQubWFwKHBlPT5gZCR7cGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcXG4gIGZuIHNldF8ke2V9KCR7Tn0sIHZhbHVlOiAke2d9KSB7XFxuICAgIHNldF8ke2V9QnlJbmRpY2VzKCR7RihkZSl9LCB2YWx1ZSk7XFxuICB9YH0pKCk7cmV0dXJue2ltcGw6KCk9PntsZXQgTj1bXTtyZXR1cm4gc3x8KE4ucHVzaChgY29uc3QgJHtTfSA9ICR7Yi5pbmRpY2VzfSgke3Iuam9pbihcIixcIil9KTtgKSxOLnB1c2goYGNvbnN0ICR7QX0gPSAke2IuaW5kaWNlc30oJHtrLmNvbXB1dGVTdHJpZGVzKHIpLmpvaW4oXCIsXCIpfSk7YCkpLHYub2Zmc2V0VG9JbmRpY2VzJiZOLnB1c2goVyksdi5pbmRpY2VzVG9PZmZzZXQmJk4ucHVzaChfKSx2LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0JiZPYmplY3QudmFsdWVzKEIpLmZvckVhY2goZGU9Pk4ucHVzaChkZSkpLHYuc2V0JiZOLnB1c2goQ2UpLHYuc2V0QnlJbmRpY2VzJiZOLnB1c2goSWUpLHYuZ2V0JiZOLnB1c2goaiksdi5nZXRCeUluZGljZXMmJk4ucHVzaCh3ZSksTi5qb2luKGBcXG5gKX0sdHlwZTpiLG9mZnNldFRvSW5kaWNlczpNLGluZGljZXNUb09mZnNldDp6LGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OkssaW5kaWNlczpGLGluZGljZXNHZXQ6cSxpbmRpY2VzU2V0OmxlLHNldDooLi4uTik9PntpZihOLmxlbmd0aCE9PXUrMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHt1fWApO2xldCBkZT1OW3VdO2lmKHR5cGVvZiBkZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgcGU9Ti5zbGljZSgwLHUpLm1hcCh3KS5qb2luKFwiLFwiKTtyZXR1cm4gdT09PTA/eGUoXCIwdVwiLGRlKTp1PT09MT94ZShwZVswXSxkZSk6KHYuc2V0PSEwLHYuc2V0QnlJbmRpY2VzPSEwLHYuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke3BlfSwgJHtkZX0pYCl9LHNldEJ5T2Zmc2V0OnhlLHNldEJ5SW5kaWNlczooTixkZSk9PnU8Mj94ZShOLGRlKToodi5zZXRCeUluZGljZXM9ITAsdi5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7Tn0sICR7ZGV9KTtgKSxnZXQ6U2UsZ2V0QnlPZmZzZXQ6YWUsZ2V0QnlJbmRpY2VzOk9lLHVzYWdlOm8/XCJpbnB1dFwiOlwib3V0cHV0XCIsbmFtZTplLHN0cmlkZXM6QSxzaGFwZTpTLHJhbms6dX19LEw9KGUsdCxyLG89MSk9PkJvKGUsdCxyLCEwLG8pLFg9KGUsdCxyLG89MSk9PkJvKGUsdCxyLCExLG8pLHZuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXA9dDt0aGlzLmluZGljZXNIZWxwZXJzPVtdO3RoaXMudW5pZm9ybXM9W107dGhpcy52YXJpYWJsZUluZGV4PTB9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh0KXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHt0eXBlb2YgdD09XCJudW1iZXJcIj9gJHt0fXVgOnR9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KHQ9THUpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dFswXSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsxXSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsyXSxzPXRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV09PT0xJiZ0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdPT09MSx1PXM/YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YDpgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaW5kZXggOiB1MzIsXFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+YCxkPXM/XCJsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1wiOmBsZXQgZ2xvYmFsX2lkeCA9ICh3b3JrZ3JvdXBfaWQueiAqICR7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXSp0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdfXUgK1xcbiAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqICR7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXX11ICsgd29ya2dyb3VwX2lkLngpICogJHtyKm8qbn11ICsgbG9jYWxfaW5kZXg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7cn0sICR7b30sICR7bn0pXFxuICBmbiBtYWluKCR7dX0pIHtcXG4gICAgJHtkfVxcbiAgYH1kZWNsYXJlVmFyaWFibGUodCxyKXt0aGlzLmluZGljZXNIZWxwZXJzLnB1c2godCksdC5zaGFwZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zaGFwZS5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTp0LnR5cGUuaW5kaWNlc30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOnQudHlwZS5pbmRpY2VzfSk7bGV0IG89dC51c2FnZT09PVwiaW5wdXRcIj9cInJlYWRcIjpcInJlYWRfd3JpdGVcIixuPXQudHlwZS5zdG9yYWdlO3JldHVybmBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtyfSkgdmFyPHN0b3JhZ2UsICR7b30+ICR7dC5uYW1lfTogYXJyYXk8JHtufT47YH1kZWNsYXJlVmFyaWFibGVzKC4uLnQpe3JldHVybiB0Lm1hcChyPT50aGlzLmRlY2xhcmVWYXJpYWJsZShyLHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbihgXFxuYCl9cmVnaXN0ZXJVbmlmb3JtKHQscil7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LHR5cGU6cn0pLHRoaXN9dW5pZm9ybURlY2xhcmF0aW9uKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IHQ9W107Zm9yKGxldHtuYW1lOnIsdHlwZTpvfW9mIHRoaXMudW5pZm9ybXMpdC5wdXNoKGAke3J9OiR7b31gKTtyZXR1cm5gXFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2B9Z2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKXtyZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSt0aGlzLmluZGljZXNIZWxwZXJzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXFxuYCl9fSxrbz1lPT5uZXcgdm4oZSkseG49KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxvPVtdO2ZvcihsZXQgbj0wO248cjtuKyspe2xldCBzPXItMS1uLHU9ZVtzXXx8MTsodFt0Lmxlbmd0aC0xLW5dfHwxKT4xJiZ1PT09MSYmby51bnNoaWZ0KHMpfXJldHVybiBvfSxEbz1lPT5lPD00fSk7dmFyIEZ1LFdvLEh1LGp1LGd0LHpvLFZvLHJyPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtGdT1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIil9LFdvPShlLHQpPT50JiZ0Lmxlbmd0aCE9PWU/Wy4uLm5ldyBBcnJheShlKS5rZXlzKCldLnJldmVyc2UoKTp0LEh1PShlLHQpPT5rLnNvcnRCYXNlZE9uUGVybShlLFdvKGUubGVuZ3RoLHQpKSxqdT0oZSx0LHIsbyk9PntsZXQgbj1bXTtuLnB1c2goYGZuIHBlcm0oaTogJHtvLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcXG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2ApO2ZvcihsZXQgcz0wO3M8dDsrK3Mpbi5wdXNoKHIuaW5kaWNlc1NldChcImFcIixlW3NdLGBpWyR7c31dYCkpO3JldHVybiBuLnB1c2goXCJyZXR1cm4gYTt9XCIpLG4uam9pbihgXFxuYCl9LGd0PShlLHQpPT57bGV0IHI9ZS5kYXRhVHlwZSxvPWUuZGltcy5sZW5ndGgsbj1XbyhvLHQpLHM9RG8obyksdT1IdShlLmRpbXMsbiksZD1zP3UubGVuZ3RoOnUsYT1zP286ZS5kaW1zLG09WChcIm91dHB1dFwiLHIsZCksZz1MKFwiYVwiLHIsYSkseD1iPT5gXFxuICAke2IucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGcsbSl9XFxuXFxuICAke2p1KG4sbyxnLG0pfVxcblxcbiAgJHtiLm1haW5TdGFydCgpfVxcbiAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxcblxcbiAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcXG5cXG4gICAgJHttLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGcuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxcbiAgfWA7cmV0dXJue25hbWU6XCJUcmFuc3Bvc2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6cz9bXCJyYW5rXCJdOltcImRpbXNcIl19LGdldFJ1bkRhdGE6Yj0+e2xldCB3PWsuc2l6ZSh1KTtyZXR1cm57b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTpiWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwody82NCl9LHByb2dyYW1Vbmlmb3JtczpzP1t7dHlwZTpcInVpbnQzMlwiLGRhdGE6d30sLi4uJG4oYlswXS5kaW1zKSwuLi4kbih1KV06W3t0eXBlOlwidWludDMyXCIsZGF0YTp3fV19fSxnZXRTaGFkZXJTb3VyY2U6eH19LHpvPShlLHQpPT57RnUoZS5pbnB1dHMpLGUuY29tcHV0ZShndChlLmlucHV0c1swXSx0LnBlcm0pKX0sVm89ZT0+aWUoe3Blcm06ZS5wZXJtfSl9KTt2YXIgS3UscXUsWXUsWHUsSnUsWnUsUXUsZWwsdGwscmwsZXQsR28sTm8sVW8sTG8sRm8sSG8sam8sS28scW8sWW8sWG89SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtNcigpO3JyKCk7S3U9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSlcIixsMTpcImJlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0scXU9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDE6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxZdT17bWF4OlwiX0Fbb2Zmc2V0XVwiLG1pbjpcIl9BW29mZnNldF1cIixtZWFuOlwiMFwiLHN1bTpcIjBcIixwcm9kOlwiMVwiLHN1bVNxdWFyZTpcIjBcIixsb2dTdW1FeHA6XCIwXCIsbDE6XCIwXCIsbDI6XCIwXCIsbG9nU3VtOlwiMFwifSxYdT17bWF4OlwiYmVzdFZhbHVlXCIsbWluOlwiYmVzdFZhbHVlXCIsc3VtOlwiYmVzdFZhbHVlXCIscHJvZDpcImJlc3RWYWx1ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZVwiLGxvZ1N1bUV4cDpcImxvZyhiZXN0VmFsdWUpXCIsbDE6XCJiZXN0VmFsdWVcIixsMjpcInNxcnQoYmVzdFZhbHVlKVwiLGxvZ1N1bTpcImxvZyhiZXN0VmFsdWUpXCJ9LEp1PShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBvPXQtZTtvPHQ7KytvKXIucHVzaChvKTtyZXR1cm4gcn0sWnU9KGUsdCk9PntsZXQgcj1bXSxvPWUubGVuZ3RoO2ZvcihsZXQgcz0wO3M8bztzKyspdC5pbmRleE9mKHMpPT09LTEmJnIucHVzaChlW3NdKTtsZXQgbj10Lm1hcChzPT5lW3NdKTtyZXR1cm5bcixuXX0sUXU9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCt0Lmxlbmd0aCxvPVtdLG49MDtmb3IobGV0IHM9MDtzPHI7cysrKXQuaW5kZXhPZihzKT09PS0xP28ucHVzaChlW24rK10pOm8ucHVzaCgxKTtyZXR1cm4gb30sZWw9KGUsdCk9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilpZihlW2UubGVuZ3RoLXItMV0hPT10LTEtcilyZXR1cm4hMTtyZXR1cm4hMH0sdGw9KGUsdCk9PntsZXQgcj1bXTtpZighZWwoZSx0KSl7Zm9yKGxldCBvPTA7bzx0OysrbyllLmluZGV4T2Yobyk9PT0tMSYmci5wdXNoKG8pO2UuZm9yRWFjaChvPT5yLnB1c2gobykpfXJldHVybiByfSxybD0oZSx0LHIsbyxuLHMsdSk9PntsZXQgZD1yWzBdLmRpbXMsYT1rLnNpemUocyksbT1rLnNpemUodSksZz1MKFwiX0FcIixyWzBdLmRhdGFUeXBlLGQpLHg9WChcIm91dHB1dFwiLG4scyksYj0zMix3PWBcXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTwke3gudHlwZS5zdG9yYWdlfSwgJHtifT47XFxuICAgICAgIGA7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTp5PT5gXFxuICAgICAgICAke3kucmVnaXN0ZXJVbmlmb3JtKFwicmVkdWNlU2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZyx4KX1cXG4gICAgICAgICR7d31cXG4gICAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XFxuICAgICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xcbiAgICAgICAgIH1cXG4gICAgICAgICAke3kubWFpblN0YXJ0KGIpfVxcbiAgICAgICAgICBsZXQgbG9jYWxfaWR4ID0gbG9jYWxfaWQueDtcXG5cXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7Yn07XFxuICAgICAgICAgIGxldCBvZmZzZXQgPSBvdXRwdXRJbmRleCAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XFxuXFxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSAke3gudHlwZS5zdG9yYWdlfSgke1l1W29dfSk7XFxuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xcbiAgICAgICAgICBmb3IgKHZhciBrID0gbG9jYWxfaWR4OyBrIDwgTGVuZ3RoOyBrID0gayArICR7Yn0pIHtcXG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSAke3gudHlwZS5zdG9yYWdlfSgke2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXQgKyBrXCIpfSk7XFxuICAgICAgICAgICBiZXN0VmFsdWUgPSAke0t1W29dfTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oTGVuZ3RoLCAke2J9dSk7XFxuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcXG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcXG4gICAgICAgICAgIGxldCBpbnRlcnZhbCA9IERJVl9DRUlMKHJlZHVjZVNpemUsIDJ1KTtcXG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XFxuICAgICAgICAgICAgYmVzdFZhbHVlID0gJHtxdVtvXX07XFxuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcXG4gICAgICAgICAgIH1cXG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcXG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgICAgICB9XFxuXFxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xcbiAgICAgICAgICAke3guc2V0QnlPZmZzZXQoXCJvdXRwdXRJbmRleFwiLGAke289PT1cIm1lYW5cIj9gYmVzdFZhbHVlIC8gJHt4LnR5cGUuc3RvcmFnZX0odW5pZm9ybXMucmVkdWNlU2l6ZSlgOmAke1h1W29dfWB9YCl9O1xcbiAgICAgICAgIH1cXG4gICAgICAgIH1gLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTpufV0sZGlzcGF0Y2hHcm91cDp7eDphfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOlwidWludDMyXCIsZGF0YTptfV19KX19LGV0PShlLHQscixvKT0+e2xldCBuPWUuaW5wdXRzLmxlbmd0aD09PTE/cjpTbihlLmlucHV0cyxyKSxzPW4uYXhlcztzLmxlbmd0aD09PTAmJiFuLm5vb3BXaXRoRW1wdHlBeGVzJiYocz1lLmlucHV0c1swXS5kaW1zLm1hcCgodyx2KT0+dikpO2xldCB1PWsubm9ybWFsaXplQXhlcyhzLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxkPXUsYT1lLmlucHV0c1swXSxtPXRsKGQsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO20ubGVuZ3RoPjAmJihhPWUuY29tcHV0ZShndChlLmlucHV0c1swXSxtKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxkPUp1KGQubGVuZ3RoLGEuZGltcy5sZW5ndGgpKTtsZXRbZyx4XT1adShhLmRpbXMsZCksYj1nO24ua2VlcERpbXMmJihiPVF1KGcsdSkpLGUuY29tcHV0ZShybCh0LHtoaW50Om4uY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sW2FdLG8sZS5pbnB1dHNbMF0uZGF0YVR5cGUsYix4KSx7aW5wdXRzOlthXX0pfSxHbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LE5vPShlLHQpPT57ZXQoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSxVbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0sTG89KGUsdCk9PntldChlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sRm89KGUsdCk9PntldChlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0sSG89KGUsdCk9PntldChlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0sam89KGUsdCk9PntldChlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxLbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxxbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSxZbz0oZSx0KT0+e2V0KGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciB0dCxubCxCcixTbixydCxvbCxhbCxpbCxzbCx1bCxsbCxkbCxjbCxwbCxmbCxudCxKbyxabyxRbyxlYSx0YSxyYSxuYSxvYSxhYSxpYSxZZSxNcj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7WG8oKTt0dD1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZS5sZW5ndGg9PT0yJiZlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4ZXMgaW5wdXQgZGltcy5cIil9LG5sPWU9PltcIlwiLFwiXCIsYHZhciB2YWx1ZSA9ICR7ZS5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwiXCJdLEJyPShlLHQscixvLG4scyx1PSExLGQ9ITEpPT57bGV0IGE9W10sbT1yWzBdLmRpbXMsZz1rLm5vcm1hbGl6ZUF4ZXMobixyWzBdLmRpbXMubGVuZ3RoKSx4PSFkJiZnLmxlbmd0aD09PTA7bS5mb3JFYWNoKCh6LEYpPT57eHx8Zy5pbmRleE9mKEYpPj0wP3UmJmEucHVzaCgxKTphLnB1c2goeil9KTtsZXQgYj1bXSx3PUwoXCJfQVwiLHJbMF0uZGF0YVR5cGUsbSksdj1YKFwib3V0cHV0XCIscyxhKSx5PW8odyx2LGcpLFM9YGlucHV0T2Zmc2V0ID0gJHt3LmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc1wiKX07YCxBPWBsZXQgJHtTfTtgLFI9YHZhciAke1N9O2AsVz15WzFdPT09XCJcIj9cIlwiOlIsTT0oeVsxXT09PVwiXCI/QTpTKStgXFxuYCt5WzJdO2ZvcihsZXQgej0wLEY9MDt6PHJbMF0uZGltcy5sZW5ndGg7eisrKXh8fGcuaW5kZXhPZih6KT49MD8odSYmRisrLE09YGZvcih2YXIgaiR7en06IHUzMiA9IDA7IGoke3p9IDwgJHtyWzBdLmRpbXNbel19OyBqJHt6fSsrKSB7XFxuICAgICAgICAgICAgICAgICR7eVsyXS5pbmNsdWRlcyhcImxhc3RJbmRleFwiKT9gbGV0IGxhc3RJbmRleCA9IGoke3p9O2A6XCJcIn1cXG4gICAgICAgICAgICAgICAgJHt3LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIix6LGBqJHt6fWApfVxcbiAgICAgICAgICAgICAgICAke019XFxuICAgICAgICAgICAgICB9YCk6KGIucHVzaChgJHt3LmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIix6LHYuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixGKSl9O2ApLEYrKyk7bGV0IEQ9ay5zaXplKGEpO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6dCxnZXRTaGFkZXJTb3VyY2U6ej0+YFxcbiAgICAgICAgJHt6LmRlY2xhcmVWYXJpYWJsZXModyx2KX1cXG5cXG4gICAgICAgICR7ei5tYWluU3RhcnQoKX1cXG4gICAgICAgICAgJHt6Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoRCl9XFxuICAgICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7dy50eXBlLmluZGljZXN9O1xcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7di5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgICAgICAgJHtiLmpvaW4oYFxcbmApfVxcbiAgICAgICAgICAke3lbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxcbiAgICAgICAgICAke1d9XFxuICAgICAgICAgICR7eVsxXX1cXG4gICAgICAgICAgJHtNfVxcbiAgICAgICAgICAke3lbM119XFxuICAgICAgICAgICR7eS5sZW5ndGg9PT00P3Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKTp5LnNsaWNlKDQpLmpvaW4oYFxcbmApfVxcbiAgICAgICAgfWAsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChELzY0KX19KX19LFNuPShlLHQpPT57bGV0IHI9W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKSxpZSh7YXhlczpyLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxydD0oZSx0LHIsbyk9PntsZXQgbj1lLmlucHV0cyxzPW4ubGVuZ3RoPT09MT9yOlNuKG4scik7ZS5jb21wdXRlKEJyKHQse2hpbnQ6cy5jYWNoZUtleX0sW25bMF1dLHMubm9vcFdpdGhFbXB0eUF4ZXMmJnMuYXhlcy5sZW5ndGg9PT0wP25sOm8scy5heGVzLG5bMF0uZGF0YVR5cGUscy5rZWVwRGltcyxzLm5vb3BXaXRoRW1wdHlBeGVzKSx7aW5wdXRzOlswXX0pfSxvbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlTG9nU3VtXCIsdCwobyxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LGFsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VMMVwiLHQsKG8sbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBhYnMoJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwiXCJdKX0saWw9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZUwyXCIsdCwobyxuKT0+W2B2YXIgdCA9ICR7bi50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtuLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFwidmFsdWUgPSBzcXJ0KHZhbHVlKTtcIl0pfSxzbD0oZSx0KT0+e3R0KGUuaW5wdXRzKSxydChlLFwiUmVkdWNlTG9nU3VtRXhwXCIsdCwobyxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGV4cCgke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sdWw9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZU1heFwiLHQsKG8sbixzKT0+e2xldCB1PVtdO2ZvcihsZXQgZD0wO2Q8by5yYW5rO2QrKykocy5pbmRleE9mKGQpPj0wfHxzLmxlbmd0aD09PTApJiZ1LnB1c2goby5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsZCwwKSk7cmV0dXJuW2Ake3Uuam9pbihgXFxuYCl9YCxgdmFyIHZhbHVlID0gJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9O2AsYHZhbHVlID0gbWF4KHZhbHVlLCAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX0pO2AsXCJcIl19KX0sbGw9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZU1lYW5cIix0LChvLG4scyk9PntsZXQgdT0xO2ZvcihsZXQgZD0wO2Q8by5yYW5rO2QrKykocy5pbmRleE9mKGQpPj0wfHxzLmxlbmd0aD09PTApJiYodSo9ZS5pbnB1dHNbMF0uZGltc1tkXSk7cmV0dXJuW1widmFyIHN1bSA9IGYzMigwKTtcIixcIlwiLGBzdW0gKz0gZjMyKCR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfSk7YCxgbGV0IHZhbHVlID0gJHtuLnR5cGUudmFsdWV9KHN1bSAvICR7dX0pO2BdfSl9LGRsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VNaW5cIix0LChvLG4scyk9PntsZXQgdT1bXTtmb3IobGV0IGQ9MDtkPG8ucmFuaztkKyspKHMuaW5kZXhPZihkKT49MHx8cy5sZW5ndGg9PT0wKSYmdS5wdXNoKGBpbnB1dEluZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHt1LmpvaW4oYFxcbmApfWAsYHZhciB2YWx1ZSA9ICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9KTtgLFwiXCJdfSl9LGNsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VQcm9kXCIsdCwobyxuKT0+W2B2YXIgdmFsdWUgPSAke24udHlwZS5zdG9yYWdlfSgxKTtgLFwiXCIsYHZhbHVlICo9ICR7by5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtgLFwiXCJdKX0scGw9KGUsdCk9Pnt0dChlLmlucHV0cykscnQoZSxcIlJlZHVjZVN1bVwiLHQsKG8sbik9PltgdmFyIHZhbHVlID0gJHtuLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke28uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07YCxcIlwiXSl9LGZsPShlLHQpPT57dHQoZS5pbnB1dHMpLHJ0KGUsXCJSZWR1Y2VTdW1TcXVhcmVcIix0LChvLG4pPT5bYHZhciB0ID0gJHtuLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke24udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtvLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9OyB2YWx1ZSArPSB0ICogdDtgLFwiXCJdKX0sbnQ9KGUsdCxyKT0+e2lmKHQubGVuZ3RoPT09MClyZXR1cm4hIXI7bGV0IG89MSxuPTE7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdC5pbmRleE9mKHMpPT09LTE/byo9ZVtzXTpuKj1lW3NdO3JldHVybiBuPDMyJiZvPjEwMjR9LEpvPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/bGwoZSx0KTpHbyhlLHQpfSxabz0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2FsKGUsdCk6Tm8oZSx0KX0sUW89KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9pbChlLHQpOlVvKGUsdCl9LGVhPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/c2woZSx0KTpMbyhlLHQpfSx0YT0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3VsKGUsdCk6Rm8oZSx0KX0scmE9KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9kbChlLHQpOkhvKGUsdCl9LG5hPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Y2woZSx0KTpqbyhlLHQpfSxvYT0oZSx0KT0+e250KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3BsKGUsdCk6S28oZSx0KX0sYWE9KGUsdCk9PntudChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9mbChlLHQpOnFvKGUsdCl9LGlhPShlLHQpPT57bnQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/b2woZSx0KTpZbyhlLHQpfSxZZT1lPT5pZShlKX0pO3ZhciBzYSx1YSxsYSxkYSxDbixjYT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtQZSgpO01yKCk7c2E9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sdWE9KGUsdCk9PmllKHtheGlzOnQuYXhpcyxrZWVwRGltczp0LmtlZXBEaW1zLHNlbGVjdExhc3RJbmRleDp0LnNlbGVjdExhc3RJbmRleH0pLGxhPShlLHQpPT57c2EoZS5pbnB1dHMpO2xldCByPShuLHMsdSk9PntsZXQgZD1bXTtmb3IobGV0IGE9MDthPG4ucmFuazthKyspKHUuaW5kZXhPZihhKT49MHx8dS5sZW5ndGg9PT0wKSYmZC5wdXNoKGBpbnB1dEluZGljZXNbJHthfV0gPSAwO2ApO3JldHVybltgJHtkLmpvaW4oYFxcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcXG52YXIgYmVzdEluZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIjw9XCI6XCI8XCJ9IHZhbHVlKSB7XFxuICAgICAgICAgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XFxuICAgICAgICAgYmVzdEluZGV4ID0gaTMyKGxhc3RJbmRleCk7XFxuICAgICAgIH1gLFwiXCIscy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RJbmRleFwiKV19LG89ZS5pbnB1dHMubGVuZ3RoPT09MT90OnVhKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShCcihcIkFyZ01pblwiLHtoaW50Om8uY2FjaGVLZXl9LFtlLmlucHV0c1swXV0scixbby5heGlzXSw3LG8ua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LGRhPShlLHQpPT57c2EoZS5pbnB1dHMpO2xldCByPShuLHMsdSk9PntsZXQgZD1bXTtmb3IobGV0IGE9MDthPG4ucmFuazthKyspKHUuaW5kZXhPZihhKT49MHx8dS5sZW5ndGg9PT0wKSYmZC5wdXNoKGBpbnB1dEluZGljZXNbJHthfV0gPSAwO2ApO3JldHVybltgJHtkLmpvaW4oYFxcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpfTtcXG52YXIgYmVzdEluZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5T2Zmc2V0KFwiaW5wdXRPZmZzZXRcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIj49XCI6XCI+XCJ9IHZhbHVlKSB7XFxuICAgICAgICAgdmFsdWUgPSAke24uZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKX07XFxuICAgICAgICAgYmVzdEluZGV4ID0gaTMyKGxhc3RJbmRleCk7XFxuICAgICAgIH1gLFwiXCIscy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RJbmRleFwiKV19LG89ZS5pbnB1dHMubGVuZ3RoPT09MT90OnVhKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShCcihcImFyZ01heFwiLHtoaW50Om8uY2FjaGVLZXl9LFtlLmlucHV0c1swXV0scixbby5heGlzXSw3LG8ua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LENuPWU9PmllKGUpfSk7dmFyIG1sLGhsLHBhLGZhPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7bWw9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0saGw9ZT0+e2xldCB0PWVbMF0uZGltcyxyPWVbMF0uZGltc1syXSxvPWsuc2l6ZSh0KS80LG49ZVswXS5kYXRhVHlwZSxzPUwoXCJpbnB1dFwiLG4sdCw0KSx1PUwoXCJiaWFzXCIsbixbcl0sNCksZD1MKFwicmVzaWR1YWxcIixuLHQsNCksYT1YKFwib3V0cHV0XCIsbix0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9fSksZ2V0U2hhZGVyU291cmNlOmc9PmBcXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtyfXUgLyA0O1xcbiAgJHtnLmRlY2xhcmVWYXJpYWJsZXMocyx1LGQsYSl9XFxuXFxuICAke2cubWFpblN0YXJ0KCl9XFxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG8pfVxcbiAgICBsZXQgdmFsdWUgPSAke3MuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxcbiAgICAgICsgJHt1LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAlIGNoYW5uZWxzXCIpfSArICR7ZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xcbiAgICAke2Euc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cXG4gIH1gfX0scGE9ZT0+e21sKGUuaW5wdXRzKSxlLmNvbXB1dGUoaGwoZS5pbnB1dHMpKX19KTt2YXIgZ2wsJGUsbWEsaGEsZ2EseWEsYmEsd2EsdmEsJGEseGEsQW4seWwsU2EsQ2EsQWEsSWEsa3IsRWEsRHIsVGEsT2EsX2EsUmEsUGEsTWEsQmEsa2EsRGEsV2EsemEsVmEsR2EsTmEsVWEsTGEsRmEsSW49SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtQZSgpO3ZlKCk7Z2w9KGUsdCxyLG8sbixzKT0+e2xldCB1PU1hdGguY2VpbCh0LzQpLGQ9XCJcIjt0eXBlb2Ygbj09XCJzdHJpbmdcIj9kPWAke259KGEpYDpkPW4oXCJhXCIpO2xldCBhPUwoXCJpbnB1dERhdGFcIixyLFt1XSw0KSxtPVgoXCJvdXRwdXREYXRhXCIsbyxbdV0sNCk7cmV0dXJuYFxcbiAgJHtlLmRlY2xhcmVWYXJpYWJsZXMoYSxtKX1cXG5cXG4gICR7cz8/XCJcIn1cXG5cXG4gICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XFxuXFxuICAgIGxldCBhID0gJHthLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICR7bS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixkKX1cXG4gIH1gfSwkZT0oZSx0LHIsbyxuLHM9ZS5kYXRhVHlwZSk9Pih7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om59LGdldFNoYWRlclNvdXJjZTp1PT5nbCh1LGsuc2l6ZShlLmRpbXMpLGUuZGF0YVR5cGUscyxyLG8pLGdldFJ1bkRhdGE6dT0+KHtvdXRwdXRzOlt7ZGltczplLmRpbXMsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGsuc2l6ZSh1WzBdLmRpbXMpLzY0LzQpfX0pfSksbWE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFic1wiLFwiYWJzXCIpKX0saGE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFjb3NcIixcImFjb3NcIikpfSxnYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQWNvc2hcIixcImFjb3NoXCIpKX0seWE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkFzaW5cIixcImFzaW5cIikpfSxiYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXNpbmhcIixcImFzaW5oXCIpKX0sd2E9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkF0YW5cIixcImF0YW5cIikpfSx2YT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQXRhbmhcIixcImF0YW5oXCIpKX0sJGE9ZT0+aWUoZSkseGE9KGUsdCk9PntsZXQgcjtzd2l0Y2godC50byl7Y2FzZSAxMDpyPVwidmVjNDxmMTY+XCI7YnJlYWs7Y2FzZSAxOnI9XCJ2ZWM0PGYzMj5cIjticmVhaztjYXNlIDEyOnI9XCJ2ZWM0PHUzMj5cIjticmVhaztjYXNlIDY6cj1cInZlYzQ8aTMyPlwiO2JyZWFrO2Nhc2UgOTpyPVwidmVjNDxib29sPlwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSBcXCd0b1xcJyBmcm9tIFxcJ0Nhc3RcXCcgb3BlcmF0b3IpOiAke3QudG99YCl9ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiQ2FzdFwiLHIsdm9pZCAwLHQuY2FjaGVLZXksdC50bykpfSxBbj0oZSx0KT0+e2xldCByPU1lKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsbz0+YGNsYW1wKCR7b30sIGNsaXBfbWluXywgY2xpcF9tYXhfKWAsYFxcbiAgICBjb25zdCBjbGlwX21pbl86IHZlYzQ8JHtyfT4gPSB2ZWM0KCR7cn0oJHt0Lm1pbn0pKTtcXG4gICAgY29uc3QgY2xpcF9tYXhfOiB2ZWM0PCR7cn0+ID0gdmVjNCgke3J9KCR7dC5tYXh9KSk7XFxuYCx0LmNhY2hlS2V5KSx7aW5wdXRzOlswXX0pfSx5bD1lPT57bGV0IHQ9ZS5sZW5ndGg+PTI/ZVsxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTpScixyPWUubGVuZ3RoPj0zP2VbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06UHI7cmV0dXJuIGllKHttaW46dCxtYXg6cn0pfSxTYT1lPT57bGV0IHQ9eWwoZS5pbnB1dHMpO0FuKGUsdCl9LENhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJDZWlsXCIsXCJjZWlsXCIpKX0sQWE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNvc1wiLFwiY29zXCIpKX0sSWE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkNvc2hcIixcImNvc2hcIikpfSxrcj1lPT5pZShlKSxFYT0oZSx0KT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIkVsdVwiLHI9PmBlbHVfdmYzMigke3J9KWAsYFxcbiAgY29uc3QgZWx1X2FscGhhXzogZjMyID0gZjMyKCR7dC5hbHBoYX0pO1xcblxcbiAgZm4gZWx1X2YzMihhOiBmMzIpIC0+IGYzMiB7XFxuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xcbiAgfVxcblxcbiAgZm4gZWx1X3ZmMzIodjogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj4ge1xcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcXG4gIH1gLHQuY2FjaGVLZXkpKX0sRHI9KGUsdD1cImYzMlwiKT0+YFxcbmNvbnN0IHIwOiAke3R9ID0gMC4zMjc1OTExO1xcbmNvbnN0IHIxOiAke3R9ID0gMC4yNTQ4Mjk1OTI7XFxuY29uc3QgcjI6ICR7dH0gPSAtMC4yODQ0OTY3MzY7XFxuY29uc3QgcjM6ICR7dH0gPSAxLjQyMTQxMzc0MTtcXG5jb25zdCByNDogJHt0fSA9IC0xLjQ1MzE1MjAyNztcXG5jb25zdCByNTogJHt0fSA9IDEuMDYxNDA1NDI5O1xcblxcbmZuIGVyZl92ZjMyKHY6ICR7ZX0pIC0+ICR7ZX0ge1xcbiAgbGV0IGFic3YgPSBhYnModik7XFxuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XFxufWAsVGE9ZT0+e2xldCB0PU1lKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJFcmZcIixyPT5gZXJmX3ZmMzIoJHtyfSlgLERyKGB2ZWM0PCR7dH0+YCx0KSkpfSxPYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRXhwXCIsXCJleHBcIikpfSxfYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiRmxvb3JcIixcImZsb29yXCIpKX0sUmE9ZT0+e2xldCB0PU1lKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJHZWx1XCIscj0+YDAuNSAqICR7cn0gKiAoMS4wICsgZXJmX3ZmMzIoJHtyfSAqIDAuNzA3MTA2NzgxMTg2NTQ3NSkpYCxEcihgdmVjNDwke3R9PmAsdCkpKX0sUGE9KGUsdCk9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJMZWFreVJlbHVcIixyPT5gc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHtyfSwgJHtyfSwgJHtyfSA+PSB2ZWM0PGYzMj4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXzogZjMyID0gZjMyKCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpfSxNYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTm90XCIsdD0+YCEke3R9YCkpfSxCYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTmVnXCIsdD0+YC0ke3R9YCkpfSxrYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiUmVjaXByb2NhbFwiLHQ9PmAxLjAvJHt0fWApKX0sRGE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlJlbHVcIix0PT5gc2VsZWN0KHZlYzQ8ZjMyPigwLjApLCAke3R9LCAke3R9ID4gdmVjNDxmMzI+KDAuMCkpYCkpfSxXYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU2lnbW9pZFwiLHQ9PmAoMS4wIC8gKDEuMCArIGV4cCgtJHt0fSkpKWApKX0semE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNpblwiLFwic2luXCIpKX0sVmE9ZT0+e2UuY29tcHV0ZSgkZShlLmlucHV0c1swXSxcIlNpbmhcIixcInNpbmhcIikpfSxHYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiU3FydFwiLFwic3FydFwiKSl9LE5hPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJUYW5cIixcInRhblwiKSl9LFVhPWU9PntlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJUYW5oXCIsXCJ0YW5oXCIpKX0sTGE9KGUsdCk9PihlLmNvbXB1dGUoJGUoZS5pbnB1dHNbMF0sXCJUaHJlc2hvbGRlZFJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8ZjMyPigwLjApLCAke3J9LCAke3J9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV86IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKSwwKSxGYT1lPT57ZS5jb21wdXRlKCRlKGUuaW5wdXRzWzBdLFwiTG9nXCIsXCJsb2dcIikpfX0pO3ZhciB3bCx2bCxIYSxqYT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTt2ZSgpO0luKCk7d2w9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzI1NjAsNTEyMCwxMDI0MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sdmw9ZT0+e2xldCB0PWVbMF0uZGltcy5zbGljZSgpO3RbMl09dFsyXS8yO2xldCByPUwoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLDQpLG89TChcImJpYXNcIixlWzBdLmRhdGFUeXBlLFtlWzBdLmRpbXNbMl1dLDQpLG49WChcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdCw0KSxzPWsuc2l6ZSh0KS80O3JldHVybntuYW1lOlwiQmlhc1NwbGl0R2VsdVwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9fSksZ2V0U2hhZGVyU291cmNlOmQ9PmBcXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XFxuICBjb25zdCBoYWxmQ2hhbm5lbHMgPSAke2VbMF0uZGltc1syXS80LzJ9dTtcXG5cXG4gICR7ZC5kZWNsYXJlVmFyaWFibGVzKHIsbyxuKX1cXG5cXG4gICR7RHIoXCJ2ZWM0ZlwiKX1cXG5cXG4gICR7ZC5tYWluU3RhcnQoKX1cXG4gICAgJHtkLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocyl9XFxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcXG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XFxuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XFxuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xcblxcbiAgICAke24uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XFxuICB9YH19LEhhPWU9Pnt3bChlLmlucHV0cyksZS5jb21wdXRlKHZsKGUuaW5wdXRzKSl9fSk7dmFyICRsLHhsLG90LEthLHFhLFlhLFhhLEphLFphLFFhLGVpLHRpLHJpLG5pPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7dmUoKTskbD0oZSx0LHIsbyxuLHMsdSxkLGEsbSxnKT0+e2xldCB4PWsuc2l6ZShvKSxiPU1hdGguY2VpbCh4LzQpLHcsdjt0eXBlb2YgdT09XCJzdHJpbmdcIj93PXY9KE0sRCk9PmAke3V9KCgke019KSwoJHtEfSkpYDp0eXBlb2YgdT09XCJmdW5jdGlvblwiP3c9dj11Oih3PXUuc2NhbGFyLHY9dS52ZWN0b3IpO2xldCB5PVwiXCIsUz1YKFwib3V0cHV0RGF0YVwiLG0sbyw0KSxBPUwoXCJhRGF0YVwiLGQsdCw0KSxSPUwoXCJiRGF0YVwiLGEsciw0KTtpZihzKXtsZXQgTT1EPT57bGV0IF89ay5jb21wdXRlU3RyaWRlcyhEKSx6PVtdO2ZvcihsZXQgRj1ELmxlbmd0aC0xO0Y+PTA7Ri0tKXtsZXQgcT1TLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsRitvLmxlbmd0aC1ELmxlbmd0aCk7ei5wdXNoKGAke19bRl19dSAqICgke3F9ICUgJHtEW0ZdfXUpYCl9cmV0dXJuIHoubGVuZ3RoPjA/ei5qb2luKFwiK1wiKTpcIjB1XCJ9O3k9YFxcbiAgICAgICAgICBmbiBjYWxjT2Zmc2V0QShvdXRwdXRJbmRpY2VzOiAke1MudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcXG4gICAgICAgICAgICByZXR1cm4gJHtNKHQpfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbiBjYWxjT2Zmc2V0QihvdXRwdXRJbmRpY2VzOiAke1MudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcXG4gICAgICAgICAgICByZXR1cm4gJHtNKHIpfTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYH1sZXQgVztpZihuKWlmKHMpe2xldCBNPWsuc2l6ZSh0KT09PTEsRD1rLnNpemUocik9PT0xO018fEQ/Vz1TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHYoTT9gJHtBLnR5cGUudmFsdWV9KCR7QS5nZXRCeU9mZnNldChcIjBcIil9LngpYDpBLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxEP2Ake1IudHlwZS52YWx1ZX0oJHtSLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOlIuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk6Vz1gXFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeCAqIDR1XCIpfTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9IGNhbGNPZmZzZXRBKG91dHB1dEluZGljZXMpO1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRCID0gY2FsY09mZnNldEIob3V0cHV0SW5kaWNlcyk7XFxuICAgICAgICAgICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHYoQS5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKSxSLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QiAvIDR1XCIpKSl9XFxuICAgICAgICAgIGB9ZWxzZSBXPVMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdihBLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxSLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCBNPShELF8sej1cIlwiKT0+e2xldCBGPWBhRGF0YVtpbmRleEEke199XVtjb21wb25lbnRBJHtffV1gLHE9YGJEYXRhW2luZGV4QiR7X31dW2NvbXBvbmVudEIke199XWA7cmV0dXJuYFxcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHtffSA9ICR7Uy5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7X311YCl9O1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHtffSA9IGNhbGNPZmZzZXRBKG91dHB1dEluZGljZXMke199KTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7X30gPSBjYWxjT2Zmc2V0QihvdXRwdXRJbmRpY2VzJHtffSk7XFxuICAgICAgICAgICAgbGV0IGluZGV4QSR7X30gPSBvZmZzZXRBJHtffSAvIDR1O1xcbiAgICAgICAgICAgIGxldCBpbmRleEIke199ID0gb2Zmc2V0QiR7X30gLyA0dTtcXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7X30gPSBvZmZzZXRBJHtffSAlIDR1O1xcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHtffSA9IG9mZnNldEIke199ICUgNHU7XFxuICAgICAgICAgICAgJHtEfVske199XSA9ICR7en0oJHt3KEYscSl9KTtcXG4gICAgICAgICAgYH07bT09PTk/Vz1gXFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XFxuICAgICAgICAgICAgJHtNKFwiZGF0YVwiLDAsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHtNKFwiZGF0YVwiLDEsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHtNKFwiZGF0YVwiLDIsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHtNKFwiZGF0YVwiLDMsXCJ1MzJcIil9XFxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOlc9YFxcbiAgICAgICAgICAgICR7TShcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cXG4gICAgICAgICAgICAke00oXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XFxuICAgICAgICAgICAgJHtNKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxcbiAgICAgICAgICAgICR7TShcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cXG4gICAgICAgICAgYH1yZXR1cm5gXFxuICAgICAgICAke2UuZGVjbGFyZVZhcmlhYmxlcyhBLFIsUyl9XFxuXFxuICAgICAgICAke2c/P1wiXCJ9XFxuICAgICAgICAke3l9XFxuXFxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhiKX1cXG4gICAgICAgICR7V31cXG4gICAgICB9YH0seGw9KGUsdCxyLG8sbixzLHU9ci5kYXRhVHlwZSk9PntsZXQgZD0hay5hcmVFcXVhbChyLmRpbXMsby5kaW1zKSxhPXIuZGltcyxtPWsuc2l6ZShyLmRpbXMpLGc9ITE7aWYoZCl7bGV0IHg9UWUuY2FsY1NoYXBlKHIuZGltcyxvLmRpbXMsITEpO2lmKCF4KXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7YT14LG09ay5zaXplKGEpO2xldCBiPWsuc2l6ZShyLmRpbXMpPT09MSx3PWsuc2l6ZShvLmRpbXMpPT09MSx2PTE7Zm9yKGxldCB5PTE7eTxhLmxlbmd0aDt5Kyspe2xldCBTPXIuZGltc1tyLmRpbXMubGVuZ3RoLXldPz8xLEE9by5kaW1zW28uZGltcy5sZW5ndGgteV0/PzE7aWYoUz09PUEpdio9UztlbHNlIGJyZWFrfSh2JTQ9PT0wfHxifHx3KSYmKGc9ITApfWVsc2UgZz0hMDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OnR9LGdldFNoYWRlclNvdXJjZTp4PT4kbCh4LHIuZGltcyxvLmRpbXMsYSxnLGQsbixyLmRhdGFUeXBlLG8uZGF0YVR5cGUsdSxzKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6dX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQvNCl9fSl9fSxvdD0oZSx0LHIsbyxuLHMpPT57ZS5jb21wdXRlKHhsKHQsbj8/XCJcIixlLmlucHV0c1swXSxlLmlucHV0c1sxXSxyLG8scykpfSxLYT1lPT57b3QoZSxcIkFkZFwiLCh0LHIpPT5gJHt0fSske3J9YCl9LHFhPWU9PntvdChlLFwiRGl2XCIsKHQscik9PmAke3R9LyR7cn1gKX0sWWE9ZT0+e290KGUsXCJFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fT09JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PT0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LFhhPWU9PntvdChlLFwiTXVsXCIsKHQscik9PmAke3R9KiR7cn1gKX0sSmE9ZT0+e2xldCB0PUwoXCJpbnB1dFwiLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGUuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7b3QoZSxcIlBvd1wiLHtzY2FsYXI6KG8sbik9PmBwb3dfY3VzdG9tKCR7b30sJHtufSlgLHZlY3RvcjoobyxuKT0+YHBvd192ZWN0b3JfY3VzdG9tKCR7b30sJHtufSlgfSxgXFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dH0sIGIgOiAke3R9KSAtPiAke3R9IHtcXG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcXG4gICAgICAgIHJldHVybiAke3R9KDEuMCk7XFxuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0fSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XFxuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0fSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0fSgyLjApKSkgIT0gMS4wKSAqICR7dH0oJHt0PT09XCJpMzJcIj9cInJvdW5kXCI6XCJcIn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XFxuICAgIH1cXG4gICAgZm4gcG93X3ZlY3Rvcl9jdXN0b20oYSA6IHZlYzQ8JHt0fT4sIGIgOiB2ZWM0PCR7dH0+KSAtPiB2ZWM0PCR7dH0+IHtcXG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcXG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XFxuICAgIH1cXG4gICAgICBgKX0sWmE9ZT0+e290KGUsXCJTdWJcIiwodCxyKT0+YCR7dH0tJHtyfWApfSxRYT1lPT57b3QoZSxcIkdyZWF0ZXJcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PiR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sZWk9ZT0+e290KGUsXCJMZXNzXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PCR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fTwke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LHRpPWU9PntvdChlLFwiR3JlYXRlck9yRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT49JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxyaT1lPT57b3QoZSxcIkxlc3NPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PD0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX19KTt2YXIgQ2wsQWwsSWwsRWwsb2ksYWksaWk9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO0NsPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtsZXQgdD1lWzBdLmRhdGFUeXBlLHI9ZVswXS5kaW1zLmxlbmd0aDtmb3IobGV0IG8gb2YgZSl7aWYoby5kYXRhVHlwZSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoby5kaW1zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX19LEFsPWU9PmBcXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcXG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcXG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XFxuICAgICAgICByZXR1cm4gaTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuICR7ZX11O1xcbiAgfWAsSWw9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxvPVtdO2ZvcihsZXQgbj0wO248cjsrK24pe2xldCBzPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtuXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtyPT09MT9vLnB1c2gocyk6bj09PTA/by5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke259dSkgeyAke3N9IH1gKTpuPT09ci0xP28ucHVzaChgZWxzZSB7ICR7c30gfWApOm8ucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke259KSB7ICR7c30gfWApfXJldHVybiBvLmpvaW4oYFxcbmApfSxFbD0oZSx0KT0+e2xldCByPWVbMF0uZGltcy5zbGljZSgpO2lmKHQ+PXIubGVuZ3RofHx0PC0xKnIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc25cXCd0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO2xldCBvPXQ8MD9yLmxlbmd0aCt0OnQsbj1yLnNsaWNlKDApO2ZvcihsZXQgdz0xO3c8ZS5sZW5ndGg7dysrKXtsZXQgdj1lW3ddLmRpbXMuc2xpY2UoKTtmb3IobGV0IHk9MDt5PHIubGVuZ3RoO3krKylpZih5PT09byluW29dKz12W3ldO2Vsc2UgaWYoclt5XSE9PXZbeV0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9bGV0IHM9ay5zaXplKG4pLHU9bmV3IEFycmF5KGUubGVuZ3RoKSxkPW5ldyBBcnJheShlLmxlbmd0aCksYT1lWzBdLmRhdGFUeXBlLG09MDtmb3IobGV0IHc9MDt3PGUubGVuZ3RoOysrdyltKz1lW3ddLmRpbXNbb10sdVt3XT1tLGRbd109TChgaW5wdXQke3d9YCxhLGVbd10uZGltcyk7bGV0IGc9WChcIm91dHB1dFwiLGEsbikseD1nLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyksYj13PT5gXFxuICAke3cuZGVjbGFyZVZhcmlhYmxlcyguLi5kLGcpfVxcblxcbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHt1Lmxlbmd0aH0+KCR7dS5tYXAodj0+YCR7dn11YCkuam9pbihcIixcIil9KTtcXG4gICR7QWwodS5sZW5ndGgpfVxcblxcbiAgJHt3Lm1haW5TdGFydCgpfVxcbiAgICAke3cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzKX1cXG5cXG4gICAgdmFyIGluZGljZXMgPSAke2cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke3h9KTtcXG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcXG4gICAgICAke3h9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcXG4gICAgfVxcblxcbiAgICAke0lsKGQsZyl9XFxuICB9YDtyZXR1cm57bmFtZTpcIkNvbmNhdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6Yn19LG9pPShlLHQpPT57Q2woZS5pbnB1dHMpLGUuY29tcHV0ZShFbChlLmlucHV0cyx0LmF4aXMpKX0sYWk9ZT0+aWUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgV2UsV3IsenIsVnI9SCgoKT0+e1widXNlIHN0cmljdFwiO1dlPShlLHQpPT57c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuYHZlYzI8JHt0fT5gO2Nhc2UgMzpyZXR1cm5gdmVjMzwke3R9PmA7Y2FzZSA0OnJldHVybmB2ZWM0PCR7dH0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtlfS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19LFdyPShlLHQ9ITEscj0hMSxvPTMpPT5cIlwiLHpyPShlLHQpPT5gXFxuICAgICAgJHtlP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpO1wiOlwiXCJ9XFxuICAgICAgLy8gVE9ETyB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lIHdoZW4gYWN0aXZhdGlvbiBpcyBzdXBwb3J0ZWQgYWJvdmUuXFxuICAgICAgLy8gJHt0P1widmFsdWUgPSBhY3RpdmF0aW9uKHZhbHVlLCBjb29yZHMpO1wiOlwiXCJ9XFxuICAgICAgYH0pO3ZhciBHcixFbj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R3I9YFxcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XFxuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxcbiAgICAgIHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudywgc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLncsIDEpKTtcXG59XFxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcXG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXFxuICAgIG91dFNoYXBlU3RyaWRlcy54LCBvdXRTaGFwZVN0cmlkZXMueSwgb3V0U2hhcGVTdHJpZGVzLnosIDEpKTtcXG59XFxuYH0pO3ZhciBOcixVcixucj1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtOcj0oZSx0PSExKT0+e3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwidmFsdWUgPSBtYXgodmFsdWUsIDAuMCk7XCJ9O2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwidmFsdWUgPSAoMS4wIC8gKDEuMCArIGV4cCgtdmFsdWUpKSk7XCJ9O2Nhc2VcIkNsaXBcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOmBjb25zdCBjbGlwX21pbl89ZjMyKCR7ZS5jbGlwTWlufSk7Y29uc3QgY2xpcF9tYXhfPWYzMigke2UuY2xpcE1heH0pO2AsYXBwbHlBY3RpdmF0aW9uOnQ/XCJ2YWx1ZSA9IGNsYW1wKHZhbHVlLCB2ZWM0KGNsaXBfbWluXyksIHZlYzQoY2xpcF9tYXhfKSk7XCI6XCJ2YWx1ZSA9IGNsYW1wKHZhbHVlLCBjbGlwX21pbl8sIGNsaXBfbWF4Xyk7XCJ9O2RlZmF1bHQ6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcIlwifX19LFVyPWU9PntsZXQgdD1lPy5hY3RpdmF0aW9ufHxcIlwiO2lmKHQ9PT1cIkNsaXBcIil7bGV0W3Isb109ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtScixQcl07cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4Om8sY2xpcE1pbjpyLGFjdGl2YXRpb25DYWNoZUtleTpgJHt0fToke3J9LCR7b31gfX1yZXR1cm57YWN0aXZhdGlvbjp0LGFjdGl2YXRpb25DYWNoZUtleTp0fX19KTt2YXIgVGwsT2wsb3Isc2ksX2wsYXIsUmwsTHIsaXI9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtucigpO1ZyKCk7VGw9KGUsdCk9PmU/YFxcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgYDpgXFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgYCxPbD0oZSx0KT0+ZT9gXFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XFxuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcXG4gICAgICAgICR7dD09PTM/XCJcIjpcImxldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107XCJ9XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XFxuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07XCJ9XFxuICAgICAgICB9YDpgXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XFxuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XFxuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldO1wifVxcbiAgICAgICAgfWAsb3I9KGUsdCxyPVwiZjMyXCIsbyxuPSExLHM9MzIsdT0hMSxkPTMyKT0+e2xldCBhPXRbMV0qZVsxXSxtPXRbMF0qZVswXSxnPW4/YTpzLHg9bj9zOmEsYj1nL3RbMF0sdz1zL3RbMV07aWYoISgobiYmYj09PTQmJmVbMV09PT00fHwhbiYmKGI9PT0zfHxiPT09NCkpJiZnJXRbMF09PT0wJiZzJXRbMV09PT0wJiZlWzBdPT09NCkpdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7bn0gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke2J9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxcbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2J9IG11c3QgYmUgMyBvciA0LlxcbiAgdGlsZUFXaWR0aCAke2d9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHtzfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHtifTwke3J9PiwgJHtnL2J9PiwgJHt4fT47XFxudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke3J9PiwgJHttL2VbMF19PiwgJHtzfT47XFxuXFxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcXG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke2J9O1xcbmNvbnN0IHRpbGVJbm5lciA9ICR7c307XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXFxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XFxuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcXG5cXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcXG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XFxuICBsZXQgYmF0Y2ggPSAke3U/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XFxuICAke28/YGxldCBiYXRjaEluZGljZXMgPSAke28ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxcbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHthfTtcXG5cXG4gIGxldCBudW1UaWxlcyA9ICR7dT9gJHtNYXRoLmNlaWwoZC9zKX1gOlwiKGRpbUlubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xcbiAgdmFyIGtTdGFydCA9ICR7dT9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xcblxcbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke3J9Piwgcm93UGVyVGhyZWFkPjtcXG5cXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxcbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke3d9O1xcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcXG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcXG4gICAgICAgICAgJHtUbChuLG8pfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7d307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XFxuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XFxuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHtvP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgfVxcbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XFxuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xcbiAgICAgICAgICAke2I9PT0zP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XFxuXFxuICAgICAgICAgICR7T2wobixiKX1cXG4gICAgICB9XFxuXFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XFxuICB9XFxufWB9LHNpPShlLHQpPT5lP2BcXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgICAgIGA6YFxcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgICAgICAgYCxfbD1lPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIixhcj0oZSx0LHI9XCJmMzJcIixvLG49ITEscz0zMix1PSExLGQ9MzIsYT0hMSk9PntsZXQgbT1lWzFdKnRbMV0sZz1lWzBdKnRbMF0seD1uP206cyxiPW4/czptO2lmKCEoYiV0WzFdPT09MCYmeCV0WzBdPT09MCYmcyV0WzFdPT09MCkpdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7Yn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHt4fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7c30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtsZXQgdz1iL3RbMV0sdj14L3RbMF0seT1zL3RbMV0sUz1hP2BcXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XFxuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke219O1xcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke2d9O1xcblxcbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtifTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcXG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt4fTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcXG4gICAgICAgICAgJHtzaShuLG8pfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3N9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHtnfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcXG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXFxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7bz9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxcbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7dFswXX1dO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke24/YG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dO2A6YG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dW2tdO2B9XFxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXFxuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgIH1cXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX07XFxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt0WzBdfTtcXG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGA6YFxcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XFxubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcXG5cXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XFxubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHttfTtcXG5cXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7d307XFxubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke3Z9O1xcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHt5fTtcXG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3d9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHt2fTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XFxuICAgICAgJHtzaShuLG8pfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXFxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHt5fTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcXG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke28/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgfVxcbiAgfVxcbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xcbiAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXFxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XFxuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XFxuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XFxuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICAke19sKG4pfVxcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgd29ya2dyb3VwQmFycmllcigpO1xcbn1cXG5cXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcXG4gIH1cXG59XFxuYDtyZXR1cm5gXFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHt4fT4sICR7Yn0+O1xcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7Z30+LCAke3N9PjtcXG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XFxuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xcbiAgY29uc3QgdGlsZUlubmVyID0gJHtzfTtcXG5cXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XFxuICAgIGxldCBiYXRjaCA9ICR7dT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcXG4gICAgJHtvP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtvLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cXG4gICAgbGV0IG51bVRpbGVzID0gJHt1P2Ake01hdGguY2VpbChkL3MpfWA6XCIoZGltSW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XFxuICAgIHZhciBrU3RhcnQgPSAke3U/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcXG5cXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XFxuXFxuICAgIC8vIFdpdGhvdXQgdGhpcyBpbml0aWFsaXphdGlvbiBzdHJhbmdlIHZhbHVlcyBzaG93IHVwIGluIGFjYy5cXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSAwLjA7XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7U31cXG4gIH1cXG5gfSxSbD0oZSx0LHIsbyxuLHM9ITEpPT57bGV0IHU9blswXSxkPW5bMV0sYT1uWzJdLG09b1swXSxnPW9bMV0seD1vWzJdLGI9b1szXSx3PXhuKHUsYSksdj14bihkLGEpLHk9TWUob1swXS50eXBlLnRlbnNvciksUz0oKT0+e2xldCBXPWcucmFuayxNPW0ucmFuayxEPWB2YXIgYUluZGljZXM6ICR7Zy50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBfPVctMi0xLHo9TS0xO18+PTA7Xy0tLHotLSlEKz1gXFxuYUluZGljZXNbJHtffV0gPSAke00+MT9gYmF0Y2hJbmRpY2VzWyR7en1dYDpcImJhdGNoSW5kaWNlc1wifTtgO3JldHVybiB3LmZvckVhY2goXz0+e0QrPWBcXG5hSW5kaWNlc1ske199XSA9IDA7YH0pLEQrPWBcXG5hSW5kaWNlc1ske1ctMn1dID0gdTMyKHJvdyk7XFxuICAgICAgICAgICAgICAgICAgIGFJbmRpY2VzWyR7Vy0xfV0gPSB1MzIoY29sSW4pO2AsRH0sQT0oKT0+e2xldCBXPXgucmFuayxNPW0ucmFuayxEPWB2YXIgYkluZGljZXM6ICR7eC50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBfPVctMi0xLHo9TS0xO18+PTA7Xy0tLHotLSlEKz1gXFxuYkluZGljZXNbJHtffV0gPSAke00+MT9gYmF0Y2hJbmRpY2VzWyR7en1dYDpcImJhdGNoSW5kaWNlc1wifTtgO3JldHVybiB2LmZvckVhY2goXz0+e0QrPWBcXG5iSW5kaWNlc1ske199XSA9IDA7YH0pLEQrPWBcXG5iSW5kaWNlc1ske1ctMn1dID0gdTMyKHJvdyk7XFxuICAgICAgICAgICAgICAgICAgIGJJbmRpY2VzWyR7Vy0xfV0gPSB1MzIoY29sSW4pO2AsRH07cmV0dXJuYFxcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke20udHlwZS5pbmRpY2VzfSkgLT4gJHtXZShlLHkpfSB7XFxuICAgICAgdmFyIHZhbHVlID0gJHtXZShlLHkpfSgwLjApO1xcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XFxuICAgICAgaWYocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUlubmVyKVxcbiAgICAgIHtcXG4gICAgICAgICR7UygpfVxcbiAgICAgICAgdmFsdWUgPSAke2cuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHttLnR5cGUuaW5kaWNlc30pIC0+ICR7V2UoZSx5KX0ge1xcbiAgICAgIHZhciB2YWx1ZSA9ICR7V2UoZSx5KX0oMC4wKTtcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xcbiAgICAgIGlmKHJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlcilcXG4gICAgICB7XFxuICAgICAgICAke0EoKX1cXG4gICAgICAgIHZhbHVlID0gJHt4LmdldEJ5SW5kaWNlcyhcImJJbmRpY2VzXCIpfTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke1dlKGUseSl9KSB7XFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcXG4gICAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcXG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xcbiAgICAgICAgJHt0P2B2YWx1ZSA9IHZhbHVlICsgJHtzP1wiYmlhc1tjb2xJbl1cIjpgJHtXZShlLHkpfShiaWFzW3Jvd10pYH07YDpcIlwifVxcbiAgICAgICAgJHtyfVxcbiAgICAgICAgJHtiLnNldEJ5SW5kaWNlcyhcInZlYzM8dTMyPihjb29yZHMpXCIsXCJ2YWx1ZVwiKX1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgYH0sTHI9KGUsdCxyLG8sbj0hMSk9PntsZXQgcz1lWzBdLmRpbXMsdT1lWzFdLmRpbXMsZD1zLnNsaWNlKDAsLTIpLGE9dS5zbGljZSgwLC0yKSxtPW8/by5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLGc9TChcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUsbSkseD1bZ10sYj1bZCxhLG1dLHc9ay5zaXplKG0pLHY9c1tzLmxlbmd0aC0yXSx5PXNbcy5sZW5ndGgtMV0sUz11W3UubGVuZ3RoLTFdLEE9eSU0PT09MCYmUyU0PT09MCx7YWN0aXZhdGlvbkZ1bmN0aW9uOlIsYXBwbHlBY3RpdmF0aW9uOld9PU5yKHQsQSksTT12PD04P1s0LDEsMV06WzQsNCwxXSxEPVs4LDgsMV0sXz1bTWF0aC5jZWlsKFMvRFswXS9NWzBdKSxNYXRoLmNlaWwodi9EWzFdL01bMV0pLE1hdGguY2VpbCh3L0RbMl0vTVsyXSldLHo9TWUoZVswXS5kYXRhVHlwZSksRj1BPzQ6MSxxPUwoXCJhXCIsZVswXS5kYXRhVHlwZSxbLi4uZCx2LHkvRl0sRiksbGU9TChcImJcIixlWzFdLmRhdGFUeXBlLFsuLi5hLHksUy9GXSxGKSxCPVgoXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLFt3LHYsUy9GXSxGKTt4LnB1c2gocSkseC5wdXNoKGxlKSx4LnB1c2goQik7bGV0IEs9W3EsbGVdLHhlPWUubGVuZ3RoPjIsYWU9UmwoRix4ZSxXLHgsYixuKTtpZih4ZSl7bGV0IGo9bj9GOjE7Sy5wdXNoKEwoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaikpfWxldCB3ZT1qPT5gXFxuICBjb25zdCBkaW1BT3V0ZXI6IGkzMiA9ICR7dn07XFxuICBjb25zdCBkaW1CT3V0ZXI6IGkzMiA9ICR7U307XFxuICBjb25zdCBkaW1Jbm5lcjogaTMyID0gJHt5fTtcXG4gICR7ai5kZWNsYXJlVmFyaWFibGVzKC4uLkssQil9XFxuICAke1J9XFxuICAke2FlfVxcbiAgJHtBP29yKE0sRCx6LGcpOmFyKE0sRCx6LGcpfVxcbiAgICAgICAgICAgICAgICAgICAke2cuaW1wbCgpfWA7cmV0dXJue25hbWU6XCJNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDp0LmFjdGl2YXRpb25DYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ol9bMF0seTpfWzFdLHo6X1syXX19KSxnZXRTaGFkZXJTb3VyY2U6d2V9fX0pO3ZhciBQbCx1aSxsaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bXQoKTtnZSgpO3ZlKCk7VnIoKTtFbigpO2lyKCk7UGw9KGUsdCxyLG8sbj0hMSxzLHU9ITEsZD00LGE9NCxtPTQsZz1cImYzMlwiKT0+e2xldCB4PWxlPT57c3dpdGNoKGxlKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHtnfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7bGV9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxiPWxlPT57c3dpdGNoKGxlKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiB3U2hhcGVbM10gKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogd1NoYXBlWzNdIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2xlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sdz1lP2BcXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Um93LCB4Q29sLCB4Q2gpO1xcbiAgICBgOmBcXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xcbiAgICBgLHY9ZT9gXFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXFxuICAgICAgYmF0Y2gsXFxuICAgICAgcm93IC8gb3V0V2lkdGgsXFxuICAgICAgcm93ICUgb3V0V2lkdGgsXFxuICAgICAgY29sKTtcXG4gICAgYDpgXFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXFxuICAgICAgYmF0Y2gsXFxuICAgICAgcm93LFxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcXG4gICAgYCx5PWU/XCJ4U2hhcGVbMV1cIjpcInhTaGFwZVsyXVwiLFM9ZT9cInhTaGFwZVsyXVwiOlwieFNoYXBlWzNdXCIsQT1lP1wicm93XCI6XCJjb2xcIixSPWU/XCJjb2xcIjpcInJvd1wiLFc9YFxcbiAgICBsZXQgaW5DaGFubmVscyA9IHdTaGFwZVsyXTtcXG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xcbiAgICBsZXQgb3V0Um93ID0gJHtBfSAvIG91dFdpZHRoO1xcbiAgICBsZXQgb3V0Q29sID0gJHtBfSAlIG91dFdpZHRoO1xcblxcbiAgICBsZXQgV1JvdyA9ICR7Un0gLyAoZmlsdGVyRGltc1sxXSAqIGluQ2hhbm5lbHMpO1xcbiAgICBsZXQgV0NvbCA9ICR7Un0gLyBpbkNoYW5uZWxzICUgZmlsdGVyRGltc1sxXTtcXG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiBzdHJpZGVbMF0gKyBkaWxhdGlvblswXSAqIFdSb3cgLSBwYWRbMF07XFxuICAgIGxldCB4Q29sID0gb3V0Q29sICogc3RyaWRlWzFdICsgZGlsYXRpb25bMV0gKiBXQ29sIC0gcGFkWzFdO1xcbiAgICBsZXQgeENoID0gJHtSfSAlIGluQ2hhbm5lbHM7XFxuICAgIHZhciByZXNEYXRhID0gJHtXZShkLGcpfSgwLjApO1xcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxcbiAgICAvLyB0aGUgXFwnc2FtZVxcJyBwYWRkaW5nIHR5cGUuXFxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eX0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke1N9KSB7XFxuICAgICAgJHt3fVxcbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgeFNoYXBlKTtcXG4gICAgICAke3goZCl9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc0RhdGE7YCxNPWU/dCYmbz9gXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XFxuICAgICR7V31gOmBcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtkfTtcXG4gICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1Jbm5lcikge1xcbiAgICAgICR7V31cXG4gICAgfVxcbiAgICByZXR1cm4gJHtXZShkLGcpfSgwLjApO2A6byYmcj9gXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XFxuICAgICR7V31gOmBcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtkfTtcXG4gICAgaWYgKHJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xcbiAgICAgICR7V31cXG4gICAgfVxcbiAgICByZXR1cm4gJHtXZShkLGcpfSgwLjApO2AsRD1gJHtiKGEpfWAsXz1XZShtLGcpLHo9ZT9XZShkLGcpOldlKGEsZyksRj1lP1dlKGEsZyk6V2UoZCxnKTtyZXR1cm5gXFxuICAgICR7V3Iocyx1LG09PT00LDQpfVxcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3p9IHtcXG4gICAgICAke2U/TTpEfVxcbiAgICB9XFxuXFxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7Rn0ge1xcbiAgICAgICR7ZT9EOk19XFxuICAgIH1cXG5cXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7X30pIHtcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke219O1xcbiAgICAgIGlmIChyb3cgPCBkaW1BT3V0ZXIgJiYgY29sIDwgZGltQk91dGVyKVxcbiAgICAgIHtcXG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcXG4gICAgICAke3Z9XFxuICAgICAgJHt6cihuLHMpfVxcbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfWB9LHVpPShlLHQscixvLG4scyx1LGQpPT57bGV0IGE9dC5mb3JtYXQ9PT1cIk5IV0NcIixtPWE/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxnPXJbMF0seD1hP3JbMl06clszXSxiPWE/clsxXTpyWzJdLHc9YT9yWzNdOnJbMV0sdj1hJiYobSU0PT09MHx8bSUzPT09MCkmJnclND09PTAseT1hP3c6eCpiLFM9YT94KmI6dyxBPVs4LDgsMV0sUj1vPD04P1s0LDEsMV06WzQsNCwxXSxXPVtNYXRoLmNlaWwoeS9BWzBdL1JbMF0pLE1hdGguY2VpbChTL0FbMV0vUlsxXSksTWF0aC5jZWlsKGcvQVsyXS9SWzJdKV07RWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke1d9YCk7bGV0IE09dj9hJiZtJTQhPT0wPzM6NDpSWzBdLEQ9QVsxXSpSWzFdLF89QVswXSpSWzBdLHo9TWF0aC5tYXgoQVswXSpNLEFbMV0pLEY9byVEPT09MCxxPW4lXz09PTAsbGU9cyV6PT09MCxCPXY/W00sNCw0XTpbMSwxLDFdLEs9TWUoZVswXS5kYXRhVHlwZSkseGU9W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHg6IGFycmF5PCR7diYmTT09PTQ/YHZlYzQ8JHtLfT5gOkt9PjtgLGBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHc6IGFycmF5PCR7dj9gdmVjNDwke0t9PmA6S30+O2BdLGFlPWBcXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke3Y/YHZlYzQ8JHtLfT5gOkt9KSB7XFxuICAgICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7dj9gdmVjNDwke0t9PmA6S30odmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke3Y/YHZlYzQ8JHtLfT5gOkt9KSB7XFxuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggJHt2P1wiLyA0XCI6XCJcIn0sIHZhbHVlKTtcXG4gICAgICB9YDtyZXR1cm4gdSYmKHhlLnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhczogYXJyYXk8JHt2P2B2ZWM0PCR7S30+YDpLfT47YCksYWUrPWBcXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7dj9gdmVjNDwke0t9PmA6S30ge1xcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHthP1wid1wiOlwieVwifSR7dj9cIi8gNFwiOlwiXCJ9XTtcXG4gICAgICAgIH1gKSx7bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpXWzBdLHk6V1sxXSx6OldbMl19fSksZ2V0U2hhZGVyU291cmNlOigpPT5gXFxuICAgICAgICAke0dyfVxcbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXFxuICAgICAgICAvLyAgb3V0U2hhcGVTdHJpZGVzOiB2ZWMzPGkzMj4sIGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4sIHBhZCA6IHZlYzI8aTMyPiwgc3RyaWRlIDogdmVjMjxpMzI+LFxcbiAgICAgICAgLy8gIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIgfTtcXG4gICAgICAgICR7eGUuam9pbihcIlwiKX1cXG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygke3hlLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PCR7dj9gdmVjNDwke0t9PmA6S30+O1xcbiAgICAgICAgLy9AZ3JvdXAoMCkgQGJpbmRpbmcoJHt4ZS5sZW5ndGgrMX0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XFxuXFxuICAgICAgICBjb25zdCB4U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzBdLmRpbXMuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHdTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMV0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtyLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBvdXRTaGFwZVN0cmlkZXMgOiB2ZWMzPGkzMj4gPSB2ZWMzPGkzMj4oJHtrLmNvbXB1dGVTdHJpZGVzKHIpLnNsaWNlKDAsMykuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0Lmtlcm5lbFNoYXBlWzBdfSwgJHt0Lmtlcm5lbFNoYXBlWzFdfSk7XFxuICAgICAgICBjb25zdCBwYWQgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHt0LnBhZHNbMF19LCAke3QucGFkc1sxXX0pO1xcbiAgICAgICAgY29uc3Qgc3RyaWRlIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5zdHJpZGVzWzBdfSwgJHt0LnN0cmlkZXNbMV19KTtcXG4gICAgICAgIGNvbnN0IGRpbGF0aW9uIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7dC5kaWxhdGlvbnNbMF19LCAke3QuZGlsYXRpb25zWzFdfSk7XFxuICAgICAgICBjb25zdCBkaW1BT3V0ZXIgOiBpMzIgPSAke299O1xcbiAgICAgICAgY29uc3QgZGltQk91dGVyIDogaTMyID0gJHtufTtcXG4gICAgICAgIGNvbnN0IGRpbUlubmVyIDogaTMyID0gJHtzfTtcXG4gICAgICAgICR7YWV9XFxuICAgICAgICAke1BsKGEsRixxLGxlLHUsdC5hY3RpdmF0aW9uLnRvTG93ZXJDYXNlKCksITEsQlswXSxCWzFdLEJbMl0sSyl9XFxuICAgICAgICAgICAgJHt2P29yKFIsQSxLLHZvaWQgMCwhYSx6KTphcihSLEEsSyx2b2lkIDAsIWEseiwhMSx2b2lkIDAsZCl9YH19fSk7dmFyIFRuLGRpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO3ZlKCk7X24oKTtucigpO1RuPShlLHQscik9PntsZXQgbz1lLmxlbmd0aD4yLG49bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIscz1lWzBdLmRpbXMsdT1lWzFdLmRpbXMsZD11WzBdL3QuZ3JvdXAse2FjdGl2YXRpb25GdW5jdGlvbjphLGFwcGx5QWN0aXZhdGlvbjptfT1Ocih0KSxnPXQuZm9ybWF0PT09XCJOSFdDXCIseD1PbihzLHUsdC5kaWxhdGlvbnMsdC5wYWRzLHQuc3RyaWRlcyxnKSxiPWsuc2l6ZSh4KSx3PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHgpLHY9TChcInhcIixlWzBdLmRhdGFUeXBlLHMpLHk9TChcIndcIixlWzFdLmRhdGFUeXBlLHUpLFM9W3YseV07byYmUy5wdXNoKEwoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMpKTtsZXQgQT1SPT5gXFxuICBjb25zdCBzdHJpZGVzOiB2ZWMyPHUzMj4gPSB2ZWMyKCR7dC5zdHJpZGVzWzBdfXUsICR7dC5zdHJpZGVzWzFdfXUpO1xcbiAgY29uc3QgcGFkczogdmVjMjx1MzI+ID0gdmVjMigke3QucGFkc1swXX11LCAke3QucGFkc1sxXX11KTtcXG5cXG4gICR7Ui5kZWNsYXJlVmFyaWFibGVzKC4uLlMsdyl9XFxuXFxuICAke2F9XFxuXFxuICAke1IubWFpblN0YXJ0KCl9XFxuICAgICR7Ui5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGIpfVxcblxcbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHtnPzM6MX1dO1xcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2c/MToyfV0sIG91dHB1dEluZGljZXNbJHtnPzI6M31dKSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsIC8gJHtkfXU7XFxuXFxuICAgIHZhciB2YWx1ZTogJHt3LnR5cGUudmFsdWV9ID0gJHt3LnR5cGUudmFsdWV9KDApO1xcbiAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8ICR7dVsxXX11OyB3SW5DaGFubmVsKyspIHtcXG4gICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHt1WzFdfXUgKyB3SW5DaGFubmVsO1xcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgJHt1WzJdfXU7IHdIZWlnaHQrKykge1xcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3QuZGlsYXRpb25zWzBdfXU7XFxuXFxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gJHtzW2c/MToyXX11KSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgJHt1WzNdfXU7IHdXaWR0aCsrKSB7XFxuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqICR7dC5kaWxhdGlvbnNbMV19dTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSAke3NbZz8yOjNdfXUpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsZXQgeFZhbCA9ICR7Zz92LmdldChcImJhdGNoXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIixcImlucHV0X2NoYW5uZWxcIik6di5nZXQoXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIpfTtcXG4gICAgICAgICAgbGV0IHdWYWwgPSAke3kuZ2V0KFwib3V0cHV0X2NoYW5uZWxcIixcIndJbkNoYW5uZWxcIixcIndIZWlnaHRcIixcIndXaWR0aFwiKX07XFxuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtufVxcbiAgICAke219XFxuICAgICR7dy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxcbiAgfWA7cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cj9yKHgpOngsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGIvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpBfX19KTt2YXIgT24sY2ksTWwscGksUm4sQmwsa2wsUG4sX249SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTtsaSgpO2lyKCk7ZGkoKTtucigpO3JyKCk7T249KGUsdCxyLG8sbixzKT0+e2xldCB1PWVbMF0sZD1lLnNsaWNlKHM/MToyLHM/Mzo0KSxhPWQubGVuZ3RoLG09dFswXSx4PXQuc2xpY2UoMikubWFwKCh2LHkpPT52Kyh2LTEpKihyW3ldLTEpKSx3PWQubWFwKCh2LHkpPT52K29beV0rb1t5K2FdKS5tYXAoKHYseSk9Pk1hdGguZmxvb3IoKHYteFt5XStuW3ldKS9uW3ldKSk7cmV0dXJuIHcuc3BsaWNlKDAsMCx1KSx3LnNwbGljZShzPzM6MSwwLG0pLHd9LGNpPVsyLDMsMSwwXSxNbD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgY29udiAxRCBhbmQgMkRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLG89ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYociE9PW8pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IG49ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke259RGApO2lmKHQucGFkcy5sZW5ndGghPT1uKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke24qMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKX0scGk9KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7Zm9yKGxldCBzPTI7czx0WzFdLmRpbXMubGVuZ3RoOysrcylyW3MtMl09PT0wJiYocltzLTJdPXRbMV0uZGltc1tzXSk7bGV0IG89ZS5wYWRzLnNsaWNlKCk7Q3QuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHRbMF0uZGltcyxlLnN0cmlkZXMsZS5kaWxhdGlvbnMscixvLGUuZm9ybWF0PT09XCJOSFdDXCIsZS5hdXRvUGFkKTtsZXQgbj1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKG4se2tlcm5lbFNoYXBlOnIscGFkczpvLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxufSxSbj1lPT57bGV0IHQ9VXIoZSkscj1lLmZvcm1hdCxvPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sbj1lLmRpbGF0aW9ucyxzPWUuZ3JvdXAsdT1lLmtlcm5lbF9zaGFwZSxkPWUucGFkcyxhPWUuc3RyaWRlcyxtPWUud19pc19jb25zdCgpO3JldHVybiBpZSh7YXV0b1BhZDpvLGZvcm1hdDpyLGRpbGF0aW9uczpuLGdyb3VwOnMsa2VybmVsU2hhcGU6dSxwYWRzOmQsc3RyaWRlczphLHdJc0NvbnN0Om0sLi4udH0pfSxCbD0oZSx0LHIpPT57bGV0IG89cGkocix0KTtpZihyLmdyb3VwIT09MSl7ZS5jb21wdXRlKFRuKHQsbykpO3JldHVybn1sZXQgbj1yLmZvcm1hdD09PVwiTkhXQ1wiLHM9dC5sZW5ndGg9PT0zLHU9dFswXS5kaW1zW24/MToyXSxkPXRbMF0uZGltc1tuPzI6M10sYT10WzBdLmRpbXNbbj8zOjFdLG09dFsxXS5kaW1zWzJdLGc9dFsxXS5kaW1zWzNdLHg9T24odFswXS5kaW1zLHRbMV0uZGltcyxyLmRpbGF0aW9ucyxvLnBhZHMsci5zdHJpZGVzLG4pLGI9eFtuPzE6Ml0sdz14W24/MjozXSx2PXhbbj8zOjFdLHk9biYmbT09PXUmJmc9PT1kJiZyLnBhZHNbMF09PT0wJiZyLnBhZHNbMV09PT0wO2lmKHl8fG09PT0xJiZnPT09MSYmci5kaWxhdGlvbnNbMF09PT0xJiZyLmRpbGF0aW9uc1sxXT09PTEmJnIuc3RyaWRlc1swXT09PTEmJnIuc3RyaWRlc1sxXT09PTEmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTApe2xldCBfPXhbMF0seixGLHEsbGU9W107aWYobil7bGV0IEI9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoZ3QodFsxXSxjaSkse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtpZihyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPUIpLHkpe2xldCBLPXUqZCphO3o9dFswXS5yZXNoYXBlKFsxLF8sS10pLEY9Qi5yZXNoYXBlKFsxLEssdl0pLHE9WzEsXyx2XX1lbHNlIHo9dFswXS5yZXNoYXBlKFtfLHUqZCxhXSksRj1CLnJlc2hhcGUoWzEsYSx2XSkscT1bXyxiKncsdl07bGUucHVzaCh6KSxsZS5wdXNoKEYpfWVsc2Ugej10WzBdLnJlc2hhcGUoW18sYSx1KmRdKSxGPXRbMV0ucmVzaGFwZShbMSx2LGFdKSxxPVtfLHYsYip3XSxsZS5wdXNoKEYpLGxlLnB1c2goeik7cyYmbGUucHVzaCh0WzJdKSxlLmNvbXB1dGUoTHIobGUsbyx4LHEsbikse2lucHV0czpsZX0pO3JldHVybn1sZXQgUz0hMCxBPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKGd0KHRbMV0sY2kpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1BKTtsZXQgUj1bdFswXSxBXTtzJiZSLnB1c2godFsyXSk7bGV0IFc9bj9iKnc6dixNPW4/djpiKncsRD1tKmcqYTtlLmNvbXB1dGUodWkoUixvLHgsVyxNLEQscyxTKSx7aW5wdXRzOlJ9KX0sa2w9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG89W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm8ucHVzaChlLmlucHV0c1syXSk7bGV0IG49WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSxzPVsxXS5jb25jYXQodC5zdHJpZGVzKSx1PVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLGQ9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSxhPXBpKHsuLi50LHBhZHM6bixzdHJpZGVzOnMsZGlsYXRpb25zOnUsa2VybmVsU2hhcGU6ZH0sbyk7ZS5jb21wdXRlKFRuKG8sYSxtPT5yP1ttWzBdLG1bMl0sbVszXV06W10pKX0sUG49KGUsdCk9PntNbChlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTM/a2woZSx0KTpCbChlLGUuaW5wdXRzLHQpfX0pO3ZhciBEbCxmaSxtaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bXQoKTtnZSgpO1ZyKCk7RW4oKTtpcigpO0RsPShlLHQ9ITEscixvPSExLG49NCk9PntsZXQgcz1XZShuLFwiZjMyXCIpLHU9QT0+e3N3aXRjaChBKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgd1NoYXBlKV07XCI7Y2FzZSA0OnJldHVybmBcXG4gICAgICAgICAgICBsZXQgY29vcmQxID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAxLCByb3dJbm5lcik7XFxuICAgICAgICAgICAgbGV0IGNvb3JkMiA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMiwgcm93SW5uZXIpO1xcbiAgICAgICAgICAgIGxldCBjb29yZDMgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDMsIHJvd0lubmVyKTtcXG4gICAgICAgICAgICBsZXQgdjAgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB3U2hhcGUpXTtcXG4gICAgICAgICAgICBsZXQgdjEgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMSwgd1NoYXBlKV07XFxuICAgICAgICAgICAgbGV0IHYyID0gV1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDIsIHdTaGFwZSldO1xcbiAgICAgICAgICAgIGxldCB2MyA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQzLCB3U2hhcGUpXTtcXG4gICAgICAgICAgICByZXR1cm4gdmVjNDxmMzI+KHYwLCB2MSwgdjIsIHYzKTtcXG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7QX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGQ9ZT9gXFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCBpWFIsIGlYQywgeENoKTtcXG4gICAgICBgOmBcXG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgaVhSLCBpWEMpO1xcbiAgICAgIGAsYT1lP2BcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3cgLyBvdXRXaWR0aCxcXG4gICAgICByb3cgJSBvdXRXaWR0aCxcXG4gICAgICBjb2wpO1xcbiAgICBgOmBcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3csXFxuICAgICAgY29sIC8gb3V0V2lkdGgsXFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xcbiAgICBgLG09ZT9cIm91dEJhY2twcm9wWzFdXCI6XCJvdXRCYWNrcHJvcFsyXVwiLGc9ZT9cIm91dEJhY2twcm9wWzJdXCI6XCJvdXRCYWNrcHJvcFszXVwiLHg9ZT9cInJvd1wiOlwiY29sXCIsYj1lP1wiY29sXCI6XCJyb3dcIix3PWBcXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7ZT9cIm91dEJhY2twcm9wWzNdXCI6XCJvdXRCYWNrcHJvcFsxXVwifTtcXG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XFxuICAgICAgbGV0IG91dFJvdyA9ICR7eH0gLyBvdXRXaWR0aDtcXG4gICAgICBsZXQgb3V0Q29sID0gJHt4fSAlIG91dFdpZHRoO1xcblxcbiAgICAgIGxldCBXUm93ID0gJHtifSAvIChmaWx0ZXJEaW1zWzFdICogaW5DaGFubmVscyk7XFxuICAgICAgbGV0IFdDb2wgPSAke2J9IC8gaW5DaGFubmVscyAlIGZpbHRlckRpbXNbMV07XFxuICAgICAgbGV0IHhSID0gZjMyKG91dFJvdyAtIHBhZHNbMF0gKyBkaWxhdGlvblswXSAqIFdSb3cpIC8gZjMyKHN0cmlkZXNbMF0pO1xcbiAgICAgIGxldCB4QyA9IGYzMihvdXRDb2wgLSBwYWRzWzFdICsgZGlsYXRpb25bMV0gKiBXQ29sKSAvIGYzMihzdHJpZGVzWzFdKTtcXG4gICAgICBpZiAoeFIgPCAwLjAgfHwgeFIgPj0gZjMyKCR7bX0pIHx8IGZyYWN0KHhSKSA+IDAuMCkge1xcbiAgICAgICAgcmV0dXJuICR7c30oMC4wKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHhDIDwgMC4wIHx8IHhDID49IGYzMigke2d9KSB8fCBmcmFjdCh4QykgPiAwLjApIHtcXG4gICAgICAgIHJldHVybiAke3N9KDAuMCk7XFxuICAgICAgfVxcbiAgICAgIGxldCBpWFIgPSBpMzIoeFIpO1xcbiAgICAgIGxldCBpWEMgPSBpMzIoeEMpO1xcbiAgICAgIGxldCB4Q2ggPSAke2J9ICUgaW5DaGFubmVscztcXG4gICAgICAke2R9XFxuICAgICAgcmV0dXJuIHhbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHhTaGFwZSkvJHtufV07YCx2PWU/YFxcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XFxuICAgICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1Jbm5lcikge1xcbiAgICAgICAgJHt3fVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJHtzfSgwLjApO2A6YFxcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bn07XFxuICAgICAgaWYgKHJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xcbiAgICAgICAgJHt3fVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJHtzfSgwLjApO2AseT1gXFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7ZT9cIm91dEJhY2twcm9wWzNdXCI6XCJvdXRCYWNrcHJvcFsxXVwifTtcXG4gICAgICBsZXQgY29vcmRYID0gZmlsdGVyRGltcy54IC0gMSAtIHJvdyAvIChmaWx0ZXJEaW1zWzFdICogaW5DaGFubmVscyk7XFxuICAgICAgbGV0IGNvb3JkWSA9IGZpbHRlckRpbXMueSAtIDEgLSAocm93IC8gaW5DaGFubmVscykgJSBmaWx0ZXJEaW1zWzFdO1xcbiAgICAgIGlmICgke2U/XCJyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXJcIjpcInJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUFPdXRlclwifSAgJiYgY29vcmRYID49IDAgJiYgY29vcmRZID49IDApIHtcXG4gICAgICAgIGxldCByb3dJbm5lciA9IHJvdyAlIGluQ2hhbm5lbHM7XFxuICAgICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCwgcm93SW5uZXIpO1xcbiAgICAgICAgJHt1KG4pfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJHtzfSgwLjApO1xcbiAgICAgIGA7cmV0dXJuYFxcbiAgJHtXcihyLG8sbj09PTQsNCl9XFxuICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3N9IHtcXG4gICAgJHtlP3Y6eX1cXG4gIH1cXG5cXG4gIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7c30ge1xcbiAgICAke2U/eTp2fVxcbiAgfVxcblxcbiAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbnB1dCA6ICR7c30pIHtcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtufTtcXG4gICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcXG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0O1xcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcXG4gICAgICAke2F9XFxuICAgICAgJHt6cih0LHIpfVxcbiAgICAgIHJlc3VsdFtnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMsIG91dFNoYXBlKS8ke259XSA9IHZhbHVlO1xcbiAgICB9XFxuICB9YH0sZmk9KGUsdCxyLG8sbixzLHUsZCk9PntsZXQgYT10LmZvcm1hdD09PVwiTkhXQ1wiLG09YT9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGc9clswXSx4PWE/clsyXTpyWzNdLGI9YT9yWzFdOnJbMl0sdz1hP3JbM106clsxXSx2PWE/bSU0PT09MCYmdyU0PT09MDp4JTQ9PT0wJiZ3JTQ9PT0wLHk9YT93OngqYixTPWE/eCpiOncsQT12P1s4LDgsMV06W3k8PTR8fFM8PTQ/NDoxNix5PjQmJlM8PTQ/NDoxNiwxXSxSPXY/WzQsNCwxXTpbeTw9ND8xOjQseT40JiZTPD00PzE6NCwxXSxXPVtNYXRoLmNlaWwoeS9BWzBdL1JbMF0pLE1hdGguY2VpbChTL0FbMV0vUlsxXSksTWF0aC5jZWlsKGcvQVsyXS9SWzJdKV07RWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udl9iYWNrcHJvcF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtXfWApO2xldCBNPXY/NDoxLEQ9TWF0aC5tYXgoQVswXSpNLEFbMV0pLF89W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHg6IGFycmF5PCR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtgLFwiQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBXOiBhcnJheTxmMzI+O1wiXSx6PVwiXCI7cmV0dXJuIHUmJihfLnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhczogYXJyYXk8JHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O2ApLHorPWBcXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9IHtcXG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7YT9cIndcIjpcInlcIn0ke3Y/XCIvIDRcIjpcIlwifV07XFxuICAgICAgICB9YCkse25hbWU6XCJDb252MkRUcmFuc3Bvc2VNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6V1swXSx5OldbMV0sejpXWzJdfX0pLGdldFNoYWRlclNvdXJjZTooKT0+YFxcbiAgICAgICAgJHtHcn1cXG4gICAgICAgICR7Xy5qb2luKGBcXG5gKX1cXG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygke18ubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdDogYXJyYXk8JHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O1xcbiAgICAgICAgY29uc3Qgb3V0QmFja3Byb3AgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzBdLmRpbXMuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHhTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgd1NoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVsxXS5kaW1zLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBvdXRTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke3Iuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IG91dFNoYXBlU3RyaWRlcyA6IHZlYzM8aTMyPiA9IHZlYzM8aTMyPigke2suY29tcHV0ZVN0cmlkZXMocikuc2xpY2UoMCwzKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3QgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Qua2VybmVsU2hhcGVbYT8xOjJdfSwgJHt0Lmtlcm5lbFNoYXBlW2E/MjozXX0pO1xcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA6IHZlYzI8aTMyPiA9IGZpbHRlckRpbXMgKyB2ZWMyPGkzMj4oXFxuICAgICAgICAgICAgICAke3QuZGlsYXRpb25zWzBdPD0xPzA6KHQua2VybmVsU2hhcGVbYT8xOjJdLTEpKih0LmRpbGF0aW9uc1swXS0xKX0sXFxuICAgICAgICAgICAgICAke3QuZGlsYXRpb25zWzFdPD0xPzA6KHQua2VybmVsU2hhcGVbYT8yOjNdLTEpKih0LmRpbGF0aW9uc1sxXS0xKX0pO1xcbiAgICAgICAgY29uc3QgcGFkcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPihpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1swXSkgLSAxIC0gKCR7dC5wYWRzWzBdK3QucGFkc1syXX0pLzIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1sxXSkgLSAxIC0gKCR7dC5wYWRzWzFdK3QucGFkc1szXX0pLzIpO1xcbiAgICAgICAgY29uc3Qgc3RyaWRlcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3Quc3RyaWRlc1swXX0sICR7dC5zdHJpZGVzWzFdfSk7XFxuICAgICAgICBjb25zdCBkaWxhdGlvbiA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke3QuZGlsYXRpb25zWzBdfSwgJHt0LmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgY29uc3QgZGltQU91dGVyIDogaTMyID0gJHtvfTtcXG4gICAgICAgIGNvbnN0IGRpbUJPdXRlciA6IGkzMiA9ICR7bn07XFxuICAgICAgICBjb25zdCBkaW1Jbm5lciA6IGkzMiA9ICR7c307XFxuICAgICAgICAke3p9XFxuICAgICAgICAke0RsKGEsdSx0LmFjdGl2YXRpb24udG9Mb3dlckNhc2UoKSwhMSxNKX1cXG4gICAgICAgICR7dj9vcihSLEEsXCJmMzJcIix2b2lkIDAsIWEsRCk6YXIoUixBLFwiZjMyXCIsdm9pZCAwLCFhLEQsITEsdm9pZCAwLGQpfWB9fX0pO3ZhciBXbCxNbixoaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bXQoKTtnZSgpO3ZlKCk7V2w9KGUsdCxyLG8sbixzLHU9ITEsZCk9PntsZXQgYT1yLmZvcm1hdD09PVwiTkhXQ1wiLG09YT8xOjIsZz1hPzI6Myx4PWE/MzoxLGI9ay5zaXplKG8pLHc9dT8yOjEsdj1yLmdyb3VwLHk9dFsxXS5kaW1zLFM9eVswXS92LEE9eVsxXSxSPWBcXG4gIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogdTMyLCB2YWx1ZSA6ICR7dT9gdmVjNDwke2R9PmA6ZH0pIHtcXG4gICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3U/YHZlYzQ8JHtkfT5gOmR9KHZhbHVlKTtcXG4gIH1gO24mJihSKz1gXFxuICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PHUzMj4pIC0+ICR7dT9gdmVjNDwke2R9PmA6ZH0ge1xcbiAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2E/XCJ3XCI6XCJ5XCJ9JHt1P1wiLyA0XCI6XCJcIn1dO1xcbiAgICB9YCk7bGV0IFc9dT80OjEsTT1MKFwiV1wiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLFcpLEQ9TChcIkR5XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsVyksXz1bRCxNXTtuJiZfLnB1c2goTChcImJpYXNcIix0WzJdLmRhdGFUeXBlLFtvW3hdXSxXKSk7bGV0IHo9WChcInJlc3VsdFwiLHRbMF0uZGF0YVR5cGUsbyxXKSxGPWB7XFxuICAgICAgICBsZXQgYmF0Y2g6IHUzMiA9ICR7cz9cImdsb2JhbF9pZC56XCI6XCJ3b3JrZ3JvdXBfaWQuelwifSAvIG91dFNoYXBlWzFdO1xcbiAgICAgICAgbGV0IHIgPSAke3M/XCJnbG9iYWxfaWQuelwiOlwid29ya2dyb3VwX2lkLnpcIn0gJSBvdXRTaGFwZVsxXTtcXG4gICAgICAgIGxldCBjID0gJHtzP1wiZ2xvYmFsX2lkLnlcIjpcIndvcmtncm91cF9pZC55XCJ9ICogJHt3fTtcXG4gICAgICAgIGxldCBkMTogdTMyID0gJHtzP1wiZ2xvYmFsX2lkLnhcIjpcIndvcmtncm91cF9pZC54XCJ9ICogNDtcXG5cXG4gICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB2ZWMyPGkzMj4ocGFkcyk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgdmFyIGRvdFByb2Q6IGFycmF5PHZlYzQ8JHtkfT4sICR7d30+O1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3d9OyBpKyspIHtcXG4gICAgICAgICAgZG90UHJvZFtpXSA9IHZlYzQ8JHtkfT4oMC4wKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IGZpbHRlckRpbXNbMF07IHdSID0gd1IgKyAxKSB7XFxuICAgICAgICAgIHZhciBkeVIgPSAoJHtkfShkeUNvcm5lci54KSArICR7ZH0od1IpKSAvICR7ZH0oc3RyaWRlcy54KTtcXG4gICAgICAgICAgbGV0IHdSUGVybSA9IGZpbHRlckRpbXNbMF0gLSAxIC0gd1I7XFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZH0ob3V0QmFja3Byb3BbMV0pIHx8XFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wIHx8IHdSUGVybSA8IDApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IGZpbHRlckRpbXNbMV07IHdDID0gd0MgKyAxKSB7XFxuICAgICAgICAgICAgbGV0IGR5QyA9ICgke2R9KGR5Q29ybmVyLnkpICsgJHtkfSh3QykpIC8gJHtkfShzdHJpZGVzLnkpO1xcbiAgICAgICAgICAgIGxldCBkeUMyID0gKCR7ZH0oZHlDb3JuZXIueSkgKyAxLjAgKyAke2R9KHdDKSkgLyAke2R9KHN0cmlkZXMueSk7XFxuICAgICAgICAgICAgbGV0IHdDUGVybSA9IGZpbHRlckRpbXNbMV0gLSAxIC0gd0M7XFxuICAgICAgICAgICAgaWYgKHdDUGVybSA8IDApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbCA9IHRydWU7XFxuICAgICAgICAgICAgdmFyIGJEeUNWYWwyID0gdHJ1ZTtcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2R9KG91dEJhY2twcm9wWzJdKSB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBiRHlDVmFsID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChkeUMyIDwgMC4wIHx8IGR5QzIgPj0gJHtkfShvdXRCYWNrcHJvcFsyXSkgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDMikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGJEeUNWYWwyID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcXG4gICAgICAgICAgICBsZXQgaWR5QzI6IHUzMiA9IHUzMihkeUMyKTtcXG4gICAgICAgICAgICBpZiAoYkR5Q1ZhbCAmJiBiRHlDVmFsMikge1xcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gb3V0QmFja3Byb3BbM107XFxuICAgICAgICAgICAgICBmb3IgKHZhciBkMiA6dTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke00uZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMlwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xcblxcbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XFxuXFxuICAgICAgICAgICAgICAgIHhWYWx1ZSA9ICAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XFxuXFxuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdmVjNDwke2R9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsKSB7XFxuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSBvdXRCYWNrcHJvcFske3h9XTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XFxuXFxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJEeUNWYWwyKSB7XFxuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSBvdXRCYWNrcHJvcFszXTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7TS5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHtNLmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XFxuXFxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke0QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZH0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZFsxXSA9IGRvdFByb2RbMV0gKyB0bXB2YWw7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHt3fTsgaSA9IGkgKyAxKSB7XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2RbaV0gKyAke24/XCJiaWFzW2MraV1cIjpcIjAuMFwifTtcXG4gICAgICAgICAgJHt6LnNldChcImJhdGNoXCIsXCJyXCIsXCJjICsgaVwiLFwiZDFcIixcInZhbHVlXCIpfTtcXG4gICAgICAgIH1cXG4gICAgICB9YCxxPWBcXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3oub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAgIGxldCBiYXRjaCA9ICR7ei5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLDApfTtcXG4gICAgICAgICAgbGV0IGQxID0gJHt6LmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIseCl9O1xcbiAgICAgICAgICBsZXQgciA9ICR7ei5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLG0pfTtcXG4gICAgICAgICAgbGV0IGMgPSAke3ouaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixnKX07XFxuICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSBwYWRzO1xcbiAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyAke0F9O1xcbiAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiAke0F9O1xcbiAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICAgIHZhciBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCBlZmZlY3RpdmVGaWx0ZXJEaW1zLng7IHdSID0gd1IgKyAxKSB7XFxuICAgICAgICAgICAgaWYgKHdSICUgZGlsYXRpb25zLnggIT0gMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBkeVIgPSAoJHtkfShkeVJDb3JuZXIpICsgJHtkfSh3UikpIC8gJHtkfShzdHJpZGVzWzBdKTtcXG4gICAgICAgICAgICBsZXQgd1JQZXJtID0gZmlsdGVyRGltcy54IC0gMSAtIHdSIC8gZGlsYXRpb25zLng7XFxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtkfShvdXRCYWNrcHJvcFske219XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxcbiAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xcblxcbiAgICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IGVmZmVjdGl2ZUZpbHRlckRpbXMueTsgd0MgPSB3QyArIDEpIHtcXG4gICAgICAgICAgICAgIGlmICh3QyAlIGRpbGF0aW9ucy55ICE9IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7ZH0oZHlDQ29ybmVyKSArICR7ZH0od0MpKSAvICR7ZH0oc3RyaWRlcy55KTtcXG4gICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSBmaWx0ZXJEaW1zLnkgLSAxIC0gd0MgLyBkaWxhdGlvbnMueTtcXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZH0ob3V0QmFja3Byb3BbJHtnfV0pIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xcbiAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiAke1N9O1xcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgJHtTfTsgZDIgPSBkMiArIDEpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7YT9ELmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDXCIsXCJpbnB1dENoYW5uZWxcIik6RC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRDaGFubmVsXCIsXCJpZHlSXCIsXCJpZHlDXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7TS5nZXQoXCJpbnB1dENoYW5uZWxcIixcIndPdXRDaGFubmVsXCIsXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIil9O1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgMTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCArICR7bj9cImJpYXNbZDFdXCI6XCIwLjBcIn07XFxuICAgICAgICAgICR7ei5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgJHtlLmRlY2xhcmVWYXJpYWJsZXMoLi4uXyx6KX1cXG4gICR7Un1cXG4gIGNvbnN0IG91dFNoYXBlIDogdmVjNDx1MzI+ID0gdmVjNDx1MzI+KCR7by5qb2luKFwiLFwiKX0pO1xcbiAgY29uc3Qgb3V0QmFja3Byb3AgOiB2ZWM0PHUzMj4gPSB2ZWM0PHUzMj4oJHt0WzBdLmRpbXMuam9pbihcIixcIil9KTtcXG4gIGNvbnN0IHN0cmlkZXMgOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4oJHtyLnN0cmlkZXNbMF19LCAke3Iuc3RyaWRlc1sxXX0pO1xcbiAgY29uc3QgZmlsdGVyRGltcyA6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPigke3Iua2VybmVsU2hhcGVbYT8xOjJdfSwgJHtyLmtlcm5lbFNoYXBlW2E/MjozXX0pO1xcbiAgY29uc3QgZGlsYXRpb25zIDogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KCR7ci5kaWxhdGlvbnNbMF19LCAke3IuZGlsYXRpb25zWzFdfSk7XFxuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zIDogdmVjMjx1MzI+ID0gZmlsdGVyRGltcyArIHZlYzI8dTMyPihcXG4gICAgICAgICAgJHtyLmRpbGF0aW9uc1swXTw9MT8wOihyLmtlcm5lbFNoYXBlW2E/MToyXS0xKSooci5kaWxhdGlvbnNbMF0tMSl9LFxcbiAgICAgICAgICAke3IuZGlsYXRpb25zWzFdPD0xPzA6KHIua2VybmVsU2hhcGVbYT8yOjNdLTEpKihyLmRpbGF0aW9uc1sxXS0xKX0pO1xcbiAgY29uc3QgcGFkcyA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPihpMzIoZWZmZWN0aXZlRmlsdGVyRGltc1swXSkgLSAxIC0gKCR7ci5wYWRzWzBdK3IucGFkc1syXX0pLzIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkzMihlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdKSAtIDEgLSAoJHtyLnBhZHNbMV0rci5wYWRzWzNdfSkvMik7XFxuICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYil9O1xcbiAgJHt1P0Y6cX19YH0sTW49KGUsdCxyKT0+e2xldCBvPWUubGVuZ3RoPjIsbj10Lm91dHB1dFNoYXBlLHM9ay5zaXplKG4pLHU9W01hdGguY2VpbChzLzY0KSwxLDFdO0VlKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHt1fWApO2xldCBkPU1lKGVbMF0uZGF0YVR5cGUpO3JldHVybntuYW1lOlwiQ29udlRyYW5zcG9zZTJEXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtkaXNwYXRjaEdyb3VwOnt4OnVbMF0seTp1WzFdLHo6dVsyXX0sb3V0cHV0czpbe2RpbXM6cj9yKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dfSksZ2V0U2hhZGVyU291cmNlOmE9PldsKGEsZSx0LG4sbyx1WzFdPT09MSYmdVsyXT09PTEsITEsZCl9fX0pO3ZhciB6bCxWbCxHbCxnaSx5aSxObCxVbCxMbCxGbCxiaSx3aT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7UGUoKTttaSgpO2hpKCk7bnIoKTtycigpO3psPShlLHQscixvLG4scyk9PihlLTEpKnQrcisoby0xKSpuKzEtcyxWbD0oZSx0LHIsbyxuKT0+e2xldCBzPU1hdGguZmxvb3IoZS8yKTt0PT09XCJTQU1FX1VQUEVSXCI/KHJbb109cyxyW25dPWUtcyk6dD09PVwiU0FNRV9MT1dFUlwiJiYocltvXT1lLXMscltuXT1zKX0sR2w9KGUsdCxyLG8sbixzLHUsZCxhLG0pPT57bGV0IGc9ZS5sZW5ndGgtMix4PW0ubGVuZ3RoPT09MDtpZihhLmxlbmd0aD09PTApZm9yKGxldCB2PTA7djxnOysrdilhLnB1c2goMCk7bGV0IGI9ZVswXSx3PXRbZD8zOjFdKm47Zm9yKGxldCB2PTAseT1lLmxlbmd0aC1nLShkPzE6MCk7djxnOysrdiwrK3kpe2xldCBTPWVbeV0sQT14P1MqdVt2XTptW3ZdLFI9emwoUyx1W3ZdLHNbdl0sdFt5XSxyW3ZdLEEpO1ZsKFIsbyxzLHYsditnKSx4JiZtLnB1c2godVt2XSooUy0xKSthW3ZdKyh0W3ldLTEpKnJbdl0rMS1zW3ZdLXNbditnXSl9bS5zcGxpY2UoMCwwLGIpLG0uc3BsaWNlKGQ/MzoxLDAsdyl9LGdpPShlLHQpPT57bGV0IHI9ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKGUua2VybmVsU2hhcGUubGVuZ3RoPT09MHx8ZS5rZXJuZWxTaGFwZS5yZWR1Y2UoKGIsdyk9PmIqdywxKT09PTApe3IubGVuZ3RoPTA7Zm9yKGxldCBiPTI7Yjx0WzFdLmRpbXMubGVuZ3RoOysrYilyLnB1c2godFsxXS5kaW1zW2JdKX1sZXQgbz1lLmZvcm1hdD09PVwiTkhXQ1wiO3Iuc3BsaWNlKDAsMCx0WzFdLmRpbXNbMF0pLHIuc3BsaWNlKG8/MzoxLDAsdFsxXS5kaW1zWzFdKTtsZXQgbj1lLnBhZHMuc2xpY2UoKSxzPWUub3V0cHV0U2hhcGUuc2xpY2UoKSx1PWUub3V0cHV0UGFkZGluZy5zbGljZSgpLGQ9dFswXS5kaW1zLGE9ZS5kaWxhdGlvbnMuc2xpY2UoKTtpZihhLnJlZHVjZSgoYix3KT0+Yit3LDApPT09MCl7bGV0IGI9dFswXS5kaW1zLmxlbmd0aC0yO2E9bmV3IEFycmF5KGIpLmZpbGwoMSl9bGV0IG09ZS5zdHJpZGVzLnNsaWNlKCk7aWYobS5yZWR1Y2UoKGIsdyk9PmIrdywwKT09PTApe2xldCBiPXRbMF0uZGltcy5sZW5ndGgtMjttPW5ldyBBcnJheShiKS5maWxsKDEpfUdsKGQscixhLGUuYXV0b1BhZCxlLmdyb3VwLG4sbSxvLHUscyk7bGV0IGc9T2JqZWN0LmFzc2lnbih7fSxlKSx4PWUuY2FjaGVLZXkrW3Iuam9pbihcIm4sXCIpLG4uam9pbihcIixcIiksbS5qb2luKFwiLFwiKSx1LmpvaW4oXCIsXCIpLHMuam9pbihcIixcIiksYS5qb2luKFwiLFwiKV0uam9pbihcIl9cIik7cmV0dXJuIE9iamVjdC5hc3NpZ24oZyx7a2VybmVsU2hhcGU6cixwYWRzOm4sb3V0cHV0UGFkZGluZzp1LG91dHB1dFNoYXBlOnMsZGlsYXRpb25zOmEsc3RyaWRlczptLGNhY2hlS2V5Onh9KSxnfSx5aT1lPT57bGV0IHQ9VXIoZSkscj1lLmZvcm1hdCxvPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bdHlwZW9mIGUuYXV0b1BhZD5cInVcIj8wOmUuYXV0b1BhZF0sbj1lLmRpbGF0aW9ucyxzPWUuZ3JvdXAsdT1lLmtlcm5lbFNoYXBlLGQ9ZS5wYWRzLGE9ZS5zdHJpZGVzLG09ZS53SXNDb25zdCgpLGc9ZS5vdXRwdXRQYWRkaW5nLHg9ZS5vdXRwdXRTaGFwZTtyZXR1cm4gaWUoe2F1dG9QYWQ6byxmb3JtYXQ6cixkaWxhdGlvbnM6bixncm91cDpzLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzpnLG91dHB1dFNoYXBlOngscGFkczpkLHN0cmlkZXM6YSx3SXNDb25zdDptLC4uLnR9KX0sTmw9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbz1lWzFdLmRpbXNbMF07aWYociE9PW8pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbj1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBzPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKGcseCk9PmcreCwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3N9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKGcseCk9PmcreCwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c31EYCk7aWYodC5wYWRzLnJlZHVjZSgoZyx4KT0+Zyt4LDApPjAmJnQucGFkcy5sZW5ndGghPT1zKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3MqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXMmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c31EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKGcseCk9PmcreCwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LFVsPVsyLDMsMSwwXSxMbD0oZSx0LHIpPT57bGV0IG89Z2kocix0KSxuPXIuZm9ybWF0PT09XCJOSFdDXCIscz10Lmxlbmd0aD09PTM7aWYoby5ncm91cCE9PTEpe2UuY29tcHV0ZShNbih0LG8pKTtyZXR1cm59bGV0IHU9by5vdXRwdXRTaGFwZSxkPXVbbj8xOjJdLGE9dVtuPzI6M10sbT11W24/MzoxXSxnPXRbMV0uZGltc1syXSx4PXRbMV0uZGltc1szXSxiPXRbMF0uZGltc1tuPzM6MV0sdz1uP2QqYTptLHY9bj9tOmQqYSx5PWcqeCpiLFM9ITAsQT1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShndCh0WzFdLFVsKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9QSk7bGV0IFI9W3RbMF0sQV07cyYmKCFuJiZ0WzJdLmRpbXMubGVuZ3RoPT09MT9SLnB1c2godFsyXS5yZXNoYXBlKFt0WzJdLmRpbXNbMF0sMSwxXSkpOlIucHVzaCh0WzJdKSksZS5jb21wdXRlKGZpKFIsbyx1LHcsdix5LHMsUykse2lucHV0czpSfSl9LEZsPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixvPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtvLmxlbmd0aD09PTMmJm8ucHVzaChlLmlucHV0c1syXSk7bGV0IG49dC5rZXJuZWxTaGFwZTsobi5sZW5ndGg9PT0wfHxuWzBdPT09MCkmJihuPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IHM9dC5kaWxhdGlvbnM7KHMubGVuZ3RoPT09MHx8c1swXT09PTApJiYocz1bMV0pO2xldCB1PXQuc3RyaWRlczsodS5sZW5ndGg9PT0wfHx1WzBdPT09MCkmJih1PVsxXSk7bGV0IGQ9dC5wYWRzO2QubGVuZ3RoPT09MCYmKGQ9WzAsMF0pLGQ9WzAsZFswXSwwLGRbMV1dLHU9WzFdLmNvbmNhdCh1KSxzPVsxXS5jb25jYXQocyksbj1bMV0uY29uY2F0KG4pO2xldCBhPWdpKHsuLi50LHBhZHM6ZCxzdHJpZGVzOnUsZGlsYXRpb25zOnMsa2VybmVsU2hhcGU6bn0sbyk7ZS5jb21wdXRlKE1uKG8sYSxtPT5yP1ttWzBdLG1bMl0sbVszXV06W21bMF0sbVsxXSxtWzNdXSkpfSxiaT0oZSx0KT0+e05sKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Mz9GbChlLHQpOkxsKGUsZS5pbnB1dHMsdCl9fSk7dmFyIEJuLEZyLHZpLEhsLGpsLGtuLERuLEtsLCRpLHhpLFNpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtCbj1cIlthLXpBLVpdfFxcXFxcXFxcLlxcXFxcXFxcLlxcXFxcXFxcLlwiLEZyPVwiKFwiK0JuK1wiKStcIix2aT1cIl5cIitGcitcIiRcIixIbD1cIihcIitGcitcIiwpKlwiK0ZyLGpsPVwiXlwiK0hsK1wiJFwiLGtuPWNsYXNze2NvbnN0cnVjdG9yKHQ9LTEpe3RoaXMuc3ltYm9sVG9JbmRpY2VzPW5ldyBNYXAsdGhpcy5pbnB1dEluZGV4PXR9YWRkU3ltYm9sKHQscil7bGV0IG89dGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHQpO289PT12b2lkIDA/bz1bcl06by5wdXNoKHIpLHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldCh0LG8pfX0sRG49Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLmVxdWF0aW9uPXI7dGhpcy5oYXNFbGxpcHNpcz0hMSx0aGlzLnN5bWJvbFRvSW5mbz1uZXcgTWFwLHRoaXMubGhzPW5ldyBBcnJheSx0aGlzLm91dHB1dERpbXM9W107bGV0W28sbl09ci5pbmNsdWRlcyhcIi0+XCIpP3Iuc3BsaXQoXCItPlwiLDIpOltyLFwiXCJdO2lmKCFvLm1hdGNoKFJlZ0V4cChqbCkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7aWYoby5zcGxpdChcIixcIikuZm9yRWFjaCgoZCxhKT0+e2xldCBtPXRbYV0uZGltcy5zbGljZSgpO2lmKCFkLm1hdGNoKFJlZ0V4cCh2aSkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IGc9dGhpcy5wcm9jZXNzVGVybShkLCEwLG0sYSk7dGhpcy5saHMucHVzaChnKX0pLG49PT1cIlwiKW4rPVsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldLmZpbHRlcigoW2QsYV0pPT5hLmNvdW50PT09MXx8ZD09PVwiLi4uXCIpLm1hcCgoW2RdKT0+ZCkuam9pbihcIlwiKTtlbHNlIGlmKCFuLm1hdGNoKFJlZ0V4cChGcikpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTXCIpO24ubWF0Y2goUmVnRXhwKEJuLFwiZ1wiKSk/LmZvckVhY2goZD0+e2lmKGQ9PT1cIi4uLlwiKXRoaXMub3V0cHV0RGltcz10aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtlbHNle2xldCBhPXRoaXMuc3ltYm9sVG9JbmZvLmdldChkKTtpZihhPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTIHN5bWJvbFwiKTt0aGlzLm91dHB1dERpbXMucHVzaChhLmRpbVZhbHVlKX19KSx0aGlzLnJocz10aGlzLnByb2Nlc3NUZXJtKG4sITAsdGhpcy5vdXRwdXREaW1zKX1hZGRTeW1ib2wodCxyLG8pe2xldCBuPXRoaXMuc3ltYm9sVG9JbmZvLmdldCh0KTtpZihuIT09dm9pZCAwKXtpZihuLmRpbVZhbHVlIT09ciYmbi5jb3VudCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc21hdGNoXCIpO24uY291bnQrKyxuLmlucHV0SW5kaWNlcy5wdXNoKG8pfWVsc2Ugbj17Y291bnQ6MSxkaW1WYWx1ZTpyLGlucHV0SW5kaWNlczpbb119O3RoaXMuc3ltYm9sVG9JbmZvLnNldCh0LG4pfXByb2Nlc3NUZXJtKHQscixvLG49LTEpe2xldCBzPW8ubGVuZ3RoLHU9ITEsZD1bXSxhPTA7aWYoIXQubWF0Y2goUmVnRXhwKHZpKSkmJiFyJiZ0IT09XCJcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBtPXQubWF0Y2goUmVnRXhwKEJuLFwiZ1wiKSksZz1uZXcga24obik7cmV0dXJuIG0/LmZvckVhY2goKHgsYik9PntpZih4PT09XCIuLi5cIil7aWYodSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBlbGxpcHNpcyBpcyBhbGxvd2VkIHBlciBpbnB1dCB0ZXJtXCIpO3U9ITA7bGV0IHc9cy1tLmxlbmd0aCsxO2lmKHc8MCl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBvdXQgb2YgYm91bmRzXCIpO2lmKGQ9by5zbGljZShhLGErdyksdGhpcy5oYXNFbGxpcHNpcyl7aWYodGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIT09ZC5sZW5ndGh8fHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkhPT1kLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaFwiKX1lbHNlIGlmKHIpdGhpcy5oYXNFbGxpcHNpcz0hMCx0aGlzLmVsbGlwc2lzRGltcz1kO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIU1wiKTtmb3IobGV0IHY9MDt2PGQubGVuZ3RoO3YrKyl7bGV0IHk9U3RyaW5nLmZyb21DaGFyQ29kZShcIjBcIi5jaGFyQ29kZUF0KDApK2IpO2cuYWRkU3ltYm9sKHksYit2KSx0aGlzLmFkZFN5bWJvbCh5LG9bYSsrXSxuKX19ZWxzZSBnLmFkZFN5bWJvbCh4LGIpLHRoaXMuYWRkU3ltYm9sKHgsb1thKytdLG4pfSksZ319LEtsPShlLHQpPT57bGV0IHI9ZVswXS5kYXRhVHlwZSxvPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBXPTA7VzxlLmxlbmd0aDsrK1cpb1tXXT1MKGBpbnB1dCR7V31gLHIsZVtXXS5kaW1zKTtsZXQgbj10Lm91dHB1dERpbXMscz1rLnNpemUobiksdT1YKFwib3V0cHV0XCIscixuKSxkPVtdLGE9QXJyYXkuZnJvbSh0LnJocy5zeW1ib2xUb0luZGljZXMua2V5cygpKSxtPVwidmFyIHByb2QgPSAxLjA7XCIsZz1cInZhciBzdW0gPSAwLjA7XCIseD1cInN1bSArPSBwcm9kO1wiLGI9W10sdz1bXSx2PVtdLHk9W10sUz10LnN5bWJvbFRvSW5mby5zaXplPT09YS5sZW5ndGg7dC5zeW1ib2xUb0luZm8uZm9yRWFjaCgoVyxNKT0+e2lmKGEuaW5jbHVkZXMoTSkpe2xldCBEPWEuaW5kZXhPZihNKTt0Lmxocy5mb3JFYWNoKChfLHopPT57aWYoVy5pbnB1dEluZGljZXMuaW5jbHVkZXMoeikpe2xldCBGPV8uc3ltYm9sVG9JbmRpY2VzLmdldChNKTtpZihGPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0YuZm9yRWFjaChxPT57ZC5wdXNoKGAke29bel0uaW5kaWNlc1NldChgaW5wdXQke3p9SW5kaWNlc2AscSx1LmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsRCkpfWApfSl9fSl9ZWxzZSB0Lmxocy5mb3JFYWNoKChELF8pPT57bGV0IHo9dC5zeW1ib2xUb0luZm8uZ2V0KE0pO2lmKHo9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7aWYoei5pbnB1dEluZGljZXMuaW5jbHVkZXMoXykpe2xldCBGPUQuc3ltYm9sVG9JbmRpY2VzLmdldChNKTtpZihGPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0YuZm9yRWFjaChxPT57Yi5wdXNoKGAke29bX10uaW5kaWNlc1NldChgaW5wdXQke199SW5kaWNlc2AscSxgJHtNfWApfWApfSkseS5wdXNoKGBwcm9kICo9ICR7b1tfXS5nZXRCeUluZGljZXMoYGlucHV0JHtffUluZGljZXNgKX07YCl9fSksdy5wdXNoKGBmb3IodmFyICR7TX06IHUzMiA9IDA7ICR7TX0gPCAke3Quc3ltYm9sVG9JbmZvLmdldChNKT8uZGltVmFsdWV9OyAke019KyspIHtgKSx2LnB1c2goXCJ9XCIpfSk7bGV0IEE9Uz9bLi4uZCxgbGV0IHN1bSA9ICR7by5tYXAoKFcsTSk9PlcuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7TX1JbmRpY2VzYCkpLmpvaW4oXCIgKiBcIil9O2BdOlsuLi5kLGcsLi4udywuLi5iLG0sLi4ueSx4LC4uLnZdLFI9Vz0+YFxcbiAgICAgICR7Vy5kZWNsYXJlVmFyaWFibGVzKC4uLm8sdSl9XFxuXFxuICAgICAgJHtXLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtXLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocyl9XFxuICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICR7by5tYXAoKE0sRCk9PmB2YXIgaW5wdXQke0R9SW5kaWNlczogJHtvW0RdLnR5cGUuaW5kaWNlc307YCkuam9pbihgXFxuYCl9XFxuICAgICAgICAke0Euam9pbihgXFxuYCl9O1xcbiAgICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIkVpbnN1bVwiLHNoYWRlckNhY2hlOntoaW50OnQuZXF1YXRpb259LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9fSksZ2V0U2hhZGVyU291cmNlOlJ9fSwkaT0oZSx0KT0+e2xldCByPW5ldyBEbihlLmlucHV0cyx0LmVxdWF0aW9uKTtlLmNvbXB1dGUoS2woZS5pbnB1dHMscikpfSx4aT1lPT57bGV0IHQ9ZS5lcXVhdGlvbi5yZXBsYWNlKC9cXFxccysvZyxcIlwiKTtyZXR1cm4gaWUoe2VxdWF0aW9uOnR9KX19KTt2YXIgcWwsQ2ksWWwsWGwsQWksSWk9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7dmUoKTtxbD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgMiBpbnB1dC5cIik7bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG89ci5sZW5ndGg8dC5sZW5ndGg/MDpyLmxlbmd0aC10Lmxlbmd0aCxuPXQubGVuZ3RoPHIubGVuZ3RoPzA6dC5sZW5ndGgtci5sZW5ndGg7Zm9yKDtvPHIubGVuZ3RoJiZuPHQubGVuZ3RoOysrbywrK24paWYocltvXSE9PXRbbl0mJnJbb10hPT0xJiZ0W25dIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dFwiKX0sQ2k9KGUsdCk9PntsZXQgcj1lLmxlbmd0aC10Lmxlbmd0aCxvPVtdO2ZvcihsZXQgbj0wO248cjsrK24pby5wdXNoKGVbbl0pO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKW8ucHVzaCh0W25dPT09MT9lW24rcl06dFtuXSk7cmV0dXJuIG99LFlsPShlLHQpPT5lLmxlbmd0aD50Lmxlbmd0aD9DaShlLHQpOkNpKHQsZSksWGw9ZT0+e2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxvPVlsKHQsciksbj1rLnNpemUobykscz1lWzBdLmRhdGFUeXBlLHU9TChcImlucHV0XCIscyx0KSxkPVgoXCJvdXRwdXRcIixzLG8pLGE9bT0+YFxcbiAgY29uc3QgaW5wdXRTaGFwZSA9ICR7dS5pbmRpY2VzKC4uLnQpfTtcXG4gICR7bS5kZWNsYXJlVmFyaWFibGVzKHUsZCl9XFxuICAke20ubWFpblN0YXJ0KCl9XFxuICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhuKX1cXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgIHZhciBpbnB1dEluZGljZXM6ICR7dS50eXBlLmluZGljZXN9O1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcXG4gICAgICBpZiAoJHt1LmluZGljZXNHZXQoXCJpbnB1dFNoYXBlXCIsXCJpXCIpfSA9PSAxKSB7XFxuICAgICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLDApfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwiaVwiLGQuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixgaSArICR7by5sZW5ndGgtdC5sZW5ndGh9YCkpfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAke2Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIikpfVxcbiAgfWA7cmV0dXJue25hbWU6XCJFeHBhbmRcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvfWB9LGdldFNoYWRlclNvdXJjZTphLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9fSl9fSxBaT1lPT57cWwoZS5pbnB1dHMpLGUuY29tcHV0ZShYbChlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgSmwsWmwsRWksVGksT2k9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO0psPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LFpsPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG89ZVsxXS5kaW1zLG49ci5sZW5ndGgscz1rLm5vcm1hbGl6ZUF4aXModC5heGlzLG4pLHU9ci5zbGljZSgwKTt1LnNwbGljZShzLDEsLi4ubyk7bGV0IGQ9cltzXSxhPWsuc2l6ZSh1KSxtPUwoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLGc9TChcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSx4PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHUpLGI9KCk9PntsZXQgdj1vLmxlbmd0aCx5PWB2YXIgaW5kaWNlc0luZGljZXMgID0gJHtnLnR5cGUuaW5kaWNlc30oMCk7YDtmb3IobGV0IFM9MDtTPHY7UysrKXkrPWAke3Y+MT9gaW5kaWNlc0luZGljZXNbJHtTfV1gOlwiaW5kaWNlc0luZGljZXNcIn0gPSAke3UubGVuZ3RoPjE/YG91dHB1dEluZGljZXNbJHtzK1N9XWA6XCJvdXRwdXRJbmRpY2VzXCJ9O2A7eSs9YFxcbiAgICAgICAgdmFyIGlkeCA9ICR7Zy5nZXRCeUluZGljZXMoXCJpbmRpY2VzSW5kaWNlc1wiKX07XFxuICAgICAgICBpZiAoaWR4IDwgMCkge1xcbiAgICAgICAgICBpZHggPSBpZHggKyAke2R9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRhdGFJbmRpY2VzID0gJHttLnR5cGUuaW5kaWNlc30oMCk7XFxuICAgICAgYDtmb3IobGV0IFM9MCxBPTA7UzxuO1MrKylTPT09cz8oeSs9YCR7bj4xP2BkYXRhSW5kaWNlc1ske1N9XWA6XCJkYXRhSW5kaWNlc1wifSA9IHUzMihpZHgpO2AsQSs9dik6KHkrPWAke24+MT9gZGF0YUluZGljZXNbJHtTfV1gOlwiZGF0YUluZGljZXNcIn0gPSAke3UubGVuZ3RoPjE/YG91dHB1dEluZGljZXNbJHtBfV1gOlwib3V0cHV0SW5kaWNlc1wifTtgLEErKyk7cmV0dXJuIHl9LHc9dj0+YFxcbiAgICAgICR7di5kZWNsYXJlVmFyaWFibGVzKG0sZyx4KX1cXG4gICAgICAke3YubWFpblN0YXJ0KCl9XFxuICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhhKX1cXG4gICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt4Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgJHtiKCl9O1xcbiAgICAgICAgbGV0IHZhbHVlID0gJHttLmdldEJ5SW5kaWNlcyhcImRhdGFJbmRpY2VzXCIpfTtcXG4gICAgICAgICR7eC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSksZ2V0U2hhZGVyU291cmNlOnd9fSxFaT1lPT5pZSh7YXhpczplLmF4aXN9KSxUaT0oZSx0KT0+e2xldCByPWUuaW5wdXRzO0psKHIpLGUuY29tcHV0ZShabChlLmlucHV0cyx0KSl9fSk7dmFyIFFsLGVkLF9pLFJpLFBpPUgoKCk9PntcInVzZSBzdHJpY3RcIjtnZSgpO1BlKCk7dmUoKTtRbD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKX0sZWQ9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbz1lWzBdLmRhdGFUeXBlLG49ci5sZW5ndGgscz1rLmNvbXB1dGVTdHJpZGVzKHIpLHU9ay5zaXplKHIpLGQ9ZVsxXS5kaW1zLGE9ZVsxXS5kYXRhVHlwZSxtPWsuc2l6ZShkKSxnPWsubm9ybWFsaXplQXhpcyh0LmF4aXMsbikseD1yW2ddLGI9ZC5zbGljZSgwKSx3PWsuc2l6ZShiKSx2PUwoXCJpbnB1dFwiLG8scikseT1MKFwiaW5kaWNlc1wiLGEsW21dKSxTPVgoXCJvdXRwdXRcIixvLGIpLEE9Uj0+YFxcbiAgICAgIGNvbnN0IGlucHV0U3RyaWRlcyA9IGFycmF5PHUzMiwgJHtzLmxlbmd0aH0+KCR7cy5tYXAoVz0+YCR7V311YCkuam9pbihcIixcIil9KTtcXG4gICAgICAke1IuZGVjbGFyZVZhcmlhYmxlcyh2LHksUyl9XFxuICAgICAgJHtSLm1haW5TdGFydCgpfVxcbiAgICAgICR7Ui5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHcpfVxcblxcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcblxcbiAgICAgIHZhciBpZHggPSAke3kuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICBpZiAoaWR4IDwgMCkge1xcbiAgICAgICAgaWR4ID0gaWR4ICsgJHt4fTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHNyY09mZnNldCA9IHUzMigwKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcXG4gICAgICAgIGlmIChpID09ICR7Z30pIHtcXG4gICAgICAgICAgc3JjT2Zmc2V0ICs9ICB1MzIoaWR4KSAqIGlucHV0U3RyaWRlc1tpXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNyY09mZnNldCArPSAke1MuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixcImlcIil9ICogaW5wdXRTdHJpZGVzW2ldO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBTaG91bGQgbmV2ZXIgaGl0IHRoaXMgd2l0aCB2YWxpZCB2YWx1ZXMgaW4gaW5kaWNlc1xcbiAgICAgIC8vIFRoaXMgaXMgYSBndWFyZCBhZ2FpbnN0IG1hbGljaW91cyBkYXRhIGluIHRoZSBpbmRpY2VzIGlucHV0XFxuICAgICAgaWYgKHNyY09mZnNldCA8IDAgfHwgc3JjT2Zmc2V0ID49ICR7dX0pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbc3JjT2Zmc2V0XTtcXG4gIH1gO3JldHVybntuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHcvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpBfX0sX2k9ZT0+aWUoe2F4aXM6ZS5heGlzfSksUmk9KGUsdCk9PntsZXQgcj1lLmlucHV0cztRbChyKSxlLmNvbXB1dGUoZWQoZS5pbnB1dHMsdCkpfX0pO3ZhciB0ZCxyZCxuZCxNaSxCaSxraT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7dGQ9ZT0+e2lmKCFlKXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMl0uZGltcy5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoZVswXS5kYXRhVHlwZSE9PWVbMV0uZGF0YVR5cGV8fGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9LHJkPShlLHQscik9PntpZihyLmxlbmd0aD09PTApcmV0dXJuXCIwdVwiO2xldCBvPXIubGVuZ3RoPT09MSYmZSE9PTF8fHIubGVuZ3RoPT09MiYmclswXSE9PWUsbj1yW3IubGVuZ3RoLTFdIT09dCxzPVwiMHVcIjtyZXR1cm4gb3x8KHMrPWArIG0gKiAke3Jbci5sZW5ndGgtMV19dWApLG58fChzKz1cIituXCIpLHN9LG5kPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1lWzFdLmRpbXMuc2xpY2UoKSxbbixzLHVdPV9yLmdldFNoYXBlT2ZHZW1tUmVzdWx0KHIsdC50cmFuc0Esbyx0LnRyYW5zQixlLmxlbmd0aD09PTM/ZVsyXS5kaW1zOnZvaWQgMCksZD1bbixzXTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBhPWsuc2l6ZShkKSxtPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCP209XCJ2YWx1ZSArPSBhW2sgKiBNICsgbV0gKiBiW24gKiBLICsga107XCI6dC50cmFuc0EmJiF0LnRyYW5zQj9tPVwidmFsdWUgKz0gYVtrICogTSArIG1dICogYltrICogTiArIG5dO1wiOiF0LnRyYW5zQSYmdC50cmFuc0I/bT1cInZhbHVlICs9IGFbbSAqIEsgKyBrXSAqIGJbbiAqIEsgKyBrXTtcIjohdC50cmFuc0EmJiF0LnRyYW5zQiYmKG09XCJ2YWx1ZSArPSBhW20gKiBLICsga10gKiBiW2sgKiBOICsgbl07XCIpO2xldCBnPU1lKGVbMF0uZGF0YVR5cGUpLHg9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IGFscGhhO1wiLGI9ZS5sZW5ndGg9PT0zP2B2YWx1ZSArPSBiZXRhICogY1ske3JkKG4scyxlWzJdLmRpbXMpfV07YDpcIlwiLHc9W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGEgOiBhcnJheTwke2d9PjtgLGBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGIgOiBhcnJheTwke2d9PjtgXTtlLmxlbmd0aD09PTMmJncucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBjIDogYXJyYXk8JHtnfT47YCk7bGV0IHY9eT0+YFxcbiAgY29uc3QgTTogdTMyID0gJHtufXU7XFxuICBjb25zdCBOOiB1MzIgPSAke3N9dTtcXG4gIGNvbnN0IEs6IHUzMiA9ICR7dX11O1xcbiAgY29uc3QgYWxwaGEgPSAke2d9KCR7dC5hbHBoYX0pO1xcbiAgY29uc3QgYmV0YSA9ICR7Z30oJHt0LmJldGF9KTtcXG5cXG4gICR7dy5qb2luKGBcXG5gKX1cXG4gIEBncm91cCgwKSBAYmluZGluZygke2UubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7Z30+O1xcblxcbiAgJHt5Lm1haW5TdGFydCgpfVxcbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhhKX1cXG5cXG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueCAvIE47XFxuICAgIGxldCBuID0gZ2xvYmFsX2lkLnggJSBOO1xcblxcbiAgICB2YXIgdmFsdWUgPSAke2d9KDApO1xcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazwke3V9dTsgaysrKSB7XFxuICAgICAgJHttfVxcbiAgICB9XFxuXFxuICAgICR7eH1cXG4gICAgJHtifVxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkLnhdID0gdmFsdWU7XFxuXFxuICB9YDtyZXR1cm57bmFtZTpcIkdlbW1cIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfX0pLGdldFNoYWRlclNvdXJjZTp2fX0sTWk9KGUsdCk9Pnt0ZChlLmlucHV0cyksZS5jb21wdXRlKG5kKGUuaW5wdXRzLHQpKX0sQmk9ZT0+aWUoZSl9KTt2YXIgb2QsYWQsaWQsc2QsRGksV2ksemk9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtQZSgpO3ZlKCk7b2Q9e25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIn0sYWQ9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbz1yLG49MixzPWsuc2l6ZVRvRGltZW5zaW9uKHIsbiksdT1rLnNpemVGcm9tRGltZW5zaW9uKHIsbiksZD1yWzFdLGE9TChcInhcIixlWzBdLmRhdGFUeXBlLFtyWzBdLHJbMV0sdV0pLG09TChcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLGc9TChcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcykseD1YKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxbclswXSxyWzFdLHVdKSxiPVthLG0sZyx4XSx3PWEudHlwZS52YWx1ZSx2PTY0LHk9Uz0+YFxcblxcbiAgY29uc3QgQzogdTMyID0gJHtkfTtcXG4gIGNvbnN0IG5vcm1TaXplOiB1MzIgPSAke3V9O1xcbiAgY29uc3QgZXBzaWxvbjogZjMyID0gJHt0LmVwc2lsb259O1xcbiAgdmFyPHdvcmtncm91cD4gbWVhblNoYXJlZCA6ICR7d307XFxuICB2YXI8d29ya2dyb3VwPiBzcXVhcmVkTm9ybVNoYXJlZCA6ICR7d307XFxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBTaGFyZWQgOiBhcnJheTwke3d9LCAke3Z9PjtcXG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSAke3Z9dTtcXG4gICR7Uy5kZWNsYXJlVmFyaWFibGVzKC4uLmIpfVxcbiAgJHtTLm1haW5TdGFydCh2KX1cXG4gICAgbGV0IG5vcm0gPSBnbG9iYWxfaWR4IC8gd29ya2dyb3VwU2l6ZTtcXG4gICAgbGV0IGJhdGNoID0gbm9ybSAvIEM7XFxuICAgIGxldCBjaGFubmVsID0gbm9ybSAlIEM7XFxuICAgIGxldCBsb2NhbEluZGV4ID0gbG9jYWxfaWQueDtcXG5cXG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XFxuICAgIHZhciBpbml0aWFsOiAke3d9ID0gMDtcXG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCBub3JtU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XFxuICAgICAgaW5pdGlhbCA9IGluaXRpYWwgKyAke2EuZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9O1xcbiAgICB9XFxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XFxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtZWFuIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxcbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cFNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XFxuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XFxuICAgICAgfVxcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgfVxcbiAgICBpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxuICAgICAgbWVhblNoYXJlZCA9IHdvcmtncm91cFNoYXJlZFswXSAvICR7d30obm9ybVNpemUpO1xcbiAgICB9XFxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgLy8gcmVpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnkuXFxuICAgIGluaXRpYWwgPSAwO1xcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IG5vcm1TaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcXG4gICAgICBsZXQgZGV2aWF0aW9uID0gICR7YS5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0gLSBtZWFuU2hhcmVkO1xcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsICsgZGV2aWF0aW9uICogZGV2aWF0aW9uO1xcbiAgICB9XFxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XFxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2Ygc3F1YXJlIG9mIGRldmlhdGlvbiBvZiBjdXJyZW50IGNoYW5uZWwgZGF0YS5cXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcXG4gICAgICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSArIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4ICsgY3VyclNpemVdO1xcbiAgICAgIH1cXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgIH1cXG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xcbiAgICAgIHNxdWFyZWROb3JtU2hhcmVkID0gd29ya2dyb3VwU2hhcmVkWzBdO1xcbiAgICB9XFxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgbGV0IGludlN0ZERldiA9IDEgLyBzcXJ0KHNxdWFyZWROb3JtU2hhcmVkIC8gJHt3fShub3JtU2l6ZSkgKyBlcHNpbG9uKTtcXG4gICAgbGV0IGNoYW5uZWxTY2FsZSA9IGludlN0ZERldiAqICR7bS5nZXRCeU9mZnNldChcImNoYW5uZWxcIil9O1xcbiAgICBsZXQgY2hhbm5lbFNoaWZ0ID0gJHtnLmdldEJ5T2Zmc2V0KFwiY2hhbm5lbFwiKX0gLSBtZWFuU2hhcmVkICogY2hhbm5lbFNjYWxlO1xcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IG5vcm1TaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcXG4gICAgICBsZXQgdmFsdWUgPSAke2EuZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9ICogY2hhbm5lbFNjYWxlICsgY2hhbm5lbFNoaWZ0O1xcbiAgICAgICR7eC5zZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiLFwidmFsdWVcIil9O1xcbiAgICB9XFxuICB9YDtyZXR1cm57Li4ub2Qsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnN9fSksZ2V0U2hhZGVyU291cmNlOnl9fSxpZD0oZSx0LHIsbyxuLHMsdSxkKT0+e2xldCBhPWx0KHUpLG09TChcImlucHV0XCIsdC5kYXRhVHlwZSx0LmRpbXMsYSksZz1MKFwic2NhbGVcIixyLmRhdGFUeXBlLHIuZGltcyxhKSx4PUwoXCJiaWFzXCIsby5kYXRhVHlwZSxvLmRpbXMsYSksYj02NCx3PWE9PT0xP1widmVjMmZcIjpgbWF0Mngke2F9ZmAsdj1hPT09MT9cImYzMlwiOmB2ZWMke2F9ZmAseT0oRCxfKT0+YCR7d30oJHtEfSwgJHtffSlgLFM9bip1L2EsQT1NYXRoLmNlaWwocy9iKSxSPUQ9PmBcXG4gIGNvbnN0IEg6IHUzMiA9ICR7c307XFxuICBjb25zdCBDOiB1MzIgPSAke3UvYX07XFxuICBjb25zdCBpbWFnZVNpemU6IHUzMiA9ICR7cyp1L2F9O1xcblxcbiAgJHtELmRlY2xhcmVWYXJpYWJsZXMobSl9XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7d30+O1xcblxcbiAgJHtELm1haW5TdGFydChiKX1cXG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAke2J9IC8gQztcXG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gKGdsb2JhbF9pZHggLyAke2J9KSAlIEM7XFxuICAgIGxldCB3Z0lkID0gZ2xvYmFsX2lkeCAlICR7Yn07XFxuICAgIGxldCB3Z09mZnNldCA9IHdnSWQgKiAke0F9O1xcbiAgICBpZiAod2dPZmZzZXQgPj0gSCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGxldCB3Z01heCA9IG1pbih3Z09mZnNldCArICR7QX0sIEgpO1xcblxcbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogaW1hZ2VTaXplICsgY3VycmVudENoYW5uZWxOdW1iZXI7XFxuICAgIHZhciBzdW0gPSAke3FlKFwiZjMyXCIsYSl9O1xcbiAgICB2YXIgc3F1YXJlZFN1bSA9ICR7cWUoXCJmMzJcIixhKX07XFxuICAgIGZvciAodmFyIGk6IHUzMiA9IHdnT2Zmc2V0OyBpIDwgd2dNYXg7IGkrKykge1xcbiAgICAgICAgbGV0IHZhbHVlID0gJHt2fShpbnB1dFtvZmZzZXQgKyBpICogQ10pO1xcbiAgICAgICAgc3VtICs9IHZhbHVlO1xcbiAgICAgICAgc3F1YXJlZFN1bSArPSB2YWx1ZSAqIHZhbHVlO1xcbiAgICB9XFxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7eShcInN1bVwiLFwic3F1YXJlZFN1bVwiKX07XFxuICB9YCxXPWUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVNZWFuXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6SlNPTi5zdHJpbmdpZnkoe2NvbXBvbmVudHM6YSxuLGg6cyxjOnV9KX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpbbix1LGIsMl0sZGF0YVR5cGU6MX1dLGRpc3BhdGNoR3JvdXA6e3g6bip1L2F9fSksZ2V0U2hhZGVyU291cmNlOlJ9LHtpbnB1dHM6W3RdLG91dHB1dHM6Wy0xXX0pWzBdLE09RD0+YFxcbiAgY29uc3QgSDogdTMyID0gJHtzfTtcXG4gIGNvbnN0IEM6IHUzMiA9ICR7dS9hfTtcXG4gIGNvbnN0IGltYWdlU2l6ZTogdTMyID0gJHtiKnUvYX07XFxuICBjb25zdCBlcHNpbG9uOiBmMzIgPSAke2R9O1xcblxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7d30+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZSA6IGFycmF5PCR7Zy50eXBlLnN0b3JhZ2V9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhcyA6IGFycmF5PCR7eC50eXBlLnN0b3JhZ2V9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHt3fT47XFxuXFxuICAke0QubWFpblN0YXJ0KCl9XFxuICAgICR7RC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFMpfVxcbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvIEM7XFxuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSBDO1xcblxcbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogaW1hZ2VTaXplO1xcbiAgICB2YXIgc3VtID0gJHtxZShcImYzMlwiLGEpfTtcXG4gICAgdmFyIHNxdWFyZWRTdW0gPSAke3FlKFwiZjMyXCIsYSl9O1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtifTsgaSsrKSB7XFxuICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dFtvZmZzZXQgKyBpICsgY3VycmVudENoYW5uZWxOdW1iZXIgKiAke2J9XTtcXG4gICAgICAgIHN1bSArPSB2YWx1ZVswXTtcXG4gICAgICAgIHNxdWFyZWRTdW0gKz0gdmFsdWVbMV07XFxuICAgIH1cXG4gICAgc3VtID0gc3VtIC8gZjMyKEgpO1xcbiAgICBzcXVhcmVkU3VtID0gc3F1YXJlZFN1bSAvIGYzMihIKTtcXG4gICAgbGV0IGludlN0ZERldiA9IDEgLyBzcXJ0KHNxdWFyZWRTdW0gLSBzdW0gKiBzdW0gKyBlcHNpbG9uKTtcXG4gICAgbGV0IGNoYW5uZWxTY2FsZSA9IGludlN0ZERldiAqICR7dn0oc2NhbGVbY3VycmVudENoYW5uZWxOdW1iZXJdKTtcXG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9ICR7dn0oYmlhc1tjdXJyZW50Q2hhbm5lbE51bWJlcl0pIC0gc3VtICogY2hhbm5lbFNjYWxlO1xcblxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3koXCJjaGFubmVsU2NhbGVcIixcImNoYW5uZWxTaGlmdFwiKX07XFxuICB9YDtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6SlNPTi5zdHJpbmdpZnkoe2NvbXBvbmVudHM6YSxuLGg6cyxjOnUsZXBzaWxvbjpkfSl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6W24sdSwyXSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoUy82NCl9fSksZ2V0U2hhZGVyU291cmNlOk19LHtpbnB1dHM6W1cscixvXSxvdXRwdXRzOlstMV19KVswXX0sc2Q9KGUsdCxyKT0+e2xldCBvPXRbMF0uZGltcyxuPW8scz1vWzBdLHU9b1tvLmxlbmd0aC0xXSxkPWsuc2l6ZUZyb21EaW1lbnNpb24obywxKS91LGE9bHQodSksbT1rLnNpemUobikvYSxnPUwoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLGEpLHg9WChcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsbixhKSxiPU1lKHRbMF0uZGF0YVR5cGUpLHc9YT09PTE/XCJ2ZWMyZlwiOmBtYXQyeCR7YX1mYCx2PWE9PT0xP2I6YHZlYyR7YX08JHtifT5gLHk9aWQoZSx0WzBdLHRbMV0sdFsyXSxzLGQsdSxyLmVwc2lsb24pLFM9QT0+YFxcbiAgY29uc3QgSDogdTMyID0gJHtkfTtcXG4gIGNvbnN0IEM6IHUzMiA9ICR7dS9hfTtcXG5cXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke2cudHlwZS5zdG9yYWdlfT47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlSW5wdXQgOiBhcnJheTwke3d9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHt4LnR5cGUuc3RvcmFnZX0+O1xcblxcbiAgJHtBLm1haW5TdGFydCgpfVxcbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvIChDICogSCk7XFxuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSBDO1xcblxcbiAgICBsZXQgc2NhbGVPZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiBDICsgY3VycmVudENoYW5uZWxOdW1iZXI7XFxuICAgIGxldCBzY2FsZSA9IHNjYWxlSW5wdXRbc2NhbGVPZmZzZXRdO1xcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7dn0oc2NhbGVbMF0pLCAke3Z9KHNjYWxlWzFdKSk7XFxuICB9YDtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHtyLmNhY2hlS2V5fWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NCl9fSksZ2V0U2hhZGVyU291cmNlOlN9LHtpbnB1dHM6W3RbMF0seV19KX0sRGk9ZT0+aWUoe2Vwc2lsb246ZS5lcHNpbG9uLGZvcm1hdDplLmZvcm1hdH0pLFdpPShlLHQpPT57dC5mb3JtYXQ9PT1cIk5IV0NcIj9zZChlLGUuaW5wdXRzLHQpOmUuY29tcHV0ZShhZChlLmlucHV0cyx0KSl9fSk7dmFyIHVkLGxkLFZpLEdpLE5pPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO2dlKCk7UGUoKTt2ZSgpO3VkPWU9PntpZighZXx8ZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuXCIpfSxsZD0oZSx0LHIpPT57bGV0IG89ZVswXS5kaW1zLG49ZVsxXSxzPWVbMl0sdT1vLGQ9ay5ub3JtYWxpemVBeGlzKHQuYXhpcyxvLmxlbmd0aCksYT1rLnNpemVUb0RpbWVuc2lvbihvLGQpLG09ay5zaXplRnJvbURpbWVuc2lvbihvLGQpLGc9ay5zaXplKG4uZGltcykseD1zP2suc2l6ZShzLmRpbXMpOjA7aWYoZyE9PW18fHMmJnghPT1tKXRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7bX0uXFxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXFxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7Z30gYW5kIGJpYXMgc2l6ZSBvZiAke3h9YCk7bGV0IGI9W107Zm9yKGxldCBNPTA7TTxvLmxlbmd0aDsrK00pTTxkP2IucHVzaChvW01dKTpiLnB1c2goMSk7bGV0IHc9bHQobSksdj1NZShlWzBdLmRhdGFUeXBlKSx5PVtMKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHcpLEwoXCJzY2FsZVwiLG4uZGF0YVR5cGUsbi5kaW1zLHcpXTtzJiZ5LnB1c2goTChcImJpYXNcIixzLmRhdGFUeXBlLHMuZGltcyx3KSkseS5wdXNoKFgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHUsdykpO2xldCBTPXI+MSxBPXI+MjtTJiZ5LnB1c2goWChcIm1lYW5EYXRhT3V0cHV0XCIsMSxiKSksQSYmeS5wdXNoKFgoXCJpbnZTdGRPdXRwdXRcIiwxLGIpKTtsZXQgUj1NPT5gXFxuICBjb25zdCBub3JtU2l6ZTogZjMyID0gJHttfTtcXG4gIGNvbnN0IG5vcm1TaXplVmVjdG9yaXplZDogdTMyID0gJHttL3d9O1xcbiAgY29uc3QgZXBzaWxvbjogZjMyID0gJHt0LmVwc2lsb259O1xcblxcbiAgJHtNLmRlY2xhcmVWYXJpYWJsZXMoLi4ueSl9XFxuICAke00ubWFpblN0YXJ0KCl9XFxuICAgICR7TS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGEpfVxcbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIG5vcm1TaXplVmVjdG9yaXplZDtcXG4gICAgdmFyIG1lYW5WZWN0b3IgPSAke3FlKFwiZjMyXCIsdyl9O1xcbiAgICB2YXIgbWVhblNxdWFyZVZlY3RvciA9ICR7cWUoXCJmMzJcIix3KX07XFxuXFxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgbm9ybVNpemVWZWN0b3JpemVkOyBoKyspIHtcXG4gICAgICBsZXQgdmFsdWUgPSAke0F0KHYsdyxcInhbaCArIG9mZnNldF1cIil9O1xcbiAgICAgIG1lYW5WZWN0b3IgKz0gdmFsdWU7XFxuICAgICAgbWVhblNxdWFyZVZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xcbiAgICB9XFxuICAgIGxldCBtZWFuID0gJHtodChcIm1lYW5WZWN0b3JcIix3KX0gLyBub3JtU2l6ZTtcXG4gICAgbGV0IG1lYW5TcXVhcmUgPSBzcXJ0KCR7aHQoXCJtZWFuU3F1YXJlVmVjdG9yXCIsdyl9IFxcbiAgICAgIC8gbm9ybVNpemUgLSBtZWFuICogbWVhbiArIGVwc2lsb24pO1xcblxcbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgbm9ybVNpemVWZWN0b3JpemVkOyBqKyspIHtcXG4gICAgICBsZXQgZjMyaW5wdXQgPSAke0F0KHYsdyxcInhbaiArIG9mZnNldF1cIil9O1xcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7QXQodix3LFwic2NhbGVbal1cIil9O1xcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7eVswXS50eXBlLnZhbHVlfSgoZjMyaW5wdXQgLSBtZWFuKSAvIG1lYW5TcXVhcmUgKiBmMzJzY2FsZVxcbiAgICAgICAgJHtzP2ArICR7QXQodix3LFwiYmlhc1tqXVwiKX1gOlwiXCJ9XFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICAke1M/XCJtZWFuRGF0YU91dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW5cIjpcIlwifTtcXG4gICAgJHtBP1wiaW52U3RkT3V0cHV0W2dsb2JhbF9pZHhdID0gMSAvIG1lYW5TcXVhcmVcIjpcIlwifTtcXG4gIH1gLFc9W3tkaW1zOnUsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiBTJiZXLnB1c2goe2RpbXM6YixkYXRhVHlwZToxfSksQSYmVy5wdXNoKHtkaW1zOmIsZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke2UubGVuZ3RofWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpXLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpSfX0sVmk9ZT0+aWUoe2F4aXM6ZS5heGlzLGVwc2lsb246ZS5lcHNpbG9ufSksR2k9KGUsdCk9Pnt1ZChlLmlucHV0cyksZS5jb21wdXRlKGxkKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCkpfX0pO3ZhciBkZCxVaSxMaT1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtpcigpO2RkPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sVWk9ZT0+e2RkKGUuaW5wdXRzKTtsZXQgdD1RZS5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7ZS5jb21wdXRlKExyKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCIsYWN0aXZhdGlvbkNhY2hlS2V5OlwiXCJ9LHQpKX19KTt2YXIgY2QscGQsZmQsbWQsaGQsZ2QseWQsYmQsd2QsRmksSGksamk9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTtQZSgpO3ZlKCk7Y2Q9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIlRvbyBmZXcgaW5wdXRzXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGUgbXVzdCBiZSBmbG9hdC5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxwZD0oZSx0LHIsbyxuLHMsdSk9PntsZXQgZD1yLmxlbmd0aCxhPVwiXCI7Zm9yKGxldCBtPWQtMTttPj0wOy0tbSlhKz1gXFxuICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixtKX0pIC0gJHtuW21dfTtcXG4gICAgICAgICAgICBpZiAoayA8IDApIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoayA+PSAke3JbbV19KSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke29bbV19O1xcbiAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgICAgIHZhbHVlID0gJHtzfSgke3V9KTtcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcXG4gICAgICAgICAgICB2YXIgayA9IDA7XFxuICAgICAgICAgICAgJHthfVxcbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xcbiAgICAgICAgICB9XFxuICAgICAgYH0sZmQ9KGUsdCxyLG8sbik9PntsZXQgcz1yLmxlbmd0aCx1PVwiXCI7Zm9yKGxldCBkPXMtMTtkPj0wOy0tZCl1Kz1gXFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsZCl9KSAtICR7bltkXX07XFxuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xcbiAgICAgICAgICAgICAgICAgIGsgPSAtaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgbGV0IF8ybl8xID0gJHsyKihyW2RdLTEpfTtcXG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xcbiAgICAgICAgICAgICAgICAgIGlmKGsgPj0gJHtyW2RdfSkge1xcbiAgICAgICAgICAgICAgICAgICAgayA9IF8ybl8xIC0gaztcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke29bZF19O1xcbiAgICAgICAgICAgIGA7cmV0dXJuYFxcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XFxuICAgICAgICAgICAgICB2YXIgayA9IDA7XFxuICAgICAgICAgICAgICAke3V9XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcXG4gICAgICAgICAgYH0sbWQ9KGUsdCxyLG8sbik9PntsZXQgcz1yLmxlbmd0aCx1PVwiXCI7Zm9yKGxldCBkPXMtMTtkPj0wOy0tZCl1Kz1gXFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsZCl9KSAtICR7bltkXX07XFxuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChrID49ICR7cltkXX0pIHtcXG4gICAgICAgICAgICAgICAgICBrID0gJHtyW2RdLTF9O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogJHtvW2RdfTtcXG4gICAgICAgICAgICBgO3JldHVybmBcXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xcbiAgICAgICAgICAgICAgJHt1fVxcbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XFxuICAgICAgICAgIGB9LGhkPShlLHQscixvLG4pPT57bGV0IHM9ci5sZW5ndGgsdT1cIlwiO2ZvcihsZXQgZD1zLTE7ZD49MDstLWQpdSs9YFxcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGQpfSkgLSAke25bZF19O1xcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XFxuICAgICAgICAgICAgICAgICAgayArPSAke3JbZF19O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChrID49ICR7cltkXX0pIHtcXG4gICAgICAgICAgICAgICAgICBrIC09ICR7cltkXX07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke29bZF19O1xcbiAgICAgICAgICAgIGA7cmV0dXJuYFxcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XFxuICAgICAgICAgICAgICB2YXIgayA9IDA7XFxuICAgICAgICAgICAgICAke3V9XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcXG4gICAgICAgICAgYH0sZ2Q9KGUsdCxyLG8sbixzKT0+e3N3aXRjaChuLm1vZGUpe2Nhc2UgMDpyZXR1cm4gcGQoZSx0LHIsbyxuLnBhZHMscyxuLnZhbHVlKTtjYXNlIDE6cmV0dXJuIGZkKGUsdCxyLG8sbi5wYWRzKTtjYXNlIDI6cmV0dXJuIG1kKGUsdCxyLG8sbi5wYWRzKTtjYXNlIDM6cmV0dXJuIGhkKGUsdCxyLG8sbi5wYWRzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LHlkPShlLHQscixvKT0+e2xldCBuPXRbMF0uZGltcyxzPWsucGFkU2hhcGUobi5zbGljZSgpLHIucGFkcyksdT1rLnNpemUocyksZD1rLmNvbXB1dGVTdHJpZGVzKG4pLGE9WChcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUscyksbT1MKFwieFwiLHRbMF0uZGF0YVR5cGUsbiksZz1nZChhLHMsbixkLHIsbyk7cmV0dXJuYFxcbiAgICAgICAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXMobSxhKX1cXG4gICAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHUpfVxcblxcbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke299KDApO1xcbiAgICAgICAgICAgICAgJHtnfVxcbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICAgICAgICAgIH1gfSxiZD0oZSx0KT0+e2xldCByPWsucGFkU2hhcGUoZVswXS5kaW1zLnNsaWNlKCksdC5wYWRzKTtyZXR1cm57bmFtZTpcIlBhZFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoay5zaXplKHIpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bz0+eWQobyxlLHQsXCJmMzJcIil9fSx3ZD0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLG89ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbj1lWzBdLmRpbXMubGVuZ3RoLHM9bmV3IEludDMyQXJyYXkoMipuKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgZD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IGE9MDthPGQubGVuZ3RoO2ErKylzW051bWJlcihkW2FdKV09TnVtYmVyKHJbYV0pLHNbTnVtYmVyKGRbYV0pK25dPU51bWJlcihyW2ErZC5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgoZCxhKT0+c1tOdW1iZXIoYSldPU51bWJlcihkKSk7bGV0IHU9W107cmV0dXJuIHMuZm9yRWFjaChkPT51LnB1c2goZCkpLGllKHttb2RlOnQubW9kZSx2YWx1ZTpvLHBhZHM6dX0pfWVsc2UgcmV0dXJuIHR9LEZpPShlLHQpPT57Y2QoZS5pbnB1dHMpO2xldCByPXdkKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShiZChlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxIaT1lPT57bGV0IHQ9ZS5tb2RlLHI9ZS52YWx1ZSxvPWUucGFkcztyZXR1cm4gaWUoe21vZGU6dCx2YWx1ZTpyLHBhZHM6b30pfX0pO3ZhciBIcixLaSxxaSxZaSxYaSxKaSxaaSxRaSxlcyx0cyxycyxucyxvcyxhcyxpcyxzcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7SHI9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHN1cHBvcnRzIDEtRCBvciAyLUQgaW5wdXRzIG9ubHkgZm9yIG5vdy5cIil9LEtpPShlLHQscik9PntsZXQgbz10LmZvcm1hdD09PVwiTkhXQ1wiLG49ZS5kaW1zLnNsaWNlKCk7byYmbi5zcGxpY2UoMSwwLG4ucG9wKCkpO2xldCBzPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIiksdT10Lmtlcm5lbFNoYXBlLnNsaWNlKCksZD10LnN0cmlkZXMuc2xpY2UoKSxhPXM/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxtPXQucGFkcy5zbGljZSgpO0N0LmFkanVzdFBvb2xBdHRyaWJ1dGVzKHIsbix1LGQsYSxtKTtsZXQgZz1DdC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKHIsbixkLGEsdSxtLHQuYXV0b1BhZCkseD1PYmplY3QuYXNzaWduKHt9LHQpO3M/T2JqZWN0LmFzc2lnbih4LHtrZXJuZWxTaGFwZTp1LHN0cmlkZXM6ZCxwYWRzOm0sZGlsYXRpb25zOmEsY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24oeCx7a2VybmVsU2hhcGU6dSxzdHJpZGVzOmQscGFkczptLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTtsZXQgYj1nLnNsaWNlKCk7cmV0dXJuIGIucHVzaChiLnNwbGljZSgxLDEpWzBdKSxbeCxvP2I6Z119LHFpPShlLHQscixvLG4scyx1LGQpPT57bGV0IGE9bi5mb3JtYXQ9PT1cIk5IV0NcIixtPXIsZz10LnR5cGUudmFsdWUseD1tLmxlbmd0aCxiPWsuc2l6ZShvKSx3PVgoXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLG8pO2lmKG4ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgdj1uLmtlcm5lbFNoYXBlW24ua2VybmVsU2hhcGUubGVuZ3RoLTFdLHk9bi5zdHJpZGVzW24uc3RyaWRlcy5sZW5ndGgtMV0sUz1uLnBhZHNbbi5wYWRzLmxlbmd0aC8yLTFdLEE9bi5wYWRzW24ucGFkcy5sZW5ndGgtMV0sUj14LShhPzI6MSksVz1cIlwiLE09XCJcIixEPVwiXCI7aWYoUytBIT09MD9XPWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke3Z9dTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtSfV0gPSBpbmRpY2VzWyR7Un1dICogJHt5fSAtICR7U30gKyBpO1xcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske1J9XSA8IDAgfHwgeEluZGljZXNbJHtSfV0gPj0gJHttW1JdfSkge1xcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICAgICAke3N9XFxuICAgICAgICAgICAgICAgIH1gOlc9YFxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7dn11OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske1J9XSA9IGluZGljZXNbJHtSfV0gKiAke3l9IC0gJHtTfSArIGk7XFxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICAgICAke3N9XFxuICAgICAgICAgICAgICAgIH1gLG4ua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IHo9bi5rZXJuZWxTaGFwZVtuLmtlcm5lbFNoYXBlLmxlbmd0aC0yXSxGPW4uc3RyaWRlc1tuLnN0cmlkZXMubGVuZ3RoLTJdLHE9bi5wYWRzW24ucGFkcy5sZW5ndGgvMi0yXSxsZT1uLnBhZHNbbi5wYWRzLmxlbmd0aC0yXSxCPXgtKGE/MzoyKSxLPW1bQl07cStsZSE9PTA/TT1gXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgJHt6fXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Qn1dID0gaW5kaWNlc1ske0J9XSAqICR7Rn0gLSAke3F9ICsgajtcXG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtCfV0gPCAwIHx8IHhJbmRpY2VzWyR7Qn1dID49ICR7S30pIHtcXG4gICAgICAgICAgICAgICAgICAgIHBhZCs9ICR7dn07XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBgOk09YFxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8ICR7en11OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske0J9XSA9IGluZGljZXNbJHtCfV0gKiAke0Z9IC0gJHtxfSArIGo7XFxuICAgICAgICAgICAgICAgIGAsRD1gXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgYH1yZXR1cm5gXFxuICAgICAgICAgICAgJHtlLmRlY2xhcmVWYXJpYWJsZXModCx3KX1cXG5cXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhiKX1cXG5cXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcblxcbiAgICAgICAgICAgICAgdmFyIHZhbHVlOiAke2d9ID0gJHtnfSgke2R9KTtcXG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xcbiAgICAgICAgICAgICAgJHtNfVxcbiAgICAgICAgICAgICAgJHtXfVxcbiAgICAgICAgICAgICAgJHtEfVxcbiAgICAgICAgICAgICAgJHt1fVxcblxcbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICAgICAgICAgICAgfWB9ZWxzZXtpZihhKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgdj1rLnNpemUobi5rZXJuZWxTaGFwZSkseT1rLmNvbXB1dGVTdHJpZGVzKG4ua2VybmVsU2hhcGUpLFM9eS5sZW5ndGgsQT1uLnBhZHMubGVuZ3RoLFI9bi5wYWRzLnJlZHVjZSgoRCxfKT0+RCtfKSxXPVwiXCI7cmV0dXJuIFI/Vz1gXFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSBpbnB1dERpbXNbal0pIHtcXG4gICAgICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGlmICghaXNQYWQpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICAgJHtzfVxcbiAgICAgICAgICAgICAgfWA6Vz1gXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgJHtzfVxcbiAgICAgICAgICAgIGAsYFxcbiAgICAgICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKHQsdyl9XFxuXFxuICAgICAgICAgICAgY29uc3QgcGFkcyA9IGFycmF5PHUzMiwgJHtBfT4oJHtuLnBhZHMubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICAgICAgY29uc3QgaW5wdXREaW1zID0gYXJyYXk8dTMyLCAke3h9Pigke20ubWFwKEQ9PmAke0R9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICAgICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IGFycmF5PHUzMiwgJHtTfT4oJHt5Lm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgICAgIGNvbnN0IHN0cmlkZXMgPSBhcnJheTx1MzIsICR7U30+KCR7bi5zdHJpZGVzLm1hcChEPT5gJHtEfXVgKS5qb2luKFwiLFwiKX0pO1xcblxcbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGIpfVxcblxcbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAgICAgICBsZXQgeEluZGljZXMgPSAke3cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke1N9PjtcXG5cXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7dy50eXBlLnZhbHVlfSgke2R9KTtcXG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XFxuXFxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7dn11OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7Uy0xfXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyBrZXJuZWxTdHJpZGVzW2pdO1xcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICoga2VybmVsU3RyaWRlc1tqXTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7Uy0xfV0gPSBvZmZzZXQ7XFxuXFxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3gtU311OyBqIDwgJHt4fXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7eC1TfXVdXFxuICAgICAgICAgICAgICAgICAgICArIG9mZnNldHNbaiAtICR7eC1TfXVdIC0gcGFkc1tqIC0gMnVdO1xcbiAgICAgICAgICAgICAgICAgICR7V31cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICR7dX1cXG5cXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1gfX0sWWk9ZT0+KHtmb3JtYXQ6ZS5mb3JtYXQsYXV0b1BhZDpbXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLGNlaWxNb2RlOmUuY2VpbF9tb2RlLGtlcm5lbFNoYXBlOmUua2VybmVsX3NoYXBlLHN0cmlkZXM6ZS5zdHJpZGVzLHBhZHM6ZS5wYWRzfSksWGk9KGUsdCxyLG8pPT57bGV0W24sc109S2kodCxvLHIpLHU9ay5zaXplKG4ua2VybmVsU2hhcGUpLGQ9TChcInhcIix0LmRhdGFUeXBlLHQuZGltcyksYT1kLnR5cGUudmFsdWUsbT1cInZhbHVlICs9IHhfdmFsO1wiLGc9XCJcIjtyZXR1cm4gbi5jb3VudEluY2x1ZGVQYWQ/Zys9YHZhbHVlIC89ICR7YX0oJHt1fSk7YDpnKz1gdmFsdWUgLz0gJHthfSgke3V9IC0gcGFkKTtgLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6by5jYWNoZUtleX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChrLnNpemUocykvNjQpfX0pLGdldFNoYWRlclNvdXJjZTp4PT5xaSh4LGQsdC5kaW1zLHMsbixtLGcsXCIwLjBcIil9fSxKaT1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAscj1ZaShlKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO3JldHVybiBpZSh7Y291bnRJbmNsdWRlUGFkOnQsLi4ucn0pfSxaaT0oZSx0KT0+e0hyKGUuaW5wdXRzKSxlLmNvbXB1dGUoWGkoXCJBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0sUWk9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdLGNhY2hlS2V5OlwiXCJ9LGVzPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4uUWksY2FjaGVLZXk6dH19LHRzPShlLHQpPT57SHIoZS5pbnB1dHMpLGUuY29tcHV0ZShYaShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfSxycz0oZSx0LHIsbyk9PntsZXRbbixzXT1LaSh0LG8sciksdT1gXFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcXG4gICAgYCxkPVwiXCIsYT1MKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50Om8uY2FjaGVLZXl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoay5zaXplKHMpLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bT0+cWkobSxhLHQuZGltcyxzLG4sdSxkLFwiLTFlNVwiKX19LG5zPShlLHQpPT57SHIoZS5pbnB1dHMpLGUuY29tcHV0ZShycyhcIk1heFBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LG9zPWU9PntsZXQgdD1lLnN0b3JhZ2Vfb3JkZXIscj1lLmRpbGF0aW9ucyxvPVlpKGUpO2lmKHQhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKG8uY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtyZXR1cm4gaWUoe3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpyLC4uLm99KX0sYXM9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5RaSxjYWNoZUtleTp0fX0saXM9KGUsdCk9PntIcihlLmlucHV0cyksZS5jb21wdXRlKHJzKFwiR2xvYmFsTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX19KTt2YXIganI9SCgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIHVzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtqcigpfSk7dmFyIGxzLGRzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtscz1cIjEuMTcuMC1kZXYuMjAyMzExMDMtMTQzOWRhMzZmZVwifSk7dmFyIGNzLFduLHBzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtkcygpO2NzPVwid2FybmluZ1wiLFduPXt3YXNtOnt9LHdlYmdsOnt9LHdlYmdwdTp7fSx2ZXJzaW9uczp7Y29tbW9uOmxzfSxzZXQgbG9nTGV2ZWwoZSl7aWYoZSE9PXZvaWQgMCl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCJ8fFtcInZlcmJvc2VcIixcImluZm9cIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJmYXRhbFwiXS5pbmRleE9mKGUpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCk7Y3M9ZX19LGdldCBsb2dMZXZlbCgpe3JldHVybiBjc319O09iamVjdC5kZWZpbmVQcm9wZXJ0eShXbixcImxvZ0xldmVsXCIse2VudW1lcmFibGU6ITB9KX0pO3ZhciBmcyxtcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cHMoKTtmcz1Xbn0pO3ZhciBocz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgZ3M9SCgoKT0+e1widXNlIHN0cmljdFwiO0tyKCl9KTt2YXIgYnM9SCgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIHdzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtLcigpfSk7dmFyIEtyPUgoKCk9PntcInVzZSBzdHJpY3RcIjtocygpO2dzKCk7YnMoKTt3cygpfSk7dmFyIHFyPUgoKCk9PntcInVzZSBzdHJpY3RcIjtLcigpfSk7dmFyIHZzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtqcigpO3FyKCl9KTt2YXIgJHM9SCgoKT0+e1widXNlIHN0cmljdFwiO3ZzKCl9KTt2YXIgeHM9SCgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFNzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtqcigpO3FyKCl9KTt2YXIgQ3M9SCgoKT0+e1widXNlIHN0cmljdFwiO1NzKCl9KTt2YXIgQXM9SCgoKT0+e1widXNlIHN0cmljdFwiO3VzKCk7bXMoKTskcygpO3FyKCk7eHMoKTtDcygpfSk7dmFyIFNkLENkLElzLEVzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtBcygpO0RlKCk7dmUoKTtTZD0oZSx0LHIpPT57bGV0IG89ZT09PXQsbj1lPHQmJnI8MCxzPWU+dCYmcj4wO2lmKG98fG58fHMpdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzXFwnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLlwiKX0sQ2Q9KGUsdCxyLG8pPT57bGV0IG49TWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL3IpKSxzPVtuXSx1PW4sZD1YKFwib3V0cHV0XCIsbyxzKSxhPWQudHlwZS5zdG9yYWdlLG09Zz0+YFxcbiAgICAgICAgJHtnLmRlY2xhcmVWYXJpYWJsZXMoZCl9XFxuICAgICAgICAke2cubWFpblN0YXJ0KCl9XFxuICAgICAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh1KX1cXG4gICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YX0oJHtlfSkgKyAke2F9KGdsb2JhbF9pZHgpICogJHthfSgke3J9KTtcXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlJhbmdlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6W2UsdCxyXS5tYXAoZz0+Zy50b1N0cmluZygpKS5qb2luKFwiX1wiKX0sZ2V0U2hhZGVyU291cmNlOm0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh1LzY0KX19KX19LElzPWU9PntsZXQgdD0wLHI9MCxvPTA7ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT02Pyh0PWUuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXSxvPWUuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXSk6ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT0xJiYodD1lLmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdLG89ZS5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0pLGZzLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmU2QodCxyLG8pLGUuY29tcHV0ZShDZCh0LHIsbyxlLmlucHV0c1swXS5kYXRhVHlwZSkse2lucHV0czpbXX0pfX0pO3ZhciBBZCxJZCxFZCxUZCxPZCxfZCxSZCxQZCxNZCxCZCxrZCxEZCxXZCx6ZCxWZCxUcyxPcyxfcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7QWQ9KGUsdCk9PntpZihlLmV2ZXJ5KHI9PnI+MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmVcIil9KSksZS5sZW5ndGg+MCl7aWYodC5tb2RlPT09XCJsaW5lYXJcIil7aWYoIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgbGluZWFyIG1vZGVcIil9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSxJZD0oZSx0LHIpPT57dC5ldmVyeShuPT5uPj0wJiZuPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IG89bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobixzKT0+b1tuXT1lW3NdKSxvfSxFZD0oZSx0LHIsbyxuLHMpPT57bGV0W3UsZCxhXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0sbT1lWzBdLmRpbXMubGVuZ3RoO2lmKHU+MCYmZS5sZW5ndGg+dSYmZVt1XS5kaW1zLmxlbmd0aD4wKWVbdV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChnPT5zLnB1c2goZykpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoZD4wJiZlLmxlbmd0aD5kJiZlW2RdLmRpbXMubGVuZ3RoPjApe2lmKGVbZF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChnPT5vLnB1c2goZykpLG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT1tJiZyPj0xOCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7QWQobyx0KSx0LmF4ZXMubGVuZ3RoPjAmJklkKG8sdC5heGVzLG0pLmZvckVhY2goKGcseCk9Pm9beF09Zyl9aWYoYT4wJiZlLmxlbmd0aD5hJiYoZVthXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChnPT5uLnB1c2goTnVtYmVyKGcpKSksbi5sZW5ndGghPT1tfHxyPj0xOCYmbi5sZW5ndGg9PT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihvLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFxcJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZFxcJyk7aWYobi5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcXCdSZXNpemUgcmVxdWlyZXMgXCJzaXplc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgcmFuayBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkXFwnKX1pZih0eXBlb2YgbzxcInVcIiYmdHlwZW9mIG48XCJ1XCImJm8ubGVuZ3RoPjAmJm4ubGVuZ3RoPm0pdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sVGQ9ZT0+XCJmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IGYzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IGYzMiwgICAgbGVuZ3RoT3JpZ2luYWw6IGYzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+IGYzMiB7IFwiKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuXCJyZXR1cm4geFJlc2l6ZWQgLyB4U2NhbGU7XCI7Y2FzZVwicHl0b3JjaF9oYWxmX3BpeGVsXCI6cmV0dXJuXCJpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHhSZXNpemVkICsgMC41KSAvIHhTY2FsZSAtIDAuNTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5cInJldHVybiAoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlO1wiO2Nhc2VcImFsaWduX2Nvcm5lcnNcIjpyZXR1cm5cImlmIChsZW5ndGhSZXNpemVkID09IDEpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVyblwiaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvaVN0YXJ0ICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgKyAgICAgICAgICAgICAgICAgICAgICAgICAgICh4UmVzaXplZCAqIChyb2lFbmQgLSByb2lTdGFydCkgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAocm9pU3RhcnQgKyByb2lFbmQpICogZjMyKGxlbmd0aE9yaWdpbmFsIC0gMSk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJoYWxmX3BpeGVsX3N5bW1ldHJpY1wiOnJldHVybltcImNvbnN0IG91dHB1dFdpZHRoID0geFNjYWxlICogbGVuZ3RoUmVzaXplZDtcIixcImNvbnN0IGFkanVzdG1lbnQgPSBsZW5ndGhSZXNpemVkIC8gb3V0cHV0V2lkdGg7XCIsXCJjb25zdCBjZW50ZXIgPSBsZW5ndGhPcmlnaW5hbCAvIDI7XCIsXCJjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1wiLFwicmV0dXJuIG9mZnNldCArICgoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlKSAtIDAuNTtcIl0uam9pbihgXFxuYCk7Y2FzZVwiaGFsZl9waXhlbFwiOnJldHVyblwicmV0dXJuICgoeFJlc2l6ZWQgKyAwLjUpIC8geFNjYWxlKSAtIDAuNTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLE9kPShlLHQpPT5cImZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6IGYzMiwgaXNEb3duU2FtcGxlOiBib29sKSAtPiBmMzIge1wiKygoKT0+e3N3aXRjaChlKXtjYXNlXCJyb3VuZF9wcmVmZXJfY2VpbFwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgIH1cIjtjYXNlXCJmbG9vclwiOnJldHVyblwicmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7XCI7Y2FzZVwiY2VpbFwiOnJldHVyblwicmV0dXJuIGNlaWwoeE9yaWdpbmFsKTtcIjtjYXNlXCJyb3VuZF9wcmVmZXJfZmxvb3JcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9vcih4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwic2ltcGxlXCI6ZGVmYXVsdDppZih0PDExKXJldHVyblwiaWYgKGlzRG93blNhbXBsZSkgICAgICAgICAgICAgICAgICAgICB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyAgICAgICAgICAgICAgICAgICAgIH1cIjt0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLF9kPShlLHQscik9PntsZXQgbz1uZXcgQXJyYXkocikuZmlsbCgwKS5jb25jYXQobmV3IEFycmF5KHIpLmZpbGwoMSkpLG49ZS5sZW5ndGg9PT0wP286ZS5zbGljZSgpO3JldHVybiB0Lmxlbmd0aD4wPyh0LmZvckVhY2goKHMsdSk9PntvW3NdPW5bdV0sb1t1K3JdPW5bdC5sZW5ndGgrdV19KSxvKTpufSxSZD0oZSx0LHIsbyk9PntsZXQgbj1bXTtpZihyLmxlbmd0aD4wKWlmKG8ubGVuZ3RoPjApe2lmKGUuZm9yRWFjaChzPT5uLnB1c2gocykpLE1hdGgubWF4KC4uLm8pPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMgaXMgb3V0IG9mIGJvdW5kXCIpO28uZm9yRWFjaCgocyx1KT0+bltzXT1yW3VdKX1lbHNlIHIuZm9yRWFjaChzPT5uLnB1c2gocykpO2Vsc2V7aWYodC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLlwiKTtuPWUubWFwKChzLHUpPT5NYXRoLnJvdW5kKHMqdFt1XSkpfXJldHVybiBufSxQZD0oZSx0LHIsbyk9PntsZXQgbj0oKCk9Pntzd2l0Y2goby5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gby5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLm8uYXhlcy5tYXAodT0+clt1XSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4ucixOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiBvLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4uby5heGVzLm1hcCh1PT5yW3VdKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi5yLE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHtvLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7ci5maWxsKDEsMCxyLmxlbmd0aCk7bGV0IHM9ZS5zbGljZSgpO3JldHVybiBvLmF4ZXMubGVuZ3RoPjA/KG8uYXhlcy5mb3JFYWNoKHU9PnJbdV09biksby5heGVzLmZvckVhY2godT0+c1t1XT1NYXRoLnJvdW5kKGVbdV0qclt1XSkpKTooci5maWxsKG4sMCxyLmxlbmd0aCkscy5mb3JFYWNoKCh1LGQpPT5zW2RdPU1hdGgucm91bmQodSpyW2RdKSkpLHN9LE1kPShlLHQscixvLG4pPT5gXFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTxmMzIsICR7ci5sZW5ndGh9PiB7XFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGFycmF5PHUzMiwgJHt0Lmxlbmd0aH0+KCR7dC5tYXAocz0+YCR7c311YCkuam9pbihcIixcIil9KTtcXG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGFycmF5PHUzMiwgJHtyLmxlbmd0aH0+KCR7ci5tYXAocz0+YCR7c311YCkuam9pbihcIixcIil9KTtcXG4gICAgICBjb25zdCBzY2FsZXMgPSBhcnJheTxmMzIsICR7by5sZW5ndGh9Pigke28ubWFwKHM9PmAke3N9ZmApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgY29uc3Qgcm9pID0gYXJyYXk8ZjMyLCAke24ubGVuZ3RofT4oJHtuLm1hcChzPT5gJHtzfWZgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXM6IGFycmF5PGYzMiwgJHtyLmxlbmd0aH0+O1xcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcXG4gICAgICAgIHZhciBvdXRwdXRJbmRleCA9ICR7ci5sZW5ndGg9PT0xP1wib3V0cHV0SW5kaWNlc1wiOlwib3V0cHV0SW5kaWNlc1tpXVwifTtcXG4gICAgICAgIGlmIChzY2FsZXNbaV0gPT0gMS4wKSB7XFxuICAgICAgICAgIG9yaWdpbmFsSW5kaWNlc1tpXSA9IGYzMihvdXRwdXRJbmRleCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvcmlnaW5hbEluZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoZjMyKG91dHB1dEluZGV4KSwgc2NhbGVzW2ldLFxcbiAgICAgICAgICAgICAgICBmMzIob3V0cHV0U2hhcGVbaV0pLCBmMzIoaW5wdXRTaGFwZVtpXSksIHJvaVtpXSwgcm9pW2kgKyAke3QubGVuZ3RofV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gb3JpZ2luYWxJbmRpY2VzO1xcbiAgICB9YCxCZD0oZSx0LHIsbyxuLHMsdSk9PmBcXG4gICAgZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcXG4gICAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBhcnJheTx1MzIsICR7ci5sZW5ndGh9Pigke3IubWFwKGQ9PmAke2R9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGFycmF5PHUzMiwgJHtvLmxlbmd0aH0+KCR7by5tYXAoZD0+YCR7ZH11YCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHNjYWxlcyA9IGFycmF5PGYzMiwgJHtuLmxlbmd0aH0+KCR7bi5tYXAoZD0+YCR7ZH1mYCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHJvaSA9IGFycmF5PGYzMiwgJHtzLmxlbmd0aH0+KCR7cy5tYXAoZD0+YCR7ZH1mYCkuam9pbihcIixcIil9KTtcXG4gICAgICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xcbiAgICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtvLmxlbmd0aH07IGkrKykge1xcbiAgICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke28ubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpcIm91dHB1dEluZGljZXNbaV1cIn07XFxuICAgICAgICAgIHZhciBpbnB1dEluZGV4OiB1MzI7XFxuICAgICAgICAgIGlmIChzY2FsZXNbaV0gPT0gMS4wKSB7XFxuICAgICAgICAgICAgaW5wdXRJbmRleCA9IG91dHB1dEluZGV4O1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoZjMyKG91dHB1dEluZGV4KSwgc2NhbGVzW2ldLFxcbiAgICAgICAgICAgICAgICAgICAgZjMyKG91dHB1dFNoYXBlW2ldKSwgZjMyKGlucHV0U2hhcGVbaV0pLCByb2lbaV0sIHJvaVtpICsgJHtyLmxlbmd0aH1dKTtcXG4gICAgICAgICAgICBpZiAoISR7dX0gfHwgKG9yaWdpbmFsX2lkeCA+PSAwICYmIG9yaWdpbmFsX2lkeCA8IGYzMihpbnB1dFNoYXBlW2ldKSkpIHtcXG4gICAgICAgICAgICAgIGlmIChvcmlnaW5hbF9pZHggPCAwKSB7XFxuICAgICAgICAgICAgICAgIGlucHV0SW5kZXggPSAwO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAoZjMyKGlucHV0U2hhcGVbaV0pIC0gMSkpIHtcXG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IGlucHV0U2hhcGVbaV0gLSAxO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZXNbaV0gPCAxKSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGlucHV0SW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcImlcIixcImlucHV0SW5kZXhcIil9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaW5wdXRJbmRpY2VzO1xcbiAgICB9YCxrZD0oZSx0KT0+YFxcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBib29sIHtcXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3QubGVuZ3RofT4oJHt0Lm1hcChyPT5gJHtyfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcXG4gICAgICAgIHZhciBpbnB1dEluZGV4ID0gJHt0Lmxlbmd0aD09PTE/XCJpbnB1dEluZGljZXNcIjpcImlucHV0SW5kaWNlc1tpXVwifTtcXG4gICAgICAgIGlmIChpbnB1dEluZGV4IDwgMCB8fCBpbnB1dEluZGV4ID49IGlucHV0U2hhcGVbaV0pIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfWAsRGQ9KGUsdCxyLG8sbixzLHUpPT57bGV0W2QsYSxtLGddPXIubGVuZ3RoPT09Mj9bLTEsMCwxLC0xXTpuWzFdPT09MT9bMCwyLDMsMV06WzAsMSwyLDNdO3JldHVybmBcXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gZjMyIHtcXG4gICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcXG4gICAgICBpbnB1dEluZGljZXNbJHthfV0gPSBtYXgoMCwgbWluKHJvdywgJHtyW2FdfSAtIDEpKTtcXG4gICAgICBpbnB1dEluZGljZXNbJHttfV0gPSBtYXgoMCwgbWluKGNvbCwgJHtyW21dfSAtIDEpKTtcXG4gICAgICBpZiAoJHtyLmxlbmd0aH0gPiAyKSB7XFxuICAgICAgICBpbnB1dEluZGljZXNbJHtnfV0gPSBjaGFubmVsO1xcbiAgICAgICAgaW5wdXRJbmRpY2VzWyR7ZH1dID0gYmF0Y2g7XFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gaW5wdXRbJHtlLmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc1wiKX1dO1xcbiAgICB9XFxuXFxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gZjMyIHtcXG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0SW5kaWNlcyk7XFxuICAgICAgdmFyIHJvdzpmMzIgPSBvcmlnaW5hbEluZGljZXNbJHthfV07XFxuICAgICAgdmFyIGNvbDpmMzIgPSBvcmlnaW5hbEluZGljZXNbJHttfV07XFxuICAgICAgaWYgKCR7c30gJiYgKHJvdyA8IDAgfHwgcm93ID4gKCR7clthXX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICR7clttXX0gLSAxKSkge1xcbiAgICAgICAgcmV0dXJuICR7dX07XFxuICAgICAgfVxcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke3JbYV19IC0gMSkpO1xcbiAgICAgIGNvbCA9IG1heCgwLCBtaW4oY29sLCAke3JbbV19IC0gMSkpO1xcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcXG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XFxuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcXG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAwO1xcbiAgICAgIHZhciBiYXRjaDogdTMyID0gMDtcXG4gICAgICBpZiAoJHtyLmxlbmd0aD4yfSkge1xcbiAgICAgICAgY2hhbm5lbCA9IHUzMihvcmlnaW5hbEluZGljZXNbJHtnfV0pO1xcbiAgICAgICAgYmF0Y2ggPSB1MzIob3JpZ2luYWxJbmRpY2VzWyR7ZH1dKTtcXG4gICAgICB9XFxuICAgICAgdmFyIHgxMTogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XFxuICAgICAgdmFyIHgxMjogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XFxuICAgICAgdmFyIHgyMTogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XFxuICAgICAgdmFyIHgyMjogZjMyID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XFxuICAgICAgdmFyIGR4MTogZjMyID0gcm93IC0gZjMyKHJvdzEpO1xcbiAgICAgIHZhciBkeDI6IGYzMiA9IGYzMihyb3cyICkgLSByb3c7XFxuICAgICAgdmFyIGR5MSA9IGNvbCAtIGYzMihjb2wxKTtcXG4gICAgICB2YXIgZHkyID0gZjMyKGNvbDIpIC0gY29sO1xcbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcXG4gICAgfWB9LFdkPShlLHQscixvLG4scyx1LGQsYSxtKT0+e2xldFtnLHhdPXIubGVuZ3RoPT09Mj9bMCwxXTpuWzFdPT09MT9bMiwzXTpbMSwyXSxiPXc9PntsZXQgdj13PT09Zz9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxcbiAgICAgIGZuICR7dn1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSwgb3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+IGYzMiB7XFxuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke28ubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpgb3V0cHV0SW5kaWNlc1ske3d9XWB9O1xcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiBmMzIgPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoZjMyKG91dHB1dEluZGV4KSwgJHtuW3ddfSxcXG4gICAgICAgIGYzMigke29bd119KSwgZjMyKCR7clt3XX0pLCAke3Nbd119LCAke3Nbd119ICsgJHtyLmxlbmd0aH0pO1xcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6IGYzMiA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XFxuXFxuICAgICAgICBpZiAoJHtkfSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7clt3XX0gLSAxKSkpIHtcXG4gICAgICAgICAgcmV0dXJuICR7YX07XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZGF0YTogYXJyYXk8ZjMyLCA0PiA9IGFycmF5PGYzMiwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XFxuICAgICAgICAgIHZhciAke3Z9OiBmMzIgPSBvcmlnaW5hbElkeCArIGYzMihpKTtcXG4gICAgICAgICAgaWYgKCR7dn0gPCAwIHx8ICR7dn0gPj0gJHtyW3ddfSkge1xcbiAgICAgICAgICAgIGlmICgke219KSB7XFxuICAgICAgICAgICAgICBjb2Vmc1tpICsgMV0gPSAwLjA7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR7ZH0pIHtcXG4gICAgICAgICAgICAgIHJldHVybiAke2F9O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAke3Z9ID0gbWF4KDAsIG1pbigke3Z9LCAke3Jbd119IC0gMSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzQ29weTogJHtlLnR5cGUuaW5kaWNlc30gPSBpbnB1dEluZGljZXM7XFxuICAgICAgICAgIGlucHV0SW5kaWNlc0NvcHlbJHt3fV0gPSB1MzIoJHt2fSk7XFxuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHt3PT09Zz9gaW5wdXRbJHtlLmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc0NvcHlcIil9XTtgOmBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dEluZGljZXNDb3B5LCBvdXRwdXRJbmRpY2VzKTtgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcXG4gICAgICB9YH07cmV0dXJuYFxcbiAgICAke2IoZyl9O1xcbiAgICAke2IoeCl9O1xcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogZjMyKSAtPiBhcnJheTxmMzIsIDQ+IHtcXG4gICAgdmFyIGFic1MgPSBhYnMocyk7XFxuICAgIHZhciBjb2VmZnM6IGFycmF5PGYzMiwgND4gPSBhcnJheTxmMzIsIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgIHZhciBvbmVNaW51c0Fic1M6IGYzMiA9IDEuMCAtIGFic1M7XFxuICAgIHZhciB0d29NaW51c0Fic1M6IGYzMiA9IDIuMCAtIGFic1M7XFxuICAgIHZhciBvbmVQbHVzQWJzUzogZjMyID0gMS4wICsgYWJzUztcXG4gICAgY29lZmZzWzBdID0gKCgke3V9ICogb25lUGx1c0Fic1MgLSA1ICogJHt1fSkgKiBvbmVQbHVzQWJzUyArIDggKiAke3V9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7dX07XFxuICAgIGNvZWZmc1sxXSA9ICgoJHt1fSArIDIpICogYWJzUyAtICgke3V9ICsgMykpICogYWJzUyAqIGFic1MgKyAxO1xcbiAgICBjb2VmZnNbMl0gPSAoKCR7dX0gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke3V9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcXG4gICAgY29lZmZzWzNdID0gKCgke3V9ICogdHdvTWludXNBYnNTIC0gNSAqICR7dX0pICogdHdvTWludXNBYnNTICsgOCAqICR7dX0pICogdHdvTWludXNBYnNTIC0gNCAqICR7dX07XFxuICAgIHJldHVybiBjb2VmZnM7XFxuICB9XFxuXFxuICBmbiBjdWJpY0ludGVycG9sYXRpb24xRCh4OiBhcnJheTxmMzIsIDQ+LCBjb2VmczogYXJyYXk8ZjMyLCA0PikgLT4gZjMyIHtcXG4gICAgdmFyIGNvZWZzU3VtOiBmMzIgPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcXG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xcbiAgfVxcblxcbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+IGYzMiB7XFxuICAgIHZhciBpbnB1dEluZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0SW5kaWNlcztcXG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dEluZGljZXMsIG91dHB1dEluZGljZXMpO1xcbiAgfVxcbiAgICBgfSx6ZD0oZSx0LHIsbyxuLHMpPT57bGV0IHU9ZS5kaW1zLGQ9X2Qocyx0LmF4ZXMsdS5sZW5ndGgpLGE9UmQodSxvLG4sdC5heGVzKSxtPW8uc2xpY2UoKTtvLmxlbmd0aD09PTAmJihtPXUubWFwKChTLEEpPT5TPT09MD8xOmFbQV0vUyksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKGE9UGQodSxhLG0sdCkpKTtsZXQgZz1YKFwib3V0cHV0XCIsZS5kYXRhVHlwZSxhKSx4PUwoXCJpbnB1dFwiLGUuZGF0YVR5cGUsdSksYj1rLnNpemUoYSksdz11Lmxlbmd0aD09PWEubGVuZ3RoJiZ1LmV2ZXJ5KChTLEEpPT5TPT09YVtBXSksdj10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIix5PVM9PmBcXG4gICAgICAke1RkKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpfTtcXG4gICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gXFxuICAgICAgICAgICAgICAke2tkKHgsdSl9O1xcbiAgICAgICAgICAgICAgJHtPZCh0Lm5lYXJlc3RNb2RlLHIpfTtcXG4gICAgICAgICAgICAgICR7QmQoeCxnLHUsYSxtLGQsdil9O1xcbiAgICAgICAgICAgICAgYDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5gXFxuICAgICAgICAgICAgICAke01kKGcsdSxhLG0sZCl9O1xcbiAgICAgICAgICAgICAgJHtEZCh4LGcsdSxhLG0sdix0LmV4dHJhcG9sYXRpb25WYWx1ZSl9O1xcbiAgICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcXG4gICAgICAgICAgICAke1dkKHgsZyx1LGEsbSxkLHQuY3ViaWNDb2VmZkEsdix0LmV4dHJhcG9sYXRpb25WYWx1ZSx0LmV4Y2x1ZGVPdXRzaWRlKX07XFxuICAgICAgICAgICAgYDtkZWZhdWx0OnRocm93IEVycm9yKFwiSW52YWxpZCByZXNpemUgbW9kZVwiKX19KSgpfTtcXG4gICAgICAke1MuZGVjbGFyZVZhcmlhYmxlcyh4LGcpfVxcbiAgICAgICR7Uy5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGIpfVxcbiAgICAgICAgaWYgKCR7d30pIHtcXG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Zy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgdmFyIGlucHV0SW5kaWNlczogJHt4LnR5cGUuaW5kaWNlc307XFxuICAgICAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBpbnB1dEluZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzKTtcXG4gICAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRJbmRpY2VzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbJHt4LmluZGljZXNUb09mZnNldChcImlucHV0SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3QuZXh0cmFwb2xhdGlvblZhbHVlfTtcXG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRJbmRpY2VzKTtcIjtjYXNlXCJjdWJpY1wiOnJldHVyblwib3V0cHV0W2dsb2JhbF9pZHhdID0gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0SW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xcbiAgICAgICAgfVxcbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke20ubGVuZ3RoPjA/bTpcIlwifXwke24ubGVuZ3RoPjA/bjpcIlwifWB9LGdldFNoYWRlclNvdXJjZTp5LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYi82NCl9fSl9fSxWZD1lPT57bGV0IHQ9ZS5jdXN0b21EYXRhQnVmZmVyO3JldHVybiBuZXcgVWludDMyQXJyYXkodCx0LmJ5dGVPZmZzZXQsMSlbMF19LFRzPShlLHQpPT57bGV0IHI9W10sbz1bXSxuPVtdLHM9VmQoZSk7RWQoZS5pbnB1dHMsdCxzLHIsbyxuKSxlLmNvbXB1dGUoemQoZS5pbnB1dHNbMF0sdCxzLHIsbyxuKSx7aW5wdXRzOlswXX0pfSxPcz1lPT57bGV0IHQ9ZS5hbnRpYWxpYXMscj1lLmF4ZXMsbz1lLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLG49ZS5jdWJpY0NvZWZmQSxzPWUuZXhjbHVkZU91dHNpZGUhPT0wLHU9ZS5leHRyYXBvbGF0aW9uVmFsdWUsZD1lLmtlZXBBc3BlY3RSYXRpb1BvbGljeSxhPWUubW9kZSxtPWUubmVhcmVzdE1vZGU9PT1cIlwiP1wic2ltcGxlXCI6ZS5uZWFyZXN0TW9kZTtyZXR1cm4gaWUoe2FudGlhbGlhczp0LGF4ZXM6cixjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpvLGN1YmljQ29lZmZBOm4sZXhjbHVkZU91dHNpZGU6cyxleHRyYXBvbGF0aW9uVmFsdWU6dSxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6ZCxtb2RlOmEsbmVhcmVzdE1vZGU6bX0pfX0pO3ZhciBHZCxOZCxScyxQcyxNcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO1BlKCk7dmUoKTtHZD1lPT57aWYoIWV8fGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLlwiKTtsZXQgdD1lWzBdLHI9ZVsxXSxvPWVbMl07aWYodC5kYXRhVHlwZSE9PXIuZGF0YVR5cGV8fHQuZGF0YVR5cGUhPT1vLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZVwiKTtpZih0LmRpbXMubGVuZ3RoIT09MyYmdC5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSAyRCBvciAzRFwiKTtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGJlIDJEIG9yIDNEXCIpO2xldCBuPXQuZGltc1t0LmRpbXMubGVuZ3RoLTFdLHM9dC5kaW1zW3QuZGltcy5sZW5ndGgtMl07aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMV0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTJdIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXRcIik7aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBiZSAxRFwiKTtpZihvLmRpbXNbby5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKGUubGVuZ3RoPjMpe2xldCB1PWVbM107aWYodS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGJlIDFEXCIpO2lmKHUuZGltc1t1LmRpbXMubGVuZ3RoLTFdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX1pZihlLmxlbmd0aD40KXtsZXQgdT1lWzRdO2lmKHUuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBiZSAxRFwiKTtpZih1LmRpbXNbdS5kaW1zLmxlbmd0aC0xXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9fSxOZD0oZSx0LHIsbyk9PntsZXQgbj1lWzBdLmRpbXMscz1rLnNpemUobiksdT1uLGQ9cyxhPW4uc2xpY2UoLTEpWzBdLG09bz9uLnNsaWNlKDAsLTEpLmNvbmNhdCgxKTpbXSxnPWUubGVuZ3RoPjMseD1lLmxlbmd0aD40LGI9byYmcj4xLHc9byYmcj4yLHY9cj4zLHk9bHQoYSksUz1bTChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyx5KSxMKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLHkpLEwoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLHkpXTtnJiZTLnB1c2goTChcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyx5KSkseCYmUy5wdXNoKEwoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMseSkpLFMucHVzaChYKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx1LHkpKSxiJiZTLnB1c2goWChcIm1lYW5PdXRwdXRcIiwxLG0pKSx3JiZTLnB1c2goWChcImludlN0ZE91dHB1dFwiLDEsbSkpLHYmJlMucHVzaChYKFwiaW5wdXRTa2lwQmlhc1N1bVwiLGVbMF0uZGF0YVR5cGUsdSx5KSk7bGV0IEE9TWUoZVswXS5kYXRhVHlwZSksUj1NPT5gXFxuICAgICAgY29uc3QgaGlkZGVuU2l6ZTogZjMyID0gJHthfTtcXG4gICAgICBjb25zdCBoaWRkZW5TaXplVmVjdG9yaXplZDogdTMyID0gJHthL3l9O1xcbiAgICAgIGNvbnN0IGVwc2lsb246IGYzMiA9ICR7dC5lcHNpbG9ufTtcXG5cXG4gICAgICAke00uZGVjbGFyZVZhcmlhYmxlcyguLi5TKX1cXG5cXG4gICAgICAke00ubWFpblN0YXJ0KCl9XFxuICAgICAgICAke00uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhkL2EpfVxcbiAgICAgICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiBoaWRkZW5TaXplVmVjdG9yaXplZDtcXG4gICAgICAgIHZhciBzdW0gPSAke3FlKFwiZjMyXCIseSl9O1xcbiAgICAgICAgdmFyIHNxdWFyZVN1bSA9ICR7cWUoXCJmMzJcIix5KX07XFxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ7IGkrKykge1xcbiAgICAgICAgICBsZXQgc2tpcFZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcXG4gICAgICAgICAgbGV0IGJpYXNWYWx1ZSA9ICR7eD9cImJpYXNbaV1cIjpcIjAuMFwifTtcXG4gICAgICAgICAgbGV0IGlucHV0VmFsdWUgPSB4W29mZnNldCArIGldO1xcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dFZhbHVlICsgc2tpcFZhbHVlICsgYmlhc1ZhbHVlO1xcbiAgICAgICAgICAke3Y/XCJpbnB1dFNraXBCaWFzU3VtW29mZnNldCArIGldID0gdmFsdWU7XCI6XCJcIn1cXG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XFxuICAgICAgICAgIGxldCBmMzJWYWx1ZSA9ICR7QXQoQSx5LFwidmFsdWVcIil9O1xcbiAgICAgICAgICBzdW0gKz0gZjMyVmFsdWU7XFxuICAgICAgICAgIHNxdWFyZVN1bSArPSBmMzJWYWx1ZSAqIGYzMlZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IG1lYW4gPSAke2h0KFwic3VtXCIseSl9IC8gaGlkZGVuU2l6ZTtcXG4gICAgICAgIGxldCB2YXJpYW5jZSA9IHNxcnQoJHtodChcInNxdWFyZVN1bVwiLHkpfSAvIGhpZGRlblNpemUgLSBtZWFuICogbWVhbiArIGVwc2lsb24pO1xcbiAgICAgICAgJHtiP1wibWVhbk91dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW47XCI6XCJcIn1cXG4gICAgICAgICR7dz9cImludlN0ZE91dHB1dFtnbG9iYWxfaWR4XSA9IDEuMCAvIHZhcmlhbmNlO1wiOlwiXCJ9XFxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgaGlkZGVuU2l6ZVZlY3Rvcml6ZWQ7IGkrKykge1xcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldIC0gJHtBfShtZWFuKSkgLyAke0F9KHZhcmlhbmNlKSAqIGdhbW1hW2ldXFxuICAgICAgICAgICArICR7Zz9cImJldGFbaV1cIjpcIjAuMFwifTtcXG4gICAgICAgIH1cXG4gICAgICB9YCxXPVt7ZGltczp1LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gcj4xJiZXLnB1c2goe2RpbXM6bSxkYXRhVHlwZToxfSkscj4yJiZXLnB1c2goe2RpbXM6bSxkYXRhVHlwZToxfSkscj4zJiZXLnB1c2goe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSkse25hbWU6XCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleX0sZ2V0U2hhZGVyU291cmNlOlIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlcsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC9hLzY0KX19KX19LFJzPShlLHQpPT57R2QoZS5pbnB1dHMpO2xldCBvPVswXTtlLm91dHB1dENvdW50PjEmJm8ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4yJiZvLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MyYmby5wdXNoKDMpLGUuY29tcHV0ZShOZChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQsITEpLHtvdXRwdXRzOm99KX0sUHM9ZT0+e2xldCB0PWUuZXBzaWxvbjtyZXR1cm4gaWUoe2Vwc2lsb246dH0pfX0pO3ZhciBVZCxZcixMZCxCcyxGZCxIZCxrcyxEcyxXcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO1BlKCk7dmUoKTtVZD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChyLG8pPT57aWYoZVtvKzFdLmRhdGFUeXBlIT09NiYmZVtvKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7b30gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LFlyPShlLHQpPT57bGV0IHI9W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2gobz0+ci5wdXNoKE51bWJlcihvKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gcn0sTGQ9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1ZcihlLDEpLG89WXIoZSwyKSxuPVlyKGUsMyk7cmV0dXJuIG4ubGVuZ3RoPT09MCYmKG49Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLGllKHtzdGFydHM6cixlbmRzOm8sYXhlczpufSl9ZWxzZSByZXR1cm4gdH0sQnM9KGUsdCxyLG8sbik9PntsZXQgcz1lO3JldHVybiBlPDAmJihzKz1yW29bdF1dKSxuW3RdPDA/TWF0aC5tYXgoMCxNYXRoLm1pbihzLHJbb1t0XV0tMSkpOk1hdGgubWF4KDAsTWF0aC5taW4ocyxyW29bdF1dKSl9LEZkPShlLHQscixvKT0+YGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRJbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xcbiAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcXG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMHU7XFxuICAgICAgICAgIGZvciAodmFyIGkgPSAke3IubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSAke28ubGVuZ3RoPT09MT9cIm91dHB1dEluZGljZXNcIjpcIm91dHB1dEluZGljZXNbaV1cIn07XFxuICAgICAgICAgICAgdmFyIGlucHV0SW5kZXggPSBvdXRwdXRJbmRleCAqIHN0ZXBzW2ldICsgc3RhcnRzW2ldICsgY2Fycnk7XFxuICAgICAgICAgICAgY2FycnkgPSBpbnB1dEluZGV4IC8gaW5wdXRTaGFwZVtpXTtcXG4gICAgICAgICAgICBpbnB1dEluZGV4ID0gaW5wdXRJbmRleCAlIGlucHV0U2hhcGVbaV07XFxuICAgICAgICAgICAgaWYgKHNpZ25zW2ldIDwgMCkge1xcbiAgICAgICAgICAgICAgaW5wdXRJbmRleCA9IGlucHV0U2hhcGVbaV0gLSBpbnB1dEluZGV4IC0gMXUgKyBzdGFydHNbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7ci5sZW5ndGg9PT0xP1wiaW5wdXRJbmRpY2VzXCI6XCJpbnB1dEluZGljZXNbaV1cIn0gPSBpbnB1dEluZGV4O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBpbnB1dEluZGljZXM7XFxuICAgICAgfWAsSGQ9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbz1rLnNpemUociksbj10LmF4ZXMubGVuZ3RoPjA/ay5ub3JtYWxpemVBeGVzKHQuYXhlcyxyLmxlbmd0aCk6Wy4uLkFycmF5KHIubGVuZ3RoKS5rZXlzKCldLHM9WXIoZSw0KTtzLmZvckVhY2goeT0+eSE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSkscy5sZW5ndGg9PT0wJiYocz1BcnJheShuLmxlbmd0aCkuZmlsbCgxKSk7bGV0IHU9dC5zdGFydHMubWFwKCh5LFMpPT5Ccyh5LFMscixuLHMpKSxkPXQuZW5kcy5tYXAoKHksUyk9PkJzKHksUyxyLG4scykpO2lmKG4ubGVuZ3RoIT09ci5sZW5ndGgpZm9yKGxldCB5PTA7eTxyLmxlbmd0aDsrK3kpbi5pbmNsdWRlcyh5KXx8KHUuc3BsaWNlKHksMCwwKSxkLnNwbGljZSh5LDAsclt5XSkscy5zcGxpY2UoeSwwLDEpKTtsZXQgYT1zLm1hcCh5PT5NYXRoLnNpZ24oeSkpO3MuZm9yRWFjaCgoeSxTLEEpPT57aWYoeTwwKXtsZXQgUj0oZFtTXS11W1NdKS95LFc9dVtTXSxNPVcrUipzW1NdO3VbU109TSxkW1NdPVcsQVtTXT0teX19KTtsZXQgbT1yLnNsaWNlKDApO24uZm9yRWFjaCgoeSxTKT0+e21beV09TWF0aC5jZWlsKChkW3ldLXVbeV0pL3NbeV0pfSk7bGV0IGc9e2RpbXM6bSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSx4PVgoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG0pLGI9TChcImlucHV0XCIsZVswXS5kYXRhVHlwZSxyKSx3PWsuc2l6ZShtKSx2PXk9PmBcXG4gICAgICAke3kuZGVjbGFyZVZhcmlhYmxlcyhiLHgpfVxcbiAgICAgICAgY29uc3Qgc2lnbnMgPSBhcnJheTxpMzIsICR7YS5sZW5ndGh9Pigke2EubWFwKFM9PmAke1N9aWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBzdGFydHMgPSBhcnJheTx1MzIsICR7dS5sZW5ndGh9Pigke3UubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBlbmRzID0gYXJyYXk8dTMyLCAke2QubGVuZ3RofT4oJHtkLm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBhcnJheTx1MzIsICR7cy5sZW5ndGh9Pigke3MubWFwKFM9PmAke1N9dWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBpbnB1dFNoYXBlID0gYXJyYXk8dTMyLCAke3IubGVuZ3RofT4oJHtyLm1hcChTPT5gJHtTfXVgKS5qb2luKFwiLFwiKX0pO1xcblxcbiAgICAgICAgJHtGZChiLHgscixtKX1cXG4gICAgICAgICR7eS5tYWluU3RhcnQoKX1cXG4gICAgICAgICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModyl9XFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt4Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgICBsZXQgaW5wdXRJbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dEluZGljZXMpO1xcbiAgICAgICAgICAke3guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYi5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIikpfVxcbiAgICAgIH1gO3JldHVybntuYW1lOlwiU2xpY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke2VbNF0/LmRpbXM/P1wiXCJ9YH0sZ2V0U2hhZGVyU291cmNlOnYsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltnXSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX19KX19LGtzPShlLHQpPT57VWQoZS5pbnB1dHMsdCk7bGV0IHI9TGQoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKEhkKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9LERzPWU9PntsZXQgdD1lLnN0YXJ0cyxyPWUuZW5kcyxvPWUuYXhlcztyZXR1cm4gaWUoe3N0YXJ0czp0LGVuZHM6cixheGVzOm99KX19KTt2YXIgamQsS2QsenMsVnMsR3M9SCgoKT0+e1widXNlIHN0cmljdFwiO2dlKCk7UGUoKTt2ZSgpO2pkPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LEtkPShlLHQpPT57bGV0IHI9TWUoZS5kYXRhVHlwZSksbz1lLmRpbXMsbj1rLnNpemUobykscz02NCx1PXQuYXhpcztpZih1PDAmJih1PW8ubGVuZ3RoK3UpLHU8by5sZW5ndGgtMSl0aHJvdyBuZXcgRXJyb3IoXCJzb2Z0bWF4IG9ubHkgc3VwcG9ydHMgbGFzdCBheGlzIGZvciBub3cuXCIpO2xldCBkPW9bdV0sYT1uL2QsbT1sdChkKSxnPWQvbSx4PW09PT0xP3I6YHZlYyR7bX08JHtyfT5gLGI9KHksUyk9PlM9PT00P2BtYXgobWF4KCR7eX0ueCwgJHt5fS55KSwgbWF4KCR7eX0ueiwgJHt5fS53KSlgOlM9PT0yP2BtYXgoJHt5fS54LCAke3l9LnkpYDpTPT09Mz9gbWF4KG1heCgke3l9LngsICR7eX0ueSksICR7eX0ueilgOnksdz1yPT09XCJmMzJcIj9gdmFyIHRocmVhZE1heCA9ICR7eH0oLTMuNDAyODIzZSszOGYpO2A6YHZhciB0aHJlYWRNYXggPSAke3h9KC02NTUwNC4waCk7YDtyZXR1cm57bmFtZTpcIlNvZnRtYXhcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6YX19KSxnZXRTaGFkZXJTb3VyY2U6eT0+YFxcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7eH07XFxuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHt4fTtcXG4gICAgICB2YXI8d29ya2dyb3VwPiB0aHJlYWRTaGFyZWQgOiBhcnJheTwke3h9LCAke3N9PjtcXG5cXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHggOiBhcnJheTwke3h9PjtcXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdCA6IGFycmF5PCR7eH0+O1xcblxcbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke3h9IHtcXG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XFxuICAgICAgICByZXR1cm4geFtpbmRleF07XFxuICAgICAgfVxcblxcbiAgICAgIGZuIHNldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyLCB2YWx1ZTogJHt4fSkge1xcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcXG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7c30sIDEsIDEpXFxuICAgICAgZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPiwgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzN1KSB7XFxuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZC54KTtcXG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWQueCk7XFxuICAgICAgICBjb25zdCB3ZyA9ICR7c307XFxuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XFxuICAgICAgICBsZXQgY29scyA9ICR7Z307XFxuICAgICAgICBsZXQgcm93X3N0cmlkZSA6IGkzMiA9ICR7Z307XFxuXFxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxcbiAgICAgICAgJHt3fVxcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcXG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xcbiAgICAgICAgICB0aHJlYWRNYXggPSBtYXgodGhyZWFkTWF4LCB2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xcbiAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZE1heDtcXG4gICAgICAgIH1cXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xcbiAgICAgICAgICByZWR1Y2VTaXplID0gY3VyclNpemUgKyAocmVkdWNlU2l6ZSAmIDEpO1xcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcXG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcXG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHt4fSgke2IoXCJ0aHJlYWRTaGFyZWRbMF1cIixtKX0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cXG4gICAgICAgIHZhciB0aHJlYWRTdW0gPSAke3h9KDAuMCk7XFxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XFxuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XFxuICAgICAgICB9XFxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XFxuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke3h9KCR7aHQoXCJ0aHJlYWRTaGFyZWRbMF1cIixtKX0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHJvd1xcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcXG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XFxuICAgICAgICAgIHNldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlLCB2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfWB9fSx6cz0oZSx0KT0+e2pkKGUuaW5wdXRzKSxlLmNvbXB1dGUoS2QoZS5pbnB1dHNbMF0sdCkpfSxWcz1lPT5pZSh7YXhpczplLmF4aXN9KX0pO3ZhciBxZCxZZCxYZCxKZCxaZCxOcyxVcyxMcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z2UoKTtQZSgpO3ZlKCk7cWQ9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpfSxZZD0oZSx0KT0+e2xldCByPVtdLG89dC5udW1PdXRwdXRzO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpLG89ci5sZW5ndGgpLGllKHtudW1PdXRwdXRzOm8sYXhpczp0LmF4aXMsc3BsaXRTaXplczpyfSl9LFhkPWU9PmBcXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX11OyBpICs9IDF1ICkge1xcbiAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XFxuICAgICAgICByZXR1cm4gaTtcXG4gICAgfVxcbiAgICB9XFxuICAgIHJldHVybiAke2V9dTtcXG59YCxKZD1lPT57bGV0IHQ9ZS5sZW5ndGgscj1bXTtmb3IobGV0IG89MDtvPHQ7KytvKXtsZXQgbj1lW29dLnNldEJ5SW5kaWNlcyhcImluZGljZXNcIixcImlucHV0W2dsb2JhbF9pZHhdXCIpO3Q9PT0xP3IucHVzaChuKTpvPT09MD9yLnB1c2goYGlmIChvdXRwdXROdW1iZXIgPT0gJHtvfXUpIHsgJHtufSB9YCk6bz09PXQtMT9yLnB1c2goYGVsc2UgeyAke259IH1gKTpyLnB1c2goYGVsc2UgaWYgKG91dHB1dE51bWJlciA9PSAke299KSB7ICR7bn0gfWApfXJldHVybmBcXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0TnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcXG4gICAgICAgICR7ci5qb2luKGBcXG5gKX1cXG4gICAgICB9YH0sWmQ9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbz1rLnNpemUociksbj1lWzBdLmRhdGFUeXBlLHM9ci5sZW5ndGgsdT10LmF4aXMsZD11PDA/ci5sZW5ndGgrdTp1LGE9bmV3IEFycmF5KHQubnVtT3V0cHV0cyksbT1MKFwiaW5wdXRcIixuLHIpLGc9bmV3IEFycmF5KHQubnVtT3V0cHV0cykseD1bXSxiPVtdLHc9MDtmb3IobGV0IFM9MDtTPHQubnVtT3V0cHV0cztTKyspe3crPXQuc3BsaXRTaXplc1tTXSxnW1NdPXc7bGV0IEE9ci5zbGljZSgpO0FbdC5heGlzXT10LnNwbGl0U2l6ZXNbU10sYi5wdXNoKEEpLGFbU109WChgb3V0cHV0JHtTfWAsbixiW1NdKSx4LnB1c2goe2RpbXM6YltTXSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSl9bGV0IHY9czwyP1wiaW5kaWNlc1wiOmBpbmRpY2VzWyR7ZH1dYCx5PVM9PmBcXG4gICR7Uy5kZWNsYXJlVmFyaWFibGVzKG0sLi4uYSl9XFxuICBjb25zdCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke2cubGVuZ3RofT4oJHtnLm1hcChBPT5gJHtBfXVgKS5qb2luKFwiLFwiKX0pO1xcbiAgJHtYZChnLmxlbmd0aCl9XFxuICAke0pkKGEpfVxcblxcbiAgJHtTLm1haW5TdGFydCgpfVxcbiAgICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvKX1cXG5cXG4gICAgdmFyIGluZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgIGxldCBvdXRwdXROdW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleCgke3Z9KTtcXG4gICAgaWYgKG91dHB1dE51bWJlciAhPSAwKSB7XFxuICAgICAgICAke3Z9IC09IHNpemVJbkNvbmNhdEF4aXNbb3V0cHV0TnVtYmVyIC0gMXVdO1xcbiAgICB9XFxuICAgIHdyaXRlQnVmZmVyRGF0YShvdXRwdXROdW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xcbiAgfWA7cmV0dXJue25hbWU6XCJTcGxpdFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXl9LGdldFNoYWRlclNvdXJjZTp5LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czp4LGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfX0pfX0sTnM9KGUsdCk9PntxZChlLmlucHV0cyk7bGV0IHI9ZS5pbnB1dHMubGVuZ3RoPT09MT90OllkKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShaZChlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxVcz1lPT57bGV0IHQ9ZS5heGlzLHI9ZS5zcGxpdFNpemVzLG89ZS5udW1PdXRwdXRzPDA/ci5sZW5ndGg6ZS5udW1PdXRwdXRzO2lmKG8hPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmdoIG11c3QgYmUgZXF1YWxcIik7cmV0dXJuIGllKHtheGlzOnQsbnVtT3V0cHV0czpvLHNwbGl0U2l6ZXM6cn0pfX0pO3ZhciBGcyxRZCxlYyx0YyxIcyxqcz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RGUoKTtnZSgpO3ZlKCk7RnM9ZT0+QXJyYXkuZnJvbShlLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLFFkPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlRpbGUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihGcyhlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LGVjPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pci5wdXNoKGVbb10qdFtvXSk7cmV0dXJuIHJ9LHRjPWU9PntsZXQgdD1lWzBdLmRpbXMscj1GcyhlWzFdKSxvPWVjKHQsciksbj1rLnNpemUobykscz1lWzBdLmRhdGFUeXBlLHU9TChcImlucHV0XCIscyx0KSxkPVgoXCJvdXRwdXRcIixzLG8pLGE9bT0+YFxcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke3UuaW5kaWNlcyguLi50KX07XFxuICAgICAgJHttLmRlY2xhcmVWYXJpYWJsZXModSxkKX1cXG4gICAgICAke20ubWFpblN0YXJ0KCl9XFxuICAgICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobil9XFxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgdmFyIGlucHV0SW5kaWNlczogJHt1LnR5cGUuaW5kaWNlc307XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XFxuICAgICAgICBsZXQgaW5wdXREaW1WYWx1ZSA9ICR7ZC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiaVwiKX0gICUgJHt1LmluZGljZXNHZXQoXCJpbnB1dFNoYXBlXCIsXCJpXCIpfTtcXG5cXG4gICAgICAgICR7dS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJpXCIsXCJpbnB1dERpbVZhbHVlXCIpfVxcbiAgICAgIH1cXG4gICAgICAke2Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIikpfVxcbiAgICB9YDtyZXR1cm57bmFtZTpcIlRpbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyfWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9fSksZ2V0U2hhZGVyU291cmNlOmF9fSxIcz1lPT57UWQoZS5pbnB1dHMpLGUuY29tcHV0ZSh0YyhlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgcmMsbmMsS3MscXM9SCgoKT0+e1widXNlIHN0cmljdFwiO0RlKCk7Z2UoKTt2ZSgpO3JjPShlLHQscixvLG4pPT57bGV0IHM9ay5zaXplKHIpLHU9TWF0aC5jZWlsKHMvNCksZD1YKFwib3V0cHV0RGF0YVwiLG4sciw0KSxhPUwoXCJhRGF0YVwiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLDQpLG09TChcImJEYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMsNCksZz1MKFwiY0RhdGFcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyw0KSx4LGI9KHcsdix5KT0+YHNlbGVjdCgke3Z9LCAke3d9LCAke3l9KWA7aWYoIW8peD1kLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGIoYS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksbS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksZy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCB3PSh2LHksUz1cIlwiKT0+e2xldCBBPWBhRGF0YVtpbmRleEEke3l9XVtjb21wb25lbnRBJHt5fV1gLFI9YGJEYXRhW2luZGV4QiR7eX1dW2NvbXBvbmVudEIke3l9XWAsVz1gYm9vbChjRGF0YVtpbmRleEMke3l9XSAmICR7NDI3ODE5MDA4MD4+PigzLXkpKjh9dSlgO3JldHVybmBcXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eX0gPSAke2Qub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke3l9dWApfTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7eX0gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3l9YCxkKX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldEIke3l9ID0gJHttLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt5fWAsZCl9O1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRDJHt5fSA9ICR7Zy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eX1gLGQpfTtcXG4gICAgICAgICAgICBsZXQgaW5kZXhBJHt5fSA9IG9mZnNldEEke3l9IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGluZGV4QiR7eX0gPSBvZmZzZXRCJHt5fSAvIDR1O1xcbiAgICAgICAgICAgIGxldCBpbmRleEMke3l9ID0gb2Zmc2V0QyR7eX0gLyA0dTtcXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7eX0gPSBvZmZzZXRBJHt5fSAlIDR1O1xcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt5fSA9IG9mZnNldEIke3l9ICUgNHU7XFxuICAgICAgICAgICAgJHt2fVske3l9XSA9ICR7U30oJHtiKEEsUixXKX0pO1xcbiAgICAgICAgICBgfTtuPT09OT94PWBcXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcXG4gICAgICAgICAgICAke3coXCJkYXRhXCIsMCxcInUzMlwiKX1cXG4gICAgICAgICAgICAke3coXCJkYXRhXCIsMSxcInUzMlwiKX1cXG4gICAgICAgICAgICAke3coXCJkYXRhXCIsMixcInUzMlwiKX1cXG4gICAgICAgICAgICAke3coXCJkYXRhXCIsMyxcInUzMlwiKX1cXG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6eD1gXFxuICAgICAgICAgICAgJHt3KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxcbiAgICAgICAgICAgICR7dyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwxKX1cXG4gICAgICAgICAgICAke3coXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMil9XFxuICAgICAgICAgICAgJHt3KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxcbiAgICAgICAgICBgfXJldHVybmBcXG4gICAgICAgICR7ZS5kZWNsYXJlVmFyaWFibGVzKGcsYSxtLGQpfVxcbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XFxuICAgICAgICAke3h9XFxuICAgICAgfWB9LG5jPWU9PntsZXQgdD1lWzFdLmRpbXMscj1lWzJdLmRpbXMsbz1lWzBdLmRpbXMsbj1lWzFdLmRhdGFUeXBlLHM9IShrLmFyZUVxdWFsKHQscikmJmsuYXJlRXF1YWwocixvKSksdT10LGQ9ay5zaXplKHQpO2lmKHMpe2xldCBhPVFlLmNhbGNTaGFwZShRZS5jYWxjU2hhcGUodCxyLCExKSxvLCExKTtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7dT1hLGQ9ay5zaXplKHUpfXJldHVybntuYW1lOlwiV2hlcmVcIixnZXRTaGFkZXJTb3VyY2U6YT0+cmMoYSxlLHUscyxuKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQvNCl9fSl9fSxLcz1lPT57ZS5jb21wdXRlKG5jKGUuaW5wdXRzKSl9fSk7dmFyIFlzLFhzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtjYSgpO2ZhKCk7amEoKTtuaSgpO2lpKCk7X24oKTt3aSgpO1NpKCk7SWkoKTtPaSgpO1BpKCk7a2koKTt6aSgpO05pKCk7TGkoKTtqaSgpO3NzKCk7RXMoKTtNcigpO19zKCk7TXMoKTtXcygpO0dzKCk7THMoKTtqcygpO3JyKCk7SW4oKTtxcygpO1lzPW5ldyBNYXAoW1tcIkFic1wiLFttYV1dLFtcIkFjb3NcIixbaGFdXSxbXCJBY29zaFwiLFtnYV1dLFtcIkFkZFwiLFtLYV1dLFtcIkFyZ01heFwiLFtkYSxDbl1dLFtcIkFyZ01pblwiLFtsYSxDbl1dLFtcIkFzaW5cIixbeWFdXSxbXCJBc2luaFwiLFtiYV1dLFtcIkF0YW5cIixbd2FdXSxbXCJBdGFuaFwiLFt2YV1dLFtcIkF2ZXJhZ2VQb29sXCIsW1ppLEppXV0sW1wiQmlhc0FkZFwiLFtwYV1dLFtcIkJpYXNTcGxpdEdlbHVcIixbSGFdXSxbXCJDYXN0XCIsW3hhLCRhXV0sW1wiQ2VpbFwiLFtDYV1dLFtcIkNsaXBWMTBcIixbQW5dXSxbXCJDbGlwXCIsW1NhXV0sW1wiQ29uY2F0XCIsW29pLGFpXV0sW1wiQ29udlwiLFtQbixSbl1dLFtcIkNvbnZUcmFuc3Bvc2VcIixbYmkseWldXSxbXCJDb3NcIixbQWFdXSxbXCJDb3NoXCIsW0lhXV0sW1wiRGl2XCIsW3FhXV0sW1wiRWluc3VtXCIsWyRpLHhpXV0sW1wiRWx1XCIsW0VhLGtyXV0sW1wiRXF1YWxcIixbWWFdXSxbXCJFcmZcIixbVGFdXSxbXCJFeHBcIixbT2FdXSxbXCJFeHBhbmRcIixbQWldXSxbXCJGbG9vclwiLFtfYV1dLFtcIkZ1c2VkQ29udlwiLFtQbixSbl1dLFtcIkdhdGhlclwiLFtUaSxFaV1dLFtcIkdhdGhlckVsZW1lbnRzXCIsW1JpLF9pXV0sW1wiR2VsdVwiLFtSYV1dLFtcIkdlbW1cIixbTWksQmldXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFt0cyxlc11dLFtcIkdsb2JhbE1heFBvb2xcIixbaXMsYXNdXSxbXCJHcmVhdGVyXCIsW1FhXV0sW1wiR3JlYXRlck9yRXF1YWxcIixbdGldXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixbV2ksRGldXSxbXCJMYXllck5vcm1hbGl6YXRpb25cIixbR2ksVmldXSxbXCJMZWFreVJlbHVcIixbUGEsa3JdXSxbXCJMZXNzXCIsW2VpXV0sW1wiTGVzc09yRXF1YWxcIixbcmldXSxbXCJMb2dcIixbRmFdXSxbXCJNYXRNdWxcIixbVWldXSxbXCJNYXhQb29sXCIsW25zLG9zXV0sW1wiTXVsXCIsW1hhXV0sW1wiTmVnXCIsW0JhXV0sW1wiTm90XCIsW01hXV0sW1wiUGFkXCIsW0ZpLEhpXV0sW1wiUG93XCIsW0phXV0sW1wiUmFuZ2VcIixbSXNdXSxbXCJSZWNpcHJvY2FsXCIsW2thXV0sW1wiUmVkdWNlTWluXCIsW3JhLFllXV0sW1wiUmVkdWNlTWVhblwiLFtKbyxZZV1dLFtcIlJlZHVjZU1heFwiLFt0YSxZZV1dLFtcIlJlZHVjZVN1bVwiLFtvYSxZZV1dLFtcIlJlZHVjZVByb2RcIixbbmEsWWVdXSxbXCJSZWR1Y2VMMVwiLFtabyxZZV1dLFtcIlJlZHVjZUwyXCIsW1FvLFllXV0sW1wiUmVkdWNlTG9nU3VtXCIsW2lhLFllXV0sW1wiUmVkdWNlTG9nU3VtRXhwXCIsW2VhLFllXV0sW1wiUmVkdWNlU3VtU3F1YXJlXCIsW2FhLFllXV0sW1wiUmVsdVwiLFtEYV1dLFtcIlJlc2l6ZVwiLFtUcyxPc11dLFtcIlNpZ21vaWRcIixbV2FdXSxbXCJTaW5cIixbemFdXSxbXCJTaW5oXCIsW1ZhXV0sW1wiU2xpY2VcIixba3MsRHNdXSxbXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsW1JzLFBzXV0sW1wiU3BsaXRcIixbTnMsVXNdXSxbXCJTcXJ0XCIsW0dhXV0sW1wiU29mdG1heFwiLFt6cyxWc11dLFtcIlN1YlwiLFtaYV1dLFtcIlRhblwiLFtOYV1dLFtcIlRhbmhcIixbVWFdXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbTGEsa3JdXSxbXCJUaWxlXCIsW0hzXV0sW1wiVHJhbnNwb3NlXCIsW3pvLFZvXV0sW1wiV2hlcmVcIixbS3NdXV0pfSk7dmFyIFhyLEpzPUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO210KCk7dmUoKTtYcj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdCh0KXtyZXR1cm4gdGhpcy5yZXBvLmdldCh0KX1zZXRBcnRpZmFjdCh0LHIpe3RoaXMucmVwby5zZXQodCxyKX1ydW4odCxyLG8sbixzLHUsZCl7bGV0IGE9dGhpcy5iYWNrZW5kLmRldmljZSxtPXRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTttLnNldFBpcGVsaW5lKHQuY29tcHV0ZVBpcGVsaW5lKTtsZXQgZz1bXTtmb3IobGV0IGIgb2YgbilnLnB1c2goe2JpbmRpbmc6Zy5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpiLmJ1ZmZlcn19KTtmb3IobGV0IGIgb2YgcylnLnB1c2goe2JpbmRpbmc6Zy5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpiLmJ1ZmZlcn19KTtkJiZnLnB1c2goe2JpbmRpbmc6Zy5sZW5ndGgscmVzb3VyY2U6ZH0pO2xldCB4PWEuY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6dC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6ZyxsYWJlbDp0LnByb2dyYW1JbmZvLm5hbWV9KTtpZihtLnNldEJpbmRHcm91cCgwLHgpLG0uZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLnUpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKyx0aGlzLmJhY2tlbmQuaXNRdWVyeUVuYWJsZWQoKSl7dHlwZW9mIHRoaXMuYmFja2VuZC5xdWVyeURhdGE+XCJ1XCImJih0aGlzLmJhY2tlbmQucXVlcnlEYXRhPXRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUodGhpcy5iYWNrZW5kLnF1ZXJ5U2V0Q291bnQqOCxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFKSk7bGV0IGI9dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0aGlzLmJhY2tlbmQucXVlcnlTZXRDb3VudCo4LEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKS5yZXNvbHZlUXVlcnlTZXQodGhpcy5iYWNrZW5kLnF1ZXJ5U2V0LDAsMix0aGlzLmJhY2tlbmQucXVlcnlEYXRhLmJ1ZmZlciwwKSx0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKS5jb3B5QnVmZmVyVG9CdWZmZXIodGhpcy5iYWNrZW5kLnF1ZXJ5RGF0YS5idWZmZXIsMCxiLmJ1ZmZlciwwLHRoaXMuYmFja2VuZC5xdWVyeVNldENvdW50KjgpLHRoaXMuYmFja2VuZC5mbHVzaCgpO2xldCB3PXRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQsdj10aGlzLmJhY2tlbmQua2VybmVscy5nZXQodykseT1gWyR7dlswXX1dICR7dlsxXX1gO2IuYnVmZmVyLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKT0+e2xldCBTPW5ldyBCaWdVaW50NjRBcnJheShiLmJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpKSxBPVNbMF0sUj1TWzFdO2IuYnVmZmVyLnVubWFwKCksdHlwZW9mIHRoaXMuYmFja2VuZC5xdWVyeVRpbWVCYXNlPlwidVwiJiYodGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2U9QSk7bGV0IFc9TnVtYmVyKEEtdGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2UpLE09TnVtYmVyKFItdGhpcy5iYWNrZW5kLnF1ZXJ5VGltZUJhc2UpO2lmKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKXx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKE0pKXRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZVwiKTt0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShiLmlkKTtsZXQgRD1cIlwiO3IuZm9yRWFjaCgoeixGKT0+e0QrPWBpbnB1dFske0Z9XTogWyR7ei5kaW1zfV0gfCAke1F0KHouZGF0YVR5cGUpfSwgYH0pO2xldCBfPVwiXCI7by5mb3JFYWNoKCh6LEYpPT57Xys9YG91dHB1dFske0Z9XTogWyR7ei5kaW1zfV0gfCAke1F0KHouZGF0YVR5cGUpfSwgYH0pLGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke3d9fCR7eX1cIiAke0R9JHtffWV4ZWN1dGlvbiB0aW1lOiAke00tV30gbnNgKX0pfXRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PTE2JiZ0aGlzLmJhY2tlbmQuZmx1c2goKX1kaXNwb3NlKCl7fWJ1aWxkKHQscil7bGV0IG89dGhpcy5iYWNrZW5kLmRldmljZSxuPVtdO28uZmVhdHVyZXMuaGFzKFwic2hhZGVyLWYxNlwiKSYmbi5wdXNoKFwiZW5hYmxlIGYxNjtcIik7bGV0IHM9a28ociksdT10LmdldFNoYWRlclNvdXJjZShzKSxkPWAke24uam9pbihgXFxuYCl9XFxuJHtzLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XFxuJHt1fWAsYT1vLmNyZWF0ZVNoYWRlck1vZHVsZSh7Y29kZTpkLGxhYmVsOnQubmFtZX0pO0VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gc2hhZGVyIGNvZGU6ICR7ZH1gKTtsZXQgbT1vLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOmEsZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybntwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTptfX1ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSh0KXtsZXQgcj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQueCxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC55fHwxLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnp8fDEscz10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZihyPD1zJiZvPD1zJiZuPD1zKXJldHVybltyLG8sbl07bGV0IHU9cipvKm4sZD1NYXRoLmNlaWwoTWF0aC5zcXJ0KHUpKTtpZihkPnMpe2lmKGQ9TWF0aC5jZWlsKE1hdGguY2JydCh1KSksZD5zKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW2QsZCxkXX1lbHNlIHJldHVybltkLGQsMV19fX0pO3ZhciBvYyxhYyxKcixacz1IKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bXQoKTtUbygpO1BvKCk7WHMoKTtKcygpO29jPShlLHQpPT57aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke3QubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke2UubGVuZ3RofS5gKTtsZXQgcj1bXTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyl7bGV0IG49ZVtvXS5kYXRhVHlwZTtzd2l0Y2godFtvXSl7Y2FzZVwibm9uZVwiOntyLnB1c2goXCJcIik7YnJlYWt9Y2FzZVwidHlwZVwiOntyLnB1c2goYCR7bn1gKTticmVha31jYXNlXCJyYW5rXCI6e2xldCBzPWVbb10uZGltcy5sZW5ndGg7ci5wdXNoKGAke259OyR7c31gKTticmVha31jYXNlXCJkaW1zXCI6e2xldCBzPWVbb10uZGltcy5qb2luKFwiLFwiKTtyLnB1c2goYCR7bn07JHtzfWApO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke3Rbb119YCl9fXJldHVybiByLmpvaW4oXCJ8XCIpfSxhYz0oZSx0KT0+e2xldCByPWUubmFtZTtyZXR1cm4gZS5zaGFkZXJDYWNoZT8uaGludCYmKHIrPVwiW1wiK2Uuc2hhZGVyQ2FjaGUuaGludCtcIl1cIikscis9YDoke29jKHQsZS5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXM/P25ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChcImRpbXNcIikpfWAscn0sSnI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsO3RoaXMuY29tbWFuZEVuY29kZXI9bnVsbDt0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsO3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5xdWVyeVNldENvdW50PTI7dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZz1uZXcgTWFwfWdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpe2lmKHRoaXMuY3VycmVudEtlcm5lbElkPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKVwiKTtsZXQgdD10aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtyZXR1cm4gdHx8KHQ9e30sdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCx0KSksdH1hc3luYyBpbml0aWFsaXplKHQpe2lmKCFuYXZpZ2F0b3IuZ3B1KXRocm93IG5ldyBFcnJvcihcIldlYkdwdUJhY2tlbmQ6IFdlYkdQVSBpcyBub3QgYXZhaWxhYmxlLlwiKTtsZXQgcj1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiV2ViR3B1QmFja2VuZDogRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci5cIik7dGhpcy5lbnY9dDtsZXQgbz1bXSxuPXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6ci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLG1heEJ1ZmZlclNpemU6ci5saW1pdHMubWF4QnVmZmVyU2l6ZSxtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6ci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafSxyZXF1aXJlZEZlYXR1cmVzOm99O3IuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiZvLnB1c2goXCJ0aW1lc3RhbXAtcXVlcnlcIiksci5mZWF0dXJlcy5oYXMoXCJzaGFkZXItZjE2XCIpJiZvLnB1c2goXCJzaGFkZXItZjE2XCIpLHRoaXMuZGV2aWNlPWF3YWl0IHIucmVxdWVzdERldmljZShuKSx0aGlzLmdwdURhdGFNYW5hZ2VyPVJvKHRoaXMpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IFhyKHRoaXMpLHRoaXMua2VybmVscz1uZXcgTWFwLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGE9bmV3IE1hcCx0aGlzLmtlcm5lbEN1c3RvbURhdGE9bmV3IE1hcCxJbyh0LmxvZ0xldmVsLCEhdC5kZWJ1ZyksdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3I9cz0+e3MuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3ImJmNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7cy5lcnJvci5tZXNzYWdlfWApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiZGV2aWNlXCIse3ZhbHVlOnRoaXMuZGV2aWNlfSl9ZGlzcG9zZSgpe3R5cGVvZiB0aGlzLnF1ZXJ5U2V0PFwidVwiJiZ0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKSx0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKX1nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe2lmKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcil7bGV0IHQ9e307dGhpcy5pc1F1ZXJ5RW5hYmxlZCgpJiYodHlwZW9mIHRoaXMucXVlcnlTZXQ+XCJ1XCImJih0aGlzLnF1ZXJ5U2V0PXRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHt0eXBlOlwidGltZXN0YW1wXCIsY291bnQ6dGhpcy5xdWVyeVNldENvdW50fSkpLHQudGltZXN0YW1wV3JpdGVzPXtxdWVyeVNldDp0aGlzLnF1ZXJ5U2V0LGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6MCxlbmRPZlBhc3NXcml0ZUluZGV4OjF9KSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj10aGlzLmdldENvbW1hbmRFbmNvZGVyKCkuYmVnaW5Db21wdXRlUGFzcyh0KX1yZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXJ9ZW5kQ29tcHV0ZVBhc3MoKXt0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciYmKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGwpfWZsdXNoKCl7dGhpcy5jb21tYW5kRW5jb2RlciYmKHRoaXMuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKS5maW5pc2goKV0pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCksdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTApfWlzUXVlcnlFbmFibGVkKCl7cmV0dXJuISEodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiZ0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nTW9kZT09PVwiZGVmYXVsdFwiKX1ydW4odCxyLG8sbixzKXtsZXQgdT1bXTtmb3IobGV0IEE9MDtBPHIubGVuZ3RoOysrQSl7bGV0IFI9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQocltBXS5kYXRhKTtpZighUil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHtyW0FdLmRhdGF9YCk7dVtBXT1SfWxldCBkPWFjKHQsciksYT10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGQpLHtvdXRwdXRzOm0sZGlzcGF0Y2hHcm91cDpnLHByb2dyYW1Vbmlmb3Jtczp4fT10LmdldFJ1bkRhdGEociksYj1vLmxlbmd0aD09PTA/bS5tYXAoKEEsUik9PlIpOm87aWYoYi5sZW5ndGghPT1tLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7Yi5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHttLmxlbmd0aH0uYCk7bGV0IHc9W10sdj1bXTtmb3IobGV0IEE9MDtBPG0ubGVuZ3RoOysrQSl7aWYoIU51bWJlci5pc0ludGVnZXIoYltBXSl8fGJbQV08LTN8fGJbQV0+PW0ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7YltBXX1gKTtpZihiW0FdPT09LTMpY29udGludWU7bGV0IFI9YltBXT09PS0xLFc9YltBXT09PS0yLE09Unx8Vz9zKG1bQV0uZGF0YVR5cGUsbVtBXS5kaW1zKTpuKGJbQV0sbVtBXS5kYXRhVHlwZSxtW0FdLmRpbXMpLEQ9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoTS5kYXRhKTtpZighRCl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7TS5kYXRhfWApO2lmKFImJnRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKEQpLFcpe2xldCBfPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtffHwoXz1bXSx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCxfKSksXy5wdXNoKEQpfXcucHVzaChNKSx2LnB1c2goRCl9bGV0IHk7aWYoeCl7bGV0IEE9MCxSPTAsVz1bXSxNPTE7eC5mb3JFYWNoKHo9PntsZXQgRj10eXBlb2Ygei5kYXRhPT1cIm51bWJlclwiP1t6LmRhdGFdOnouZGF0YSxxO3N3aXRjaChGLmxlbmd0aCl7Y2FzZSAxOnE9NDticmVhaztjYXNlIDI6cT04O2JyZWFrO2Nhc2UgMzpxPTE2O2JyZWFrO2Nhc2UgNDpxPTE2O2JyZWFrO2Nhc2UgNTpxPTE2O2JyZWFrO2Nhc2UgNjpxPTE2O2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxlbmd0aDogJHtGLmxlbmd0aH1gKX0oUj09PTV8fFI9PT02KSYmKHE9MTYpLHE+TSYmKE09cSksQT1NYXRoLmNlaWwoQS9xKSpxLFI9Ri5sZW5ndGgsVy5wdXNoKEEpLEErPUYubGVuZ3RoKjR9KSxBPU1hdGguY2VpbChBL00pKk07bGV0IEQ9bmV3IEFycmF5QnVmZmVyKEEpO3guZm9yRWFjaCgoeixGKT0+e2xldCBxPVdbRl0sbGU9dHlwZW9mIHouZGF0YT09XCJudW1iZXJcIj9bei5kYXRhXTp6LmRhdGE7ei50eXBlPT09XCJpbnQzMlwiP25ldyBJbnQzMkFycmF5KEQscSxsZS5sZW5ndGgpLnNldChsZSk6ei50eXBlPT09XCJ1aW50MzJcIj9uZXcgVWludDMyQXJyYXkoRCxxLGxlLmxlbmd0aCkuc2V0KGxlKTpuZXcgRmxvYXQzMkFycmF5KEQscSxsZS5sZW5ndGgpLnNldChsZSl9KTtsZXQgXz10aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShBLEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO3RoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKF8uYnVmZmVyLDAsRCwwLEEpLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShfLmlkKSx5PXtvZmZzZXQ6MCxzaXplOkEsYnVmZmVyOl8uYnVmZmVyfX1sZXQgUz10aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGcpO3JldHVybiBhfHwoYT10aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHQsUyksdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChkLGEpKSxFZShcImluZm9cIiwoKT0+YFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHt0Lm5hbWV9XCIgKGtleT0ke2R9KSB3aXRoICR7U1swXX14JHtTWzFdfXgke1NbMl19YCksdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4oYSxyLHcsdSx2LFMseSksd311cGxvYWQodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZCh0LHIpfW1lbWNweSh0LHIpe3RoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHQscil9YXN5bmMgZG93bmxvYWQodCxyKXthd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKHQscil9YWxsb2ModCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHQpLmlkfWZyZWUodCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh0KX1jcmVhdGVLZXJuZWwodCxyLG8sbil7bGV0IHM9WXMuZ2V0KHQpO2lmKCFzKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHt0fWApO3RoaXMua2VybmVscy5zZXQocixbdCxuLHNbMF0sW3NbMV0sb11dKX1yZWxlYXNlS2VybmVsKHQpe2xldCByPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKHIpe2ZvcihsZXQgbyBvZiByKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShvLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LHIsbyl7bGV0IG49dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldFtzLHUsZCxhXT1uO2lmKHRoaXMuY3VycmVudEtlcm5lbElkIT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske3N9XSAke3V9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7dGhpcy5jdXJyZW50S2VybmVsSWQ9dCxhWzBdJiYoYVsxXT1hWzBdKGFbMV0pLGFbMF09dm9pZCAwKSxFZShcImluZm9cIiwoKT0+YFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtzfV0gJHt1fVwiLi4uYCk7bGV0IG09dGhpcy5lbnYuZGVidWc7dGhpcy50ZW1wb3JhcnlEYXRhPVtdO3RyeXtyZXR1cm4gbSYmdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoXCJ2YWxpZGF0aW9uXCIpLGQocixhWzFdKSwwfWNhdGNoKGcpe3JldHVybiBvLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHtzfV0gJHt1fVwiIGZhaWxlZC4gJHtnfWApKSwxfWZpbmFsbHl7bSYmby5wdXNoKHRoaXMuZGV2aWNlLnBvcEVycm9yU2NvcGUoKS50aGVuKGc9Pmc/YEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtzfV0gJHt1fVwiOiAke2cubWVzc2FnZX1gOm51bGwpKTtmb3IobGV0IGcgb2YgdGhpcy50ZW1wb3JhcnlEYXRhKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShnLmlkKTt0aGlzLnRlbXBvcmFyeURhdGE9W10sdGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbH19cmVnaXN0ZXJCdWZmZXIodCxyLG8sbil7bGV0IHM9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7c3x8KHM9bmV3IE1hcCx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLnNldCh0LHMpKTtsZXQgdT1zLmdldChyKSxkPXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihvLG4sdT8uWzFdKTtyZXR1cm4gcy5zZXQocixbZCxvXSksZH11bnJlZ2lzdGVyQnVmZmVycyh0KXtsZXQgcj10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtyJiYoci5mb3JFYWNoKG89PnRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG9bMV0pKSx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZSh0KSl9Z2V0QnVmZmVyKHQpe2xldCByPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHt0fWApO3JldHVybiByLmJ1ZmZlcn1jcmVhdGVEb3dubG9hZGVyKHQscixvKXtyZXR1cm4gYXN5bmMoKT0+e2xldCBuPWF3YWl0IHluKHRoaXMsdCxyKTtyZXR1cm4gRW8obi5idWZmZXIsbyl9fX19KTt2YXIgUXM9e307SXIoUXMse2luaXQ6KCk9PmljfSk7dmFyIHNyLHpuLGljLGV1PUgoKCk9PntcInVzZSBzdHJpY3RcIjtEZSgpO1pzKCk7bXQoKTtnZSgpO3NyPWNsYXNzIGV7Y29uc3RydWN0b3IodCxyLG8sbil7dGhpcy5tb2R1bGU9dDt0aGlzLmRhdGFUeXBlPXI7dGhpcy5kYXRhPW87dGhpcy5kaW1zPW59Z2V0RmxvYXQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ay5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBGbG9hdDMyQXJyYXk6bmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEJpZ0ludDY0QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1rLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEJpZ0ludDY0QXJyYXk6bmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRJbnQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTYpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9ay5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBJbnQzMkFycmF5Om5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9cmVzaGFwZSh0KXtpZihrLnNpemUodCkhPT1rLnNpemUodGhpcy5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5ldyBzaGFwZVwiKTtyZXR1cm4gbmV3IGUodGhpcy5tb2R1bGUsdGhpcy5kYXRhVHlwZSx0aGlzLmRhdGEsdCl9fSx6bj1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsbyl7dGhpcy5tb2R1bGU9dDt0aGlzLmJhY2tlbmQ9cjt0aGlzLmN1c3RvbURhdGFPZmZzZXQ9MDt0aGlzLmN1c3RvbURhdGFTaXplPTA7bGV0IG49dC5IRUFQVTMyLHM9bz4+Mjt0aGlzLm9wS2VybmVsQ29udGV4dD1uW3MrK107bGV0IHU9bltzKytdO3RoaXMub3V0cHV0Q291bnQ9bltzKytdLHRoaXMuY3VzdG9tRGF0YU9mZnNldD1uW3MrK10sdGhpcy5jdXN0b21EYXRhU2l6ZT1uW3MrK107bGV0IGQ9W107Zm9yKGxldCBhPTA7YTx1O2ErKyl7bGV0IG09bltzKytdLGc9bltzKytdLHg9bltzKytdLGI9W107Zm9yKGxldCB3PTA7dzx4O3crKyliLnB1c2gobltzKytdKTtkLnB1c2gobmV3IHNyKHQsbSxnLGIpKX10aGlzLmlucHV0cz1kfWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQscil7bGV0IG89cj8uaW5wdXRzPy5tYXAoZD0+dHlwZW9mIGQ9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbZF06ZCk/P3RoaXMuaW5wdXRzLG49cj8ub3V0cHV0cz8/W10scz0oZCxhLG0pPT5uZXcgc3IodGhpcy5tb2R1bGUsYSx0aGlzLm91dHB1dChkLG0pLG0pLHU9KGQsYSk9PntsZXQgbT1lcihkKTtpZighbSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkfWApO2xldCBnPW0qay5zaXplKGEpO3JldHVybiBuZXcgc3IodGhpcy5tb2R1bGUsZCx0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGcpLmlkLGEpfTtyZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bih0LG8sbixzLHUpfW91dHB1dCh0LHIpe2xldCBvPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgbj10aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxK3IubGVuZ3RoKSo0KSxzPW4+PjI7dGhpcy5tb2R1bGUuSEVBUFUzMltzKytdPXIubGVuZ3RoO2ZvcihsZXQgdT0wO3U8ci5sZW5ndGg7dSsrKXRoaXMubW9kdWxlLkhFQVBVMzJbcysrXT1yW3VdO3JldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCx0LG4pfWNhdGNoKG4pe3Rocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbFxcJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtyfV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtufWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKG8pfX19LGljPWFzeW5jKGUsdCk9PntsZXQgcj1lLmpzZXBJbml0O2lmKHImJm5hdmlnYXRvci5ncHUpe2lmKCF0Lndhc20uc2ltZCl0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIGZvciBXZWJHUFU9T04gYW5kIFNJTUQ9T0ZGLiBQbGVhc2Ugc2V0IGBlbnYud2FzbS5zaW1kYCB0byB0cnVlIHdoZW4gdXNpbmcgV2ViR1BVIEVQXCIpO2xldCBvPW5ldyBKcjthd2FpdCBvLmluaXRpYWxpemUodCkscihvLG49Pm8uYWxsb2Mobiksbj0+by5mcmVlKG4pLChuLHMsdSxkPSExKT0+e2lmKGQpRWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtufSwgZHN0PSR7c30sIHNpemU9JHt1fWApLG8ubWVtY3B5KG4scyk7ZWxzZXtFZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHtufSwgZ3B1RGF0YUlkPSR7c30sIHNpemU9JHt1fWApO2xldCBhPWUuSEVBUFU4LnN1YmFycmF5KG4sbit1KTtvLnVwbG9hZChzLGEpfX0sYXN5bmMobixzLHUpPT57RWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtufSwgZGF0YU9mZnNldD0ke3N9LCBzaXplPSR7dX1gKSxhd2FpdCBvLmRvd25sb2FkKG4sKCk9PmUuSEVBUFU4LnN1YmFycmF5KHMscyt1KSl9LChuLHMsdSk9Pm8uY3JlYXRlS2VybmVsKG4scyx1LHQuZGVidWd8fHQud2ViZ3B1LnByb2ZpbGluZ01vZGU9PT1cImRlZmF1bHRcIj9lLlVURjhUb1N0cmluZyhlLl9Kc2VwR2V0Tm9kZU5hbWUocykpOmAke3N9YCksbj0+by5yZWxlYXNlS2VybmVsKG4pLChuLHMsdSxkKT0+e0VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke3V9LCBrZXJuZWw9JHtufSwgY29udGV4dERhdGFPZmZzZXQ9JHtzfWApO2xldCBhPW5ldyB6bihlLG8scyk7cmV0dXJuIG8uY29tcHV0ZUtlcm5lbChuLGEsZCl9KX19fSk7dmFyIHdvO3dvPXVvKCk7dmFyIFJ1PWdvKCkscG4sZm49ITEsRXI9ITEsYm89ITEsUHU9KCk9Pnt0cnl7cmV0dXJuIHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIj8hMToodHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSkpfWNhdGNoe3JldHVybiExfX0sTXU9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sQnU9KGUsdCk9PmU/dD9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20tc2ltZC53YXNtXCI6dD9cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLndhc21cIix2bz1hc3luYyBlPT57aWYoZm4pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKEVyKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGRldGVjdGVkLlwiKTtpZihibyl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGZhaWxlZC5cIik7RXI9ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcyxvPWUuc2ltZCxuPXI+MSYmUHUoKSxzPW8mJk11KCksdT1lLndhc21QYXRocyxkPXR5cGVvZiB1PT1cInN0cmluZ1wiP3U6dm9pZCAwLGE9QnUocyxuKSxtPXR5cGVvZiB1PT1cIm9iamVjdFwiP3VbYV06dm9pZCAwLGc9ITEseD1bXTtpZih0PjAmJngucHVzaChuZXcgUHJvbWlzZShiPT57c2V0VGltZW91dCgoKT0+e2c9ITAsYigpfSx0KX0pKSx4LnB1c2gobmV3IFByb21pc2UoKGIsdyk9PntsZXQgdj1uP1J1OndvLHk9e2xvY2F0ZUZpbGU6KFMsQSk9PntpZihuJiZTLmVuZHNXaXRoKFwiLndvcmtlci5qc1wiKSYmdHlwZW9mIEJsb2I8XCJ1XCIpcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3lvKCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk7aWYoUy5lbmRzV2l0aChcIi53YXNtXCIpKXtpZihtKXJldHVybiBtO2xldCBSPWQ/P0E7cmV0dXJuIGE9PT1cIm9ydC13YXNtLXNpbWQud2FzbVwiP1IrXCJvcnQtd2FzbS1zaW1kLmpzZXAud2FzbVwiOmE9PT1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiP1IrXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiOlIrYX1yZXR1cm4gQStTfX07aWYobilpZih0eXBlb2YgQmxvYj5cInVcIil5Lm1haW5TY3JpcHRVcmxPckJsb2I9KHZvaWQgMCkoX19kaXJuYW1lLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtsZXQgUz1gdmFyIG9ydFdhc21UaHJlYWRlZD0ke3YudG9TdHJpbmcoKX07YDt5Lm1haW5TY3JpcHRVcmxPckJsb2I9bmV3IEJsb2IoW1NdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KX12KHkpLnRoZW4oUz0+e0VyPSExLGZuPSEwLHBuPVMsYigpfSxTPT57RXI9ITEsYm89ITAsdyhTKX0pfSkpLGF3YWl0IFByb21pc2UucmFjZSh4KSxnKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sUmU9KCk9PntpZihmbiYmcG4pcmV0dXJuIHBuO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfTt2YXIgQmU9KGUsdCk9PntsZXQgcj1SZSgpLG89ci5sZW5ndGhCeXRlc1VURjgoZSkrMSxuPXIuX21hbGxvYyhvKTtyZXR1cm4gci5zdHJpbmdUb1VURjgoZSxuLG8pLHQucHVzaChuKSxufSxadD0oZSx0LHIsbyk9PntpZih0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwpe2lmKHIuaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtuLHNdKT0+e2xldCB1PXQ/dCtuOm47aWYodHlwZW9mIHM9PVwib2JqZWN0XCIpWnQocyx1K1wiLlwiLHIsbyk7ZWxzZSBpZih0eXBlb2Ygcz09XCJzdHJpbmdcInx8dHlwZW9mIHM9PVwibnVtYmVyXCIpbyh1LHMudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2Ygcz09XCJib29sZWFuXCIpbyh1LHM/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2Ygc31gKX0pfSxBZT1lPT57bGV0IHQ9UmUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBvPXQuc3RhY2tBbGxvYyg4KTt0Ll9PcnRHZXRMYXN0RXJyb3IobyxvKzQpO2xldCBuPXQuSEVBUDMyW28vNF0scz10LkhFQVBVMzJbby80KzFdLHU9cz90LlVURjhUb1N0cmluZyhzKTpcIlwiO3Rocm93IG5ldyBFcnJvcihgJHtlfSBFUlJPUl9DT0RFOiAke259LCBFUlJPUl9NRVNTQUdFOiAke3V9YCl9ZmluYWxseXt0LnN0YWNrUmVzdG9yZShyKX19O3ZhciAkbz1lPT57bGV0IHQ9UmUoKSxyPTAsbz1bXSxuPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKW4ubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKW4ubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYobi50ZXJtaW5hdGU9ITEpO2xldCBzPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKHM9QmUoZS50YWcsbykpLHI9dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhuLmxvZ1NldmVyaXR5TGV2ZWwsbi5sb2dWZXJib3NpdHlMZXZlbCwhIW4udGVybWluYXRlLHMpLHI9PT0wJiZBZShcIkNhblxcJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxlPy5leHRyYSE9PXZvaWQgMCYmWnQoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCh1LGQpPT57bGV0IGE9QmUodSxvKSxtPUJlKGQsbyk7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkocixhLG0pIT09MCYmQWUoYENhblxcJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHt1fSAtICR7ZH0uYCl9KSxbcixvXX1jYXRjaChzKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMociksby5mb3JFYWNoKHU9PnQuX2ZyZWUodSkpLHN9fTt2YXIga3U9ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0sRHU9ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LFd1PWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShyPT4odHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSx6dT0oZSx0LHIpPT57Zm9yKGxldCBvIG9mIHQpe2xldCBuPXR5cGVvZiBvPT1cInN0cmluZ1wiP286by5uYW1lO3N3aXRjaChuKXtjYXNlXCJ4bm5wYWNrXCI6bj1cIlhOTlBBQ0tcIjticmVhaztjYXNlXCJ3ZWJublwiOmlmKG49XCJXRUJOTlwiLHR5cGVvZiBvIT1cInN0cmluZ1wiKXtsZXQgdT1vO2lmKHU/LmRldmljZVR5cGUpe2xldCBkPUJlKFwiZGV2aWNlVHlwZVwiLHIpLGE9QmUodS5kZXZpY2VUeXBlLHIpO1JlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGQsYSkhPT0wJiZBZShgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogXFwnZGV2aWNlVHlwZVxcJyAtICR7dS5kZXZpY2VUeXBlfS5gKX1pZih1Py5wb3dlclByZWZlcmVuY2Upe2xldCBkPUJlKFwicG93ZXJQcmVmZXJlbmNlXCIsciksYT1CZSh1LnBvd2VyUHJlZmVyZW5jZSxyKTtSZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxkLGEpIT09MCYmQWUoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6IFxcJ3Bvd2VyUHJlZmVyZW5jZVxcJyAtICR7dS5wb3dlclByZWZlcmVuY2V9LmApfX1icmVhaztjYXNlXCJ3ZWJncHVcIjppZihuPVwiSlNcIix0eXBlb2YgbyE9XCJzdHJpbmdcIil7bGV0IHU9bztpZih1Py5wcmVmZXJyZWRMYXlvdXQpe2lmKHUucHJlZmVycmVkTGF5b3V0IT09XCJOQ0hXXCImJnUucHJlZmVycmVkTGF5b3V0IT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgXFwnTkNIV1xcJyBvciBcXCdOSFdDXFwnOiAke3UucHJlZmVycmVkTGF5b3V0fWApO2xldCBkPUJlKFwicHJlZmVycmVkTGF5b3V0XCIsciksYT1CZSh1LnByZWZlcnJlZExheW91dCxyKTtSZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxkLGEpIT09MCYmQWUoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6IFxcJ3ByZWZlcnJlZExheW91dFxcJyAtICR7dS5wcmVmZXJyZWRMYXlvdXR9LmApfX1icmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke259YCl9bGV0IHM9QmUobixyKTtSZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLHMpIT09MCYmQWUoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtufS5gKX19LHhvPWU9PntsZXQgdD1SZSgpLHI9MCxvPVtdLG49ZXx8e307V3Uobik7dHJ5e2xldCBzPWt1KG4uZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIiksdT1EdShuLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxkPXR5cGVvZiBuLmxvZ0lkPT1cInN0cmluZ1wiP0JlKG4ubG9nSWQsbyk6MCxhPW4ubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcihhKXx8YTwwfHxhPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHthfWApO2xldCBtPW4ubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIobSl8fG08MHx8bT40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bX1gKTtsZXQgZz10eXBlb2Ygbi5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP0JlKG4ub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxvKTowO2lmKHI9dC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMocywhIW4uZW5hYmxlQ3B1TWVtQXJlbmEsISFuLmVuYWJsZU1lbVBhdHRlcm4sdSwhIW4uZW5hYmxlUHJvZmlsaW5nLDAsZCxhLG0sZykscj09PTAmJkFlKFwiQ2FuXFwndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxuLmV4ZWN1dGlvblByb3ZpZGVycyYmenUocixuLmV4ZWN1dGlvblByb3ZpZGVycyxvKSxuLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpZm9yKGxldFt4LGJdb2YgT2JqZWN0LmVudHJpZXMobi5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSl7aWYodHlwZW9mIHghPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7eH1gKTtpZih0eXBlb2YgYiE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoYil8fGI8MCl0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHtifWApO2xldCB3PUJlKHgsbyk7dC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKHIsdyxiKSE9PTAmJkFlKGBDYW5cXCd0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke3h9IC0gJHtifS5gKX1yZXR1cm4gbi5leHRyYSE9PXZvaWQgMCYmWnQobi5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCh4LGIpPT57bGV0IHc9QmUoeCxvKSx2PUJlKGIsbyk7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHIsdyx2KSE9PTAmJkFlKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3h9IC0gJHtifS5gKX0pLFtyLG9dfWNhdGNoKHMpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMociksby5mb3JFYWNoKHU9PnQuX2ZyZWUodSkpLHN9fTtEZSgpO3ZhciBydT0hMSxzYz1lPT57bGV0IHQ9UmUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBvPXQuc3RhY2tBbGxvYyg4KTtyZXR1cm4gdC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG8sbys0KSE9PTAmJkFlKFwiQ2FuXFwndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpLFt0LkhFQVAzMltvLzRdLHQuSEVBUDMyW28vNCsxXV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShyKX19LHVjPShlLHQpPT57UmUoKS5fT3J0SW5pdChlLHQpIT09MCYmQWUoXCJDYW5cXCd0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxudT1hc3luYyBlPT57dWMoZS53YXNtLm51bVRocmVhZHMsdHIoZS5sb2dMZXZlbCkpO3tsZXQgdD0oZXUoKSxNdChRcykpLmluaXQ7YXdhaXQgdChSZSgpLGUpfXJ1PSEwfSx1cj1uZXcgTWFwLG91PSgpPT5ydSxWbj1lPT57bGV0IHQ9UmUoKSxyPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKHI9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuXFwndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke2UuYnl0ZUxlbmd0aH0uYCk7cmV0dXJuIHQuSEVBUFU4LnNldChlLHIpLFtyLGUuYnl0ZUxlbmd0aF19LEduPShlLHQpPT57bGV0IHI9UmUoKSxvPTAsbj0wLHM9MCx1PVtdLGQ9W10sYT1bXTt0cnl7W24sdV09eG8odCksbz1yLl9PcnRDcmVhdGVTZXNzaW9uKGVbMF0sZVsxXSxuKSxvPT09MCYmQWUoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb24uXCIpO2xldFttLGddPXNjKG8pLHg9W10sYj1bXSx3PVtdO2ZvcihsZXQgeT0wO3k8bTt5Kyspe2xldCBTPXIuX09ydEdldElucHV0TmFtZShvLHkpO1M9PT0wJiZBZShcIkNhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLGQucHVzaChTKSx4LnB1c2goci5VVEY4VG9TdHJpbmcoUykpfWZvcihsZXQgeT0wO3k8Zzt5Kyspe2xldCBTPXIuX09ydEdldE91dHB1dE5hbWUobyx5KTtTPT09MCYmQWUoXCJDYW5cXCd0IGdldCBhbiBvdXRwdXQgbmFtZS5cIiksYS5wdXNoKFMpO2xldCBBPXIuVVRGOFRvU3RyaW5nKFMpO2IucHVzaChBKTt7bGV0IFI9dHlwZW9mIHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT1cInN0cmluZ1wiP3QucHJlZmVycmVkT3V0cHV0TG9jYXRpb246dD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24/LltBXT8/XCJjcHVcIjtpZihSIT09XCJjcHVcIiYmUiE9PVwiY3B1LXBpbm5lZFwiJiZSIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7Un0uYCk7dy5wdXNoKFIpfX1sZXQgdj1udWxsO3JldHVybiB3LnNvbWUoeT0+eT09PVwiZ3B1LWJ1ZmZlclwiKSYmKHM9ci5fT3J0Q3JlYXRlQmluZGluZyhvKSxzPT09MCYmQWUoXCJDYW5cXCd0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSx2PXtoYW5kbGU6cyxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6dyxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOncubWFwKHk9PmhuKHkpKX0pLHVyLnNldChvLFtvLGQsYSx2XSksW28seCxiXX1jYXRjaChtKXt0aHJvdyBkLmZvckVhY2goZz0+ci5fT3J0RnJlZShnKSksYS5mb3JFYWNoKGc9PnIuX09ydEZyZWUoZykpLHMhPT0wJiZyLl9PcnRSZWxlYXNlQmluZGluZyhzKSxvIT09MCYmci5fT3J0UmVsZWFzZVNlc3Npb24obyksbX1maW5hbGx5e3IuX2ZyZWUoZVswXSksbiE9PTAmJnIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSx1LmZvckVhY2gobT0+ci5fZnJlZShtKSl9fSxhdT0oZSx0KT0+e2xldCByPVZuKGUpO3JldHVybiBHbihyLHQpfSxpdT1lPT57bGV0IHQ9UmUoKSxyPXVyLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFtvLG4scyx1XT1yO3UmJnQuX09ydFJlbGVhc2VCaW5kaW5nKHUuaGFuZGxlKSx0LmpzZXBVbnJlZ2lzdGVyQnVmZmVycz8uKGUpLG4uZm9yRWFjaChkPT50Ll9PcnRGcmVlKGQpKSxzLmZvckVhY2goZD0+dC5fT3J0RnJlZShkKSksdC5fT3J0UmVsZWFzZVNlc3Npb24obyksdXIuZGVsZXRlKGUpfSx0dT0oZSx0LHIsbyxuKT0+e2lmKCFlKXt0LnB1c2goMCk7cmV0dXJufWxldCBzPVJlKCksdT1lWzBdLGQ9ZVsxXSxhPWVbM10sbSxnO2lmKHU9PT1cInN0cmluZ1wiJiZhPT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7aWYoYT09PVwiZ3B1LWJ1ZmZlclwiKXtsZXQgdz1lWzJdLmdwdUJ1ZmZlcix2PWVyKG1uKHUpKTtnPWQucmVkdWNlKCh5LFMpPT55KlMsMSkqdixtPXMuanNlcFJlZ2lzdGVyQnVmZmVyKG8sbix3LGcpfWVsc2V7bGV0IHc9ZVsyXTtpZihBcnJheS5pc0FycmF5KHcpKXtnPTQqdy5sZW5ndGgsbT1zLl9tYWxsb2MoZyksci5wdXNoKG0pO2xldCB2PW0vNDtmb3IobGV0IHk9MDt5PHcubGVuZ3RoO3krKyl7aWYodHlwZW9mIHdbeV0hPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHt5fSBpcyBub3QgYSBzdHJpbmdgKTtzLkhFQVBVMzJbdisrXT1CZSh3W3ldLHIpfX1lbHNlIGc9dy5ieXRlTGVuZ3RoLG09cy5fbWFsbG9jKGcpLHIucHVzaChtKSxzLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkody5idWZmZXIsdy5ieXRlT2Zmc2V0LGcpLG0pfWxldCB4PXMuc3RhY2tTYXZlKCksYj1zLnN0YWNrQWxsb2MoNCpkLmxlbmd0aCk7dHJ5e2xldCB3PWIvNDtkLmZvckVhY2goeT0+cy5IRUFQMzJbdysrXT15KTtsZXQgdj1zLl9PcnRDcmVhdGVUZW5zb3IobW4odSksbSxnLGIsZC5sZW5ndGgsaG4oYSkpO3Y9PT0wJiZBZShgQ2FuXFwndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtvfSwgaW5kZXg9JHtufS5gKSx0LnB1c2godil9ZmluYWxseXtzLnN0YWNrUmVzdG9yZSh4KX19LHN1PWFzeW5jKGUsdCxyLG8sbixzKT0+e2xldCB1PVJlKCksZD11ci5nZXQoZSk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W2EsbSxnLHhdPWQsYj10Lmxlbmd0aCx3PW8ubGVuZ3RoLHY9MCx5PVtdLFM9W10sQT1bXSxSPVtdLFc9dS5zdGFja1NhdmUoKSxNPXUuc3RhY2tBbGxvYyhiKjQpLEQ9dS5zdGFja0FsbG9jKGIqNCksXz11LnN0YWNrQWxsb2Modyo0KSx6PXUuc3RhY2tBbGxvYyh3KjQpO3RyeXtbdix5XT0kbyhzKTtmb3IobGV0IGFlPTA7YWU8YjthZSsrKXR1KHJbYWVdLFMsUixlLHRbYWVdKTtmb3IobGV0IGFlPTA7YWU8dzthZSsrKXR1KG5bYWVdLEEsUixlLGIrb1thZV0pO2xldCBGPU0vNCxxPUQvNCxsZT1fLzQsQj16LzQ7Zm9yKGxldCBhZT0wO2FlPGI7YWUrKyl1LkhFQVBVMzJbRisrXT1TW2FlXSx1LkhFQVBVMzJbcSsrXT1tW3RbYWVdXTtmb3IobGV0IGFlPTA7YWU8dzthZSsrKXUuSEVBUFUzMltsZSsrXT1BW2FlXSx1LkhFQVBVMzJbQisrXT1nW29bYWVdXTtpZih4KXtsZXR7aGFuZGxlOmFlLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczp3ZSxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOmp9PXg7aWYobS5sZW5ndGghPT1iKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtifSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsXFwncyBpbnB1dCBjb3VudCAoJHttLmxlbmd0aH0pLmApO2ZvcihsZXQgU2U9MDtTZTxiO1NlKyspe2xldCBPZT10W1NlXTthd2FpdCB1Ll9PcnRCaW5kSW5wdXQoYWUsbVtPZV0sU1tTZV0pIT09MCYmQWUoYENhblxcJ3QgYmluZCBpbnB1dFske1NlfV0gZm9yIHNlc3Npb249JHtlfS5gKX1mb3IobGV0IFNlPTA7U2U8dztTZSsrKXtsZXQgT2U9b1tTZV07bltTZV0/LlszXT91Ll9PcnRCaW5kT3V0cHV0KGFlLGdbT2VdLEFbU2VdLDApIT09MCYmQWUoYENhblxcJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske1NlfV0gZm9yIHNlc3Npb249JHtlfS5gKTp1Ll9PcnRCaW5kT3V0cHV0KGFlLGdbT2VdLDAsaltPZV0pIT09MCYmQWUoYENhblxcJ3QgYmluZCBvdXRwdXRbJHtTZX1dIHRvICR7d2VbU2VdfSBmb3Igc2Vzc2lvbj0ke2V9LmApfX1sZXQgSzt4P0s9YXdhaXQgdS5fT3J0UnVuV2l0aEJpbmRpbmcoYSx4LmhhbmRsZSx3LF8sdik6Sz1hd2FpdCB1Ll9PcnRSdW4oYSxELE0sYix6LHcsXyx2KSxLIT09MCYmQWUoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IHhlPVtdO2ZvcihsZXQgYWU9MDthZTx3O2FlKyspe2xldCB3ZT11LkhFQVBVMzJbXy80K2FlXTtpZih3ZT09PUFbYWVdKXt4ZS5wdXNoKG5bYWVdKTtjb250aW51ZX1sZXQgaj11LnN0YWNrU2F2ZSgpLFNlPXUuc3RhY2tBbGxvYyg0KjQpLE9lPSExLEllLENlPTA7dHJ5e3UuX09ydEdldFRlbnNvckRhdGEod2UsU2UsU2UrNCxTZSs4LFNlKzEyKSE9PTAmJkFlKGBDYW5cXCd0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHthZX0uYCk7bGV0IE5lPVNlLzQsTGU9dS5IRUFQVTMyW05lKytdO0NlPXUuSEVBUFUzMltOZSsrXTtsZXQgTj11LkhFQVBVMzJbTmUrK10sZGU9dS5IRUFQVTMyW05lKytdLHBlPVtdO2ZvcihsZXQgVGU9MDtUZTxkZTtUZSsrKXBlLnB1c2godS5IRUFQVTMyW04vNCtUZV0pO3UuX09ydEZyZWUoTik7bGV0IHplPXBlLnJlZHVjZSgoVGUsa2UpPT5UZSprZSwxKTtJZT1RdChMZSk7bGV0IFVlPXg/Lm91dHB1dFByZWZlcnJlZExvY2F0aW9uc1tvW2FlXV07aWYoSWU9PT1cInN0cmluZ1wiKXtpZihVZT09PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2xldCBUZT1bXSxrZT1DZS80O2ZvcihsZXQgR2U9MDtHZTx6ZTtHZSsrKXtsZXQgWGU9dS5IRUFQVTMyW2tlKytdLEZlPUdlPT09emUtMT92b2lkIDA6dS5IRUFQVTMyW2tlXS1YZTtUZS5wdXNoKHUuVVRGOFRvU3RyaW5nKFhlLEZlKSl9eGUucHVzaChbSWUscGUsVGUsXCJjcHVcIl0pfWVsc2UgaWYoVWU9PT1cImdwdS1idWZmZXJcIiYmemU+MCl7bGV0IFRlPXUuanNlcEdldEJ1ZmZlcihDZSksa2U9ZXIoTGUpO2lmKGtlPT09dm9pZCAwfHwhU28oSWUpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke0llfWApO09lPSEwLHhlLnB1c2goW0llLHBlLHtncHVCdWZmZXI6VGUsZG93bmxvYWQ6dS5qc2VwQ3JlYXRlRG93bmxvYWRlcihUZSx6ZSprZSxJZSksZGlzcG9zZTooKT0+e3UuX09ydFJlbGVhc2VUZW5zb3Iod2UpfX0sXCJncHUtYnVmZmVyXCJdKX1lbHNle2xldCBUZT1UcihJZSksa2U9bmV3IFRlKHplKTtuZXcgVWludDhBcnJheShrZS5idWZmZXIsa2UuYnl0ZU9mZnNldCxrZS5ieXRlTGVuZ3RoKS5zZXQodS5IRUFQVTguc3ViYXJyYXkoQ2UsQ2Ura2UuYnl0ZUxlbmd0aCkpLHhlLnB1c2goW0llLHBlLGtlLFwiY3B1XCJdKX19ZmluYWxseXt1LnN0YWNrUmVzdG9yZShqKSxJZT09PVwic3RyaW5nXCImJkNlJiZ1Ll9mcmVlKENlKSxPZXx8dS5fT3J0UmVsZWFzZVRlbnNvcih3ZSl9fXJldHVybiB4JiZ1Ll9PcnRDbGVhckJvdW5kT3V0cHV0cyh4LmhhbmRsZSkseGV9ZmluYWxseXt1LnN0YWNrUmVzdG9yZShXKSxTLmZvckVhY2goRj0+dS5fT3J0UmVsZWFzZVRlbnNvcihGKSksQS5mb3JFYWNoKEY9PnUuX09ydFJlbGVhc2VUZW5zb3IoRikpLFIuZm9yRWFjaChGPT51Ll9mcmVlKEYpKSx2IT09MCYmdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnModikseS5mb3JFYWNoKEY9PnUuX2ZyZWUoRikpfX0sdXU9ZT0+e2xldCB0PVJlKCkscj11ci5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBvPXJbMF0sbj10Ll9PcnRFbmRQcm9maWxpbmcobyk7bj09PTAmJkFlKFwiQ2FuXFwndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpLHQuX09ydEZyZWUobil9LGx1PWU9PntsZXQgdD1bXTtmb3IobGV0IHIgb2YgZSl7bGV0IG89clsyXTshQXJyYXkuaXNBcnJheShvKSYmXCJidWZmZXJcImluIG8mJnQucHVzaChvLmJ1ZmZlcil9cmV0dXJuIHR9O3NlbGYub25tZXNzYWdlPWU9Pntzd2l0Y2goZS5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOnRyeXt2byhlLmRhdGEuaW4pLnRoZW4oKCk9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCJ9KSx0PT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwiLGVycjp0fSkpfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCIsZXJyOnR9KX1icmVhaztjYXNlXCJpbml0LW9ydFwiOnRyeXtudShlLmRhdGEuaW4pLnRoZW4oKCk9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC1vcnRcIn0pLHQ9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC1vcnRcIixlcnI6dH0pKX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCIsZXJyOnR9KX1icmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0cnl7bGV0e21vZGVsOnR9PWUuZGF0YS5pbixyPVZuKHQpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsb3V0OnJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dHJ5e2xldHttb2RlbGRhdGE6dCxvcHRpb25zOnJ9PWUuZGF0YS5pbixvPUduKHQscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixvdXQ6b30pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsZXJyOnR9KX1icmVhaztjYXNlXCJjcmVhdGVcIjp0cnl7bGV0e21vZGVsOnQsb3B0aW9uczpyfT1lLmRhdGEuaW4sbz1hdSh0LHIpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlXCIsb3V0Om99KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwicmVsZWFzZVwiOnRyeXtsZXQgdD1lLmRhdGEuaW47aXUodCkscG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIixlcnI6dH0pfWJyZWFrO2Nhc2VcInJ1blwiOnRyeXtsZXR7c2Vzc2lvbklkOnQsaW5wdXRJbmRpY2VzOnIsaW5wdXRzOm8sb3V0cHV0SW5kaWNlczpuLG9wdGlvbnM6c309ZS5kYXRhLmluO3N1KHQscixvLG4scykudGhlbih1PT57cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixvdXQ6dX0sbHUodSkpfSx1PT57cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixlcnI6dX0pfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixlcnI6dH0pfWJyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0cnl7bGV0IHQ9ZS5kYXRhLmluO3V1KHQpLHBvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsZXJyOnR9KX1icmVhaztjYXNlXCJpcy1vcnQtZW52LWluaXRpYWxpemVkXCI6dHJ5e2xldCB0PW91KCk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpcy1vcnQtZW52LWluaXRpYWxpemVkXCIsb3V0OnR9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImlzLW9ydC1lbnYtaW5pdGlhbGl6ZWRcIixlcnI6dH0pfWJyZWFrO2RlZmF1bHQ6fX07fSkoKTtcXG4vKipcXG4gKiBAbGljZW5zZVxcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXFxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XFxuICpcXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcXG4gKlxcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICovXFxuLyoqXFxuICogQGxpY2Vuc2VcXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XFxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxcbiAqXFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxuICpcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAqL1xcbi8qKlxcbiAqIEBsaWNlbnNlXFxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXG4gKlxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcbiAqXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gKi9cXG4nfSk7dmFyIGh0LGplLGJuLCRhLHhhLHBhLGZhLG1hLGhhLGdhLHlhLGJhLHdhLHZhLEl0LHZwLHluLHNsLHVsLGxsLGRsLFNhLGNsLHBsLGZsLG1sLENhPUwoKCk9PntcInVzZSBzdHJpY3RcIjskdCgpO29sKCk7SHQoKTtodD0oKT0+ISFJZS53YXNtLnByb3h5JiZ0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIsYm49ITEsJGE9ITEseGE9ITEsbWE9W10saGE9W10sZ2E9W10seWE9W10sYmE9W10sd2E9W10sdmE9W10sSXQ9KCk9PntpZihibnx8ISRhfHx4YXx8IWplKXRocm93IG5ldyBFcnJvcihcIndvcmtlciBub3QgcmVhZHlcIil9LHZwPWU9Pntzd2l0Y2goZS5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmJuPSExLGUuZGF0YS5lcnI/KHhhPSEwLHBhWzFdKGUuZGF0YS5lcnIpKTooJGE9ITAscGFbMF0oKSk7YnJlYWs7Y2FzZVwiaW5pdC1vcnRcIjplLmRhdGEuZXJyP2ZhWzFdKGUuZGF0YS5lcnIpOmZhWzBdKCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2FsbG9jYXRlXCI6ZS5kYXRhLmVycj9tYS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOm1hLnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6ZS5kYXRhLmVycj9oYS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOmhhLnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlXCI6ZS5kYXRhLmVycj9nYS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOmdhLnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwicmVsZWFzZVwiOmUuZGF0YS5lcnI/eWEuc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp5YS5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwicnVuXCI6ZS5kYXRhLmVycj9iYS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOmJhLnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOmUuZGF0YS5lcnI/d2Euc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp3YS5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwiaXMtb3J0LWVudi1pbml0aWFsaXplZFwiOmUuZGF0YS5lcnI/dmEuc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp2YS5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2RlZmF1bHQ6fX0seW49dHlwZW9mIGRvY3VtZW50PFwidVwiP2RvY3VtZW50Py5jdXJyZW50U2NyaXB0Py5zcmM6dm9pZCAwLHNsPWFzeW5jKCk9PntpZihodCgpKXtpZigkYSlyZXR1cm47aWYoYm4pdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZih4YSl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO3JldHVybiBibj0hMCxJZS53YXNtLndhc21QYXRocz09PXZvaWQgMCYmeW4mJnluLmluZGV4T2YoXCJibG9iOlwiKSE9PTAmJihJZS53YXNtLndhc21QYXRocz15bi5zdWJzdHIoMCwreW4ubGFzdEluZGV4T2YoXCIvXCIpKzEpKSxuZXcgUHJvbWlzZSgoZSx0KT0+e2plPy50ZXJtaW5hdGUoKTtsZXQgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtpbCgpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpO2plPW5ldyBXb3JrZXIocix7bmFtZTpcIm9ydC13YXNtLXByb3h5LXdvcmtlclwifSksamUub25lcnJvcj1uPT50KG4pLGplLm9ubWVzc2FnZT12cCxVUkwucmV2b2tlT2JqZWN0VVJMKHIpLHBhPVtlLHRdO2xldCBhPXt0eXBlOlwiaW5pdC13YXNtXCIsaW46SWUud2FzbX07amUucG9zdE1lc3NhZ2UoYSl9KX1lbHNlIHJldHVybiBQbyhJZS53YXNtKX0sdWw9YXN5bmMgZT0+e2lmKGh0KCkpcmV0dXJuIEl0KCksbmV3IFByb21pc2UoKHQscik9PntmYT1bdCxyXTtsZXQgYT17dHlwZTpcImluaXQtb3J0XCIsaW46ZX07amUucG9zdE1lc3NhZ2UoYSl9KTthd2FpdCBRdShlKX0sbGw9YXN5bmMgZT0+aHQoKT8oSXQoKSxuZXcgUHJvbWlzZSgodCxyKT0+e21hLnB1c2goW3Qscl0pO2xldCBhPXt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsaW46e21vZGVsOmV9fTtqZS5wb3N0TWVzc2FnZShhLFtlLmJ1ZmZlcl0pfSkpOmRhKGUpLGRsPWFzeW5jKGUsdCk9Pmh0KCk/KEl0KCksbmV3IFByb21pc2UoKHIsYSk9PntoYS5wdXNoKFtyLGFdKTtsZXQgbj17dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLGluOnttb2RlbGRhdGE6ZSxvcHRpb25zOnR9fTtqZS5wb3N0TWVzc2FnZShuKX0pKTpjYShlLHQpLFNhPWFzeW5jKGUsdCk9PntpZihodCgpKXtpZih0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbil0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gb3B0aW9uIFwicHJlZmVycmVkT3V0cHV0TG9jYXRpb25cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtyZXR1cm4gSXQoKSxuZXcgUHJvbWlzZSgocixhKT0+e2dhLnB1c2goW3IsYV0pO2xldCBuPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOmUsb3B0aW9uczp0fX07amUucG9zdE1lc3NhZ2UobixbZS5idWZmZXJdKX0pfWVsc2UgcmV0dXJuIGVsKGUsdCl9LGNsPWFzeW5jIGU9PntpZihodCgpKXJldHVybiBJdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57eWEucHVzaChbdCxyXSk7bGV0IGE9e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07amUucG9zdE1lc3NhZ2UoYSl9KTt0bChlKX0scGw9YXN5bmMoZSx0LHIsYSxuLHMpPT57aWYoaHQoKSl7aWYoci5zb21lKHU9PnVbM10hPT1cImNwdVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtpZihuLnNvbWUodT0+dSkpdGhyb3cgbmV3IEVycm9yKFwicHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtyZXR1cm4gSXQoKSxuZXcgUHJvbWlzZSgodSxsKT0+e2JhLnB1c2goW3UsbF0pO2xldCBvPXIscD17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6byxvdXRwdXRJbmRpY2VzOmEsb3B0aW9uczpzfX07amUucG9zdE1lc3NhZ2UocCxhbChvKSl9KX1lbHNlIHJldHVybiBybChlLHQscixhLG4scyl9LGZsPWFzeW5jIGU9PntpZihodCgpKXJldHVybiBJdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57d2EucHVzaChbdCxyXSk7bGV0IGE9e3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsaW46ZX07amUucG9zdE1lc3NhZ2UoYSl9KTtubChlKX0sbWw9YXN5bmMoKT0+aHQoKT8oSXQoKSxuZXcgUHJvbWlzZSgoZSx0KT0+e3ZhLnB1c2goW2UsdF0pO2xldCByPXt0eXBlOlwiaXMtb3J0LWVudi1pbml0aWFsaXplZFwifTtqZS5wb3N0TWVzc2FnZShyKX0pKTpadSgpfSk7dmFyIHduLGhsLCRwLHZuLGdsPUwoKCk9PntcInVzZSBzdHJpY3RcIjskdCgpO0NhKCk7RGUoKTtobD0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm5bZS50eXBlLGUuZGltcyxlLmRhdGEsXCJjcHVcIl07Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHtncHVCdWZmZXI6ZS5ncHVCdWZmZXJ9LFwiZ3B1LWJ1ZmZlclwiXTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2UubG9jYXRpb259IGZvciAke3QoKX1gKX19LCRwPWU9Pntzd2l0Y2goZVszXSl7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBVZShlWzBdLGVbMl0sZVsxXSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOntsZXQgdD1lWzBdO2lmKCFZcih0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIEdQVSB0ZW5zb3JgKTtsZXR7Z3B1QnVmZmVyOnIsZG93bmxvYWQ6YSxkaXNwb3NlOm59PWVbMl07cmV0dXJuIFVlLmZyb21HcHVCdWZmZXIocix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6YSxkaXNwb3NlOm59KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSx2bj1jbGFzc3thc3luYyBjcmVhdGVTZXNzaW9uQWxsb2NhdGUodCl7bGV0IHI9YXdhaXQgZmV0Y2godCk7aWYoci5zdGF0dXMhPT0yMDApdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBtb2RlbDogJHt0fWApO2xldCBhPWF3YWl0IHIuYXJyYXlCdWZmZXIoKTtyZXR1cm4gbGwobmV3IFVpbnQ4QXJyYXkoYSkpfWFzeW5jIGxvYWRNb2RlbCh0LHIpe2lmKGF3YWl0IG1sKCl8fCh3bnx8KHduPXVsKEllKSksYXdhaXQgd24sd249dm9pZCAwKSx0eXBlb2YgdD09XCJzdHJpbmdcIilpZih0eXBlb2YgcHJvY2VzczxcInVcIiYmcHJvY2Vzcy52ZXJzaW9ucyYmcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKXtsZXQgYT1hd2FpdCh2b2lkIDApKHQpO1t0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgU2EoYSxyKX1lbHNle2xldCBhPWF3YWl0IHRoaXMuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKHQpO1t0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgZGwoYSxyKX1lbHNlW3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBTYSh0LHIpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4gY2wodGhpcy5zZXNzaW9uSWQpfWFzeW5jIHJ1bih0LHIsYSl7bGV0IG49W10scz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKGc9PntsZXQgdj1nWzBdLCQ9Z1sxXSxiPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKHYpO2lmKGI9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7dn0nYCk7bi5wdXNoKCQpLHMucHVzaChiKX0pO2xldCB1PVtdLGw9W107T2JqZWN0LmVudHJpZXMocikuZm9yRWFjaChnPT57bGV0IHY9Z1swXSwkPWdbMV0sYj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2Yodik7aWYoYj09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7dn0nYCk7dS5wdXNoKCQpLGwucHVzaChiKX0pO2xldCBvPW4ubWFwKChnLHYpPT5obChnLCgpPT5gaW5wdXQgXCIke3RoaXMuaW5wdXROYW1lc1tzW3ZdXX1cImApKSxwPXUubWFwKChnLHYpPT5nP2hsKGcsKCk9PmBvdXRwdXQgXCIke3RoaXMub3V0cHV0TmFtZXNbbFt2XV19XCJgKTpudWxsKSxtPWF3YWl0IHBsKHRoaXMuc2Vzc2lvbklkLHMsbyxsLHAsYSkseT17fTtmb3IobGV0IGc9MDtnPG0ubGVuZ3RoO2crKyl5W3RoaXMub3V0cHV0TmFtZXNbbFtnXV1dPXVbZ10/PyRwKG1bZ10pO3JldHVybiB5fXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpe2ZsKHRoaXMuc2Vzc2lvbklkKX19fSk7dmFyIHhwLCRuLHlsPUwoKCk9PntcInVzZSBzdHJpY3RcIjskdCgpO0NhKCk7Z2woKTt4cD0oKT0+e2lmKCh0eXBlb2YgSWUud2FzbS5pbml0VGltZW91dCE9XCJudW1iZXJcInx8SWUud2FzbS5pbml0VGltZW91dDwwKSYmKEllLndhc20uaW5pdFRpbWVvdXQ9MCksdHlwZW9mIEllLndhc20uc2ltZCE9XCJib29sZWFuXCImJihJZS53YXNtLnNpbWQ9ITApLHR5cGVvZiBJZS53YXNtLnByb3h5IT1cImJvb2xlYW5cIiYmKEllLndhc20ucHJveHk9ITEpLHR5cGVvZiBJZS53YXNtLm51bVRocmVhZHMhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKEllLndhc20ubnVtVGhyZWFkcyl8fEllLndhc20ubnVtVGhyZWFkczw9MCl7bGV0IGU9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj8odm9pZCAwKSgpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtJZS53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LCRuPWNsYXNze2FzeW5jIGluaXQoKXt4cCgpLGF3YWl0IHNsKCl9YXN5bmMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIodCxyKXtsZXQgYT1uZXcgdm47cmV0dXJuIGF3YWl0IGEubG9hZE1vZGVsKHQsciksUHJvbWlzZS5yZXNvbHZlKGEpfX19KTt2YXIgYmw9e307a3QoYmwse3dhc21CYWNrZW5kOigpPT5TcH0pO3ZhciBTcCx3bD1MKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eWwoKTtTcD1uZXcgJG59KTt2YXIgSXA9e307a3QoSXAse0luZmVyZW5jZVNlc3Npb246KCk9PnBvLFRlbnNvcjooKT0+VWUsVHJhaW5pbmdTZXNzaW9uOigpPT5nbyxkZWZhdWx0OigpPT5DcCxlbnY6KCk9PkllLHJlZ2lzdGVyQmFja2VuZDooKT0+ZnR9KTttb2R1bGUuZXhwb3J0cz12dChJcCk7JHQoKTskdCgpOyR0KCk7dmFyIGJvPVwiMS4xNy4wLWRldi4yMDIzMTEwMy0xNDM5ZGEzNmZlXCI7dmFyIENwPVJuO3tsZXQgZT0od2woKSx2dChibCkpLndhc21CYWNrZW5kO3R5cGVvZiBuYXZpZ2F0b3I8XCJ1XCImJm5hdmlnYXRvci5ncHUmJmZ0KFwid2ViZ3B1XCIsZSw1KSxmdChcImNwdVwiLGUsMTApLGZ0KFwid2FzbVwiLGUsMTApLGZ0KFwieG5ucGFja1wiLGUsOSksZnQoXCJ3ZWJublwiLGUsOSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KEllLnZlcnNpb25zLFwid2ViXCIse3ZhbHVlOmJvLGVudW1lcmFibGU6ITB9KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ydC53ZWJncHUubWluLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiY29uc3Qgb3J0ID0gcmVxdWlyZSgnb25ueHJ1bnRpbWUtd2ViL3dlYmdwdScpO1xuXG5jb25zdCBNQVhfV0lEVEggPSAyODtcbmNvbnN0IE1BWF9IRUlHSFQgPSAyODtcbmNvbnN0IE1PREVMX1dJRFRIID0gMjg7XG5jb25zdCBNT0RFTF9IRUlHSFQgPSAyODtcblxuY29uc3QgTU9ERUxfTUFQID0ge1xuICAgIG1uaXN0X21vZGVsOiBbXCJtb2RlbHMvbW5pc3RfY25uLm9ubnhcIl0sXG59O1xuXG5jb25zdCBjb25maWcgPSBnZXRDb25maWcoKTtcblxub3J0LmVudi53YXNtLm51bVRocmVhZHMgPSBjb25maWcudGhyZWFkcztcbm9ydC5lbnYud2FzbS5wcm94eSA9IHRydWU7XG5cbmxldCBjYW52YXM7XG5sZXQgZmlsZWluO1xubGV0IGRlY29kZXJfbGF0ZW5jeTtcblxudmFyIGltYWdlX2VtYmVkZGluZ3M7XG52YXIgc2VzcyA9IFtdO1xudmFyIGltYWdlSW1hZ2VEYXRhO1xuXG5mdW5jdGlvbiBsb2coaSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0dXMnKS5pbm5lckhUTUwgKz0gYDxicj5bJHtwZXJmb3JtYW5jZS5ub3coKS50b0ZpeGVkKDMpfV0gYCArIGk7XG4gICAgY29uc29sZS5sb2coaSk7XG59XG5cblxuLyoqXG4gKiBnZXQgc29tZSBwYXJhbWV0ZXJzIGZyb20gdXJsXG4gKi9cbmZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgICBjb25zdCBxdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpO1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIG1vZGVsOiBcIm1uaXN0X21vZGVsXCIsXG4gICAgICAgIHByb3ZpZGVyOiBcIndlYmdwdVwiLFxuICAgICAgICBkZXZpY2U6IFwiZ3B1XCIsXG4gICAgICAgIHRocmVhZHM6IFwiMVwiLFxuICAgIH07XG4gICAgbGV0IHZhcnMgPSBxdWVyeS5zcGxpdChcIiZcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwYWlyID0gdmFyc1tpXS5zcGxpdChcIj1cIik7XG4gICAgICAgIGlmIChwYWlyWzBdIGluIGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnW3BhaXJbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBhaXJbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBhcmd1bWVudDogXCIgKyBwYWlyWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25maWcudGhyZWFkcyA9IHBhcnNlSW50KGNvbmZpZy50aHJlYWRzKTtcbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNpemVUZW5zb3Iob3JpZ2luYWxUZW5zb3IpIHtcbiAgICAvLyBBc3N1bWluZyAnb3JpZ2luYWxUZW5zb3InIGlzIHlvdXIgT05OWCBSdW50aW1lIFdlYiB0ZW5zb3Igd2l0aCBkaW1lbnNpb25zIFsxLCAzLCAyOCwgMjhdXG4gICAgLy8gY29uc3Qgb3JpZ2luYWxTaGFwZSA9IG9yaWdpbmFsVGVuc29yLmRpbXM7IC8vIEdldCB0aGUgb3JpZ2luYWwgdGVuc29yJ3MgZGltZW5zaW9uc1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRlbnNvclxuICAgIC8vIGNvbnN0IHRvdGFsRWxlbWVudHMgPSBvcmlnaW5hbFNoYXBlLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyAqIHZhbCk7XG5cbiAgICAvLyBBc3N1bWluZyAnb3JpZ2luYWxEYXRhJyBpcyB5b3VyIEZsb2F0MzJBcnJheSBjb250YWluaW5nIHRoZSB0ZW5zb3IncyBkYXRhXG4gICAgY29uc3Qgb3JpZ2luYWxEYXRhID0gb3JpZ2luYWxUZW5zb3IuZGF0YTtcblxuICAgIC8vIFJlc2hhcGUgdGhlIHRlbnNvciB0byBbMSwgMSwgMjgsIDI4XVxuICAgIGNvbnN0IHJlc2hhcGVkVGVuc29yID0gbmV3IG9ydC5UZW5zb3Iob3JpZ2luYWxEYXRhLnNsaWNlKDAsIDI4KjI4KSwgWzEsIDEsIDI4LCAyOF0pOyAvLyBBZGp1c3QgdGhlIG5ldyBzaGFwZSBhcyBuZWVkZWRcblxuICAgIC8vICdyZXNoYXBlZFRlbnNvcicgbm93IGNvbnRhaW5zIHRoZSBkYXRhIGZyb20gJ29yaWdpbmFsVGVuc29yJyBidXQgd2l0aCB0aGUgbmV3IHNoYXBlIFsxLCAxLCAyOCwgMjhdXG4gICAgbG9nKGBbcmVzaXplVGVuc29yXSByZXNoYXBlZFRlbnNvciBpcyAke3Jlc2hhcGVkVGVuc29yLmRpbXN9YCk7XG4gICAgcmV0dXJuIHJlc2hhcGVkVGVuc29yO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtdWx0aXBseVRlbnNvcih0ZW5zb3IsIHNjYWxhcikge1xuICAgIC8vIEFzc3VtaW5nICd0ZW5zb3InIGlzIHlvdXIgT05OWCBSdW50aW1lIFdlYiB0ZW5zb3JcbiAgICBjb25zdCBkYXRhID0gdGVuc29yLmRhdGE7XG5cbiAgICAvLyBNdWx0aXBseSBldmVyeSBlbGVtZW50IGJ5IDI1NVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldICo9IHNjYWxhcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRlbnNvcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0S2V5c0FuZFZhbHVlcyhvcmlnaW5hbE9iamVjdCkge1xuICAgIGZvciAoa2V5IGluIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGxvZyhgW2dldEtleXNBbmRWYWx1ZXNdIG9iamVjdFske2tleX1dOiAke29yaWdpbmFsT2JqZWN0W2tleV19YCk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW5hbE9iamVjdFtrZXldO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpZldoaXRlQmFja2dyb3VuZChpbWdBcnIsIHRocmVzaG9sZCA9IDAuMykge1xuICAgIC8vIEFzc3VtaW5nICdpbWdBcnInIGlzIGEgSmF2YVNjcmlwdCBhcnJheSBvciB0eXBlZCBhcnJheSByZXByZXNlbnRpbmcgaW1hZ2UgZGF0YVxuICAgIC8vIGNvbnN0IGJhY2tncm91bmRWYWx1ZSA9IDI1NTsgLy8gVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgY29uc3QgYmFja2dyb3VuZFZhbHVlID0gMTsgLy8gVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXG5cbiAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBiYWNrZ3JvdW5kIHZhbHVlXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvLyBBc3N1bWluZyAndGVuc29yJyBpcyB5b3VyIE9OTlggUnVudGltZSBXZWIgdGVuc29yXG4gICAgY29uc3QgZGF0YSA9IGltZ0Fyci5kYXRhO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGJyZWFrO1xuICAgICAgICBpZiAoZGF0YVtpXSA9PSBiYWNrZ3JvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGxvZyhgZGF0YSAke2l9IGlzICR7ZGF0YVtpXX1gKTtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQgKyAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiBiYWNrZ3JvdW5kIHBpeGVsc1xuICAgIC8vIGNvbnN0IHBlcmNlbnQgPSBjb3VudCAvIGltZ0Fyci5sZW5ndGg7XG4gICAgdmFyIHBlcmNlbnQgPSBjb3VudCAvIDc4NDtcblxuICAgIGxvZyhgW2lmV2hpdGVCYWNrZ3JvdW5kXSBwZXJjZW50IHdoaXRlbmVzc3MgaXMgJHtwZXJjZW50fTsgY291bnQgaXMgJHtjb3VudH07ICR7aW1nQXJyLmRpbXN9YClcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwZXJjZW50YWdlIGV4Y2VlZHMgdGhlIHRocmVzaG9sZFxuICAgIGlmIChwZXJjZW50ID49IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpbnZlcnRJbWFnZShpbWdBcnIpIHtcbiAgICBjb25zdCBkYXRhID0gaW1nQXJyLmRhdGE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IDEgLSBkYXRhW2ldO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1nQXJyO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZURhdGFGcm9tVGVuc29yKGltYWdlVGVuc29yLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gQ29udmVydCB0aGUgdGVuc29yIGRhdGEgdG8gYSByZWd1bGFyIGFycmF5IChBc3N1bWluZyBpdCdzIGEgRmxvYXQzMkFycmF5IG9yIHNpbWlsYXIpXG4gICAgdGVuc29yRGF0YSA9IEFycmF5LmZyb20oaW1hZ2VUZW5zb3IuZGF0YSk7XG4gICAgdGVuc29yRGF0YSA9IHRlbnNvckRhdGEubWFwKHZhbHVlID0+IHZhbHVlICogMjU1KTtcblxuICAgIGxvZyhgW2dldEltYWdlRGF0YUZyb21UZW5zb3JdIHRlbnNvckRhdGEubGVuZ3RoOiAke3RlbnNvckRhdGEubGVuZ3RofWApXG5cbiAgICBjb25zdCBncmF5c2NhbGVEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRlbnNvckRhdGEpO1xuXG4gICAgY29uc3QgcmdiYURhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTsgLy8gUkdCQSBwaXhlbCBkYXRhXG5cbiAgICAvLyBQb3B1bGF0ZSB0aGUgUkdCQSBwaXhlbCBkYXRhIHdpdGggdGhlIGdyYXlzY2FsZSB2YWx1ZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoICogaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgY29uc3QgZ3JheXNjYWxlVmFsdWUgPSBncmF5c2NhbGVEYXRhW2ldO1xuXG4gICAgICAgIC8vIFNldCB0aGUgc2FtZSBncmF5c2NhbGUgdmFsdWUgZm9yIFJHQkEgY2hhbm5lbHMgKFIsIEcsIEIsIEEpXG4gICAgICAgIGNvbnN0IHBpeGVsSW5kZXggPSBpICogNDtcbiAgICAgICAgcmdiYURhdGFbcGl4ZWxJbmRleF0gPSBncmF5c2NhbGVWYWx1ZTsgLy8gUmVkIGNoYW5uZWxcbiAgICAgICAgcmdiYURhdGFbcGl4ZWxJbmRleCArIDFdID0gZ3JheXNjYWxlVmFsdWU7IC8vIEdyZWVuIGNoYW5uZWxcbiAgICAgICAgcmdiYURhdGFbcGl4ZWxJbmRleCArIDJdID0gZ3JheXNjYWxlVmFsdWU7IC8vIEJsdWUgY2hhbm5lbFxuICAgICAgICByZ2JhRGF0YVtwaXhlbEluZGV4ICsgM10gPSAyNTU7IC8vIEFscGhhIGNoYW5uZWwgKGZ1bGx5IG9wYXF1ZSlcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gSW1hZ2VEYXRhIG9iamVjdCBmcm9tIHRoZSBSR0JBIHBpeGVsIGRhdGFcbiAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKHJnYmFEYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxvZyhgW2dldEltYWdlRGF0YUZyb21UZW5zb3JdIGltYWdlRGF0YTogJHtpbWFnZURhdGF9IyMjYClcblxuICAgIC8vIFVzZSBpbWFnZURhdGEgd2l0aCBhIGNhbnZhcywgcHV0SW1hZ2VEYXRhKCksIG9yIG90aGVyIGNhbnZhcyBvcGVyYXRpb25zXG4gICAgcmV0dXJuIGltYWdlRGF0YTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaHRtbERpc3BsYXlJbWFnZShpbWFnZVRlbnNvciwgZWxlbWVudElELCB3aWR0aD0yOCwgaGVpZ2h0PTI4KSB7XG4gICAgLy8gd2lkdGggPSBpbWFnZVRlbnNvci5kaW1zWzJdO1xuICAgIC8vIGhlaWdodCA9IGltYWdlVGVuc29yLmRpbXNbM107XG5cbiAgICBsb2coYFtodG1sRGlzcGxheUltYWdlXSBpbWFnZVRlbnNvcjogJHt3aWR0aH0sICR7aGVpZ2h0fSMjI2ApO1xuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gYXdhaXQgZ2V0SW1hZ2VEYXRhRnJvbVRlbnNvcihpbWFnZVRlbnNvciwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAvLyBDcmVhdGUgYSBjYW52YXMgYW5kIGRyYXcgdGhlIGltYWdlIGRhdGEgb250byBpdFxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gICAgLy8gQ29udmVydCB0aGUgY2FudmFzIGNvbnRlbnQgdG8gYSBkYXRhIFVSTFxuICAgIGNvbnN0IGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTsgLy8gQ2hhbmdlICdpbWFnZS9wbmcnIHRvIHRoZSBkZXNpcmVkIGltYWdlIGZvcm1hdFxuXG4gICAgY29uc3QgaW1nRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJRCk7XG4gICAgaW1nRWxlbWVudC5zcmMgPSBkYXRhVVJMO1xufVxuXG4vKlxuKiBpbnZlcnQgYSB3aGl0ZSBiYWNrZ3JvdW5kIHRvIGJsYWNrIG9yIHJlbWFpbiBzbyBpZiBibGFja1xuKi9cbmFzeW5jIGZ1bmN0aW9uIGludmVydFdoaXRlQmFja2dyb3VuZChpbWdBcnIpIHtcblxuXG4gICAgaXNXaGl0ZSA9IGF3YWl0IGlmV2hpdGVCYWNrZ3JvdW5kKGltZ0Fycik7XG4gICAgLy8gaXNXaGl0ZSA9IHRydWU7XG4gICAgaWYgKGlzV2hpdGUgPT0gdHJ1ZSkge1xuICAgICAgICAvLyBpbnZlcnQgaW1hZ2VcbiAgICAgICAgbG9nKGBbaW52ZXJ0V2hpdGVCYWNrZ3JvdW5kXSB5YWF5ISBpbWFnZSBpcyB3aGl0ZSBiYWNrZ3JvdW5kOyBnb3R0YSBpbnZlcnQhYCk7XG4gICAgICAgIGltZ0FyciA9IGF3YWl0IGludmVydEltYWdlKGltZ0Fycik7XG4gICAgICAgIGxvZyhgW2ludmVydFdoaXRlQmFja2dyb3VuZF0geWFheSEgaW1hZ2UncyB3aGl0ZSBiYWNrZ3JvdW5kIGludmVydGVkIHN1Y2Nlc3NmdWxseSFgKTtcbiAgICAgICAgcmV0dXJuIGltZ0FycjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2coYFtpbnZlcnRXaGl0ZUJhY2tncm91bmRdIG5vbyEgaW1nIGlzIE5PVCB3aGl0ZSBiYWNrZ3JvdW5kYCk7XG4gICAgICAgIHJldHVybiBpbWdBcnI7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpbWFnZVByZXByb2Nlc3NpbmcoaW1nQXJyKSB7XG5cbiAgICAvLyAxLCAxLCAyOCwgMjhcbiAgICBpbWdBcnIgPSBhd2FpdCBvcnQuVGVuc29yLmZyb21JbWFnZShpbWdBcnIsIG9wdGlvbnMgPSB7cmVzaXplZFdpZHRoOiBNT0RFTF9XSURUSCwgcmVzaXplZEhlaWdodDogTU9ERUxfSEVJR0hUfSk7XG5cbiAgICAvLyBhYmMgPSBhd2FpdCBpZldoaXRlQmFja2dyb3VuZChpbWdBcnIpO1xuXG4gICAgaW1nQXJyID0gYXdhaXQgcmVzaXplVGVuc29yKGltZ0Fycik7XG5cbiAgICAvLyBmaW5kX3doaXRlX2JhY2tncm91bmRcbiAgICBpbWdBcnIgPSBhd2FpdCBpbnZlcnRXaGl0ZUJhY2tncm91bmQoaW1nQXJyKTtcbiAgICAvLyBiaXR3aXNlX25vdFxuICAgIC8vIGF3YWl0IGh0bWxEaXNwbGF5SW1hZ2UoaW1nQXJyLCAnZGVidWctaW1hZ2UnKTsgLy8gZm9yIERFQlVHR0lOR1xuXG4gICAgcmV0dXJuIGltZ0FycjsgXG5cbn1cblxuLyoqXG4gKiBoYW5kbGVyIGNhbGxlZCB3aGVuIGltYWdlIGF2YWlsYWJsZVxuICogcnVuIHRoZSBtb2RlbCAoZW5jb2Rlcikgb24gdGhlIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1vZGVsRm9yd2FyZChpbWcpIHtcbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZywgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZywgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcblxuICAgIGNvbnN0IHByZWRpY3Rpb25fZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdGlvbi1lbGVtZW50XCIpO1xuICAgIHByZWRpY3Rpb25fZWxlbWVudC5pbm5lckhUTUwgPSBcIj9cIjtcbiAgICBcbiAgICBmaWxlaW4uZGlzYWJsZWQgPSB0cnVlO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIC8vIGRlY29kZXJfbGF0ZW5jeS5pbm5lclRleHQgPSBcIlwiO1xuICAgIGNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcIndhaXRcIjtcbiAgICBpbWFnZV9lbWJlZGRpbmdzID0gdW5kZWZpbmVkO1xuICAgIHZhciB3aWR0aCA9IGltZy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuICAgIGlmICh3aWR0aCA+IGhlaWdodCkge1xuICAgICAgICBpZiAod2lkdGggPiBNQVhfV0lEVEgpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAqIChNQVhfV0lEVEggLyB3aWR0aCk7XG4gICAgICAgICAgICB3aWR0aCA9IE1BWF9XSURUSDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoZWlnaHQgPiBNQVhfSEVJR0hUKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoICogKE1BWF9IRUlHSFQgLyBoZWlnaHQpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTUFYX0hFSUdIVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcblxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgbG9nKGBbbW9kZWxGb3J3YXJkXSBpbWcuaGVpZ2h0OiAke2ltZy5oZWlnaHR9IyMjIGltZy53aWR0aDogJHtpbWcud2lkdGh9YClcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpbWFnZUltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBsb2coYFttb2RlbEZvcndhcmRdIGJlZm9yZSBhd2FpdCBpbWFnZVByZXByb2Nlc3NpbmcuLi5gKTtcbiAgICBjb25zdCBpbWdUZW5zb3IgPSBhd2FpdCBpbWFnZVByZXByb2Nlc3NpbmcoaW1hZ2VJbWFnZURhdGEpO1xuICAgIGxvZyhgW21vZGVsRm9yd2FyZF0gYWZ0ZXIgYXdhaXQgaW1hZ2VQcmVwcm9jZXNzaW5nLi4uYCk7XG5cbiAgICAvLyBhd2FpdCBodG1sRGlzcGxheUltYWdlKGltZ1RlbnNvciwgJ2RlYnVnLWltYWdlJyk7IC8vIGZvciBERUJVR0dJTkdcblxuICAgIGxvZyhgW21vZGVsRm9yd2FyZF0gIyMjaW1nVGVuc29yLmRpbXMgaXMgdGhpczogJHtpbWdUZW5zb3IuZGltc30jIyNgKTtcbiAgICBsb2coYFttb2RlbEZvcndhcmRdICMjI2ltZ1RlbnNvciBzYW1wbGUgaXMgdGhpczogJHtpbWdUZW5zb3IuZGF0YS5zbGljZSgxMTAsIDExOSl9IyMjYCk7XG4gICAgXG4gICAgY29uc3QgZmVlZCA9IHsgXCJpbnB1dC4xXCI6IGltZ1RlbnNvciB9O1xuICAgIGNvbnN0IHMgPSBhd2FpdCBzZXNzWzBdO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsb2coXCJbbW9kZWxGb3J3YXJkXSBzOlwiLCBzKVxuICAgIGxvZyhgW21vZGVsRm9yd2FyZF0gZm9yd2FyZCBwYXNzaW5nIGltYWdlIHRocm91Z2ggdGhlIG1vZGVsYCk7XG4gICAgaW1hZ2VfZW1iZWRkaW5ncyA9IGF3YWl0IHMucnVuKGZlZWQpOyAvLyBNT0RFTC5GT1JXQVJEXG4gICAgbG9nKGBbbW9kZWxGb3J3YXJkXSBmb3J3YXJkIHBhc3NpbmcgY29tcGxldGVkIWApO1xuXG4gICAgY29uc3QgZW1iX3Byb3BlcnR5ID0gYXdhaXQgZ2V0S2V5c0FuZFZhbHVlcyhpbWFnZV9lbWJlZGRpbmdzKTtcbiAgICBwcm9icyA9IGVtYl9wcm9wZXJ0eVsnY3B1RGF0YSddO1xuICAgIG1heF9wcm9iID0gTWF0aC5tYXgoLi4ucHJvYnMpO1xuICAgIG1heEluZCA9IHByb2JzLmluZGV4T2YobWF4X3Byb2IpO1xuXG4gICAgcHJvYnNBcnJheSA9IEFycmF5LmZyb20ocHJvYnMpXG4gICAgZXhwUHJvYk51bXMgPSBwcm9ic0FycmF5Lm1hcChmdW5jdGlvbihlYWNoX2VsZW1lbnQpe1xuICAgICAgICByZXR1cm4gTnVtYmVyKE1hdGguZXhwKGVhY2hfZWxlbWVudCkpO1xuICAgIH0pO1xuICAgIHRvdGFsUHJvYk51bXMgPSBleHBQcm9iTnVtcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICBleHBQcm9iUHJvYnMgPSBleHBQcm9iTnVtcy5tYXAoZnVuY3Rpb24oZWFjaF9lbGVtZW50KXtcbiAgICAgICAgcmV0dXJuIE51bWJlcigoKGVhY2hfZWxlbWVudC90b3RhbFByb2JOdW1zKSoxMDApLnRvRml4ZWQoMikpO1xuICAgIH0pO1xuICAgIHByZWRpY3Rpb25fZWxlbWVudC5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cInRvb2x0aXBfY3VzdG9tXCI+JHttYXhJbmR9PHNwYW4gY2xhc3M9XCJ0b29sdGlwdGV4dF9jdXN0b21cIj5Qcm9iYWJpbGl0aWVzOiAke2V4cFByb2JQcm9icy5qb2luKFwiJSwgXCIpfSU8L3NwYW4+PC9kaXY+YDtcbiAgICBsb2coYFttb2RlbEZvcndhcmRdIENsYXNzOiAke21heEluZH0gfCAgUHJvYmFiaWxpdGllczogJHtleHBQcm9iUHJvYnMuam9pbihcIiUsIFwiKX1gKTtcblxuICAgIGZpbGVpbi5kaXNhYmxlZCA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogZmV0Y2ggYW5kIGNhY2hlIHVybFxuVXNlcyBmdW5jdGlvbnM6XG4xLiBsb2dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRDYWNoZSh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKFwib25ueFwiKTtcblxuICAgICAgICBpZiAoY29uZmlnLmNsZWFyX2NhY2hlKSB7Y2FjaGUuZGVsZXRlKHVybCk7fVxuXG4gICAgICAgIGxldCBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhY2hlLm1hdGNoKHVybCk7XG4gICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLmFkZCh1cmwpO1xuICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaCh1cmwpO1xuICAgICAgICAgICAgbG9nKGBbZmV0Y2hBbmRDYWNoZV0gJHt1cmx9IGxvYWRlZCAoZnJvbSBuZXR3b3JrKWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nKGBbZmV0Y2hBbmRDYWNoZV0gJHt1cmx9IGxvYWRlZCAoZnJvbSBjYWNoZSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2FjaGVkUmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nKGBbZmV0Y2hBbmRDYWNoZV0gJHt1cmx9IChmcm9tIG5ldHdvcmspYCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwpLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgfVxufVxuXG4vKlxuICogbG9hZCBlbmNvZGVyIGFuZCBkZWNvZGVyIHNlcXVlbnRpYWxseVxuVXNlcyBmdW5jdGlvbnM6XG4xLiBmZXRjaEFuZENhY2hlXG4yLiBtb2RlbEZvcndhcmQgKG1vZGVsIGZvcndhcmQpXG4zLiBsb2dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZF9tb2RlbChtb2RlbCwgaW1nKSB7XG4gICAgaWR4PTA7XG4gICAgbG9nKGBbbG9hZF9tb2RlbF0gaWR4OiAke2lkeH1gKTtcblxuICAgIC8vIC0tLSBzZWxlY3QgZGV2aWNlIHdlYm5uIG9yIHdlYmdwdVxuICAgIGxldCBwcm92aWRlciA9IGNvbmZpZy5wcm92aWRlcjtcbiAgICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgICAgIGNhc2UgXCJ3ZWJublwiOlxuICAgICAgICAgICAgaWYgKCEoXCJtbFwiIGluIG5hdmlnYXRvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJubiBpcyBOT1Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdmlkZXIgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJ3ZWJublwiLFxuICAgICAgICAgICAgICAgIGRldmljZVR5cGU6IGNvbmZpZy5kZXZpY2UsXG4gICAgICAgICAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiAnZGVmYXVsdCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2coJ1tsb2FkX21vZGVsXSB3ZWJubiBhY3RpdmF0ZWQhJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndlYmdwdVwiOlxuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IuZ3B1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2ViZ3B1IGlzIE5PVCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2coJ1tsb2FkX21vZGVsXSB3ZWJncHUgYWN0aXZhdGVkIScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG9wdCA9IHsgZXhlY3V0aW9uUHJvdmlkZXJzOiBbcHJvdmlkZXJdIH07XG4gICAgLy8gLS0tIHNlbGVjdCBkZXZpY2Ugd2Vibm4gb3Igd2ViZ3B1XG5cbiAgICBmZXRjaEFuZENhY2hlKG1vZGVsW2lkeF0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgc2Vzc1tpZHhdID0gb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKGRhdGEsIG9wdCk7IC8vIGRhdGEgYW5kIGRldmljZVxuXG4gICAgICAgIC8vIC0tIHVzZWxlc3MgZ2FyYmFnZVxuICAgICAgICBzZXNzW2lkeF0udGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsb2coYFtsb2FkX21vZGVsXSBbZmV0Y2hBbmRDYWNoZS50aGVuXSAke21vZGVsW2lkeF19IHN1Y2Nlc3NmdWxseSBsb2FkZWQhYCk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBsb2coYFtsb2FkX21vZGVsXSBbZmV0Y2hBbmRDYWNoZS50aGVuXSAke21vZGVsW2lkeF19IGxvYWQgZmFpbGVkIHdpdGggJHtlfS5gKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9nKFwiW2xvYWRfbW9kZWxdIFtmZXRjaEFuZENhY2hlLnRoZW5dIGltZyBpcyBkZWZpbmVkIVwiKTtcbiAgICAgICAgICAgIC8vIG1vZGVsRm9yd2FyZChpbWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge2xvZyhcIltsb2FkX21vZGVsXSBbZmV0Y2hBbmRDYWNoZS50aGVuXSBpbWcgaXMgdW5kZWZpbmVkIVwiKX1cbiAgICB9KVxufVxuXG5cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnNob3VsZENhbU9uID0gZmFsc2U7XG52YXIgY2FwdHVyZUludGVydmFsO1xuXG5mdW5jdGlvbiBjYXB0dXJlQ2FtZXJhSW1hZ2UoKSB7XG4gIHZhciB2aWRlbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG5cbiAgdmFyIGltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcmlnaW5hbC1pbWFnZScpO1xuXG4gIC8vIENhcHR1cmUgYW4gaW1hZ2UgZnJvbSB0aGUgdmlkZW8gc3RyZWFtXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAvLyBTZXQgdGhlIGNhcHR1cmVkIGltYWdlIGFzIHRoZSBzcmMgb2YgdGhlIGltZyBlbGVtZW50XG4gIGltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbi8vICAgaW1nLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZVwiO1xuICBjb25zb2xlLmxvZyhgW2NhcHR1cmVDYW1lcmFJbWFnZV0gaW1nLnNyYyByZXdyaXR0ZW4hYCk7XG5cbiAgbW9kZWxGb3J3YXJkKGltZyk7XG4gIGNvbnNvbGUubG9nKGBbY2FwdHVyZUNhbWVyYUltYWdlXSBtb2RlbCBmb3J3YXJkIGRvbmUhYCk7XG59XG5cbmZ1bmN0aW9uIHN3aXRjaENhbWVyYSgpIHtcbiAgc2hvdWxkQ2FtT24gPSAhc2hvdWxkQ2FtT247XG5cbiAgaWYgKHNob3VsZENhbU9uPT10cnVlKSB7XG4gICAgb25DYW1lcmEoKTtcbiAgfSBlbHNlIHtcbiAgICBvZmZDYW1lcmEoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZDYW1lcmEoKSB7XG4gIGNvbnNvbGUubG9nKGBbb2ZmQ2FtZXJhXSBidXR0b24gcHJlc3NlZC4uLiBzaG91bGRDYW1PbjogJHtzaG91bGRDYW1Pbn1gKTtcblxuICB2YXIgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpZGVvLWVsZW1lbnQnKTtcblxuICB2YXIgc3RyZWFtID0gdmlkZW9FbGVtZW50LnNyY09iamVjdDtcbiAgICB2YXIgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICB9KTtcblxuICAgIHZpZGVvRWxlbWVudC5yZW1vdmUoKTtcbiAgY29uc29sZS5sb2coYFtvZmZDYW1lcmFdIGNhbWVyYV9kaXYgcmVtb3ZlZC4uLmApO1xuXG4gIHZhciBvcmlnaW5hbEltYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yaWdpbmFsLWltYWdlJyk7XG4gIG9yaWdpbmFsSW1hZ2Uuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XG4gIGNvbnNvbGUubG9nKGBbb2ZmQ2FtZXJhXSBvcmlnaW5hbEltYWdlIHJlY292ZXJlZC4uLmApO1xuXG4gIGxldCBpbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9yaWdpbmFsLWltYWdlXCIpO1xuICBtb2RlbEZvcndhcmQoaW1nKTtcbiAgY29uc29sZS5sb2coYFtvZmZDYW1lcmFdIG9yaWdpbmFsSW1hZ2UgcHJlZGljdGlvbiBjb21wbGV0ZS4uLmApO1xuXG4gIGlmIChjYXB0dXJlSW50ZXJ2YWwpIHtcbiAgICBjbGVhckludGVydmFsKGNhcHR1cmVJbnRlcnZhbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25DYW1lcmEoKSB7XG4gIGNvbnNvbGUubG9nKGBbb25DYW1lcmFdIGJ1dHRvbiBwcmVzc2VkLi4uIHNob3VsZENhbU9uOiAke3Nob3VsZENhbU9ufWApO1xuICAvLyBHZXQgdGhlIGRpdiBlbGVtZW50XG4gIHZhciBkaXZFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbWVyYV9kaXYnKTtcbiAgXG4gIHZhciBvcmlnaW5hbEltYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yaWdpbmFsLWltYWdlJyk7XG4gIG9yaWdpbmFsSW1hZ2Uuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gIC8vIENoZWNrIGlmIGdldFVzZXJNZWRpYSBpcyBhdmFpbGFibGVcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgIC8vIFJlcXVlc3QgYWNjZXNzIHRvIHRoZSBjYW1lcmFcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IHRydWUgfSlcbiAgICAgICAgICAudGhlbihmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdmlkZW8gZWxlbWVudFxuICAgICAgICAgICAgICB2YXIgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LmlkID0gXCJ2aWRlby1lbGVtZW50XCI7XG4gICAgICAgICAgICAgIC8vIFNldCB0aGUgc291cmNlIG9mIHRoZSB2aWRlbyBlbGVtZW50IHRvIHRoZSBjYW1lcmEgc3RyZWFtXG4gICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICAgIC8vIEF1dG9wbGF5IHRoZSB2aWRlb1xuICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBTZXQgdGhlIHdpZHRoIG9mIHRoZSB2aWRlbyB0byBtYXRjaCB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSB2aWRlbyBlbGVtZW50IHRvIHRoZSBkaXZcbiAgICAgICAgICAgICAgZGl2RWxlbWVudC5hcHBlbmRDaGlsZCh2aWRlb0VsZW1lbnQpO1xuXG4gICAgICAgICAgICAgIGNhcHR1cmVJbnRlcnZhbCA9IHNldEludGVydmFsKGNhcHR1cmVDYW1lcmFJbWFnZSwgMzAwMCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIHRoZSBjYW1lcmE6JywgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignZ2V0VXNlck1lZGlhIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyJyk7XG4gIH1cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxudXNlcyB0aGUgZnVuY3Rpb25zOlxuMS4gbG9hZF9tb2RlbFxuMi4gbW9kZWxGb3J3YXJkIChlbmNvZGVyKVxuMy4gaGFuZGxlQ2xpY2sgKGRlY29kZXIpXG40LiBsb2dcbiovXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuXG4gICAgY29uc3QgbW9kZWwgPSBNT0RFTF9NQVBbY29uZmlnLm1vZGVsXTsgLy8gbG9hZCB0aGUgbW9kZWxcblxuICAgIGxvZyhgW21haW5dIGNvbmZpZy5tb2RlbDogJHtjb25maWcubW9kZWx9YCk7XG5cbiAgICBmaWxlaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGUtaW5cIik7XG5cbiAgICBsZXQgaW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcmlnaW5hbC1pbWFnZVwiKTsgLy8gZWd5cHRpYW4tY2F0XG5cbiAgICBsb2coXCJbbWFpbl0gQkVGT1JFIG1vZGVsIGxvYWRpbmcuLi5cIilcbiAgICBsb2FkX21vZGVsKG1vZGVsLCBpbWcpLnRoZW4oKCkgPT4ge30sIChlKSA9PiB7bG9nKGUpO30pOyAvLyBbRVhUX0ZVTkNdIGxvYWRfbW9kZWxcbiAgICBsb2coXCJbbWFpbl0gbW9kZWwgbG9hZGVkOyBzZXNzOlwiLCBzZXNzKVxuXG4gICAgbG9nKFwiW21haW5dIFtzcGVjaWFsXSBiZWZvcmUgbG9uZSBtb2RlbEZvcndhcmQuLi5cIilcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMjAwMCkpO1xuICAgIG1vZGVsRm9yd2FyZChpbWcpO1xuICAgIGxvZyhcIlttYWluXSBbc3BlY2lhbF0gYWZ0ZXIgbG9uZSBtb2RlbEZvcndhcmQuLi5cIilcblxuICAgIC8vIC0tLSBbMl0gaW1hZ2UgdXBsb2FkXG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nKGBbbWFpbl0gW2ltZy5vbmxvYWRdIGJlZm9yZSBtb2RlbCBmb3J3YXJkaW5nIGltYWdlLi4uYCk7XG4gICAgICAgIG1vZGVsRm9yd2FyZChpbWcpO1xuICAgICAgICBsb2coYFttYWluXSBbaW1nLm9ubG9hZF0gYWZ0ZXIgbW9kZWwgZm9yd2FyZGluZyBpbWFnZS4uLmApO1xuICAgIH1cblxuICAgIGZpbGVpbi5vbmNoYW5nZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgbG9nKGBbbWFpbl0gW2ZpbGVpbi5vbmNoYW5nZV0gYmVnaW5uaW5nIG9mIGZpbGVpbi5vbmNoYW5nZSAuLi5gKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2dC50YXJnZXQgfHwgd2luZG93LmV2ZW50LnNyYztcbiAgICAgICAgbGV0IGZpbGVzID0gdGFyZ2V0LmZpbGVzO1xuICAgICAgICBpZiAoRmlsZVJlYWRlciAmJiBmaWxlcyAmJiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZyhgW21haW5dIFtmaWxlaW4ub25jaGFuZ2VdIFtpZiAoRmlsZVJlYWRlciAmJl0gYmVmb3JlIG5ldyBmaWxlcmVhZGVyYCk7XG4gICAgICAgICAgICBsZXQgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICBsb2coYFttYWluXSBbZmlsZWluLm9uY2hhbmdlXSBbaWYgKEZpbGVSZWFkZXIgJiZdIGFmdGVyIG5ldyBmaWxlcmVhZGVyYCk7XG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2coYFttYWluXSBbZmlsZWluLm9uY2hhbmdlXSBbaWYgKEZpbGVSZWFkZXIgJiZdIFtmaWxlUmVhZGVyLm9ubG9hZF0gYmVmb3JlIGltZy5zcmMgPSBmaWxlUmVhZGVyLnJlc3VsdGApO1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBsb2coYFttYWluXSBbZmlsZWluLm9uY2hhbmdlXSBbaWYgKEZpbGVSZWFkZXIgJiZdIFtmaWxlUmVhZGVyLm9ubG9hZF0gYWZ0ZXIgaW1nLnNyYyA9IGZpbGVSZWFkZXIucmVzdWx0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZXNbMF0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIC0tLSB1c2VfY2FtZXJhXG4gICAgY2FtZXJhRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidXNlX2NhbWVyYVwiKTtcbiAgICBjYW1lcmFFbGVtZW50Lm9uY2hhbmdlID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBzd2l0Y2hDYW1lcmEoKTtcbiAgICB9XG5cbn1cblxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7IG1haW4oKTsgfSk7XG4iXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiYSIsImkiLCJzZWxmIiwiV3IiLCJCdCIsImZ0IiwiTnIiLCJIYSIsInFhIiwiT24iLCJJZSIsIlhhIiwiSmEiLCJUbiIsIlphIiwiZW8iLCJ0byIsInJvIiwibHIiLCJHciIsImFvIiwib28iLCJzbyIsInVvIiwiRmUiLCJVZSIsIkxyIiwicG8iLCJIciIsImdvIiwiX24iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtsIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiQmwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiTWwiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIkwiLCJlIiwidCIsIkx0Iiwia3QiLCJyIiwiZ2V0IiwiZW51bWVyYWJsZSIsInZ0IiwibiIsImNhbGwiLCJEbCIsInZhbHVlIiwiVnIiLCJNYXAiLCJpbml0IiwiY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIiLCJUeXBlRXJyb3IiLCJzZXQiLCJiYWNrZW5kIiwicHJpb3JpdHkiLCJFcnJvciIsImluZGV4T2YiLCJzcGxpY2UiLCJzIiwibGVuZ3RoIiwicHVzaCIsImFzeW5jIiwiaW5pdGlhbGl6ZWQiLCJhYm9ydGVkIiwiaW5pdFByb21pc2UiLCJ1IiwibmFtZSIsImVyciIsIm1hcCIsImpvaW4iLCJMYSIsImphIiwiS2EiLCJ3YXNtIiwid2ViZ2wiLCJ3ZWJncHUiLCJ2ZXJzaW9ucyIsImNvbW1vbiIsImxvZ0xldmVsIiwiWWEiLCJRYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiZGltcyIsImhlaWdodCIsImdldENvbnRleHQiLCJ0ZW5zb3JMYXlvdXQiLCJvIiwicCIsImZvcm1hdCIsImwiLCJub3JtIiwibWVhbiIsImJpYXMiLCJtIiwieSIsImciLCJ2IiwiJCIsImIiLCJTIiwiSSIsImRhdGEiLCJUIiwiQiIsIlAiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRvRGF0YVVSTCIsImNyZWF0ZUltYWdlRGF0YSIsIkQiLCJubyIsIlVyIiwidGVuc29yRm9ybWF0IiwiRmxvYXQzMkFycmF5IiwiSFRNTEltYWdlRWxlbWVudCIsIkltYWdlRGF0YSIsIkltYWdlQml0bWFwIiwicmVzaXplZEhlaWdodCIsInJlc2l6ZWRXaWR0aCIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsIlByb21pc2UiLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3JjIiwib25sb2FkIiwicHV0SW1hZ2VEYXRhIiwiZG93bmxvYWQiLCJkaXNwb3NlIiwibG9jYXRpb24iLCJ0eXBlIiwidGV4dHVyZSIsImRhdGFUeXBlIiwiZ3B1QnVmZmVyIiwiaW8iLCJVaW50OEFycmF5IiwiSW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQzMkFycmF5IiwiQmlnSW50NjRBcnJheSIsImZyb20iLCJCaWdVaW50NjRBcnJheSIsImxvIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIlJhbmdlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInRoaXMiLCJkYXRhTG9jYXRpb24iLCJjcHVEYXRhIiwiZ3B1VGV4dHVyZURhdGEiLCJkb3dubG9hZGVyIiwiZGlzcG9zZXIiLCJncHVCdWZmZXJEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiQmlnSW50Iiwic2l6ZSIsImZyb21JbWFnZSIsImZyb21UZXh0dXJlIiwiZnJvbUdwdUJ1ZmZlciIsImZyb21QaW5uZWRCdWZmZXIiLCJ0b0ltYWdlRGF0YSIsImVuc3VyZVZhbGlkIiwiZ2V0RGF0YSIsImlzRG93bmxvYWRpbmciLCJyZXNoYXBlIiwiRnIiLCJjbyIsImhhbmRsZXIiLCJydW4iLCJvdXRwdXROYW1lcyIsImlucHV0TmFtZXMiLCJyZWxlYXNlIiwiY3JlYXRlIiwiQXJyYXlCdWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJleGVjdXRpb25Qcm92aWRlcnMiLCJzdGFydFByb2ZpbGluZyIsImVuZFByb2ZpbGluZyIsImZvIiwibW8iLCJobyIsImV2YWxNb2RlbCIsIm9wdGltaXplck1vZGVsIiwiY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlciIsImNoZWNrcG9pbnRTdGF0ZSIsInRyYWluTW9kZWwiLCJ0eXBlTmFycm93aW5nRm9yUnVuU3RlcCIsImNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzIiwicnVuVHJhaW5TdGVwIiwibG9hZFBhcmFtZXRlcnNCdWZmZXIiLCJnZXRDb250aWd1b3VzUGFyYW1ldGVycyIsInlvIiwiUm4iLCJJbmZlcmVuY2VTZXNzaW9uIiwiVGVuc29yIiwiVHJhaW5pbmdTZXNzaW9uIiwiZW52IiwicmVnaXN0ZXJCYWNrZW5kIiwiJHQiLCJQbiIsInJlYWRGaWxlIiwiV2wiLCJrbiIsIkJuIiwiTmwiLCJNbiIsIiRvIiwidm8iLCJEbiIsIndvIiwiY3VycmVudFNjcmlwdCIsIl9fZmlsZW5hbWUiLCJyZWFkeSIsImQiLCJmIiwianNlcEluaXQiLCJ3IiwiQyIsIl8iLCJHIiwiViIsInVlIiwiT2EiLCJQYSIsInJhIiwiUmEiLCJTYSIsIlkiLCJaIiwiSiIsImNlIiwibWUiLCJZZSIsIkUiLCJ0ZSIsIk90IiwicmVzb2x2ZSIsInJlamVjdCIsIkRhIiwiVGEiLCJlcnJvcnMiLCJmbHVzaCIsImFsbCIsImZpbHRlciIsIl9PcnRSdW4iLCJfT3J0UnVuV2l0aEJpbmRpbmciLCJfT3J0QmluZElucHV0IiwianNlcFJlZ2lzdGVyQnVmZmVyIiwicmVnaXN0ZXJCdWZmZXIiLCJqc2VwVW5yZWdpc3RlckJ1ZmZlcnMiLCJ1bnJlZ2lzdGVyQnVmZmVycyIsImpzZXBHZXRCdWZmZXIiLCJnZXRCdWZmZXIiLCJqc2VwQ3JlYXRlRG93bmxvYWRlciIsImNyZWF0ZURvd25sb2FkZXIiLCJhc3NpZ24iLCJ3aW5kb3ciLCJpbXBvcnRTY3JpcHRzIiwicHJvY2VzcyIsIm5vZGUiLCJkaXJuYW1lIiwiX19kaXJuYW1lIiwic3RhcnRzV2l0aCIsIlVSTCIsIm5vcm1hbGl6ZSIsInJlYWRGaWxlU3luYyIsImJ1ZmZlciIsInRoaXNQcm9ncmFtIiwiYXJndiIsInJlcGxhY2UiLCJzbGljZSIsImV4aXRDb2RlIiwiaW5zcGVjdCIsImhyZWYiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInN0YXR1cyIsIm9uZXJyb3IiLCJwcmludCIsImNvbnNvbGUiLCJsb2ciLCJiaW5kIiwicHJpbnRFcnIiLCJlcnJvciIsInF1aXQiLCJ3YXNtQmluYXJ5Iiwibm9FeGl0UnVudGltZSIsIldlYkFzc2VtYmx5IiwicWUiLCJSIiwiSCIsIksiLCJsZSIsIk0iLCJxIiwieGUiLCJvZSIsIlciLCJ3ZSIsIkhFQVA4IiwiSEVBUDE2IiwiSEVBUDMyIiwiSEVBUFU4IiwiSEVBUFUxNiIsIkhFQVBVMzIiLCJIRUFQRjMyIiwiSEVBUEY2NCIsImoiLCJTZSIsIlRlIiwiRWUiLCJwcmVSdW4iLCJzaGlmdCIsInVuc2hpZnQiLCJkZSIsIkNlIiwiZ3QiLCJMZSIsIm9uQWJvcnQiLCJSdW50aW1lRXJyb3IiLCJVIiwicGUiLCJsb2NhdGVGaWxlIiwiTmUiLCJPZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwib2siLCJhcnJheUJ1ZmZlciIsImNhdGNoIiwiSGUiLCJpbnN0YW50aWF0ZSIsIkdlIiwiZXQiLCJtaW4iLCJtYXgiLCJhbHBoYSIsImtlZXBEaW1zIiwibm9vcFdpdGhFbXB0eUF4ZXMiLCJheGVzIiwic3ViYXJyYXkiLCJwZXJtIiwiYXV0b1BhZCIsImRpbGF0aW9ucyIsImdyb3VwIiwia2VybmVsX3NoYXBlIiwicGFkcyIsInN0cmlkZXMiLCJ3SXNDb25zdCIsIm91dHB1dFBhZGRpbmciLCJvdXRwdXRTaGFwZSIsImFjdGl2YXRpb24iLCJSZSIsImtlcm5lbFNoYXBlIiwiZmUiLCJhdXRvX3BhZCIsImNlaWxfbW9kZSIsImNvdW50X2luY2x1ZGVfcGFkIiwic3RvcmFnZV9vcmRlciIsImJldGEiLCJ0cmFuc0EiLCJ0cmFuc0IiLCJzZWxlY3RMYXN0SW5kZXgiLCJheGlzIiwibnVtT3V0cHV0cyIsInNwbGl0U2l6ZXMiLCJhbnRpYWxpYXMiLCJjb29yZGluYXRlVHJhbnNmb3JtTW9kZSIsImN1YmljQ29lZmZBIiwiZXhjbHVkZU91dHNpZGUiLCJleHRyYXBvbGF0aW9uVmFsdWUiLCJrZWVwQXNwZWN0UmF0aW9Qb2xpY3kiLCJtb2RlIiwibmVhcmVzdE1vZGUiLCJzdGFydHMiLCJlbmRzIiwiZXBzaWxvbiIsImVxdWF0aW9uIiwid19pc19jb25zdCIsImFjdGl2YXRpb25fcGFyYW1zIiwiS2UiLCJtZXNzYWdlIiwiQXQiLCJFdCIsIk1hIiwiVXQiLCJKZSIsIlRleHREZWNvZGVyIiwicXQiLCJkZWNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ6dCIsImNoYXJDb2RlQXQiLCJLdCIsImx0IiwieHIiLCJkdCIsIld0IiwiR3QiLCJ5dCIsIk50IiwiVnQiLCJZdCIsIlVTRVIiLCJMT0dOQU1FIiwiUEFUSCIsIlBXRCIsIkhPTUUiLCJMQU5HIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2VzIiwiU3IiLCJWZSIsIlh0IiwibmUiLCJ0b1N0cmluZyIsInVyIiwicHQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldERheSIsIkRhdGUiLCJCYSIsIkNhIiwiZ2V0VGltZSIsInNldERhdGUiLCJzZXRNb250aCIsInNldEZ1bGxZZWFyIiwiV2EiLCJWYSIsIkVhIiwiSWEiLCJGYSIsIndhIiwiJGEiLCJVYSIsIlJlZ0V4cCIsInNwbGl0Iiwic3Vic3RyaW5nIiwiTWF0aCIsImZsb29yIiwiYWJzIiwiaW5jbHVkZXMiLCJKdCIsImN0IiwidHQiLCJJciIsIl90IiwiUXQiLCJadCIsIkFyIiwiRXIiLCJQciIsIkZ0IiwiQnJvd3NlciIsIkdhIiwiTmEiLCJyZXN1bWUiLCJPciIsInBhdXNlIiwib3IiLCJUdCIsImVyIiwiZm9yRWFjaCIsIm9uRXhpdCIsIlRyIiwiUnIiLCJ6IiwiQSIsIngiLCJOYU4iLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENEYXkiLCJVVEMiLCJnZXRTZWNvbmRzIiwiZ2V0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJzZXRUaW1lIiwiZ2V0WWVhciIsInRyIiwiY2VpbCIsInRvVGltZVN0cmluZyIsIm1hdGNoIiwiYXBwbHkiLCJoIiwibm93IiwiYyIsInBlcmZvcm1hbmNlIiwiY29weVdpdGhpbiIsImdyb3ciLCJrIiwiRiIsImFyZ3VtZW50cyIsInBvcCIsImlyIiwiRmliZXJzIiwiYWIiLCJDciIsIl9fZXJybm9fbG9jYXRpb24iLCJtYWxsb2MiLCJzdGFja1NhdmUiLCJzdGFja0FsbG9jIiwiYnQiLCJOIiwibW9uaXRvclJ1bkRlcGVuZGVuY2llcyIsImNsZWFySW50ZXJ2YWwiLCJpbnN0YW50aWF0ZVdhc20iLCJpbnN0YW50aWF0ZVN0cmVhbWluZyIsInplIiwiaW5zdGFuY2UiLCJfT3J0SW5pdCIsIk8iLCJfT3J0R2V0TGFzdEVycm9yIiwiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zIiwiUSIsIl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlciIsIl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUiLCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5IiwiX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyIsIl9PcnRDcmVhdGVTZXNzaW9uIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwiX09ydEdldElucHV0T3V0cHV0Q291bnQiLCJYIiwiX09ydEdldElucHV0TmFtZSIsIl9PcnRHZXRPdXRwdXROYW1lIiwiX09ydEZyZWUiLCJfT3J0Q3JlYXRlVGVuc29yIiwiX09ydEdldFRlbnNvckRhdGEiLCJhYSIsIl9PcnRSZWxlYXNlVGVuc29yIiwiYmEiLCJfT3J0Q3JlYXRlUnVuT3B0aW9ucyIsImNhIiwiX09ydEFkZFJ1bkNvbmZpZ0VudHJ5IiwiZGEiLCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnMiLCJlYSIsIl9PcnRDcmVhdGVCaW5kaW5nIiwiZmEiLCJnYSIsIl9PcnRCaW5kT3V0cHV0IiwiaGEiLCJfT3J0Q2xlYXJCb3VuZE91dHB1dHMiLCJpYSIsIl9PcnRSZWxlYXNlQmluZGluZyIsImthIiwibGEiLCJfT3J0RW5kUHJvZmlsaW5nIiwibWEiLCJfSnNlcE91dHB1dCIsIm5hIiwiX0pzZXBHZXROb2RlTmFtZSIsIm9hIiwiUnQiLCJfbWFsbG9jIiwicGEiLCJfZnJlZSIsInNhIiwicnIiLCJ0YSIsIm5yIiwidWEiLCJhciIsInZhIiwieGEiLCJ5YSIsInphIiwiQWEiLCJzciIsImNhbGxlZFJ1biIsIm9uUnVudGltZUluaXRpYWxpemVkIiwicG9zdFJ1biIsInNldFN0YXR1cyIsInNldFRpbWVvdXQiLCJfX19zdGFydF9lbV9qcyIsIl9fX3N0b3BfZW1fanMiLCJzdGFja1Jlc3RvcmUiLCJVVEY4VG9TdHJpbmciLCJzdHJpbmdUb1VURjgiLCJsZW5ndGhCeXRlc1VURjgiLCJwcmVJbml0IiwieG8iLCJTbyIsIkNvIiwiY3B1cyIsIlZsIiwiUm8iLCJHbCIsIlduIiwiTm4iLCJqciIsIlRvIiwiRmwiLCJMbCIsIkhsIiwiUG8iLCJQZSIsIk1lIiwiZHIiLCJBZSIsImtvIiwiamwiLCJxbCIsIktsIiwiWWwiLCJNbyIsIlZuIiwiY3IiLCJwciIsIktyIiwiZnIiLCJZciIsIlVuIiwiWGwiLCJKbCIsInpvIiwiV28iLCJObyIsIlFsIiwiX2UiLCJWbyIsIlhyIiwiWmwiLCJGbyIsIkZuIiwiR24iLCJMbyIsIkxuIiwiaWUiLCJIbiIsIm50IiwiTXQiLCJKciIsIlFyIiwiWnIiLCJqbyIsIkJlIiwicW4iLCJtdCIsIlFlIiwiRHQiLCJTdCIsInFvIiwiam4iLCJLbyIsIktuIiwiWW8iLCJ0ZCIsIlhvIiwicmQiLCJuZCIsIkN0IiwiSm8iLCJRbyIsImFkIiwib2QiLCJpZCIsInNkIiwidWQiLCJsZCIsImRkIiwiY2QiLCJwZCIsImZkIiwiYXQiLCJabyIsImVpIiwidGkiLCJyaSIsIm5pIiwiYWkiLCJvaSIsImlpIiwic2kiLCJ1aSIsIm90IiwibWQiLCJ0biIsIlluIiwiaXQiLCJoZCIsImdkIiwieWQiLCJiZCIsIndkIiwidmQiLCIkZCIsInhkIiwiU2QiLCJDZCIsInN0IiwiZGkiLCJjaSIsInBpIiwiZmkiLCJtaSIsImhpIiwiZ2kiLCJ5aSIsImJpIiwid2kiLCJaZSIsInZpIiwiJGkiLCJ4aSIsIlNpIiwiWG4iLCJJZCIsIkFkIiwiSWkiLCJFZCIsIiRlIiwiRWkiLCJfaSIsIk9pIiwiVGkiLCJSaSIsIlBpIiwia2kiLCJCaSIsIk1pIiwiSm4iLCJfZCIsIkRpIiwiemkiLCJXaSIsIk5pIiwicm4iLCJWaSIsIm5uIiwiVWkiLCJHaSIsIkZpIiwiTGkiLCJIaSIsImppIiwicWkiLCJLaSIsIllpIiwiWGkiLCJKaSIsIlFpIiwiWmkiLCJlcyIsInRzIiwicnMiLCJucyIsIlRkIiwiUmQiLCJhcyIsIlBkIiwia2QiLCJ1dCIsImlzIiwic3MiLCJ1cyIsImxzIiwiZHMiLCJjcyIsInBzIiwiZnMiLCJtcyIsImhzIiwiTWQiLCJEZCIsInpkIiwiV2QiLCJ5cyIsImJzIiwiV2UiLCJhbiIsIm9uIiwidW4iLCJsbiIsImRuIiwiTmQiLCJWZCIsImdyIiwidnMiLCJVZCIsInlyIiwiR2QiLCJjbiIsIkZkIiwiJHMiLCJDcyIsIkxkIiwiSXMiLCJIZCIsImpkIiwicWQiLCJBcyIsIktkIiwiWWQiLCJYZCIsIkpkIiwiT3MiLCJUcyIsIlFkIiwiWmQiLCJlYyIsInRjIiwiUnMiLCJwbiIsImtzIiwibmMiLCJhYyIsIkJzIiwiTXMiLCJvYyIsInpzIiwiaWMiLCJzYyIsIldzIiwidWMiLCJsYyIsIlZzIiwiVXMiLCJkYyIsImNjIiwiRnMiLCJMcyIsInBjIiwiZmMiLCJtYyIsImpzIiwicXMiLCJoYyIsImdjIiwieWMiLCJiYyIsIllzIiwiWHMiLCJ3YyIsInZjIiwiUXMiLCJacyIsIiRjIiwidHUiLCJ4YyIsIlNjIiwiQ2MiLCJJYyIsIkFjIiwiRWMiLCJfYyIsIk9jIiwiVGMiLCJudSIsImF1IiwiZm4iLCJpdSIsInN1IiwidXUiLCJsdSIsImR1IiwiY3UiLCJwdSIsImZ1IiwibXUiLCJodSIsImd1IiwieXUiLCJidSIsInd1IiwiUGMiLCJrYyIsIiR1IiwiQmMiLCJNYyIsIkRjIiwiemMiLCJXYyIsIk5jIiwiVmMiLCJVYyIsIkdjIiwiRmMiLCJMYyIsIkhjIiwiamMiLCJxYyIsIktjIiwiU3UiLCJDdSIsIlljIiwiWGMiLCJBdSIsIkV1IiwiSmMiLCJtbiIsIlFjIiwiT3UiLCJaYyIsImVwIiwiVHUiLCJSdSIsInRwIiwicnAiLCJrdSIsIkJ1IiwibnAiLCJhcCIsIm9wIiwiaXAiLCJzcCIsIkR1IiwienUiLCJOdSIsInVwIiwibHAiLCJkcCIsIlZ1IiwiY3AiLCJwcCIsIkd1IiwiTHUiLCJobiIsImZwIiwibXAiLCJnbiIsIklvIiwiX28iLCJFbyIsInpuIiwiQW8iLCJhZSIsIlFiIiwid2IiLCJ5YiIsImpiIiwieGIiLCJ6YiIsIkFiIiwiZWUiLCJyZSIsImhlIiwiYmUiLCJydCIsInNlIiwieG4iLCJiYiIsIkZiIiwiRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCIsIldvcmtlciIsIndyaXRlU3luYyIsIklOSVRJQUxfTUVNT1JZIiwid2FzbU1lbW9yeSIsIk1lbW9yeSIsImluaXRpYWwiLCJtYXhpbXVtIiwic2hhcmVkIiwianQiLCIkciIsInllIiwidGVybWluYXRlIiwib25tZXNzYWdlIiwiRWIiLCJ0YiIsImNtZCIsInN0YXJ0X3JvdXRpbmUiLCJHYiIsImFyZyIsInJiIiwicHRocmVhZF9wdHIiLCJ1bnJlZiIsInBvc3RNZXNzYWdlIiwiTWIiLCJIYiIsIm1iIiwiZ2IiLCJ2YiIsInViIiwiQmIiLCJyZWNlaXZlT2JqZWN0VHJhbnNmZXIiLCJEYiIsInRocmVhZEluaXRUTFMiLCJsYiIsInNldEV4aXRTdGF0dXMiLCJrYiIsIlNiIiwiQ24iLCJDYiIsInRhcmdldFRocmVhZCIsIk1yIiwiUmIiLCJ0cmFuc2Zlckxpc3QiLCJ0aHJlYWQiLCJsb2FkZWQiLCJhbGVydCIsInRocmVhZElkIiwidGV4dCIsInRhcmdldCIsImFyZ3MiLCJmaWxlbmFtZSIsImxpbmVubyIsImhhbmRsZXJzIiwidXJsT3JCbG9iIiwibWFpblNjcmlwdFVybE9yQmxvYiIsIndhc21Nb2R1bGUiLCJxYiIsIlBUaHJlYWQiLCJmYiIsInBiIiwib2IiLCJuYiIsIk9iIiwiZXN0YWJsaXNoU3RhY2tTcGFjZSIsIkRyIiwiaW52b2tlRW50cnlQb2ludCIsIkluIiwiX3IiLCJBdG9taWNzIiwiTmIiLCJzdG9yZSIsIl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdCIsImNoZWNrTWFpbGJveCIsIlNuIiwiQW4iLCJFbiIsIlB0IiwiS2IiLCJKYiIsImNiIiwiaWIiLCJlYiIsIlRiIiwiSWIiLCJMYiIsInZsIiwiJGwiLCJrciIsInd0IiwiX2EiLCJCciIsIlNsIiwiQ2wiLCJUbCIsIlJsIiwiaGIiLCJzYiIsIkVsIiwiQWwiLCJfbCIsIk9sIiwicmVmIiwidGltZU9yaWdpbiIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJQYiIsIlViIiwieGwiLCJwdGhyZWFkX3NlbGYiLCJQbCIsIl9wdGhyZWFkX3NlbGYiLCJfX2Vtc2NyaXB0ZW5fdGxzX2luaXQiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQiLCJ6ciIsIl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCIsIl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94IiwiZHluQ2FsbF9paSIsInN0YXJ0V29ya2VyIiwia2VlcFJ1bnRpbWVBbGl2ZSIsIkV4aXRTdGF0dXMiLCJPbyIsImdmIiwiVWwiLCJIdCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJ2YWxpZGF0ZSIsImluaXRUaW1lb3V0IiwibnVtVGhyZWFkcyIsInNpbWQiLCJ3YXNtUGF0aHMiLCJlbmRzV2l0aCIsIkJsb2IiLCJjcmVhdGVPYmplY3RVUkwiLCJyYWNlIiwicXIiLCJoYXMiLCJhZGQiLCJlbnRyaWVzIiwiQm8iLCJsb2dTZXZlcml0eUxldmVsIiwiaXNJbnRlZ2VyIiwibG9nVmVyYm9zaXR5TGV2ZWwiLCJ0YWciLCJleHRyYSIsIldlYWtTZXQiLCJEbyIsInNlc3Npb24iLCJ1c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5Iiwic29tZSIsImVuYWJsZU1lbVBhdHRlcm4iLCJkZXZpY2VUeXBlIiwicG93ZXJQcmVmZXJlbmNlIiwicHJlZmVycmVkTGF5b3V0IiwiZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCIsImV4ZWN1dGlvbk1vZGUiLCJsb2dJZCIsIm9wdGltaXplZE1vZGVsRmlsZVBhdGgiLCJlbmFibGVDcHVNZW1BcmVuYSIsImVuYWJsZVByb2ZpbGluZyIsImZyZWVEaW1lbnNpb25PdmVycmlkZXMiLCJEZSIsInh0IiwidG9JU09TdHJpbmciLCJVbyIsIkdvIiwiSG8iLCJkZXZpY2UiLCJjcmVhdGVCdWZmZXIiLCJ1c2FnZSIsIkdQVUJ1ZmZlclVzYWdlIiwiQ09QWV9EU1QiLCJNQVBfUkVBRCIsImdldENvbW1hbmRFbmNvZGVyIiwiZW5kQ29tcHV0ZVBhc3MiLCJjb3B5QnVmZmVyVG9CdWZmZXIiLCJtYXBBc3luYyIsIkdQVU1hcE1vZGUiLCJSRUFEIiwiZ2V0TWFwcGVkUmFuZ2UiLCJkZXN0cm95Iiwic3RvcmFnZUNhY2hlIiwiZnJlZUJ1ZmZlcnMiLCJmcmVlVW5pZm9ybUJ1ZmZlcnMiLCJidWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyIsImJ1ZmZlcnNQZW5kaW5nIiwiZXh0ZXJuYWxCdWZmZXJzIiwidXBsb2FkIiwiYnl0ZU9mZnNldCIsIm9yaWdpbmFsU2l6ZSIsIm1hcHBlZEF0Q3JlYXRpb24iLCJNQVBfV1JJVEUiLCJDT1BZX1NSQyIsInVubWFwIiwiZ3B1RGF0YSIsIm1lbWNweSIsInJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJkZWxldGUiLCJ1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJTVE9SQUdFIiwiVU5JRk9STSIsInJlZnJlc2hQZW5kaW5nQnVmZmVycyIsImtlIiwiY2FjaGVLZXkiLCJfY2FjaGVLZXkiLCJzb3J0IiwiZ2UiLCJjYWxjTWF0TXVsU2hhcGUiLCJjYWxjU2hhcGUiLCJpc1ZhbGlkQnJvYWRjYXN0IiwiZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSIsInNpemVGcm9tRGltZW5zaW9uIiwic2l6ZVRvRGltZW5zaW9uIiwiY29tcHV0ZVN0cmlkZXMiLCJub3JtYWxpemVBeGlzIiwibm9ybWFsaXplQXhlcyIsInNvcnRCYXNlZE9uUGVybSIsInJldmVyc2UiLCJwYWRTaGFwZSIsImFyZUVxdWFsIiwiZXZlcnkiLCJhZGp1c3RQb29sQXR0cmlidXRlcyIsImFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCIsImFkanVzdFBhZEFuZFJldHVyblNoYXBlIiwiY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSIsImNvbXB1dGVTaGFwZUhlbHBlciIsImNvbXB1dGVDb252T3V0cHV0U2hhcGUiLCJnZXRTaGFwZU9mR2VtbVJlc3VsdCIsInZlIiwia2V5cyIsImluZGljZXMiLCJzdG9yYWdlIiwidGVuc29yIiwib2Zmc2V0VG9JbmRpY2VzIiwiaW5kaWNlc1RvT2Zmc2V0IiwiYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQiLCJzZXRCeUluZGljZXMiLCJnZXRCeUluZGljZXMiLCJpbXBsIiwidmFsdWVzIiwiaW5kaWNlc0dldCIsInJhbmsiLCJpbmRpY2VzU2V0Iiwic2V0QnlPZmZzZXQiLCJnZXRCeU9mZnNldCIsInNoYXBlIiwibm9ybWFsaXplZERpc3BhdGNoR3JvdXAiLCJpbmRpY2VzSGVscGVycyIsInVuaWZvcm1zIiwidmFyaWFibGVJbmRleCIsImd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMiLCJtYWluU3RhcnQiLCJkZWNsYXJlVmFyaWFibGUiLCJkZWNsYXJlVmFyaWFibGVzIiwicmVnaXN0ZXJVbmlmb3JtIiwidW5pZm9ybURlY2xhcmF0aW9uIiwiYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucyIsIm1yIiwic2hhZGVyQ2FjaGUiLCJoaW50IiwiaW5wdXREZXBlbmRlbmNpZXMiLCJnZXRSdW5EYXRhIiwib3V0cHV0cyIsImRpc3BhdGNoR3JvdXAiLCJwcm9ncmFtVW5pZm9ybXMiLCJnZXRTaGFkZXJTb3VyY2UiLCJpbnB1dHMiLCJjb21wdXRlIiwibGkiLCJlbiIsInN1bSIsInByb2QiLCJzdW1TcXVhcmUiLCJsb2dTdW1FeHAiLCJsMSIsImwyIiwibG9nU3VtIiwiZ2V0QmlnSW50NjRBcnJheSIsIkNpIiwiQWkiLCJRbiIsImdldEZsb2F0MzJBcnJheSIsIm9zIiwiZ3MiLCJzY2FsYXIiLCJ2ZWN0b3IiLCJ3cyIsInNuIiwiWm4iLCJociIsImFjdGl2YXRpb25GdW5jdGlvbiIsImFwcGx5QWN0aXZhdGlvbiIsImNsaXBNaW4iLCJjbGlwTWF4IiwiYWN0aXZhdGlvbkNhY2hlS2V5IiwiYnIiLCJ4cyIsInRvTG93ZXJDYXNlIiwiU3MiLCJrZXJuZWxDdXN0b21EYXRhIiwid1QiLCJjb25jYXQiLCJFcyIsIl9zIiwiUHMiLCJyZWR1Y2UiLCJmaWxsIiwiRHMiLCJzeW1ib2xUb0luZGljZXMiLCJpbnB1dEluZGV4IiwiYWRkU3ltYm9sIiwiaGFzRWxsaXBzaXMiLCJzeW1ib2xUb0luZm8iLCJsaHMiLCJvdXRwdXREaW1zIiwicHJvY2Vzc1Rlcm0iLCJjb3VudCIsImVsbGlwc2lzRGltcyIsImRpbVZhbHVlIiwicmhzIiwiaW5wdXRJbmRpY2VzIiwiTnMiLCJHcyIsIkhzIiwiS3MiLCJKcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb21wb25lbnRzIiwiZXUiLCJvdXRwdXRDb3VudCIsInJ1Iiwib3UiLCJ2dSIsImNlaWxNb2RlIiwiY291bnRJbmNsdWRlUGFkIiwic3RvcmFnZU9yZGVyIiwieHUiLCJnZXRJbnQzMkFycmF5IiwidmFsaWRhdGVJbnB1dENvbnRlbnQiLCJJdSIsInJvdW5kIiwiTUFYX1ZBTFVFIiwiTUlOX1ZBTFVFIiwiY3VzdG9tRGF0YUJ1ZmZlciIsIl91IiwiUHUiLCJzaWduIiwiTXUiLCJXdSIsIlV1IiwiRnUiLCJIdSIsImp1IiwicmVwbyIsImF0dHJpYnV0ZXNCb3VuZCIsImdldEFydGlmYWN0Iiwic2V0QXJ0aWZhY3QiLCJnZXRDb21wdXRlUGFzc0VuY29kZXIiLCJzZXRQaXBlbGluZSIsImNvbXB1dGVQaXBlbGluZSIsImJpbmRpbmciLCJyZXNvdXJjZSIsImNyZWF0ZUJpbmRHcm91cCIsImxheW91dCIsImdldEJpbmRHcm91cExheW91dCIsImxhYmVsIiwicHJvZ3JhbUluZm8iLCJzZXRCaW5kR3JvdXAiLCJkaXNwYXRjaFdvcmtncm91cHMiLCJwZW5kaW5nRGlzcGF0Y2hOdW1iZXIiLCJpc1F1ZXJ5RW5hYmxlZCIsInF1ZXJ5RGF0YSIsImdwdURhdGFNYW5hZ2VyIiwicXVlcnlTZXRDb3VudCIsIlFVRVJZX1JFU09MVkUiLCJyZXNvbHZlUXVlcnlTZXQiLCJxdWVyeVNldCIsImN1cnJlbnRLZXJuZWxJZCIsImtlcm5lbHMiLCJxdWVyeVRpbWVCYXNlIiwiYnVpbGQiLCJmZWF0dXJlcyIsImNyZWF0ZVNoYWRlck1vZHVsZSIsImNvZGUiLCJjcmVhdGVDb21wdXRlUGlwZWxpbmUiLCJlbnRyeVBvaW50Iiwibm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUiLCJsaW1pdHMiLCJtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbiIsInNxcnQiLCJjYnJ0IiwicXUiLCJjb21tYW5kRW5jb2RlciIsImNvbXB1dGVQYXNzRW5jb2RlciIsInNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nIiwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEiLCJpbml0aWFsaXplIiwiZ3B1IiwicmVxdWVzdEFkYXB0ZXIiLCJyZXF1aXJlZExpbWl0cyIsIm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSIsIm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSIsIm1heEJ1ZmZlclNpemUiLCJtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVkiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVoiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVxdWVzdERldmljZSIsInByb2dyYW1NYW5hZ2VyIiwia2VybmVsUGVyc2lzdGVudERhdGEiLCJkZWJ1ZyIsIm9udW5jYXB0dXJlZGVycm9yIiwiR1BVVmFsaWRhdGlvbkVycm9yIiwiY3JlYXRlQ29tbWFuZEVuY29kZXIiLCJjcmVhdGVRdWVyeVNldCIsInRpbWVzdGFtcFdyaXRlcyIsImJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXgiLCJlbmRPZlBhc3NXcml0ZUluZGV4IiwiYmVnaW5Db21wdXRlUGFzcyIsImVuZCIsInF1ZXVlIiwic3VibWl0IiwiZmluaXNoIiwicHJvZmlsaW5nTW9kZSIsInRlbXBvcmFyeURhdGEiLCJ3cml0ZUJ1ZmZlciIsIm9mZnNldCIsImFsbG9jIiwiZnJlZSIsImNyZWF0ZUtlcm5lbCIsInJlbGVhc2VLZXJuZWwiLCJjb21wdXRlS2VybmVsIiwicHVzaEVycm9yU2NvcGUiLCJwb3BFcnJvclNjb3BlIiwiS3UiLCJocCIsIndyIiwiSnUiLCJncCIsInlwIiwiUXUiLCJ2ciIsIlp1IiwiZWwiLCJ0bCIsIlh1IiwicmwiLCJubCIsImFsIiwiaHQiLCJqZSIsImJuIiwiSXQiLCJ2cCIsInluIiwic2wiLCJ1bCIsImxsIiwiZGwiLCJjbCIsInBsIiwiZmwiLCJtbCIsInduIiwiaGwiLCIkcCIsInZuIiwieHAiLCIkbiIsIll1IiwiY3VzdG9tRGF0YU9mZnNldCIsImN1c3RvbURhdGFTaXplIiwib3BLZXJuZWxDb250ZXh0Iiwib3V0cHV0Iiwib2wiLCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiIsImhhbmRsZSIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9ucyIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQiLCJpbCIsIlV5Iiwid3AiLCJwcm94eSIsIm91dCIsInJldm9rZU9iamVjdFVSTCIsImluIiwibW9kZWwiLCJtb2RlbGRhdGEiLCJvcHRpb25zIiwic2Vzc2lvbklkIiwib3V0cHV0SW5kaWNlcyIsImdsIiwiY3JlYXRlU2Vzc2lvbkFsbG9jYXRlIiwibG9hZE1vZGVsIiwieWwiLCJibCIsIndhc21CYWNrZW5kIiwiU3AiLCJ3bCIsIklwIiwiZGVmYXVsdCIsIkNwIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwidW5kZWZpbmVkIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsIm9ydCIsIk1BWF9XSURUSCIsIk1BWF9IRUlHSFQiLCJNT0RFTF9XSURUSCIsIk1PREVMX0hFSUdIVCIsIk1PREVMX01BUCIsIm1uaXN0X21vZGVsIiwiY29uZmlnIiwicHJvdmlkZXIiLCJ0aHJlYWRzIiwidmFycyIsInNlYXJjaCIsInBhaXIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJzZUludCIsImdldENvbmZpZyIsImZpbGVpbiIsImltYWdlX2VtYmVkZGluZ3MiLCJpbWFnZUltYWdlRGF0YSIsImNhcHR1cmVJbnRlcnZhbCIsInNlc3MiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCIsInRvRml4ZWQiLCJpbWFnZVByZXByb2Nlc3NpbmciLCJpbWdBcnIiLCJvcmlnaW5hbFRlbnNvciIsIm9yaWdpbmFsRGF0YSIsInJlc2hhcGVkVGVuc29yIiwicmVzaXplVGVuc29yIiwiaXNXaGl0ZSIsInRocmVzaG9sZCIsInBlcmNlbnQiLCJpZldoaXRlQmFja2dyb3VuZCIsImludmVydEltYWdlIiwiaW52ZXJ0V2hpdGVCYWNrZ3JvdW5kIiwibW9kZWxGb3J3YXJkIiwiaW1nIiwicHJlZGljdGlvbl9lbGVtZW50IiwiZGlzYWJsZWQiLCJjYW52YXMiLCJzdHlsZSIsImN1cnNvciIsImN0eCIsImltZ1RlbnNvciIsImZlZWQiLCJlbWJfcHJvcGVydHkiLCJvcmlnaW5hbE9iamVjdCIsImtleSIsImdldEtleXNBbmRWYWx1ZXMiLCJwcm9icyIsIm1heF9wcm9iIiwibWF4SW5kIiwicHJvYnNBcnJheSIsImV4cFByb2JOdW1zIiwiZWFjaF9lbGVtZW50IiwiZXhwIiwidG90YWxQcm9iTnVtcyIsImV4cFByb2JQcm9icyIsImNhcHR1cmVDYW1lcmFJbWFnZSIsInZpZGVvIiwicXVlcnlTZWxlY3RvciIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsInNob3VsZENhbU9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImlkeCIsIm9wdCIsInVybCIsImNhY2hlIiwiY2FjaGVzIiwiY2xlYXJfY2FjaGUiLCJjYWNoZWRSZXNwb25zZSIsImZldGNoQW5kQ2FjaGUiLCJsb2FkX21vZGVsIiwib25jaGFuZ2UiLCJldnQiLCJmaWxlcyIsImV2ZW50IiwiRmlsZVJlYWRlciIsImZpbGVSZWFkZXIiLCJyZXN1bHQiLCJyZWFkQXNEYXRhVVJMIiwiY2FtZXJhRWxlbWVudCIsImRpdkVsZW1lbnQiLCJkaXNwbGF5IiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwic3RyZWFtIiwidmlkZW9FbGVtZW50Iiwic3JjT2JqZWN0IiwiYXV0b3BsYXkiLCJhcHBlbmRDaGlsZCIsInNldEludGVydmFsIiwib25DYW1lcmEiLCJnZXRUcmFja3MiLCJ0cmFjayIsInN0b3AiLCJyZW1vdmUiLCJvZmZDYW1lcmEiLCJtYWluIl0sInNvdXJjZVJvb3QiOiIifQ==